  	RASIPADDR   ipaddrDns	    to DWORD
       	RASIPADDR   ipaddrDnsAlt	to DWORD
       	RASIPADDR   ipaddrWins	    to DWORD
       	RASIPADDR   ipaddrWinsAlt	to DWORD

    //
    // RASSUBENTRY Conversion
    //
    Items deleted:
        DWORD       dwSize;     // version is MPR_INTERFACE_DEVICE_0
        DWORD       dwfFlags;   // unused anyway

    Items modified:
        DWORD dwAlternateOffset to PWCHAR pszAlternates

*/

#include "dimsvcp.h"
#include <ras.h>
#include <dimsvc.h>     // Generated by MIDL
#include <mprapi.h>
#include <mprapip.h>
#include "rpbk.h"

//
// Definitions
//
#define MPRIO_UnsupportedOptions            \
        (                                   \
            RASEO_UseCountryAndAreaCodes  | \
            RASEO_TerminalBeforeDial      | \
            RASEO_TerminalAfterDial       | \
            RASEO_ModemLights             | \
            RASEO_UseLogonCredentials     | \
            RASEO_Custom                  | \
            RASEO_PreviewPhoneNumber      | \
            RASEO_PreviewUserPw           | \
            RASEO_PreviewDomain           | \
            RASEO_ShowDialingProgress       \
        )

//
// Strings
//
static const WCHAR  pszRouterPbkFmt[] = L"\\ras\\Router.pbk";

// 
// Structure tracks router entry information
//
typedef struct _RPBK_ENTRY_INFO
{
    PWCHAR pszPhonebookPath;

    DWORD dwEntrySize;
    LPRASENTRY pRasEntry;
    
    DWORD dwCustAuthDataSize;
    LPBYTE lpbCustAuthData;
    
} RPBK_ENTRY_INFO;

// 
// Structure tracks sub entry information
//
typedef struct _RPBK_SUBENTRY_INFO
{
    PWCHAR pszPhonebookPath;
    LPRASSUBENTRY pRasSubEntry;
    DWORD dwSize;
} RPBK_SUBENTRY_INFO;

//
// Common allocation
//
PVOID
RpbkAlloc(
    IN DWORD dwBytes,
    IN BOOL bZero)
{
    return LOCAL_ALLOC( (bZero) ? HEAP_ZERO_MEMORY : 0, dwBytes );
}

//
// Common free
//
VOID
RpbkFree(
    IN PVOID pvData)
{
    LOCAL_FREE( pvData );
}    

//
// Cleans up the entry info blob
//
VOID
RpbkFreeEntryInfo(
    IN RPBK_ENTRY_INFO * pInfo)
{
    if (pInfo)
    {
        if (pInfo->pszPhonebookPath)
        {
            RpbkFreePhonebookPath(pInfo->pszPhonebookPath);
        }
        if (pInfo->pRasEntry)
        {
            RpbkFree(pInfo->pRasEntry);
        }
        if (pInfo->lpbCustAuthData)
        {
            RpbkFree(pInfo->lpbCustAuthData);
        }
        RpbkFree(pInfo);
    }
}

//
// Cleans up the sub entry info blob
//
VOID
RpbkFreeSubEntryInfo(
    IN RPBK_SUBENTRY_INFO * pInfo)
{
    if (pInfo)
    {
        if (pInfo->pszPhonebookPath)
        {
            RpbkFree(pInfo->pszPhonebookPath);
        }
        if (pInfo->pRasSubEntry)
        {
            RpbkFree(pInfo->pRasSubEntry);
        }
        RpbkFree(pInfo);
    }
}

//
// Returns a heap-allocated copy of the path to the router
// phonebook
//
DWORD 
RpbkGetPhonebookPath(
    OUT PWCHAR* ppszPath)
{
    WCHAR pszSystemPath[MAX_PATH];
    UINT uiLength = sizeof(pszSystemPath) / sizeof(WCHAR);
    DWORD dwRetSize = 0;
    PWCHAR pszRet = NULL;

    // Find the system directory
    //
    uiLength = GetSystemDirectoryW(pszSystemPath, uiLength);
    if (uiLength == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Allocate the return buffer
    //
    dwRetSize = ((uiLength + 1) * sizeof(WCHAR)) + sizeof(pszRouterPbkFmt);
    pszRet = (PWCHAR) RpbkAlloc(dwRetSize, FALSE);
    if (pszRet == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Format the string
    //
    wcscpy(pszRet, pszSystemPath);
    wcscpy(pszRet + uiLength, pszRouterPbkFmt);

    *ppszPath = pszRet;
    
    return NO_ERROR;
}

//
// Cleans up after RpbkGetPhonebookPath
//
DWORD
RpbkFreePhonebookPath(
    IN PWCHAR pszPath)
{
    if ( pszPath )
    {
        RpbkFree(pszPath);
    }

    return NO_ERROR;
}

//
// Returns size in bytes of a multisz.
//
DWORD
RpbkGetMultiSzSize(
    IN LPWSTR lpwsMultSz
)
{
    LPWSTR lpwsPtr = lpwsMultSz;
    DWORD dwcbAlternates  = 0;
    DWORD dwCurCount;

    if ( lpwsMultSz == NULL )
    {
        return( 0 );
    }

    while( *lpwsPtr != L'\0' )
    {
        dwCurCount = ( wcslen( lpwsPtr ) + 1 );
        dwcbAlternates += dwCurCount;
        lpwsPtr += dwCurCount;
    }

    //
    // One more for the last NULL terminator
    //

    dwcbAlternates++;

    dwcbAlternates *= sizeof( WCHAR );

    return( dwcbAlternates );
}

//
// Copies a multi sz 
//
DWORD 
RpbkCopyMultiSz(
    IN LPWSTR lpwsDst,
    IN LPWSTR lpwsSrc)
{
    if (!lpwsDst || !lpwsSrc)
    {
        return ERROR_INVALID_PARAMETER;
    }

    while (lpwsSrc[0] || lpwsSrc[1])
    {
        *lpwsDst = *lpwsSrc;
        lpwsDst++;
        lpwsSrc++;
    }
    lpwsDst[0] = (WCHAR)0;
    lpwsDst[1] = (WCHAR)0;
    
    return NO_ERROR;
}

//
// Removes any unsupported options from the interface data
// provided.
//
DWORD
RpbkConformIfData(
    IN DWORD dwLevel, 
    IN LPBYTE pInterfaceData)
{
    MPR_INTERFACE_2* pIf2 = (MPR_INTERFACE_2*)pInterfaceData;

    // Clear the unsupported options
    //
    pIf2->dwfOptions &= ~MPRIO_UnsupportedOptions;

    // Make sure that netbios doesn't get reported
    //
    pIf2->dwfNetProtocols &= ~RASNP_NetBEUI;

    // Make sure that the type is not internet
    //
    if (pIf2->dwType == RASET_Internet)
    {
        pIf2->dwType = RASET_Phone;
    }

    return NO_ERROR;
}

//
// Removes any unsupported options from the router entry
// provided.
//
DWORD
RpbkConformEntry(
    IN LPRASENTRY pEntry)
{
    // Clear the unsupported options
    //
    pEntry->dwfOptions &= ~MPRIO_UnsupportedOptions;

    // Make sure that netbios is not enabled
    //
    pEntry->dwfNetProtocols &= ~RASNP_NetBEUI;

    // Make sure that the type is not internet
    //
    if (pEntry->dwType == RASET_Internet)
    {
        pEntry->dwType = RASET_Phone;
    }

    // Default all other values of the entry that
    // can't be supplied through MPR_INTERFACE_* 
    // structures.
    pEntry->dwSize              = sizeof(RASENTRY);
    pEntry->dwReserved1         = 0;
    pEntry->dwReserved2         = 0;
    pEntry->dwFramingProtocol   = RASFP_Ppp;
    pEntry->dwFrameSize         = 0;
    pEntry->dwCountryID         = 0;
    pEntry->dwCountryCode       = 0;
    pEntry->szScript[0]         = L'\0';
    pEntry->szAutodialDll[0]    = L'\0';
    pEntry->szAutodialFunc[0]   = L'\0';
    pEntry->szCustomDialDll[0]  = L'\0';
    pEntry->szAreaCode[0]       = L'\0';

    return NO_ERROR;
}

//
// Reads in the router phonebook entry associated with
// the given interface
//
DWORD 
RpbkOpenEntry(
    IN  ROUTER_INTERFACE_OBJECT* pIfObject, 
    OUT PHANDLE                  phEntry )
{
    RPBK_ENTRY_INFO * pInfo = NULL;
    DWORD dwErr = NO_ERROR, dwSize;

    do {
        // Initialize
        *phEntry = NULL;
    
        // Allocate the control structure
        //
        pInfo = (RPBK_ENTRY_INFO*) RpbkAlloc(sizeof(RPBK_ENTRY_INFO), TRUE);
        if (pInfo == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Get the phonebook path
        //
        dwErr = RpbkGetPhonebookPath(&(pInfo->pszPhonebookPath));
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Find out how big the ras entry needs to be
        //
        dwErr = RasGetEntryProperties(
                    pInfo->pszPhonebookPath,
                    pIfObject->lpwsInterfaceName,
                    NULL,
                    &(pInfo->dwEntrySize),
                    NULL,
                    NULL);
        if (dwErr != ERROR_BUFFER_TOO_SMALL)
        {
            break;
        }

        // Allocate the ras entry structure
        //
        pInfo->pRasEntry = (LPRASENTRY) RpbkAlloc(pInfo->dwEntrySize, TRUE);
        if (pInfo->pRasEntry == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Read in the ras entry
        //
        pInfo->pRasEntry->dwSize = sizeof(RASENTRY);
        dwErr = RasGetEntryProperties(
                    pInfo->pszPhonebookPath,
                    pIfObject->lpwsInterfaceName,
                    pInfo->pRasEntry,
                    &(pInfo->dwEntrySize),
                    NULL,
                    NULL);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Find out how big the custom auth data needs
        // to be
        dwErr = RasGetCustomAuthDataW (
                    pInfo->pszPhonebookPath,
                    pIfObject->lpwsInterfaceName,
                    NULL,
                    &(pInfo->dwCustAuthDataSize));
        if ( (dwErr != NO_ERROR) &&
             (dwErr != ERROR_BUFFER_TOO_SMALL)
           )
        {
            break;
        }

        dwErr = NO_ERROR;
        if ( pInfo->dwCustAuthDataSize ) 
        {
            // Allocate the custom auth data
            //
            pInfo->lpbCustAuthData = 
                RpbkAlloc(pInfo->dwCustAuthDataSize, TRUE);
                
            if (pInfo->lpbCustAuthData == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Read in the ras entry
            //
            dwErr = RasGetCustomAuthDataW(
                        pInfo->pszPhonebookPath,
                        pIfObject->lpwsInterfaceName,
                        pInfo->lpbCustAuthData,
                        &(pInfo->dwCustAuthDataSize));
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }

        // Assign the return value
        *phEntry = (HANDLE)pInfo;
        
    } while (FALSE);         

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RpbkFreeEntryInfo(pInfo);
        }
    }
    
    return dwErr;
}

//
// Cleans up the data returned by RpbkOpen* functions
//
DWORD 
RpbkCloseEntry( 
    IN HANDLE hEntry )
{
    RpbkFreeEntryInfo((RPBK_ENTRY_INFO*)hEntry);
    
    return NO_ERROR;
}

//
// Writes out the router phonebook entry based on the 
// the given interface
//
DWORD
RpbkSetEntry( 
    IN  DWORD            dwLevel,
    IN  LPBYTE           pInterfaceData )
{
    MPRI_INTERFACE_2* pIf2   = (MPRI_INTERFACE_2*)pInterfaceData;
    LPRASENTRY       pEntry = NULL;
    PWCHAR           pszAlternates = NULL, pszPath = NULL;
    DWORD            dwErr = NO_ERROR, dwSize;
    LPWSTR           pszAltSrc = NULL;
    
    // Validate parameters
    if (!pIf2)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the ras entry structure
    //
    dwSize = sizeof(RASENTRY);
    if (pIf2->dwAlternatesOffset)
    {
        pszAltSrc = (LPWSTR)
            ((ULONG_PTR)(pIf2) + (ULONG_PTR)(pIf2->dwAlternatesOffset));
            
        dwSize += RpbkGetMultiSzSize(pszAltSrc);
                
    }
    pEntry = RpbkAlloc(dwSize, TRUE);
    if (pEntry == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Assign all assignable fields
    //
    pEntry->dwfOptions                  = pIf2->dwfOptions;
    *((DWORD*)&(pEntry->ipaddr))        = pIf2->ipaddr;
    *((DWORD*)&(pEntry->ipaddrDns))     = pIf2->ipaddrDns;
    *((DWORD*)&(pEntry->ipaddrDnsAlt))  = pIf2->ipaddrDnsAlt;
    *((DWORD*)&(pEntry->ipaddrWins))    = pIf2->ipaddrWins;
    *((DWORD*)&(pEntry->ipaddrWinsAlt)) = pIf2->ipaddrWinsAlt;
    pEntry->dwfNetProtocols             = pIf2->dwfNetProtocols;
    pEntry->dwChannels                  = pIf2->dwChannels;
    pEntry->dwSubEntries                = pIf2->dwSubEntries;
    pEntry->dwDialMode                  = pIf2->dwDialMode;
    pEntry->dwDialExtraPercent          = pIf2->dwDialExtraPercent;
    pEntry->dwDialExtraSampleSeconds    = pIf2->dwDialExtraSampleSeconds;
    pEntry->dwHangUpExtraPercent        = pIf2->dwHangUpExtraPercent;
    pEntry->dwHangUpExtraSampleSeconds  = pIf2->dwHangUpExtraSampleSeconds;
    pEntry->dwIdleDisconnectSeconds     = pIf2->dwIdleDisconnectSeconds;
    pEntry->dwType                      = pIf2->dwType;
    pEntry->dwEncryptionType            = pIf2->dwEncryptionType;
    pEntry->dwCustomAuthKey             = pIf2->dwCustomAuthKey;
    pEntry->dwVpnStrategy               = pIf2->dwVpnStrategy;
    pEntry->guidId                      = pIf2->guidId;

    // Copy all copyable fields
    //
    wcscpy(pEntry->szLocalPhoneNumber,  pIf2->szLocalPhoneNumber);
    wcscpy(pEntry->szDeviceType,        pIf2->szDeviceType);
    wcscpy(pEntry->szDeviceName,        pIf2->szDeviceName);
    wcscpy(pEntry->szX25PadType,        pIf2->szX25PadType);
    wcscpy(pEntry->szX25Address,        pIf2->szX25Address);
    wcscpy(pEntry->szX25Facilities,     pIf2->szX25Facilities);
    wcscpy(pEntry->szX25UserData,       pIf2->szX25UserData);

    do 
    {
        // Copy the alternates list
        //
        if (pIf2->dwAlternatesOffset)
        {
            pEntry->dwAlternateOffset = sizeof(RASENTRY);
                 
            pszAlternates = (PWCHAR)
                ((ULONG_PTR)(pEntry) + 
                 (ULONG_PTR)(pEntry->dwAlternateOffset));
                 
            dwErr = RpbkCopyMultiSz(pszAlternates, pszAltSrc);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }
        else
        {
            pEntry->dwAlternateOffset = 0;
        }

        // Remove any unsupported options that may have made
        // it in. (shouldn't be any)
        //
        dwErr = RpbkConformEntry(pEntry);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Map MPRIO_IpSecPreSharedKey to RASEO_PreSharedKey
        // 
        //
        if(pIf2->dwfOptions & MPRIO_IpSecPreSharedKey)
        {   
            pEntry->dwfOptions &= ~(MPRIO_IpSecPreSharedKey);
            pEntry->dwfOptions2 |= RASEO2_UsePreSharedKey;
        }

        // Discover the phonebook path
        dwErr = RpbkGetPhonebookPath(&pszPath);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Save the entry
        dwErr = RasSetEntryPropertiesW(
                    pszPath,
                    pIf2->wszInterfaceName,
                    pEntry,
                    dwSize, 
                    NULL,
                    0);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

        // Save the custom auth options
        //
        dwErr = RasSetCustomAuthDataW( 
                    pszPath,
                    pIf2->wszInterfaceName,
                    (LPBYTE)(pIf2 + 1),
                    pIf2->dwCustomAuthDataSize);
        if ( dwErr != NO_ERROR )                    
        {
            break;
        }
        
    } while (FALSE);        

    // Cleanup
    {
        if (pEntry)
        {
            RpbkFree(pEntry);
        }
        if (pszPath)
        {
            RpbkFree(pszPath);
        }
    }

    return dwErr;
}
    
//
// Deletes the given entry from the phonebook
//
DWORD 
RpbkDeleteEntry( 
    IN PWCHAR pszInterfaceName )
{
    PWCHAR           pszPath = NULL;
    DWORD            dwErr = NO_ERROR;
    
    do
    {
        // Get the phonebook path
        //
        dwErr = RpbkGetPhonebookPath(&pszPath);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Delete the entry
        //
        dwErr = RasDeleteEntry(pszPath, pszInterfaceName);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
    } while (FALSE);
    
    // Cleanup
    {
        if ( pszPath )
        {
            RpbkFree(pszPath);
        }
    }
    
    return dwErr;
}

//
// Calculates the required size of a buffer to hold interface information
// at the given level based on the given entry or sub entry.
//
DWORD
RpbkEntryToIfDataSize(
    IN  HANDLE  hEntry, 
    IN  DWORD   dwLevel,
    OUT LPDWORD lpdwcbSizeOfData )
{
    RPBK_ENTRY_INFO* pInfo = (RPBK_ENTRY_INFO*)hEntry;
    DWORD dwSize;
    PWCHAR pszAlternates = NULL;

    // Validate parameters
    if (!pInfo)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize
    *lpdwcbSizeOfData = 0;

    // For level 2, the size is the size of the level 2 
    // structure plus the size of the alternate phone list   
    if (dwLevel != 2)
    {
        return ERROR_INVALID_LEVEL;
    }

    // Initailize the size to the base size
    //
    dwSize = sizeof(MPR_INTERFACE_2);

    //  Add on the size of the custom auth data
    //
    dwSize += pInfo->dwCustAuthDataSize;
    
    //  Add on the size of the alternates list
    //
    if (pInfo->pRasEntry->dwAlternateOffset)
    {
        pszAlternates = (PWCHAR)
            ((ULONG_PTR)(pInfo->pRasEntry) + 
             (ULONG_PTR)(pInfo->pRasEntry->dwAlternateOffset));
             
        dwSize += RpbkGetMultiSzSize(pszAlternates);
    }

    // Assign the return value
    //
    *lpdwcbSizeOfData = dwSize;
    
    return NO_ERROR;
}

//
// Populates the ras portion of the given interface info blob based on the 
// level and entry or subentry.
//
DWORD
RpbkEntryToIfData( 
    IN  HANDLE           hEntry, 
    IN  DWORD            dwLevel,
    OUT LPBYTE           pInterfaceData )
{
    RPBK_ENTRY_INFO* pInfo  = (RPBK_ENTRY_INFO*)hEntry;
    MPRI_INTERFACE_2* pIf2   = (MPRI_INTERFACE_2*)pInterfaceData;
    LPRASENTRY       pEntry = NULL;
    PWCHAR           pszSrc, pszDst;
    DWORD            dwErr = NO_ERROR, dwOffset = 0;
    
    // Validate parameters
    if (!pInfo || !pIf2)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Alias the ras entry
    //
    pEntry = pInfo->pRasEntry;

    // Assign all assignable fields
    //
    pIf2->dwfOptions                = pEntry->dwfOptions;
    pIf2->ipaddr                    = *((DWORD*)&(pEntry->ipaddr));
    pIf2->ipaddrDns                 = *((DWORD*)&(pEntry->ipaddrDns));
    pIf2->ipaddrDnsAlt              = *((DWORD*)&(pEntry->ipaddrDnsAlt));
    pIf2->ipaddrWins                = *((DWORD*)&(pEntry->ipaddrWins));
    pIf2->ipaddrWinsAlt             = *((DWORD*)&(pEntry->ipaddrWinsAlt));
    pIf2->dwfNetProtocols           = pEntry->dwfNetProtocols;
    pIf2->dwChannels                = pEntry->dwChannels;
    pIf2->dwSubEntries              = pEntry->dwSubEntries;
    pIf2->dwDialMode                = pEntry->dwDialMode;
    pIf2->dwDialExtraPercent        = pEntry->dwDialExtraPercent;
    pIf2->dwDialExtraSampleSeconds  = pEntry->dwDialExtraSampleSeconds;
    pIf2->dwHangUpExtraPercent      = pEntry->dwHangUpExtraPercent;
    pIf2->dwHangUpExtraSampleSeconds= pEntry->dwHangUpExtraSampleSeconds;
    pIf2->dwIdleDisconnectSeconds   = pEntry->dwIdleDisconnectSeconds;
    pIf2->dwType                    = pEntry->dwType;
    pIf2->dwEncryptionType          = pEntry->dwEncryptionType;
    pIf2->dwCustomAuthKey           = pEntry->dwCustomAuthKey;
    pIf2->dwVpnStrategy             = pEntry->dwVpnStrategy;
    pIf2->guidId                    = pEntry->guidId;

    // Copy all copyable fields
    //
    wcscpy(pIf2->szLocalPhoneNumber,  pEntry->szLocalPhoneNumber);
    wcscpy(pIf2->szDeviceType,        pEntry->szDeviceType);
    wcscpy(pIf2->szDeviceName,        pEntry->szDeviceName);
    wcscpy(pIf2->szX25PadType,        pEntry->szX25PadType);
    wcscpy(pIf2->szX25Address,        pEntry->szX25Address);
    wcscpy(pIf2->szX25Facilities,     pEntry->szX25Facilities);
    wcscpy(pIf2->szX25UserData,       pEntry->szX25UserData);

    // Append the custom auth data to the end of the
    // structure.
    //
    dwOffset = sizeof(MPRI_INTERFACE_2);
    if ( pInfo->dwCustAuthDataSize )
    {
        pIf2->dwCustomAuthDataSize = 
            pInfo->dwCustAuthDataSize;
        
        pIf2->dwCustomAuthDataOffset = TRUE;
        
        CopyMemory(
            pIf2 + 1, 
            pInfo->lpbCustAuthData, 
            pInfo->dwCustAuthDataSize);
    }

    // Append the alternates list
    //
    dwOffset += pInfo->dwCustAuthDataSize;
    if (pEntry->dwAlternateOffset)
    {
        pIf2->dwAlternatesOffset = TRUE;
            
        pszSrc = (PWCHAR)((ULONG_PTR)(pEntry) + 
             (ULONG_PTR)(pEntry->dwAlternateOffset));

        pszDst = (PWCHAR)((ULONG_PTR)(pIf2) + (ULONG_PTR)dwOffset);
             
        dwErr = RpbkCopyMultiSz(pszDst, pszSrc);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }
    else
    {
        pIf2->dwAlternatesOffset = 0;
    }

    // Remove any unsupported options that may have made
    // it in. (shouldn't be any)
    //
    dwErr = RpbkConformIfData(dwLevel, pInterfaceData);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if(pEntry->dwfOptions2 & RASEO2_UsePreSharedKey)
    {
        pIf2->dwfOptions |= MPRIO_IpSecPreSharedKey;
    }

    return NO_ERROR;
}

// 
// Reads in the router phonebook sub entry associated with
// the given interface
//
DWORD 
RpbkOpenSubEntry(
    IN  ROUTER_INTERFACE_OBJECT* pIfObject, 
    IN  DWORD                    dwIndex,    
    OUT PHANDLE                  phSubEntry )
{
    RPBK_SUBENTRY_INFO * pInfo = NULL;
    DWORD dwErr = NO_ERROR, dwSize;

    do {
        // Initialize
        *phSubEntry = NULL;
    
        // Allocate the control structure
        //
        pInfo = (RPBK_SUBENTRY_INFO*) 
            RpbkAlloc(sizeof(RPBK_SUBENTRY_INFO), TRUE);
            
        if (pInfo == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Get the phonebook path
        //
        dwErr = RpbkGetPhonebookPath(&(pInfo->pszPhonebookPath));
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Find out how big the ras entry needs to be
        //
        dwErr = RasGetSubEntryPropertiesW(
                    pInfo->pszPhonebookPath,
                    pIfObject->lpwsInterfaceName,
                    dwIndex,
                    NULL,
                    &(pInfo->dwSize),
                    NULL,
                    NULL);
        if (dwErr != ERROR_BUFFER_TOO_SMALL)
        {
            break;
        }

        // Allocate the ras entry structure
        //
        pInfo->pRasSubEntry = 
            (LPRASSUBENTRY) RpbkAlloc(pInfo->dwSize, TRUE);
            
        if (pInfo->pRasSubEntry == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Read in the ras entry
        //
        pInfo->pRasSubEntry->dwSize = sizeof(RASSUBENTRY);
        dwErr = RasGetSubEntryProperties(
                    pInfo->pszPhonebookPath,
                    pIfObject->lpwsInterfaceName,
                    dwIndex,
                    pInfo->pRasSubEntry,
                    &(pInfo->dwSize),
                    NULL,
                    NULL);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Assign the return value
        *phSubEntry = (HANDLE)pInfo;
        
    } while (FALSE);         

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RpbkFreeSubEntryInfo(pInfo);
        }
    }
    
    return dwErr;
}

//
// Cleans up the data returned by RpbkOpen* functions
//
DWORD 
RpbkCloseSubEntry( 
    IN HANDLE hSubEntry )
{
    RpbkFreeSubEntryInfo((RPBK_SUBENTRY_INFO*)hSubEntry);
    
    return NO_ERROR;
}

DWORD
RpbkSetSubEntry( 
    IN  PWCHAR pszInterface,
    IN  DWORD  dwIndex,
    IN  DWORD  dwLevel,
    OUT LPBYTE pDevData )
{
    MPR_DEVICE_0*    pDev0  = (MPR_DEVICE_0*)pDevData;
    MPR_DEVICE_1*    pDev1  = (MPR_DEVICE_1*)pDevData;
    LPRASSUBENTRY    pSubEntry = NULL;
    PWCHAR           pszAlternates = NULL, pszPath = NULL;
    DWORD            dwErr = NO_ERROR, dwSize;
    
    // Validate parameters
    if (! pDev0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the ras entry structure
    //
    dwSize = sizeof(RASSUBENTRY);
    if ((dwLevel == 1) && (pDev1->szAlternates))
    {
        dwSize += RpbkGetMultiSzSize(pDev1->szAlternates);
    }
    pSubEntry = RpbkAlloc(dwSize, TRUE);
    if (pSubEntry == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pSubEntry->dwSize = sizeof(RASSUBENTRY);

    do 
    {
        // Copy all copyable fields
        //
        if ( dwLevel == 0 )
        {
            wcscpy(pSubEntry->szDeviceType,  pDev0->szDeviceType);
            wcscpy(pSubEntry->szDeviceName,  pDev0->szDeviceName);
        }            
        
        if ( dwLevel == 1 )
        {
            wcscpy(pSubEntry->szDeviceType,  pDev1->szDeviceType);
            wcscpy(pSubEntry->szDeviceName,  pDev1->szDeviceName);
            wcscpy(pSubEntry->szLocalPhoneNumber,  pDev1->szLocalPhoneNumber);

            if (pDev1->szAlternates)
            {
                pSubEntry->dwAlternateOffset = sizeof(RASSUBENTRY);
                     
                pszAlternates = (PWCHAR)
                    ((ULONG_PTR)(pSubEntry) + 
                     (ULONG_PTR)(pSubEntry->dwAlternateOffset));
                     
                dwErr = RpbkCopyMultiSz(pszAlternates, pDev1->szAlternates);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
            }
            else
            {
                pSubEntry->dwAlternateOffset = 0;
            }
        }

        // Discover the phonebook path
        dwErr = RpbkGetPhonebookPath(&pszPath);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Save the entry
        dwErr = RasSetSubEntryPropertiesW(
                    pszPath,
                    pszInterface,
                    dwIndex,
                    pSubEntry,
                    dwSize, 
                    NULL,
                    0);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

    } while (FALSE);        

    // Cleanup
    {
        if (pSubEntry)
        {
            RpbkFree(pSubEntry);
        }
        if (pszPath)
        {
            RpbkFree(pszPath);
        }
    }

    return dwErr;
}
    
DWORD
RpbkSubEntryToDevDataSize(
    IN  HANDLE  hSubEntry, 
    IN  DWORD   dwLevel,
    OUT LPDWORD lpdwcbSizeOfData )
{
    RPBK_SUBENTRY_INFO* pInfo = (RPBK_SUBENTRY_INFO*)hSubEntry;
    DWORD dwSize = 0;
    PWCHAR pszAlternates = NULL;

    // Validate parameters
    if (pInfo == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize
    *lpdwcbSizeOfData = 0;

    // Initailize the size 
    //
    if ( dwLevel == 0 )
    {
        dwSize = sizeof(MPR_DEVICE_0);
    }
    else
    {
        dwSize = sizeof(MPR_DEVICE_1);
        
        //  Add on the size of the alternates list
        //
        if (pInfo->pRasSubEntry->dwAlternateOffset)
        {
            pszAlternates = (PWCHAR)
                ((ULONG_PTR)(pInfo->pRasSubEntry) + 
                 (ULONG_PTR)(pInfo->pRasSubEntry->dwAlternateOffset));
                 
            dwSize += RpbkGetMultiSzSize(pszAlternates);
        }
    }

    // Assign the return value
    //
    *lpdwcbSizeOfData = dwSize;
    
    return NO_ERROR;
}
    
DWORD
RpbkSubEntryToDevData( 
    IN  HANDLE  hSubEntry, 
    IN  DWORD   dwLevel,
    OUT LPBYTE  pDeviceData )
{
    RPBK_SUBENTRY_INFO* pInfo  = (RPBK_SUBENTRY_INFO*)hSubEntry;
    MPR_DEVICE_0*    pDev0  = (MPR_DEVICE_0*)pDeviceData;
    MPR_DEVICE_1*    pDev1  = (MPR_DEVICE_1*)pDeviceData;
    LPRASSUBENTRY    pSubEntry = NULL;
    PWCHAR           pszAlternates = NULL;
    DWORD            dwErr = NO_ERROR, dwOffset = 0;
    
    // Validate parameters
    if (!pInfo || !pDev0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Alias the ras entry
    //
    pSubEntry = pInfo->pRasSubEntry;

    // Copy all copyable fields
    //
    if ( dwLevel == 0 )
    {
        wcscpy(pDev0->szDeviceType,       pSubEntry->szDeviceType);
        wcscpy(pDev0->szDeviceName,       pSubEntry->szDeviceName);
    }        
    
    else if ( dwLevel == 1 )
    {
        wcscpy(pDev1->szDeviceType,       pSubEntry->szDeviceType);
        wcscpy(pDev1->szDeviceName,       pSubEntry->szDeviceName);
        wcscpy(pDev1->szLocalPhoneNumber,  pSubEntry->szLocalPhoneNumber);
        
        // Append the custom auth data to the end of the
        // structure.
        //
        dwOffset += sizeof(MPR_DEVICE_1);
        if (pSubEntry->dwAlternateOffset)
        {
            pDev1->szAlternates = (PWCHAR)
                ((ULONG_PTR)(pDev1) + dwOffset);
                
            pszAlternates = (PWCHAR)
                ((ULONG_PTR)(pSubEntry) + 
                 (ULONG_PTR)(pSubEntry->dwAlternateOffset));
                 
            dwErr = RpbkCopyMultiSz(pDev1->szAlternates, pszAlternates);
            if (dwErr != NO_ERROR)
            {
                return dwErr;
            }
        }
        else
        {
            pDev1->szAlternates = NULL;
        }
    }
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\dim\server\main.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.     **/
/********************************************************************/

//***
//
// Filename:    main.c
//
// Description: This module contains the main procedure of the Dynamic
//              Interface Manager server service. It will contain code to
//              initialize and install itself. It also contains
//              code to respond to the server controller. It will also
//              handle service shutdown.
//
// History:     May 11,1995.    NarenG      Created original version.
//
#define _ALLOCATE_DIM_GLOBALS_
#include "dimsvcp.h"
#include <winsvc.h>
#include <winuser.h>
#include <dbt.h>
#include <ndisguid.h>
#include <wmium.h>
#include <rpc.h>
#include <iaspolcy.h>
#include <iasext.h>
#include <lmserver.h>
#include <srvann.h>
#include <ddmif.h>

#define RAS_CONTROL_CONFIGURE 128

//**
//
// Call:        MediaSenseCallback
//
// Returns:     None
//
// Description:
//
VOID
WINAPI
MediaSenseCallback(
    PWNODE_HEADER   pWnodeHeader,
    UINT_PTR        NotificationContext
)
{
    ROUTER_INTERFACE_OBJECT * pIfObject;
    PWNODE_SINGLE_INSTANCE    pWnode   = (PWNODE_SINGLE_INSTANCE)pWnodeHeader;
    LPWSTR                    lpwsName = (LPWSTR)RtlOffsetToPointer( 
                                                pWnode, 
                                                pWnode->OffsetInstanceName );

    if ( (gblDIMConfigInfo.ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
         ||
         (gblDIMConfigInfo.ServiceStatus.dwCurrentState == SERVICE_STOPPED ))
    {
        return;
    }

    //
    // Get the information for the media disconnect.
    //

    if ( memcmp( &(pWnodeHeader->Guid), 
                 &GUID_NDIS_STATUS_MEDIA_DISCONNECT, 
                 sizeof( GUID ) ) == 0 )
    {
        DIMTRACE1("MediaSenseCallback for sense disconnect called for %ws",
                  lpwsName );

        IfObjectNotifyOfMediaSenseChange();
    }
    else
    {
        //
        // Get the information for the media connect.
        //

        if ( memcmp( &(pWnodeHeader->Guid), 
                     &GUID_NDIS_STATUS_MEDIA_CONNECT, 
                     sizeof( GUID ) ) == 0 )
        {
            DIMTRACE1("MediaSenseCallback for sense connect called for %ws",
                      lpwsName );

            IfObjectNotifyOfMediaSenseChange();
        }
    }
}

//**
//
// Call:        MediaSenseRegister
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
MediaSenseRegister(
    IN BOOL fRegister
)
{
    DWORD       dwRetCode = NO_ERROR;
    PVOID       pvDeliveryInfo = MediaSenseCallback;

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_CONNECT),
                    (BOOLEAN)fRegister,    
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR ) 
    {
        return( dwRetCode );
    }

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_DISCONNECT),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    return( NO_ERROR );
}

//**
//
// Call:        BindingsNotificationsCallback
//
// Returns:     None
//
// Description:
//
VOID
WINAPI
BindingsNotificationsCallback(
    PWNODE_HEADER   pWnodeHeader,
    UINT_PTR        NotificationContext
)
{
    LPWSTR lpwszGUIDStart; 
    LPWSTR lpwszGUIDEnd;
    LPWSTR lpwszGUID;
    WCHAR  wchGUIDSaveLast;
    ROUTER_INTERFACE_OBJECT * pIfObject;
    PWNODE_SINGLE_INSTANCE    pWnode   = (PWNODE_SINGLE_INSTANCE)pWnodeHeader;
    LPWSTR                    lpwsName = (LPWSTR)RtlOffsetToPointer(
                                                pWnode,
                                                pWnode->OffsetInstanceName );
    LPWSTR                    lpwsTransportName = (LPWSTR)RtlOffsetToPointer(
                                                        pWnode,
                                                        pWnode->DataBlockOffset );

    if ( (gblDIMConfigInfo.ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
         ||
         (gblDIMConfigInfo.ServiceStatus.dwCurrentState == SERVICE_STOPPED ))
    {
        return;
    }

    //
    // Extract GUID from the \device\GUID name
    //

    lpwszGUID       = lpwsTransportName + wcslen( lpwsTransportName ) + 1;
    lpwszGUIDStart  = wcsrchr( lpwszGUID, L'{' );
    lpwszGUIDEnd    = wcsrchr( lpwszGUID, L'}' );

    if (    (lpwszGUIDStart != NULL )
        &&  (lpwszGUIDEnd != NULL ))
    {
        wchGUIDSaveLast = *(lpwszGUIDEnd+1);

        EnterCriticalSection( &(gblInterfaceTable.CriticalSection));

        *(lpwszGUIDEnd+1) = (WCHAR)NULL;

        pIfObject = IfObjectGetPointerByName( lpwszGUIDStart, FALSE );

        *(lpwszGUIDEnd+1) = wchGUIDSaveLast;

        //
        // If we got a bind notification
        //

        if ( memcmp( &(pWnodeHeader->Guid), &GUID_NDIS_NOTIFY_BIND, sizeof( GUID ) ) == 0)
        {
            DIMTRACE2("BindingsNotificationsCallback BIND for %ws,Transport=%ws",
                       lpwsName, lpwsTransportName );
            //
            // If we have this interface loaded.
            //
            
            if ( pIfObject != NULL )
            {
                //
                // If this interface is being bound to IP
                //

                if ( _wcsicmp( L"TCPIP", lpwsTransportName ) == 0 )
                {
                    DWORD dwTransportIndex = GetTransportIndex( PID_IP );

                    //
                    // If IP routermanager is loaded and this interface is not
                    // already registered with it
                    //

                    if (( dwTransportIndex != -1 ) &&
                        ( pIfObject->Transport[dwTransportIndex].hInterface 
                                                                == INVALID_HANDLE_VALUE ))
                    {
                        AddInterfacesToRouterManager( lpwszGUIDStart, PID_IP );
                    }
                }

                //
                // If this interface is being bound to IPX
                //

                if ( _wcsicmp( L"NWLNKIPX", lpwsTransportName ) == 0 )
                {
                    DWORD dwTransportIndex = GetTransportIndex( PID_IPX );

                    //
                    // If IPX routermanager is loaded and this interface is not
                    // already registered with it
                    //

                    if (( dwTransportIndex != -1 ) &&
                        ( pIfObject->Transport[dwTransportIndex].hInterface 
                                                                == INVALID_HANDLE_VALUE ))
                    {
                        AddInterfacesToRouterManager( lpwszGUIDStart, PID_IPX );
                    }
                }
            }
        }
        else if (memcmp( &(pWnodeHeader->Guid),&GUID_NDIS_NOTIFY_UNBIND,sizeof(GUID))==0)
        {
            if ( pIfObject != NULL )
            {
                //
                // Get the information for the media connect.
                //

                DIMTRACE2("BindingsNotificationsCallback UNDBIND for %ws,Transport=%ws", 
                           lpwsName, lpwsTransportName ); 

                if ( _wcsicmp( L"TCPIP", lpwsTransportName ) == 0 )
                {
                    IfObjectDeleteInterfaceFromTransport( pIfObject, PID_IP );
                }

                if ( _wcsicmp( L"NWLNKIPX", lpwsTransportName ) == 0 )
                {
                    IfObjectDeleteInterfaceFromTransport( pIfObject, PID_IPX );
                }
            }
        }

        LeaveCriticalSection( &(gblInterfaceTable.CriticalSection) );
    }
}

//**
//
// Call:        BindingsNotificationsRegister
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
BindingsNotificationsRegister(
    IN BOOL fRegister
)
{
    DWORD       dwRetCode = NO_ERROR;
    PVOID       pvDeliveryInfo = BindingsNotificationsCallback;

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_NOTIFY_BIND),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_NOTIFY_UNBIND),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    return( NO_ERROR );
}

//**
//
// Call:    DimAnnounceServiceStatus
//
// Returns: none
//
// Description: Will simly call SetServiceStatus to inform the service
//      control manager of this service's current status.
//
VOID
DimAnnounceServiceStatus(
    VOID
)
{
    BOOL dwRetCode;

    ASSERT (gblDIMConfigInfo.hServiceStatus);

    //
    // Increment the checkpoint in a pending state:
    //

    switch( gblDIMConfigInfo.ServiceStatus.dwCurrentState )
    {
    case SERVICE_START_PENDING:
    case SERVICE_STOP_PENDING:

        gblDIMConfigInfo.ServiceStatus.dwCheckPoint++;

        break;

    default:
        break;
    }

    dwRetCode = SetServiceStatus( gblDIMConfigInfo.hServiceStatus,
                                  &gblDIMConfigInfo.ServiceStatus );

    if ( dwRetCode == FALSE )
    {
        //TracePrintfExA( gblDIMConfigInfo.dwTraceId,
        //                TRACE_DIM,
        //                "SetServiceStatus returned %d", GetLastError() );
    }
}

//**
//
// Call:    DimCleanUp
//
// Returns: none
//
// Description: Will free any allocated memory, deinitialize RPC, deinitialize
//              the kernel-mode server and unload it if it was loaded.
//              This could have been called due to an error on SERVICE_START
//              or normal termination.
//
VOID
DimCleanUp(
    IN DWORD    dwError
)
{
    DWORD dwIndex;
    
    //
    // Announce that we are stopping
    //

    gblDIMConfigInfo.ServiceStatus.dwCurrentState     = SERVICE_STOP_PENDING;
    gblDIMConfigInfo.ServiceStatus.dwControlsAccepted = 0;
    gblDIMConfigInfo.ServiceStatus.dwCheckPoint       = 1;
    gblDIMConfigInfo.ServiceStatus.dwWaitHint         = 200000;

    DimAnnounceServiceStatus();

    if ( gbldwDIMComponentsLoaded & DIM_RPC_LOADED )
    {
        DimTerminateRPC();
    }

    //
    // Stop the timer and delete the timer Q if there is one.
    //

    if ( gblDIMConfigInfo.hTimerQ != NULL )
    {
        if(gblDIMConfigInfo.hTimer != NULL)
        {
            RtlDeleteTimer(gblDIMConfigInfo.hTimerQ,
                           gblDIMConfigInfo.hTimer,
                           NULL);
            gblDIMConfigInfo.hTimer = NULL;                           
        }
        
        RtlDeleteTimerQueueEx( gblDIMConfigInfo.hTimerQ, INVALID_HANDLE_VALUE );
        gblDIMConfigInfo.hTimerQ = NULL;
    }

    EnterCriticalSection( &(gblDIMConfigInfo.CSRouterIdentity) );

    DeleteCriticalSection( &(gblDIMConfigInfo.CSRouterIdentity) );

    if ( gbldwDIMComponentsLoaded & DIM_DDM_LOADED )
    {
        //
        // If we are not in LANOnly mode then stop DDM
        //

        if ( gblDIMConfigInfo.dwRouterRole != ROUTER_ROLE_LAN )
        {
            if ( gblhEventDDMServiceState != NULL )
            {
                SetEvent( gblhEventDDMServiceState );
            }
        }

        //
        // Wait for all threads in use to stop
        //

        while( gblDIMConfigInfo.dwNumThreadsRunning > 0 )
        {
            Sleep( 1000 );
        }
    }

    // just to increment checkpoints
    DimAnnounceServiceStatus();

    //
    // Tear down and free everything
    //

    if ( gbldwDIMComponentsLoaded & DIM_RMS_LOADED )
    {
        DimUnloadRouterManagers();
    }

    //
    // Unregister for media sense
    //

    MediaSenseRegister( FALSE );

    //
    // Unregister for bind/unbind sense
    //

    BindingsNotificationsRegister( FALSE );

    //
    // Need to sleep to give the router managers a change to unload
    // bug# 78711
    //

    Sleep( 2000 );

    if ( gblhModuleDDM != NULL )
    {
        VOID        (*DDMPostCleanup)( VOID ) = NULL;

        DDMPostCleanup = (VOID(*)( VOID ))
                        GetDDMEntryPoint("DDMPostCleanup");

        if(NULL != DDMPostCleanup)
        {
            //
            // Call DDM to cleanup.
            //
            DDMPostCleanup();
        }
        
        FreeLibrary( gblhModuleDDM );
    }

    //
    // If security object was created
    //

    if ( gbldwDIMComponentsLoaded & DIM_SECOBJ_LOADED )
    {
        DimSecObjDelete();
    }

    if ( gblDIMConfigInfo.hMprConfig != NULL )
    {
        MprConfigServerDisconnect( gblDIMConfigInfo.hMprConfig );
    }

    if ( gblhEventDDMTerminated != NULL )
    {
        CloseHandle( gblhEventDDMTerminated );
    }

    if ( gblhEventDDMServiceState != NULL )
    {
        CloseHandle( gblhEventDDMServiceState );
    }

    if ( gblhEventTerminateDIM != NULL )
    {
        CloseHandle( gblhEventTerminateDIM );
    }

    if ( gblhEventRMState != NULL )
    {
        CloseHandle( gblhEventRMState );
    }

    if ( gblDIMConfigInfo.hObjectRouterIdentity != NULL )
    {
        RouterIdentityObjectClose( gblDIMConfigInfo.hObjectRouterIdentity );
    }

    //
    // Wait for everybody to release this and then delete it
    //

    EnterCriticalSection( &(gblInterfaceTable.CriticalSection) );

    DeleteCriticalSection( &(gblInterfaceTable.CriticalSection) );

    gbldwDIMComponentsLoaded = 0;


    if ( gblDIMConfigInfo.dwTraceId != INVALID_TRACEID )
    {
        TraceDeregisterA( gblDIMConfigInfo.dwTraceId );
    }

    RouterLogDeregister( gblDIMConfigInfo.hLogEvents );

    //
    // Destroy private heap
    //

    if ( gblDIMConfigInfo.hHeap != NULL )
    {
        HeapDestroy( gblDIMConfigInfo.hHeap );
    }

    DIMTRACE1("DimCleanup completed for error %d", dwError );
    
    //
    // Zero init all the globals
    //

    gblRouterManagers           = NULL;
    gbldwDIMComponentsLoaded    = 0;
    gblhEventDDMTerminated      = NULL;
    gblhEventRMState            = NULL;
    gblhEventDDMServiceState    = NULL;
    gblhModuleDDM               = NULL;
    gblhEventTerminateDIM       = NULL;
    ZeroMemory( &gblInterfaceTable,     sizeof( gblInterfaceTable ) );

    {
        SERVICE_STATUS_HANDLE svchandle = gblDIMConfigInfo.hServiceStatus;
        ZeroMemory( &gblDIMConfigInfo,      sizeof( gblDIMConfigInfo ) );
        gblDIMConfigInfo.hServiceStatus = svchandle;
    }
    
    //
    // Zero out only the procedure entrypoints. This is a side effect of
    // the merge into svchost.exe since svchost doesn't unload mprdim
    // anymore when router stops.
    //

    for ( dwIndex = 0; 
          gblDDMFunctionTable[dwIndex].lpEntryPointName != NULL;
          dwIndex ++ )
    {
        gblDDMFunctionTable[dwIndex].pEntryPoint = NULL;
    }

    if ( dwError == NO_ERROR )
    {
        gblDIMConfigInfo.ServiceStatus.dwWin32ExitCode = NO_ERROR;
    }
    else
    {
        gblDIMConfigInfo.ServiceStatus.dwWin32ExitCode =
                                                ERROR_SERVICE_SPECIFIC_ERROR;
    }

    gblDIMConfigInfo.ServiceStatus.dwServiceType  = SERVICE_WIN32_SHARE_PROCESS;
    gblDIMConfigInfo.ServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    gblDIMConfigInfo.ServiceStatus.dwControlsAccepted   = 0;
    gblDIMConfigInfo.ServiceStatus.dwCheckPoint         = 0;
    gblDIMConfigInfo.ServiceStatus.dwWaitHint           = 0;
    gblDIMConfigInfo.ServiceStatus.dwServiceSpecificExitCode = dwError;

    gbldwDIMComponentsLoaded |= DIM_SERVICE_STOPPED;

    DimAnnounceServiceStatus();
    
}

//**
//
// Call:        ServiceHandlerEx
//
// Returns:     none
//
// Description: Will respond to control requests from the service controller.
//
DWORD
ServiceHandlerEx(
    IN DWORD        dwControlCode,
    IN DWORD        dwEventType,
    IN LPVOID       lpEventData,
    IN LPVOID       lpContext
)
{
    DWORD dwRetCode = NO_ERROR;

    switch( dwControlCode )
    {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        if ( ( gblDIMConfigInfo.ServiceStatus.dwCurrentState ==
                                                        SERVICE_STOP_PENDING)
            ||
            ( gblDIMConfigInfo.ServiceStatus.dwCurrentState ==
                                                        SERVICE_STOPPED ))
        {
            break;
        }

        DIMTRACE("Service control stop or shutdown called");

        //
        // Announce that we are stopping
        //

        gblDIMConfigInfo.ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        gblDIMConfigInfo.ServiceStatus.dwControlsAccepted = 0;
        gblDIMConfigInfo.ServiceStatus.dwCheckPoint       = 1;
        gblDIMConfigInfo.ServiceStatus.dwWaitHint         = 200000;

        DimAnnounceServiceStatus();

        //
        // Make sure service is started before initiating a stop
        //

        while( !( gbldwDIMComponentsLoaded & DIM_SERVICE_STARTED ) )
        {
            //
            // Check to see if the we have already sent the
            // stopped status. If it did, then bail.
            //
            if(gbldwDIMComponentsLoaded & DIM_SERVICE_STOPPED)
            {
                return dwRetCode;
            }
            
            Sleep( 1000 );
        }

        SetEvent( gblhEventTerminateDIM );

        return( NO_ERROR );

    case SERVICE_CONTROL_PAUSE:

        if ( ( gblDIMConfigInfo.ServiceStatus.dwCurrentState ==
                                                        SERVICE_PAUSE_PENDING)
            ||
            ( gblDIMConfigInfo.ServiceStatus.dwCurrentState ==
                                                        SERVICE_PAUSED ))
            break;


        gblDIMConfigInfo.ServiceStatus.dwCurrentState     = SERVICE_PAUSED;
        gblDIMConfigInfo.ServiceStatus.dwControlsAccepted = 0;
        gblDIMConfigInfo.ServiceStatus.dwCheckPoint       = 0;
        gblDIMConfigInfo.ServiceStatus.dwWaitHint         = 200000;
        gblDIMConfigInfo.ServiceStatus.dwControlsAccepted = 
                                               SERVICE_ACCEPT_STOP
                                             | SERVICE_ACCEPT_PAUSE_CONTINUE
                                             | SERVICE_ACCEPT_SHUTDOWN;

        SetEvent( gblhEventDDMServiceState );

        break;

    case SERVICE_CONTROL_CONTINUE:

        if ( ( gblDIMConfigInfo.ServiceStatus.dwCurrentState ==
                                                SERVICE_CONTINUE_PENDING )
            ||
            ( gblDIMConfigInfo.ServiceStatus.dwCurrentState ==
                                                SERVICE_RUNNING ) )
            break;

        gblDIMConfigInfo.ServiceStatus.dwCheckPoint     = 0;
        gblDIMConfigInfo.ServiceStatus.dwWaitHint       = 0;
        gblDIMConfigInfo.ServiceStatus.dwCurrentState   = SERVICE_RUNNING;
        gblDIMConfigInfo.ServiceStatus.dwControlsAccepted = 
                                              SERVICE_ACCEPT_STOP
                                            | SERVICE_ACCEPT_PAUSE_CONTINUE
                                            | SERVICE_ACCEPT_SHUTDOWN;

        SetEvent( gblhEventDDMServiceState );

        break;

    case SERVICE_CONTROL_DEVICEEVENT:

        if ( ( gblDIMConfigInfo.ServiceStatus.dwCurrentState ==
                                                        SERVICE_STOP_PENDING)
            ||
            ( gblDIMConfigInfo.ServiceStatus.dwCurrentState ==
                                                        SERVICE_STOPPED ))
        {
            break;
        }

        if ( lpEventData != NULL)
        {
            DEV_BROADCAST_DEVICEINTERFACE* pInfo =
                                (DEV_BROADCAST_DEVICEINTERFACE*)lpEventData;


            if ( pInfo->dbcc_devicetype == DBT_DEVTYP_DEVICEINTERFACE )
            {
                ROUTER_INTERFACE_OBJECT * pIfObject = NULL;

                if ( ( dwEventType == DBT_DEVICEARRIVAL ) ||
                     ( dwEventType == DBT_DEVICEREMOVECOMPLETE ) )
                {
                    //
                    // Extract GUID from the \device\GUID name
                    //

                    LPWSTR lpwszGUIDStart  = wcsrchr( pInfo->dbcc_name, L'{' );
                    LPWSTR lpwszGUIDEnd    = wcsrchr( pInfo->dbcc_name, L'}' );

                    if ( lpwszGUIDStart != NULL )
                    {
                        WCHAR  wchGUIDSaveLast = *(lpwszGUIDEnd+1);

                        EnterCriticalSection( &(gblInterfaceTable.CriticalSection));

                        *(lpwszGUIDEnd+1) = (WCHAR)NULL;

                        pIfObject = IfObjectGetPointerByName( lpwszGUIDStart, FALSE );

                        *(lpwszGUIDEnd+1) = wchGUIDSaveLast;

                        if ( dwEventType == DBT_DEVICEARRIVAL )
                        {
                            if ( pIfObject == NULL )
                            {
                                DIMTRACE1("Device arrival:[%ws]", lpwszGUIDStart );

                                RegLoadInterfaces( lpwszGUIDStart, TRUE );
                            }
                        }
                        else 
                        {
                            if ( pIfObject != NULL )
                            {
                                DIMTRACE1("Device removed:[%ws]", lpwszGUIDStart );

                                IfObjectDeleteInterfaceFromTransport( pIfObject, PID_IP );

                                IfObjectDeleteInterfaceFromTransport( pIfObject, PID_IPX);

                                IfObjectRemove( pIfObject->hDIMInterface );
                            }
                        }

                        LeaveCriticalSection( &(gblInterfaceTable.CriticalSection) );
                    }
                }
            }
        }

        break;

    case RAS_CONTROL_CONFIGURE:

        //
        //  Code for dynamic configuration of RAP
        //
    
        DIMTRACE( "Received Remote Access Policy change control message" );

        {
            //
            // thread needs to be COM initialized
            //

            HRESULT hResult = CoInitializeEx( NULL, COINIT_MULTITHREADED );

            if ( SUCCEEDED( hResult ) )
            {
                //
                // configure, doesn't matter if the API call fails
                //

                ConfigureIas();
            
                CoUninitialize();
            }
        }

        break;

    case SERVICE_CONTROL_POWEREVENT:

        switch( dwEventType )
        {
            case PBT_APMQUERYSTANDBY:
            case PBT_APMQUERYSUSPEND:

                //
                // Check if the this is running on a workstation
                //

                if (gblOsVersionInfo.wProductType == VER_NT_WORKSTATION)
                {
                    //
                    // DIM has no say in the hibernation process on a 
                    // workstation
                    //

                    break;
                }
                
                
                //
                // If we are running as an RRAS server, on a Server platform,
                // refuse the hibernate.
                //
                // This is not the best possible response, but given that
                // connectivity is liable to break if an RRAS server is 
                // hibernated it is reasonable to prevent it (for now).
                //
                // In addition, the design of RTM currently (.net server)
                // causes a delayed deletion of routes from the TCP/IP stack
                // on a hibernate (routes deleted from IP Router Manager prior
                // to hibernate are deleted from the stack when coming out of
                // hibernate) leading to the loss of routes and hence 
                // connectivity.  Until the design of RTM is fixed rejecting
                // the hibernate query is the best solution.
                //

                if ( gblDIMConfigInfo.dwRouterRole &
                     ( ROUTER_ROLE_LAN | ROUTER_ROLE_WAN | ROUTER_ROLE_RAS ) )
                {
                    dwRetCode = ERROR_ACTIVE_CONNECTIONS;
                }

                break;

            case PBT_APMRESUMECRITICAL:
            default:
            {
                break;
            }
        }

        break;

    case SERVICE_CONTROL_NETBINDADD:
    case SERVICE_CONTROL_NETBINDREMOVE:
    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:

        break;

    default:

        return( ERROR_CALL_NOT_IMPLEMENTED );

        break;
    }

    DimAnnounceServiceStatus();

    return( dwRetCode );
}

//**
//
// Call:        ServiceMain
//
// Returns:     None
//
// Description: This is the main procedure for the DIM Server Service. It
//              will be called when the service is supposed to start itself.
//              It will do all service wide initialization.
//
VOID
ServiceMain(
    IN DWORD    argc,   // Command line arguments. Will be ignored.
    IN LPWSTR * lpwsServiceArgs
)
{
    DIM_INFO    DimInfo;
    DWORD       dwRetCode;
    DWORD       dwIndex;
    DWORD       (*DDMServiceInitialize)( DIM_INFO * );
    VOID        (*DDMServicePostListens)( VOID *) = NULL;

    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( lpwsServiceArgs );

    gbldwDIMComponentsLoaded &= ~(DIM_SERVICE_STOPPED);

    gblDIMConfigInfo.hServiceStatus = RegisterServiceCtrlHandlerEx(
                                            TEXT("remoteaccess"),
                                            ServiceHandlerEx,
                                            NULL );

    if ( !gblDIMConfigInfo.hServiceStatus )
    {
        return;
    }

    gblDIMConfigInfo.ServiceStatus.dwServiceType  = SERVICE_WIN32_SHARE_PROCESS;
    gblDIMConfigInfo.ServiceStatus.dwCurrentState = SERVICE_START_PENDING;

    DimAnnounceServiceStatus();

    gblDIMConfigInfo.dwTraceId = TraceRegisterA( "Router" );

    try {
        //
        // Mutex around the interface table
        //

        InitializeCriticalSection( &(gblInterfaceTable.CriticalSection) );

        //
        // Mutex around setting router identity attributes
        //

        InitializeCriticalSection( &(gblDIMConfigInfo.CSRouterIdentity) );
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return;
    }

    
    gblDIMConfigInfo.hLogEvents = RouterLogRegister( DIM_SERVICE_NAME );

    /*
    if ( gblDIMConfigInfo.hLogEvents == NULL )
    {
        DimCleanUp( GetLastError() );
        return;
    }
    */

    //
    // Create DIM private heap
    //

    gblDIMConfigInfo.hHeap = HeapCreate( 0, DIM_HEAP_INITIAL_SIZE,
                                            DIM_HEAP_MAX_SIZE );

    if ( gblDIMConfigInfo.hHeap == NULL )
    {
        DimCleanUp( GetLastError() );
        return;
    }


    //
    // Lead DIM parameters from the registry
    //

    if ( ( dwRetCode = RegLoadDimParameters() ) != NO_ERROR )
    {
        DimCleanUp( dwRetCode );
        return;
    }

    DimAnnounceServiceStatus();

    //
    // Create event that will be used by DIM to make sure all the Router
    // Managers have shut down when DIM is stopping.
    //

    gblhEventRMState = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( gblhEventRMState == (HANDLE)NULL )
    {
        DimCleanUp( GetLastError() );
        return;
    }

    //
    // Announce that we have successfully started.
    //

    gblDIMConfigInfo.ServiceStatus.dwCurrentState      = SERVICE_RUNNING;
    gblDIMConfigInfo.ServiceStatus.dwCheckPoint        = 0;
    gblDIMConfigInfo.ServiceStatus.dwWaitHint          = 0;
    gblDIMConfigInfo.ServiceStatus.dwControlsAccepted  = 
                                              SERVICE_ACCEPT_STOP
                                            | SERVICE_ACCEPT_POWEREVENT
                                            | SERVICE_ACCEPT_PAUSE_CONTINUE
                                            | SERVICE_ACCEPT_SHUTDOWN;

    DimAnnounceServiceStatus();

    //
    // Load the router managers
    //

    gbldwDIMComponentsLoaded |= DIM_RMS_LOADED;

    if ( ( dwRetCode = RegLoadRouterManagers() ) != NO_ERROR )
    {
        DimCleanUp( dwRetCode );
        return;
    }

#if (WINVER >= 0x0501)

    if ( gblDIMConfigInfo.dwNumRouterManagers == 0)
    {
        DimCleanUp( ROUTERLOG_IPX_TRANSPORT_NOT_SUPPORTED );
        return;
    }

#endif

    //
    // Create event that will be used to shutdown the DIM service
    //

    gblhEventTerminateDIM = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( gblhEventTerminateDIM == (HANDLE)NULL )
    {
        DimCleanUp( GetLastError() );
        return;
    }

    //
    // If not in LAN only mode load the Demand Dial Manager DLL
    //

    if ( gblDIMConfigInfo.dwRouterRole != ROUTER_ROLE_LAN ) 
    {
        //
        // Create event that will be used by DDM to notify DIM that it has
        // terminated
        //

        gblhEventDDMTerminated = CreateEvent( NULL, TRUE, FALSE, NULL );

        if ( gblhEventDDMTerminated == (HANDLE)NULL )
        {
            DimCleanUp( GetLastError() );
            return;
        }

        //
        // Create event that will be used by DIM to notify DDM that there is
        // is a change is state of this service
        //

        gblhEventDDMServiceState = CreateEvent( NULL, FALSE, FALSE, NULL );

        if ( gblhEventDDMServiceState == (HANDLE)NULL )
        {
            DimCleanUp( GetLastError() );
            return;
        }

        if ( ( dwRetCode = RegLoadDDM() ) != NO_ERROR )
        {
            DimCleanUp( dwRetCode );
            return;
        }

        //
        // Initialize the DDM
        //

        DDMServiceInitialize = (DWORD(*)( DIM_INFO * ))
                                    GetDDMEntryPoint( "DDMServiceInitialize" );

        if ( DDMServiceInitialize == NULL )
        {
            DimCleanUp( ERROR_PROC_NOT_FOUND );
            return;
        }

        DDMServicePostListens = (VOID(*)( VOID *))
                                    GetDDMEntryPoint( "DDMServicePostListens" );

        if ( DDMServicePostListens == NULL )
        {
            DimCleanUp( ERROR_PROC_NOT_FOUND );
            return;
        }

        DimInfo.pInterfaceTable         = &gblInterfaceTable;
        DimInfo.pRouterManagers         = gblRouterManagers;
        DimInfo.dwNumRouterManagers     = gblDIMConfigInfo.dwNumRouterManagers;
        DimInfo.pServiceStatus          = &gblDIMConfigInfo.ServiceStatus;
        DimInfo.phEventDDMServiceState  = &gblhEventDDMServiceState;
        DimInfo.phEventDDMTerminated    = &gblhEventDDMTerminated;
        DimInfo.dwTraceId               = gblDIMConfigInfo.dwTraceId;
        DimInfo.hLogEvents              = gblDIMConfigInfo.hLogEvents;
        DimInfo.lpdwNumThreadsRunning   =
                                    &(gblDIMConfigInfo.dwNumThreadsRunning);
        DimInfo.lpfnIfObjectAllocateAndInit     = IfObjectAllocateAndInit;
        DimInfo.lpfnIfObjectGetPointerByName    = IfObjectGetPointerByName;
        DimInfo.lpfnIfObjectGetPointer          = IfObjectGetPointer;
        DimInfo.lpfnIfObjectRemove              = IfObjectRemove;
        DimInfo.lpfnIfObjectInsertInTable       = IfObjectInsertInTable;
        DimInfo.lpfnIfObjectWANDeviceInstalled  = IfObjectWANDeviceInstalled;
        DimInfo.lpfnRouterIdentityObjectUpdate
                                      = RouterIdentityObjectUpdateDDMAttributes;

        if ( ( dwRetCode = DDMServiceInitialize( &DimInfo ) ) != NO_ERROR )
        {
            DimCleanUp( dwRetCode );
            return;
        }

        gbldwDIMComponentsLoaded |= DIM_DDM_LOADED;

        //
        // Initialize random number generator that is used by DDM
        //

        srand( GetTickCount() );
    }

    //
    // What is the platform
    //

    RtlGetNtProductType( &(gblDIMConfigInfo.NtProductType) );

    //
    // Need this to do GUID to friendly name mapping
    //

    MprConfigServerConnect( NULL, &gblDIMConfigInfo.hMprConfig );

    //
    // Add the various interfaces
    //

    dwRetCode = RegLoadInterfaces( NULL, gblDIMConfigInfo.dwNumRouterManagers ); 

    if ( dwRetCode != NO_ERROR )
    {
        DimCleanUp( dwRetCode );
        return;
    }

    if ( ( dwRetCode = DimSecObjCreate() ) != NO_ERROR )
    {
        DimCleanUp( dwRetCode );
        return;
    }

    gbldwDIMComponentsLoaded |= DIM_SECOBJ_LOADED;

    dwRetCode = DimInitializeRPC( 
                        gblDIMConfigInfo.dwRouterRole == ROUTER_ROLE_LAN );

    if ( dwRetCode != NO_ERROR )
    {
        DimCleanUp( dwRetCode );
        return;
    }

    gbldwDIMComponentsLoaded |= DIM_RPC_LOADED;

    //
    // Start a timer that when fired will go out and plumb the router attributes
    //

    if ( RtlCreateTimerQueue( &(gblDIMConfigInfo.hTimerQ) ) == STATUS_SUCCESS )
    {
        //
        // We wait 5 minutes in the case where we are the router providing
        // connectivity to the DC so we wait for all routing protocols to
        // stabalize and propagate.
        //

        gblDIMConfigInfo.dwRouterIdentityDueTime = 5*60*1000;

        RtlCreateTimer( gblDIMConfigInfo.hTimerQ,
                     &(gblDIMConfigInfo.hTimer),
                     RouterIdentityObjectUpdateAttributes,
                     (PVOID)TRUE,
                     gblDIMConfigInfo.dwRouterIdentityDueTime,
                     0,  
                     WT_EXECUTEDEFAULT );
    }

    GetSystemTimeAsFileTime( (FILETIME*)&gblDIMConfigInfo.qwStartTime );

    if ( gbldwDIMComponentsLoaded & DIM_DDM_LOADED )
    {
        if (DDMServicePostListens) //to keep prefast happy
            DDMServicePostListens(NULL);
    }

    //
    // Set the RAS bit for NetServerEnum
    //

    if( I_ScSetServiceBits( gblDIMConfigInfo.hServiceStatus,
                            SV_TYPE_DIALIN_SERVER,
                            TRUE,
                            TRUE,
                            NULL) == FALSE )
    {
        DimCleanUp( GetLastError() );

        return;
    }

    //
    // Register for device notifications.  Specifically, we're interested
    // in network adapters coming and going.  If this fails, we proceed
    // anyway.
    //
    
    {
        DEV_BROADCAST_DEVICEINTERFACE PnpFilter;

        ZeroMemory( &PnpFilter, sizeof( PnpFilter ) );
        PnpFilter.dbcc_size         = sizeof( PnpFilter );
        PnpFilter.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
        PnpFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;

        gblDIMConfigInfo.hDeviceNotification = 
                                RegisterDeviceNotification(
                                        (HANDLE)gblDIMConfigInfo.hServiceStatus,
                                        &PnpFilter,
                                        DEVICE_NOTIFY_SERVICE_HANDLE );

        if ( gblDIMConfigInfo.hDeviceNotification == NULL )
        {
            dwRetCode = GetLastError();

            DIMTRACE1( "RegisterDeviceNotification failed with error %d",
                        dwRetCode );

            DimCleanUp( dwRetCode );

            return;
        }
    }

    //
    // Register for media sense events
    //

    if ( ( dwRetCode = MediaSenseRegister( TRUE ) ) != NO_ERROR )
    {
        DIMTRACE1( "Registering for media sense failed with dwRetCode = %d", 
                   dwRetCode );

        dwRetCode = NO_ERROR;
    }

    //
    // Register for BIND/UNBIND notifications
    //

    if ( ( dwRetCode = BindingsNotificationsRegister( TRUE ) ) != NO_ERROR )
    {
        DIMTRACE1( "Registering for bindings notifications failed with dwRetCode = %d",
                   dwRetCode );

        dwRetCode = NO_ERROR;
    }


    DIMTRACE( "Multi-Protocol Router started successfully" );

    gbldwDIMComponentsLoaded |= DIM_SERVICE_STARTED;

    //
    // Notify all router managers that all interfaces have been loaded at
    // service start.
    //

    for (dwIndex = 0; dwIndex < gblDIMConfigInfo.dwNumRouterManagers; dwIndex++)
    {
        gblRouterManagers[dwIndex].DdmRouterIf.RouterBootComplete();
    }

    //
    // If we are a demand dial router
    //

    if ( gblDIMConfigInfo.dwRouterRole & ROUTER_ROLE_WAN )
    {
        DWORD dwXportIndex = GetTransportIndex( PID_IP );

        //
        // Initate persistent demand dial conenctions
        //

        DWORD (*IfObjectInitiatePersistentConnections)() =
         (DWORD(*)())GetDDMEntryPoint("IfObjectInitiatePersistentConnections");

        IfObjectInitiatePersistentConnections();

        //
        // If a WAN device is installed and IP is installed then we 
        // start advertizing on specific multicast address so as to make this
        // router discoverable
        //

        IfObjectWANDeviceInstalled( DimInfo.fWANDeviceInstalled );
    }

    //
    // Just wait here for DIM to terminate.
    //

    dwRetCode = WaitForSingleObject( gblhEventTerminateDIM, INFINITE );

    if ( dwRetCode == WAIT_FAILED )
    {
        dwRetCode = GetLastError();
    }
    else
    {
        dwRetCode = NO_ERROR;
    }

    DimCleanUp( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\dim\server\mibapi.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    mibapi.c
//
// Description: Contains code to manipulate MIB apis
//
// History:     May 11,1995	    NarenG		Created original version.
//
#include "dimsvcp.h"
#include <dimsvc.h>     // Generated by MIDL

//**
//
// Call:        RMIBEntryCreate
//
// Returns:     NO_ERROR - Success
//              ERROR_UNKNOWN_PROTOCOL_ID or non-zero return code from
//              MIBEntryCreate
//
// Description: Simply called the appropriate router manager to do the real 
//              work.
//
DWORD
RMIBEntryCreate(
    IN  MIB_SERVER_HANDLE           hMibServer,
    IN  DWORD                       dwPid,
    IN  DWORD                       dwRoutingPid,
    IN  PDIM_MIB_ENTRY_CONTAINER    pInfoStruct
)
{
    DWORD dwAccessStatus;
    DWORD dwRetCode        = NO_ERROR;
    DWORD dwTransportIndex = GetTransportIndex( dwPid );

    //
    // Check if caller has access
    //

    if ( DimSecObjAccessCheck( DIMSVC_ALL_ACCESS, &dwAccessStatus) != NO_ERROR)
    {
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwTransportIndex == (DWORD)-1 )
    {
        return( ERROR_UNKNOWN_PROTOCOL_ID );
    }

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBEntryCreate( 
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry );

    return( dwRetCode );
}

//**
//
// Call:        RMIBEntryDelete
//
// Returns:     NO_ERROR - Success
//              ERROR_UNKNOWN_PROTOCOL_ID or non-zero return code from
//              MIBEntryCreate
//
// Description: Simply called the appropriate router manager to do the real 
//              work.
//
DWORD
RMIBEntryDelete(
    IN  MIB_SERVER_HANDLE           hMibServer,
    IN  DWORD                       dwPid,
    IN  DWORD                       dwRoutingPid,
    IN  PDIM_MIB_ENTRY_CONTAINER    pInfoStruct
)
{
    DWORD dwAccessStatus;
    DWORD dwRetCode        = NO_ERROR;
    DWORD dwTransportIndex = GetTransportIndex( dwPid );

    //
    // Check if caller has access
    //

    if ( DimSecObjAccessCheck( DIMSVC_ALL_ACCESS, &dwAccessStatus) != NO_ERROR)
    {
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwTransportIndex == (DWORD)-1 )
    {
        return( ERROR_UNKNOWN_PROTOCOL_ID );
    }

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBEntryDelete(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry );

    return( dwRetCode );
}

//**
//
// Call:        RMIBEntrySet
//
// Returns:     NO_ERROR - Success
//              ERROR_UNKNOWN_PROTOCOL_ID or non-zero return code from
//              MIBEntryCreate
//
// Description: Simply called the appropriate router manager to do the real 
//              work.
//
DWORD
RMIBEntrySet(
    IN  MIB_SERVER_HANDLE           hMibServer,
    IN  DWORD                       dwPid,
    IN  DWORD                       dwRoutingPid,
    IN  PDIM_MIB_ENTRY_CONTAINER    pInfoStruct
)
{
    DWORD dwAccessStatus;
    DWORD dwRetCode        = NO_ERROR;
    DWORD dwTransportIndex = GetTransportIndex( dwPid );

    //
    // Check if caller has access
    //

    if ( DimSecObjAccessCheck( DIMSVC_ALL_ACCESS, &dwAccessStatus) != NO_ERROR)
    {
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwTransportIndex == (DWORD)-1 )
    {
        return( ERROR_UNKNOWN_PROTOCOL_ID );
    }

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBEntrySet(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry );

    return( dwRetCode );
}

//**
//
// Call:        RMIBEntryGet
//
// Returns:     NO_ERROR - Success
//              ERROR_UNKNOWN_PROTOCOL_ID 
//              ERROR_NOT_ENOUGH_MEMORY
//              non-zero return code from MIBEntryGet
//
// Description: Simply called the appropriate router manager to do the real
//              work.
//
//
DWORD
RMIBEntryGet(
    IN      MIB_SERVER_HANDLE           hMibServer,
    IN      DWORD                       dwPid,
    IN      DWORD                       dwRoutingPid,
    IN OUT  PDIM_MIB_ENTRY_CONTAINER    pInfoStruct
)
{
    LPBYTE pOutputBuf       = NULL;
    DWORD  dwOutputBufSize  = 0;
    DWORD  dwRetCode        = NO_ERROR;
    DWORD  dwTransportIndex = GetTransportIndex( dwPid );

    //
    // We do not do access check for MIB Get apis since these are called
    // by iphlpapi.dll which can be run in the user's context. It is assumed
    // that the various mibs will take care of their own security.
    //

    if ( dwTransportIndex == (DWORD)-1 )
    {
        return( ERROR_UNKNOWN_PROTOCOL_ID );
    }

    //
    // First get the size of the required entry
    //

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBEntryGet(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                NULL );

    if ( dwRetCode != ERROR_INSUFFICIENT_BUFFER )
    {
        return( dwRetCode );
    }

    pOutputBuf = MIDL_user_allocate( dwOutputBufSize );

    if ( pOutputBuf == NULL )
    {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBEntryGet(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                pOutputBuf );
    if ( dwRetCode == NO_ERROR )
    {
        pInfoStruct->dwMibOutEntrySize = dwOutputBufSize;
        pInfoStruct->pMibOutEntry      = pOutputBuf;
    }
    else
    {
        pInfoStruct->dwMibOutEntrySize = 0;
        pInfoStruct->pMibOutEntry      = NULL;
        MIDL_user_free( pOutputBuf );
    }

    return( dwRetCode );
}

//**
//
// Call:        RMIBEntryGetFirst
//
// Returns:     NO_ERROR - Success
//              ERROR_UNKNOWN_PROTOCOL_ID
//              ERROR_NOT_ENOUGH_MEMORY
//              non-zero return code from MIBEntryGetFirst
//
// Description: Simply called the appropriate router manager to do the real
//              work.
//
//
DWORD
RMIBEntryGetFirst(
    IN      MIB_SERVER_HANDLE           hMibServer,
    IN      DWORD                       dwPid,
    IN      DWORD                       dwRoutingPid,
    IN OUT  PDIM_MIB_ENTRY_CONTAINER    pInfoStruct
)
{
    LPBYTE pOutputBuf       = NULL;
    DWORD  dwOutputBufSize  = 0;
    DWORD  dwRetCode        = NO_ERROR;
    DWORD  dwTransportIndex = GetTransportIndex( dwPid );

    //
    // We do not do access check for MIB Get apis since these are called
    // by iphlpapi.dll which can be run in the user's context. It is assumed
    // that the various mibs will take care of their own security.
    //

    if ( dwTransportIndex == (DWORD)-1 )
    {
        return( ERROR_UNKNOWN_PROTOCOL_ID );
    }

    //
    // First get the size of the required entry
    //

    dwRetCode=gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBEntryGetFirst(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                NULL );

    if ( dwRetCode != ERROR_INSUFFICIENT_BUFFER )
    {
        return( dwRetCode );
    }

    pOutputBuf = MIDL_user_allocate( dwOutputBufSize );

    if ( pOutputBuf == NULL )
    {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    dwRetCode=gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBEntryGetFirst(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                pOutputBuf );

    if ( dwRetCode == NO_ERROR )
    {
        pInfoStruct->dwMibOutEntrySize = dwOutputBufSize;
        pInfoStruct->pMibOutEntry      = pOutputBuf;
    }
    else
    {
        pInfoStruct->dwMibOutEntrySize = 0;
        pInfoStruct->pMibOutEntry      = NULL;
        MIDL_user_free( pOutputBuf );
    }

    return( dwRetCode );
}

//**
//
// Call:        RMIBEntryGetNext
//
// Returns:     NO_ERROR - Success
//              ERROR_UNKNOWN_PROTOCOL_ID
//              ERROR_NOT_ENOUGH_MEMORY
//              non-zero return code from MIBEntryGetNext
//
// Description: Simply called the appropriate router manager to do the real
//              work.
//
DWORD
RMIBEntryGetNext(
    IN      MIB_SERVER_HANDLE           hMibServer,
    IN      DWORD                       dwPid,
    IN      DWORD                       dwRoutingPid,
    IN OUT  PDIM_MIB_ENTRY_CONTAINER    pInfoStruct
)
{
    LPBYTE pOutputBuf       = NULL;
    DWORD  dwOutputBufSize  = 0;
    DWORD  dwRetCode        = NO_ERROR;
    DWORD  dwTransportIndex = GetTransportIndex( dwPid );

    //
    // We do not do access check for MIB Get apis since these are called
    // by iphlpapi.dll which can be run in the user's context. It is assumed
    // that the various mibs will take care of their own security.
    //

    if ( dwTransportIndex == (DWORD)-1 )
    {
        return( ERROR_UNKNOWN_PROTOCOL_ID );
    }

    //
    // First get the size of the required entry
    //

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBEntryGetNext(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                NULL );

    if ( dwRetCode != ERROR_INSUFFICIENT_BUFFER )
    {
        return( dwRetCode );
    }

    pOutputBuf = MIDL_user_allocate( dwOutputBufSize );

    if ( pOutputBuf == NULL )
    {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBEntryGetNext(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                pOutputBuf );

    if ( dwRetCode == NO_ERROR )
    {
        pInfoStruct->dwMibOutEntrySize = dwOutputBufSize;
        pInfoStruct->pMibOutEntry      = pOutputBuf;
    }
    else
    {
        pInfoStruct->dwMibOutEntrySize = 0;
        pInfoStruct->pMibOutEntry      = NULL;
        MIDL_user_free( pOutputBuf ); 
    }

    return( dwRetCode );
}

//**
//
// Call:        RMIBGetTrapInfo
//
// Returns:     NO_ERROR - Success
//              ERROR_UNKNOWN_PROTOCOL_ID
//              ERROR_NOT_ENOUGH_MEMORY
//              non-zero return code from MIBGetTrapInfo
//
// Description: Simply called the appropriate router manager to do the real
//              work.
//
DWORD
RMIBGetTrapInfo(
    IN      MIB_SERVER_HANDLE           hMibServer,
    IN      DWORD                       dwPid,
    IN      DWORD                       dwRoutingPid,
    IN OUT  PDIM_MIB_ENTRY_CONTAINER    pInfoStruct
)
{
    LPBYTE pOutputBuf       = NULL;
    DWORD  dwOutputBufSize  = 0;
    DWORD  dwRetCode        = NO_ERROR;
    DWORD  dwTransportIndex = GetTransportIndex( dwPid );

    //
    // We do not do access check for MIB Get apis since these are called
    // by iphlpapi.dll which can be run in the user's context. It is assumed
    // that the various mibs will take care of their own security.
    //

    if ( dwTransportIndex == (DWORD)-1 )
    {
        return( ERROR_UNKNOWN_PROTOCOL_ID );
    }

    if (gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBGetTrapInfo == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // First get the size of the required entry
    //

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBGetTrapInfo(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                NULL );

    if ( dwRetCode != ERROR_INSUFFICIENT_BUFFER )
    {
        return( dwRetCode );
    }

    pOutputBuf = MIDL_user_allocate( dwOutputBufSize );

    if ( pOutputBuf == NULL )
    {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBGetTrapInfo(
                                                dwRoutingPid,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                pOutputBuf );

    if ( dwRetCode == NO_ERROR )
    {
        pInfoStruct->dwMibOutEntrySize = dwOutputBufSize;
        pInfoStruct->pMibOutEntry      = pOutputBuf;
    }
    else
    {
        pInfoStruct->dwMibOutEntrySize = 0;
        pInfoStruct->pMibOutEntry      = NULL;
        MIDL_user_free( pOutputBuf ); 
    }

    return( dwRetCode );
}

//**
//
// Call:        RMIBSetTrapInfo
//
// Returns:     NO_ERROR - Success
//              ERROR_UNKNOWN_PROTOCOL_ID
//              ERROR_NOT_ENOUGH_MEMORY
//              non-zero return code from MIBSetTrapInfo
//              Failures from OpenProcess
//              Failures from DuplicateHandle
//
// Description: Simply called the appropriate router manager to do the real
//              work.
//
DWORD
RMIBSetTrapInfo(
    IN      MIB_SERVER_HANDLE           hMibServer,
    IN      DWORD                       dwPid,
    IN      DWORD                       dwRoutingPid,
    IN      ULONG_PTR                   hEvent,
    IN      DWORD                       dwClientProcessId,
    IN OUT  PDIM_MIB_ENTRY_CONTAINER    pInfoStruct
)
{
    DWORD  dwAccessStatus;
    LPBYTE pOutputBuf       = NULL;
    DWORD  dwOutputBufSize  = 0;
    DWORD  dwRetCode        = NO_ERROR;
    HANDLE hDuplicatedEvent;
    HANDLE hClientProcess;
    DWORD  dwTransportIndex = GetTransportIndex( dwPid );

    //
    // Check if caller has access
    //

    if ( DimSecObjAccessCheck( DIMSVC_ALL_ACCESS, &dwAccessStatus) != NO_ERROR)
    {
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwTransportIndex == (DWORD)-1 )
    {
        return( ERROR_UNKNOWN_PROTOCOL_ID );
    }

    if (gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBSetTrapInfo == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Get process handle of the caller of this API
    //

    hClientProcess = OpenProcess(
                            STANDARD_RIGHTS_REQUIRED | SPECIFIC_RIGHTS_ALL,
                            FALSE, 
                            dwClientProcessId);

    if ( hClientProcess == NULL )
    {
        return( GetLastError() );
    }

    //
    // Duplicate the handle to the event
    //

    if ( !DuplicateHandle(  hClientProcess, 
                            (HANDLE)hEvent, 
                            GetCurrentProcess(), 
                            &hDuplicatedEvent,
                            0, 
                            FALSE, 
                            DUPLICATE_SAME_ACCESS ) )
    {
        CloseHandle( hClientProcess );

        return( GetLastError() );
    }

    CloseHandle( hClientProcess );

    //
    // First get the size of the required entry
    //

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBSetTrapInfo(
                                                dwRoutingPid,
                                                hDuplicatedEvent,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                NULL );

    if ( dwRetCode != ERROR_INSUFFICIENT_BUFFER )
    {
        CloseHandle( hDuplicatedEvent );

        return( dwRetCode );
    }

    pOutputBuf = MIDL_user_allocate( dwOutputBufSize );

    if ( pOutputBuf == NULL )
    {
        CloseHandle( hDuplicatedEvent );

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    dwRetCode = gblRouterManagers[dwTransportIndex].DdmRouterIf.MIBSetTrapInfo(
                                                dwRoutingPid,
                                                hDuplicatedEvent,
                                                pInfoStruct->dwMibInEntrySize,
                                                pInfoStruct->pMibInEntry,
                                                &dwOutputBufSize,
                                                pOutputBuf );

    if ( dwRetCode == NO_ERROR )
    {
        pInfoStruct->dwMibOutEntrySize = dwOutputBufSize;
        pInfoStruct->pMibOutEntry      = pOutputBuf;
    }
    else
    {
        pInfoStruct->dwMibOutEntrySize = 0;
        pInfoStruct->pMibOutEntry      = NULL;
        MIDL_user_free( pOutputBuf ); 
        CloseHandle( hDuplicatedEvent );
    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\dim\server\rpc.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    rpc.c
//
// Description: Contains code to initialize and terminate RPC
//
// History:     May 11,1995	    NarenG		Created original version.
//

#include "dimsvcp.h"
#include <rpc.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>

#include "dimsvc_s.c"


//**
//
// Call:    DimInitializeRPC
//
// Returns: NO_ERROR    - success
//          ERROR_NOT_ENOUGH_MEMORY
//          nonzero returns from RPC APIs
//                  RpcServerRegisterIf()
//                  RpcServerUseProtseqEp()
//
// Description: Starts an RPC Server, adds the address (or port/pipe),
//              and adds the interface (dispatch table).
//
DWORD
DimInitializeRPC( 
    IN BOOL fLanOnlyMode
)
{
    RPC_STATUS           RpcStatus;

    //
    // RASMAN is not around so we need to do this stuff
    //

    if ( fLanOnlyMode )
    {
        //
        // Ignore the second argument for now.
        //

        RpcStatus = RpcServerUseProtseqEpW( TEXT("ncacn_np"),
                                        10,
                                        TEXT("\\PIPE\\ROUTER"),
                                        NULL );

        //
        // We need to ignore the RPC_S_DUPLICATE_ENDPOINT error
        // in case this DLL is reloaded within the same process.
        // 

        if ( RpcStatus != RPC_S_OK && RpcStatus != RPC_S_DUPLICATE_ENDPOINT)    
        {
            return( RpcStatus );
        }

    }

    RpcStatus = RpcServerRegisterIfEx( dimsvc_ServerIfHandle, 
                                       0, 
                                       0,
                                       RPC_IF_AUTOLISTEN,
                                       RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                       NULL );

    if ( ( RpcStatus == RPC_S_OK ) || ( RpcStatus == RPC_S_ALREADY_LISTENING ) )
    {
        return( NO_ERROR );
    }
    else
    {
        return( RpcStatus );
    }
}

//**
//
// Call:        DimTerminateRPC
//
// Returns:     none
//
// Description: Deletes the interface.
//
VOID
DimTerminateRPC(
    VOID
)
{
    RPC_STATUS status;
    
    if(RPC_S_OK != (status = RpcServerUnregisterIf( 
                                dimsvc_ServerIfHandle, 0, 0 )))
    {
#if DBG
        DbgPrint("REMOTEACCESS: DimTerminateRPC returned error"
                 " 0x%x\n", status);
#endif
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\dim\server\rpbk.h ===
/*
    File: rpbk.h

    Defines functions that operate on the router phonebook portions
    of the mpr structures.

*/

#ifndef __MPRDIM_RPBK_H
#define __MPRDIM_RPBK_H

//
// Utilities
//
DWORD 
RpbkGetPhonebookPath(
    OUT PWCHAR* ppszPath);

DWORD
RpbkFreePhonebookPath(
    IN PWCHAR pszPath);

//
// Entry api's
//
DWORD 
RpbkOpenEntry(
    IN  ROUTER_INTERFACE_OBJECT* pIfObject, 
    OUT PHANDLE                  phEntry );
    
DWORD 
RpbkCloseEntry( 
    IN HANDLE hEntry );
    
DWORD
RpbkSetEntry( 
    IN  DWORD            dwLevel,
    IN  LPBYTE           pInterfaceData );
    
DWORD 
RpbkDeleteEntry(
    IN PWCHAR            pszInterfaceName );
    
DWORD
RpbkEntryToIfDataSize(
    IN  HANDLE  hEntry, 
    IN  DWORD   dwLevel,
    OUT LPDWORD lpdwcbSizeOfData );
    
DWORD
RpbkEntryToIfData( 
    IN  HANDLE           hEntry, 
    IN  DWORD            dwLevel,
    OUT LPBYTE           pInterfaceData );

//
// Subentry api's
//

DWORD 
RpbkOpenSubEntry(
    IN  ROUTER_INTERFACE_OBJECT* pIfObject, 
    IN  DWORD  dwIndex,    
    OUT PHANDLE phSubEntry );
    
DWORD 
RpbkCloseSubEntry( 
    IN HANDLE hSubEntry );
    
DWORD
RpbkSetSubEntry( 
    IN  PWCHAR pszInterface,
    IN  DWORD  dwIndex,
    IN  DWORD  dwLevel,
    OUT LPBYTE pInterfaceData );
    
DWORD
RpbkSubEntryToDevDataSize(
    IN  HANDLE  hSubEntry, 
    IN  DWORD   dwLevel,
    OUT LPDWORD lpdwcbSizeOfData );
    
DWORD
RpbkSubEntryToDevData( 
    IN  HANDLE  hSubEntry, 
    IN  DWORD   dwLevel,
    OUT LPBYTE  pDeviceData );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\dim\server\rtridobj.c ===
/********************************************************************/
/**          Copyright(c) 1985-1997 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    rtridobj
//
// Description: Support routines to manipulate router information in the
//              router object
//
// History:     Feb 11,1998         NarenG              Created original version.
//

#include "dimsvcp.h"

#include <activeds.h>
#include <adsi.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lmapibuf.h>
#define SECURITY_WIN32
#include <security.h>
#include <routprot.h>
#include <rtinfo.h>

#include <dimsvc.h>     // Generated by MIDL

#define ROUTER_IDENTITY_OBJECT_NAME    TEXT("CN=RouterIdentity")
#define ROUTER_OBJECT_ATTRIBUTE_NAME   TEXT("MsRRASAttribute")
#define ROUTER_LDAP_PREFIX             TEXT("LDAP://")
#define ROUTER_CN_COMMA                TEXT(",")
#define ROUTER_IDENTITY_CLASS          TEXT("RRASAdministrationConnectionPoint")

LPWSTR RouterObjectAttributeNames[] =
{
    ROUTER_OBJECT_ATTRIBUTE_NAME
};

//**
//
// Call:        RouterIdentityObjectOpen
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given the machine name of the router, will return the handle
//              to the router's administration service point or router object.
//
DWORD
RouterIdentityObjectOpen(
    IN  LPWSTR      lpwszRouterName,
    IN  DWORD       dwRouterType,
    OUT HANDLE *    phObjectRouterIdentity
)
{
    DWORD                               dwRetCode;
    LPWSTR                              lpwszRouterIdentityObjectPath = NULL;
    LPWSTR                              lpwszComputerObjectPath       = NULL;
    DOMAIN_CONTROLLER_INFO *            pDomainControllerInfo         = NULL;
    HRESULT                             hResult  = HRESULT_FROM_WIN32(NO_ERROR);
    DWORD                               dwCharCount;

    do
    {
        dwRetCode = DsGetDcName( NULL,
                                 NULL,
                                 NULL,
                                 NULL,   
                                 DS_DIRECTORY_SERVICE_REQUIRED |
                                 DS_WRITABLE_REQUIRED,
                                 &pDomainControllerInfo );

        if ( dwRetCode != NO_ERROR )
        {
            TracePrintfExA( gblDIMConfigInfo.dwTraceId, 
                            TRACE_DIM, "No DS located, DsGetDcName()=%d",
                            dwRetCode );
            break;
        }

        if ( !( pDomainControllerInfo->Flags & DS_DS_FLAG ) )
        {
            TracePrintfExA( gblDIMConfigInfo.dwTraceId, 
                            TRACE_DIM, "No DS located");

            dwRetCode = ERROR_DOMAIN_CONTROLLER_NOT_FOUND;

            break;
        }

        //
        // Get the CN of the router object
        //

        dwCharCount = 200;

        lpwszComputerObjectPath = LOCAL_ALLOC(LPTR, dwCharCount*sizeof(WCHAR));
        if (lpwszComputerObjectPath == NULL)
        {
            TracePrintfExA( gblDIMConfigInfo.dwTraceId, 
                            TRACE_DIM, "Memory exhausted -- unable to continue");

            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;

            break;
        }

        if ( !GetComputerObjectName( NameFullyQualifiedDN,
                                     lpwszComputerObjectPath,
                                     &dwCharCount ) )
        {
            //
            // We failed for some other reason
            //

            LPWSTR lpwsComputerObjectPathReAlloc = 
                            LOCAL_REALLOC( lpwszComputerObjectPath,
                                          (++dwCharCount)*sizeof(WCHAR) );

            if ( lpwsComputerObjectPathReAlloc == NULL )
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;

                break;
            }

            lpwszComputerObjectPath = lpwsComputerObjectPathReAlloc;

            if ( !GetComputerObjectName( NameFullyQualifiedDN,
                                         lpwszComputerObjectPath,
                                         &dwCharCount ) )
            {
                dwRetCode = GetLastError();

                break;
            }
        }

        lpwszRouterIdentityObjectPath =
            LOCAL_ALLOC( LPTR,
                        sizeof( ROUTER_LDAP_PREFIX )            +
                        sizeof( ROUTER_IDENTITY_OBJECT_NAME )   +
                        sizeof( ROUTER_CN_COMMA )               +
                        ((wcslen( lpwszComputerObjectPath )+1)* sizeof(WCHAR)));

        if ( lpwszRouterIdentityObjectPath == NULL )
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wcscpy( lpwszRouterIdentityObjectPath, ROUTER_LDAP_PREFIX );
        wcscat( lpwszRouterIdentityObjectPath, ROUTER_IDENTITY_OBJECT_NAME );
        wcscat( lpwszRouterIdentityObjectPath, ROUTER_CN_COMMA );
        wcscat( lpwszRouterIdentityObjectPath, lpwszComputerObjectPath );

        //
        // Try to open the router identity object
        //

        hResult =  ADSIOpenDSObject( lpwszRouterIdentityObjectPath,
                                     NULL,
                                     NULL,
                                     0,
                                     phObjectRouterIdentity );

        if ( hResult == HRESULT_FROM_WIN32( ERROR_DS_NO_SUCH_OBJECT ) )
        {
            HANDLE          hObjectComputer;
            ADS_ATTR_INFO   AttributeEntries[2];
            ADSVALUE        ObjectClassAttributeValue;
            ADSVALUE        msRRASAttributeValues[3];
            WCHAR           wchmsRRASAttributeValue1[50];
            WCHAR           wchmsRRASAttributeValue2[50];
            WCHAR           wchmsRRASAttributeValue3[50];
            DWORD           dwIndex = 0;

            //
            // If we failed because it doesn't exist, then create it
            //

            wcscpy( lpwszRouterIdentityObjectPath, ROUTER_LDAP_PREFIX );
            wcscat( lpwszRouterIdentityObjectPath, lpwszComputerObjectPath );

            hResult =  ADSIOpenDSObject(
                                     lpwszRouterIdentityObjectPath,
                                     NULL,
                                     NULL,
                                     0,
                                     &hObjectComputer );

            if ( FAILED( hResult ) )
            {
                dwRetCode = HRESULT_CODE( hResult );

                break;
            }

            //
            // Set up attributes for this object
            //

            ObjectClassAttributeValue.dwType = ADSTYPE_CASE_IGNORE_STRING;
            ObjectClassAttributeValue.CaseIgnoreString = ROUTER_IDENTITY_CLASS;

            AttributeEntries[0].pszAttrName     = TEXT("ObjectClass");
            AttributeEntries[0].dwControlCode   = ADS_ATTR_APPEND;
            AttributeEntries[0].dwADsType       = ADSTYPE_CASE_IGNORE_STRING;
            AttributeEntries[0].pADsValues      = &ObjectClassAttributeValue;
            AttributeEntries[0].dwNumValues     = 1;

            if ( dwRouterType & ROUTER_ROLE_RAS )
            {
                wsprintf( wchmsRRASAttributeValue1,
                          TEXT("%d:%d:%d"),
                          DIM_MS_VENDOR_ID,
                          6,
                          602 );

                msRRASAttributeValues[dwIndex].dwType =
                                                    ADSTYPE_CASE_IGNORE_STRING;
                msRRASAttributeValues[dwIndex].CaseIgnoreString =
                                                    wchmsRRASAttributeValue1;
                dwIndex++;
            }

            if ( dwRouterType & ROUTER_ROLE_LAN )
            {
                wsprintf( wchmsRRASAttributeValue2,
                          TEXT("%d:%d:%d"),
                          DIM_MS_VENDOR_ID,
                          6,
                          601 );

                msRRASAttributeValues[dwIndex].dwType =
                                                   ADSTYPE_CASE_IGNORE_STRING;
                msRRASAttributeValues[dwIndex].CaseIgnoreString =
                                                   wchmsRRASAttributeValue2;
                dwIndex++;
            }

            if ( dwRouterType & ROUTER_ROLE_WAN )
            {
                wsprintf( wchmsRRASAttributeValue3,
                          TEXT("%d:%d:%d"),
                          DIM_MS_VENDOR_ID,
                          6,
                          603 );

                msRRASAttributeValues[dwIndex].dwType =
                                                   ADSTYPE_CASE_IGNORE_STRING;
                msRRASAttributeValues[dwIndex].CaseIgnoreString =
                                                   wchmsRRASAttributeValue3;

                dwIndex++;
            }

            AttributeEntries[1].pszAttrName     = ROUTER_OBJECT_ATTRIBUTE_NAME;
            AttributeEntries[1].dwControlCode   = ADS_ATTR_APPEND;
            AttributeEntries[1].dwADsType       = ADSTYPE_CASE_IGNORE_STRING;
            AttributeEntries[1].pADsValues      = msRRASAttributeValues;
            AttributeEntries[1].dwNumValues     = dwIndex;

            hResult =  ADSICreateDSObject(
                                    hObjectComputer,
                                    ROUTER_IDENTITY_OBJECT_NAME,
                                    AttributeEntries,
                                    2 );

            ADSICloseDSObject( hObjectComputer );

            if ( FAILED( hResult ) )
            {
                dwRetCode = HRESULT_CODE( hResult );

                break;
            }

            wcscpy(lpwszRouterIdentityObjectPath, ROUTER_LDAP_PREFIX);
            wcscat(lpwszRouterIdentityObjectPath, ROUTER_IDENTITY_OBJECT_NAME);
            wcscat(lpwszRouterIdentityObjectPath, ROUTER_CN_COMMA );
            wcscat(lpwszRouterIdentityObjectPath, lpwszComputerObjectPath);

            //
            // Now open it to get the handle
            //

            hResult =  ADSIOpenDSObject(
                                     lpwszRouterIdentityObjectPath,
                                     NULL,
                                     NULL,
                                     0,
                                     phObjectRouterIdentity );
        }

        if ( FAILED( hResult ) )
        {
            dwRetCode = HRESULT_CODE( hResult );
        }
        else
        {
            dwRetCode = NO_ERROR;
        }

    } while( FALSE );

    if ( lpwszRouterIdentityObjectPath != NULL )
    {
        LOCAL_FREE( lpwszRouterIdentityObjectPath );
    }

    if ( lpwszComputerObjectPath != NULL )
    {
        LOCAL_FREE( lpwszComputerObjectPath );
    }

    if ( pDomainControllerInfo != NULL )
    {
        NetApiBufferFree( pDomainControllerInfo );
    }

    TracePrintfExA( gblDIMConfigInfo.dwTraceId, TRACE_DIM, 
                    "RouterIdentityObjectOpen returned %d", dwRetCode );

    return( dwRetCode );
}

//**
//
// Call:        RouterIdentityObjectClose
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will close the router object.
//
VOID
RouterIdentityObjectClose(
    IN HANDLE hObjectRouterIdentity
)
{
    ADSICloseDSObject( hObjectRouterIdentity );
}

//**
//
// Call:        RouterIdentityObjectGetAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will retreive all the attributes of the give Router object
//
DWORD
RouterIdentityObjectGetAttributes(
    IN      HANDLE      hRouterIdentityObject,
    OUT     HANDLE *    phRouterIdentityAttributes

)
{
    ADS_ATTR_INFO *     pADSAttributes          = NULL;
    DWORD               dwNumAttributesReturned = 0;
    HRESULT             hResult;

    *phRouterIdentityAttributes = NULL;

    //
    // Get all the attributes in this object
    //

    hResult = ADSIGetObjectAttributes(
                    hRouterIdentityObject,
                    RouterObjectAttributeNames,
                    sizeof( RouterObjectAttributeNames ) / sizeof( LPWSTR ),
                    &pADSAttributes,
                    &dwNumAttributesReturned );

    if ( FAILED( hResult ) )
    {
        return( HRESULT_CODE( hResult ) );
    }

    if ( dwNumAttributesReturned > 0 )
    {
        *phRouterIdentityAttributes = (HANDLE)pADSAttributes;
    }
    else
    {
        TracePrintfExA( gblDIMConfigInfo.dwTraceId, 
                        TRACE_DIM, "No attributes in identity object" );
    }

    return( NO_ERROR );
}


//**
//
// Call:        RouterIdentityObjectIsValueSet
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will check to see if a give value exists for the attribute
//
BOOL
RouterIdentityObjectIsValueSet(
    IN HANDLE   hRouterIdentityAttributes,
    IN DWORD    dwVendorId,
    IN DWORD    dwType,
    IN DWORD    dwValue
)
{
    ADS_ATTR_INFO * pADSAttributes = (ADS_ATTR_INFO *)hRouterIdentityAttributes;
    DWORD           dwIndex;
    WCHAR           wchValue[100];
    CHAR            chValue[100];

    if ( pADSAttributes == NULL )
    {
        return( FALSE );   
    }

    if (_wcsicmp(pADSAttributes->pszAttrName, ROUTER_OBJECT_ATTRIBUTE_NAME)!=0)
    {
        return( FALSE );
    }

    wsprintf( wchValue, TEXT("%d:%d:%d"), dwVendorId, dwType, dwValue );
    sprintf( chValue, "%d:%d:%d", dwVendorId, dwType, dwValue );
    
    for( dwIndex = 0; dwIndex < pADSAttributes->dwNumValues; dwIndex ++ )
    {
        ADSVALUE * pADsValue = &(pADSAttributes->pADsValues[dwIndex]);

        switch (pADsValue->dwType) {

            case ADSTYPE_PROV_SPECIFIC:
            {
                ADS_PROV_SPECIFIC *pProviderSpecific;
                pProviderSpecific = &pADsValue->ProviderSpecific;
                if (strncmp( pProviderSpecific->lpValue, chValue, 
                    pProviderSpecific->dwLength) == 0 )
                {
                    return( TRUE );
                }
                break;
            }
            
            case ADSTYPE_CASE_IGNORE_STRING:
                if ( _wcsicmp( pADsValue->CaseIgnoreString, wchValue ) == 0 )
                {
                    return( TRUE );
                }
                break;

            default : //same as ADSTYPE_CASE_IGNORE_STRING
                if ( _wcsicmp( pADsValue->CaseIgnoreString, wchValue ) == 0 )
                {
                    return( TRUE );
                }
                break;
        }
    }

    return( FALSE );
}

//**
//
// Call:        RouterIdentityObjectGetValue
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will get the specified indexed value from the router object
//
DWORD
RouterIdentityObjectGetValue(
    IN HANDLE   hRouterIdentityAttributes,
    IN DWORD    dwValueIndex,
    IN DWORD *  lpdwVendorId,
    IN DWORD *  lpdwType,
    IN DWORD *  lpdwValue
)
{
    ADS_ATTR_INFO * pADSAttributes = (ADS_ATTR_INFO *)hRouterIdentityAttributes;
    DWORD           dwIndex;
    ADSVALUE *      pADsValue;

    if ( pADSAttributes == NULL )
    {
        return( ERROR_DS_NO_ATTRIBUTE_OR_VALUE );   
    }

    if (_wcsicmp(pADSAttributes->pszAttrName, ROUTER_OBJECT_ATTRIBUTE_NAME)!=0)
    {
        return( ERROR_DS_NO_ATTRIBUTE_OR_VALUE );   
    }

    if ( dwValueIndex >= pADSAttributes->dwNumValues )
    {
        *lpdwVendorId   = (DWORD)-1;
        *lpdwType       = (DWORD)-1;
        *lpdwValue      = (DWORD)-1;

        return( NO_ERROR );
    }

    pADsValue = &(pADSAttributes->pADsValues[dwValueIndex]);

    switch (pADsValue->dwType) {

        case ADSTYPE_PROV_SPECIFIC:
        {
            ADS_PROV_SPECIFIC *pProviderSpecific;
            CHAR            chValue[100];
            pProviderSpecific = &pADsValue->ProviderSpecific;

            strncpy(chValue, pProviderSpecific->lpValue,
                pProviderSpecific->dwLength);
            chValue[pProviderSpecific->dwLength] = 0;
            
            if (scanf( chValue,
                         TEXT("%d:%d:%d"),
                         lpdwVendorId,
                         lpdwType,
                         lpdwValue ) == EOF)
            {
                return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }          
            break;
        }
        default :
        {
            if (swscanf( pADsValue->CaseIgnoreString,
                         TEXT("%d:%d:%d"),
                         lpdwVendorId,
                         lpdwType,
                         lpdwValue ) == EOF)
            {
                return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }
            
            break;
        }
    }
    
    return( NO_ERROR );
}

//**
//
// Call:        RouterIdentityObjectAddRemoveValue
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will add or remove a value from the multi-valued attribute
//
DWORD
RouterIdentityObjectAddRemoveValue(
    IN  HANDLE      hRouterIdentityObject,
    IN  DWORD       dwVendorId,
    IN  DWORD       dwType,
    IN  DWORD       dwValue,
    IN  BOOL        fAdd
)
{
    HRESULT         hResult;
    DWORD           dwNumAttributesModified;
    ADS_ATTR_INFO   AttributeEntry[1];
    WCHAR           wchValue[100];
    ADSVALUE        AttributeValue;

    wsprintf( wchValue, TEXT("%d:%d:%d"), dwVendorId, dwType, dwValue );

    AttributeValue.dwType           = ADSTYPE_CASE_IGNORE_STRING;
    AttributeValue.CaseIgnoreString = wchValue;

    AttributeEntry[0].pszAttrName   = ROUTER_OBJECT_ATTRIBUTE_NAME;
    AttributeEntry[0].dwControlCode = ( fAdd )
                                            ? ADS_ATTR_APPEND
                                            : ADS_ATTR_DELETE;
    AttributeEntry[0].dwADsType     = ADSTYPE_CASE_IGNORE_STRING;
    AttributeEntry[0].pADsValues    = &AttributeValue;
    AttributeEntry[0].dwNumValues   = 1;

    if ( fAdd )
    {
        TracePrintfExA( gblDIMConfigInfo.dwTraceId,
                        TRACE_DIM,
                        "Adding value %ws in the Router Identity Object",
                        wchValue );
    }
    else
    {
        TracePrintfExA( gblDIMConfigInfo.dwTraceId,
                        TRACE_DIM,
                        "Removing value %ws in the Router Identity Object",
                        wchValue );
    }

    hResult = ADSISetObjectAttributes( hRouterIdentityObject,
                                       AttributeEntry,
                                       1,
                                       &dwNumAttributesModified );
    if ( FAILED( hResult ) )
    {
        return( HRESULT_CODE( hResult ) );
    }

    return( NO_ERROR );
}

//**
//
// Call:        RouterIdentityObjectFreeAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Frees allocated set of attributes returned by
//              RouterIdentityObjectGetAttributes
//
VOID
RouterIdentityObjectFreeAttributes(
    IN HANDLE   hRouterIdentityAttributes
)
{
    if ( hRouterIdentityAttributes != NULL )
    {
        FreeADsMem( (ADS_ATTR_INFO *)hRouterIdentityAttributes );
    }
}

//**
//
// Call:        RouterIdentityObjectSetAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will gather all current configuration information and plumb it
//              into the router identity object in the DS.
//
//              Note: 
//                  This API first takes the lock on the interface table,
//                  then it takes the lock around the device table to get the
//                  installed device types. Hence this API MUST NOT be called
//                  while holding a lock around the interface table since this
//                  violates the design principal of first holding the 
//                  device lock before holding the interface lock.
//
DWORD
RouterIdentityObjectSetAttributes(
    IN HANDLE  hRouterIdentityObject
)
{
    DWORD                       dwRetCode;
    HANDLE                      hRouterIdentityAttributes;
    DWORD                       dwIndex = 0;
    ROUTER_IDENTITY_ATTRIBUTE   RIAttributes[DIM_MAX_IDENTITY_ATTRS];
    DWORD                       dwXportIndex;

    //
    // Obtain router identity information plumbed in the DS currently
    //

    dwRetCode = RouterIdentityObjectGetAttributes(
                                                hRouterIdentityObject,
                                                &hRouterIdentityAttributes );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    //
    // Now get the current running configuration of the router
    //

    //
    // First, what is our role?
    //

    if ( gblDIMConfigInfo.dwRouterRole & ROUTER_ROLE_LAN )
    {
        RIAttributes[dwIndex].dwVendorId = DIM_MS_VENDOR_ID;
        RIAttributes[dwIndex].dwType     = 6;
        RIAttributes[dwIndex].dwValue    = 601;

        dwIndex++;
    }

    if ( gblDIMConfigInfo.dwRouterRole & ROUTER_ROLE_RAS )
    {
        RIAttributes[dwIndex].dwVendorId = DIM_MS_VENDOR_ID;
        RIAttributes[dwIndex].dwType     = 6;
        RIAttributes[dwIndex].dwValue    = 602;

        dwIndex++;
    }

    if ( gblDIMConfigInfo.dwRouterRole & ROUTER_ROLE_WAN )
    {
        RIAttributes[dwIndex].dwVendorId = DIM_MS_VENDOR_ID;
        RIAttributes[dwIndex].dwType     = 6;
        RIAttributes[dwIndex].dwValue    = 603;

        dwIndex++;
    }

    //
    // Check if a LAN interface exists
    //

    EnterCriticalSection( &(gblInterfaceTable.CriticalSection) );

    if ( IfObjectDoesLanInterfaceExist() )
    {
        RIAttributes[dwIndex].dwVendorId    = 311;
        RIAttributes[dwIndex].dwType        = 6;
        RIAttributes[dwIndex].dwValue       = 712;

        dwIndex++;
    }

    //
    // Get all IP routing protocols
    //

    if ( ( dwXportIndex = GetTransportIndex( PID_IP ) ) != (DWORD)-1 )
    {
        BYTE * pGlobalInfo      = NULL;
        DWORD  dwGlobalInfoSize = 0;

        dwRetCode =
                gblRouterManagers[dwXportIndex].DdmRouterIf.GetGlobalInfo(
                                            pGlobalInfo,
                                            &dwGlobalInfoSize );

        if ( dwRetCode == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( dwGlobalInfoSize > 0 )
            {
                pGlobalInfo = LOCAL_ALLOC( LPTR, dwGlobalInfoSize );

                if ( pGlobalInfo != NULL )
                {
                    dwRetCode =
                    gblRouterManagers[dwXportIndex].DdmRouterIf.GetGlobalInfo(
                                            pGlobalInfo,
                                            &dwGlobalInfoSize );

                    if ( dwRetCode == NO_ERROR )
                    {
                        DWORD                   dwRoutingProtIndex;
                        RTR_INFO_BLOCK_HEADER * pInfoBlock =
                                        (RTR_INFO_BLOCK_HEADER *)(pGlobalInfo);

                        for ( dwRoutingProtIndex = 0;
                              dwRoutingProtIndex < pInfoBlock->TocEntriesCount;
                              dwRoutingProtIndex++ )
                        {
                            DWORD dwVendorId;

                            RIAttributes[dwIndex].dwType     
                            = TYPE_FROM_PROTO_ID(
                            pInfoBlock->TocEntry[dwRoutingProtIndex].InfoType );

                            // 
                            // Add unicast and multicast protocol ids
                            //
                            if ( ( RIAttributes[dwIndex].dwType 
                                                        == PROTO_TYPE_UCAST ) ||
                                 ( RIAttributes[dwIndex].dwType 
                                                        == PROTO_TYPE_MCAST ) )
                            {
                                DWORD dwProtoId;
                                
                                dwVendorId = VENDOR_FROM_PROTO_ID(

                                pInfoBlock->TocEntry[dwRoutingProtIndex].InfoType );

                                dwProtoId = PROTO_FROM_PROTO_ID(

                                pInfoBlock->TocEntry[dwRoutingProtIndex].InfoType );

                                //
                                // Nothing defined for dhcp relay agent
                                //
                                if ( dwProtoId == PROTO_IP_BOOTP )
                                {
                                    continue;
                                }
                                
                                if ( ( dwVendorId == PROTO_VENDOR_MS0 ) ||
                                     ( dwVendorId == PROTO_VENDOR_MS1 ) ||
                                     ( dwVendorId == PROTO_VENDOR_MS2 ) )
                                {
                                    RIAttributes[dwIndex].dwVendorId = 311;
                                }
                                else
                                {
                                    RIAttributes[dwIndex].dwVendorId = dwVendorId;
                                }

                                RIAttributes[dwIndex].dwValue    
                                = PROTO_FROM_PROTO_ID(
                                pInfoBlock->TocEntry[dwRoutingProtIndex].InfoType );

                                dwIndex++;
                            }

                            // 
                            // Add ms0 protocols
                            //
                            else if (RIAttributes[dwIndex].dwType == 
                                        PROTO_TYPE_MS0 )
                            {
                                DWORD dwProtoId;
                                
                                dwVendorId = VENDOR_FROM_PROTO_ID(

                                pInfoBlock->TocEntry[dwRoutingProtIndex].InfoType );

                                dwProtoId = PROTO_FROM_PROTO_ID(

                                pInfoBlock->TocEntry[dwRoutingProtIndex].InfoType );

                                // 
                                // Check for NAT
                                // Vendor= MS, TypeMajor= 6, TypeMinor= 604
                                //
                                if ( ( dwVendorId == PROTO_VENDOR_MS1 ) && 
                                     ( dwProtoId  == PROTO_IP_NAT)
                                   )
                                {
                                    RIAttributes[dwIndex].dwVendorId = 
                                        PROTO_VENDOR_MS1;
                                    RIAttributes[dwIndex].dwType     = 
                                        6;
                                    RIAttributes[dwIndex].dwValue    = 
                                        604;
                                        
                                    dwIndex++;
                                }
                            }
                        }
                    }

                    LOCAL_FREE( pGlobalInfo );
                }
            }
        }

        // As per amritanr, if you have the ip router installed,
        // then ip forwarding is always turned on.
        //
        // Ip Fwd'ing Enabled: Vendor= MS, TypeMajor= 6, TypeMinor= 501
        //
        RIAttributes[dwIndex].dwVendorId = PROTO_VENDOR_MS1;
        RIAttributes[dwIndex].dwType     = 6;
        RIAttributes[dwIndex].dwValue    = 501;
        dwIndex++;
    }

    //
    // Get all IPX routing protocols
    //

    if ( ( dwXportIndex = GetTransportIndex( PID_IPX ) ) != (DWORD)-1 )
    {
        // All nt5 ipx routers support rip and sap.  Go ahead 
        // and attributes for both.
        //

        // IPXRIP: Vendor= MS, TypeMajor= 5, TypeMinor= 1
        //
        RIAttributes[dwIndex].dwVendorId = PROTO_VENDOR_MS1;
        RIAttributes[dwIndex].dwType     = 5;
        RIAttributes[dwIndex].dwValue    = 1;
        dwIndex++;

        // IPXSAP: Vendor= MS, TypeMajor= 5, TypeMinor= 2
        //
        RIAttributes[dwIndex].dwVendorId = PROTO_VENDOR_MS1;
        RIAttributes[dwIndex].dwType     = 5;
        RIAttributes[dwIndex].dwValue    = 2;
        dwIndex++;

        // Ipx Fwd'ing Enabled: Vendor= MS, TypeMajor= 6, TypeMinor= 502
        //
        RIAttributes[dwIndex].dwVendorId = PROTO_VENDOR_MS1;
        RIAttributes[dwIndex].dwType     = 6;
        RIAttributes[dwIndex].dwValue    = 502;
        dwIndex++;
    }

    LeaveCriticalSection( &(gblInterfaceTable.CriticalSection) );

    RIAttributes[dwIndex].dwVendorId    = (DWORD)-1;
    RIAttributes[dwIndex].dwType        = (DWORD)-1;
    RIAttributes[dwIndex].dwValue       = (DWORD)-1;

    //
    // Get all the RAS server information
    //

    if ( gblDIMConfigInfo.dwRouterRole & ( ROUTER_ROLE_RAS | ROUTER_ROLE_WAN ) )
    {
        DWORD (*DDMGetIdentityAttributes)( ROUTER_IDENTITY_ATTRIBUTE * ) =
            (DWORD(*)( ROUTER_IDENTITY_ATTRIBUTE * ))
                                GetDDMEntryPoint("DDMGetIdentityAttributes");

        if(NULL != DDMGetIdentityAttributes)
        {
            dwRetCode = DDMGetIdentityAttributes( RIAttributes );
        }
        else
        {
            ASSERT(FALSE);
        }
    }

    //
    // Now obtain walk thru the current configration an make sure that
    // all of it is plumbed. If it is not then go ahead and set it.
    //

    for ( dwIndex = 0;
          RIAttributes[dwIndex].dwVendorId != (DWORD)-1;
          dwIndex++ )
    {
        //
        // If this attribute is not set, then set it
        //

        if ( !RouterIdentityObjectIsValueSet(
                                        hRouterIdentityAttributes,
                                        RIAttributes[dwIndex].dwVendorId,
                                        RIAttributes[dwIndex].dwType,
                                        RIAttributes[dwIndex].dwValue ) )
        {
            RouterIdentityObjectAddRemoveValue(
                                        hRouterIdentityObject,
                                        RIAttributes[dwIndex].dwVendorId,
                                        RIAttributes[dwIndex].dwType,
                                        RIAttributes[dwIndex].dwValue,
                                        TRUE );
        }
    }

    //
    // Now walk thru and remove attributes in the DS that are not in our
    // current configuration. We reconcile all attributes with
    // dwType values 0,1 or 5, and with dwVendorId of 311 (Microsoft) with
    // dwType value of 6.
    //

    for ( dwIndex = 0;; dwIndex++ )
    {
        DWORD dwVendorId;
        DWORD dwType;
        DWORD dwValue;
        DWORD dwCurrentValueIndex;
        BOOL  fInCurrentConfiguration = FALSE;

        dwRetCode = RouterIdentityObjectGetValue( hRouterIdentityAttributes,
                                                  dwIndex,
                                                  &dwVendorId,
                                                  &dwType,
                                                  &dwValue );

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        //
        // We are done
        //

        if ( dwVendorId == (DWORD)-1 )
        {
            break;
        }

        //
        // Ignore these types
        //

        if ( ( dwType != 0 ) && ( dwType != 1 ) && ( dwType != 5 ) &&
             ( !( ( dwType == 6 ) && ( dwVendorId == DIM_MS_VENDOR_ID ) ) ) )
        {
            continue;
        }

        //
        // Now check to see it this attribute is a member of our current
        // configuration
        //


        for ( dwCurrentValueIndex = 0;
              RIAttributes[dwCurrentValueIndex].dwVendorId != (DWORD)-1;
              dwCurrentValueIndex++ )
        {
            if ( (RIAttributes[dwCurrentValueIndex].dwVendorId == dwVendorId)&&
                 (RIAttributes[dwCurrentValueIndex].dwType     == dwType )   &&
                 (RIAttributes[dwCurrentValueIndex].dwValue    == dwValue ) )
            {
                //
                // Attribute is part of current configuration
                //

                fInCurrentConfiguration = TRUE;
            }
        }

        if ( !fInCurrentConfiguration )
        {
            //
            // Remove this attribute from the DS since it is not in our
            // current configuration
            //


            dwRetCode = RouterIdentityObjectAddRemoveValue(
                                                        hRouterIdentityObject,
                                                        dwVendorId,
                                                        dwType,
                                                        dwValue,
                                                        FALSE );
            if ( dwRetCode != NO_ERROR )
            {
                break;
            }
        }
    }

    RouterIdentityObjectFreeAttributes( hRouterIdentityAttributes );

    return( dwRetCode );
}

//**
//
// Call:        RouterIdentityObjectUpdateAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will be called to update the attributes currently set in the DS
//              or to set it if it was not able to be set originally
//
VOID
RouterIdentityObjectUpdateAttributes(
    IN PVOID    pParameter,
    IN BOOLEAN  fTimedOut
)
{
    DWORD dwRetCode        = NO_ERROR;
    BOOL  fCalledFromTimer = (BOOL)PtrToUlong(pParameter);

    //
    // Make sure service is in the running state
    //

    if ( gblDIMConfigInfo.ServiceStatus.dwCurrentState != SERVICE_RUNNING )
    {
        if(fCalledFromTimer)
        {
            //
            // Delete the timer if theres one queued before we
            // return from here otherwise DeleteTimerQ in
            // DimCleanup will hang.
            //
            RtlDeleteTimer(gblDIMConfigInfo.hTimerQ,
                           gblDIMConfigInfo.hTimer, 
                           NULL);
            gblDIMConfigInfo.hTimer = NULL;
        }
        
        return;
    }

    if ( fCalledFromTimer )
    {
        //
        // Always call DeleteTimer otherwise we will leak memory
        //

        RtlDeleteTimer( gblDIMConfigInfo.hTimerQ,
                        gblDIMConfigInfo.hTimer,
                        NULL );

        gblDIMConfigInfo.hTimer = NULL;                        

        //
        // Called from timer thread so we first try to obtain a handle to
        // the router idenitity object
        //

        dwRetCode = RouterIdentityObjectOpen(
                              NULL,
                              ( gblDIMConfigInfo.dwRouterRole ),
                              &(gblDIMConfigInfo.hObjectRouterIdentity) );

        if ( ( dwRetCode != NO_ERROR ) ||
             ( gblDIMConfigInfo.hObjectRouterIdentity == NULL ) ) 
        {
            //
            // Check to see if service is stopping and create a timer for this
            // only if it is in running state.
            //
            if(gblDIMConfigInfo.ServiceStatus.dwCurrentState == SERVICE_RUNNING)
            {
                //
                // Couldn't access DC, try again later for a max of once a day
                //

                if ( gblDIMConfigInfo.dwRouterIdentityDueTime < 24*60*60*1000 )
                {
                    gblDIMConfigInfo.dwRouterIdentityDueTime *= 2;
                }

                TracePrintfExA(
                           gblDIMConfigInfo.dwTraceId,
                           TRACE_DIM,
                           "Could not access DC, will set router attributes later");

                RtlCreateTimer( gblDIMConfigInfo.hTimerQ,
                                &(gblDIMConfigInfo.hTimer),
                                RouterIdentityObjectUpdateAttributes,
                                (PVOID)TRUE,
                                gblDIMConfigInfo.dwRouterIdentityDueTime,
                                0,
                                WT_EXECUTEDEFAULT );
            }                            

            return;
        }

        //
        // Otherwise we succeeded in opening the router identity object
        // and we set the identity information below.
        //
    }
    else
    {
        //
        // If we do not have a handle for the router identity object, then
        // either we are in the process of obtaining it or we are not
        // a member of the DS, so in both cases simply return
        //

        if ( gblDIMConfigInfo.hObjectRouterIdentity == NULL )
        {
            return;
        }
    }

    //
    // Can be called from different threads at the same time so we need
    // Critical section around this code so that we do not have 2 writers to 
    // the DS at the same time that trample on each other. ex could be called
    // by DDM thread as well as the timer thread.
    //

    EnterCriticalSection( &(gblDIMConfigInfo.CSRouterIdentity) );

    TracePrintfExA( gblDIMConfigInfo.dwTraceId,
                    TRACE_DIM,
                    "Setting router attributes in the identity object" );

    RouterIdentityObjectSetAttributes( gblDIMConfigInfo.hObjectRouterIdentity );

    LeaveCriticalSection( &(gblDIMConfigInfo.CSRouterIdentity) );
}

//**
//
// Call:        RouterIdentityObjectUpdateAttributesForDD
//
// Returns:     None
//
// Description:
//
VOID
RouterIdentityObjectUpdateAttributesForDDM(
    PVOID pParameter
)
{
    RouterIdentityObjectUpdateAttributes( (PVOID)NULL, FALSE );
}

//**
//
// Call:        RouterIdentityObjectUpdateDDMAttributes
//
// Returns:     None
//
// Description: Export this call to DDM. When DDM calls this call, it already
//              has taken a lock around it's device table and cannot make
//              the call to update attributes directly because the   
//              RouterIdentityObjectUpdateAttributes call takes the
//              lock around the RouterIdentity object leading to a deadlock.
//              Hence we execute this call asynchronously using a worker
//              thread.
//              
//
VOID
RouterIdentityObjectUpdateDDMAttributes(
    VOID
)
{
    RtlQueueWorkItem( RouterIdentityObjectUpdateAttributesForDDM,
                      NULL,
                      WT_EXECUTEDEFAULT );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\dim\server\security.c ===
/*********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	        **/
/*********************************************************************/

//***
//
// Filename:	security.c
//
// Description: This module contains code that will create and delete the
//		        security object. It will also contain access checking calls.
//
// History:
//	            June 21,1995.	NarenG		Created original version.
//
// NOTE: ??? The lpdwAccessStatus parameter for AccessCheckAndAuditAlarm
//	         returns junk. ???
//
#include "dimsvcp.h"
#include <rpc.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>

typedef struct _DIM_SECURITY_OBJECT 
{

    LPWSTR		            lpwsObjectName;
    LPWSTR		            lpwsObjectType;
    GENERIC_MAPPING	        GenericMapping;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;

} DIM_SECURITY_OBJECT, PDIM_SECURITY_OBJECT;

static DIM_SECURITY_OBJECT DimSecurityObject;

#define DIMSVC_SECURITY_OBJECT		TEXT("DimSvcAdminApi");
#define DIMSVC_SECURITY_OBJECT_TYPE	TEXT("Security");



//**
//
// Call:	    DimSecObjCreate
//
// Returns:	    NO_ERROR	- success
//		        ERROR_NOT_ENOUGH_MEMORY
//		        non-zero returns from security functions
//
// Description: This procedure will set up the security object that will
//		        be used to check to see if an RPC client is an administrator
//		        for the local machine.
//
DWORD
DimSecObjCreate( 
	VOID 
)
{
    PSID			        pAdminSid 	     = NULL;
    PSID			        pLocalSystemSid  = NULL;
    PSID 			        pServerOpSid     = NULL;
    PACL			        pDacl		     = NULL;
    HANDLE			        hProcessToken    = NULL;
    PULONG			        pSubAuthority;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNtAuth = SECURITY_NT_AUTHORITY;
    SECURITY_DESCRIPTOR	    SecurityDescriptor;
    DWORD			        dwRetCode;
    DWORD			        cbDaclSize;

    //
    // Set up security object
    //

    DimSecurityObject.lpwsObjectName = DIMSVC_SECURITY_OBJECT;
    DimSecurityObject.lpwsObjectType = DIMSVC_SECURITY_OBJECT_TYPE;

    //
    // Generic mapping structure for the security object
    // All generic access types are allowed API access.
    //

    DimSecurityObject.GenericMapping.GenericRead =  STANDARD_RIGHTS_READ |
	    					    DIMSVC_ALL_ACCESS;

    DimSecurityObject.GenericMapping.GenericWrite = STANDARD_RIGHTS_WRITE |
	    					    DIMSVC_ALL_ACCESS;

    DimSecurityObject.GenericMapping.GenericExecute = 
						    STANDARD_RIGHTS_EXECUTE |
						    DIMSVC_ALL_ACCESS;

    DimSecurityObject.GenericMapping.GenericAll =   DIMSVC_ALL_ACCESS;

    do 
    {

	    dwRetCode = NO_ERROR;

        //
    	// Set up the SID for the admins that will be allowed to have
    	// access. This SID will have 2 sub-authorities
    	// SECURITY_BUILTIN_DOMAIN_RID and DOMAIN_ALIAS_ADMIN_RID.
    	//

    	pAdminSid = (PSID)LOCAL_ALLOC( LPTR, GetSidLengthRequired( 2 ) );

    	if ( pAdminSid == NULL ) 
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

    	if ( !InitializeSid( pAdminSid, &SidIdentifierNtAuth, 2 ) ) 
        {
	        dwRetCode = GetLastError();
	        break;
	    }
    
        //
    	// Set the sub-authorities 
    	//

    	pSubAuthority  = GetSidSubAuthority( pAdminSid, 0 );
    	*pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    	pSubAuthority  = GetSidSubAuthority( pAdminSid, 1 );
    	*pSubAuthority = DOMAIN_ALIAS_RID_ADMINS;
    
        //
	    // Create the server operators SID
	    //
    	pServerOpSid = (PSID)LOCAL_ALLOC( LPTR, GetSidLengthRequired( 2 ) );

    	if ( pServerOpSid == NULL ) 
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

    	if ( !InitializeSid( pServerOpSid, &SidIdentifierNtAuth, 2 ) ) 
        {
	        dwRetCode = GetLastError();
	        break;
	    }
    
        //
    	// Set the sub-authorities 
    	//

    	pSubAuthority  = GetSidSubAuthority( pServerOpSid, 0 );
    	*pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    	pSubAuthority  = GetSidSubAuthority( pServerOpSid, 1 );
    	*pSubAuthority = DOMAIN_ALIAS_RID_SYSTEM_OPS;

        //
    	// Create the LocalSystemSid which will be the owner and the primary 
    	// group of the security object. 
    	//

    	pLocalSystemSid = (PSID)LOCAL_ALLOC( LPTR, GetSidLengthRequired( 1 ) );

    	if ( pLocalSystemSid == NULL ) 
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

    	if ( !InitializeSid( pLocalSystemSid, &SidIdentifierNtAuth, 1 ) ) 
        {
	        dwRetCode = GetLastError();
	        break;
	    }

        //
    	// Set the sub-authorities 
    	//

    	pSubAuthority = GetSidSubAuthority( pLocalSystemSid, 0 );
    	*pSubAuthority = SECURITY_LOCAL_SYSTEM_RID;

        //
    	// Set up the DACL that will allow admins with the above SID all access
    	// It should be large enough to hold all ACEs.
    	// 

    	cbDaclSize = sizeof(ACL) + ( sizeof(ACCESS_ALLOWED_ACE) * 2 ) +
		     GetLengthSid(pAdminSid) + GetLengthSid(pServerOpSid);
		     
    	if ( (pDacl = (PACL)LOCAL_ALLOC( LPTR, cbDaclSize ) ) == NULL ) 
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY; 
	        break;
	    }
	
        if ( !InitializeAcl( pDacl,  cbDaclSize, ACL_REVISION2 ) ) 
        {
	        dwRetCode = GetLastError();
	        break;
 	    }
    
        //
        // Add the ACE to the DACL
    	//

    	if ( !AddAccessAllowedAce( pDacl, 
			           ACL_REVISION2, 
			           DIMSVC_ALL_ACCESS, // What the admin can do
			           pAdminSid )) 
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	if ( !AddAccessAllowedAce( pDacl, 
			           ACL_REVISION2, 
			           DIMSVC_ALL_ACCESS, // What the admin can do
			           pServerOpSid )) 
        {
	        dwRetCode = GetLastError();
	        break;
	    }

        //
        // Create the security descriptor an put the DACL in it.
    	//

    	if ( !InitializeSecurityDescriptor( &SecurityDescriptor, 1 ))
        {
	        dwRetCode = GetLastError();
	        break;
    	}

    	if ( !SetSecurityDescriptorDacl( &SecurityDescriptor, 
					 TRUE, 
					 pDacl, 
					 FALSE ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

        //
	    // Set owner for the descriptor
   	    //

    	if ( !SetSecurityDescriptorOwner( &SecurityDescriptor, 
					  pLocalSystemSid, 
					  FALSE ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

        //
	    // Set group for the descriptor
   	    //

    	if ( !SetSecurityDescriptorGroup( &SecurityDescriptor, 
					  pLocalSystemSid, 
					  FALSE ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

        //
    	// Get token for the current process
    	//
    	if ( !OpenProcessToken( GetCurrentProcess(), 
				TOKEN_QUERY, 
				&hProcessToken ))
        {
	        dwRetCode = GetLastError();
	        break;
    	}

        //
    	// Create a security object. This is really just a security descriptor
    	// is self-relative form. This procedure will allocate memory for this
    	// security descriptor and copy all in the information passed in. This
    	// allows us to free all dynamic memory allocated.
    	//

    	if ( !CreatePrivateObjectSecurity( 
				      NULL,
				      &SecurityDescriptor,
				      &(DimSecurityObject.pSecurityDescriptor),
				      FALSE,
				      hProcessToken, 
    				  &(DimSecurityObject.GenericMapping)
				     )) 
	        dwRetCode = GetLastError();

    } while( FALSE );

    //
    // Free up the dynamic memory
    //

    if ( pLocalSystemSid != NULL )
    	LOCAL_FREE( pLocalSystemSid );

    if ( pAdminSid != NULL )
    	LOCAL_FREE( pAdminSid );

    if ( pServerOpSid != NULL )
    	LOCAL_FREE( pServerOpSid );

    if ( pDacl != NULL )
    	LOCAL_FREE( pDacl );

    if ( hProcessToken != NULL )
    	CloseHandle( hProcessToken );

    return( dwRetCode );

}

//**
//
// Call:	    DimSecObjDelete
//
// Returns:	    NO_ERROR	- success
//		        non-zero returns from security functions
//
// Description: Will destroy a valid security descriptor.
//
DWORD
DimSecObjDelete( 
    VOID 
)
{
    if ( !IsValidSecurityDescriptor( DimSecurityObject.pSecurityDescriptor))
    	return( NO_ERROR );

    if (!DestroyPrivateObjectSecurity( &DimSecurityObject.pSecurityDescriptor))
	    return( GetLastError() );

    return( NO_ERROR );
}

//**
//
// Call:	    DimSecObjAccessCheck
//
// Returns:	    NO_ERROR	- success
//		        non-zero returns from security functions
//
// Description: This procedure will first impersonate the client, then
//		        check to see if the client has the desired access to the
//		        security object. If he/she does then the AccessStatus 
//		        variable will be set to NO_ERROR otherwise it will be
//		        set to ERROR_ACCESS_DENIED. It will the revert to self and
//		        return.
//
DWORD
DimSecObjAccessCheck( 
    IN  DWORD 		DesiredAccess, 
    OUT LPDWORD     lpdwAccessStatus 		
)
{
    DWORD		dwRetCode;
    ACCESS_MASK	GrantedAccess;
    BOOL		fGenerateOnClose;

    //
    // Impersonate the client
    //

    dwRetCode = RpcImpersonateClient( NULL );

    if ( dwRetCode != RPC_S_OK )
	    return( dwRetCode );

    dwRetCode = AccessCheckAndAuditAlarm( 
				    DIM_SERVICE_NAME,
				    NULL,
    				DimSecurityObject.lpwsObjectType,
				    DimSecurityObject.lpwsObjectName,
				    DimSecurityObject.pSecurityDescriptor,
				    DesiredAccess,
				    &(DimSecurityObject.GenericMapping),
				    FALSE,
 			 	    &GrantedAccess,	
				    (LPBOOL)lpdwAccessStatus,
				    &fGenerateOnClose
				  );

    if ( !dwRetCode )
    {
        DWORD dwTmpRetCode = GetLastError();
        dwRetCode = RpcRevertToSelf();
	    return( dwTmpRetCode );
    }

    dwRetCode = RpcRevertToSelf();
    if (dwRetCode != RPC_S_OK)
        return dwRetCode;

    //
    // Check if desired access == granted Access
    //

    if ( DesiredAccess != GrantedAccess )
	    *lpdwAccessStatus = ERROR_ACCESS_DENIED;
    else
	    *lpdwAccessStatus = NO_ERROR;

    return( NO_ERROR );
}

BOOL
DimIsLocalService()
{
    BOOL        fIsLocalService = FALSE;
    RPC_STATUS  rpcstatus;
    HANDLE      CurrentThreadToken = NULL;
    BOOL        fImpersonate    = FALSE;
    DWORD       retcode         = ERROR_SUCCESS;
    SID         sidLocalService = { 1, 1,
                        SECURITY_NT_AUTHORITY,
                        SECURITY_LOCAL_SERVICE_RID };


    rpcstatus = RpcImpersonateClient(NULL);
    if(RPC_S_OK != rpcstatus)
    {
        goto done;
    }

    fImpersonate = TRUE;
    
    retcode = NtOpenThreadToken(
               NtCurrentThread(),
               TOKEN_QUERY,
               TRUE,
               &CurrentThreadToken
               );

    if(retcode != ERROR_SUCCESS)
    {
        goto done;
    }

    if (!CheckTokenMembership( CurrentThreadToken,
                        &sidLocalService, &fIsLocalService ))
    {
        fIsLocalService = FALSE;
    }


done:

    if(fImpersonate)
    {
        retcode = RpcRevertToSelf();
    }

    if(NULL != CurrentThreadToken)
    {
        NtClose(CurrentThreadToken);
    }

    return fIsLocalService;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_

#define FILTER_INBOUND  0
#define FILTER_OUTBOUND 1

DWORD APIENTRY
MprUIFilterConfig(
    IN  CWnd*       pParent,
    IN  LPCWSTR     pwsMachineName,
    IN  LPCWSTR     pwsInterfaceName,
    IN  DWORD       dwTransportId,
    IN  DWORD       dwFilterType    // FILTER_INBOUND, FILTER_OUTBOUND
    ); 

#endif // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\bpool.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inc\ppool.h

Abstract:

    Structures and #defines for managing NDIS_BUFFER pools. This is
    merely a reformatted version of SteveC's l2tp\bpool.h

Revision History:


--*/


#ifndef __BPOOL_H__
#define __BPOOL_H__


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

//
// Buffer pool control block.  A buffer pool prevents fragmentation of the
// non-paged memory pool by allocating the memory for a group of buffers in a
// single contiguous block.  At user's option, the buffer pool routines may
// allocate a pool of NDIS_BUFFER buffer descriptors and associate each with
// the memory buffers sliced from the contiguous block.  This allows the
// buffer to be reused while the virtual->physical memory mapping is performed
// only once.  All necessary pool growth and shrinkage is handled internally.
//


typedef struct _BUFFER_POOL
{
    //
    // Size in bytes of an individual buffer in the pool.
    //
    
    ULONG           ulBufferSize;

    //
    // The optimal number of buffers to allocate in each buffer block.
    //
    
    ULONG           ulBuffersPerBlock;

    //
    // Maximum number of individual buffers that may be allocated in the
    // entire pool or 0 for unlimited.
    //
    
    ULONG           ulMaxBuffers;

    //
    // Current number of individual buffers allocated in the entire pool.
    //
    
    ULONG           ulCurBuffers;

    //
    // Garbage collection occurs after this many calls to FreeBufferToPool.
    //
    
    ULONG           ulFreesPerCollection;

    //
    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    
    ULONG           ulFreesSinceCollection;

    //
    // Indicates an NDIS_BUFFER is to be associated with each individual
    // buffer in the pool.
    //
    
    BOOLEAN         fAssociateNdisBuffer;

    //
    // True if we allocate a whole page of memory
    //

    BOOLEAN         fAllocatePage;

    //
    // Memory identification tag for allocated blocks.
    //
    
    ULONG           ulTag;

    //
    // Head of the double linked list of BUFFER_BLOCKs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    
    LIST_ENTRY      leBlockHead;

    //
    // Head of the double linked list of free BUFFER_HEADs.  Each BUFFER_HEAD
    // in the list is ready to go, i.e. it preceeds it's already allocated
    // memory buffer and, if appropriate, has an NDIS_BUFFER associated with
    // it.
    // Access to the list is protected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of blocks and the
    // list of buffers must lock each other and (b) double links are necessary
    // for garbage collection.
    //
    
    LIST_ENTRY      leFreeBufferHead;

    //
    // This lock protects this structure and both the list of blocks and the
    // list of buffers.
    //
    
    RT_LOCK         rlLock;

}BUFFER_POOL, *PBUFFER_POOL;

//
// Header of a single block of buffers from a buffer pool.  The BUFFER_HEAD of
// the first buffer immediately follows.
//

typedef struct _BUFFER_BLOCK
{
    //
    // Link to the prev/next buffer block header in the buffer pool's list.
    //
    
    LIST_ENTRY      leBlockLink;

    //
    // NDIS's handle of the pool of NDIS_BUFFER descriptors associated with
    // this block, or NULL if none.  (Note: With the current NT implementation
    // of NDIS_BUFFER as MDL this is always NULL).
    //
    
    NDIS_HANDLE     nhNdisPool;

    //
    // Back pointer to the buffer pool.
    //
    
    PBUFFER_POOL    pPool;

    //
    // Number of individual buffers in this block on the free list.
    //
    
    ULONG           ulFreeBuffers;
    
}BUFFER_BLOCK, *PBUFFER_BLOCK;

#define ALIGN8_BLOCK_SIZE       (ALIGN_UP(sizeof(BUFFER_BLOCK), ULONGLONG))

//
// Header of an individual buffer.  The buffer memory itself immediately
// follows.
//

typedef struct _BUFFER_HEAD
{
    //
    // Links to prev/next buffer header in the buffer pool's free list.
    //
    
    LIST_ENTRY      leFreeBufferLink;

#if LIST_DBG

    BOOLEAN         bBusy;
    LIST_ENTRY      leListLink;
    ULONG           ulAllocFile;
    ULONG           ulAllocLine; 
    ULONG           ulFreeFile;
    ULONG           ulFreeLine; 

#endif

    //
    // Back link to owning buffer block header.
    //
    
    PBUFFER_BLOCK   pBlock;

    //
    // NDIS buffer descriptor of this buffer.  This is NULL unless the pool is
    // initialized with the 'fAssociateNdisBuffer' option.
    //
    
    PNDIS_BUFFER    pNdisBuffer;
    
}BUFFER_HEAD, *PBUFFER_HEAD;

#define ALIGN8_HEAD_SIZE    (ALIGN_UP(sizeof(BUFFER_HEAD), ULONGLONG))

#if LIST_DBG

#define NotOnList(p)        \
    (((p)->leListLink.Flink == NULL) && ((p)->leListLink.Blink == NULL))

#endif

#define BUFFER_FROM_HEAD(p)     (PBYTE)((ULONG_PTR)(p) + ALIGN8_HEAD_SIZE)

#define HEAD_FROM_BUFFER(p)     (PBUFFER_HEAD)((ULONG_PTR)(p) - ALIGN8_HEAD_SIZE)

//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT PBUFFER_POOL pPool,
    IN  ULONG        ulBufferSize,
    IN  ULONG        ulMaxBuffers,
    IN  ULONG        ulBuffersPerBlock,
    IN  ULONG        ulFreesPerCollection,
    IN  BOOLEAN      fAssociateNdisBuffer,
    IN  ULONG        ulTag
    );

BOOLEAN
FreeBufferPool(
    IN PBUFFER_POOL pPool
    );


#if !LIST_DBG

BOOLEAN
GetBufferListFromPool(
    IN  PBUFFER_POOL pPool,
    IN  ULONG        ulNumBuffersNeeded,
    OUT PLIST_ENTRY  pleList
    );

VOID
FreeBufferListToPool(
    IN PBUFFER_POOL pPool,
    IN PLIST_ENTRY  pleList
    );

PBYTE
GetBufferFromPool(
    IN PBUFFER_POOL pPool
    );

VOID
FreeBufferToPoolEx(
    IN PBUFFER_POOL pPool,
    IN PBYTE        pbyBuffer,
    IN BOOLEAN      fGarbageCollection
    );

NTSTATUS
GetBufferChainFromPool(
    IN      PBUFFER_POOL    pPool,
    IN OUT  PNDIS_PACKET    pnpPacket,
    IN      ULONG           ulBufferLength,
    OUT     NDIS_BUFFER     **ppnbFirstBuffer,
    OUT     VOID            **ppvFirstData
    );

VOID
FreeBufferChainToPool(
    IN PBUFFER_POOL pPool,
    IN PNDIS_PACKET pnpPacket
    );

#else

#define GetBufferListFromPool(a,b,c) GETLIST((a),(b),(c),__FILE_SIG__,__LINE__)

BOOLEAN
GETLIST(
    IN  PBUFFER_POOL pPool,
    IN  ULONG        ulNumBuffersNeeded,
    OUT PLIST_ENTRY  pleList,
    IN  ULONG        ulFileSig,
    IN  ULONG        ulLine
    );

#define FreeBufferListToPool(a,b) FREELIST((a),(b),__FILE_SIG__,__LINE__)

VOID
FREELIST(
    IN PBUFFER_POOL pPool,
    IN PLIST_ENTRY  pleList,
    IN ULONG        ulFileSig,
    IN ULONG        ulLine
    );

#define GetBufferFromPool(a) GET((a),__FILE_SIG__,__LINE__)

PBYTE
GET(
    IN PBUFFER_POOL pPool,
    IN ULONG        ulFileSig,
    IN ULONG        ulLine
    );

#define FreeBufferToPoolEx(a,b,c) FREE((a),(b),(c),__FILE_SIG__,__LINE__)

VOID
FREE(
    IN PBUFFER_POOL pPool,
    IN PBYTE        pbyBuffer,
    IN BOOLEAN      fGarbageCollection,
    IN ULONG        ulFileSig,
    IN ULONG        ulLine
    );

#define GetBufferChainFromPool(a,b,c,d,e) GETCHAIN((a),(b),(c),(d),(e),__FILE_SIG__,__LINE__)

NTSTATUS
GETCHAIN(
    IN      PBUFFER_POOL    pPool,
    IN OUT  PNDIS_PACKET    pnpPacket,
    IN      ULONG           ulBufferLength,
    OUT     NDIS_BUFFER     **ppnbFirstBuffer,
    OUT     VOID            **ppvFirstData,
    IN      ULONG           ulFileSig,
    IN      ULONG           ulLine
    );

#define FreeBufferChainToPool(a,b) FREECHAIN((a),(b),__FILE_SIG__,__LINE__)

VOID
FREECHAIN(
    IN PBUFFER_POOL pPool,
    IN PNDIS_PACKET pnpPacket,
    IN ULONG        ulFileSig,
    IN ULONG        ulLine
    );

#endif

#define FreeBufferToPool(p,b)     FreeBufferToPoolEx((p),(b), TRUE)

PNDIS_BUFFER
GetNdisBufferFromBuffer(
    IN PBYTE        pbyBuffer
    );

ULONG
BufferSizeFromBuffer(
    IN PBYTE        pbyBuffer
    );

PNDIS_BUFFER
PoolHandleForNdisCopyBufferFromBuffer(
    IN PBYTE        pbyBuffer
    );


#endif // __BPOOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\asyncpub.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation

Module Name:

	asyncpub.h

Abstract:

	This file contains all public data structures and defines used
	by asyncmac.  It defines the Ioctl interface to asyncmac.

Author:

	Tony Bell	(TonyBe) October 16, 1996

Environment:

	Kernel Mode

Revision History:

	TonyBe		10/16/96		Created

--*/

#ifndef _ASYNCMAC_PUB_
#define _ASYNCMAC_PUB_

//------------------------------------------------------------------------
//--------------------- OLD RAS COMPRESSION INFORMATION ------------------
//------------------------------------------------------------------------

// The defines below are for the compression bitmap field.

// No bits are set if compression is not available at all
#define	COMPRESSION_NOT_AVAILABLE		0x00000000

// This bit is set if the mac can do version 1 compressed frames
#define COMPRESSION_VERSION1_8K			0x00000001
#define COMPRESSION_VERSION1_16K		0x00000002
#define COMPRESSION_VERSION1_32K		0x00000004
#define COMPRESSION_VERSION1_64K		0x00000008

// And this to turn off any compression feature bit
#define COMPRESSION_OFF_BIT_MASK		(~(	COMPRESSION_VERSION1_8K  | \
											COMPRESSION_VERSION1_16K | \
                                        	COMPRESSION_VERSION1_32K | \
                                        	COMPRESSION_VERSION1_64K ))

// We need to find a place to put the following supported featurettes...
#define XON_XOFF_SUPPORTED				0x00000010

#define COMPRESS_BROADCAST_FRAMES		0x00000080

#define UNKNOWN_FRAMING					0x00010000
#define NO_FRAMING						0x00020000

#define NT31RAS_COMPRESSION 254

#define FUNC_ASYCMAC_OPEN				0
#define FUNC_ASYCMAC_CLOSE				1
#define FUNC_ASYCMAC_TRACE				2
#define FUNC_ASYCMAC_DCDCHANGE			3

#ifdef MY_DEVICE_OBJECT
#define FILE_DEVICE_ASYMAC		0x031
#define	ASYMAC_CTL_CODE(_Function)	CTL_CODE(FILE_DEVICE_ASYMAC, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)
#else
#define	ASYMAC_CTL_CODE(_Function)	CTL_CODE(FILE_DEVICE_NETWORK, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#define	IOCTL_ASYMAC_OPEN			ASYMAC_CTL_CODE(FUNC_ASYCMAC_OPEN		)
#define IOCTL_ASYMAC_CLOSE			ASYMAC_CTL_CODE(FUNC_ASYCMAC_CLOSE		)
#define IOCTL_ASYMAC_TRACE			ASYMAC_CTL_CODE(FUNC_ASYCMAC_TRACE		)
#define IOCTL_ASYMAC_DCDCHANGE		ASYMAC_CTL_CODE(FUNC_ASYCMAC_DCDCHANGE	)

//
// Asyncmac error messages
//
// All AsyncMac errors start with this base number
#define ASYBASE	700

// The Mac has not bound to an upper protocol, or the
// previous binding to AsyncMac has been destroyed.
#define ASYNC_ERROR_NO_ADAPTER			ASYBASE+0

// A port was attempted to be open that was not CLOSED yet.
#define ASYNC_ERROR_ALREADY_OPEN		ASYBASE+1

// All the ports (allocated) are used up or there is
// no binding to the AsyncMac at all (and thus no ports).
// The number of ports allocated comes from the registry.
#define ASYNC_ERROR_NO_PORT_AVAILABLE	ASYBASE+2

// In the open IOCtl to the AsyncParameter the Adapter
// parameter passed was invalid.
#define	ASYNC_ERROR_BAD_ADAPTER_PARAM	ASYBASE+3

// During a close or compress request, the port
// specified did not exist.
#define ASYNC_ERROR_PORT_NOT_FOUND		ASYBASE+4

// A request came in for the port which could not
// be handled because the port was in a bad state.
// i.e. you can't a close a port if its state is OPENING
#define ASYNC_ERROR_PORT_BAD_STATE		ASYBASE+5

// A call to ASYMAC_COMPRESS was bad with bad
// parameters.  That is, parameters that were not
// supported.  The fields will not be set to the bad params.
#define ASYNC_ERROR_BAD_COMPRESSION_INFO ASYBASE+6

// this structure is passed in as the input buffer when opening a port
typedef struct ASYMAC_OPEN ASYMAC_OPEN, *PASYMAC_OPEN;
struct ASYMAC_OPEN {
OUT NDIS_HANDLE	hNdisEndpoint;		// unique for each endpoint assigned
IN  ULONG		LinkSpeed;    		// RAW link speed in bits per sec
IN  USHORT		QualOfConnect;		// NdisAsyncRaw, NdisAsyncErrorControl, ...
IN	HANDLE		FileHandle;			// the Win32 or Nt File Handle
};


// this structure is passed in as the input buffer when closing a port
typedef struct ASYMAC_CLOSE ASYMAC_CLOSE, *PASYMAC_CLOSE;
struct ASYMAC_CLOSE {
    NDIS_HANDLE	hNdisEndpoint;		// unique for each endpoint assigned
	PVOID		MacAdapter;			// Which binding to AsyMac to use -- if set
									// to NULL, will default to last binding
};


typedef struct ASYMAC_DCDCHANGE ASYMAC_DCDCHANGE, *PASYMAC_DCDCHANGE;
struct ASYMAC_DCDCHANGE {
    NDIS_HANDLE	hNdisEndpoint;		// unique for each endpoint assigned
	PVOID		MacAdapter;			// Which binding to AsyMac to use -- if set
									// to NULL, will default to last binding
};


// this structure is used to read/set configurable 'feature' options
// during authentication this structure is passed and an
// agreement is made which features to support
typedef struct ASYMAC_FEATURES ASYMAC_FEATURES, *PASYMAC_FEATURES;
struct ASYMAC_FEATURES {
    ULONG		SendFeatureBits;	// A bit field of compression/features sendable
	ULONG		RecvFeatureBits;	// A bit field of compression/features receivable
	ULONG		MaxSendFrameSize;	// Maximum frame size that can be sent
									// must be less than or equal default
	ULONG		MaxRecvFrameSize;	// Maximum frame size that can be rcvd
									// must be less than or equal default

	ULONG		LinkSpeed;			// New RAW link speed in bits/sec
									// Ignored if 0
};

#endif			// ASYNC_PUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\debug.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\ip\wanarp\debug.c

Abstract:

    Debug functions

Revision History:

    AmritanR

--*/

#define __FILE_SIG__    DEBUG_SIG

#include "inc.h"

#define PRINT_BYTES(x) (UCHAR)x,(UCHAR)(x>>8),(UCHAR)(x>>16),(UCHAR)(x>>24)

#if RT_LOCK_DEBUG

KSPIN_LOCK  g_kslLockLock;

#endif

#if RT_MEM_DEBUG

RT_LOCK     g_rlMemoryLock;
LIST_ENTRY  g_leAllocMemListHead;
LIST_ENTRY  g_leFreeMemListHead;

#endif

VOID
RtInitializeDebug()
{

#if RT_TRACE_DEBUG

    g_byDebugLevel  = RT_DBG_LEVEL_NONE;
    //g_byDebugLevel  = RT_DBG_LEVEL_INFO;
    //g_byDebugLevel  = 0x00;
    g_fDebugComp    = 0xFFFFFFFF;

#endif

#if RT_LOCK_DEBUG
    
    KeInitializeSpinLock(&(g_kslLockLock));
    
#endif


#if RT_MEM_DEBUG

    RtInitializeSpinLock(&g_rlMemoryLock);
    
    InitializeListHead(&g_leAllocMemListHead);
    InitializeListHead(&g_leFreeMemListHead);
    
#endif

}

#if RT_LOCK_DEBUG

VOID
RtpInitializeSpinLock(
    IN  PRT_LOCK  pLock,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber
    )
{
	pLock->ulLockSig        = RT_LOCK_SIG;
	pLock->ulFileSig        = 0;
	pLock->ulLineNumber     = 0;
	pLock->bAcquired        = 0;
	pLock->pktLastThread    = (PKTHREAD)NULL;

	KeInitializeSpinLock(&(pLock->kslLock));
}

VOID
RtpAcquireSpinLock(
    IN  PRT_LOCK  pLock,
    OUT PKIRQL      pkiIrql, 
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bAtDpc
    )
{
	PKTHREAD		pThread;
    KIRQL           kiInternalIrql;
   
	pThread = KeGetCurrentThread();

    if(bAtDpc)
    {
        kiInternalIrql = KeGetCurrentIrql();

        if(kiInternalIrql isnot DISPATCH_LEVEL)
        {
            DbgPrint("RTDBG: Called AcquireSpinLockAtDpc for lock at 0x%x when not at DISPATCH. File %c%c%c%c, Line %d\n",
                     pLock,
                     PRINT_BYTES(ulFileSig),
                     ulLineNumber);
        
            DbgBreakPoint();
        }
    }

    KeAcquireSpinLock(&(g_kslLockLock),
                      &kiInternalIrql);
    
	if(pLock->ulLockSig isnot RT_LOCK_SIG)
	{
		DbgPrint("RTDBG: Trying to acquire uninited lock 0x%x, File %c%c%c%c, Line %d\n",
                 pLock,
                 (CHAR)(ulFileSig & 0xff),
                 (CHAR)((ulFileSig >> 8) & 0xff),
                 (CHAR)((ulFileSig >> 16) & 0xff),
                 (CHAR)((ulFileSig >> 24) & 0xff),
                 ulLineNumber);
        
		DbgBreakPoint();
	}

	if(pLock->bAcquired isnot 0)
	{
		if(pLock->pktLastThread is pThread)
		{
			DbgPrint("RTDBG: Detected recursive locking!: pLock 0x%x, File %c%c%c%c, Line %d\n",
                     pLock,
                     PRINT_BYTES(ulFileSig),
                     ulLineNumber);
            
			DbgPrint("RTDBG: pLock 0x%x already acquired in File %c%c%c%c, Line %d\n",
                     pLock,
                     PRINT_BYTES(pLock->ulFileSig),
                     pLock->ulLineNumber);
            
			DbgBreakPoint();
		}
	}
    
    KeReleaseSpinLock(&(g_kslLockLock),
                      kiInternalIrql);
    
    if(bAtDpc)
    {
        KeAcquireSpinLockAtDpcLevel(&(pLock->kslLock));
    }
    else
    {
        KeAcquireSpinLock(&(pLock->kslLock),
                          pkiIrql);
    }

	//
	//  Mark this lock.
	//
    
	pLock->pktLastThread = pThread;
	pLock->ulFileSig     = ulFileSig;
	pLock->ulLineNumber  = ulLineNumber;
	pLock->bAcquired     = TRUE;
}

VOID
RtpReleaseSpinLock(
    IN  PRT_LOCK  pLock,
    IN  KIRQL       kiIrql,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bFromDpc
    )
{
	if(pLock->ulLockSig isnot RT_LOCK_SIG)
	{
		DbgPrint("RTDBG: Trying to release uninited lock 0x%x, File %c%c%c%c, Line %d\n",
                 pLock,
                 PRINT_BYTES(ulFileSig),
                 ulLineNumber);
		DbgBreakPoint();
	}

	if(pLock->bAcquired is 0)
	{
		DbgPrint("RTDBG: Detected release of unacquired lock 0x%x, File %c%c%c%c, Line %d\n",
                 pLock,
                 PRINT_BYTES(ulFileSig),
                 ulLineNumber);
        
		DbgBreakPoint();
	}
    
	pLock->ulFileSig        = ulFileSig;
	pLock->ulLineNumber     = ulLineNumber;
	pLock->bAcquired        = FALSE;
	pLock->pktLastThread    = (PKTHREAD)NULL;


    if(bFromDpc)
    {
        KeReleaseSpinLockFromDpcLevel(&(pLock->kslLock));
    }
    else
    {
        KeReleaseSpinLock(&(pLock->kslLock),
                          kiIrql);
    }
}


#endif // RT_LOCK_DEBUG

#if RT_MEM_DEBUG

PVOID
RtpAllocate(
    IN POOL_TYPE    ptPool,
	IN ULONG	    ulSize,
    IN ULONG        ulTag,
	IN ULONG	    ulFileSig,
	IN ULONG	    ulLineNumber
    )
{
	PVOID			pBuffer;
	PRT_ALLOCATION  pwaAlloc;
    KIRQL           kiIrql;
    

	pwaAlloc    = ExAllocatePoolWithTag(ptPool,
                                        ulSize+sizeof(RT_ALLOCATION),
                                        ulTag);
    
	if(pwaAlloc is NULL)
	{
		Trace(MEMORY, ERROR,
              ("Failed to allocate %d bytes in file %c%c%c%c, line %d\n",
               ulSize, PRINT_BYTES(ulFileSig), ulLineNumber));
        
		pBuffer = NULL;
	}
	else
	{
		pBuffer = (PVOID)&(pwaAlloc->pucData);

        pwaAlloc->ulMemSig      = RT_MEMORY_SIG;
		pwaAlloc->ulFileSig     = ulFileSig;
		pwaAlloc->ulLineNumber  = ulLineNumber;
		pwaAlloc->ulSize        = ulSize;
        
		RtAcquireSpinLock(&(g_rlMemoryLock), &kiIrql);

		InsertHeadList(&g_leAllocMemListHead,
                       &(pwaAlloc->leLink));
        
        
		RtReleaseSpinLock(&g_rlMemoryLock, kiIrql);
    }

    return pBuffer;

}


VOID
RtpFree(
	PVOID	    pvPointer,
    IN ULONG	ulFileSig,
	IN ULONG	ulLineNumber
    )
{
	PRT_ALLOCATION  pwaAlloc;
    KIRQL           kiIrql;
    PRT_FREE        pFree;
 
	pwaAlloc    = CONTAINING_RECORD(pvPointer, RT_ALLOCATION, pucData);

    if(pwaAlloc->ulMemSig is RT_FREE_SIG)
    {
        DbgPrint("RTDBG: Trying to free memory that is already freed. Pointer0x%x, File %c%c%c%c, Line %d. Was freed at File %c%c%c%c, Line %d. \n",
                 pvPointer,
                 PRINT_BYTES(ulFileSig),
                 ulLineNumber,
                 PRINT_BYTES(pwaAlloc->ulFileSig),
                 pwaAlloc->ulLineNumber);

        return;
    }
        
	if(pwaAlloc->ulMemSig isnot RT_MEMORY_SIG)
	{
        DbgPrint("RTDBG: Trying to free memory whose signature is wrong. Pointer 0x%x\n",
                 pvPointer);
        
        
		DbgBreakPoint();

		return;
	}

    //
    // create a warp free block for it
    //

    pFree = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(RT_FREE),
                                  FREE_TAG);

    //
    // Take the lock so that no one else touches the list
    //
    
	RtAcquireSpinLock(&(g_rlMemoryLock), &kiIrql);

    RemoveEntryList(&(pwaAlloc->leLink));

    if(pFree isnot NULL)
    {
        pFree->ulMemSig          = RT_FREE_SIG;
        pFree->ulAllocFileSig    = pwaAlloc->ulFileSig;
        pFree->ulAllocLineNumber = pwaAlloc->ulLineNumber;
        pFree->ulFreeFileSig     = ulFileSig;
        pFree->ulFreeLineNumber  = ulLineNumber;
        pFree->pStartAddr        = (UINT_PTR)(pwaAlloc->pucData);
        pFree->ulSize            = pwaAlloc->ulSize;

        pwaAlloc->ulMemSig      = RT_FREE_SIG;
        pwaAlloc->ulFileSig     = ulFileSig;
        pwaAlloc->ulLineNumber  = ulLineNumber;

        InsertTailList(&g_leFreeMemListHead,
                       &(pFree->leLink));
    }
    else
    {
        Trace(MEMORY, ERROR,
              ("Unable to create free block for allocation at %d %c%c%c%c, freed at %d %c%c%c%c. Size %d\n",
               pwaAlloc->ulLineNumber,
               PRINT_BYTES(pwaAlloc->ulFileSig),
               ulLineNumber,
               PRINT_BYTES(ulFileSig),
               pwaAlloc->ulSize));
    }

	RtReleaseSpinLock(&(g_rlMemoryLock), kiIrql);

    ExFreePool(pwaAlloc);
}


VOID
RtAuditMemory()
{
    PRT_ALLOCATION  pwaAlloc;
    PLIST_ENTRY     pleNode;
    PRT_FREE        pFree;

    while(!IsListEmpty(&g_leAllocMemListHead))
    {
        pleNode = RemoveHeadList(&g_leAllocMemListHead);
        
        pwaAlloc = CONTAINING_RECORD(pleNode, RT_ALLOCATION, leLink);

        if(pwaAlloc->ulMemSig is RT_MEMORY_SIG)
        {
            DbgPrint("RTDBG: Unfreed memory. %d bytes. Pointer 0x%x, File %c%c%c%c, Line %d\n",
                     pwaAlloc->ulSize,
                     pwaAlloc->pucData,
                     PRINT_BYTES(pwaAlloc->ulFileSig),
                     pwaAlloc->ulLineNumber);

            DbgBreakPoint();

            ExFreePool(pwaAlloc);

            continue;
        }

        DbgPrint("RTDBG: Allocation with bad signature. Pointer 0x%x\n",
                 pwaAlloc->pucData);
        

        DbgBreakPoint();

        
        continue;
    }

    while(!IsListEmpty(&g_leFreeMemListHead))
    {
        pleNode = RemoveHeadList(&g_leFreeMemListHead);
        
        pFree   = CONTAINING_RECORD(pleNode, RT_FREE, leLink);

        if(pFree->ulMemSig is RT_FREE_SIG)
        {
            ExFreePool(pFree);

            continue;
        }

        DbgPrint("RTDBG: Freed memory with bad signature.\n");

        DbgBreakPoint();
    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\dim.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    dim.h
//
// Description: Contains all definitions related to the interface between
//              the Dynamic Interface Manager and other components like 
//              the router managers.
//
// History:     March 24,1995	    NarenG		Created original version.
//
#ifndef _DIM_
#define _DIM_

#include <mprapi.h>

typedef enum _UNREACHABILITY_REASON
{
    INTERFACE_OUT_OF_RESOURCES,
    INTERFACE_CONNECTION_FAILURE,
    INTERFACE_DISABLED,
    INTERFACE_SERVICE_IS_PAUSED,
    INTERFACE_DIALOUT_HOURS_RESTRICTION,
    INTERFACE_NO_MEDIA_SENSE,
    INTERFACE_NO_DEVICE

} UNREACHABILITY_REASON;

//
// This data structure represents the interface between the DIM and the various 
// router managers. Each router manager will be a user-mode DLL that will 
// export the following call:
//

typedef struct _DIM_ROUTER_INTERFACE 
{
    //
    // Protocol Id of the Router Manager
    //

    OUT DWORD	dwProtocolId;

    //
    // The StopRouter call should not block. It should return 
    // PENDING if it needs to block and then call the RouterStopped call. 
    //

    OUT DWORD 
    (APIENTRY *StopRouter)( VOID );

    //
    // Called once by DIM after all interfaces read from the registry are 
    // loaded after router startup 
    // 

    OUT DWORD
    (APIENTRY *RouterBootComplete)( VOID );

    //
    // Called when an interface is connected
    //

    OUT DWORD 
    (APIENTRY *InterfaceConnected)( 
                IN      HANDLE                  hInterface,
                IN      PVOID                   pFilter,
                IN      PVOID                   pPppProjectionResult );

    //
    // Will be called once for each router or each client that connects. 
    // For a client, the pInterfaceInfo will be NULL. INTERFACE_TYPE 
    // identified the type of the interface is being added. 
    // hDIMInterface is the handle that should be used by 
    // the various router  managers when making calls into DIM.
    //

    OUT DWORD 
    (APIENTRY *AddInterface)(    
                IN      LPWSTR                  lpwsInterfaceName, 
                IN      LPVOID                  pInterfaceInfo, 
                IN      ROUTER_INTERFACE_TYPE   InterfaceType,
                IN      HANDLE                  hDIMInterface, 
                IN OUT  HANDLE *                phInterface );

    OUT DWORD 
    (APIENTRY *DeleteInterface)( 
                IN      HANDLE          hInterface );   

    OUT DWORD 
    (APIENTRY *GetInterfaceInfo)(    
                IN      HANDLE          hInterface,
                OUT     LPVOID          pInterfaceInfo,
                IN OUT  LPDWORD         lpdwInterfaceInfoSize );

    //
    // pInterfaceInfo may be NULL if there was no change
    //
    
    OUT DWORD
    (APIENTRY *SetInterfaceInfo)(    
                IN      HANDLE          hInterface,
                IN      LPVOID          pInterfaceInfo );

    OUT DWORD
    (APIENTRY *DisableInterface)(
                IN      HANDLE          hInterface,
                IN      DWORD           dwProtocolId
                );

    OUT DWORD
    (APIENTRY *EnableInterface)(
                IN      HANDLE          hInterface,
                IN      DWORD           dwProtocolId
                );

    //
    // Notification that the interface is not reachable at this time. 
    // This is in response to a previos call to ConnectInterface.
    // (All WAN links are busy at this time or remote destination is busy etc).
    //

    OUT DWORD
    (APIENTRY *InterfaceNotReachable)(   
                IN      HANDLE                  hInterface,
                IN      UNREACHABILITY_REASON   Reason );

    //
    // Notification that a previously unreachable interface may be reachable 
    // at this time. 
    //

    OUT DWORD
    (APIENTRY *InterfaceReachable)(  
                IN      HANDLE          hInterface );     

    OUT DWORD
    (APIENTRY *UpdateRoutes)(    
                IN      HANDLE          hInterface,
                IN      HANDLE          hEvent );

    //
    // When the hEvent is signaled, the caller of UpdateRoutes will call
    // this function. If the update succeeded then *lpdwUpdateResult will
    // be NO_ERROR otherwise it will be non-zero.
    //

    OUT DWORD
    (APIENTRY *GetUpdateRoutesResult)(
                IN      HANDLE          hInterface,
		        OUT	    LPDWORD         lpdwUpdateResult );

    OUT DWORD
    (APIENTRY *SetGlobalInfo)(   
                IN      LPVOID          pGlobalInfo );

    OUT DWORD
    (APIENTRY *GetGlobalInfo)(   
                OUT     LPVOID          pGlobalInfo,
                IN OUT  LPDWORD         lpdwGlobalInfoSize );

    //
    // The MIBEntryGetXXX APIs should return ERROR_INSUFFICIENT_BUFFER
    // and the size of the required output buffer if the size of the output
    // buffer passed in is 0.
    //

    OUT DWORD
    (APIENTRY *MIBEntryCreate)(
                IN      DWORD           dwRoutingPid,
                IN      DWORD           dwEntrySize,
                IN      LPVOID          lpEntry );

    OUT DWORD
    (APIENTRY *MIBEntryDelete)(
                IN      DWORD           dwRoutingPid,
                IN      DWORD           dwEntrySize,
                IN      LPVOID          lpEntry );

    OUT DWORD
    (APIENTRY *MIBEntrySet)(
                IN      DWORD           dwRoutingPid,
                IN      DWORD           dwEntrySize,
                IN      LPVOID          lpEntry );

    OUT DWORD
    (APIENTRY *MIBEntryGet)(
                IN      DWORD           dwRoutingPid,
                IN      DWORD           dwInEntrySize,
                IN      LPVOID          lpInEntry, 
                IN OUT  LPDWORD         lpOutEntrySize,
                OUT     LPVOID          lpOutEntry );

    OUT DWORD
    (APIENTRY *MIBEntryGetFirst)(
                IN      DWORD           dwRoutingPid,
                IN      DWORD           dwInEntrySize,
                IN      LPVOID          lpInEntry, 
                IN OUT  LPDWORD         lpOutEntrySize,
                OUT     LPVOID          lpOutEntry );

    OUT DWORD
    (APIENTRY *MIBEntryGetNext)(
                IN      DWORD           dwRoutingPid,
                IN      DWORD           dwInEntrySize,
                IN      LPVOID          lpInEntry, 
                IN OUT  LPDWORD         lpOutEntrySize,
                OUT     LPVOID          lpOutEntry );

    OUT DWORD
    (APIENTRY *MIBGetTrapInfo)(
                IN      DWORD           dwRoutingPid,
                IN      DWORD           dwInDataSize,
                IN      LPVOID          lpInData,
                IN OUT  LPDWORD         lpOutDataSize,
                OUT     LPVOID          lpOutData );

    OUT DWORD
    (APIENTRY *MIBSetTrapInfo)(
                IN      DWORD           dwRoutingPid,
                IN      HANDLE          hEvent,
                IN      DWORD           dwInDataSize,
                IN      LPVOID          lpInData,
                IN OUT  LPDWORD         lpOutDataSize,
                OUT     LPVOID          lpOutData );

    OUT DWORD
    (APIENTRY *SetRasAdvEnable)(
                IN      BOOL            bEnable );


    //
    // The following calls will be called by the various router managers. 
    // The addresses of these entry points into the DIM will be filled in by DIM
    // before the StartRouter call. The router managers should not call any of
    // these calls within the context of a call from DIM into the router 
    // manager.
    //

    IN DWORD
    (APIENTRY *ConnectInterface)(    
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId  ); 

    IN DWORD
    (APIENTRY *DisconnectInterface)( 
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId );

    //
    // This call will make DIM store the interface information into the 
    // Site Object for this interface.
    //

    IN DWORD
    (APIENTRY *SaveInterfaceInfo)(   
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId,
                IN      LPVOID          pInterfaceInfo,
                IN      DWORD           cbInterfaceInfoSize );

    //
    // This will make DIM get interface information from the Site object. 
    //

    IN DWORD
    (APIENTRY *RestoreInterfaceInfo)(    
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId,
                IN      LPVOID          lpInterfaceInfo,
                IN      LPDWORD         lpcbInterfaceInfoSize );

    IN DWORD
    (APIENTRY *SaveGlobalInfo)(   
                IN      DWORD           dwProtocolId,
                IN      LPVOID          pGlobalInfo,
                IN      DWORD           cbGlobalInfoSize );

    IN VOID
    (APIENTRY *RouterStopped)(
                IN      DWORD           dwProtocolId,
                IN      DWORD           dwError  ); 

    IN VOID
    (APIENTRY *InterfaceEnabled)(
                IN      HANDLE          hDIMInterface, 
                IN      DWORD           dwProtocolId,
                IN      BOOL            fEnabled  ); 

} DIM_ROUTER_INTERFACE, *PDIM_ROUTER_INTERFACE;

//
// This will be called, once for each available router manager DLL, when the 
// DIM service is initializing. This will by a synchronous call.
// If it returns NO_ERROR then it is assumed that the router manager has 
// started. Otherwise it is an error.
//

DWORD APIENTRY 
StartRouter(
    IN OUT DIM_ROUTER_INTERFACE *   pDimRouterIf,
    IN     BOOL                     fLANModeOnly,
    IN     LPVOID                   pGlobalInfo
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\bpool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.c
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#define __FILE_SIG__    BPOOL_SIG

#include "inc.h"

LONG    g_lHPool;

#define CHECK_LOCK_ENTRY(pPool)                 \
{                                               \
    if(InterlockedExchange(&g_lHPool,           \
                           1) isnot 0)          \
    {                                           \
        RtAssert(FALSE);                        \
    }                                           \
}

#define CHECK_LOCK_EXIT(pPool)                  \
{                                               \
    if(InterlockedExchange(&g_lHPool,           \
                           0) isnot 1)          \
    {                                           \
        RtAssert(FALSE);                        \
    }                                           \
}

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
AddBufferBlockToPool(
    IN  PBUFFER_POOL pPool,
    OUT BYTE         **ppHead
    );

VOID
FreeUnusedPoolBlocks(
    IN PBUFFER_POOL pPool
    );

BOOLEAN
IsEntryOnList(
    PLIST_ENTRY pleHead,
    PLIST_ENTRY pleEntry
    );

//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT PBUFFER_POOL pPool,
    IN ULONG         ulBufferSize,
    IN ULONG         ulMaxBuffers,
    IN ULONG         ulBuffersPerBlock,
    IN ULONG         ulFreesPerCollection,
    IN BOOLEAN       fAssociateNdisBuffer,
    IN ULONG         ulTag
    )

/*++
  
Routine Description

    Initialize caller's buffer pool control block
    
Locks

    Caller's 'pPool' buffer must be protected from multiple access during
    this call
    
Arguments

    pPool                The buffer pool to be initialized
    ulBufferSize         Size in bytes of an individual buffer
    ulMaxBuffers         Maximum number of buffers allowed in the entire
                         pool or 0 for unlimited.
    ulBuffersPerBlock    Number of buffers to include in each block of buffers.
    ulFreesPerCollection Number of FreeBufferToPool calls until the next
                         garbage collect scan, or 0 for default.
    fAssociateNdisBuffer Set if an NDIS_BUFFER should be allocated and
                         associated with each individual buffer.
    ulTag                Pool tag to use when allocating blocks.

Return Value

    None

--*/

{
    ULONG   ulNumBuffers;


    pPool->ulBufferSize             = ulBufferSize;
    pPool->ulMaxBuffers             = ulMaxBuffers;
    pPool->ulFreesSinceCollection   = 0;
    pPool->fAssociateNdisBuffer     = fAssociateNdisBuffer;
    pPool->fAllocatePage            = TRUE;
    pPool->ulTag                    = ulTag;

    //
    // Figure out the number of buffers if we allocated a page
    //

    ulNumBuffers = (PAGE_SIZE - ALIGN8_BLOCK_SIZE)/(ALIGN8_HEAD_SIZE + ALIGN_UP(ulBufferSize, ULONGLONG));

    pPool->ulBuffersPerBlock        = ulNumBuffers;

    if(ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        //
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        
        pPool->ulFreesPerCollection = 50 * pPool->ulBuffersPerBlock;
    }


    InitializeListHead(&(pPool->leBlockHead));
    InitializeListHead(&(pPool->leFreeBufferHead));

    RtInitializeSpinLock(&(pPool->rlLock));
}


BOOLEAN
FreeBufferPool(
    IN PBUFFER_POOL pPool
    )

/*++
  
Routine Description

    Free up all resources allocated in buffer pool. This is the
    inverse of InitPool.
    
Locks

    
Arguments

    
Return Value

    TRUE    if successful
    FALSE   if any of the pool could not be freed due to outstanding packets.

--*/

{
    BOOLEAN fSuccess;
    KIRQL   irql;

    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    FreeUnusedPoolBlocks(pPool);

    fSuccess = (pPool->ulCurBuffers is 0);

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);

    return fSuccess;
}

#if LIST_DBG

PBYTE
GET(
    IN PBUFFER_POOL pPool,
    IN ULONG        ulFileSig,
    IN ULONG        ulLine
    )

#else

PBYTE
GetBufferFromPool(
    IN PBUFFER_POOL pPool
    )

#endif

/*++
  
Routine Description

    Returns the address of the useable memory in an individual buffer
    allocated from the pool. The pool is expanded, if necessary, but caller
    should still check for NULL return since the pool may have been at
    maximum size.
    
Locks


Arguments

    pPool   Pointer to pool
    
Return Value
    NO_ERROR

--*/

{
    PLIST_ENTRY  pleNode;
    PBUFFER_HEAD pHead;
    PBYTE        pbyBuffer;
    KIRQL        irql;
    
    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);
    
    if(IsListEmpty(&pPool->leFreeBufferHead))
    {
        pleNode = NULL;
    }
    else
    {
        pleNode = RemoveHeadList(&pPool->leFreeBufferHead);
      
        pHead = CONTAINING_RECORD(pleNode, BUFFER_HEAD, leFreeBufferLink);

#if LIST_DBG
 
        RtAssert(!IsEntryOnList(&pPool->leFreeBufferHead,
                                pleNode));

        pHead->ulAllocFile = ulFileSig;
        pHead->ulAllocLine = ulLine;
#endif

        pHead->pBlock->ulFreeBuffers--;

        //
        // If there was an associated NDIS_BUFFER, adjust its length
        // to the full size
        //

        if(pPool->fAssociateNdisBuffer)
        {
            RtAssert(pHead->pNdisBuffer);

            NdisAdjustBufferLength(pHead->pNdisBuffer,
                                   pPool->ulBufferSize);
        }
            
    }

#if LIST_DBG

    RtAssert(pPool->leFreeBufferHead.Flink is pleNode->Flink);

#endif

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);

    if(pleNode)
    {

#if LIST_DBG

        RtAssert(NotOnList(pHead));
        RtAssert(!(pHead->bBusy));
        pHead->bBusy = TRUE;
        InitializeListHead(&(pHead->leFreeBufferLink));

#endif

        pbyBuffer = BUFFER_FROM_HEAD(pHead);
    }
    else
    {
        //
        // The free list was empty.  Try to expand the pool.
        //
        
        AddBufferBlockToPool(pPool,
                             &pbyBuffer);

#if LIST_DBG

        pHead = HEAD_FROM_BUFFER(pbyBuffer);

        pHead->ulAllocFile = ulFileSig;
        pHead->ulAllocLine = ulLine;
        pHead->bBusy       = TRUE;

#endif

    }
    
    return pbyBuffer;
}


#if LIST_DBG

NTSTATUS
GETCHAIN(
    IN      PBUFFER_POOL    pPool,
    IN OUT  PNDIS_PACKET    pnpPacket,
    IN      ULONG           ulBufferLength,
    OUT     NDIS_BUFFER     **ppnbFirstBuffer,
    OUT     VOID            **ppvFirstData,
    IN      ULONG           ulFileSig,
    IN      ULONG           ulLine
    )

#else

NTSTATUS
GetBufferChainFromPool(
    IN      PBUFFER_POOL    pPool,
    IN OUT  PNDIS_PACKET    pnpPacket,
    IN      ULONG           ulBufferLength,
    OUT     NDIS_BUFFER     **ppnbFirstBuffer OPTIONAL,
    OUT     VOID            **ppvFirstData OPTIONAL
    )

#endif

/*++
  
Routine Description

    Gets a chain of buffers and hooks them onto an NDIS_PACKET
    This requires that the BUFFER_POOL have been created with the
    fAssociateNdisBuffer option
    
Locks

    Acquires the Pool lock.
    Also calls GetPacketFromPool() which acquires the packet pool lock
    
Arguments


Return Value
    NO_ERROR

--*/

{
    ULONG           i, ulBufNeeded, ulLastSize;
    KIRQL           irql;
    PLIST_ENTRY     pleNode;
    PBUFFER_HEAD    pHead;
    NTSTATUS        nStatus;
 
    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    RtAssert(pPool->fAssociateNdisBuffer is TRUE);
    
    //
    // Figure out the number of buffers needed
    //

    ulBufNeeded = ulBufferLength / pPool->ulBufferSize;
    ulLastSize  = ulBufferLength % pPool->ulBufferSize;

    if(ulLastSize isnot 0)
    {
        //
        // The buffer length is not an exact multiple of the buffer size
        // so we need one more buffer with length == ulLastSize
        //
        
        ulBufNeeded++;
    }
    else
    {
        //
        // Set it to the full size, needed to make some code work
        // without extra if()
        //
        
        ulLastSize = pPool->ulBufferSize;
    }
    
    RtAssert(ulBufNeeded);

    i = 0;

    nStatus = STATUS_SUCCESS;
    
    while(i < ulBufNeeded)
    {
        //
        // The buffer pool must be locked at this point
        //
        
        while(!IsListEmpty(&pPool->leFreeBufferHead))
        {
            pleNode = RemoveHeadList(&pPool->leFreeBufferHead);

            pHead = CONTAINING_RECORD(pleNode,
                                      BUFFER_HEAD,
                                      leFreeBufferLink);
            
            (pHead->pBlock->ulFreeBuffers)--;
       
#if LIST_DBG

            RtAssert(pPool->leFreeBufferHead.Flink is pleNode->Flink);
 
            RtAssert(!IsEntryOnList(&pPool->leFreeBufferHead,
                                    pleNode));

            RtAssert(NotOnList(pHead));
            RtAssert(!(pHead->bBusy));
            pHead->bBusy = TRUE;
            InitializeListHead(&(pHead->leFreeBufferLink));

            pHead->ulAllocFile = ulFileSig;
            pHead->ulAllocLine = ulLine;

#endif
   
            if(i is 0)
            {
                //
                // This is the first buffer
                //

                if(ppnbFirstBuffer)
                {
                    *ppnbFirstBuffer = pHead->pNdisBuffer;
                }

                if(ppnbFirstBuffer)
                {
                    *ppvFirstData    = BUFFER_FROM_HEAD(pHead);
                }
            }

            i++;

            if(i is ulBufNeeded)
            {
                //
                // This is the last buffer. Set the length to the last length
                //
                
                NdisAdjustBufferLength(pHead->pNdisBuffer,
                                       ulLastSize);
            
                //
                // Add the buffer to the NDIS_PACKET
                //
            
                NdisChainBufferAtBack(pnpPacket,
                                      pHead->pNdisBuffer);

                //
                // Done chaining packets - break out of the
                // while(!IsListEmpty()) loop
                //
                
                break;
            }
            else
            {
                //
                // Adjust the length to the full length, since the buffer
                // may have earlier been used as smaller sized
                //
                
                NdisAdjustBufferLength(pHead->pNdisBuffer,
                                       pPool->ulBufferSize);

                //
                // Add the buffer to the NDIS_PACKET
                //
            
                NdisChainBufferAtBack(pnpPacket,
                                      pHead->pNdisBuffer);
                
            }
        }

        RtReleaseSpinLock(&(pPool->rlLock),
                          irql);


        if(i isnot ulBufNeeded)
        {
            //
            // We did not get all the buffers we needed
            // Grow the buffer pool and try again
            //

            if(AddBufferBlockToPool(pPool, NULL))
            {
                //
                // Ok atleast one buffer was added, go to the 
                // while(i < ulBufNeeded)
                //

                RtAcquireSpinLock(&(pPool->rlLock),
                                  &irql);

                continue;
            }
            else
            {
                //
                // Looks like there is not enough memory. Free what ever we
                // have chained up and get out
                //

                FreeBufferChainToPool(pPool,
                                      pnpPacket);

                nStatus = STATUS_INSUFFICIENT_RESOURCES;

                break;
            }
        }
    }

    return nStatus;
}

#if LIST_DBG

BOOLEAN
GETLIST(
    IN  PBUFFER_POOL pPool,
    IN  ULONG        ulNumBuffersNeeded,
    OUT PLIST_ENTRY  pleList,
    IN  ULONG        ulFileSig,
    IN  ULONG        ulLine
    )

#else

BOOLEAN
GetBufferListFromPool(
    IN  PBUFFER_POOL pPool,
    IN  ULONG        ulNumBuffersNeeded,
    OUT PLIST_ENTRY  pleList
    )

#endif

/*++
  
Routine Description

    Gets a chain of buffers and hooks them onto a BUFFER_HEAD using the
    leFreeBufferLink
    
Locks

    Acquires the Pool lock.
    
Arguments


Return Value

    TRUE if successful

--*/

{
    ULONG       i;
    KIRQL       irql;
    BOOLEAN     bRet;
 
    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    RtAssert(pPool->fAssociateNdisBuffer is TRUE);
    RtAssert(ulNumBuffersNeeded); 

    i    = 0;
    bRet = TRUE;
 
    InitializeListHead(pleList);
    
    while(i < ulNumBuffersNeeded)
    {
        //
        // The buffer pool must be locked at this point
        //
        
        while(!IsListEmpty(&pPool->leFreeBufferHead))
        {
            PBUFFER_HEAD    pHead;
            PLIST_ENTRY     pleNode;

            pleNode = RemoveHeadList(&pPool->leFreeBufferHead);
           
            pHead = CONTAINING_RECORD(pleNode,
                                      BUFFER_HEAD,
                                      leFreeBufferLink);
            
            (pHead->pBlock->ulFreeBuffers)--;

#if LIST_DBG
        
            RtAssert(pPool->leFreeBufferHead.Flink is pleNode->Flink);
  
            RtAssert(!IsEntryOnList(&pPool->leFreeBufferHead,
                                    pleNode));
            RtAssert(NotOnList(pHead));
            RtAssert(!(pHead->bBusy));
            pHead->bBusy = TRUE;
            InitializeListHead(&(pHead->leFreeBufferLink));
            pHead->ulAllocFile = ulFileSig;
            pHead->ulAllocLine = ulLine;

#endif
 
            //
            // Insert the buffer to the tail of the list
            //
                
#if LIST_DBG

            InsertTailList(pleList,
                           &(pHead->leListLink));

#else

            InsertTailList(pleList,
                           &(pHead->leFreeBufferLink));

#endif

            i++;

            //
            // Adjust the length to the full length, since the buffer
            // may have earlier been used as smaller sized
            //
            
            NdisAdjustBufferLength(pHead->pNdisBuffer,
                                   pPool->ulBufferSize);

            if(i is ulNumBuffersNeeded)
            {
                //
                // Got all the buffer we need
                //

                break;
            }
        }

        //
        // At this point we either have all the buffers we need or are out
        // of buffers. Release the lock and see which case
        //

        RtReleaseSpinLock(&(pPool->rlLock),
                          irql);


        if(i isnot ulNumBuffersNeeded)
        {
            //
            // We did not get all the buffers we needed
            // Grow the buffer pool and try again
            //

            if(AddBufferBlockToPool(pPool, NULL))
            {
                //
                // Ok atleast one buffer was added, go to the 
                // while(i < ulNumBuffersNeeded)
                //

                RtAcquireSpinLock(&(pPool->rlLock),
                                  &irql);

                continue;
            }
            else
            {
                //
                // Looks like there is not enough memory. Free what ever we
                // have chained up and get out
                //

                if(!IsListEmpty(pleList))
                {
                    FreeBufferListToPool(pPool,
                                         pleList);
                }


                bRet = FALSE;

                break;
            }
        }
    }

    return bRet;
}

#if LIST_DBG

VOID
FREE(
    IN PBUFFER_POOL pPool,
    IN PBYTE        pbyBuffer,
    IN BOOLEAN      fGarbageCollection,
    IN ULONG        ulFileSig,
    IN ULONG        ulLine
    )

#else

VOID
FreeBufferToPoolEx(
    IN PBUFFER_POOL pPool,
    IN PBYTE        pbyBuffer,
    IN BOOLEAN      fGarbageCollection
    )

#endif

/*++
  
Routine Description

     Returns a buffer to the pool of unused buffers. The buffer must have
     been previously allocated with GetBufferFromPool.

Locks


Arguments

    pBuffer     Buffer to free
    pPool       Pool to free to

    fGarbageCollection is set when the free should be considered for
    purposes of garbage collection.  This is used by the AddBufferToPool
    routine to avoid counting the initial "add" frees.  Normal callers
    should set this flag.
    
Return Value

    NO_ERROR

--*/

{
    PBUFFER_HEAD pHead;
    KIRQL        irql;
    PLIST_ENTRY  pNext;
    
    //
    // The buffer head would be just above the actual data buffer
    //
    
    pHead = HEAD_FROM_BUFFER(pbyBuffer);

    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

#if LIST_DBG

    RtAssert(!IsEntryOnList(&pPool->leFreeBufferHead,
                            &pHead->leFreeBufferLink));

    RtAssert(NotOnList(pHead));
    RtAssert(IsListEmpty(&(pHead->leFreeBufferLink)));
    RtAssert(pHead->bBusy);
    pHead->bBusy = FALSE;
    pHead->ulFreeFile = ulFileSig;
    pHead->ulFreeLine = ulLine;

    pNext = pPool->leFreeBufferHead.Flink;

#endif

    InsertHeadList(&(pPool->leFreeBufferHead),
                   &(pHead->leFreeBufferLink));

#if LIST_DBG

    RtAssert(pHead->leFreeBufferLink.Flink is pNext);

#endif

    pHead->pBlock->ulFreeBuffers++;

    if(fGarbageCollection)
    {
        pPool->ulFreesSinceCollection++;
        
        if(pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
        {
            //
            // Time to collect garbage, i.e. free any blocks in the pool
            // not in use.
            //
            
            FreeUnusedPoolBlocks(pPool);
            pPool->ulFreesSinceCollection = 0;
            
        }
    }

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);
}

#if LIST_DBG

VOID
FREECHAIN(
    IN PBUFFER_POOL pPool,
    IN PNDIS_PACKET pnpPacket,
    IN ULONG        ulFileSig,
    IN ULONG        ulLine
    )

#else

VOID
FreeBufferChainToPool(
    IN PBUFFER_POOL pPool,
    IN PNDIS_PACKET pnpPacket
    )

#endif

/*++
  
Routine Description

    Frees a chain of buffers off an NDIS_PACKET to a buffer pool

Locks

    Acquires the buffer spin lock

Arguments

    pPool   The buffer pool
    pnpPacket   NDIS_PACKET off of which the buffers are chained

Return Value

    NO_ERROR

--*/

{
    PBUFFER_HEAD    pHead;
    PNDIS_BUFFER    pnbBuffer;
    KIRQL           irql;
    UINT            uiBuffLength;
    PVOID           pvData;
    
    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    //
    // Loop through the chained buffers, free each
    //

    while(TRUE)
    {
        PLIST_ENTRY pNext;

        NdisUnchainBufferAtFront(pnpPacket,
                                 &pnbBuffer);

        if(pnbBuffer is NULL)
        {
            //
            // No more buffers
            //
            
            break;
        }

        NdisQueryBuffer(pnbBuffer,
                        &pvData,
                        &uiBuffLength);
        
        pHead = HEAD_FROM_BUFFER(pvData);

#if LIST_DBG

        RtAssert(!IsEntryOnList(&pPool->leFreeBufferHead,
                                &pHead->leFreeBufferLink));

        RtAssert(NotOnList(pHead));
        RtAssert(IsListEmpty(&(pHead->leFreeBufferLink)));
        RtAssert(pHead->bBusy);
        pHead->bBusy = FALSE;
        pHead->ulFreeFile = ulFileSig;
        pHead->ulFreeLine = ulLine;
        pNext = pPool->leFreeBufferHead.Flink;

#endif

        InsertHeadList(&(pPool->leFreeBufferHead),
                       &(pHead->leFreeBufferLink));

#if LIST_DBG

        RtAssert(pHead->leFreeBufferLink.Flink is pNext);

#endif

        pHead->pBlock->ulFreeBuffers++;

        pPool->ulFreesSinceCollection++;
    }
    
    if(pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
    {
        //
        // Time to collect garbage, i.e. free any blocks in the pool
        // not in use.
        //
    
        FreeUnusedPoolBlocks(pPool);

        pPool->ulFreesSinceCollection = 0;
    }

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);

}

#if LIST_DBG

VOID
FREELIST(
    IN PBUFFER_POOL pPool,
    IN PLIST_ENTRY  pleList,
    IN ULONG        ulFileSig,
    IN ULONG        ulLine
    )

#else

VOID
FreeBufferListToPool(
    IN PBUFFER_POOL pPool,
    IN PLIST_ENTRY  pleList
    )

#endif

/*++
  
Routine Description

    Frees a list of buffers, linked using the leFreeBufferLink
    
Locks

    Locks the bufferpool
    
Arguments


Return Value

    None

--*/

{
    KIRQL       irql;
    
    if(IsListEmpty(pleList))
    {
        RtAssert(FALSE);
        
        return;
    }

    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    //
    // Loop through the list of buffers, free each
    //

    while(!IsListEmpty(pleList))
    {
        PLIST_ENTRY     pleNode, pNext;
        PBUFFER_HEAD    pTempBuffHead;
        
        pleNode = RemoveHeadList(pleList);

#if LIST_DBG

        pTempBuffHead = CONTAINING_RECORD(pleNode,
                                          BUFFER_HEAD,
                                          leListLink);

        RtAssert(IsListEmpty(&(pTempBuffHead->leFreeBufferLink)));

        RtAssert(!IsEntryOnList(&pPool->leFreeBufferHead,
                                &pTempBuffHead->leFreeBufferLink));

        pTempBuffHead->leListLink.Flink = NULL;
        pTempBuffHead->leListLink.Blink = NULL;

        RtAssert(pTempBuffHead->bBusy);
        pTempBuffHead->bBusy = FALSE;
        pTempBuffHead->ulFreeFile = ulFileSig;
        pTempBuffHead->ulFreeLine = ulLine;
        pNext = pPool->leFreeBufferHead.Flink;
#else

        pTempBuffHead = CONTAINING_RECORD(pleNode,
                                          BUFFER_HEAD,
                                          leFreeBufferLink);

#endif

        InsertHeadList(&(pPool->leFreeBufferHead),
                       &(pTempBuffHead->leFreeBufferLink));
   

#if LIST_DBG

        RtAssert(pTempBuffHead->leFreeBufferLink.Flink is pNext);

#endif 

        pTempBuffHead->pBlock->ulFreeBuffers++;

        pPool->ulFreesSinceCollection++;
    }
    
    if(pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
    {
        //
        // Time to collect garbage, i.e. free any blocks in the pool
        // not in use.
        //
    
        FreeUnusedPoolBlocks(pPool);

        pPool->ulFreesSinceCollection = 0;
    }

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);

}

//
// should make the following #define's
//

PNDIS_BUFFER
GetNdisBufferFromBuffer(
    IN PBYTE pbyBuffer
    )

/*++
  
Routine Description

    Returns the NDIS_BUFFER associated with the buffer which was
    obtained previously with GetBufferFromPool.
    
Locks


Arguments


Return Value
    
    Pointer to NDIS_BUFFER associated with the buffer
    
--*/

{
    PBUFFER_HEAD pHead;

    pHead = HEAD_FROM_BUFFER(pbyBuffer);
    
    return pHead->pNdisBuffer;
}


ULONG
BufferSizeFromBuffer(
    IN PBYTE pbyBuffer
    )

/*++
  
Routine Description

     Returns the original size of the buffer 'pBuffer' which was obtained
     previously with GetBufferFromPool.  This is useful for undoing
     NdisAdjustBufferLength
     
Locks


Arguments


Return Value

    Original size of buffer

--*/

{
    PBUFFER_HEAD pHead;

    pHead = HEAD_FROM_BUFFER(pbyBuffer);
    
    return pHead->pBlock->pPool->ulBufferSize;
}


PNDIS_BUFFER
PoolHandleFromBuffer(
    IN PBYTE pbyBuffer
    )

/*++
  
Routine Description

    Returns the handle of the NDIS buffer pool from which the NDIS_BUFFER
    associated with this buffer was obtained.  Caller may use the handle to
    pass to NdisCopyBuffer, one such use per buffer at a time.
    
Locks


Arguments


Return Value

    NO_ERROR

--*/

{
    PBUFFER_HEAD pHead;

    pHead = HEAD_FROM_BUFFER(pbyBuffer);
    
    return pHead->pBlock->nhNdisPool;
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

BOOLEAN
AddBufferBlockToPool(
    IN  PBUFFER_POOL pPool,
    OUT BYTE         **ppbyRetBuff OPTIONAL
    )

/*++

Routine Description

    Allocate a new buffer block and add it to the buffer pool 'pPool'.

Locks


Arguments


Return Value

    TRUE    If we could add a buffer block
    FALSE   otherwise

--*/

{

    ULONG   ulSize, i;
    BOOLEAN fOk, fAssociateNdisBuffer;
    PBYTE   pbyReturn, pbyBuffer;
    KIRQL   irql;

    PBUFFER_HEAD    pHead;
    NDIS_STATUS     nsStatus;
    PBUFFER_BLOCK   pNew;
    
    fOk = FALSE;
    pNew = NULL;

    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    //
    // Save this for reference after the lock is released.
    //
    
    fAssociateNdisBuffer = pPool->fAssociateNdisBuffer;

    do
    {
        //
        // If it is already over the max, dont allocate any more
        // Note that we dont STRICTLY respect the max, we will allow, one
        // block over max
        //

        if(pPool->ulMaxBuffers and (pPool->ulCurBuffers >= pPool->ulMaxBuffers))
        {
            Trace(MEMORY, WARN,
                  ("AddBufferBlockToPool: Quota exceeded\n"));

            //
            // No can do.  The pool was created with a maximum size and that
            // has been reached.
            //

            break;
        }

        ulSize = PAGE_SIZE;

        //
        // Allocate the contiguous memory block for the BUFFERBLOCK header
        // and the individual buffers.
        //
        
        pNew = RtAllocate(NonPagedPool,
                          ulSize,
                          pPool->ulTag);
                          
        if(!pNew)
        {
            Trace(MEMORY, ERROR,
                  ("AddBufferBlockToPool: Cant allocate %d bytes\n",
                   ulSize));

            break;
        }

        //
        // Zero only the block header portion.
        //
        
        NdisZeroMemory(pNew, 
                       ALIGN8_BLOCK_SIZE);

        if(fAssociateNdisBuffer)
        {
            //
            // Allocate a pool of NDIS_BUFFER descriptors.
            //
            // Twice as many descriptors are allocated as buffers so
            // caller can use the PoolHandleForNdisCopyBufferFromBuffer
            // routine to obtain a pool handle to pass to the
            // NdisCopyBuffer used to trim the L2TP header from received
            // packets.  In the current NDIS implmentation on NT this does
            // nothing but return a NULL handle and STATUS_SUCCESS,
            // because NDIS_BUFFER's are just MDL's,
            // NdisAllocatePool is basically a no-op, and for that
            // matter, NdisCopyBuffer doesn't really use the pool handle
            // it's passed.  It's cheap to stay strictly compliant here,
            // though, so we do that.
            //
            
            NdisAllocateBufferPool(&nsStatus,
                                   &pNew->nhNdisPool,
                                   pPool->ulBuffersPerBlock * 2);
            
            if(nsStatus isnot NDIS_STATUS_SUCCESS)
            {
                Trace(MEMORY, ERROR,
                      ("AddBufferBlockToPool: Status %x allocating buffer pool\n",
                       nsStatus));

                break;
            }
        }

        //
        // Fill in the back pointer to the pool.
        //
        
        pNew->pPool = pPool;

        //
        // Link the new block.  At this point, all the buffers are
        // effectively "in use".  They are made available in the loop
        // below.
        //
        
        pPool->ulCurBuffers += pPool->ulBuffersPerBlock;
        
        InsertHeadList(&pPool->leBlockHead, &pNew->leBlockLink);
        
        fOk = TRUE;
        
    }while(FALSE);

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);

    if(!fOk)
    {
        //
        // Bailing, undo whatever succeeded.
        //
        
        if(pNew)
        {
            RtFree(pNew);
            
            if(pNew->nhNdisPool)
            {
                NdisFreeBufferPool(pNew->nhNdisPool);
            }
        }

        return FALSE;
    }

    //
    // Initialize each individual buffer slice and add it to the list of free
    // buffers.
    //
    
    if(ppbyRetBuff isnot NULL)
    { 
        //
        // User has passed a pointer to pointer and wants us to return 
        // a buffer back
        //

        pbyReturn = NULL;
    }
    else
    {
        //
        // User wants us to grow the pool but not return a buffer.
        // Set the pbyReturn to a non null value, this way all buffers
        // will be freed to pool
        //

        pbyReturn = (PBYTE)1;
    }

    //
    // For each slice of the block, where a slice consists of a BUFFER_HEAD
    // and the buffer memory that immediately follows it...
    //
   
#define NEXT_HEAD(h)                            \
    (PBUFFER_HEAD)((ULONG_PTR)(h) + ALIGN8_HEAD_SIZE + ALIGN_UP(pPool->ulBufferSize, ULONGLONG))

    for(i = 0, pHead = (PBUFFER_HEAD)((ULONG_PTR)pNew + ALIGN8_BLOCK_SIZE);
        i < pPool->ulBuffersPerBlock;
        i++, pHead = NEXT_HEAD(pHead))
    {
        pbyBuffer = BUFFER_FROM_HEAD(pHead);
        
        InitializeListHead(&pHead->leFreeBufferLink);

#if LIST_DBG
        
        pHead->leListLink.Flink = NULL;
        pHead->leListLink.Blink = NULL;

        //
        // Set to TRUE here because the FreeBuffer below expects it to 
        // be true
        //

        pHead->bBusy = TRUE;

#endif

        pHead->pBlock       = pNew;
        pHead->pNdisBuffer  = NULL;
        
        if(fAssociateNdisBuffer)
        {
            //
            // Associate an NDIS_BUFFER descriptor from the pool we
            // allocated above.
            //
            
            NdisAllocateBuffer(&nsStatus,
                               &pHead->pNdisBuffer,
                               pNew->nhNdisPool,
                               pbyBuffer,
                               pPool->ulBufferSize);
            
            if(nsStatus isnot NDIS_STATUS_SUCCESS)
            {
                Trace(MEMORY, ERROR,
                      ("AddBufferBlockToPool: Status %x allocating buffer\n",
                       nsStatus));

                continue;
            }
        }
        
        if(pbyReturn)
        {
            //
            // Add the constructed buffer to the list of free buffers.
            // The 'FALSE' tells the garbage collection algorithm the
            // operation is an "add" rather than a "release" and should be
            // ignored.
            //
            
            FreeBufferToPoolEx(pPool,
                               pbyBuffer,
                               FALSE);
        }   
        else    
        {   
            //
            // The first successfully constructed buffer is returned by
            // this routine.
            //
            
            pbyReturn = pbyBuffer;
        }
    }

    if(ppbyRetBuff isnot NULL)
    {
        RtAssert(pbyReturn);

        *ppbyRetBuff = pbyReturn;
    }

    return TRUE;
}


VOID
FreeUnusedPoolBlocks(
    IN PBUFFER_POOL pPool
    )

/*++
  
Routine Description

    Check if any of the blocks in pool 'pPool' are not in use, and if so,
    free them.

Locks

    IMPORTANT: Caller must hold the pool lock.

    The MSDN doc says that no locks may be held while calling
    NdisFreePacketXxx, but according to JameelH that is incorrect.

Arguments


Return Value

    None
    
--*/

{
    PLIST_ENTRY     pleNode, pleNextNode;
    PBUFFER_BLOCK   pBlock;
    ULONG           i;
    PBUFFER_HEAD    pHead;

    //
    // For each block in the pool...
    //
    
    pleNode = pPool->leBlockHead.Flink;
    
    while(pleNode isnot &pPool->leBlockHead)
    {
        pleNextNode = pleNode->Flink;

        pBlock = CONTAINING_RECORD(pleNode, BUFFER_BLOCK, leBlockLink);
        
        if(pBlock->ulFreeBuffers == pPool->ulBuffersPerBlock)
        {
            //
            // Found a block with no buffers in use.  Walk the buffer block
            // removing each buffer from the pool's free list and freeing any
            // associated NDIS_BUFFER descriptor.
            //
           
            pHead = (PBUFFER_HEAD)((ULONG_PTR)pBlock + ALIGN8_BLOCK_SIZE);
 
            for(i = 0;
                i < pPool->ulBuffersPerBlock;
                i++, pHead = NEXT_HEAD(pHead))
            {

#if LIST_DBG

                RtAssert(IsEntryOnList(&(pPool->leFreeBufferHead),
                                       &(pHead->leFreeBufferLink)));

                RtAssert(NotOnList(pHead));
                RtAssert(!(pHead->bBusy));

#endif

                RemoveEntryList(&pHead->leFreeBufferLink);

                if(pHead->pNdisBuffer)
                {
                    NdisFreeBuffer(pHead->pNdisBuffer);
                }
            }

            //
            // Remove and release the unused block.
            //
            
            RemoveEntryList(pleNode);
            
            pPool->ulCurBuffers -= pPool->ulBuffersPerBlock;

            if(pBlock->nhNdisPool)
            {
                NdisFreeBufferPool(pBlock->nhNdisPool);
            }

            RtFree(pBlock);
        }
        else
        {
            RtAssert(pBlock->ulFreeBuffers < pPool->ulBuffersPerBlock);
        }

        pleNode = pleNextNode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\dim\server\util.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    util.c
//
// Description: Various miscillaneous routines
//
// History:     May 11,1995	    NarenG		Created original version.
//

#include "dimsvcp.h"

//**
//
// Call:        GetTransportIndex
//
// Returns:     Index of the tansport entry in the interface object
//
// Description: Given the id of a protocol return an index.
//
DWORD
GetTransportIndex(
    IN DWORD dwProtocolId
)
{
    DWORD dwTransportIndex;

    for ( dwTransportIndex = 0;
          dwTransportIndex < gblDIMConfigInfo.dwNumRouterManagers;
          dwTransportIndex++ )
    {
        if ( gblRouterManagers[dwTransportIndex].DdmRouterIf.dwProtocolId
                                                            == dwProtocolId )
        {
            return( dwTransportIndex );
        }
    }

    return( (DWORD)-1 );
}

//**
//
// Call:        GetDDMEntryPoint
//
// Returns:     Pointer to entry point into DDM - success
//              NULL - failure
//
// Description: Will return the entry point into the DDM if there is one.
//
FARPROC
GetDDMEntryPoint(
    IN LPSTR    lpEntryPoint
)
{
    DWORD   dwIndex;

    for ( dwIndex = 0; 
          gblDDMFunctionTable[dwIndex].lpEntryPointName != NULL;
          dwIndex ++ )
    {
        if ( _stricmp( gblDDMFunctionTable[dwIndex].lpEntryPointName,
                      lpEntryPoint ) == 0 )
        {       
            return( gblDDMFunctionTable[dwIndex].pEntryPoint );
        }
    }

    return( NULL );
}

//**
//
// Call:        GetSizeOfDialoutHoursRestriction
//
// Returns:     size in bytes of lpwsDialoutHoursRestriction
//
// Description: Utility to calculate the size in bytes of the MULTI_SZ pointed
//              to by lpwsDialoutHoursRestriction.
//
DWORD
GetSizeOfDialoutHoursRestriction(
    IN LPWSTR   lpwsMultSz
)
{
    LPWSTR lpwsPtr = lpwsMultSz;
    DWORD dwcbBytes  = 0;
    DWORD dwCurCount;

    if ( lpwsMultSz == NULL )
    {
        return( 0 );
    }

    while( *lpwsPtr != L'\0' )
    {
        dwCurCount = ( wcslen( lpwsPtr ) + 1 );
        dwcbBytes += dwCurCount;
        lpwsPtr += dwCurCount;
    }

    //
    // One more for the last NULL terminator
    //

    dwcbBytes++;

    dwcbBytes *= sizeof( WCHAR );

    return( dwcbBytes );
}

//**
//
// Call:    IsInterfaceRoleAcceptable
//
// Returns: TRUE if the interface plays a role that is compatible with the 
//          given transport and router configuration.
//
//          FALSE otherwise.
//
// Description: Some interfaces are only acceptable to some transports when 
//              the router is running in a certain mode.  The classic example 
//              is the internal ip interface which will be rejected by the IP 
//              router manager when in lan-only mode.
//
//              The acceptable roles are hardcoded in this function.
//              At the time this function was written, there was only one 
//              interface (internal ip) whose role was important to any 
//              transport.  In the future, instead of harcoding more roles 
//              into this function, we should consider adding "role" as a 
//              per-interface property both to the runtime structures 
//              and to the permanant store.
//
BOOL
IsInterfaceRoleAcceptable(
    IN ROUTER_INTERFACE_OBJECT* pIfObject,
    IN DWORD dwTransportId)
{
    if (pIfObject == NULL)
    {
        return FALSE;
    }
    
    if ((gblDIMConfigInfo.dwRouterRole == ROUTER_ROLE_LAN)  &&
        (dwTransportId == PID_IP)                           && 
        (pIfObject->IfType == ROUTER_IF_TYPE_INTERNAL))
    {
        return FALSE;
    }

    return TRUE;
}

#ifdef MEM_LEAK_CHECK
//**
//
// Call:        DebugAlloc
//
// Returns:     return from HeapAlloc
//
// Description: Will use the memory table to store the pointer returned by
//              LocalAlloc
//
LPVOID
DebugAlloc( DWORD Flags, DWORD dwSize )
{
    DWORD Index;
    LPVOID pMem = HeapAlloc(gblDIMConfigInfo.hHeap, HEAP_ZERO_MEMORY,dwSize+4);

    if ( pMem == NULL )
    {
        return( pMem );
    }

    for( Index=0; Index < DIM_MEM_TABLE_SIZE; Index++ )
    {
        if ( DimMemTable[Index] == NULL )
        {
            DimMemTable[Index] = pMem;
            break;
        }
    }

    //
    // Our signature
    //

    *(((LPBYTE)pMem)+dwSize)   = 0x0F;
    *(((LPBYTE)pMem)+dwSize+1) = 0x0E;
    *(((LPBYTE)pMem)+dwSize+2) = 0x0A;
    *(((LPBYTE)pMem)+dwSize+3) = 0x0B;

    RTASSERT( Index != DIM_MEM_TABLE_SIZE );

    return( pMem );
}

//**
//
// Call:        DebugFree
//
// Returns:     return from HeapFree
//
// Description: Will remove the pointer from the memeory table before freeing
//              the memory block
//
BOOL
DebugFree( PVOID pMem )
{
    DWORD Index;

    for( Index=0; Index < DIM_MEM_TABLE_SIZE; Index++ )
    {
        if ( DimMemTable[Index] == pMem )
        {
            DimMemTable[Index] = NULL;
            break;
        }
    }

    RTASSERT( Index != DIM_MEM_TABLE_SIZE );

    return( HeapFree( gblDIMConfigInfo.hHeap, 0, pMem ) );
}

//**
//
// Call:        DebugReAlloc
//
// Returns:     return from HeapReAlloc
//
// Description: Will change the value of the realloced pointer.
//
LPVOID
DebugReAlloc( PVOID pMem, DWORD dwSize )
{
    DWORD Index;

    if ( pMem == NULL )
    {
        RTASSERT(FALSE);
    }

    for( Index=0; Index < DDM_MEM_TABLE_SIZE; Index++ )
    {
        if ( DdmMemTable[Index] == pMem )
        {
            DdmMemTable[Index] = HeapReAlloc( gblDDMConfigInfo.hHeap,
                                              HEAP_ZERO_MEMORY,
                                              pMem, dwSize+8 );

            pMem = DdmMemTable[Index];

            *((LPDWORD)pMem) = dwSize;

            ((LPBYTE)pMem) += 4;

            //
            // Our signature
            //

            *(((LPBYTE)pMem)+dwSize)   = 0x0F;
            *(((LPBYTE)pMem)+dwSize+1) = 0x0E;
            *(((LPBYTE)pMem)+dwSize+2) = 0x0A;
            *(((LPBYTE)pMem)+dwSize+3) = 0x0B;

            break;
        }
    }

    RTASSERT( Index != DDM_MEM_TABLE_SIZE );

    return( (LPVOID)pMem );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\dimif.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    dimif.h
//
// Description: Contains definitions of data structures and contstants used
//              by components that interface with DIM. (DDM)
//
// History:     May 11,1995	    NarenG		Created original version.
//

#ifndef _DIMIF_
#define _DIMIF_

#define NUM_IF_BUCKETS              31  // # of buckets in the interface hash
                                        // table
//
// Debug trace component values
//

#define TRACE_DIM                   (0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC|TRACE_USE_DATE)
#define TRACE_FSM                   (0x00020000|TRACE_USE_MASK|TRACE_USE_MSEC|TRACE_USE_DATE)
#define TRACE_MESSAGES              (0x00040000|TRACE_USE_MASK|TRACE_USE_MSEC|TRACE_USE_DATE)
#define TRACE_NETBIOS               (0x00080000|TRACE_USE_MASK|TRACE_USE_MSEC|TRACE_USE_DATE)
#define TRACE_STACK                 (0x00100000|TRACE_USE_MASK|TRACE_USE_MSEC|TRACE_USE_DATE)
#define TRACE_SECURITY              (0x00200000|TRACE_USE_MASK|TRACE_USE_MSEC|TRACE_USE_DATE)
#define TRACE_TIMER                 (0x00400000|TRACE_USE_MASK|TRACE_USE_MSEC|TRACE_USE_DATE)

//
//  This represents a router manager in the DIM
//

typedef struct _ROUTER_MANAGER_OBJECT
{
    BOOL                    fIsRunning;

    LPVOID                  pDefaultClientInterface;

    DWORD                   dwDefaultClientInterfaceSize;

    HMODULE                 hModule;

    DIM_ROUTER_INTERFACE    DdmRouterIf;

} ROUTER_MANAGER_OBJECT, *PROUTER_MANAGER_OBJECT;

//
// Various states that an router interface can have.
//

typedef enum ROUTER_INTERFACE_STATE
{
    RISTATE_DISCONNECTED,
    RISTATE_CONNECTING,
    RISTATE_CONNECTED

} ROUTER_INTERFACE_STATE;

//
// State flags for each Transport Interface
//

#define RITRANSPORT_CONNECTED   0x00000001
#define RITRANSPORT_ENABLED     0x00000002

//
//  This represents an interface for a certain transport
//

typedef struct _ROUTER_INTERFACE_TRANSPORT
{
    HANDLE  hInterface;

    DWORD   fState;

} ROUTER_INTERFACE_TRANSPORT, *PROUTER_INTERFACE_TRANSPORT;

//
// This represents a WAN/LAN interface in the DIM.
//

#define IFFLAG_LOCALLY_INITIATED            0x00000001
#define IFFLAG_PERSISTENT                   0x00000002
#define IFFLAG_ENABLED                      0x00000004
#define IFFLAG_OUT_OF_RESOURCES             0x00000008
#define IFFLAG_DISCONNECT_INITIATED         0x00000010
#define IFFLAG_CONNECTION_FAILURE           0x00000020
#define IFFLAG_DIALOUT_HOURS_RESTRICTION    0x00000040
#define IFFLAG_NO_MEDIA_SENSE               0x00000080
#define IFFLAG_NO_DEVICE                    0x00000100
#define IFFLAG_DIALMODE_DIALASNEEDED        0x00000200
#define IFFLAG_DIALMODE_DIALALL             0x00000400

typedef struct _ROUTER_INTERFACE_OBJECT
{
    struct _ROUTER_INTERFACE_OBJECT * pNext;

    HANDLE                      hDIMInterface;  // Handle to this interface

    ROUTER_INTERFACE_STATE      State;

    ROUTER_INTERFACE_TYPE       IfType;

    HCONN                       hConnection;

    HRASCONN                    hRasConn;

    DWORD                       fMediaUsed;

    DWORD                       fFlags;

    DWORD                       dwNumSubEntries;

    DWORD                       dwNumSubEntriesCounter;

    DWORD                       dwNumOfReConnectAttempts;

    DWORD                       dwNumOfReConnectAttemptsCounter;

    DWORD                       dwSecondsBetweenReConnectAttempts;

    DWORD                       dwReachableAfterSecondsMin;

    DWORD                       dwReachableAfterSecondsMax;

    DWORD                       dwReachableAfterSeconds;

    HANDLE                      hEventNotifyCaller;

    LPWSTR                      lpwsInterfaceName;

    DWORD                       dwLastError;

    LPWSTR                      lpwsDialoutHoursRestriction;

    PPP_INTERFACE_INFO          PppInterfaceInfo;

    ROUTER_INTERFACE_TRANSPORT  Transport[1];       // Array of Transports

} ROUTER_INTERFACE_OBJECT, *PROUTER_INTERFACE_OBJECT;

//
// This represents the hash table of Router Interface Objects
//

typedef struct _ROUTER_INTERFACE_TABLE
{
    DWORD                       dwNumTotalInterfaces;

    DWORD                       dwNumLanInterfaces;

    DWORD                       dwNumWanInterfaces;

    DWORD                       dwNumClientInterfaces;

    ROUTER_INTERFACE_OBJECT *   IfBucket[NUM_IF_BUCKETS]; // Array of buckets

    CRITICAL_SECTION            CriticalSection;        // Mutual exclusion 
                                                        // around this table

} ROUTER_INTERFACE_TABLE, *PROUTER_INTERFACE_TABLE;

//
// Router identity attribute structure definition.
//

typedef struct _ROUTER_IDENTITY_ATTRIBUTE_
{
    DWORD dwVendorId;
    DWORD dwType;
    DWORD dwValue;

} ROUTER_IDENTITY_ATTRIBUTE, *PROUTER_IDENTITY_ATTRIBUTE;

//
// Interface Object manipulation functions
//


ROUTER_INTERFACE_OBJECT *
IfObjectAllocateAndInit(
    IN  LPWSTR                  lpwstrName,
    IN  ROUTER_INTERFACE_STATE  State,
    IN  ROUTER_INTERFACE_TYPE   IfType,
    IN  HCONN                   hConnection,
    IN  BOOL                    fEnabled,
    IN  DWORD                   dwReachableAfterSecondsMin,
    IN  DWORD                   dwReachableAfterSecondsMax,
    IN  LPWSTR                  lpwsDialoutHours,
    IN OUT PVOID *              ppvContext
);

DWORD
IfObjectInsertInTable(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

ROUTER_INTERFACE_OBJECT *
IfObjectGetPointer(
    IN HANDLE hDIMInterface
);

ROUTER_INTERFACE_OBJECT *
IfObjectGetPointerByName(
    IN LPWSTR lpwstrName,
    IN BOOL   fIncludeClientInterfaces
);

DWORD
IfObjectHashIfHandleToBucket(
    IN HANDLE hDIMInterface
);

VOID
IfObjectRemove(
    IN HANDLE hDIMInterface
);

BOOL
IfObjectDoesLanInterfaceExist(
    VOID
);

VOID
IfObjectFree(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

VOID
IfObjectWANDeviceInstalled(
    IN BOOL fWANDeviceInstalled
);

VOID
IfObjectNotifyOfReachabilityChange(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN BOOL                      fReachable,
    IN UNREACHABILITY_REASON     dwReason
);

BOOL
IfObjectIsLANDeviceActive(
    IN  LPWSTR                      lpwsInterfaceName,
    OUT LPDWORD                     lpdwInactiveReason
);

VOID
IfObjectNotifyOfMediaSenseChange(
    VOID
);

VOID
IfObjectDeleteInterfaceFromTransport(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN DWORD                     dwPid
);

//
// Router identity object function prototypes
//

DWORD
RouterIdentityObjectOpen(
    IN  LPWSTR      lpwszRouterName,
    IN  DWORD       dwRouterType,
    OUT HANDLE *    phObjectRouterIdentity
);

VOID
RouterIdentityObjectClose(
    IN HANDLE hObjectRouterIdentity
);

BOOL
RouterIdentityObjectIsValueSet(
    IN HANDLE   hRouterIdentityAttributes,
    IN DWORD    dwVendorId,
    IN DWORD    dwType,
    IN DWORD    dwValue
);

DWORD
RouterIdentityObjectGetValue(
    IN HANDLE   hRouterIdentityAttributes,
    IN DWORD    dwValueIndex,
    IN DWORD *  lpdwVendorId,
    IN DWORD *  lpdwType,
    IN DWORD *  lpdwValue
);

DWORD
RouterIdentityObjectAddRemoveValue(
    IN  HANDLE      hRouterIdentityObject,
    IN  DWORD       dwVendorId,
    IN  DWORD       dwType,
    IN  DWORD       dwValue,
    IN  BOOL        fAdd
);

VOID
RouterIdentityObjectFreeAttributes(
    IN HANDLE   hRouterIdentityAttributes
);

DWORD
RouterIdentityObjectSetAttributes(
    IN HANDLE  hRouterIdentityObject
);

VOID
RouterIdentityObjectUpdateAttributes(
    IN PVOID    pParameter,
    IN BOOLEAN  fTimedOut
);

VOID
RouterIdentityObjectUpdateDDMAttributes(
    VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\iputils.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\defs.c

Abstract:
    IP Router Manager defines

Revision History:

    Gurdeep Singh Pall          6/16/95  Created

--*/

#ifndef __IPUTILS_H__
#define __IPUTILS_H__

//
// LONG
// Cmp(DWORD dwFirst, DWORD dwSecond, LONG lResult)
//

#define Cmp(dwFirst,dwSecond,lResult) ((LONG)((lResult) = ((dwFirst) - (dwSecond))))

//
// LONG
// PortCmp(WORD wPort1, WORD wPort2, LONG lResult)
//

#define PortCmp(dwPort1, dwPort2,lResult) ((LONG)((lResult) = ((ntohs((WORD)dwPort1)) - (ntohs((WORD)dwPort2)))))

// The addresses are in Network order

//
// LONG
// InetCmp(DWORD IpAddr1, DWORD IpAddr2, LONG lResult)
//

#define InetCmp(dwIpAddr1,dwIpAddr2,res)                                                            \
            ((LONG)(((res) = (((dwIpAddr1) & 0x000000ff) - ((dwIpAddr2) & 0x000000ff))) ? (res)   : \
                    (((res) = (((dwIpAddr1) & 0x0000ff00) - ((dwIpAddr2) & 0x0000ff00))) ? (res)  : \
                     (((res) = (((dwIpAddr1) & 0x00ff0000) - ((dwIpAddr2) & 0x00ff0000))) ? (res) : \
                      ((res) = ((((dwIpAddr1) & 0xff000000)>>8) - (((dwIpAddr2) & 0xff000000)>>8)))))))


#endif // __IPUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\ipbootp.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    ipbootp.h
//
// History:
//      Abolade Gbadegesin  August 31, 1995     Created
//
// Definitions for IP BOOTP Relay Agent, used by IP Router Manager
//============================================================================


#ifndef _IPBOOTP_H_
#define _IPBOOTP_H_



//----------------------------------------------------------------------------
// CONSTANTS AND MACRO DECLARATIONS
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// current bootp config version
//----------------------------------------------------------------------------

#define BOOTP_CONFIG_VERSION_500    500



//----------------------------------------------------------------------------
// constants for the MIB tables exposed b IPBOOTP
//----------------------------------------------------------------------------

#define IPBOOTP_GLOBAL_CONFIG_ID    0
#define IPBOOTP_IF_STATS_ID         1
#define IPBOOTP_IF_CONFIG_ID        2
#define IPBOOTP_IF_BINDING_ID       3



//----------------------------------------------------------------------------
// constants for the field IPBOOTP_GLOBAL_CONFIG::GC_LoggingLevel
//----------------------------------------------------------------------------

#define IPBOOTP_LOGGING_NONE        0
#define IPBOOTP_LOGGING_ERROR       1
#define IPBOOTP_LOGGING_WARN        2
#define IPBOOTP_LOGGING_INFO        3




//----------------------------------------------------------------------------
// constants used for the fields IPBOOTP_IF_STATS::IS_State
// and IPBOOTP_IF_CONFIG::IC_State
//----------------------------------------------------------------------------

#define IPBOOTP_STATE_ENABLED       0x00000001
#define IPBOOTP_STATE_BOUND         0x00000002




//----------------------------------------------------------------------------
// constants for the field IPBOOTP_IF_CONFIG::IC_RelayMode
//----------------------------------------------------------------------------

#define IPBOOTP_RELAY_DISABLED      0
#define IPBOOTP_RELAY_ENABLED       1




//----------------------------------------------------------------------------
// macros for manipulating the variable length IPBOOTP_GLOBAL_CONFIG struct
//
// IPBOOTP_GLOBAL_CONFIG_SIZE computes the size of a global config struct
//
// IPBOOTP_GLOBAL_SERVER_TABLE computes the starting address of the series
//  of DHCP/BOOTP server IP addresses in a global config struct
//
// e.g.
//      PIPBOOTP_GLOBAL_CONFIG pigcSource, pigcDest;
//
//      pigcDest = malloc(IPBOOTP_GLOBAL_CONFIG_SIZE(pigcSource));
//      memcpy(pigcDest, pigcSource, IPBOOTP_GLOBAL_CONFIG_SIZE(pigcSource));
//
// e.g.
//      DWORD i, *pdwSrv;
//      PIPBOOTP_GLOBAL_CONFIG pigc;
//
//      pdwSrv = IPBOOTP_GLOBAL_SERVER_TABLE(pigc);
//      for (i = 0; i < pigc->GC_ServerCount; i++) {
//          printf("%s\n", inet_ntoa(*(struct in_addr *)pdwSrv));
//      }
//----------------------------------------------------------------------------

#define IPBOOTP_GLOBAL_CONFIG_SIZE(cfg) \
        (sizeof(IPBOOTP_GLOBAL_CONFIG) + (cfg)->GC_ServerCount * sizeof(DWORD))
#define IPBOOTP_GLOBAL_SERVER_TABLE(cfg) ((PDWORD)((cfg) + 1))




//----------------------------------------------------------------------------
// macros for manipulating the variable-length IPBOOTP_IF_BINDING structure
//
// IPBOOTP_IF_BINDING_SIZE computes the size of a binding structure.
//
// IPBOOTP_IF_ADDRESS_TABLE computes the starting address in a binding struct
//      of the series of IPBOOTP_IP_ADDRESS structures which are the bindings
//      for the interface in question.
//
// e.g.
//      PIPBOOTP_IF_BINDING piibSource, piibDest;
//
//      piibDest = malloc(IPBOOTP_IF_BINDING_SIZE(piicSource));
//      memcpy(piibDest, piicSource, IPBOOTP_IF_BINDING_SIZE(piicSource));
//
// e.g.
//      DWORD i;
//      PIPBOOTP_IF_BINDING piib;
//      PIPBOOTP_IP_ADDRESS *pdwAddr;
//
//      pdwAddr = IPBOOTP_IF_ADDRESS_TABLE(piib);
//      for (i = 0; i < piib->IB_AddrCount; i++) {
//          printf("%s-", inet_ntoa(*(struct in_addr *)&pdwAddr->IA_Address));
//          printf("%s\n", inet_ntoa(*(struct in_addr *)&pdwAddr->IA_Netmask));
//      }
//----------------------------------------------------------------------------

#define IPBOOTP_IF_BINDING_SIZE(bind) \
        (sizeof(IPBOOTP_IF_BINDING) + \
         (bind)->IB_AddrCount * sizeof(IPBOOTP_IP_ADDRESS))

#define IPBOOTP_IF_ADDRESS_TABLE(bind)  ((PIPBOOTP_IP_ADDRESS)((bind) + 1))






//----------------------------------------------------------------------------
// STRUCTURE DEFINITIONS
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// struct:      IPBOOTP_GLOBAL_CONFIG
//
// This MIB entry stores global configuration for IPBOOTP.
// There is only one instance, so this entry has no index.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
// after the base structure comes an array of GC_ServerCount DWORDs,
// each of which contains an IP address which is a DHCP/BOOTP server
// to which packets will be sent.
//
// All IP address fields must be in network order.
//----------------------------------------------------------------------------

typedef struct _IPBOOTP_GLOBAL_CONFIG {

    DWORD       GC_LoggingLevel;
    DWORD       GC_MaxRecvQueueSize;
    DWORD       GC_ServerCount;

} IPBOOTP_GLOBAL_CONFIG, *PIPBOOTP_GLOBAL_CONFIG;




//----------------------------------------------------------------------------
// struct:      IPBOOTP_IF_STATS
//
// This MIB entry stores per-interface statistics for IPBOOTP.
// All IP addresses are in network order.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPBOOTP_IF_STATS {

    DWORD       IS_State;
    DWORD       IS_SendFailures;
    DWORD       IS_ReceiveFailures;
    DWORD       IS_ArpUpdateFailures;
    DWORD       IS_RequestsReceived;
    DWORD       IS_RequestsDiscarded;
    DWORD       IS_RepliesReceived;
    DWORD       IS_RepliesDiscarded;

} IPBOOTP_IF_STATS, *PIPBOOTP_IF_STATS;




//----------------------------------------------------------------------------
// struct:      IPBOOTP_IF_CONFIG
//
// This MIB entry describes per-interface configuration
// All IP address are in network order.
//
// Note:
//      The field IC_State is read-only.
//----------------------------------------------------------------------------

typedef struct _IPBOOTP_IF_CONFIG {

    DWORD       IC_State;
    DWORD       IC_RelayMode;
    DWORD       IC_MaxHopCount;
    DWORD       IC_MinSecondsSinceBoot;

} IPBOOTP_IF_CONFIG, *PIPBOOTP_IF_CONFIG;




//----------------------------------------------------------------------------
// struct:      IPBOOTP_IF_BINDING
//
// This MIB entry contains the table of IP addresses to which each interface
// is bound.
// All IP addresses are in network order.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
//  The base structure contains of the field IB_AddrCount, which gives
//  the number of IP addresses to which the indexed interface is bound.
//  The IP addresses themselves follow the base structure, and are given
//  as IPBOOTP_IP_ADDRESS structures.
//
// This MIB entry is read-only.
//----------------------------------------------------------------------------

typedef struct _IPBOOTP_IF_BINDING {

    DWORD       IB_State;
    DWORD       IB_AddrCount;

} IPBOOTP_IF_BINDING, *PIPBOOTP_IF_BINDING;




//----------------------------------------------------------------------------
// struct:      IPBOOTP_IP_ADDRESS
//
// This structure is used for storing interface bindings.
// A series of structures of this type follows the IPBOOTP_IF_BINDING
// structure (described above).
//
// Both fields are IP address fields in network-order.
//----------------------------------------------------------------------------

typedef struct _IPBOOTP_IP_ADDRESS {

    DWORD       IA_Address;
    DWORD       IA_Netmask;

} IPBOOTP_IP_ADDRESS, *PIPBOOTP_IP_ADDRESS;





//----------------------------------------------------------------------------
// struct:      IPBOOTP_MIB_SET_INPUT_DATA
//
// This is passed as input data for MibSet
// Note that only the global config and interface config are writable
//----------------------------------------------------------------------------

typedef struct _IPBOOTP_MIB_SET_INPUT_DATA {

    DWORD       IMSID_TypeID;
    DWORD       IMSID_IfIndex;
    DWORD       IMSID_BufferSize;
    DWORD       IMSID_Buffer[1];

} IPBOOTP_MIB_SET_INPUT_DATA, *PIPBOOTP_MIB_SET_INPUT_DATA;




//----------------------------------------------------------------------------
// struct:      IPBOOTP_MIB_GET_INPUT_DATA
//
// This is passed as input data for MibGet, MibGetFirst, and MibGetNext
//----------------------------------------------------------------------------

typedef struct _IPBOOTP_MIB_GET_INPUT_DATA {

    DWORD       IMGID_TypeID;
    DWORD       IMGID_IfIndex;

} IPBOOTP_MIB_GET_INPUT_DATA, *PIPBOOTP_MIB_GET_INPUT_DATA;





//----------------------------------------------------------------------------
// struct:      IPBOOTP_MIB_GET_OUTPUT_DATA
//
// This is passed as output data for MibGet, MibGetFirst, and MibGetNext
// Note that at the end of a table MibGetNext wraps to the next table,
// and therefore the value IMGOD_TypeID should be examined to see the type
// of the data returned in the output buffer
//----------------------------------------------------------------------------

typedef struct _IPBOOTP_MIB_GET_OUTPUT_DATA {

    DWORD       IMGOD_TypeID;
    DWORD       IMGOD_IfIndex;
    BYTE        IMGOD_Buffer[1];

} IPBOOTP_MIB_GET_OUTPUT_DATA, *PIPBOOTP_MIB_GET_OUTPUT_DATA;


//----------------------------------------------------------------------------
// Function:    EnableDhcpInformServer
//              DisableDhcpInformServer
//
// Routines used by the RAS server to redirect DHCP inform packets
// to a particular server.
//----------------------------------------------------------------------------

VOID APIENTRY
EnableDhcpInformServer(
    DWORD DhcpInformServer
    );

VOID APIENTRY
DisableDhcpInformServer(
    VOID
    );

#endif // _IPBOOTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\ipxrterr.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxrterr.h

Abstract:

    This module contains the definitions of the IPX Router error codes

Author:

    Stefan Solomon  03/16/1995

Revision History:


--*/

#ifndef _IPXRTERR_
#define _IPXRTERR_

//*********************************************************
//							  *
//		 IPX Router APIs Return Codes		  *
//							  *
//*********************************************************

#define     IPX_ERROR_BASE				30000

#define     IPX_ERROR_NONEXISTENT_ENTRY			IPX_ERROR_BASE + 1
#define     IPX_ERROR_NO_MORE_ITEMS			IPX_ERROR_BASE + 2
#define     IPX_ERROR_INVALID_PARAMETER			IPX_ERROR_BASE + 3
#define     IPX_ERROR_OUT_OF_RESOURCES			IPX_ERROR_BASE + 4
#define     IPX_ERROR_INTERNAL				IPX_ERROR_BASE + 5
#define     IPX_ERROR_PENDING				IPX_ERROR_BASE + 6
#define     IPX_ERROR_INVALID_INTERFACE			IPX_ERROR_BASE + 7
#define     IPX_ERROR_INVALID_GROUP_ID			IPX_ERROR_BASE + 8
#define     IPX_ERROR_INVALID_TABLE_ID			IPX_ERROR_BASE + 9
#define     IPX_INVALID_FUNCTION			IPX_ERROR_BASE + 10
#define     IPX_ERROR_MISSING_INTERFACE_INFO		IPX_ERROR_BASE + 11
#define     IPX_ERROR_NETWORK_NUMBER_IN_USE		IPX_ERROR_BASE + 12
#define     IPX_ERROR_DUPLICATE_SERVER_NAMES		IPX_ERROR_BASE + 13
#define     IPX_ERROR_ROUTER_NOT_ACTIVE 		IPX_ERROR_BASE + 14
#define     IPX_ERROR_NO_WAN_NET_NUMBER 		IPX_ERROR_BASE + 15
#define     IPX_ERROR_NO_INTERFACE			IPX_ERROR_BASE + 16
#define     IPX_ERROR_ROUTER_DOWN			IPX_ERROR_BASE + 17


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\igmprm.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: igmprm.h
//
// Abstract:
//      Contains type definitions and declarations for IGMPv2 
//      used by the IP Router Manager.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================

#ifndef _IGMPRM_H_
#define _IGMPRM_H_

#define IGMP_CONFIG_VERSION_500 0x500
// next non-compatible version
#define IGMP_CONFIG_VERSION_600 0x600

#define IGMP_VERSION_1_2        0x201
//next incompatible version
#define IGMP_VERSION_1_2_5      0x250
#define IGMP_VERSION_3          0x301
//next non-compatible version
#define IGMP_VERSION_3_5        0x351

#define IS_IGMP_VERSION_1_2(Flag)  ((Flag)==0x201)
#define IS_IGMP_VERSION_3(Flag)    ((Flag)==0x301)
#define IS_CONFIG_IGMP_V3(pConfig) ((pConfig)->Version==IGMP_VERSION_3)


//----------------------------------------------------------------------------
// constants identifying IGMP's MIB tables. The "TypeId" is set to this value
//
// IGMP_GLOBAL_CONFIG_ID : returns the global config
// IGMP_IF_BINDING_ID    : returns list of bindings for each interface, and
//            for a RAS interface returns a list of current RAS clients.
// IGMP_IF_CONFIG_ID     : returns the config info for an interface
// IGMP_IF_STATS_ID      : returns the stats for an interface
// IGMP_IF_GROUPS_LIST_ID: returns the list of multicast group members on that
//            interface.
// IGMP_GROUP_IFS_LIST_ID: returns the list of interfaces joined for that
//            group
// IGMP_PROXY_INDEX_ID   : returns the index of interface owned by igmp proxy.
//----------------------------------------------------------------------------

#define IGMP_GLOBAL_CONFIG_ID               0
#define IGMP_GLOBAL_STATS_ID                1
#define IGMP_IF_BINDING_ID                  2
#define IGMP_IF_CONFIG_ID                   3
#define IGMP_IF_STATS_ID                    4
#define IGMP_IF_GROUPS_LIST_ID              5
#define IGMP_GROUP_IFS_LIST_ID              6
#define IGMP_PROXY_IF_INDEX_ID              7
#define IGMP_LAST_TABLE_ID                  7



//----------------------------------------------------------------------------
// Flags in "Flags"
//    used to control the data returned from MIB queries
//
// IGMP_ENUM_FOR_RAS_CLIENTS   : enumerate for ras clients only
// IGMP_ENUM_ONE_ENTRY         : return only one Interface-Group entry.
// IGMP_ENUM_ALL_INTERFACES_GROUPS: enumerate all interfaces. If enumeration
//              reaches end of an interface, it will go to the next interface
// IGMP_ENUM_INTERFACE_TABLE_BEGIN: indicate the beginning of a table.
// IGMP_ENUM_INTERFACE_TABLE_CONTINUE: enum for interface has to continue
// IGMP_ENUM_INTERFACE_TABLE_END: end of enumeration for that interface.
//----------------------------------------------------------------------------

// flags that are passed unchanged between calls during enumeration.

#define IGMP_ENUM_FOR_RAS_CLIENTS           0x0001
#define IGMP_ENUM_ONE_ENTRY                 0x0002
#define IGMP_ENUM_ALL_INTERFACES_GROUPS     0x0004
#define IGMP_ENUM_ALL_TABLES                0x0008
#define IGMP_ENUM_SUPPORT_FORMAT_IGMPV3     0x0010


// flags that are changed between calls during the enumeration

#define IGMP_ENUM_INTERFACE_TABLE_BEGIN     0x0100
#define IGMP_ENUM_INTERFACE_TABLE_CONTINUE  0x0200
#define IGMP_ENUM_INTERFACE_TABLE_END       0x0400

// set in response only
#define IGMP_ENUM_FORMAT_IGMPV3             0x1000


#define CLEAR_IGMP_ENUM_INTERFACE_TABLE_FLAGS(Flags) (Flags = (Flags&0x00FF))




//----------------------------------------------------------------------------
// Constants used for the field IfType
// IGMP_IF_NOT_RAS    : the interface is conneted to a LAN.
// IGMP_IF_RAS_ROUTER : the interface is connected to another router over RAS
// IGMP_IF_RAS_SERVER : the entry corresponds to a RAS server
//            if it contains stats, then it represents summarized stats
// IGMP_IF_RAS_CLIENT : the entry corresponds to a RAS client
// if IGMP_IF_PROXY: then one of the 1st 4 flags still will be set to enable
//            switch from proxy to igmp router
//----------------------------------------------------------------------------

#define IGMP_IF_NOT_RAS                     1
#define IGMP_IF_RAS_ROUTER                  2
#define IGMP_IF_RAS_SERVER                  3                
#define IGMP_IF_RAS_CLIENT                  4                
#define IGMP_IF_PROXY                       8

#define IS_IFTYPE_PROXY(IfType)             ((IfType) & IGMP_IF_PROXY)




//----------------------------------------------------------------------------
// Constants used for the field IgmpProtocolType
//----------------------------------------------------------------------------

#define IGMP_PROXY                          0
#define IGMP_ROUTER_V1                      1
#define IGMP_ROUTER_V2                      2
#define IGMP_ROUTER_V3                      3
#define IGMP_PROXY_V3                       0x10

#define IS_CONFIG_IGMPRTR(pConfig) \
    (((pConfig)->IgmpProtocolType==IGMP_ROUTER_V1) \
    ||((pConfig)->IgmpProtocolType==IGMP_ROUTER_V2) \
    ||((pConfig)->IgmpProtocolType==IGMP_ROUTER_V3) )
    
#define IS_CONFIG_IGMPRTR_V1(pConfig) ((pConfig)->IgmpProtocolType==IGMP_ROUTER_V1)
#define IS_CONFIG_IGMPRTR_V2(pConfig) ((pConfig)->IgmpProtocolType==IGMP_ROUTER_V2)
#define IS_CONFIG_IGMPRTR_V3(pConfig) ((pConfig)->IgmpProtocolType==IGMP_ROUTER_V3)
#define IS_CONFIG_IGMPPROXY(pConfig) \
    ((pConfig)->IgmpProtocolType==IGMP_PROXY \
    ||(pConfig)->IgmpProtocolType==IGMP_PROXY_V3)
#define IS_CONFIG_IGMPPROXY_V2(pConfig) ((pConfig)->IgmpProtocolType==IGMP_PROXY)
#define IS_CONFIG_IGMPPROXY_V3(pConfig) \
                                    ((pConfig)->IgmpProtocolType==IGMP_PROXY_V3)




//----------------------------------------------------------------------------
// constants used for the field IGMP_MIB_GLOBAL_CONFIG::LoggingLevel
//----------------------------------------------------------------------------

#define IGMP_LOGGING_NONE                   0
#define IGMP_LOGGING_ERROR                  1
#define IGMP_LOGGING_WARN                   2
#define IGMP_LOGGING_INFO                   3




//----------------------------------------------------------------------------
// constants used for the fields
// IGMP_MIB_IF_STATS::State, IGMP_MIB_IF_CONFIG::State and
// IGMP_MIB_IF_BINDING::State
//----------------------------------------------------------------------------

#define IGMP_STATE_BOUND                    0x01
#define IGMP_STATE_ENABLED_BY_RTRMGR        0x02
#define IGMP_STATE_ENABLED_IN_CONFIG        0x04
#define IGMP_STATE_ENABLED_BY_MGM           0x08

//
// the below are not flags. So check for equality after anding.
//

#define IGMP_STATE_MGM_JOINS_ENABLED        0x10
#define IGMP_STATE_ACTIVATED                0x07

#define IS_IGMP_STATE_MGM_JOINS_ENABLED(Flag) \
    (((Flag) & IGMP_STATE_MGM_JOINS_ENABLED) == IGMP_STATE_MGM_JOINS_ENABLED)
#define IS_IGMP_STATE_ACTIVATED(Flag) \
    (((Flag) & IGMP_STATE_ACTIVATED) == IGMP_STATE_ACTIVATED)



//----------------------------------------------------------------------------
// constants used for the field
//  IGMP_MIB_IF_STATS:QuerierState
//----------------------------------------------------------------------------

#define RTR_QUERIER                         0x10
#define RTR_NOT_QUERIER                     0x00

#define IS_IGMPRTR_QUERIER(flag)            (flag&0x10)




//----------------------------------------------------------------------------
// STRUCTURE DEFINITIONS
//----------------------------------------------------------------------------



//----------------------------------------------------------------------------
// struct:      IGMP_MIB_GLOBAL_CONFIG
//
// This MIB entry stores global configuration for IGMP
// There is only one instance, so this entry has no index.
//
// If RASClientStats is set, then per RAS client statistics is also kept
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_GLOBAL_CONFIG {

    DWORD       Version;
    DWORD       LoggingLevel;
    DWORD       RasClientStats;
    
} IGMP_MIB_GLOBAL_CONFIG, *PIGMP_MIB_GLOBAL_CONFIG;




//----------------------------------------------------------------------------
// struct:      IGMP_MIB_GLOBAL_STATS
//
// This MIB entry stores global statistics for IGMP
// There is only one instance, so this entry has no index.
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_GLOBAL_STATS {

    DWORD       CurrentGroupMemberships;
    DWORD       GroupMembershipsAdded;

} IGMP_MIB_GLOBAL_STATS, *PIGMP_MIB_GLOBAL_STATS;




//----------------------------------------------------------------------------
// enum:        IGMP_STATIC_GROUP_TYPE
//
// Igmp Static groups can be added to Igmp router in 3 modes:
//      IGMP_HOST_JOIN: group joined on a socket opened on that interface
//      IGMPRTR_JOIN_MGM_ONLY: the group is joined to MGM, so packets are
//                   forwarded out on that interface and not up in the stack.
//      IGMP_PROXY_JOIN: the group is statically joined on the proxy interface
// These are the values for IGMP_STATIC_GROUP::mode
//----------------------------------------------------------------------------

typedef enum _IGMP_STATIC_GROUP_TYPE {

    IGMP_HOST_JOIN    =1,
    IGMPRTR_JOIN_MGM_ONLY
    
} IGMP_STATIC_GROUP_TYPE;
    



//----------------------------------------------------------------------------
// struct:      IGMP_STATIC_GROUP
//----------------------------------------------------------------------------

typedef struct _IGMP_STATIC_GROUP {

    DWORD                   GroupAddr;
    IGMP_STATIC_GROUP_TYPE  Mode;

} IGMP_STATIC_GROUP, *PIGMP_STATIC_GROUP;

//----------------------------------------------------------------------------
// struct:      STATIC_GROUP_V3
//----------------------------------------------------------------------------

#define INCLUSION 1
#define EXCLUSION 0

typedef struct _IGMP_STATIC_GROUP_V3 {

    DWORD                   GroupAddr;
    IGMP_STATIC_GROUP_TYPE  Mode;

    DWORD       FilterType;
    DWORD       NumSources;
    //DWORD       Sources[0];
    
} IGMP_STATIC_GROUP_V3, *PIGMP_STATIC_GROUP_V3;


//----------------------------------------------------------------------------
// struct:      IGMP_MIB_IF_CONFIG
//
// This  entry describes per-interface configuration.
// All IP address fields must be in network order.
// IfIndex, IpAddr, IfType are set by the igmp module. It is not set when 
// AddInterface is called
//
// Flags:   IGMP_INTERFACE_ENABLED_IN_CONFIG
//          IGMP_ACCEPT_RTRALERT_PACKETS_ONLY
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_IF_CONFIG {
    
    DWORD       Version;
    DWORD       IfIndex; //read only:index
    DWORD       IpAddr;  //read only
    DWORD       IfType;  //read only

    DWORD       Flags;

    DWORD       IgmpProtocolType;
    DWORD       RobustnessVariable;
    DWORD       StartupQueryInterval;
    DWORD       StartupQueryCount;
    DWORD       GenQueryInterval;
    DWORD       GenQueryMaxResponseTime;
    DWORD       LastMemQueryInterval;
    DWORD       LastMemQueryCount;
    DWORD       OtherQuerierPresentInterval;//read only
    DWORD       GroupMembershipTimeout;     //read only
    DWORD       NumStaticGroups;
    
} IGMP_MIB_IF_CONFIG, *PIGMP_MIB_IF_CONFIG;


//
// static groups
//

#define GET_FIRST_IGMP_STATIC_GROUP(pConfig) \
                        ((PIGMP_STATIC_GROUP)((PIGMP_MIB_IF_CONFIG)(pConfig)+1))

#define IGMP_MIB_IF_CONFIG_SIZE(pConfig) \
                        (sizeof(IGMP_MIB_IF_CONFIG) + \
                        (pConfig)->NumStaticGroups*sizeof(IGMP_STATIC_GROUP))

#define GET_FIRST_IGMP_STATIC_GROUP_V3(pConfig) \
                        ((PIGMP_STATIC_GROUP_V3)((PIGMP_MIB_IF_CONFIG)(pConfig)+1))

#define GET_NEXT_IGMP_STATIC_GROUP_V3(pConfig, pStaticGroupV3) \
    (((pConfig)->Version<IGMP_VERSION_3) \
    ?((PIGMP_STATIC_GROUP_V3) ((PCHAR)pStaticGroupV3+sizeof(IGMP_STATIC_GROUP))) \
    :((PIGMP_STATIC_GROUP_V3) ((PCHAR)pStaticGroupV3+sizeof(IGMP_STATIC_GROUP_V3) \
                            +sizeof(DWORD)*pStaticGroupV3->NumSources)) )

#define IGMP_MIB_STATIC_GROUP_SIZE(pConfig, pStaticGroup) \
    (((pConfig)->Version<IGMP_VERSION_3)?sizeof(IGMP_STATIC_GROUP)\
                    :sizeof(IGMP_STATIC_GROUP_V3)+sizeof(DWORD)*(pStaticGroup)->NumSources)

//
// Flags
//

#define IGMP_INTERFACE_ENABLED_IN_CONFIG    0x0001
#define IGMP_ACCEPT_RTRALERT_PACKETS_ONLY   0x0002

#define IGMP_ENABLED_FLAG_SET(Flags) \
                ((Flags) & IGMP_INTERFACE_ENABLED_IN_CONFIG)




//----------------------------------------------------------------------------
// struct:      IGMP_MIB_IF_STATS
//
// This MIB entry stores per-interface statistics for IGMP.
//
// If this is a ras client interface, then IpAddr is set to the NextHopAddress
//      of the RAS client.
//
// This structure is read-only.
//
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_IF_STATS {

    DWORD       IfIndex;                    // same as in MIB_IF_CONFIG
    DWORD       IpAddr;                     // same as in MIB_IF_CONFIG
    DWORD       IfType;                     // same as in MIB_IF_CONFIG

    BYTE        State;                      // bound/enabled
    BYTE        QuerierState;               // (not)querier
    DWORD       IgmpProtocolType;           // router/proxy, and ver(1/2/3)
    DWORD       QuerierIpAddr;
    DWORD       ProxyIfIndex;               // IfIndex of proxy(req by mib)
    
    DWORD       QuerierPresentTimeLeft;   
    DWORD       LastQuerierChangeTime;
    DWORD       V1QuerierPresentTimeLeft;   //obsolete

    DWORD       Uptime;                     // seconds it has been activated
    DWORD       TotalIgmpPacketsReceived; 
    DWORD       TotalIgmpPacketsForRouter;   
    DWORD       GeneralQueriesReceived;
    DWORD       WrongVersionQueries;
    DWORD       JoinsReceived;
    DWORD       LeavesReceived;
    DWORD       CurrentGroupMemberships;
    DWORD       GroupMembershipsAdded;
    DWORD       WrongChecksumPackets;
    DWORD       ShortPacketsReceived;
    DWORD       LongPacketsReceived;
    DWORD       PacketsWithoutRtrAlert; 
    
} IGMP_MIB_IF_STATS, *PIGMP_MIB_IF_STATS;




//----------------------------------------------------------------------------
// struct:        IGMP_MIB_IF_GROUPS_LIST
//
// This MIB entry stores the list of multicast groups which are members on 
//            that interface
//
// THIS STRUCTURE HAS VARIABLE LENGTH.
// The structure is followed by NumGroups number of IGMP_MIB_GROUP_INFO structs
//
// This structure is read-only
//
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_IF_GROUPS_LIST {

    DWORD       IfIndex;
    DWORD       IpAddr;
    DWORD       IfType;

    DWORD       NumGroups;

    BYTE        Buffer[1];
    
} IGMP_MIB_IF_GROUPS_LIST, *PIGMP_MIB_IF_GROUPS_LIST;






//----------------------------------------------------------------------------
// struct:        IGMP_MIB_GROUP_INFO
//    
// If the interface is of type RAS_SERVER then the group membership of all the 
// RAS clients is summarized, and the GroupUpTime and GroupExpiryTime is the 
// maximum over all member RAS Clients, while the V1HostPresentTimeLeft is set 
// to 0. If the interface is of type RAS_CLIENT, the IpAddr is the next hop Ip 
// address of the RAS Client. The membership is summarized over RAS clients 
// unless the IGMP_ENUM_FOR_RAS_CLIENTS_ID flag is set in Flags.
//
// Flag: IGMP_GROUP_FWD_TO_MGM implies that the group had been added to MGM
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_GROUP_INFO {

    union {
        DWORD        IfIndex;
        DWORD       GroupAddr;
    };
    DWORD       IpAddr;

    DWORD       GroupUpTime;
    DWORD       GroupExpiryTime;
    
    DWORD       LastReporter;
    DWORD       V1HostPresentTimeLeft;
    DWORD       Flags;
    
} IGMP_MIB_GROUP_INFO, *PIGMP_MIB_GROUP_INFO;

typedef struct _IGMP_MIB_GROUP_SOURCE_INFO_V3 {
    DWORD       Source;
    DWORD       SourceExpiryTime;   //not valid for exclusion mode
    DWORD       SourceUpTime;
    DWORD       Flags;
} IGMP_MIB_GROUP_SOURCE_INFO_V3, *PIGMP_MIB_GROUP_SOURCE_INFO_V3;

#define GET_FIRST_IGMP_MIB_GROUP_SOURCE_INFO_V3(pGroupInfoV3) \
    ((PIGMP_MIB_GROUP_SOURCE_INFO_V3)((PIGMP_MIB_GROUP_INFO_V3)(pGroupInfoV3)+1))


typedef struct _IGMP_MIB_GROUP_INFO_V3 {
    union {
        DWORD        IfIndex;
        DWORD       GroupAddr;
    };
    DWORD       IpAddr;

    DWORD       GroupUpTime;
    DWORD       GroupExpiryTime;
    
    DWORD       LastReporter;
    DWORD       V1HostPresentTimeLeft;
    DWORD       Flags;
    
    //v3 additions
    DWORD       Version; //1/2/3
    DWORD       Size;   //size of this struct
    DWORD       FilterType;//EXCLUSION/INCLUSION
    DWORD       V2HostPresentTimeLeft;
    DWORD       NumSources;
    //IGMP_MIB_GROUP_SOURCE_INFO_V3      Sources[0];
    
} IGMP_MIB_GROUP_INFO_V3, *PIGMP_MIB_GROUP_INFO_V3;

#define IGMP_GROUP_TYPE_NON_STATIC   0x0001
#define IGMP_GROUP_TYPE_STATIC       0x0002
#define IGMP_GROUP_FWD_TO_MGM        0x0004
#define IGMP_GROUP_ALLOW             0x0010
#define IGMP_GROUP_BLOCK             0x0020
#define IGMP_GROUP_NO_STATE          0x0040

//----------------------------------------------------------------------------
// struct:         IGMP_MIB_GROUP_IFS_LIST
//
// This MIB entry stores the list of interfaces which have received joins for 
//        that group.
//
// THIS STRUCTURE HAS VARIABLE LENGTH.
// The structure is followed by NumInterfaces number of structures of type 
//        IGMP_MIB_GROUP_INFO or IGMP_MIB_GROUP_INFO_V3
//
// This structure is read-only
//
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_GROUP_IFS_LIST {

    DWORD       GroupAddr;
    DWORD       NumInterfaces;
    BYTE        Buffer[1];

} IGMP_MIB_GROUP_IFS_LIST, *PIGMP_MIB_GROUP_IFS_LIST;




//----------------------------------------------------------------------------
// struct:      IGMP_MIB_IF_BINDING
//
// This MIB entry contains the table of IP addresses to which each interface
// is bound.
// All IP addresses are in network order.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
//  The base structure contains of the field AddrCount, which gives
//  the number of IP addresses to which the indexed interface is bound.
//  The IP addresses themselves follow the base structure, and are given
//  as IGMP_MIB_IP_ADDRESS structures. 

//  If IfType == IGMP_IF_RAS_SERVER, the IGMP_MIB_IF_BINDING is followed by
//    one IGMP_MIB_IP_ADDRESS struct containing the binding of the server 
//  interface and is followed by (AddrCount-1) next hop addresses of 
//  RAS clients which are of type DWORD.
//
// This MIB entry is read-only.
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_IF_BINDING {

    DWORD       IfIndex;

    DWORD       IfType;
    DWORD       State;
    DWORD       AddrCount;

} IGMP_MIB_IF_BINDING, *PIGMP_MIB_IF_BINDING;





//----------------------------------------------------------------------------
// struct:      IGMP_MIB_IP_ADDRESS
//
// This structure is used for storing interface bindings.
// A series of structures of this type follows the IGMP_MIB_IF_BINDING
// structure (described above) .
//
// Both fields are IP address fields in network-order.
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_IP_ADDRESS {

    DWORD       IpAddr;
    DWORD       SubnetMask;

} IGMP_MIB_IP_ADDRESS, *PIGMP_MIB_IP_ADDRESS;

typedef IGMP_MIB_IP_ADDRESS     IGMP_IP_ADDRESS;
typedef PIGMP_MIB_IP_ADDRESS    PIGMP_IP_ADDRESS;

#define IGMP_BINDING_FIRST_ADDR(bind)  ((PIGMP_IP_ADDRESS)((bind) + 1))




//---------------------------------------------------------------------------
//struct:       IGMP_IF_BINDING
// This structure is passed during BindInterface Call
//---------------------------------------------------------------------------
typedef struct _IGMP_IF_BINDING {

    DWORD       State;
    DWORD       AddrCount;

} IGMP_IF_BINDING, *PIGMP_IF_BINDING;




//----------------------------------------------------------------------------
// struct:      IGMP_MIB_SET_INPUT_DATA
//
// This is passed as input data for MibSet.
// Note that only global config and interface config can be set.
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_SET_INPUT_DATA {

    DWORD       TypeId;

    USHORT      Flags; //todo: change subtype to Flags
        
    DWORD       BufferSize;
    BYTE        Buffer[1];

} IGMP_MIB_SET_INPUT_DATA, *PIGMP_MIB_SET_INPUT_DATA;



//----------------------------------------------------------------------------
// struct:      IGMP_MIB_GET_INPUT_DATA
//
// This is passed as input data for MibGet, MibGetFirst, MibGetNext.
// All tables are readable.
// These and all other IP addresses must be in network order.
//
// Count: specifies the number of entries to return
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_GET_INPUT_DATA {

    DWORD       TypeId;
    USHORT      Flags;//set IGMP_ENUM_FORMAT_IGMPV3 if you support v3
    USHORT      Signature;
    
    DWORD       IfIndex;
    DWORD       RasClientAddr;
    DWORD       GroupAddr;
    
    DWORD       Count;
    
} IGMP_MIB_GET_INPUT_DATA, *PIGMP_MIB_GET_INPUT_DATA;





//----------------------------------------------------------------------------
// struct:      IGMP_MIB_GET_OUTPUT_DATA
//
// This is written into the output data by MibGet, MibGetFirst, MibGetNext.
// Note that at the end of a table MibGetNext wraps to the next table,
// and therefore the value TypeID should be examined to see the
// type of the data returned in the output buffer.
//----------------------------------------------------------------------------

typedef struct _IGMP_MIB_GET_OUTPUT_DATA {

    DWORD       TypeId;
    DWORD       Flags; //IGMP_ENUM_FORMAT_IGMPV3 set if v3 struct
    
    DWORD       Count;
    BYTE        Buffer[1];

} IGMP_MIB_GET_OUTPUT_DATA, *PIGMP_MIB_GET_OUTPUT_DATA;


#endif // _IGMPRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\ipriprm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: ipriprm.h
//
// History:
//      Abolade Gbadegesin  Aug-7-1995  Created.
//
// Contains type definitions and declarations for IP RIP,
// used by the IP Router Manager.
//============================================================================

#ifndef _IPRIPRM_H_
#define _IPRIPRM_H_



//----------------------------------------------------------------------------
// CONSTANT AND MACRO DECLARATIONS
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// constants identifying IPRIP's MIB tables
//----------------------------------------------------------------------------

#define IPRIP_GLOBAL_STATS_ID       0
#define IPRIP_GLOBAL_CONFIG_ID      1
#define IPRIP_IF_STATS_ID           2
#define IPRIP_IF_CONFIG_ID          3
#define IPRIP_IF_BINDING_ID         4
#define IPRIP_PEER_STATS_ID         5




//----------------------------------------------------------------------------
// constants used for the field IPRIP_GLOBAL_CONFIG::GC_LoggingLevel
//----------------------------------------------------------------------------

#define IPRIP_LOGGING_NONE      0
#define IPRIP_LOGGING_ERROR     1
#define IPRIP_LOGGING_WARN      2
#define IPRIP_LOGGING_INFO      3




//----------------------------------------------------------------------------
// constants used for the following fields:
// IPRIP_GLOBAL_CONFIG::GC_PeerFilterMode,
// IPRIP_IF_CONFIG::IC_AcceptFilterMode, and
// IPRIP_IF_CONFIG::IC_AnnounceFilterMode
//----------------------------------------------------------------------------

#define IPRIP_FILTER_DISABLED               0
#define IPRIP_FILTER_INCLUDE                1
#define IPRIP_FILTER_EXCLUDE                2




//----------------------------------------------------------------------------
// constants used for the fields
// IPRIP_IF_STATS::IS_State, IPRIP_IF_CONFIG::IC_State and
// IPRIP_IF_BINDING::IB_State
//----------------------------------------------------------------------------

#define IPRIP_STATE_ENABLED         0x00000001
#define IPRIP_STATE_BOUND           0x00000002



//----------------------------------------------------------------------------
// constant for the field IPRIP_IF_CONFIG::IC_AuthenticationKey;
//  defines maximum authentication key size
//----------------------------------------------------------------------------

#define IPRIP_MAX_AUTHKEY_SIZE              16




//----------------------------------------------------------------------------
// constants used to construct the field IPRIP_IF_CONFIG::IC_ProtocolFlags
//----------------------------------------------------------------------------

#define IPRIP_FLAG_ACCEPT_HOST_ROUTES           0x00000001
#define IPRIP_FLAG_ANNOUNCE_HOST_ROUTES         0x00000002
#define IPRIP_FLAG_ACCEPT_DEFAULT_ROUTES        0x00000004
#define IPRIP_FLAG_ANNOUNCE_DEFAULT_ROUTES      0x00000008
#define IPRIP_FLAG_SPLIT_HORIZON                0x00000010
#define IPRIP_FLAG_POISON_REVERSE               0x00000020
#define IPRIP_FLAG_GRACEFUL_SHUTDOWN            0x00000040
#define IPRIP_FLAG_TRIGGERED_UPDATES            0x00000080
#define IPRIP_FLAG_OVERWRITE_STATIC_ROUTES      0x00000100
#define IPRIP_FLAG_NO_SUBNET_SUMMARY            0x00000200



//----------------------------------------------------------------------------
// constants for the field IPRIP_IF_CONFIG::IC_UpdateMode
//----------------------------------------------------------------------------

#define IPRIP_UPDATE_PERIODIC               0
#define IPRIP_UPDATE_DEMAND                 1


//----------------------------------------------------------------------------
// constants for the field IPRIP_IF_CONFIG::IC_AcceptMode
//----------------------------------------------------------------------------

#define IPRIP_ACCEPT_DISABLED               0
#define IPRIP_ACCEPT_RIP1                   1
#define IPRIP_ACCEPT_RIP1_COMPAT            2
#define IPRIP_ACCEPT_RIP2                   3


//----------------------------------------------------------------------------
// constants for the field IPRIP_IF_CONFIG::IC_AnnounceMode
//----------------------------------------------------------------------------

#define IPRIP_ANNOUNCE_DISABLED             0
#define IPRIP_ANNOUNCE_RIP1                 1
#define IPRIP_ANNOUNCE_RIP1_COMPAT          2
#define IPRIP_ANNOUNCE_RIP2                 3


//----------------------------------------------------------------------------
// constants for the field IPRIP_IF_CONFIG::IC_AuthenticationType
//----------------------------------------------------------------------------

#define IPRIP_AUTHTYPE_NONE                 1
#define IPRIP_AUTHTYPE_SIMPLE_PASSWORD      2
#define IPRIP_AUTHTYPE_MD5                  3


//----------------------------------------------------------------------------
// constants for the field IPRIP_IF_CONFIG::IC_UnicastPeerMode
//----------------------------------------------------------------------------

#define IPRIP_PEER_DISABLED                 0
#define IPRIP_PEER_ALSO                     1
#define IPRIP_PEER_ONLY                     2



//----------------------------------------------------------------------------
// macros for manipulating the variable length IPRIP_GLOBAL_CONFIG structure
//
// IPRIP_GLOBAL_CONFIG_SIZE computes the size of a global config struct
//
// IPRIP_GLOBAL_PEER_FILTER_TABLE computes the starting address
//      of the series of peer IP addresses which comprise
//      the peer filter table in a global config struct
//
// e.g.
//      PIPRIP_GLOBAL_CONFIG pigcSource, pigcDest;
//
//      pigcDest = malloc(IPRIP_GLOBAL_CONFIG_SIZE(pigcSource));
//      memcpy(pigcDest, pigcSource, IPRIP_GLOBAL_CONFIG_SIZE(pigcSource));
//
// e.g.
//      DWORD i, *pdwPeer;
//      PIPRIP_GLOBAL_CONFIG pigc;
//      
//      pdwPeer = IPRIP_GLOBAL_PEER_FILTER_TABLE(pigc);
//      for (i = 0; i < pigc->GC_PeerFilterCount; i++, pdwPeer++) {
//          printf("%s\n", inet_ntoa(*(struct in_addr *)pdwPeer));
//      }
//----------------------------------------------------------------------------

#define IPRIP_GLOBAL_CONFIG_SIZE(cfg)   \
        (sizeof(IPRIP_GLOBAL_CONFIG) +  \
         (cfg)->GC_PeerFilterCount * sizeof(DWORD))

#define IPRIP_GLOBAL_PEER_FILTER_TABLE(cfg)  ((PDWORD)((cfg) + 1))



//----------------------------------------------------------------------------
// macros used for manipulating the field IPRIP_IF_CONFIG::IC_ProtocolFlags;
//
// IPRIP_FLAG_ENABLE enables a flag in a config structure
//
// IPRIP_FLAG_DISABLE disables a flag in a config structure
//
// IPRIP_FLAG_IS_ENABLED evaluates to non-zero if a given flag is enabled
//      in a config structure
//
// IPRIP_FLAG_IS_DISABLED evaluates to non-zero if a given flag is disabled
//      in a config structure
//
// e.g.
//      IPRIP_IF_CONFIG iic;
//      IPRIP_FLAG_ENABLE(&iic, ACCEPT_HOST_ROUTES);
//
// e.g.
//      IPRIP_IF_CONFIG iic;
//      printf((IPRIP_FLAG_IS_ENABLED(&iic, SPLIT_HORIZON) ? "split" : ""));
//----------------------------------------------------------------------------

#define IPRIP_FLAG_ENABLE(iic, flag) \
        ((iic)->IC_ProtocolFlags |= IPRIP_FLAG_ ## flag)
#define IPRIP_FLAG_DISABLE(iic, flag) \
        ((iic)->IC_ProtocolFlags &= ~ (IPRIP_FLAG_ ## flag))
#define IPRIP_FLAG_IS_ENABLED(iic, flag) \
        ((iic)->IC_ProtocolFlags & IPRIP_FLAG_ ## flag)
#define IPRIP_FLAG_IS_DISABLED(iic, flag) \
        !IPRIP_FLAG_IS_ENABLED(iic, flag)
        



//----------------------------------------------------------------------------
// macros for manipulating the variable-length IPRIP_IF_CONFIG structure
//
// IPRIP_IF_CONFIG_SIZE computes the size of a config structure.
//
// IPRIP_IF_UNICAST_PEER_TABLE computes the starting address
//      in a config struct of the series of IP addresses for peers
//      to whom routes are to be sent by unicast.
//
// IPRIP_IF_CONFIG_ACCEPT_FILTER_TABLE computes the starting address
//      of the series of route-acceptance filters in a config structure.
//
// IPRIP_IF_CONFIG_ANNOUNCE_FILTER_TABLE computes the starting address
//      of the series of route-announcement filters in a config structure.
//
// e.g.
//      PIPRIP_IF_CONFIG piicSource, piicDest;
//
//      piicDest = malloc(IPRIP_IF_CONFIG_SIZE(piicSource));
//      memcpy(piicDest, piicSource, IPRIP_IF_CONFIG_SIZE(piicSource));
//
// e.g.
//      DWORD i, *pdwPeer;
//      PIPRIP_IF_CONFIG piic;
//
//      pdwPeer = IPRIP_IF_UNICAST_PEER_TABLE(piic);
//      for (i = 0; i < piic->IC_UnicastPeerCount; i++) {
//          printf("%s\n", inet_ntoa(*(struct in_addr *)pdwPeer));
//      }
//----------------------------------------------------------------------------

#define IPRIP_IF_CONFIG_SIZE(cfg) \
        (sizeof(IPRIP_IF_CONFIG) + \
         (cfg)->IC_UnicastPeerCount * sizeof(DWORD) + \
         (cfg)->IC_AcceptFilterCount * sizeof(IPRIP_ROUTE_FILTER) + \
         (cfg)->IC_AnnounceFilterCount * sizeof(IPRIP_ROUTE_FILTER))

#define IPRIP_IF_UNICAST_PEER_TABLE(cfg) ((PDWORD)((cfg) + 1))

#define IPRIP_IF_ACCEPT_FILTER_TABLE(cfg)   \
        ((PIPRIP_ROUTE_FILTER)( \
            IPRIP_IF_UNICAST_PEER_TABLE(cfg) + (cfg)->IC_UnicastPeerCount ))
            
#define IPRIP_IF_ANNOUNCE_FILTER_TABLE(cfg) \
        ((PIPRIP_ROUTE_FILTER)( \
            IPRIP_IF_ACCEPT_FILTER_TABLE(cfg) + (cfg)->IC_AcceptFilterCount ))



//----------------------------------------------------------------------------
// macros for manipulating the variable-length IPRIP_IF_BINDING structure
//
// IPRIP_IF_BINDING_SIZE computes the size of a binding structure.
//
// IPRIP_IF_ADDRESS_TABLE computes the starting address in a binding struct
//      of the series of IPRIP_IP_ADDRESS structures which are the bindings
//      for the interface in question.
//
// e.g.
//      PIPRIP_IF_BINDING piibSource, piibDest;
//
//      piibDest = malloc(IPRIP_IF_BINDING_SIZE(piicSource));
//      memcpy(piibDest, piicSource, IPRIP_IF_BINDING_SIZE(piicSource));
//
// e.g.
//      DWORD i;
//      PIPRIP_IF_BINDING piib;
//      PIPRIP_IP_ADDRESS *pdwAddr;
//
//      pdwAddr = IPRIP_IF_ADDRESS_TABLE(piib);
//      for (i = 0; i < piib->IB_AddrCount; i++) {
//          printf("%s-", inet_ntoa(*(struct in_addr *)&pdwAddr->IA_Address));
//          printf("%s\n", inet_ntoa(*(struct in_addr *)&pdwAddr->IA_Netmask));
//      }
//----------------------------------------------------------------------------

#define IPRIP_IF_BINDING_SIZE(bind) \
        (sizeof(IPRIP_IF_BINDING) + \
         (bind)->IB_AddrCount * sizeof(IPRIP_IP_ADDRESS))

#define IPRIP_IF_ADDRESS_TABLE(bind)  ((PIPRIP_IP_ADDRESS)((bind) + 1))






//----------------------------------------------------------------------------
// STRUCTURE DEFINITIONS
//----------------------------------------------------------------------------




//----------------------------------------------------------------------------
// struct:      IPRIP_GLOBAL_STATS
//
// This MIB entry stores global statistics for IPRIP;
// There is only one instance, so this entry has no index.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPRIP_GLOBAL_STATS {

    DWORD       GS_SystemRouteChanges;
    DWORD       GS_TotalResponsesSent;

} IPRIP_GLOBAL_STATS, *PIPRIP_GLOBAL_STATS;




//----------------------------------------------------------------------------
// struct:      IPRIP_GLOBAL_CONFIG
//
// This MIB entry stores global configuration for IPRIP
// There is only one instance, so this entry has no index.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
// after the base structure comes an array of GC_PeerFilterCount DWORDs,
// each of which contains an IP address which is a peer which will be
// accepted or rejected depending on the value of GC_PeerFilterMode.
//
// Thus, if GC_PeerFilterMode is IPRIP_FILTER_EXCLUDE, routes will be
// rejected which come from the routers whose addresses are in the peer array,
// and all other routers will be accepted.
//
// Likewise, if GC_PeerFilterMode is IPRIP_FILTER_INCLUDE, routes will
// be only be accepted if they are from the routers in the peer array.
//----------------------------------------------------------------------------

typedef struct _IPRIP_GLOBAL_CONFIG {

    DWORD       GC_LoggingLevel;
    DWORD       GC_MaxRecvQueueSize;
    DWORD       GC_MaxSendQueueSize;
    DWORD       GC_MinTriggeredUpdateInterval;
    DWORD       GC_PeerFilterMode;
    DWORD       GC_PeerFilterCount;

} IPRIP_GLOBAL_CONFIG, *PIPRIP_GLOBAL_CONFIG;




//----------------------------------------------------------------------------
// struct:      IPRIP_IF_STATS
//
// This MIB entry stores per-interface statistics for IPRIP.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPRIP_IF_STATS {

    DWORD       IS_State;
    DWORD       IS_SendFailures;
    DWORD       IS_ReceiveFailures;
    DWORD       IS_RequestsSent;
    DWORD       IS_RequestsReceived;
    DWORD       IS_ResponsesSent;
    DWORD       IS_ResponsesReceived;
    DWORD       IS_BadResponsePacketsReceived;
    DWORD       IS_BadResponseEntriesReceived;
    DWORD       IS_TriggeredUpdatesSent;

} IPRIP_IF_STATS, *PIPRIP_IF_STATS;





//----------------------------------------------------------------------------
// struct:      IPRIP_IF_CONFIG
//
// This MIB entry describes per-interface configuration.
// All IP address fields must be in network order.
//
// Note:
//      The field IC_State is read-only.
//      The field IC_AuthenticationKey is write-only.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
// after the base structure comes
//
//  1. the table of unicast peers configured for this interface,
//      with each entry being a DWORD containing an IP address, where a
//      unicast peer is a router to which updates will be unicast;
//      if IC_UnicastPeerMode is IPRIP_PEER_ONLY, RIP packets will only
//      be sent to these peers; if IC_UnicastPeerMode is IPRIP_PEER_ALSO,
//      RIP packets will be sent to these peers as well as being sent
//      via broadcast/multicast.
//
//  2. the table of filters used to filter routes before accepting them,
//      with each entry being of type IPRIP_ROUTE_FILTER.
//      The use of these depends on the rule in IC_AcceptFilterMode. Thus
//      if IC_AcceptFilterMode is IPRIP_FILTER_INCLUDE, these filters specify
//      which routes to include, and all other routes are excluded.
//
//  3. the table of filters used to filter routes before announcing them,
//      with each entry being of type IPRIP_ROUTE_FILTER;
//      The use of these depend on the rule in IC_AnnounceFilterMode. Thus
//      if IC_AnnounceFilterMode is IPRIP_FILTER_INCLUDE, these filters
//      specify which routes to include, and all other routes are excluded.
//
// IC_UnicastPeerCount, IC_AcceptFilterCount, and IC_AnnounceFilterCount 
// give the counts of entries in each of the above tables.
//
// If the interface type is PERMANENT, then routing information will
// be broadcast AND sent by unicast to the routers in the unicast peer table.
// Otherwise, routing information will only be unicast to the routers in the
// unicast peer table.
//----------------------------------------------------------------------------

typedef struct _IPRIP_IF_CONFIG {

    DWORD       IC_State;
    DWORD       IC_Metric;
    DWORD       IC_UpdateMode;
    DWORD       IC_AcceptMode;
    DWORD       IC_AnnounceMode;
    DWORD       IC_ProtocolFlags;
    DWORD       IC_RouteExpirationInterval;
    DWORD       IC_RouteRemovalInterval;
    DWORD       IC_FullUpdateInterval;
    DWORD       IC_AuthenticationType;
    BYTE        IC_AuthenticationKey[IPRIP_MAX_AUTHKEY_SIZE];
    WORD        IC_RouteTag;
    DWORD       IC_UnicastPeerMode;
    DWORD       IC_AcceptFilterMode;
    DWORD       IC_AnnounceFilterMode;
    DWORD       IC_UnicastPeerCount;
    DWORD       IC_AcceptFilterCount;
    DWORD       IC_AnnounceFilterCount;

} IPRIP_IF_CONFIG, *PIPRIP_IF_CONFIG;




//----------------------------------------------------------------------------
// struct:      IPRIP_ROUTE_FILTER
//
// This is used for per-interface filters in the structure IPRIP_IF_CONFIG
//
// Each filter describes an instance of the default filter action;
// if the default accept filter action  is IPRIP_FILTER_INCLUDE,
// then each of the accept filters in the filter table will be treated
// as an inclusion range. If an interface's default announce filter action is
// IPRIP_FILTER_EXCLUDE, then each of that interface's announce filters
// will be treated as an exclusion range.
//
// Both the low and high IP addresses must be in network order.
//----------------------------------------------------------------------------

typedef struct _IPRIP_ROUTE_FILTER {

    DWORD       RF_LoAddress;
    DWORD       RF_HiAddress;

} IPRIP_ROUTE_FILTER, *PIPRIP_ROUTE_FILTER;




//----------------------------------------------------------------------------
// struct:      IPRIP_IF_BINDING
//
// This MIB entry contains the table of IP addresses to which each interface
// is bound.
// All IP addresses are in network order.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
//  The base structure contains of the field IB_AddrCount, which gives
//  the number of IP addresses to which the indexed interface is bound.
//  The IP addresses themselves follow the base structure, and are given
//  as IPRIP_IP_ADDRESS structures.
//
// This MIB entry is read-only.
//----------------------------------------------------------------------------

typedef struct _IPRIP_IF_BINDING {

    DWORD       IB_State;
    DWORD       IB_AddrCount;

} IPRIP_IF_BINDING, *PIPRIP_IF_BINDING;




//----------------------------------------------------------------------------
// struct:      IPRIP_IP_ADDRESS
//
// This structure is used for storing interface bindings.
// A series of structures of this type follows the IPRIP_IF_BINDING
// structure (described above).
//
// Both fields are IP address fields in network-order.
//----------------------------------------------------------------------------

typedef struct _IPRIP_IP_ADDRESS {

    DWORD       IA_Address;
    DWORD       IA_Netmask;

} IPRIP_IP_ADDRESS, *PIPRIP_IP_ADDRESS;





//----------------------------------------------------------------------------
// struct:      IPRIP_PEER_STATS
//
// This MIB entry describes statistics kept about neighboring routers.
// All IP addresses are in network order.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPRIP_PEER_STATS {

    DWORD       PS_LastPeerRouteTag;
    DWORD       PS_LastPeerUpdateTickCount;
    DWORD       PS_LastPeerUpdateVersion;
    DWORD       PS_BadResponsePacketsFromPeer;
    DWORD       PS_BadResponseEntriesFromPeer;

} IPRIP_PEER_STATS, *PIPRIP_PEER_STATS;




//----------------------------------------------------------------------------
// struct:      IPRIP_MIB_SET_INPUT_DATA
//
// This is passed as input data for MibSet.
// Note that only global config and interface config can be set.
//----------------------------------------------------------------------------

typedef struct _IPRIP_MIB_SET_INPUT_DATA {

    DWORD       IMSID_TypeID;
    DWORD       IMSID_IfIndex;
    DWORD       IMSID_BufferSize;
    BYTE        IMSID_Buffer[1];

} IPRIP_MIB_SET_INPUT_DATA, *PIPRIP_MIB_SET_INPUT_DATA;




//----------------------------------------------------------------------------
// struct:      IPRIP_MIB_GET_INPUT_DATA
//
// This is passed as input data for MibGet, MibGetFirst, MibGetNext.
// All tables are readable.
// These and all other IP addresses must be in network order.
//----------------------------------------------------------------------------

typedef struct _IPRIP_MIB_GET_INPUT_DATA {

    DWORD       IMGID_TypeID;
    union {
        DWORD   IMGID_IfIndex;
        DWORD   IMGID_PeerAddress;
    };

} IPRIP_MIB_GET_INPUT_DATA, *PIPRIP_MIB_GET_INPUT_DATA;




//----------------------------------------------------------------------------
// struct:      IPRIP_MIB_GET_OUTPUT_DATA
//
// This is written into the output data by MibGet, MibGetFirst, MibGetNext.
// Note that at the end of a table MibGetNext wraps to the next table,
// and therefore the value IMGOD_TypeID should be examined to see the
// type of the data returned in the output buffer.
//----------------------------------------------------------------------------

typedef struct _IPRIP_MIB_GET_OUTPUT_DATA {

    DWORD       IMGOD_TypeID;
    union {
        DWORD   IMGOD_IfIndex;
        DWORD   IMGOD_PeerAddress;
    };
    BYTE        IMGOD_Buffer[1];

} IPRIP_MIB_GET_OUTPUT_DATA, *PIPRIP_MIB_GET_OUTPUT_DATA;


#endif // _IPRIPRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\iprtprio.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\inc\iprtprio.h


Abstract:

    Header defining interface to Routing Protocol Priority DLL.

Revision History:

    Gurdeep Singh Pall		7/19/95	Created

--*/


//
// Returns the priority for the route
//

DWORD 
ComputeRouteMetric(
    IN  DWORD   dwProtoId
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\msdprm.h ===
/*++
Copyright (c) 1998, Microsoft Corporation

Module:
  msdp\msdprm.h

Abstract:
  Contains type definitions and declarations for MSDP,
  used by the IP Router Manager.

Revistion History:
  Dave Thaler   May-21-1999 Created.
--*/

#ifndef _MSDPRM_H_
#define _MSDPRM_H_

//---------------------------------------------------------------------------
// CONSTANT DECLARATIONS
//---------------------------------------------------------------------------

#define MSDP_CONFIG_VERSION_500    500

//---------------------------------------------------------------------------
// constants identifying MSDP's MIB tables
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// constants used for the field MSDP_GLOBAL_CONFIG::LoggingLevel
//---------------------------------------------------------------------------

#define MSDP_LOGGING_NONE      0
#define MSDP_LOGGING_ERROR     1
#define MSDP_LOGGING_WARN      2
#define MSDP_LOGGING_INFO      3


//---------------------------------------------------------------------------
// STRUCTURE DEFINITIONS
//---------------------------------------------------------------------------

  



//---------------------------------------------------------------------------
// struct:      MSDP_IPV4_PEER_CONFIG
//
// This MIB entry describes per-peer configuration.
// All IP address fields must be in network order.
//---------------------------------------------------------------------------

#define MSDP_PEER_CONFIG_KEEPALIVE     0x01
// unused                              0x02
#define MSDP_PEER_CONFIG_CONNECTRETRY  0x04
#define MSDP_PEER_CONFIG_CACHING       0x08
#define MSDP_PEER_CONFIG_DEFAULTPEER   0x10
#define MSDP_PEER_CONFIG_PASSIVE       0x20 // derived flag

#define MSDP_ENCAPS_NONE 0
#define MSDP_ENCAPS_TCP  1
#define MSDP_ENCAPS_UDP  2
#define MSDP_ENCAPS_GRE  3

#define MSDP_ENCAPS_DEFAULT MSDP_ENCAPS_NONE

typedef struct _MSDP_IPV4_PEER_CONFIG {
    IPV4_ADDRESS ipRemoteAddress;
    IPV4_ADDRESS ipLocalAddress;

    // Or'ing of the flags listed above
    DWORD        dwConfigFlags;

    ULONG        ulKeepAlive;
    ULONG        ulConnectRetry;

    DWORD        dwEncapsMethod;
} MSDP_IPV4_PEER_CONFIG, *PMSDP_IPV4_PEER_CONFIG;

#define MSDP_STATE_IDLE          0
#define MSDP_STATE_CONNECT       1
#define MSDP_STATE_ACTIVE        2
#define MSDP_STATE_OPENSENT      3
#define MSDP_STATE_OPENCONFIRM   4
#define MSDP_STATE_ESTABLISHED   5

typedef struct _MSDP_IPV4_PEER_ENTRY {
    MSDP_IPV4_PEER_CONFIG;

    DWORD        dwState;
    ULONG        ulRPFFailures;
    ULONG        ulInSAs;
    ULONG        ulOutSAs;
    ULONG        ulInSARequests;
    ULONG        ulOutSARequests;
    ULONG        ulInSAResponses;
    ULONG        ulOutSAResponses;
    ULONG        ulInControlMessages;
    ULONG        ulOutControlMessages;
    ULONG        ulInDataPackets;
    ULONG        ulOutDataPackets;
    ULONG        ulFsmEstablishedTransitions;
    ULONG        ulFsmEstablishedTime;
    ULONG        ulInMessageElapsedTime;
} MSDP_IPV4_PEER_ENTRY, *PMSDP_IPV4_PEER_ENTRY;

//----------------------------------------------------------------------------
// struct:      MSDP_GLOBAL_CONFIG
//
// This MIB entry stores global configuration for MSDP
// There is only one instance, so this entry has no index.
//
//---------------------------------------------------------------------------

#define MSDP_GLOBAL_FLAG_ACCEPT_ALL 0x01

#define MSDP_MIN_CACHE_LIFETIME 90

typedef struct _MSDP_GLOBAL_CONFIG {
    // Fields duplicated in the CONFIGURATION_ENTRY struct
    DWORD              dwLoggingLevel;    // pce->dwLogLevel
    DWORD              dwFlags;
    ULONG              ulDefKeepAlive;
    ULONG              ulDefConnectRetry; // pTpi->usDefaultConnectRetryInterval

    // Protocol-specific fields
    ULONG              ulCacheLifetime;
    ULONG              ulSAHolddown;
} MSDP_GLOBAL_CONFIG, *PMSDP_GLOBAL_CONFIG;

typedef struct _MSDP_GLOBAL_ENTRY {
    MSDP_GLOBAL_CONFIG;
   
    DWORD              dwEnabled;           // XXX not yet implemented
    ULONG              ulNumSACacheEntries;
    HANDLE             hSAAdvTimer;
    DWORD              dwRouterId;
} MSDP_GLOBAL_ENTRY, *PMSDP_GLOBAL_ENTRY;

typedef struct _MSDP_REQUESTS_ENTRY {
    IPV4_ADDRESS       ipGroup;
    IPV4_ADDRESS       ipMask;
    IPV4_ADDRESS       ipPeer;
} MSDP_REQUESTS_ENTRY, *PMSDP_REQUESTS_ENTRY;

typedef struct _MSDP_REQUESTS_TABLE
{
    DWORD               dwNumEntries;
    MSDP_REQUESTS_ENTRY table[ANY_SIZE];
}MSDP_REQUESTS_TABLE, *PMSDP_REQUESTS_TABLE;

typedef struct _MSDP_SA_CACHE_ENTRY {
    IPV4_ADDRESS       ipGroupAddr;
    IPV4_ADDRESS       ipSourceAddr;
    IPV4_ADDRESS       ipOriginRP;
    IPV4_ADDRESS       ipPeerLearnedFrom;
    IPV4_ADDRESS       ipRPFPeer;
    ULONG              ulInSAs;
    ULONG              ulInDataPackets;
    ULONG              ulUpTime;
    ULONG              ulExpiryTime;
} MSDP_SA_CACHE_ENTRY, *PMSDP_SA_CACHE_ENTRY;

typedef struct _MSDP_SA_CACHE_TABLE
{
    DWORD               dwNumEntries;
    MSDP_SA_CACHE_ENTRY table[ANY_SIZE];
}MSDP_SA_CACHE_TABLE, *PMSDP_SA_CACHE_TABLE;

//---------------------------------------------------------------------------
// MACRO DECLARATIONS
//---------------------------------------------------------------------------

//----------------------------------------
// constants identifying MSDP's MIB tables
#define MIBID_MSDP_GLOBAL          0
#define MIBID_MSDP_REQUESTS_ENTRY  1
#define MIBID_MSDP_IPV4_PEER_ENTRY 2
#define MIBID_MSDP_SA_CACHE_ENTRY  3

#endif // _MSDPRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\ospf_cfg.h ===
#ifndef __OSPFCFG_H__
#define __OSPFCFG_H__

// ospf_cfg.h


// structure types

#define	OSPF_END_PARAM_TYPE		            0
#define	OSPF_GLOBAL_PARAM_TYPE		        1
#define	OSPF_AREA_PARAM_TYPE		        2
#define	OSPF_AREA_RANGE_PARAM_TYPE	        3
#define	OSPF_INTF_PARAM_TYPE		        4
#define	OSPF_NEIGHBOR_PARAM_TYPE	        5
#define	OSPF_VIRT_INTF_PARAM_TYPE	        6
#define OSPF_ROUTE_FILTER_PARAM_TYPE        7
#define OSPF_PROTOCOL_FILTER_PARAM_TYPE     8

#define OSPF_LOGGING_NONE  ((DWORD) 0)
#define OSPF_LOGGING_ERROR ((DWORD) 1)
#define OSPF_LOGGING_WARN  ((DWORD) 2)
#define OSPF_LOGGING_INFO  ((DWORD) 3)

#define OSPF_LOGGING_MAX_VALUE  OSPF_LOGGING_INFO
#define OSPF_LOGGING_MIN_VALUE  OSPF_LOGGING_NONE
#define OSPF_LOGGING_DEFAULT    OSPF_LOGGING_WARN

// Global Parameters
typedef struct _OSPF_GLOBAL_PARAM
{
    DWORD	type;			// OSPF_GLOBAL_PARAM_TYPE
    DWORD	create;			// 1 = created, 2 = deleted
    DWORD	enable;			// 1 = enable, 2 = disable
    DWORD  	routerId;
    DWORD	ASBrdrRtr;		// 1 = yes, 2 = no
    DWORD   logLevel;       // One of the above
}OSPF_GLOBAL_PARAM, *POSPF_GLOBAL_PARAM;


// Area Parameters

typedef struct _OSPF_AREA_PARAM
{
    DWORD	type;			// OSPF_AREA_PARAM_TYPE
    DWORD	create;			// 1 = created, 2 = deleted
    DWORD	enable;			// 1 = enable, 2 = disable
    DWORD  	areaId;
    DWORD	authType;		// 1 = none, 2 = simple password
    DWORD	importASExtern;		// 1 = yes, 2 = no
    DWORD	stubMetric;
    DWORD	importSumAdv;		// 1 = yes, 2 = no
}OSPF_AREA_PARAM, *POSPF_AREA_PARAM;


// Area Range Parameters

typedef struct _OSPF_AREA_RANGE_PARAM
{
    DWORD	type;			// OSPF_AREA_RANGE_PARAM_TYPE
    DWORD	create;			// 1 = created, 2 = deleted
    DWORD	enable;			// 1 = enable, 2 = disable
    DWORD  	areaId;
    DWORD  	rangeNet;
    DWORD  	rangeMask;
}OSPF_AREA_RANGE_PARAM, *POSPF_AREA_RANGE_PARAM;

// Interface Parameters

typedef struct _OSPF_INTERFACE_PARAM
{
    DWORD	type;			// OSPF_INTF_PARAM_TYPE
    DWORD	create;			// 1 = created, 2 = deleted
    DWORD	enable;			// 1 = enable, 2 = disable
    DWORD  	intfIpAddr;
    DWORD  	intfSubnetMask;
    DWORD  	areaId;
    DWORD	intfType;		// 1 = broadcast, 2 = NBMA, 
					        // 3 = point-to-point
    DWORD	routerPriority;	
    DWORD	transitDelay;
    DWORD	retransInterval;
    DWORD	helloInterval;
    DWORD	deadInterval;
    DWORD	pollInterval;
    DWORD	metricCost;
    BYTE	password[8];
    DWORD	mtuSize;
}OSPF_INTERFACE_PARAM, *POSPF_INTERFACE_PARAM;


// NBMA Neighbor Parameters

typedef struct _OSPF_NBMA_NEIGHBOR_PARAM
{
    DWORD	type;			// OSPF_NEIGHBOR_PARAM_TYPE
    DWORD	create;			// 1 = created, 2 = deleted
    DWORD	enable;			// 1 = enable, 2 = disable
    DWORD  	neighborIpAddr;
    DWORD  	intfIpAddr;
    DWORD	neighborPriority;
}OSPF_NBMA_NEIGHBOR_PARAM, *POSPF_NBMA_NEIGHBOR_PARAM;


// Virtual Interface Parameters

typedef struct _OSPF_VIRT_INTERFACE_PARAM
{
    DWORD	type;			// OSPF_VIRT_INTF_PARAM_TYPE
    DWORD	create;			// 1 = created, 2 = deleted
    DWORD	enable;			// 1 = enable, 2 = disable
    DWORD  	transitAreaId;
    DWORD  	virtNeighborRouterId;
    DWORD	transitDelay;
    DWORD	retransInterval;
    DWORD	helloInterval;
    DWORD	deadInterval;
    BYTE	password[8];
}OSPF_VIRT_INTERFACE_PARAM, *POSPF_VIRT_INTERFACE_PARAM;

typedef struct _OSPF_ROUTE_FILTER
{
    DWORD   dwAddress;
    DWORD   dwMask;
}OSPF_ROUTE_FILTER, *POSPF_ROUTE_FILTER;

typedef enum _OSPF_FILTER_ACTION
{
    ACTION_DROP = 0,
    ACTION_ACCEPT = 1
}OSPF_FILTER_ACTION, *POSPF_FILTER_ACTION;

typedef struct _OSPF_ROUTE_FILTER_INFO
{
    DWORD               type;
    OSPF_FILTER_ACTION  ofaActionOnMatch;
    DWORD               dwNumFilters;
    OSPF_ROUTE_FILTER   pFilters[1];
}OSPF_ROUTE_FILTER_INFO, *POSPF_ROUTE_FILTER_INFO;

#define SIZEOF_OSPF_ROUTE_FILTERS(X)    \
    (FIELD_OFFSET(OSPF_ROUTE_FILTER_INFO, pFilters[0]) + ((X) * sizeof(OSPF_ROUTE_FILTER)))

typedef struct _OSPF_PROTO_FILTER_INFO
{
    DWORD               type;
    OSPF_FILTER_ACTION  ofaActionOnMatch;
    DWORD               dwNumFilters;
    DWORD               pdwProtoId[1];
}OSPF_PROTO_FILTER_INFO, *POSPF_PROTO_FILTER_INFO;

#define SIZEOF_OSPF_PROTO_FILTERS(X)    \
    (FIELD_OFFSET(OSPF_PROTO_FILTER_INFO, pdwProtoId[0]) + ((X) * sizeof(DWORD)))


#endif //__OSPFCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\mprlog.h ===
/********************************************************************/
/**            Copyright(c) 1992 Microsoft Corporation.            **/
/********************************************************************/

//***
//
// Filename:    mprlog.h
//
// Description:
//
// History:     August 26,1995.  NarenG Created original version.
//
//***

//
// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define ROUTER_LOG_BASE                                 20000

#define ROUTERLOG_CANT_LOAD_NBGATEWAY                   (ROUTER_LOG_BASE+1)
/*
 * Cannot load the NetBIOS gateway DLL component because of the following error: %1
 */

#define ROUTERLOG_CANT_GET_REGKEYVALUES                 (ROUTER_LOG_BASE+2)
/*
 * Cannot access registry key values.
 */

#define ROUTERLOG_CANT_ENUM_REGKEYVALUES                (ROUTER_LOG_BASE+3)
/*
 * Cannot enumerate Registry key values. %1
 */

#define ROUTERLOG_INVALID_PARAMETER_TYPE                (ROUTER_LOG_BASE+4)
/*
 * Parameter %1 has an invalid type.
 */

#define ROUTERLOG_CANT_ENUM_PORTS                       (ROUTER_LOG_BASE+5)
/*
 * Cannot enumerate the Remote Access Connection Manager ports. %1
 */

#define ROUTERLOG_NO_DIALIN_PORTS                       (ROUTER_LOG_BASE+6)
/*
 * The Remote Access Service is not configured to receive calls or all ports
 * configured for receiving calls are in use by other applications.
 */

#define ROUTERLOG_CANT_RECEIVE_FRAME                    (ROUTER_LOG_BASE+7)
/*
 * Cannot receive initial frame on port %1 because of the following error: %2
 * The user has been disconnected.
 */

#define ROUTERLOG_AUTODISCONNECT                        (ROUTER_LOG_BASE+8)
/*
 * The user connected to port %1 has been disconnected due to inactivity.
 */

#define ROUTERLOG_EXCEPT_MEMORY                         (ROUTER_LOG_BASE+9)
/*
 * The user connected to port %1 has been disconnected because there is not
 * enough memory available in the system.
 */

#define ROUTERLOG_EXCEPT_SYSTEM                         (ROUTER_LOG_BASE+10)
/*
 * The user connected to port %1 has been disconnected due to a system error.
 */

#define ROUTERLOG_EXCEPT_LAN_FAILURE                    (ROUTER_LOG_BASE+11)
/*
 * The user connected to port %1 has been disconnected due to a critical network
 * error on the local network.
 */

#define ROUTERLOG_EXCEPT_ASYNC_FAILURE                  (ROUTER_LOG_BASE+12)
/*
 * The user connected to port %1 has been disconnected due to a critical network
 * error on the async network.
 */

#define ROUTERLOG_DEV_HW_ERROR                          (ROUTER_LOG_BASE+13)
/*
 * The communication device attached to port %1 is not functioning.
 */

#define ROUTERLOG_AUTH_FAILURE                          (ROUTER_LOG_BASE+14)
/*
 * The user %1 has connected and failed to authenticate on port %2. The line
 * has been disconnected.
 */

#define ROUTERLOG_AUTH_SUCCESS                          (ROUTER_LOG_BASE+15)
/*
 * The user %1 has connected and has been successfully authenticated on
 * port %2.
 */

#define ROUTERLOG_AUTH_CONVERSATION_FAILURE             (ROUTER_LOG_BASE+16)
/*
 * The user connected to port %1 has been disconnected because there was a
 * transport-level error during the authentication conversation.
 */

#define ROUTERLOG_CANT_RESET_LAN                        (ROUTER_LOG_BASE+18)
/*
 * Cannot reset the network adapter for LANA %1. The error code is the data.
 */

#define ROUTERLOG_CANT_GET_COMPUTERNAME                 (ROUTER_LOG_BASE+19)
/*
 * Remote Access Server Security Failure.
 * Cannot locate the computer name. GetComputerName call has failed.
 */

#define ROUTERLOG_CANT_ADD_RASSECURITYNAME              (ROUTER_LOG_BASE+20)
/*
 * Remote Access Server Security Failure.
 * Cannot add the name for communication with the security agent on LANA %1.
 */

#define ROUTERLOG_CANT_GET_ADAPTERADDRESS               (ROUTER_LOG_BASE+21)
/*
 * Remote Access Server Security Failure.
 * Cannot access the network adapter address on LANA %1.
 */

#define ROUTERLOG_SESSOPEN_REJECTED                     (ROUTER_LOG_BASE+22)
/*
 * Remote Access Server Security Failure.
 * The security agent has rejected the Remote Access server's call to
 * establish a session on LANA %1.
 */

#define ROUTERLOG_START_SERVICE_REJECTED                (ROUTER_LOG_BASE+23)
/*
 * Remote Access Server Security Failure.
 * The security agent has rejected the Remote Access server's request to start
 * the service on this computer on LANA %1.
 */

#define ROUTERLOG_SECURITY_NET_ERROR                    (ROUTER_LOG_BASE+24)
/*
 * Remote Access Server Security Failure.
 * A network error has occurred when trying to establish a session with the
 * security agent on LANA %1.
 * The error code is the data.
 */

#define ROUTERLOG_EXCEPT_OSRESNOTAV                     (ROUTER_LOG_BASE+25)
/*
 * The user connected to port %1 has been disconnected because there are no
 * operating system resources available.
 */

#define ROUTERLOG_EXCEPT_LOCKFAIL                       (ROUTER_LOG_BASE+26)
/*
 * The user connected to port %1 has been disconnected because of a failure to
 * lock user memory.
 */

#define ROUTERLOG_CANNOT_OPEN_RASHUB                    (ROUTER_LOG_BASE+27)
/*
 * Remote Access Connection Manager failed to start because NDISWAN could not
 * be opened.
 */


#define ROUTERLOG_CANNOT_INIT_SEC_ATTRIBUTE             (ROUTER_LOG_BASE+28)
/*
 *   Remote Access Connection Manager failed to start because it could not initialize the
 * security attributes. Restart the computer. %1
 */


#define ROUTERLOG_CANNOT_GET_ENDPOINTS                  (ROUTER_LOG_BASE+29)
/*
 *   Remote Access Connection Manager failed to start because no endpoints were available.
 * Restart the computer.
 */


#define ROUTERLOG_CANNOT_GET_MEDIA_INFO                 (ROUTER_LOG_BASE+30)
/*
 *   Remote Access Connection Manager failed to start because it could not load one or
 * more communication DLLs. Ensure that your communication hardware is installed and then
 * restart the computer. %1
 */


#define ROUTERLOG_CANNOT_GET_PORT_INFO                  (ROUTER_LOG_BASE+31)
/*
 *   Remote Access Connection Manager failed to start because it could not locate port
 * information from media DLLs. %1
 */


#define ROUTERLOG_CANNOT_GET_PROTOCOL_INFO              (ROUTER_LOG_BASE+32)
/*
 *   Remote Access Connection Manager failed to start because it could not access
 * protocol information from the Registry. %1
 */


#define ROUTERLOG_CANNOT_REGISTER_LSA                   (ROUTER_LOG_BASE+33)
/*
 *   Remote Access Connection Manager failed to start because it could not register
 * with the local security authority.
 * Restart the computer. %1
 */


#define ROUTERLOG_CANNOT_CREATE_FILEMAPPING             (ROUTER_LOG_BASE+34)
/*
 *   Remote Access Connection Manager failed to start because it could not create shared
 * file mapping.
 * Restart the computer. %1
 */


#define ROUTERLOG_CANNOT_INIT_BUFFERS                   (ROUTER_LOG_BASE+35)
/*
 *   Remote Access Connection Manager failed to start because it could not create buffers.
 * Restart the computer. %1
 */


#define ROUTERLOG_CANNOT_INIT_REQTHREAD                 (ROUTER_LOG_BASE+36)
/*
 *   Remote Access Connection Manager failed to start because it could not access resources.
 * Restart the computer. %1
 */


#define ROUTERLOG_CANNOT_START_WORKERS                  (ROUTER_LOG_BASE+37)
/*
 *   Remote Access Connection Manager service failed to start because it could not start worker
 * threads.
 * Restart the computer.
 */

#define ROUTERLOG_CANT_GET_LANNETS                      (ROUTER_LOG_BASE+38)
/*
 * Remote Access Server Configuration Error.
 * Cannot find the LANA numbers for the network adapters.
 * Remote clients connecting with the NBF protocol will only be able to access resources on the local machine. 
 */

#define ROUTERLOG_CANNOT_OPEN_SERIAL_INI                (ROUTER_LOG_BASE+39)
/*
 * RASSER.DLL cannot open the SERIAL.INI file.
 */

#define ROUTERLOG_CANNOT_GET_ASYNCMAC_HANDLE            (ROUTER_LOG_BASE+40)
/*
 * An attempt by RASSER.DLL to get an async media access control handle failed.
 */

#define ROUTERLOG_CANNOT_LOAD_SERIAL_DLL                (ROUTER_LOG_BASE+41)
/*
 * RASMXS.DLL cannot load RASSER.DLL.
 */

#define ROUTERLOG_CANNOT_ALLOCATE_ROUTE                 (ROUTER_LOG_BASE+42)
/*
 * The Remote Access server cannot allocate a route for the user connected on port %1 bacause of the following error: %2
 * The user has been disconnected.
 * Check the configuration of your Remote Access Service.
 */

#define ROUTERLOG_ADMIN_MEMORY_FAILURE                  (ROUTER_LOG_BASE+43)
/*
 * Cannot allocate memory in the admin support thread for the Remote Access Service.
 */

#define ROUTERLOG_ADMIN_THREAD_CREATION_FAILURE         (ROUTER_LOG_BASE+44)
/*
 * Cannot create an instance thread in the admin support thread for the Remote Access Service.
 */

#define ROUTERLOG_ADMIN_PIPE_CREATION_FAILURE           (ROUTER_LOG_BASE+45)
/*
 * Cannot create a named pipe instance in the admin support thread for the Remote Access Service.
 */

#define ROUTERLOG_ADMIN_PIPE_FAILURE                    (ROUTER_LOG_BASE+46)
/*
 * General named pipe failure occurred in the admin support thread for the Remote Access Service.
 */

#define ROUTERLOG_ADMIN_INVALID_REQUEST                 (ROUTER_LOG_BASE+47)
/*
 * An invalid request was sent to the admin support thread for the Remote Access Service,
 * possibly from a down-level admin tool.  The request was not processed.
 */

#define ROUTERLOG_USER_ACTIVE_TIME				        (ROUTER_LOG_BASE+48)
/*
 * The user %1 connected on port %2 on %3 at %4 and disconnected on
 * %5 at %6.  The user was active for %7 minutes %8 seconds.  %9 bytes
 * were sent and %10 bytes were received. The port speed was %11.  The
 * reason for disconnecting was %12.
 */

#define ROUTERLOG_AUTH_TIMEOUT                          (ROUTER_LOG_BASE+49)
/*
 * The user connected to port %1 has been disconnected because the authentication process
 * did not complete within the required amount of time.
 */

#define ROUTERLOG_AUTH_NO_PROJECTIONS                   (ROUTER_LOG_BASE+50)
/*
 * The user %1 connected to port %2 has been disconnected because no network protocols were successfully negotiated.
 */

#define ROUTERLOG_AUTH_INTERNAL_ERROR                   (ROUTER_LOG_BASE+51)
/*
 * The user connected to port %1 has been disconnected because an internal authentication error occurred.
 */

#define ROUTERLOG_NO_LANNETS_AVAILABLE			        (ROUTER_LOG_BASE+52)
/*
 * The NetBIOS gateway has been configured to access the network but there are no network adapters available.
 * Remote clients connecting with the NBF protocol will only be able to access resources on the local machine. 
 */

#define ROUTERLOG_NETBIOS_SESSION_ESTABLISHED		    (ROUTER_LOG_BASE+53)
/*
 * The user %1 established a NetBIOS session between
 * the remote workstation %2 and the network server %3.
 */

#define ROUTERLOG_RASMAN_NOT_AVAILABLE			        (ROUTER_LOG_BASE+54)
/*
 * Remote Access Service failed to start because the Remote Access Connection Manager failed to initialize because of the following error: %1
 */

#define ROUTERLOG_CANT_ADD_NAME				            (ROUTER_LOG_BASE+55)
/*
 * Cannot add the remote computer name %1 on LANA %2 for the client being connected on port %3.
 * The error code is the data.
 */

#define ROUTERLOG_CANT_DELETE_NAME 			            (ROUTER_LOG_BASE+56)
/*
 * Cannot delete the remote computer name %1 from LANA %2 for the client being disconnected on port %3.
 * The error code is the data.
 */

#define ROUTERLOG_CANT_ADD_GROUPNAME			        (ROUTER_LOG_BASE+57)
/*
 * Cannot add the remote computer group name %1 on LANA %2.
 * The error code is the data.
 */

#define ROUTERLOG_CANT_DELETE_GROUPNAME			        (ROUTER_LOG_BASE+58)
/*
 * Cannot delete the remote computer group name %1 from LANA %2.
 * The error code is the data.
 */

#define ROUTERLOG_UNSUPPORTED_BPS                       (ROUTER_LOG_BASE+59)
/*
 * The modem on %1 moved to an unsupported BPS rate.
 */

#define ROUTERLOG_SERIAL_QUEUE_SIZE_SMALL			    (ROUTER_LOG_BASE+60)
/*
 * The serial driver could not allocate adequate I/O queues.
 * This may result in an unreliable connection.
 */

#define ROUTERLOG_CANNOT_REOPEN_BIPLEX_PORT		        (ROUTER_LOG_BASE+61)
/*
 * Remote Access Connection Manager could not reopen biplex port %1. This port
 * will not be available for calling in or calling out.
 * Restart all Remote Access Service components.
 */

#define ROUTERLOG_DISCONNECT_ERROR 			            (ROUTER_LOG_BASE+62)
/*
 * Internal Error: Disconnect operation on %1 completed with an error. %1
 */

#define ROUTERLOG_CANNOT_INIT_PPP				        (ROUTER_LOG_BASE+63)
/*
 * Remote Access Connection Manager failed to start because the Point to Point
 * Protocol failed to initialize. %1
 */

#define ROUTERLOG_CLIENT_CALLED_BACK                    (ROUTER_LOG_BASE+64)
/*
 * The user %1 on port %2 was called back at the number %3.
 */

#define ROUTERLOG_PROXY_CANT_CREATE_PROCESS             (ROUTER_LOG_BASE+65)
/*
 * The Remote Access Gateway Proxy could not create a process.
 */

#define ROUTERLOG_PROXY_CANT_CREATE_PIPE                (ROUTER_LOG_BASE+66)
/*
 * The Remote Access Gateway Proxy could not create a named pipe.
 */

#define ROUTERLOG_PROXY_CANT_CONNECT_PIPE               (ROUTER_LOG_BASE+67)
/*
 * The Remote Access Gateway Proxy could not establish a named pipe connection
 * with the Remote Access Supervisor Proxy.
 */

#define ROUTERLOG_PROXY_READ_PIPE_FAILURE               (ROUTER_LOG_BASE+68)
/*
 * A general error occurred reading from the named pipe in the Remote Access Proxy.
 */

#define ROUTERLOG_CANT_OPEN_PPP_REGKEY			        (ROUTER_LOG_BASE+69)
/*
 * Cannot open or obtain information about the PPP key or one of its subkeys. %1
 */

#define ROUTERLOG_PPP_CANT_LOAD_DLL			            (ROUTER_LOG_BASE+70)
/*
 * Point to Point Protocol engine was unable to load the %1 module. %2
 */

#define ROUTERLOG_PPPCP_DLL_ERROR				        (ROUTER_LOG_BASE+71)
/*
 * The Point to Point Protocol module %1 returned an error while initializing.
 * %2
 */

#define ROUTERLOG_NO_AUTHENTICATION_CPS			        (ROUTER_LOG_BASE+72)
/*
 * The Point to Point Protocol failed to load the required PAP and/or CHAP
 * authentication modules.
 */

#define ROUTERLOG_PPP_FAILURE                           (ROUTER_LOG_BASE+73)
/*
 * The following error occurred in the Point to Point Protocol module on port: %1, UserName: %2.
 * %3
 */

#define ROUTERLOG_IPXCP_NETWORK_NUMBER_CONFLICT		    (ROUTER_LOG_BASE+74)
/*
 * The IPX network number %1 requested by the remote side for the WAN interface
 * is already in use on the local LAN.
 * Possible solution:
 * Disconnect this computer from the LAN and wait 3 minutes before dialing again;
 */

#define ROUTERLOG_IPXCP_CANNOT_CHANGE_WAN_NETWORK_NUMBER    (ROUTER_LOG_BASE+75)
/*
 * The IPX network number %1 requested by the remote workstation for the WAN interface
 * can not be used on the local IPX router because the router is configured to
 * give the same network number to all the remote workstations.
 * If you want to connect a remote workstation with a different network number you
 * should reconfigure the router to disable the common network number option.
 */

#define ROUTERLOG_PASSWORD_EXPIRED                      (ROUTER_LOG_BASE+76)
/*
 * The password for user %1\%2 connected on port %3 has expired.  The line
 * has been disconnected.
 */

#define ROUTERLOG_ACCT_EXPIRED                          (ROUTER_LOG_BASE+77)
/*
 * The account for user %1\%2 connected on port %3 has expired.  The line
 * has been disconnected.
 */

#define ROUTERLOG_NO_DIALIN_PRIVILEGE                   (ROUTER_LOG_BASE+78)
/*
 * The account for user %1\%2 connected on port %3 does not have Remote Access
 * privilege.  The line has been disconnected.
 */

#define ROUTERLOG_UNSUPPORTED_VERSION                   (ROUTER_LOG_BASE+79)
/*
 * The software version of the user %1\%2 connected on port %3 is unsupported.
 * The line has been disconnected.
 */

#define ROUTERLOG_ENCRYPTION_REQUIRED                   (ROUTER_LOG_BASE+80)
/*
 * The server machine is configured to require data encryption.  The machine
 * for user %1\%2 connected on port %3 does not support encryption.  The line
 * has been disconnected.
 */

#define ROUTERLOG_NO_SECURITY_CHECK                     (ROUTER_LOG_BASE+81)
/*
 * Remote Access Server Security Failure.  Could not reset lana %1 (the error
 * code is the data).  Security check not performed.
 */

#define ROUTERLOG_GATEWAY_NOT_ACTIVE_ON_NET             (ROUTER_LOG_BASE+82)
/*
 * The Remote Access Server could not reset lana %1 (the error code is the
 * data) and will not be active on it.
 */

#define ROUTERLOG_IPXCP_WAN_NET_POOL_NETWORK_NUMBER_CONFLICT    (ROUTER_LOG_BASE+83)
/*
 * The IPX network number %1 configured for the pool of WAN network numbers
 * can not be used because it conflicts with another network number on the net.
 * You should re-configure the pool to have unique network numbers.
 */

#define ROUTERLOG_SRV_ADDR_CHANGED                      (ROUTER_LOG_BASE+84)
/*
 * The Remote Access Server will stop using IP Address %1 (either because it
 * was unable to renew the lease from the DHCP Server, the administrator
 * switched between static address pool and DHCP addresses, or the administrator
 * changed to a different network for DHCP addresses). All connected users
 * using IP will be unable to access network resources. Users can re-connect
 * to the server to restore IP connectivity.
 */

#define ROUTERLOG_CLIENT_ADDR_LEASE_LOST			    (ROUTER_LOG_BASE+85)
/*
 * The Remote Access Server was unable to renew the lease for IP Address %1
 * from the DHCP Server. The user assigned with this IP address will be unable to
 * access network resources using IP. Re-connecting to the server will restore IP
 * connectivity.
 */

#define ROUTERLOG_ADDRESS_NOT_AVAILABLE			        (ROUTER_LOG_BASE+86)
/*
 * The Remote Access Server was unable to acquire an IP Address from the DHCP Server
 * to assign to the incoming user.
 */

#define ROUTERLOG_SRV_ADDR_NOT_AVAILABLE			    (ROUTER_LOG_BASE+87)
/*
 * The Remote Access Server was unable to acquire an IP Address from the DHCP Server
 * to be used on the Server Adapter. Incoming user will be unable to connect using
 * IP.
 */

#define ROUTERLOG_SRV_ADDR_ACQUIRED			            (ROUTER_LOG_BASE+88)
/*
 * The Remote Access Server acquired IP Address %1 to be used on the Server
 * Adapter.
 */

#define ROUTERLOG_CALLBACK_FAILURE                      (ROUTER_LOG_BASE+89)
/*
 * The Remote Access Server's attempt to callback user %1 on port %2 at %3
 * failed because of the following error: %4
 */

#define ROUTERLOG_PROXY_WRITE_PIPE_FAILURE              (ROUTER_LOG_BASE+90)
/*
 * A general error occurred writing to the named pipe in the Remote Access Proxy.
 */

#define ROUTERLOG_CANT_OPEN_SECMODULE_KEY               (ROUTER_LOG_BASE+91)
/*
 * Cannot open the RAS security host Registry key. The following error
 * occurred: %1
 */

#define ROUTERLOG_CANT_LOAD_SECDLL                      (ROUTER_LOG_BASE+92)
/*
 * Cannot load the Security host module component. The following error
 * occurred: %1
 */

#define ROUTERLOG_SEC_AUTH_FAILURE                      (ROUTER_LOG_BASE+93)
/*
 * The user %1 has connected and failed to authenticate with a third party
 * security on port %2. The line has been disconnected.
 */

#define ROUTERLOG_SEC_AUTH_INTERNAL_ERROR               (ROUTER_LOG_BASE+94)
/*
 * The user connected to port %1 has been disconnected because the following 
 * internal authentication error occurred in the third party security module: %2
 */

#define ROUTERLOG_CANT_RECEIVE_BYTES                    (ROUTER_LOG_BASE+95)
/*
 * Cannot receive initial data on port %1 because of the following error: %2
 * The user has been disconnected.
 */

#define ROUTERLOG_AUTH_DIFFUSER_FAILURE                 (ROUTER_LOG_BASE+96)
/*
 * The user was autheticated as %1 by the third party security host module but
 * was authenticated as %2 by the RAS security. The user has been disconnected.
 */

#define ROUTERLOG_LICENSE_LIMIT_EXCEEDED                (ROUTER_LOG_BASE+97)
/*
 * A user was unable to connect on port %1.
 * No more connections can be made to this remote computer because the computer
 * has exceeded its client license limit.
 */

#define ROUTERLOG_AMB_CLIENT_NOT_ALLOWED                (ROUTER_LOG_BASE+98)
/*
 * A user was unable to connect on port %1.
 * The NetBIOS protocol has been disabled for the Remote Access Server.
 */
#define ROUTERLOG_CANT_QUERY_VALUE                      (ROUTER_LOG_BASE+99)
/*
 * Cannot access Registry value for %1.
 */

#define ROUTERLOG_CANT_OPEN_REGKEY                      (ROUTER_LOG_BASE+100)
/*
 * Cannot access the Registry key %1.
 */

#define ROUTERLOG_REGVALUE_OVERIDDEN                    (ROUTER_LOG_BASE+101)
/*
 * Using the default value for Registry parameter %1 because the value given is
 * not in the legal range for the parameter.
 */

#define ROUTERLOG_CANT_ENUM_SUBKEYS                     (ROUTER_LOG_BASE+102)
/*
 * Cannot enumerate keys of Registry key %1.
 */

#define ROUTERLOG_LOAD_DLL_ERROR                        (ROUTER_LOG_BASE+103)
/*
 * Unable to load %1.
 */

#define ROUTERLOG_NOT_ENOUGH_MEMORY                     (ROUTER_LOG_BASE+104)
/*
 * Memory allocation failure.
 */

#define ROUTERLOG_COULDNT_LOAD_IF                       (ROUTER_LOG_BASE+105)
/*
 * Unable to load the interface %1 from the registry. The following error
 * occurred: %2
 */

#define ROUTERLOG_COULDNT_ADD_INTERFACE                 (ROUTER_LOG_BASE+106)
/*
 * Unable to add the interface %1 with the Router Manager for the %2 protocol. The
 * following error occurred: %3
 */

#define ROUTERLOG_COULDNT_REMOVE_INTERFACE              (ROUTER_LOG_BASE+107)
/*
 * Unable to remove the interface %1 with the Router Manager for the %2 protocol.
 * The following error occurred: %3
 */

#define ROUTERLOG_UNABLE_TO_OPEN_PORT                   (ROUTER_LOG_BASE+108)
/*
 * Unable to open the port %1 for use. %2
 */

#define ROUTERLOG_UNRECOGNIZABLE_FRAME_RECVD            (ROUTER_LOG_BASE+109)
/*
 * Cannot recognize initial frame received on port %1.
 * The line has been disconnected.
 */

#define ROUTERLOG_CANT_START_PPP                        (ROUTER_LOG_BASE+110)
/*
 * An error occurred in the Point to Point Protocol module on port %1 while
 * trying to initiate a connection. %2
 */

#define ROUTERLOG_CONNECTION_ATTEMPT_FAILED             (ROUTER_LOG_BASE+111)
/*
 * A Demand Dial connection to the remote interface %1 on port %2 was
 * successfully initiated but failed to complete successfully because of the 
 * following error: %3
 */

#define ROUTERLOG_CANT_OPEN_ADMINMODULE_KEY             (ROUTER_LOG_BASE+112)
/*
 * Cannot open the RAS third party administration host DLL Registry key.
 * The following error occurred: %1
 */

#define ROUTERLOG_CANT_LOAD_ADMINDLL                    (ROUTER_LOG_BASE+113)
/*
 * Cannot load the RAS third party administration DLL component.
 * The following error occurred: %1
 */

#define ROUTERLOG_NO_PROTOCOLS_CONFIGURED               (ROUTER_LOG_BASE+114)
/*
 * The Service will not accept calls. No protocols were configured for use.
 */

#define ROUTERLOG_IPX_NO_VIRTUAL_NET_NUMBER             (ROUTER_LOG_BASE+115)
/*
 * IPX Routing requires an internal network number for correct operation.
 */

#define ROUTERLOG_IPX_CANT_LOAD_PROTOCOL                (ROUTER_LOG_BASE+116)
/*
 * Cannot load routing protocol DLL %1. The error code is in data.
 */

#define ROUTERLOG_IPX_CANT_REGISTER_PROTOCOL            (ROUTER_LOG_BASE+117)
/*
 * Cannot register routing protocol 0x%1. The error code is in data.
 */

#define ROUTERLOG_IPX_CANT_START_PROTOCOL               (ROUTER_LOG_BASE+118)
/*
 * Cannot start routing protocol 0x%1. The error code is in data.
 */

#define ROUTERLOG_IPX_CANT_LOAD_IPXCP                   (ROUTER_LOG_BASE+119)
/*
 * Cannot load IPXCP protocol DLL.  The error code is in data.
 */

#define ROUTERLOG_IPXSAP_SAP_SOCKET_IN_USE              (ROUTER_LOG_BASE+120)
/*
 * Could not open IPX SAP socket for exclusive access.
 * The error code is in data.
 */

#define ROUTERLOG_IPXSAP_SERVER_ADDRESS_CHANGE          (ROUTER_LOG_BASE+121)
/*
 * Server %1 has changed its IPX address.  Old and new addresses are in data.
 */

#define ROUTERLOG_IPXSAP_SERVER_DUPLICATE_ADDRESSES     (ROUTER_LOG_BASE+122)
/*
 * Server %1 is advertised with different IPX address.  Old and new addresses are in data.
 */

#define ROUTERLOG_IPXRIP_RIP_SOCKET_IN_USE              (ROUTER_LOG_BASE+123)
/*
 * Could not open IPX RIP socket for exclusive access.
 * The error code is in data.
 */

#define ROUTERLOG_IPXRIP_LOCAL_NET_NUMBER_CONFLICT      (ROUTER_LOG_BASE+124)
/*
 * Another IPX router claims different network number for interface %1.
 * Offending router IPX address is in data.
 */

#define ROUTERLOG_PERSISTENT_CONNECTION_FAILURE         (ROUTER_LOG_BASE+125)
/*
 * A Demand Dial persistent connection to the remote interface %1 failed to be
 * initated succesfully. The following error occurred: %2
 */

#define ROUTERLOG_IP_DEMAND_DIAL_PACKET                 (ROUTER_LOG_BASE+126)
/*
 * A packet from %1 destined to %2 over protocol 0x%3 caused interface %4
 * to be brought up. The first %5 bytes of the packet are in the data.
 */

#define ROUTERLOG_DID_NOT_LOAD_DDMIF                    (ROUTER_LOG_BASE+127)
/*
 * The Demand Dial interface %1 was not loaded. The router was not started in
 * in Demand Dial mode.
 */

#define ROUTERLOG_CANT_LOAD_ARAP                        (ROUTER_LOG_BASE+128)
/*
 * Cannot load the Appletalk Remote Access DLL component because of the following error: %1
 */

#define ROUTERLOG_CANT_START_ARAP                       (ROUTER_LOG_BASE+129)
/*
 * An error occurred in the Appletalk Remote Access Protocol module on port %1
 * while trying to initiate a connection. %2
 */

#define ROUTERLOG_ARAP_FAILURE                          (ROUTER_LOG_BASE+130)
/*
 * The following error occurred in the Appletalk Remote Access Protocol module on
 * port %1. %2
 */

#define ROUTERLOG_ARAP_NOT_ALLOWED                      (ROUTER_LOG_BASE+131)
/*
 * A user was unable to connect on port %1.
 * The Appletalk Remote Access protocol has been disabled for the Remote
 * Access Server.
 */

#define ROUTERLOG_CANNOT_INIT_RASRPC                    (ROUTER_LOG_BASE+132)
/*
 * Remote Access Connection Manager failed to start because the RAS RPC
 * module failed to initialize. %1
 */

#define ROUTERLOG_IPX_CANT_LOAD_FORWARDER               (ROUTER_LOG_BASE+133)
/*
 * IPX Routing failed to start because IPX forwarder driver could
 * not be loaded.
 */

#define ROUTERLOG_IPX_BAD_GLOBAL_CONFIG                 (ROUTER_LOG_BASE+134)
/*
 * IPX global configuration information is corrupted.
 */

#define ROUTERLOG_IPX_BAD_CLIENT_INTERFACE_CONFIG       (ROUTER_LOG_BASE+135)
/*
 * IPX dial-in client configuration information is corrupted.
 */

#define ROUTERLOG_IPX_BAD_INTERFACE_CONFIG              (ROUTER_LOG_BASE+136)
/*
 * IPX configuration information for interface %1 is corrupted.
 */

#define ROUTERLOG_IPX_DEMAND_DIAL_PACKET                (ROUTER_LOG_BASE+137)
/*
 * An IPX packet caused interface %1 to be brought up.
 * The the first %2 bytes of the packet are in data.
 */

#define ROUTERLOG_CONNECTION_FAILURE                    (ROUTER_LOG_BASE+138)
/*
 * A Demand Dial connection to the remote interface %1 failed to be
 * initated succesfully. The following error occurred: %2
 */

#define ROUTERLOG_CLIENT_AUTODISCONNECT                 (ROUTER_LOG_BASE+139)
/*
 * The port %1 has been disconnected due to inactivity.
 */

#define ROUTERLOG_PPP_SESSION_TIMEOUT                   (ROUTER_LOG_BASE+140)
/*
 * The port %1 has been disconnected because the user reached the maximum connect time allowed by the administrator.
 */

#define ROUTERLOG_AUTH_SUCCESS_ENCRYPTION               (ROUTER_LOG_BASE+141)
/*
 * The user %1 has connected and has been successfully authenticated on
 * port %2. Data sent and received over this link is encrypted.
 */

#define ROUTERLOG_AUTH_SUCCESS_STRONG_ENCRYPTION        (ROUTER_LOG_BASE+142)
/*
 * The user %1 has connected and has been successfully authenticated on
 * port %2. Data sent and received over this link is strongly encrypted.
 */

#define ROUTERLOG_NO_DEVICES_FOR_IF                     (ROUTER_LOG_BASE+143)
/*
 * Unable to load the interface %1 from the registry. There are no routing enabled ports available for use by this demand dial interface. Use the Routing and RemoteAccess Administration tool to configure this interface to use a device that is routing enabled. Stop and restart the router for this demand dial interface to be loaded from the registry.
 */

#define ROUTERLOG_LIMITED_WKSTA_SUPPORT                 (ROUTER_LOG_BASE+144)
/*
 * The Demand-Dial interface %1 was not registered with the Router.
 * Demand-Dial interfaces are not supported on a Windows NT Workstation.
 */

#define ROUTERLOG_CANT_INITIALIZE_IP_SERVER             (ROUTER_LOG_BASE+145)
/*
 * Cannot initialize the Remote Access and Router service to accept calls using 
 * the TCP/IP transport protocol. The following error occurred: %1
 */

#define ROUTERLOG_RADIUS_SERVER_NO_RESPONSE             (ROUTER_LOG_BASE+146)
/*
 * The RADIUS server %1 did not respond to the initial request. 
 * Please make sure that the server name or IP address and secret are correct.
 */

#define ROUTERLOG_PPP_INIT_FAILED                       (ROUTER_LOG_BASE+147)
/*
 * The Remote Access service failed to start because the Point to Point was
 * not initialized successfully. %1
 */

#define ROUTERLOG_RADIUS_SERVER_NAME                    (ROUTER_LOG_BASE+148)
/*
 * The RADIUS server name %1 could not be successfully resolved to an IP address. Please make sure that the name is spelled correctly and that the RADIUS server is running correctly.
 */

#define ROUTERLOG_IP_NO_GLOBAL_INFO                     (ROUTER_LOG_BASE+149)
/*
 * No global configuration was supplied to the IP Router Manager. Please rerun
 * setup.
 */

#define ROUTERLOG_IP_CANT_ADD_DD_FILTERS                (ROUTER_LOG_BASE+150)
/*
 * Unable to add demand dial filters for interface %1
 */

#define ROUTERLOG_PPPCP_INIT_ERROR				        (ROUTER_LOG_BASE+151)
/*
 * The Control Protocol %1 in the Point to Point Protocol module %2 returned an
 * error while initializing. %3
 */

#define ROUTERLOG_AUTHPROVIDER_FAILED_INIT              (ROUTER_LOG_BASE+152)
/*
 * The currently configured authentication provider failed to load and initialize successfully. %1
 */

#define ROUTERLOG_ACCTPROVIDER_FAILED_INIT              (ROUTER_LOG_BASE+153)
/*
 * The currently configured accounting provider failed to load and initialize successfully. %1
 */

#define ROUTERLOG_IPX_AUTO_NETNUM_FAILURE               (ROUTER_LOG_BASE+154)
/*
 * The IPX Internal Network Number is invalid and the IPX Router Manager was unsuccessful in its
 * attempt to automatically assign a valid one.  Reconfigure the IPX Internal Network Number through 
 * the connections folder and restart the Routing and Remote Access service.
 */

#define ROUTERLOG_IPX_WRN_STACK_STARTED                 (ROUTER_LOG_BASE+155)
/*
 * In order for the IPX Router Manager (which runs as part of the Routing and Remote Access Service)
 * to run, it had to start the IPX Protocol Stack Driver.  This driver was either manually stopped
 * or marked as demand start.  The Routing and Remote Access Service was probably started by the creation of
 * Incoming Connections or through the Routing and Remote Access snapin.
 */

#define ROUTERLOG_IPX_STACK_DISABLED                    (ROUTER_LOG_BASE+156)
/*
 * The IPX Router Manager was unable to start because the IPX Protocol Stack Driver could
 * not be started.
 */

#define ROUTERLOG_IP_MCAST_NOT_ENABLED                  (ROUTER_LOG_BASE+157)
/*
 * The interface %1 could not be enabled for multicast. %2 will not be
 * activated over this interface.
 */

#define ROUTERLOG_CONNECTION_ESTABLISHED                (ROUTER_LOG_BASE+158)
/*
 * The user %1 successfully established a connection to %2 using the device %3.
 */

#define ROUTERLOG_DISCONNECTION_OCCURRED                (ROUTER_LOG_BASE+159)
/*
 * The connection to %1 made by user %2 using device %3 was disconnected. 
 */

#define ROUTERLOG_BAP_CLIENT_CONNECTED                  (ROUTER_LOG_BASE+161)
/*
 * The user %1 successfully established a connection to %2 using the device %3.
 * This connection happened automatically because the bandwidth utilization was 
 * high.
 */

#define ROUTERLOG_BAP_SERVER_CONNECTED                  (ROUTER_LOG_BASE+162)
/*
 * The Remote Access Server established a connection to %1 for the user %2
 * using the device %3. This connection happened automatically because the
 * bandwidth utilization
 * was high.
 */

#define ROUTERLOG_BAP_DISCONNECTED                      (ROUTER_LOG_BASE+163)
/*
 * The connection to %1 made by user %2 using device %3 was disconnected. This
 * disconnection happened automatically because the bandwidth utilization was
 * low.
 */

#define ROUTERLOG_BAP_WILL_DISCONNECT                   (ROUTER_LOG_BASE+164)
/*
 * The Remote Access Server wants to disconnect a link in the connection to %1
 * made by user %2 because the bandwidth utilization is too low.
 */

#define ROUTERLOG_LOCAL_UNNUMBERED_IPCP                 (ROUTER_LOG_BASE+165)
/*
 * A connection has been established on port %1 using interface %2, but no IP
 * address was obtained.
 */

#define ROUTERLOG_REMOTE_UNNUMBERED_IPCP                (ROUTER_LOG_BASE+166)
/*
 * A connection has been established on port %1 using interface %2, but the 
 * remote side got no IP address.
 */

#define ROUTERLOG_NO_IP_ADDRESS                         (ROUTER_LOG_BASE+167)
/*
 * No IP address is available to hand out to the dial-in client. 
 */

#define ROUTERLOG_CANT_GET_SERVER_CRED                  (ROUTER_LOG_BASE+168)
/*
 * Could not retrieve the Remote Access Server's certificate due to the 
 * following error: %1
 */

#define ROUTERLOG_AUTONET_ADDRESS                       (ROUTER_LOG_BASE+169)
/*
 * Unable to contact a DHCP server. The Automatic Private IP Address %1 will be
 * assigned to dial-in clients. Clients may be unable to access resources on
 * the network.
 */

#define ROUTERLOG_EAP_AUTH_FAILURE                      (ROUTER_LOG_BASE+170)
/*
 * The user %1 has connected and failed to authenticate because of
 * the following error: %2
 */

#define ROUTERLOG_IPSEC_FILTER_FAILURE                  (ROUTER_LOG_BASE+171)
/*
 * Failed to apply IP Security on port %1 because of error: %2. 
 * No calls will be accepted to this port. 
 */

#define ROUTERLOG_IP_SCOPE_NAME_CONFLICT                (ROUTER_LOG_BASE+172)
/*
 * Multicast scope mismatch with %1:
 * Locally-configured name "%2",
 * Remotely-configured name "%3".
 */

#define ROUTERLOG_IP_SCOPE_ADDR_CONFLICT                (ROUTER_LOG_BASE+173)
/*
 * Multicast scope address mismatch for scope "%1",
 * Locally-configured range is %4-%5,
 * Remotely-configured range is %2-%3
 */

#define ROUTERLOG_IP_POSSIBLE_LEAKY_SCOPE               (ROUTER_LOG_BASE+174)
/*
 * Possible leaky multicast Local Scope detected between this machine and
 * %1, since a boundary appears to exist for %2, but not for
 * the local scope.  If this warning continues to occur, a problem likely
 * exists.
 */

#define ROUTERLOG_NONCONVEX_SCOPE_ZONE                  (ROUTER_LOG_BASE+175)
/*
 * Multicast scope '%1' is non-convex, since border router
 * %2 appears to be outside.
 */

#define ROUTERLOG_IP_LEAKY_SCOPE                        (ROUTER_LOG_BASE+176)
/*
 * A leak was detected in multicast scope '%1'.  One of the
 * following routers is misconfigured:
 * %2
 */

#define ROUTERLOG_IP_IF_UNREACHABLE                     (ROUTER_LOG_BASE+177)
/*
 * Interface %1 is unreachable because of reason %2.
 */

#define ROUTERLOG_IP_IF_REACHABLE                       (ROUTER_LOG_BASE+178)
/*
 * Interface %1 is now reachable.
 */

#define ROUTERLOG_IF_UNREACHABLE_REASON1                (ROUTER_LOG_BASE+179)
/*
 * Interface %1 is unreachable because there are no modems (or other connecting devices) 
 * available for use by this interface.
 */

#define ROUTERLOG_IF_UNREACHABLE_REASON2                (ROUTER_LOG_BASE+180)
/*
 * Interface %1 is unreachable because the connection attempt failed.
 */

#define ROUTERLOG_IF_UNREACHABLE_REASON3                (ROUTER_LOG_BASE+181)
/*
 * Interface %1 is unreachable because it has been administratively disabled.
 */

#define ROUTERLOG_IF_UNREACHABLE_REASON4                (ROUTER_LOG_BASE+182)
/*
 * Interface %1 is unreachable because the Routing and RemoteACcess service is in a 
 * paused state.
 */

#define ROUTERLOG_IF_UNREACHABLE_REASON5                (ROUTER_LOG_BASE+183)
/*
 * Interface %1 is unreachable because it is not allowed to connect at this time.
 * Check the dial-out hours configured on this interface.
 */

#define ROUTERLOG_IF_UNREACHABLE_REASON6                (ROUTER_LOG_BASE+184)
/*
 * Interface %1 is unreachable because it is not currently connected to the network.
 */

#define ROUTERLOG_IF_UNREACHABLE_REASON7                (ROUTER_LOG_BASE+185)
/*
 * Interface %1 is unreachable because the network card for this interface has been 
 * removed.
 */

#define ROUTERLOG_IF_REACHABLE                          (ROUTER_LOG_BASE+186)
/*
 * Interface %1 is now reachable.
 */

#define ROUTERLOG_NTAUTH_FAILURE                        (ROUTER_LOG_BASE+187)
/*
 * The user %1 failed an authentication attempt due to the following reason: %2
 */

#define ROUTERLOG_CONNECTION_ATTEMPT_FAILURE            (ROUTER_LOG_BASE+188)
/*
 * The user %1, attempting to connect on %2, was disconnected because of the following 
 * reason: %3
 */

#define ROUTERLOG_NTAUTH_FAILURE_EX                     (ROUTER_LOG_BASE+189)
/*
 * The user %1 connected from %2 but failed an authentication attempt due to the following reason: %3
 */

#define ROUTERLOG_EAP_TLS_CERT_NOT_CONFIGURED           (ROUTER_LOG_BASE+190)
/*
 * Because no certificate has been configured for clients dialing in with
 * EAP-TLS, a default certificate is being sent to user %1. Please go to the
 * user's Remote Access Policy and configure the Extensible Authentication
 * Protocol (EAP).
 */

#define ROUTERLOG_EAP_TLS_CERT_NOT_FOUND                (ROUTER_LOG_BASE+191)
/*
 * Because the certificate that was configured for clients dialing in with
 * EAP-TLS was not found, a default certificate is being sent to user %1.
 * Please go to the user's Remote Access Policy and configure the Extensible
 * Authentication Protocol (EAP).
 */

#define ROUTERLOG_NO_IPSEC_CERT                         (ROUTER_LOG_BASE+192)
/*
 * A certificate could not be found. Connections that use the L2TP protocol over IPSec 
 * require the installation of a machine certificate, also known as a computer 
 * certificate. No L2TP calls will be accepted.
 */

#define ROUTERLOG_IP_CANT_ADD_PFILTERIF                 (ROUTER_LOG_BASE+193)
/*
 * An error occured while configuring IP packet filters over %1.  This is often
 * the result of another service, e.g Microsoft Proxy Server, also using the 
 * Windows 2000 filtering services.
 */

 #define ROUTERLOG_USER_ACTIVE_TIME_VPN                 (ROUTER_LOG_BASE+194)
/*
 * The user %1 connected on port %2 on %3 at %4 and disconnected on
 * %5 at %6.  The user was active for %7 minutes %8 seconds.  %9 bytes
 * were sent and %10 bytes were received. The
 * reason for disconnecting was %11.
 */

#define ROUTERLOG_BAP_DISCONNECT                        (ROUTER_LOG_BASE+195)
/*
 * The user %1 has been disconnected on port %2. %3
 */

#define ROUTERLOG_INVALID_RADIUS_RESPONSE               (ROUTER_LOG_BASE+196)
/*
 * An invalid response was received from the RADIUS server %1. %2
 */

#define ROUTERLOG_RASAUDIO_FAILURE                      (ROUTER_LOG_BASE+197)
/*
 * Ras Audio Acceleration failed to %1. %2
 */

#define ROUTERLOG_RADIUS_SERVER_CHANGED                 (ROUTER_LOG_BASE+198)
/*
 * Choosing radius server %1 for authentication.
 */

#define ROUTERLOG_IP_IF_TYPE_NOT_SUPPORTED              (ROUTER_LOG_BASE+199)
/*
 * IPinIP tunnel interfaces are no longer supported
 */

#define ROUTERLOG_IP_USER_CONNECTED                     (ROUTER_LOG_BASE+200)
/*
 * The user %1 connected on port %2 has been assigned address %3
 */

#define ROUTERLOG_IP_USER_DISCONNECTED                  (ROUTER_LOG_BASE+201)
/*
 * The user with ip address %1 has disconnected
 */

#define ROUTERLOG_CANNOT_REVERT_IMPERSONATION          (ROUTER_LOG_BASE+202)
/*
 * An error occured while trying to revert impersonation.
 */

#define ROUTERLOG_CANT_LOAD_SECDLL_EXPLICIT            (ROUTER_LOG_BASE+203)
/*
 * Cannot load the Security host module component. The following error
 * occurred: %1 is not a valid win32 application.
 */

#define ROUTERLOG_CANT_LOAD_ADMINDLL_EXPLICIT          (ROUTER_LOG_BASE+204)
/*
 * Cannot load the RAS third party administration DLL component.
 * The following error occurred: %1 is not a valid win32 application.
 */

#define ROUTERLOG_IPX_TRANSPORT_NOT_SUPPORTED         (ROUTER_LOG_BASE+205)
/*
 * IPX routing is no longer supported.
 */

#define ROUTERLOG_OLD_LOG_DELETED                     (ROUTER_LOG_BASE+206)
/*
 * Disk full. Deleted older logfile %1 to create free space.
 */

#define ROUTERLOG_OLD_LOG_DELETE_ERROR                (ROUTER_LOG_BASE+207)
/*
 * Disk full. Could not delete older logfile %1 to create free space.
 */

#define ROUTERLOG_OLD_LOG_NOT_FOUND                   (ROUTER_LOG_BASE+208)
/*
 * Disk full. Could not find older logfile to delete and create free space.
 */

#define ROUTER_LOG_BASEEND                              (ROUTER_LOG_BASE+999)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\ppool.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ppool.h

Abstract:

    Structures and #defines for managing NDIS_PACKET pools. This is
    merely a reformatted version of SteveC's l2tp\ppool.h

Revision History:


--*/


#ifndef __IPINIP_PPOOL_H__
#define __IPINIP_PPOOL_H___


//
// Data structures
//

//
// Packet pool control block.  A packet pool encapsulates an NDIS packet pool
// handling all pool growth and shrinkage internally.
//

typedef struct _PACKET_POOL
{
    //
    // Size in bytes of the ProtocolReserved array for each packet in the
    // pool.
    //
    
    ULONG ulProtocolReservedLength;

    //
    // The optimal number of packets to allocate in each packet block.
    //
    
    ULONG ulPacketsPerBlock;

    //
    // Maximum number of individual packets that may be allocated in the
    // entire pool, or 0 for unlimited.
    //
    
    ULONG ulMaxPackets;

    //
    // Current number of individual packets allocated in the entire pool.
    //
    
    ULONG ulCurPackets;

    //
    // Garbage collection occurs after this many calls to FreePacketToPool.
    //
    
    ULONG ulFreesPerCollection;

    //
    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    
    ULONG ulFreesSinceCollection;

    //
    // Memory identification tag for allocated blocks.
    //
    
    ULONG ulTag;

    //
    // Head of the double linked list of PACKET_BLOCKs.  Access to the
    // list is protected with 'lock' in this structure.
    //
    
    LIST_ENTRY  leBlockHead;

    //
    // Head of the double linked list of free PACKET_HEADs.  Each
    // PACKET_HEAD in the list is ready to go, i.e. it already has an
    // NDIS_PACKET associated with it.
    // Access to the list is prototected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of
    // blocks and this list must lock each other and (b) double links are
    // necessary for garbage collection.
    //
    
    LIST_ENTRY  leFreePktHead;

    //
    // This lock protects this structure and both the list of blocks and the
    // list of packets.
    //
    
    RT_LOCK     rlLock;
    
}PACKET_POOL, *PPACKET_POOL;

//
// Header of a single block of packets from a packet pool.  The PACKET_HEAD of
// the first buffer immediately follows.
//

typedef struct _PACKET_BLOCK
{
    //
    // Links to the prev/next packet block header in the packet pool's list.
    //
    
    LIST_ENTRY      leBlockLink;

    //
    // NDIS's handle of the pool of NDIS_PACKET descriptors associated with
    // this block, or NULL if none.
    //
    
    NDIS_HANDLE     nhNdisPool;

    //
    // Back pointer to the packet pool.
    //
    
    PPACKET_POOL    pPool;

    //
    // Number of individual packets in this block.
    //
    
    ULONG           ulPackets;

    //
    // Number of individual packets in this block on the free list.
    //
    
    ULONG           ulFreePackets;
    
}PACKET_BLOCK ,*PPACKET_BLOCK;

//
// Control information for an individual packet.  For the packet pool, this
// "header" does not actually preceed anything, but this keeps the terminology
// consistent with the very similar buffer pool routines.
//

typedef struct _PACKET_HEAD
{
    //
    // Link to next packet header in the packet pool's free list.
    //
    
    LIST_ENTRY      leFreePktLink;

    //
    // Back link to owning packet block header.
    //
    
    PPACKET_BLOCK   pBlock;

    //
    // NDIS packet descriptor of this buffer.
    //
    
    PNDIS_PACKET    pNdisPacket;
    
}PACKET_HEAD, *PPACKET_HEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PPACKET_POOL pPool,
    IN  ULONG        ulProtocolReservedLength,
    IN  ULONG        ulMaxPackets,
    IN  ULONG        ulPacketsPerBlock,
    IN  ULONG        ulFreesPerCollection,
    IN  ULONG        ulTag
    );

BOOLEAN
FreePacketPool(
    IN PPACKET_POOL  pPool
    );

PNDIS_PACKET
GetPacketFromPool(
    IN  PPACKET_POOL pPool,
    OUT PACKET_HEAD  **ppHead
    );

VOID
FreePacketToPool(
    IN PPACKET_POOL  pPool,
    IN PPACKET_HEAD  pHead,
    IN BOOLEAN       fGarbageCollection
    );

//
// PPACKET_POOL
// PacketPoolFromPacketHead(
//    IN PPACKET_HEAD pHead
//    );
//


#define PacketPoolFromPacketHead(pHead) \
    ((pHead)->pBlock->pPool)


#endif // __IPINIP_PPOOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\ppool.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ppool.h

Abstract:

    Code for managing NDIS_PACKET pools. This is merely a reformatted version
    of SteveC's l2tp\ppool.c

Revision History:


--*/

#define __FILE_SIG__    PPOOL_SIG

#include "inc.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

PPACKET_HEAD
AddPacketBlockToPool(
    IN PPACKET_POOL pPool
    );

VOID
FreeUnusedPacketPoolBlocks(
    IN PPACKET_POOL pPool
    );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PPACKET_POOL pPool,
    IN  ULONG        ulProtocolReservedLength,
    IN  ULONG        ulMaxPackets,
    IN  ULONG        ulPacketsPerBlock,
    IN  ULONG        ulFreesPerCollection,
    IN  ULONG        ulTag
    )
/*++
Routine Description

    Initialize caller's packet pool control block 'pPool'

Locks

    Caller's 'pPool' packet must be protected from multiple access during
    this call.
    
Arguments

    ulProtocolReservedLength    size in bytes of the 'ProtocolReserved'
                                array of each individual packet.
    ulMaxPackets                maximum number of packets allowed in the
                                entire pool, or 0 for unlimited.
    ulPacketsPerBlock           number of packets to include in each block
                                of packets.
    ulFreesPerCollection        number of FreePacketToPool calls until the
                                next garbage collect scan, or 0 for default.
    ulTag                       pool tag to use when allocating blocks
    
Return Value

    None

--*/
{
    pPool->ulProtocolReservedLength     = ulProtocolReservedLength;
    pPool->ulPacketsPerBlock            = ulPacketsPerBlock;
    pPool->ulMaxPackets                 = ulMaxPackets;
    pPool->ulFreesSinceCollection       = 0;
    pPool->ulTag                        = ulTag;

    if(ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        //
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        
        pPool->ulFreesPerCollection = 50 * pPool->ulPacketsPerBlock;
    }

    InitializeListHead(&(pPool->leBlockHead));
    InitializeListHead(&(pPool->leFreePktHead));
    
    RtInitializeSpinLock(&(pPool->rlLock));
}


BOOLEAN
FreePacketPool(
    IN PPACKET_POOL pPool
    )
/*++
Routine Description

    Free up all resources allocated in packet pool 'pPool'.  This is the
    inverse of InitPacketPool.

Locks


Arguments


Return Value

    TRUE    if successful
    FALSE   if any of the pool could not be freed due to outstanding packets

--*/
{
    BOOLEAN fSuccess;
    KIRQL   irql;
    
    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    FreeUnusedPacketPoolBlocks(pPool);

    fSuccess = (pPool->ulCurPackets is 0);

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);

    return fSuccess;
}


PNDIS_PACKET
GetPacketFromPool(
    IN  PPACKET_POOL pPool,
    OUT PACKET_HEAD  **ppHead
    )
/*++
Routine Description

    Returns the address of the NDIS_PACKET descriptor allocated from the
    pool. The pool is expanded, if necessary, but caller should
    still check for NULL return since the pool may have been at maximum
    size. 

Locks


Arguments

    pPool   Pool to get packet from
    ppHead  Pointer the "cookie" that is used to return the packet to
            the pool (see FreePacketToPool).  Caller would normally stash this
            value in the appropriate 'reserved' areas of the packet for
            retrieval later.
            
Return Value

    Pointer to NDIS_PACKET or NULL

--*/
{
    PLIST_ENTRY  pleNode;
    PPACKET_HEAD pHead;
    PNDIS_PACKET pPacket;
    KIRQL        irql;


    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    if(IsListEmpty(&pPool->leFreePktHead))
    {
        pleNode = NULL;
    }
    else
    {
        pleNode = RemoveHeadList(&(pPool->leFreePktHead));
        
        pHead = CONTAINING_RECORD(pleNode, PACKET_HEAD, leFreePktLink);
        
        pHead->pBlock->ulFreePackets--;
    }

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);

    if(!pleNode)
    {
        //
        // The free list was empty.  Try to expand the pool.
        //
        
        pHead = AddPacketBlockToPool(pPool);
        
        if(!pHead)
        {
            return NULL;
        }
    }

    *ppHead = pHead;
    
    return pHead->pNdisPacket;
}


VOID
FreePacketToPool(
    IN PPACKET_POOL pPool,
    IN PPACKET_HEAD pHead,
    IN BOOLEAN      fGarbageCollection
    )
/*++
Routine Description

    Returns a packet to the pool of unused packet. The packet must have
    been previously allocate with GetaPacketFromPool.
    
Locks


Arguments

    pPool   Pool to which the packet is to be returned
    pHead   The "cookie" that was given when the packet was allocated
    
    fGarbageCollection is set when the free should be considered for
    purposes of garbage collection.  This is used by the AddPacketToPool
    routine to avoid counting the initial "add" frees.  Normal callers
    should set this flag.
    
Return Value
    NO_ERROR

--*/
{
    KIRQL   irql;

    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    InsertHeadList(&(pPool->leFreePktHead),
                   &(pHead->leFreePktLink));
    
    pHead->pBlock->ulFreePackets++;
    
    if(fGarbageCollection)
    {
        pPool->ulFreesSinceCollection++;
        
        if(pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
        {
            //
            // Time to collect garbage, i.e. free any blocks in the pool
            // not in use.
            //
            
            FreeUnusedPacketPoolBlocks(pPool);
            
            pPool->ulFreesSinceCollection = 0;
        }   
    }   

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);
}


//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------------

PPACKET_HEAD
AddPacketBlockToPool(
    IN PPACKET_POOL pPool
    )
/*++
Routine Description

    Allocate a new packet block and add it to the packet pool

Locks


Arguments


Return Value
    NO_ERROR

--*/
{
    NDIS_STATUS     status;
    PPACKET_BLOCK   pNew;
    ULONG           ulSize;
    ULONG           ulCount;
    BOOLEAN         fOk;
    PPACKET_HEAD    pReturn;
    KIRQL           irql;

    
    fOk  = FALSE;
    pNew = NULL;

    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    do
    {
        if((pPool->ulMaxPackets) and
           (pPool->ulCurPackets >= pPool->ulMaxPackets))
        {
            //
            // No can do.  The pool was initialized with a max size and that
            // has been reached.
            //
            
            break;
        }

        //
        // Calculate the contiguous block's size and the number of packets
        // it will hold.
        //

        ulCount = pPool->ulPacketsPerBlock;
            
        if(pPool->ulMaxPackets)
        {
            if(ulCount > (pPool->ulMaxPackets - pPool->ulCurPackets))
            {
                //
                // If a max was specified, respect that
                //
                
                ulCount = pPool->ulMaxPackets - pPool->ulCurPackets;
            }
        }

        //
        // We allocate a PACKET_BLOCK to account for this block of packets
        // and one PACKET_HEAD per packet
        //
        
        ulSize = sizeof(PACKET_BLOCK) + (ulCount * sizeof(PACKET_HEAD));

        //
        // Allocate the contiguous memory block for the PACKETBLOCK header
        // and the individual PACKET_HEADs.
        //
        
        pNew = RtAllocate(NonPagedPool,
                          ulSize,
                          pPool->ulTag);

        if(!pNew)
        {
            Trace(UTIL, ERROR,
                  ("AddPacketBlockToPool: Unable to allocate %d bytes\n",
                   ulSize));
            
            break;
        }

        //
        // Zero only the block header portion.
        //
        
        NdisZeroMemory(pNew, sizeof(PACKET_BLOCK));

        //
        // Allocate a pool of NDIS_PACKET descriptors.
        //
        
        NdisAllocatePacketPool(&status,
                               &pNew->nhNdisPool,
                               ulCount,
                               pPool->ulProtocolReservedLength);

        if(status isnot NDIS_STATUS_SUCCESS)
        {
            Trace(UTIL, ERROR,
                  ("AddPacketBlockToPool: Unable to allocate packet pool for %d packets\n",
                   ulCount));
            
            break;
        }

        //
        // Fill in the back pointer to the pool.
        //
        
        pNew->pPool = pPool;

        //
        // Link the new block.  At this point, all the packets are
        // effectively "in use".  They are made available in the loop
        // below.
        //
        
        pNew->ulPackets      = ulCount;
        pPool->ulCurPackets += ulCount;
        
        InsertHeadList(&(pPool->leBlockHead),
                       &(pNew->leBlockLink));
        
        fOk = TRUE;
        
    }while(FALSE);

    RtReleaseSpinLock(&pPool->rlLock,
                      irql);

    if(!fOk)
    {
        //
        // Bailing, undo whatever succeeded.
        //
        
        if(pNew)
        {
            RtFree(pNew);
            
            if(pNew->nhNdisPool)
            {
                NdisFreePacketPool(pNew->nhNdisPool);
            }
        }

        return NULL;
    }

    //
    // Initialize each individual packet header and add it to the list of free
    // packets.
    //
    
    {
        ULONG i;
        PPACKET_HEAD pHead;

        pReturn = NULL;

        //
        // For each PACKET_HEAD of the block...
        //
        
        for(i = 0, pHead = (PPACKET_HEAD)(pNew + 1);
            i < ulCount;
            i++, pHead++)
        {
            InitializeListHead(&pHead->leFreePktLink);
            
            pHead->pBlock       = pNew;
            pHead->pNdisPacket  = NULL;

            //
            // Associate an NDIS_PACKET descriptor from the pool we
            // allocated above.
            //
            
            NdisAllocatePacket(&status,
                               &pHead->pNdisPacket,
                               pNew->nhNdisPool);

            if(status isnot NDIS_STATUS_SUCCESS)
            {
                continue;
            }

            if(pReturn)
            {
                //
                // Add the constructed packet to the list of free packets.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                
                FreePacketToPool(pPool,
                                 pHead,
                                 FALSE);
            }
            else
            {
                //
                // The first successfully constructed packet is returned by
                // this routine.
                //
                
                pReturn = pHead;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedPacketPoolBlocks(
    IN PPACKET_POOL pPool
    )
/*++
Routine Description

    Check if any of the blocks in pool are not in use, and if so, free them.
    
Locks

    Caller must hold the pool lock

    NOTE: The MSDN doc says that no locks may be held while calling
    NdisFreePacketXxx, but according to JameelH that is incorrect.
    
Arguments

    pPool   Pointer to pool
    
Return Value

    None

--*/
{
    PLIST_ENTRY pleNode;

    //
    // For each block in the pool...
    //
    
    pleNode = pPool->leBlockHead.Flink;
    
    while(pleNode isnot &(pPool->leBlockHead))
    {
        PLIST_ENTRY     pleNextNode;
        PPACKET_BLOCK   pBlock;

        pleNextNode = pleNode->Flink;

        pBlock = CONTAINING_RECORD(pleNode, PACKET_BLOCK, leBlockLink);
        
        if(pBlock->ulFreePackets >= pBlock->ulPackets)
        {
            ULONG        i;
            PPACKET_HEAD pHead;

            //
            // Found a block with no packets in use.  Walk the packet block
            // removing each packet from the pool's free list and freeing any
            // associated NDIS_PACKET descriptor.
            //
            
            for(i = 0, pHead = (PPACKET_HEAD)(pBlock + 1);
                i < pBlock->ulPackets;
                i++, pHead++)
            {
                RemoveEntryList(&(pHead->leFreePktLink));

                if(pHead->pNdisPacket)
                {
                    NdisFreePacket(pHead->pNdisPacket);
                }
            }

            //
            // Remove and release the unused block.
            //
            
            RemoveEntryList(pleNode);
            
            pPool->ulCurPackets -= pBlock->ulPackets;

            if(pBlock->nhNdisPool)
            {
                NdisFreePacketPool(pBlock->nhNdisPool);
            }

            RtFree(pBlock);
        }

        pleNode = pleNextNode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\ipxrtprt.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    routprot.h

Abstract:
    Include file for Routing Protocol inteface to Router Managers

--*/

#ifndef __ROUTING_ROUTPROT_H__
#define __ROUTING_ROUTPROT_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include "stm.h"

#pragma warning(disable:4201)

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Supported functionality flags                                            //
//                                                                          //
// ROUTING 		            Imports Routing Table Manager APIs              //
// SERVICES		            Exports Service Table Manager APIs              //
// DEMAND_UPDATE_ROUTES     IP and IPX RIP support for Autostatic           //
// DEMAND_UPDATE_SERVICES   IPX SAP, NLSP support for Autostatic            //
// PROMISCUOUS_ADD_IF       Adds all interfaces, even if no info is present //
// MULTICAST                Supports multicast                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define ROUTING 		        0x00000001
#define DEMAND_UPDATE_ROUTES    0x00000004

#if MPR40
#define MS_ROUTER_VERSION       0x00000400
#else
    #if MPR50
    #define MS_ROUTER_VERSION       0x00000500
    #else
    #error Router version not defined
    #endif
#endif

typedef enum _ROUTING_PROTOCOL_EVENTS
{
    ROUTER_STOPPED,              // Result is empty
    SAVE_GLOBAL_CONFIG_INFO,     // Result is empty
    SAVE_INTERFACE_CONFIG_INFO,  // Result is interface index
                                 // for which config info is to be saved.
    UPDATE_COMPLETE,             // Result is UPDATE_COMPLETE_MESSAGE structure
}ROUTING_PROTOCOL_EVENTS;


typedef enum _NET_INTERFACE_TYPE
{
    PERMANENT,
    DEMAND_DIAL,
    LOCAL_WORKSTATION_DIAL,
    REMOTE_WORKSTATION_DIAL
} NET_INTERFACE_TYPE;

typedef struct _SUPPORT_FUNCTIONS
{
    //
    // Function called by routing protocol to initiate demand dial connection
    //

    OUT DWORD
    (WINAPI *DemandDialRequest)(
        IN      DWORD           ProtocolId,
        IN      DWORD           InterfaceIndex
        ) ;

    //
    // The following entrypoints are provided as a way for getting
    // information that spans components
    //

    OUT DWORD
    (WINAPI *MIBEntryCreate)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryDelete)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntrySet)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGet)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry );

    OUT DWORD
    (WINAPI *MIBEntryGetFirst)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGetNext)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

} SUPPORT_FUNCTIONS, *PSUPPORT_FUNCTIONS ;


//
// All IPX Protocols must use the protocol ids defined in the range below.
// Protocols not identified below can use any unassigned number greater than
// IPX_PROTOCOL_BASE.
//

#define IPX_PROTOCOL_BASE   0x0001ffff
#define IPX_PROTOCOL_RIP    IPX_PROTOCOL_BASE + 1
#define IPX_PROTOCOL_SAP    IPX_PROTOCOL_BASE + 2
#define IPX_PROTOCOL_NLSP   IPX_PROTOCOL_BASE + 3

typedef struct _UPDATE_COMPLETE_MESSAGE
{
    ULONG	InterfaceIndex;
    ULONG	UpdateType;	       // DEMAND_UPDATE_ROUTES, DEMAND_UPDATE_SERVICES
    ULONG	UpdateStatus;	   // NO_ERROR if successfull

}   UPDATE_COMPLETE_MESSAGE, *PUPDATE_COMPLETE_MESSAGE;

//
//  Message returned in Result parameter to GET_EVENT_MESSAGE api call.
//  UpdateCompleteMessage   returned for UPDATE_COMPLETE message
//  InterfaceIndex          returned for SAVE_INTERFACE_CONFIG_INFO message
//

typedef union _MESSAGE
{
    UPDATE_COMPLETE_MESSAGE UpdateCompleteMessage;
    DWORD                   InterfaceIndex;

}   MESSAGE, *PMESSAGE;

//
//     IPX Adapter Binding Info - Used in ActivateInterface
//

typedef struct	IPX_ADAPTER_BINDING_INFO
{
    ULONG	AdapterIndex;
    UCHAR	Network[4];
    UCHAR	LocalNode[6];
    UCHAR	RemoteNode[6];
    ULONG	MaxPacketSize;
    ULONG	LinkSpeed;

}IPX_ADAPTER_BINDING_INFO, *PIPX_ADAPTER_BINDING_INFO;

//
//  Protocol Start/Stop Entry Points
//


typedef
DWORD
(WINAPI * PSTART_PROTOCOL) (
    IN HANDLE 	            NotificationEvent,
    IN PSUPPORT_FUNCTIONS   SupportFunctions,
    IN LPVOID               GlobalInfo
    );

typedef
DWORD
(WINAPI * PSTOP_PROTOCOL) (
    VOID
    );

typedef
DWORD
(WINAPI * PADD_INTERFACE) (
    IN LPWSTR               InterfaceName,
    IN ULONG	            InterfaceIndex,
    IN NET_INTERFACE_TYPE   InterfaceType,
    IN PVOID	            InterfaceInfo
    );

typedef
DWORD
(WINAPI * PDELETE_INTERFACE) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PGET_EVENT_MESSAGE) (
    OUT ROUTING_PROTOCOL_EVENTS  *Event,
    OUT MESSAGE                  *Result
    );

typedef
DWORD
(WINAPI * PGET_INTERFACE_INFO) (
    IN      ULONG	InterfaceIndex,
    IN      PVOID   InterfaceInfo,
    IN OUT PULONG	InterfaceInfoSize
    );

typedef
DWORD
(WINAPI * PSET_INTERFACE_INFO) (
    IN ULONG	InterfaceIndex,
    IN PVOID	InterfaceInfo
    );

typedef
DWORD
(WINAPI * PBIND_INTERFACE) (
    IN ULONG	InterfaceIndex,
    IN PVOID	BindingInfo
    ) ;

typedef
DWORD
(WINAPI * PUNBIND_INTERFACE) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PENABLE_INTERFACE) (
    IN ULONG	InterfaceIndex
    ) ;

typedef
DWORD
(WINAPI * PDISABLE_INTERFACE) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PGET_GLOBAL_INFO) (
    IN     PVOID 	GlobalInfo,
    IN OUT PULONG   GlobalInfoSize
    );

typedef
DWORD
(WINAPI * PSET_GLOBAL_INFO) (
    IN PVOID 	GlobalInfo
    );

typedef
DWORD
(WINAPI * PDO_UPDATE_ROUTES) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PMIB_CREATE) (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    );

typedef
DWORD
(WINAPI * PMIB_DELETE) (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    );

typedef
DWORD
(WINAPI * PMIB_GET) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG	OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_SET) (
    IN ULONG 	InputDataSize,
    IN PVOID	InputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_FIRST) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID   OutputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_NEXT) (
    IN  ULONG   InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_SET_TRAP_INFO) (
    IN  HANDLE  Event,
    IN  ULONG   InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG	OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_TRAP_INFO) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID	OutputData
    );

//
// NT5.0 additions
//

typedef
DWORD
(WINAPI *PCONNECT_CLIENT) (
    IN ULONG    InterfaceIndex,
    IN PVOID    ClientAddress
    );

typedef
DWORD
(WINAPI *PDISCONNECT_CLIENT) (
    IN ULONG    InterfaceIndex,
    IN PVOID    ClientAddress
    );

//
// InterfaceFlags used with the GetNeighbors() call below
//

#define MRINFO_TUNNEL_FLAG   0x01
#define MRINFO_PIM_FLAG      0x04
#define MRINFO_DOWN_FLAG     0x10
#define MRINFO_DISABLED_FLAG 0x20
#define MRINFO_QUERIER_FLAG  0x40
#define MRINFO_LEAF_FLAG     0x80

typedef
DWORD
(WINAPI *PGET_NEIGHBORS) (
    IN     DWORD  InterfaceIndex,
    IN     PDWORD NeighborList,
    IN OUT PDWORD NeighborListSize,
       OUT PBYTE  InterfaceFlags
    );

//
// StatusCode values used with the GetMfeStatus() call below.
// The protocol should return the highest-valued one that applies.
//

#define MFE_NO_ERROR          0 // none of the below events
#define MFE_REACHED_CORE      1 // this router is an RP/core for the group

//
// StatusCode values set by oif owner only
//

#define MFE_OIF_PRUNED        5 // no downstream receivers exist on oif

//
// StatusCode values set by iif owner only
//

#define MFE_PRUNED_UPSTREAM   4 // a prune was send upstream
#define MFE_OLD_ROUTER       11 // upstream nbr doesn't support mtrace

//
// StatusCode values which are used only by the Router Manager itself:
//

#define MFE_NOT_FORWARDING    2 // not fwding for an unspecified reason
#define MFE_WRONG_IF          3 // mtrace received on iif
#define MFE_BOUNDARY_REACHED  6 // iif or oif is admin scope boundary
#define MFE_NO_MULTICAST      7 // oif is not multicast-enabled
#define MFE_IIF               8 // mtrace arrived on iif
#define MFE_NO_ROUTE          9 // router has no route that matches
#define MFE_NOT_LAST_HOP     10 // router is not the proper last-hop router
#define MFE_PROHIBITED       12 // mtrace is administratively prohibited
#define MFE_NO_SPACE         13 // not enough room in packet

typedef
DWORD
(WINAPI *PGET_MFE_STATUS) (
    IN     DWORD  InterfaceIndex,
    IN     DWORD  GroupAddress,
    IN     DWORD  SourceAddress,
    OUT    PBYTE  StatusCode
    );

//
// This is the structure passed between the router manager
// and a registering protocol.
//
// IN OUT DWORD dwVersion
// This is filled by the router manager to indicate the version it supports.
// The DLL MUST set this to the version that the protocol will support.
//
// IN DWORD dwProtocolId
// This the protocol the router manager is expecting the DLL to register.
// If the DLL does not support this protocol, it MUST return
// ERROR_NOT_SUPPORTED
// A DLL will be called once for every protocol it supports
//
// IN OUT DWORD fSupportedFunctionality
// These are the flags denoting the functionality the router manager
// supports. The DLL MUST reset this to the functionality that it
// supports
//


typedef struct _MPR40_ROUTING_CHARACTERISTICS
{
    DWORD               dwVersion;
    DWORD               dwProtocolId;
    DWORD               fSupportedFunctionality;
    PSTART_PROTOCOL     pfnStartProtocol;
    PSTOP_PROTOCOL      pfnStopProtocol;
    PADD_INTERFACE      pfnAddInterface;
    PDELETE_INTERFACE   pfnDeleteInterface;
    PGET_EVENT_MESSAGE  pfnGetEventMessage;
    PGET_INTERFACE_INFO pfnGetInterfaceInfo;
    PSET_INTERFACE_INFO pfnSetInterfaceInfo;
    PBIND_INTERFACE     pfnBindInterface;
    PUNBIND_INTERFACE   pfnUnbindInterface;
    PENABLE_INTERFACE   pfnEnableInterface;
    PDISABLE_INTERFACE  pfnDisableInterface;
    PGET_GLOBAL_INFO    pfnGetGlobalInfo;
    PSET_GLOBAL_INFO    pfnSetGlobalInfo;
    PDO_UPDATE_ROUTES   pfnUpdateRoutes;
    PMIB_CREATE         pfnMibCreateEntry;
    PMIB_DELETE         pfnMibDeleteEntry;
    PMIB_GET            pfnMibGetEntry;
    PMIB_SET            pfnMibSetEntry;
    PMIB_GET_FIRST      pfnMibGetFirstEntry;
    PMIB_GET_NEXT       pfnMibGetNextEntry;
    PMIB_SET_TRAP_INFO  pfnMibSetTrapInfo;
    PMIB_GET_TRAP_INFO  pfnMibGetTrapInfo;
}MPR40_ROUTING_CHARACTERISTICS;

typedef struct _MPR50_ROUTING_CHARACTERISTICS
{

#ifdef __cplusplus
    MPR40_ROUTING_CHARACTERISTICS   mrcMpr40Chars;
#else
    MPR40_ROUTING_CHARACTERISTICS;
#endif

    PCONNECT_CLIENT                 pfnConnectClient;
    PDISCONNECT_CLIENT              pfnDisconnectClient;
    PGET_NEIGHBORS                  pfnGetNeighbors;
    PGET_MFE_STATUS                 pfnGetMfeStatus;

}MPR50_ROUTING_CHARACTERISTICS;

#if MPR50
typedef MPR50_ROUTING_CHARACTERISTICS MPR_ROUTING_CHARACTERISTICS;
#else
    #if MPR40
    typedef MPR40_ROUTING_CHARACTERISTICS MPR_ROUTING_CHARACTERISTICS;
    #endif
#endif

typedef MPR_ROUTING_CHARACTERISTICS *PMPR_ROUTING_CHARACTERISTICS;


//
// All routing protocols must export the following entry point.
// The router manager calls this function to allow the routing
// protocol to register
//

#define REGISTER_PROTOCOL_ENTRY_POINT           RegisterProtocol
#define REGISTER_PROTOCOL_ENTRY_POINT_STRING    "RegisterProtocol"

typedef
DWORD
(WINAPI * PREGISTER_PROTOCOL) (
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );


#ifdef __cplusplus
}
#endif

#pragma warning(default:4201)

#endif //__ROUTING_ROUTPROT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\priopriv.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\inc\priopriv.h


Abstract:
    Header defining interface to Routing Protocol Priority DLL.

Revision History:

    Gurdeep Singh Pall		7/19/95	Created

--*/

#ifndef __PRIOPRIV_H__
#define __PRIOPRIV_H__


//
// Prototypes
//

DWORD
SetPriorityInfo(
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    );

DWORD
GetPriorityInfo(
    IN  PVOID   pvBuffer,
    OUT PDWORD  pdwBufferSize
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\rasclient_strsafe.h ===
//+----------------------------------------------------------------------------
//
// File:     rasclient_strsafe.h
//
// Synopsis: Includes strsafe.h from sdk\inc as well as adding other common RAS
//           string related items like Macros
//
// Copyright (c) 2002 Microsoft Corporation
//
// Author:   quintinb  Created    02/05/2002
//
//+----------------------------------------------------------------------------

#ifndef _RASCLIENT_STRSAFE_INCLUDED_
#define _RASCLIENT_STRSAFE_INCLUDED_
#pragma once

#if DEBUG && defined(CMASSERTMSG)
#define CELEMS(x)   (                           \
                        CMASSERTMSG(sizeof(x) != sizeof(void*), TEXT("possible incorrect usage of CELEMS")), \
                        (sizeof(x))/(sizeof(x[0])) \
                    )
#else
#define CELEMS(x) ((sizeof(x))/(sizeof(x[0])))
#endif // DEBUG

#include <strsafe.h>

#define NULL_OKAY 0x1
#define EMPTY_STRING_OKAY 0x2

//+----------------------------------------------------------------------------
//
// Function:  IsBadInputStringW
//
// Synopsis:  Function to check if a given input string is a "good" string.
//            The function is basically a wrapper for IsBadStringPtr but
//            depending on what flags are passed to the function it will accept
//            NULL string pointers (c_dwNullOkay), or empty strings (c_dwEmptyStringOkay).
//            Note that we also require the string to be NULL terminated within
//            the size given.
//
// Arguments: pszString - String pointer to check
//            cchStringSizeToCheck - number of TCHARS to check in the input string (this will often be estimated)
//            dwCheckFlags - Flags to control what checking to do on the string or
//                           what is an acceptable good string.  Current list:
//                              NULL_OKAY -- allows NULL pointers to be "okay"
//                              EMPTY_STRING_OKAY -- allows the empty string ("") 
//                                                     to be "okay"
//
// Returns:   BOOL - TRUE if the given pointer is bad
//                   FALSE if the pointer passes all checks
//
// History:   quintinb    Created       02/18/02
//
//+----------------------------------------------------------------------------
__inline BOOL __stdcall IsBadInputStringW(LPCWSTR pszString, UINT cchStringSizeToCheck, DWORD dwCheckFlags)
{
    BOOL bReturn = TRUE; // assume the worst, a bad input string

    //
    //  First check the pointer to see if it is NULL or not
    //
    if (pszString)
    {
        //
        //  No point in having us check 0 characters in the string...
        //
        if (cchStringSizeToCheck)
        {
            //
            //  Okay, now let's check to see if the string is readable.
            //  Note that IsBadStringPtr will stop checking the string
            //  when it has examined the number of bytes passed in or
            //  when it hits a terminating NULL char, whichever it hits
            //  first.
            //
            if (!IsBadStringPtrW(pszString, cchStringSizeToCheck*sizeof(WCHAR)))
            {
                //
                //  Okay, it's readable.  Let's check to see if it is NULL terminated
                //  within cchStringSizeToCheck, if not then we consider it a bad string.
                //

                if(SUCCEEDED(StringCchLengthW((LPWSTR)pszString, cchStringSizeToCheck, NULL))) //Note we actually don't care how long the string is...
                {
                    //
                    //  Finally, check to see if the string is the empty string
                    //
                    BOOL bEmptyString = (L'\0' == pszString[0]);
                    BOOL bEmptyStringOkay = (EMPTY_STRING_OKAY == (dwCheckFlags & EMPTY_STRING_OKAY));

                    if ((bEmptyString && bEmptyStringOkay) || !bEmptyString)
                    {
                        bReturn = FALSE;
                    }            
                }
            }
        }
    }
    else
    {
        bReturn = (NULL_OKAY != (dwCheckFlags & NULL_OKAY)); // If NULL and NULL is okay, return FALSE.
    }

    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  IsBadInputStringA
//
// Synopsis:  Function to check if a given input string is a "good" string.
//            The function is basically a wrapper for IsBadStringPtr but
//            depending on what flags are passed to the function it will accept
//            NULL string pointers (c_dwNullOkay), or empty strings (c_dwEmptyStringOkay).
//            Note that we also require the string to be NULL terminated within
//            the size given.
//
// Arguments: pszString - String pointer to check
//            cchStringSizeToCheck - number of TCHARS to check in the input string (this will often be estimated)
//            dwCheckFlags - Flags to control what checking to do on the string or
//                           what is an acceptable good string.  Current list:
//                              NULL_OKAY -- allows NULL pointers to be "okay"
//                              EMPTY_STRING_OKAY -- allows the empty string ("") 
//                                                     to be "okay"
//
// Returns:   BOOL - TRUE if the given pointer is bad
//                   FALSE if the pointer passes all checks
//
// History:   quintinb    Created       02/18/02
//
//+----------------------------------------------------------------------------
__inline BOOL __stdcall IsBadInputStringA(LPCSTR pszString, UINT cchStringSizeToCheck, DWORD dwCheckFlags)
{
    BOOL bReturn = TRUE; // assume the worst, a bad input string

    //
    //  First check the pointer to see if it is NULL or not
    //
    if (pszString)
    {
        //
        //  No point in having us check 0 characters in the string...
        //
        if (cchStringSizeToCheck)
        {
            //
            //  Okay, now let's check to see if the string is readable.
            //  Note that IsBadStringPtr will stop checking the string
            //  when it has examined the number of bytes passed in or
            //  when it hits a terminating NULL char, whichever it hits
            //  first.
            //
            if (!IsBadStringPtrA(pszString, cchStringSizeToCheck*sizeof(CHAR)))
            {
                //
                //  Okay, it's readable.  Let's check to see if it is NULL terminated
                //  within cchStringSizeToCheck, if not then we consider it a bad string.
                //

                if(SUCCEEDED(StringCchLengthA((LPSTR)pszString, cchStringSizeToCheck, NULL))) //Note we actually don't care how long the string is...
                {
                    //
                    //  Finally, check to see if the string is the empty string
                    //
                    BOOL bEmptyString = ('\0' == pszString[0]);
                    BOOL bEmptyStringOkay = (EMPTY_STRING_OKAY == (dwCheckFlags & EMPTY_STRING_OKAY));

                    if ((bEmptyString && bEmptyStringOkay) || !bEmptyString)
                    {
                        bReturn = FALSE;
                    }            
                }
            }
        }
    }
    else
    {
        bReturn = (NULL_OKAY != (dwCheckFlags & NULL_OKAY)); // If NULL and NULL is okay, return FALSE.
    }

    return bReturn;
}


#ifdef UNICODE
#define IsBadInputString IsBadInputStringW
#else
#define IsBadInputString IsBadInputStringA
#endif

#endif // _RASCLIENT_STRSAFE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\rtmcnfg.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmcnfg.h

Abstract:
    Configuration Information for RTMv2 DLL

Author:
    Chaitanya Kodeboyina (chaitk) 17-Aug-1998

Revision History:

--*/

#ifndef __ROUTING_RTMCNFG_H__
#define __ROUTING_RTMCNFG_H__

#ifdef __cplusplus
extern "C" 
{
#endif


//
// RTM Config Information for an RTM instance
//

typedef struct _RTM_INSTANCE_CONFIG
{
    ULONG          DummyConfig;         // Nothing in the config at present
}
RTM_INSTANCE_CONFIG, *PRTM_INSTANCE_CONFIG;


//
// RTM Config Information for an address family
//

typedef struct _RTM_ADDRESS_FAMILY_CONFIG
{
    UINT           AddressSize;          // Address size in this address family

    RTM_VIEW_SET   ViewsSupported;       // Views supported by this addr family

    UINT           MaxOpaqueInfoPtrs;    // Number of opaque ptr slots in dest

    UINT           MaxNextHopsInRoute;   // Max. number of equal cost next-hops

    UINT           MaxHandlesInEnum;     // Max. number of handles returned in
                                         // any RTMv2 call that returns handles

    UINT           MaxChangeNotifyRegns; // Max. number of change notification 
                                         // registrations at any single instant
} 
RTM_ADDRESS_FAMILY_CONFIG, *PRTM_ADDRESS_FAMILY_CONFIG;



//
// Functions to read and write RTM configuration information
//

DWORD
RtmWriteDefaultConfig (
    IN      USHORT                          RtmInstanceId
    );


DWORD
WINAPI
RtmReadInstanceConfig (
    IN      USHORT                          RtmInstanceId,
    OUT     PRTM_INSTANCE_CONFIG            InstanceConfig
    );

DWORD
WINAPI
RtmWriteInstanceConfig (
    IN      USHORT                          RtmInstanceId,
    IN      PRTM_INSTANCE_CONFIG            InstanceConfig
    );


DWORD
WINAPI
RtmReadAddressFamilyConfig (
    IN      USHORT                          RtmInstanceId,
    IN      USHORT                          AddressFamily,
    OUT     PRTM_ADDRESS_FAMILY_CONFIG      AddrFamilyConfig
    );

DWORD
WINAPI
RtmWriteAddressFamilyConfig (
    IN      USHORT                          RtmInstanceId,
    IN      USHORT                          AddressFamily,
    IN      PRTM_ADDRESS_FAMILY_CONFIG      AddrFamilyConfig
    );


#ifdef __cplusplus
}
#endif

#endif //__ROUTING_RTMCNFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\rmrtm.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routing\inc\rtm.h

Abstract:
	Router Manager private interface for Routing Table Manager DLL


Author:

	Vadim Eydelman

Revision History:

--*/

#ifndef _ROUTING_RMRTM
#define _ROUTING_RMRTM

// Two protocol families are currently supported (IP, IPX)
// It should be enough to modify this constant to support additional
// protocol families (from the RTM's point of view). Up to 256 families
// can be supported (if somebody needs more (???!!!), the next constant should
// be modified to free more low order bits for use by protocol family constants)
//
// Changed the number of protocol families from 2
// to 1 (as we support only IPX). IP and other
// future address families are supported by RTMv2.
//
#define RTM_NUM_OF_PROTOCOL_FAMILIES		1

// Tag that rtm ors in Protocol Family field of the handles it
// exports to clients for validation purposes
#define RTM_CLIENT_HANDLE_TAG			('RTM'<<8)

/*++
*******************************************************************

	N E T W O R K _ N U M B E R _ C M P _ F U N C

Routine Description:
	Compares two network numbers and returns result that can be used for
	route sorting
Arguments:
	Net1,Net2	- pointers to protocol family dependent network number structures
					to be compared
Return Value:
	<0 - Net2 follows Net1 
	>0 - Net1 follows Net2
	=0 - Net1==Net2

*******************************************************************
--*/
typedef 
INT
(*PNETWORK_NUMBER_CMP_FUNC) (
	PVOID			Net1,
	PVOID			Net2
	);

/*++
*******************************************************************

	N E X T _ H O P _ A D D R E S S _ C M P _ F U N C

Routine Description:
	Compares next hop addresses of two routes and returns result that can be used for
	route sorting
Arguments:
	Route1,Route2	- pointers to protocol family dependent route structures whose
						next hop addresses are to be compared
Return Value:
	<0 - Route2 should follow Route1 if sorted by next hop address
	>0 - Route1 should follow Route2 if sorted by next hop address
	=0 - Route1 has same next hop address as Route2

*******************************************************************
--*/
typedef 
INT
(*PNEXT_HOP_ADDRESS_CMP_FUNC) (
	PVOID			Route1,
	PVOID			Route2
	);

/*++
*******************************************************************

	F A M I L Y _ S P E C I F I C _ D A T A _ C M P _ F U N C

Routine Description:
	Compares family specific data fields of two routes and returns if
	the are equal
Arguments:
	Route1,Route2	- pointers to protocol family dependent route structures whose
						protocol family specific data fields are to be compared
Return Value:
	TRUE	 - protocol family specific data fields of Route1 and Route2 are
				equivalent
	FALSE	 - protocol family specific data fields of Route1 and Route2 are
				different

*******************************************************************
--*/
typedef 
BOOL
(*PFAMILY_SPECIFIC_DATA_CMP_FUNC) (
	PVOID			Route1,
	PVOID			Route2
	);

/*++
*******************************************************************

		R O U T E _ M E T R I C _ C M P _ F U N C

Routine Description:
	Compares two routes and returns result that identifies the
	better route
Arguments:
	Route1,Route2	- pointers to protocol family dependent route structures whose
						parameters are to be compared
Return Value:
	<0 - Route1 is better than Route2
	>0 - Route2 is better than Route1
	=0 - Route1 is as good as Route2

*******************************************************************
--*/
typedef 
INT
(*PROUTE_METRIC_CMP_FUNC) (
	PVOID			Route1,
	PVOID			Route2
	);


/*++
*******************************************************************

	R O U T E _ H A S H _ F U N C

Routine Description:
	Retuns value that can be used for route hashing by network number
Arguments:
	Net -	network number to be used for hashing
Return Value:
	Hash value

*******************************************************************
--*/
typedef 
INT
(*PROUTE_HASH_FUNC) (
	PVOID			Net
	);

/*++
*******************************************************************

	R O U T E _ V A L I D A T E _ F U N C

Routine Description:
	Validates the data in the route structure and possibly updates
	some of them.  This routine is called each time the new route
	is added to tha table or any of parameters of an existing route
	changes
Arguments:
	Route -	pointer to protocol family dependent route structure to
			be validated
Return Value:
	NO_ERROR - route was successfully validated
	ERROR_INVALID_PARAMETER - route structure is invalid, RTM will reject
		client's request to add or change the route

*******************************************************************
--*/
typedef 
DWORD
(*PROUTE_VALIDATE_FUNC) (
	PVOID			Route
	);

/*++
*******************************************************************

	R O U T E _ C H A N G E _ C A L L B A C K

Routine Description:
	Gets called whenever the best route to some desination network changes
	(intended to be used by the protocol family manager to notify kernel mode
	forwarders of route changes)
Arguments:
	Flags - identifies what kind of change caused the call and what
			information is provided in the route buffers:
		RTM_ROUTE_ADDED - first route was added for a destination network,
							CurBestRoute is contains added route info
		RTM_ROUTE_DELETED - the only route available for a destination
							network was deleted, PrevBestRoute contains deleted
							route info
		RTM_ROUTE_CHANGED - there was a change in any of the following
							parameters of the BEST route to a destination
							network:
								RoutingProtocol,
								InterfaceID,
								Metric,
								NextHopAddress,
								FamilySpecificData.
							PrevBestRoute contains the route info as it was
							before the change, CurBestRoute contains current
							best route info.
				Note that the route change message can be generated
				both as result of protocol adding/deleting the route
				that becomes/was the best and changing best route parameters
				such that the route becomes/no longer is the best route.
	CurBestRoute - current best route info (if any)
	PrevBestRoute - previous best route info (if any)
	
Return Value:
	None
*******************************************************************
--*/
typedef 
VOID
(*PROUTE_CHANGE_CALLBACK) (
	DWORD			Flags,
	PVOID			CurBestRoute,
	PVOID			PrevBestRoute
	);


typedef struct _RTM_PROTOCOL_FAMILY_CONFIG {
	ULONG							RPFC_MaxTableSize;	// Size of address space reserved
														// for the table
	INT								RPFC_HashSize;		// Size of hash table
	INT								RPFC_RouteSize;		// Size of route structure
	PNETWORK_NUMBER_CMP_FUNC 		RPFC_NNcmp;
	PNEXT_HOP_ADDRESS_CMP_FUNC		RPFC_NHAcmp;
	PFAMILY_SPECIFIC_DATA_CMP_FUNC	RPFC_FSDcmp;
	PROUTE_METRIC_CMP_FUNC			RPFC_RMcmp;
	PROUTE_HASH_FUNC				RPFC_Hash;
	PROUTE_VALIDATE_FUNC			RPFC_Validate;
	PROUTE_CHANGE_CALLBACK			RPFC_Change;
	} RTM_PROTOCOL_FAMILY_CONFIG, *PRTM_PROTOCOL_FAMILY_CONFIG;


/*++
*******************************************************************

	R t m C r e a t e R o u t e T a b l e

Routine Description:
	Create route table for protocol family
Arguments:
	ProtocolFamily - index that identifies protocol family
	Config - protocol family table configuration parameters
Return Value:
	NO_ERROR - table was created ok
	ERROR_INVALID_PARAMETER - protocol family is out of range supported by the RTM
	ERROR_ALREDY_EXISTS - protocol family table already exists
	ERROR_NOT_ENOUGH_MEMORY - could not allocate memory to perform
						the operation
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD
RtmCreateRouteTable (
	IN DWORD							ProtocolFamily,
	IN PRTM_PROTOCOL_FAMILY_CONFIG		Config
	);


/*++
*******************************************************************

	R t m D e l e t e R o u t e T a b l e

Routine Description:
	Dispose of all resources allocated for the route table
Arguments:
	ProtocolFamily - index that identifies protocol family
Return Value:
	NO_ERROR - table was deleted ok
	ERROR_INVALID_PARAMETER - no table to delete

*******************************************************************
--*/
DWORD
RtmDeleteRouteTable (
	DWORD		ProtocolFamily
	);


/*++
*******************************************************************

	R t m B l o c k S e t R o u t e E n a b l e

Routine Description:
	Disables/Reenables all routes in subset specified by enumeration
	flags and corresponding criteria.  This operation can only be performed
	by the registered client and applies only to routes added by this
	client.
	Route change messages will be generated for disabled/reenabled routes that
	were/became the best.
	Disabled routes are invisible for route queries, but could still be 
	maintained by the RTM itself or routing protocol handler that added
	these routes (add, delete, and aging mechanisms still apply)
Arguments:
	ClientHandle - handle that identifies the client and routing protocol
						of routes to be disabled/reenabled
	EnumerationFlags - further limit subset of routes being enabled to only
						those that have same values in the fields
						specified by the flags as in CriteriaRoute
		Note that only RTM_ONLY_THIS_NETWORK and RTM_ONLY_THIS_INTERFACE
		can be used (RTM_ONLY_BEST_ROUTES does not apply because best
		route designation is adjusted as routes are enabled/disabled and
		all routes will be affected anyway)
	CriteriaRoute - protocol family dependent structure (RTM_??_ROUTE) with
					set values in fields that correspond to EnumerationFlags
	Enable - FALSE: disable, TRUE: reenable
Return Value:
	NO_ERROR - routes were disabled/reenabled ok
	ERROR_NO_ROUTES - no routes exist that match specified criteria
	ERROR_INVALID_HANDLE - client handle is not a valid RTM handle
	ERROR_NOT_ENOUGH_MEMORY - could not allocate memory to perform
						the operation
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later

*******************************************************************
--*/
DWORD WINAPI
RtmBlockSetRouteEnable (
	IN HANDLE		ClientHandle,
	IN DWORD		EnumerationFlags,
	IN PVOID		CriteriaRoute,
	IN BOOL			Enable
	);
	
#define RtmBlockDisableRoutes(Handle,Flags,CriteriaRoute)	\
		RtmBlockSetRouteEnable(Handle,Flags,CriteriaRoute,FALSE)
#define RtmBlockReenableRoutes(Handle,Flags,CriteriaRoute)	\
		RtmBlockSetRouteEnable(Handle,Flags,CriteriaRoute,TRUE)


// Use this flags in enumeration methods to enumerate disabled routes
#define RTM_INCLUDE_DISABLED_ROUTES		0x40000000

/*++
*******************************************************************

	R t m B l o c k C o n v e r t R o u t e s T o S t a t i c

Routine Description:
	Converts all routes as specified by enumeration flags to routes of
	static protocol (as defined by StaticClientHandle).
	No route change messages are generated as the result of this operation.
	This functionality is normally used only by Router Manager for a specific
	protocol family
 Arguments:
	ClientHandle - handle that identifies static protocol client
	EnumerationFlags - limit subset of routes being converted to only
						those that have same values in the fields
						specified by the flags as in CriteriaRoute
	CriteriaRoute - protocol family dependent structure (RTM_??_ROUTE) with
					set values in fields that correspond to EnumerationFlags
Return Value:
	NO_ERROR - routes were converted ok
	ERROR_NO_ROUTES - no routes exist that match specified criteria
	ERROR_INVALID_HANDLE - client handle is not a valid RTM handle
	ERROR_NOT_ENOUGH_MEMORY - could not allocate memory to perform
						the operation
	ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
							try again later
*******************************************************************
--*/
DWORD WINAPI
RtmBlockConvertRoutesToStatic (
	IN HANDLE		ClientHandle,
	IN DWORD		EnumerationFlags,
	IN PVOID		CriteriaRoute
	);

	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\rasdiagp.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    rasdiagp.h

Abstract:

    This file contains all public data structures and defines used
    by Rasmontr.dll. These were added to expose the NetSh.exe commands
    within Rasmontr to the RAS Client Diagnostics User Interface.

Author:

    Jeff Sigman (JeffSi) September 04, 2001

Environment:

    User Mode

Revision History:

    JeffSi      09/04/01        Created

--*/

#ifndef _RASDIAGP_H_
#define _RASDIAGP_H_

//
// Valid flags for DiagGetReportFunc
//
#define RAS_DIAG_EXPORT_TO_FILE  0x00000001 // Save report to a file, return
                                            // report file name in pwszString.
                                            // No compression or file deletion.
#define RAS_DIAG_EXPORT_TO_EMAIL 0x00000002 // Attach compressed report to the
                                            // email addressed in pwszString.
                                            // Delete un-compressed report.
#define RAS_DIAG_DISPLAY_FILE    0x00000004 // Save report to a temp file name,
                                            // return file name in pwszString.
                                            // No compression or file deletion.
#define RAS_DIAG_VERBOSE_REPORT  0x00000008 // Include all reporting information
                                            // Warning, can take more than 5 min

typedef struct _GET_REPORT_STRING_CB
{
    DWORD dwPercent;
    PVOID pContext;
    PWCHAR pwszState;

} GET_REPORT_STRING_CB;

typedef DWORD (*DiagGetReportCb)(IN GET_REPORT_STRING_CB* pInfo);

typedef DWORD (*DiagInitFunc)();
typedef DWORD (*DiagUnInitFunc)();
typedef DWORD (*DiagClearAllFunc)();
typedef DWORD (*DiagGetReportFunc)(IN DWORD dwFlags,
                                   IN OUT LPCWSTR pwszString,
                                   IN OPTIONAL DiagGetReportCb pCallback,
                                   IN OPTIONAL PVOID pContext);
typedef BOOL  (*DiagGetStateFunc)();
typedef DWORD (*DiagSetAllFunc)(IN BOOL fEnable);
typedef DWORD (*DiagSetAllRasFunc)(IN BOOL fEnable);
typedef DWORD (*DiagWppTracing)();

typedef struct _RAS_DIAGNOSTIC_FUNCTIONS
{
    DiagInitFunc      Init;      // Must be called before any funcs are used
    DiagUnInitFunc    UnInit;    // Must be called when finished for cleanup
    DiagClearAllFunc  ClearAll;  // Clears all tracing logs, then enables all
    DiagGetReportFunc GetReport; // Get report based on RAS_DIAG flags
    DiagGetStateFunc  GetState;  // Returns whether all of RAS tracing is on
    DiagSetAllFunc    SetAll;    // Enables all tracing (modem, ipsec, RAS,...)
    DiagSetAllRasFunc SetAllRas; // Enables only RAS (%windir%\tracing) tracing
    DiagWppTracing    WppTrace;  // Enables any active WPP tracing sessions

} RAS_DIAGNOSTIC_FUNCTIONS;

typedef DWORD (*DiagGetDiagnosticFunctions) (OUT RAS_DIAGNOSTIC_FUNCTIONS* pFunctions);

#endif // _RASDIAGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\rasman.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  5/26/92 Gurdeep Singh Pall  Created
//
//
//  Description: This file contains all structure and constant definitions for
//       RAS Manager Component.
//
//****************************************************************************


#ifndef _RASMAN_
#define _RASMAN_

#define RASMERGE

#include <windows.h>
#include <mprapi.h>                         // defines for MAX_MEDIA_NAME, MAX_DEVICE_NAME
                                            // MAX_PORT_NAME
#include <ras.h>

#include <rpc.h>    // for RPC_BIND_HANDLE

#include <rasapip.h> // for RASEVENT

#define WM_RASAPICOMPLETE           0xCCCC  // From the "user" window msg range

#define RASMAN_SERVICE_NAME         "RASMAN"

#define MAX_USERKEY_SIZE            132

#define MAX_PARAM_KEY_SIZE          32

#define MAX_XPORT_NAME              128

#define MAX_IDENTIFIER_SIZE         32

#define MAX_STAT_NAME               32

#define MAX_CHALLENGE_SIZE          8

#define MAX_RESPONSE_SIZE           24

#define MAX_USERNAME_SIZE           UNLEN

#define MAX_DOMAIN_SIZE             DNLEN

#define MAX_PASSWORD_SIZE           PWLEN

#define MAX_LAN_NETS                16

#define MAX_PROTOCOLS_PER_PORT      4

#define MAX_DLL_NAME_SIZE           8

#define MAX_ENTRYPOINT_NAME_SIZE    32

#define MAX_ARG_STRING_SIZE         128

#define MAX_ENTRYNAME_SIZE          256

#define MAX_PHONENUMBER_SIZE        128

#define MAX_CALLBACKNUMBER_SIZE     MAX_PHONENUMBER_SIZE

#define MAX_PHONEENTRY_SIZE         (MAX_PHONENUMBER_SIZE < MAX_ENTRYNAME_SIZE \
                                    ? MAX_ENTRYNAME_SIZE                       \
                                    : MAX_PHONENUMBER_SIZE)

#define RASMAN_MAX_PROTOCOLS        32  // matches MAX_PROTOCOLS defined in wanpub.h

#define RASMAN_PROTOCOL_ADDED       1
#define RASMAN_PROTOCOL_REMOVED     2

#define INVALID_TAPI_ID             0xffffffff

//
// Defines for Ndiswan DriverCaps
//

#define RAS_NDISWAN_40BIT_ENABLED       0x00000000

#define RAS_NDISWAN_128BIT_ENABLED      0x00000001

typedef  HANDLE  HPORT ;

typedef  HANDLE  HBUNDLE ;

typedef  HANDLE  HCONN;

#define INVALID_HPORT       ((HPORT) -1)

enum RASMAN_STATUS {

    OPEN    = 0,

    CLOSED  = 1,

    UNAVAILABLE = 2,

    REMOVED = 3

}   ;

typedef enum RASMAN_STATUS  RASMAN_STATUS ;

//
// Max Total Number of dialed in clients allowed.
//
#define MAX_ALLOWED_DIALIN                  1000


#define CALL_NONE                   0x00
#define CALL_IN                     0x01
#define CALL_OUT                    0x02
#define CALL_ROUTER                 0x04
#define CALL_LOGON                  0x08
#define CALL_OUT_ONLY               0x10
#define CALL_IN_ONLY                0x20
#define CALL_OUTBOUND_ROUTER      0x40

#define CALL_DEVICE_NOT_FOUND       0x10000000

typedef DWORD RASMAN_USAGE ;

#define RASMAN_ALIGN8(_x) ((_x + 7) & (~7))
#define RASMAN_ALIGN(_x)  ((_x + sizeof(ULONG_PTR) - 1) & (~(sizeof(ULONG_PTR) - 1)))

#define RasInitializeCriticalSection(_cs, _status)  \
{                                                   \
    *_status = 0;                                   \
    try                                             \
    {                                               \
        InitializeCriticalSection(_cs);             \
    }                                               \
    except(EXCEPTION_EXECUTE_HANDLER)               \
    {                                               \
        *_status = GetExceptionCode();              \
    }                                               \
}                                                   \

enum RAS_FORMAT {

    Number      = 0,

    String      = 1

} ;

typedef enum RAS_FORMAT RAS_FORMAT ;


union RAS_VALUE {

    DWORD   Number ;

    struct  
    {
        DWORD   Length ;
        DWORD   dwAlign;
        PCHAR   Data ;
    } String ;

    struct
    {
        DWORD   Length;
        DWORD   dwAlign1;
        DWORD   dwOffset;
        DWORD   dwAlign2;
        
    } String_OffSet;
} ;

typedef union RAS_VALUE RAS_VALUE ;



enum RASMAN_STATE {

    CONNECTING  = 0,

    LISTENING   = 1,

    CONNECTED   = 2,

    DISCONNECTING   = 3,

    DISCONNECTED    = 4,

    LISTENCOMPLETED = 5,

} ;

typedef enum RASMAN_STATE   RASMAN_STATE ;

enum RASMAN_CONNECTION_STATE {

    RCS_NOT_CONNECTED = 0,

    RCS_CONNECTING,

    RCS_CONNECTED
};

typedef enum RASMAN_CONNECTION_STATE RASMAN_CONNECTION_STATE;

enum RASMAN_DISCONNECT_REASON {

    USER_REQUESTED = 0,

    REMOTE_DISCONNECTION = 1,

    HARDWARE_FAILURE = 2,

    NOT_DISCONNECTED = 3
} ;

typedef enum RASMAN_DISCONNECT_REASON   RASMAN_DISCONNECT_REASON ;


struct RAS_PARAMS {

    CHAR P_Key  [MAX_PARAM_KEY_SIZE] ;

    RAS_FORMAT P_Type ;

    BYTE P_Attributes ;

    BYTE balign[3];

    RAS_VALUE P_Value ;

} ;

typedef struct RAS_PARAMS   RAS_PARAMS ;


struct RASMAN_PORT {

    HPORT P_Handle ;

    CHAR P_PortName  [MAX_PORT_NAME] ;

    RASMAN_STATUS P_Status ;

    RASDEVICETYPE P_rdtDeviceType;

    RASMAN_USAGE P_ConfiguredUsage ;

    RASMAN_USAGE P_CurrentUsage ;

    CHAR P_MediaName [MAX_MEDIA_NAME] ;

    CHAR P_DeviceType[MAX_DEVICETYPE_NAME] ;

    CHAR P_DeviceName[MAX_DEVICE_NAME+1] ;

    DWORD P_LineDeviceId ;

    DWORD P_AddressId ;

} ;

typedef struct RASMAN_PORT  RASMAN_PORT ;

struct RASMAN_PORT_32 {

    DWORD P_Port ;

    CHAR P_PortName  [MAX_PORT_NAME] ;

    RASMAN_STATUS P_Status ;

    RASDEVICETYPE P_rdtDeviceType;

    RASMAN_USAGE P_ConfiguredUsage ;

    RASMAN_USAGE P_CurrentUsage ;

    CHAR P_MediaName [MAX_MEDIA_NAME] ;

    CHAR P_DeviceType[MAX_DEVICETYPE_NAME] ;

    CHAR P_DeviceName[MAX_DEVICE_NAME+1] ;

    DWORD P_LineDeviceId ;

    DWORD P_AddressId ;
};

typedef struct RASMAN_PORT_32 RASMAN_PORT_32;

struct RASMAN_PORT_400 {

    HPORT       P_Handle ;

    CHAR        P_PortName  [MAX_PORT_NAME] ;

    RASMAN_STATUS   P_Status ;

    RASMAN_USAGE    P_ConfiguredUsage ;

    RASMAN_USAGE    P_CurrentUsage ;

    CHAR        P_MediaName [MAX_MEDIA_NAME] ;

    CHAR        P_DeviceType[MAX_DEVICETYPE_NAME] ;

    CHAR        P_DeviceName[MAX_DEVICE_NAME+1] ;

    DWORD       P_LineDeviceId ;    // only valid for TAPI devices

    DWORD       P_AddressId ;       // only valid for TAPI devices

} ;

typedef struct RASMAN_PORT_400  RASMAN_PORT_400 ;



struct RASMAN_PORTINFO {

    DWORD   PI_NumOfParams ;

    DWORD   dwAlign;

    RAS_PARAMS  PI_Params[1] ;

} ;

typedef struct RASMAN_PORTINFO RASMAN_PORTINFO ;


struct RASMAN_DEVICE {

    CHAR    D_Name  [MAX_DEVICE_NAME+1] ;

} ;

typedef struct RASMAN_DEVICE    RASMAN_DEVICE ;


struct RASMAN_DEVICEINFO {

    DWORD   DI_NumOfParams ;
    
    DWORD   dwAlign;

    RAS_PARAMS  DI_Params[1] ;

} ;

typedef struct RASMAN_DEVICEINFO   RASMAN_DEVICEINFO ;



enum RAS_PROTOCOLTYPE {

    ASYBEUI     = 0x80D5,

    IPX     = 0x8137,

    IP      = 0x0800,

    ARP     = 0x0806,

    APPLETALK   = 0x80F3,

    XNS     = 0x0600,

    RASAUTH     = 0x8FFF,

    INVALID_TYPE= 0x2222
} ;

typedef enum RAS_PROTOCOLTYPE RAS_PROTOCOLTYPE ;




struct RASMAN_PROTOCOLINFO {

    CHAR        PI_XportName    [MAX_XPORT_NAME] ;

    RAS_PROTOCOLTYPE    PI_Type ;

} ;

typedef struct RASMAN_PROTOCOLINFO RASMAN_PROTOCOLINFO ;

struct  RASMAN_ROUTEINFO {

    RAS_PROTOCOLTYPE RI_Type ;

    BYTE    RI_LanaNum ;

    WCHAR   RI_XportName    [MAX_XPORT_NAME] ;

    WCHAR   RI_AdapterName  [MAX_XPORT_NAME] ;

} ;

typedef struct RASMAN_ROUTEINFO    RASMAN_ROUTEINFO ;


struct RAS_PROTOCOLS {

    RASMAN_ROUTEINFO   RP_ProtocolInfo[MAX_PROTOCOLS_PER_PORT] ;
} ;

typedef struct RAS_PROTOCOLS RAS_PROTOCOLS ;

typedef struct _RAS_CALLEDID_INFO
{
    DWORD           dwSize;

    BYTE            bCalledId[1];

} RAS_CALLEDID_INFO, *PRAS_CALLEDID_INFO;

typedef struct _RAS_DEVICE_INFO
{
    DWORD           dwVersion;

    BOOL            fWrite;

    BOOL            fRasEnabled;

    BOOL            fRouterEnabled;

    BOOL            fRouterOutboundEnabled;

    DWORD           dwTapiLineId;

    DWORD           dwError;

    DWORD           dwNumEndPoints;

    DWORD           dwMaxOutCalls;

    DWORD           dwMaxInCalls;

    DWORD           dwMinWanEndPoints;

    DWORD           dwMaxWanEndPoints;

    RASDEVICETYPE   eDeviceType;

    GUID            guidDevice;

    CHAR            szPortName[MAX_PORT_NAME + 1];

    CHAR            szDeviceName[MAX_DEVICE_NAME + 1];

    WCHAR           wszDeviceName[MAX_DEVICE_NAME + 1];

} RAS_DEVICE_INFO, *PRAS_DEVICE_INFO;


#define RASMAN_DEFAULT_CREDS        0x00000001
#define RASMAN_OPEN_CALLOUT         0x00000002

struct  RASMAN_INFO {

    RASMAN_STATUS       RI_PortStatus ;

    RASMAN_STATE        RI_ConnState ;

    DWORD           RI_LinkSpeed ;

    DWORD           RI_LastError ;

    RASMAN_USAGE        RI_CurrentUsage ;

    CHAR            RI_DeviceTypeConnecting [MAX_DEVICETYPE_NAME] ;

    CHAR            RI_DeviceConnecting [MAX_DEVICE_NAME + 1] ;

    CHAR            RI_szDeviceType[MAX_DEVICETYPE_NAME];

    CHAR            RI_szDeviceName[MAX_DEVICE_NAME + 1];

    CHAR            RI_szPortName[MAX_PORT_NAME + 1];

    RASMAN_DISCONNECT_REASON    RI_DisconnectReason ;

    DWORD           RI_OwnershipFlag ;

    DWORD           RI_ConnectDuration ;

    DWORD           RI_BytesReceived ;

    //
    // If this port belongs to a connection, then
    // the following fields are filled in.
    //
    CHAR            RI_Phonebook[MAX_PATH+1];

    CHAR            RI_PhoneEntry[MAX_PHONEENTRY_SIZE+1];

    HCONN           RI_ConnectionHandle;

    DWORD           RI_SubEntry;

    RASDEVICETYPE   RI_rdtDeviceType;

    GUID            RI_GuidEntry;
    
    DWORD           RI_dwSessionId;

    DWORD           RI_dwFlags;

} ;


typedef struct RASMAN_INFO    RASMAN_INFO ;

struct  RASMAN_INFO_400 {

    RASMAN_STATUS       RI_PortStatus ;

    RASMAN_STATE        RI_ConnState ;

    DWORD           RI_LinkSpeed ;

    DWORD           RI_LastError ;

    RASMAN_USAGE        RI_CurrentUsage ;

    CHAR            RI_DeviceTypeConnecting [MAX_DEVICETYPE_NAME] ;

    CHAR            RI_DeviceConnecting [MAX_DEVICE_NAME+1] ;

    RASMAN_DISCONNECT_REASON    RI_DisconnectReason ;

    DWORD           RI_OwnershipFlag ;

    DWORD           RI_ConnectDuration ;

    DWORD           RI_BytesReceived ;

    //
    // If this port belongs to a connection, then
    // the following fields are filled in.
    //
    CHAR            RI_Phonebook[MAX_PATH+1];

    CHAR            RI_PhoneEntry[MAX_PHONEENTRY_SIZE+1];

    HCONN           RI_ConnectionHandle;

    DWORD           RI_SubEntry;
} ;


typedef struct RASMAN_INFO_400    RASMAN_INFO_400 ;


struct  RAS_STATISTICS {

    WORD    S_NumOfStatistics ;

    ULONG   S_Statistics[1] ;

} ;

typedef struct RAS_STATISTICS   RAS_STATISTICS ;

#define MAX_STATISTICS      14
#define MAX_STATISTICS_EX   (MAX_STATISTICS * 2)

#define MAX_STATISTICS_EXT  12

struct RAS_DEVCONFIG
{
    DWORD dwOffsetofModemSettings;
    DWORD dwSizeofModemSettings;
    DWORD dwOffsetofExtendedCaps;
    DWORD dwSizeofExtendedCaps;
    BYTE  abInfo[1];
};

typedef struct RAS_DEVCONFIG RAS_DEVCONFIG;

#ifdef RASMERGE
//
// These structures have been added temporarily
// to rasman.h when the RAS ui was moved over.
// They are necessary to get the UI to compile,
// but are not used internally.  These structures
// should be removed when the UI is converted to
// mpradmin APIs.  (adiscolo 16-Sep-1996)
//
typedef struct _RAS_PORT_STATISTICS
{
    // The connection statistics are followed by port statistics
    // A connection is across multiple ports.
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwBytesXmitedUncompressed;
    DWORD   dwBytesRcvedUncompressed;
    DWORD   dwBytesXmitedCompressed;
    DWORD   dwBytesRcvedCompressed;

    // the following are the port statistics
    DWORD   dwPortBytesXmited;
    DWORD   dwPortBytesRcved;
    DWORD   dwPortFramesXmited;
    DWORD   dwPortFramesRcved;
    DWORD   dwPortCrcErr;
    DWORD   dwPortTimeoutErr;
    DWORD   dwPortAlignmentErr;
    DWORD   dwPortHardwareOverrunErr;
    DWORD   dwPortFramingErr;
    DWORD   dwPortBufferOverrunErr;
    DWORD   dwPortBytesXmitedUncompressed;
    DWORD   dwPortBytesRcvedUncompressed;
    DWORD   dwPortBytesXmitedCompressed;
    DWORD   dwPortBytesRcvedCompressed;

} RAS_PORT_STATISTICS, *PRAS_PORT_STATISTICS;

#define RASSAPI_MAX_PARAM_KEY_SIZE        32

enum RAS_PARAMS_FORMAT {

    ParamNumber     = 0,

    ParamString     = 1

} ;
typedef enum RAS_PARAMS_FORMAT  RAS_PARAMS_FORMAT ;

union RAS_PARAMS_VALUE {

    DWORD   Number ;

    struct  {
        DWORD   Length ;
        PCHAR   Data ;
        } String ;
} ;
typedef union RAS_PARAMS_VALUE  RAS_PARAMS_VALUE ;

struct RAS_PARAMETERS {

    CHAR    P_Key   [RASSAPI_MAX_PARAM_KEY_SIZE] ;

    RAS_PARAMS_FORMAT   P_Type ;

    BYTE    P_Attributes ;

    RAS_PARAMS_VALUE    P_Value ;

} ;
typedef struct RAS_PARAMETERS   RAS_PARAMETERS ;
#endif // RASMERGE

#define BYTES_XMITED                0   // Generic Stats

#define BYTES_RCVED                 1

#define FRAMES_XMITED               2

#define FRAMES_RCVED                3

#define CRC_ERR                     4   // Hardware Stats

#define TIMEOUT_ERR                 5

#define ALIGNMENT_ERR               6

#define HARDWARE_OVERRUN_ERR        7

#define FRAMING_ERR                 8

#define BUFFER_OVERRUN_ERR          9

#define BYTES_XMITED_UNCOMPRESSED   10  // Compression Stats

#define BYTES_RCVED_UNCOMPRESSED    11

#define BYTES_XMITED_COMPRESSED     12

#define BYTES_RCVED_COMPRESSED      13

#define COMPRESSION_RATIO_IN        10
#define COMPRESSION_RATIO_OUT       11

#define MSTYPE_COMPRESSION          0x00000001

#define MSTYPE_ENCRYPTION_40        0x00000010

#define MSTYPE_ENCRYPTION_40F       0x00000020

#define MSTYPE_ENCRYPTION_128       0x00000040

#define MSTYPE_ENCRYPTION_56        0x00000080

#define MSTYPE_HISTORYLESS          0x01000000

#define MACTYPE_NT31RAS             254

#define MAX_SESSIONKEY_SIZE         8

#define MAX_USERSESSIONKEY_SIZE     16

#define MAX_NT_RESPONSE_SIZE        24

#define MAX_COMPVALUE_SIZE          32

#define MAX_COMPOUI_SIZE            3

#define MAX_EAPKEY_SIZE             256

#define VERSION_40                  4

#define VERSION_50                  5

#define VERSION_501                 6

//
// Information stored in rasman per-connection.
//
#define CONNECTION_PPPMODE_INDEX                        0
#define CONNECTION_PPPRESULT_INDEX                      1
#define CONNECTION_AMBRESULT_INDEX                      2
#define CONNECTION_SLIPRESULT_INDEX                     3
#define CONNECTION_PPPREPLYMESSAGE_INDEX                4
#define CONNECTION_IPSEC_INFO_INDEX                     5
#define CONNECTION_CREDENTIALS_INDEX                     6
#define CONNECTION_CUSTOMAUTHINTERACTIVEDATA_INDEX    7
#define CONNECTION_TCPWINDOWSIZE_INDEX                 8
#define CONNECTION_LUID_INDEX                            9
#define CONNECTION_REFINTERFACEGUID_INDEX                10
#define CONNECTION_REFDEVICEGUID_INDEX                  11
#define CONNECTION_DEVICEGUID_INDEX                     12


//
// Information stored in rasman per-port.
//
#define PORT_PHONENUMBER_INDEX                  0
#define PORT_DEVICENAME_INDEX                   1
#define PORT_DEVICETYPE_INDEX                   2
#define PORT_CONNSTATE_INDEX                    3
#define PORT_CONNERROR_INDEX                    4
#define PORT_CONNRESPONSE_INDEX                 5
#define PORT_CUSTOMAUTHDATA_INDEX               6
#define PORT_CUSTOMAUTHINTERACTIVEDATA_INDEX    7
#define PORT_IPSEC_INFO_INDEX                   8
#define PORT_USERSID_INDEX                      9
#define PORT_DIALPARAMSUID_INDEX                10
#define PORT_OLDPASSWORD_INDEX                  11
#define PORT_CREDENTIALS_INDEX                  12
#define PORT_SLIPFLAGS_INDEX                    13

//
// IPSEC DOI ESP algorithms
//
#define RASMAN_IPSEC_ESP_DES                0x00000001
#define RASMAN_IPSEC_ESP_DES_40             0x00000002
#define RASMAN_IPSEC_ESP_3_DES              0x00000004
#define RASMAN_IPSEC_ESP_MAX                0x00000008


//
// Defines for COMPRESS_INFO AuthType field
//
#define AUTH_USE_MSCHAPV1        0x00000001
#define AUTH_USE_MSCHAPV2        0x00000002
#define AUTH_USE_EAP             0x00000003

//
// Defines for COMPRESS_INFO flags
//
#define CCP_PAUSE_DATA          0x00000001  // this bit is set if the bundle
                                            // should pause data transfer.
                                            // the bit is cleared if the bundle
                                            // should resume data transfer
#define CCP_IS_SERVER           0x00000002  // this bit is set if the bundle
                                            // is the server
                                            // the bit is cleared if the bundle
                                            // is the client
#define CCP_SET_KEYS            0x00000004  // indicates that the key
                                            // information is valid
#define CCP_SET_COMPTYPE        0x00000008  // indicates that the comptype

enum RAS_L2TP_ENCRYPTION
{
    RAS_L2TP_NO_ENCRYPTION = 0,     // Request no encryption

    RAS_L2TP_OPTIONAL_ENCRYPTION,   // Request encryption but none OK

    RAS_L2TP_REQUIRE_ENCRYPTION,    // Require encryption of any strength

    RAS_L2TP_REQUIRE_MAX_ENCRYPTION // Require maximum strength encryption
};

typedef enum RAS_L2TP_ENCRYPTION RAS_L2TP_ENCRYPTION;

struct RAS_COMPRESSION_INFO {

    //
    // May be used for encryption, non-zero if supported.
    //

    UCHAR RCI_LMSessionKey[MAX_SESSIONKEY_SIZE];

    //
    // Used for 128Bit encryption, non-zero if supported.
    //

    UCHAR RCI_UserSessionKey[MAX_USERSESSIONKEY_SIZE];

    //
    // Used for 128Bit encryption, only valid if RCI_UserSessionKey is valid.
    //

    UCHAR RCI_Challenge[MAX_CHALLENGE_SIZE];

    UCHAR RCI_NTResponse[MAX_NT_RESPONSE_SIZE];

    //
    // bit 0 = MPPPC, bit 5 = encryption
    //

    ULONG RCI_MSCompressionType;

    ULONG RCI_AuthType;

    //
    // 0=OUI, 1-253 = Public, 254 = NT31 RAS, 255=Not supported
    //

    UCHAR   RCI_MacCompressionType;

    WORD    RCI_MacCompressionValueLength ;

    union {
    struct {        // Proprietary: used for comp type 0

        UCHAR RCI_CompOUI[MAX_COMPOUI_SIZE];

        UCHAR RCI_CompSubType;

        UCHAR RCI_CompValues[MAX_COMPVALUE_SIZE];

    } RCI_Proprietary;

    struct {        // Public: used for comp type 1-254

        UCHAR RCI_CompValues[MAX_COMPVALUE_SIZE];

    } RCI_Public;

    } RCI_Info ;

    ULONG RCI_Flags;

    ULONG RCI_EapKeyLength;

    UCHAR RCI_EapKey[MAX_EAPKEY_SIZE];

};

typedef struct RAS_COMPRESSION_INFO RAS_COMPRESSION_INFO;


struct PROTOCOL_CONFIG_INFO {

    DWORD  P_Length ;

    BYTE   P_Info[1] ;
} ;

typedef struct PROTOCOL_CONFIG_INFO PROTOCOL_CONFIG_INFO ;


struct RASMAN_PPPFEATURES {

    DWORD MRU;
    DWORD ACCM;
    DWORD AuthProtocol;
    DWORD MagicNumber;
    BOOL  PFC;
    BOOL  ACFC;

} ;

typedef struct RASMAN_PPPFEATURES RASMAN_PPPFEATURES ;


enum RAS_FRAMING {PPP, RAS, AUTODETECT, SLIP, SLIPCOMP, SLIPCOMPAUTO} ;

typedef enum RAS_FRAMING RAS_FRAMING ;

struct RAS_FRAMING_CAPABILITIES {

    DWORD   RFC_MaxFrameSize;
    DWORD   RFC_MaxReconstructedFrameSize;
    DWORD   RFC_FramingBits;
    DWORD   RFC_DesiredACCM;

} ;

typedef struct RAS_FRAMING_CAPABILITIES RAS_FRAMING_CAPABILITIES ;


struct RAS_FRAMING_INFO {

    DWORD RFI_MaxSendFrameSize;
    DWORD RFI_MaxRecvFrameSize;
    DWORD RFI_MaxRSendFrameSize;
    DWORD RFI_MaxRRecvFrameSize;
    DWORD RFI_HeaderPadding;
    DWORD RFI_TailPadding;
    DWORD RFI_SendFramingBits;
    DWORD RFI_RecvFramingBits;
    DWORD RFI_SendCompressionBits;
    DWORD RFI_RecvCompressionBits;
    DWORD RFI_SendACCM;
    DWORD RFI_RecvACCM;

} ;

typedef struct RAS_FRAMING_INFO RAS_FRAMING_INFO ;


// NDIS WAN Framing bits: used with RasPortGetFramingEx and RasPortSetFramingEx
//            APIs.
//

#define OLD_RAS_FRAMING                     0x00000001

#define RAS_COMPRESSION                     0x00000002

#define PPP_MULTILINK_FRAMING               0x00000010

#define PPP_SHORT_SEQUENCE_HDR_FORMAT       0x00000020

#define PPP_FRAMING                         0x00000100

#define PPP_COMPRESS_ADDRESS_CONTROL        0x00000200

#define PPP_COMPRESS_PROTOCOL_FIELD         0x00000400

#define PPP_ACCM_SUPPORTED                  0x00000800

#define SLIP_FRAMING                        0x00001000

#define SLIP_VJ_COMPRESSION                 0x00002000

#define SLIP_VJ_AUTODETECT                  0x00004000

#define MEDIA_NRZ_ENCODING                  0x00010000

#define MEDIA_NRZI_ENCODING                 0x00020000

#define MEDIA_NLPID                         0x00040000

#define RFC_1356_FRAMING                    0x00100000

#define RFC_1483_FRAMING                    0x00200000

#define RFC_1490_FRAMING                    0x00400000

#define SHIVA_FRAMING                       0x01000000



// Defines for RAS_PROTOCOLCOMPRESSION
//
#define VJ_IP_COMPRESSION        0x002d
#define NO_PROTOCOL_COMPRESSION      0x0000

struct RAS_PROTOCOLCOMPRESSION {

    union {

    struct {

        WORD    RP_IPCompressionProtocol;

        BYTE    RP_MaxSlotID;       // How many slots to allocate

        BYTE    RP_CompSlotID;      // 1 = Slot ID was negotiated

    } RP_IP ;

    struct {

        WORD    RP_IPXCompressionProtocol;

    } RP_IPX ;

    } RP_ProtocolType ;

} ;

typedef struct RAS_PROTOCOLCOMPRESSION RAS_PROTOCOLCOMPRESSION ;

#define RAS_VERSION         6

#define PT_WORKSTATION      1

#define PT_SERVER           2

#define PS_PERSONAL         1

#define PS_PROFESSIONAL     2

#define GUIDSTRLEN          39

typedef DWORD               PRODUCT_TYPE;
typedef DWORD               PRODUCT_SKU;

enum _DEVICE_STATUS
{
    DS_Enabled = 0,

    DS_Disabled,

    DS_Unavailable,

    DS_Removed
};

typedef enum _DEVICE_STATUS DEVICE_STATUS;

typedef struct DeviceInfo
{
    //
    // Private fields which are used
    // internally in rastapi/rasman
    //
    struct DeviceInfo   *Next;

    BOOL                fValid;                             // Is this information valid

    DWORD               dwCurrentEndPoints;                 // Current number of ports on this adapter

    DWORD               dwCurrentDialedInClients;           // Number of clients dialed in currently

    DWORD               dwInstanceNumber;                   // Instance Number

    DWORD               dwNextPortNumber;                   // The number assigned next to distinguish rasman

    DEVICE_STATUS       eDeviceStatus;                      // Status of the device

    DWORD               dwUsage;

    RAS_CALLEDID_INFO   *pCalledID;                         // Called id information read from registry

    RAS_DEVICE_INFO     rdiDeviceInfo;                      // Device info structure
} DeviceInfo, *pDeviceInfo;

//
// Definitions for Ras{Get,Set}DialParams
//
// The dwMask values control/specify which fields
// of the RAS_DIALPARAMS are stored/retrieved.
//
// NOTE: these values have to match the RASCF_*
// values in ras.h.
//
#define DLPARAMS_MASK_USERNAME                  0x00000001

#define DLPARAMS_MASK_PASSWORD                  0x00000002

#define DLPARAMS_MASK_DOMAIN                    0x00000004

#define DLPARAMS_MASK_PHONENUMBER               0x00000008

#define DLPARAMS_MASK_CALLBACKNUMBER            0x00000010

#define DLPARAMS_MASK_SUBENTRY                  0x00000020

#define DLPARAMS_MASK_DEFAULT_CREDS             0x00000040

#define DLPARAMS_MASK_PRESHAREDKEY              0x00000080

#define DLPARAMS_MASK_SERVER_PRESHAREDKEY       0x00000100

#define DLPARAMS_MASK_DDM_PRESHAREDKEY          0x00000200

//
// The following are flags used internall and 
// don't really map to external apis. So we are
// defining the bits from MSB.
//
#define DLPARAMS_MASK_OLDSTYLE          0x80000000

#define DLPARAMS_MASK_DELETE            0x40000000

#define DLPARAMS_MASK_DELETEALL         0x20000000

typedef struct _RAS_DIALPARAMS {

    DWORD DP_Uid;

    WCHAR DP_PhoneNumber[MAX_PHONENUMBER_SIZE + 1];

    WCHAR DP_CallbackNumber[MAX_CALLBACKNUMBER_SIZE + 1];

    WCHAR DP_UserName[MAX_USERNAME_SIZE + 1];

    WCHAR DP_Password[MAX_PASSWORD_SIZE + 1];

    WCHAR DP_Domain[MAX_DOMAIN_SIZE + 1];

    DWORD DP_SubEntry;

} RAS_DIALPARAMS, *PRAS_DIALPARAMS;


//
// Connection Flags
//
#define CONNECTION_REDIALONLINKFAILURE      0x00000001
#define CONNECTION_SHAREFILEANDPRINT        0x00000002
#define CONNECTION_BINDMSNETCLIENT          0x00000004
#define CONNECTION_USERASCREDENTIALS        0x00000008
#define CONNECTION_USEPRESHAREDKEY          0x00000010

//
// Definitions for Ras{Get,Set}ConnectionParams
//
typedef struct _RAS_CONNECTIONPARAMS {
    //
    // Phonebook and entry name.
    //
    CHAR CP_Phonebook[MAX_PATH + 1];

    CHAR CP_PhoneEntry[MAX_PHONEENTRY_SIZE + 1];

    //
    // Idle disconnect parameters
    //
    DWORD CP_IdleDisconnectSeconds;

    //
    // Connection Flags
    //
    DWORD CP_ConnectionFlags;

} RAS_CONNECTIONPARAMS, *PRAS_CONNECTIONPARAMS;

//
// Flags for RasAddNotification.
//
// Note: the NOTIF_* values must match the
// RASCN_* values in ras.h
//
#define NOTIF_CONNECT           0x00000001

#define NOTIF_DISCONNECT        0x00000002

#define NOTIF_BANDWIDTHADDED    0x00000004

#define NOTIF_BANDWIDTHREMOVED  0x00000008


//
// Overlapped I/O structure
// used by the device and media DLLs.
//
// This structure is used with the I/O
// completion port associated with each
// of the port handles.
//
// This structure is also used by the
// rasapi32 dialing machine and PPP event
// mechanism.
//
typedef struct _RAS_OVERLAPPED {

    OVERLAPPED RO_Overlapped;   // the I/O overlapped structure

    DWORD      RO_EventType;    // OVEVT_* flags below

    PVOID      RO_Info;         // optional

    HANDLE     RO_hInfo;        // optional

} RAS_OVERLAPPED, *PRAS_OVERLAPPED;


typedef struct _NEW_PORT_NOTIF {

    PVOID          *NPN_pmiNewPort;
    CHAR            NPN_MediaName[MAX_MEDIA_NAME];

} NEW_PORT_NOTIF, *PNEW_PORT_NOTIF;

typedef struct _REMOVE_LINE_NOTIF {

    DWORD dwLineId;

} REMOVE_LINE_NOTIF, *PREMOVE_LINE_NOTIF;

typedef struct _PORT_USAGE_NOTIF {

    PVOID          *PUN_pmiPort;
    CHAR            PUN_MediaName[MAX_MEDIA_NAME];

} PORT_USAGE_NOTIF, *PPORT_USAGE_NOTIF;

typedef struct _PNP_EVENT_NOTIF {

    DWORD           dwEvent;
    RASMAN_PORT     RasPort;

} PNP_EVENT_NOTIF, *PPNP_EVENT_NOTIF;


#define PNP_NOTIFCALLBACK           0x00000001
#define PNP_NOTIFEVENT              0x00000002

#define PNPNOTIFEVENT_CREATE        0x00000001
#define PNPNOTIFEVENT_REMOVE        0x00000002
#define PNPNOTIFEVENT_USAGE         0x00000004

#define LEGACY_PPTP                 0
#define LEGACY_L2TP                 1
#define LEGACY_MAX                  2

//
// RAS_OVERLAPPED.RO_EventTypes for device
// and medial DLLs.
//
#define OVEVT_DEV_IGNORED                           0   // ignored

#define OVEVT_DEV_STATECHANGE                       1   // disconnect event

#define OVEVT_DEV_ASYNCOP                           2   // async operation event

#define OVEVT_DEV_SHUTDOWN                          4   // shutdown event

#define OVEVT_RASMAN_TIMER                          6   // timer

#define OVEVT_RASMAN_CLOSE                          7   // close event posted by a client to rasman

#define OVEVT_RASMAN_FINAL_CLOSE                    8   // event posted by ppp engine when it has shut down

#define OVEVT_RASMAN_RECV_PACKET                    9   // event posted by tapi/...

#define OVEVT_RASMAN_THRESHOLD                      10  // event notifying setting of a threshold event

#define OVEVT_DEV_CREATE                            11  // new port event (PnP)

#define OVEVT_DEV_REMOVE                            12  // device remove event (PnP)

#define OVEVT_DEV_CONFIGCHANGE                      13  // pptp config changed (PnP)

#define OVEVT_DEV_RASCONFIGCHANGE                   14  // Configuration of some device changed (PnP)

#define OVEVT_RASMAN_ADJUST_TIMER                   15  // someone added a timer element..

#define OVEVT_RASMAN_HIBERNATE                      16  // ndiswan is asking rasman to hibernate

#define OVEVT_RASMAN_PROTOCOL_EVENT                 17  // ndiswan indicates a protocol event

#define OVEVT_RASMAN_POST_RECV_PKT                  18  // post receive packet in rasmans thread

#define OVEVT_RASMAN_DEREFERENCE_CONNECTION         19  // post event to disconnect

#define OVEVT_RASMAN_POST_STARTRASAUTO              20  // start rasauto service

#define OVEVT_RASMAN_DEFERRED_CLOSE_CONNECTION      21 // Close deferred connections

//
// RAS_OVERLAPPED.RO_EventTypes for rasapi32
// dialing machine and PPP.
//
#define OVEVT_DIAL_IGNORED          0   // ignored

#define OVEVT_DIAL_DROP             1   // port disconnected

#define OVEVT_DIAL_STATECHANGE      2   // rasdial state change

#define OVEVT_DIAL_PPP              3   // PPP event received

#define OVEVT_DIAL_LAST             4   // no more events on this port

#define OVEVT_DIAL_SHUTDOWN         5   // shutdown event

#define REQUEST_BUFFER_SIZE         2500

#define RECEIVE_OUTOF_PROCESS       0x00000001

#define RECEIVE_WAITING             0x00000002

#define RECEIVE_PPPSTARTED          0x00000004

#define RECEIVE_PPPLISTEN           0x00000008

#define RECEIVE_PPPSTOPPED          0x00000010

#define RECEIVE_PPPSTART            0x00000020

#define RASMANFLAG_PPPSTOPPENDING   0x00000001

typedef struct _RAS_RPC
{

    RPC_BINDING_HANDLE hRpcBinding;
    BOOL               fLocal;
    DWORD              dwVersion;
    TCHAR              szServer[MAX_COMPUTERNAME_LENGTH + 1];

} RAS_RPC, *PRAS_RPC;

#define RasGetServerVersion(_hConnection)   (_hConnection == NULL) ? \
                                        VERSION_501 : \
                                        ((RAS_RPC *)_hConnection)->dwVersion

typedef struct _RAS_DEVICE_INFO_V500
{
    DWORD           dwVersion;

    BOOL            fWrite;

    BOOL            fRasEnabled;

    BOOL            fRouterEnabled;

    DWORD           dwTapiLineId;

    DWORD           dwError;

    DWORD           dwNumEndPoints;

    DWORD           dwMaxOutCalls;

    DWORD           dwMaxInCalls;

    DWORD           dwMinWanEndPoints;

    DWORD           dwMaxWanEndPoints;

    RASDEVICETYPE   eDeviceType;

    GUID            guidDevice;

    CHAR            szPortName[MAX_PORT_NAME + 1];

    CHAR            szDeviceName[MAX_DEVICE_NAME + 1];

} RAS_DEVICE_INFO_V500, *PRAS_DEVICE_INFO_V500;

typedef struct _RAS_CUSTOM_AUTH_DATA
{

    DWORD   cbCustomAuthData;
    BYTE    abCustomAuthData[1];

} RAS_CUSTOM_AUTH_DATA, *PRAS_CUSTOM_AUTH_DATA;

typedef struct _RAS_CONNECT_INFO
{

    DWORD dwCallerIdSize;
    CHAR  *pszCallerId;
    DWORD dwCalledIdSize;
    CHAR  *pszCalledId;
    DWORD dwConnectResponseSize;
    CHAR  *pszConnectResponse;
    DWORD dwAltCalledIdSize;
    CHAR  *pszAltCalledId;
    BYTE  abdata[1];

} RAS_CONNECT_INFO, *PRAS_CONNECT_INFO;

typedef struct _RASTAPI_CONNECT_INFO
{

    DWORD dwCallerIdSize;
    DWORD dwCallerIdOffset;
    DWORD dwCalledIdSize;
    DWORD dwCalledIdOffset;
    DWORD dwConnectResponseSize;
    DWORD dwConnectResponseOffset;
    DWORD dwAltCalledIdSize;
    DWORD dwAltCalledIdOffset;
    BYTE  abdata[1];

} RASTAPI_CONNECT_INFO, *PRASTAPI_CONNECT_INFO;


typedef struct _EAPLOGONINFO
{
    DWORD dwSize;
    DWORD dwLogonInfoSize;
    DWORD dwOffsetLogonInfo;
    DWORD dwPINInfoSize;
    DWORD dwOffsetPINInfo;
    BYTE  abdata[1];
} EAPLOGONINFO, *PEAPLOGONINFO;



//
// Structure used in IOCTL_NDISWAN_GET_DRIVER_INFO
//
typedef struct _RAS_NDISWAN_DRIVER_INFO
{
    OUT     ULONG   DriverCaps;
    OUT     ULONG   Reserved;
} RAS_NDISWAN_DRIVER_INFO, *P_NDISWAN_DRIVER_INFO;


//
// Structure used in IOCTL_NDISWAN_GET_BANDWIDTH_UTILIZATION
//
typedef struct _RAS_GET_BANDWIDTH_UTILIZATION
{
    OUT ULONG      ulUpperXmitUtil;
    OUT ULONG      ulLowerXmitUtil;
    OUT ULONG      ulUpperRecvUtil;
    OUT ULONG      ulLowerRecvUtil;
} RAS_GET_BANDWIDTH_UTILIZATION, *PRAS_GET_BANDWIDTH_UTILIZATION;

//
// This structure should match the WAN_PROTOCOL_INFO in wanpub.h
//
typedef struct _RASMAN_PROTOCOL_INFO
{
    USHORT  ProtocolType;       // protocol's Ethertype
    USHORT  PPPId;              // protocol's PPP ID
    ULONG   MTU;                // MTU being used
    ULONG   TunnelMTU;          // MTU used for tunnels
    ULONG   PacketQueueDepth;   // max depth of packet queue (in seconds)
} RASMAN_PROTOCOL_INFO, *PRASMAN_PROTOCOL_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_PROTOCOL_INFO
//
typedef struct _RASMAN_GET_PROTOCOL_INFO
{
    OUT ULONG                ulNumProtocols;
    OUT RASMAN_PROTOCOL_INFO ProtocolInfo[RASMAN_MAX_PROTOCOLS];
} RASMAN_GET_PROTOCOL_INFO, *PRASMAN_GET_PROTOCOL_INFO;

typedef struct _RASMANCOMMSETTINGS
{
    DWORD     dwSize;
    BYTE      bParity;
    BYTE      bStop;
    BYTE      bByteSize;
    BYTE      bAlign;
} RASMANCOMMSETTINGS, *PRASMANCOMMSETTINGS;

#define RASCRED_LOGON       0x00000001
#define RASCRED_EAP         0x00000002

typedef struct _RASMAN_CREDENTIALS
{
    DWORD dwFlags;
    DWORD cbPasswordData;
    PBYTE pbPasswordData;
    USHORT usLength;
    USHORT usMaximumLength;
    CHAR szUserName[UNLEN];
    BYTE bpad[8];
    CHAR szDomain[DNLEN + 1];
    WCHAR wszPassword[PWLEN];
    UCHAR ucSeed;
} RASMAN_CREDENTIALS, *PRASMAN_CREDENTIALS;


//
// RAS Manager entrypoint Prototypes
//

DWORD RasStartRasAutoIfRequired(void);

DWORD APIENTRY RasPortOpen(PCHAR,
                           HPORT*,
                           HANDLE);

DWORD APIENTRY RasPortClose(HPORT);

DWORD APIENTRY RasPortEnum(HANDLE,
                           PBYTE,
                           PDWORD,
                           PDWORD);

DWORD APIENTRY RasPortGetInfo(HANDLE,
                              HPORT,
                              PBYTE,
                              PDWORD);

DWORD APIENTRY RasPortSetInfo(HPORT,
                              RASMAN_PORTINFO*);

DWORD APIENTRY RasPortDisconnect(HPORT,
                                 HANDLE);

DWORD APIENTRY RasPortSend(HPORT,
                           PBYTE,
                           DWORD);

DWORD APIENTRY RasPortReceive(HPORT,
                              PBYTE,
                              PDWORD,
                              DWORD,
                              HANDLE);

DWORD APIENTRY RasPortListen(HPORT,
                             DWORD,
                             HANDLE);

DWORD APIENTRY RasPortConnectComplete(HPORT);

DWORD APIENTRY RasPortGetStatistics(HANDLE,
                                    HPORT,
                                    PBYTE,
                                    PDWORD);

DWORD APIENTRY RasPortClearStatistics(HANDLE,
                                      HPORT);

DWORD APIENTRY RasPortGetStatisticsEx(HANDLE,
                                      HPORT,
                                      PBYTE,
                                      PDWORD);

DWORD APIENTRY RasDeviceEnum(HANDLE,
                             PCHAR,
                             PBYTE,
                             PDWORD,
                             PDWORD);

DWORD APIENTRY RasDeviceGetInfo(HANDLE,
                                HPORT,
                                PCHAR,
                                PCHAR,
                                PBYTE,
                                PDWORD);

DWORD APIENTRY RasDeviceSetInfo(HPORT,
                                PCHAR,
                                PCHAR,
                                RASMAN_DEVICEINFO*);

DWORD APIENTRY RasDeviceConnect(HPORT,
                                PCHAR,
                                PCHAR,
                                DWORD,
                                HANDLE);

DWORD APIENTRY RasGetInfo( HANDLE,
                           HPORT,
                           RASMAN_INFO*);

DWORD APIENTRY RasGetInfoEx( HANDLE,
                             RASMAN_INFO*,
                             PWORD);

DWORD APIENTRY RasGetBuffer( PBYTE*,
                             PDWORD);

DWORD APIENTRY RasFreeBuffer(PBYTE);

DWORD APIENTRY RasProtocolEnum( PBYTE,
                                PDWORD,
                                PDWORD);

DWORD APIENTRY RasAllocateRoute( HPORT,
                                 RAS_PROTOCOLTYPE,
                                 BOOL,
                                 RASMAN_ROUTEINFO*);

DWORD APIENTRY RasActivateRoute( HPORT,
                                 RAS_PROTOCOLTYPE,
                                 RASMAN_ROUTEINFO*,
                                 PROTOCOL_CONFIG_INFO*);

DWORD APIENTRY RasActivateRouteEx( HPORT,
                                   RAS_PROTOCOLTYPE,
                                   DWORD,
                                   RASMAN_ROUTEINFO*,
                                   PROTOCOL_CONFIG_INFO*);

DWORD APIENTRY RasDeAllocateRoute( HBUNDLE,
                                   RAS_PROTOCOLTYPE);

DWORD APIENTRY RasCompressionGetInfo( HPORT,
                                      RAS_COMPRESSION_INFO* Send,
                                      RAS_COMPRESSION_INFO* Recv);

DWORD APIENTRY RasCompressionSetInfo( HPORT,
                                      RAS_COMPRESSION_INFO* Send,
                                      RAS_COMPRESSION_INFO* Recv);

DWORD APIENTRY RasGetUserCredentials( PBYTE,
                                      PLUID,
                                      PWCHAR,
                                      PBYTE,
                                      PBYTE,
                                      PBYTE,
                                      PBYTE) ;

DWORD APIENTRY RasSetCachedCredentials( PCHAR,
                                        PCHAR,
                                        PCHAR ) ;

DWORD APIENTRY RasRequestNotification ( HPORT,
                                        HANDLE) ;

DWORD APIENTRY RasPortCancelReceive (HPORT) ;

DWORD APIENTRY RasPortEnumProtocols ( HANDLE,
                                      HPORT,
                                      RAS_PROTOCOLS*,
                                      PDWORD) ;

DWORD APIENTRY RasEnumLanNets ( DWORD *,
                                UCHAR *) ;

DWORD APIENTRY RasPortSetFraming ( HPORT,
                                   RAS_FRAMING,
                                   RASMAN_PPPFEATURES*,
                                   RASMAN_PPPFEATURES*) ;

DWORD APIENTRY RasPortRegisterSlip ( HPORT,
                                     DWORD,
                                     DWORD,
                                     BOOL,
                                     WCHAR*,
                                     WCHAR*,
                                     WCHAR*,
                                     WCHAR*) ;

DWORD APIENTRY RasPortStoreUserData ( HPORT,
                                      PBYTE,
                                      DWORD) ;

DWORD APIENTRY RasPortRetrieveUserData ( HPORT,
                                         PBYTE,
                                         DWORD *) ;

DWORD APIENTRY RasPortGetFramingEx ( HANDLE,
                                     HPORT,
                                     RAS_FRAMING_INFO *) ;

DWORD APIENTRY RasPortSetFramingEx ( HPORT,
                                     RAS_FRAMING_INFO *) ;

DWORD APIENTRY RasPortGetProtocolCompression ( HPORT,
                                               RAS_PROTOCOLTYPE,
                                               RAS_PROTOCOLCOMPRESSION *,
                                               RAS_PROTOCOLCOMPRESSION *) ;

DWORD APIENTRY RasPortSetProtocolCompression ( HPORT,
                                               RAS_PROTOCOLTYPE,
                                               RAS_PROTOCOLCOMPRESSION *,
                                               RAS_PROTOCOLCOMPRESSION *) ;

DWORD APIENTRY RasGetFramingCapabilities ( HPORT,
                                           RAS_FRAMING_CAPABILITIES*) ;

//DWORD APIENTRY RasInitialize () ;

DWORD APIENTRY RasPortReserve ( PCHAR,
                                HPORT*) ;

DWORD APIENTRY RasPortFree (HPORT) ;

DWORD APIENTRY RasPortBundle( HPORT,
                              HPORT );

DWORD APIENTRY RasPortGetBundledPort ( HPORT oldport,
                                       HPORT *pnewport) ;

DWORD APIENTRY RasBundleGetPort ( HANDLE hConnection,
                                  HBUNDLE hbundle,
                                  HPORT *phport) ;

DWORD APIENTRY RasPortGetBundle ( HANDLE hConnection,
                                  HPORT hport,
                                  HBUNDLE *phbundle) ;

DWORD APIENTRY RasReferenceRasman (BOOL fAttach);

DWORD APIENTRY RasGetAttachedCount ( DWORD *pdwAttachedCount );

DWORD APIENTRY RasGetDialParams ( DWORD dwUID,
                                  LPDWORD lpdwMask,
                                  PRAS_DIALPARAMS pDialParams);

DWORD APIENTRY RasSetDialParams ( DWORD dwOldUID,
                                  DWORD dwMask,
                                  PRAS_DIALPARAMS pDialParams,
                                  BOOL fDelete);

DWORD APIENTRY RasCreateConnection( HCONN *lphconn,
                                    DWORD dwSubEntries,
                                    DWORD *lpdwEntryAlreadyConnected,
                                    DWORD *lpdwSubEntryInfo,
                                    DWORD dwDialMode,
                                    GUID *pGuidEntry,
                                    CHAR *lpszPhonebookPath,
                                    CHAR *lpszEntryName,
                                    CHAR *lpszRefPbkPath,
                                    CHAR *lpszRefEntryName);

DWORD APIENTRY RasDestroyConnection (HCONN hconn);

DWORD APIENTRY RasConnectionEnum (HANDLE hConnection,
                                  HCONN *lphconn,
                                  LPDWORD lpdwcbConnections,
                                  LPDWORD lpdwcConnections);

DWORD APIENTRY RasAddConnectionPort ( HCONN hconn,
                                      HPORT hport,
                                      DWORD dwSubEntry);

DWORD APIENTRY RasEnumConnectionPorts ( HANDLE hConnection,
                                        HCONN hconn,
                                        RASMAN_PORT *pPorts,
                                        LPDWORD lpdwcbPorts,
                                        LPDWORD lpdwcPorts);

DWORD APIENTRY RasGetConnectionParams ( HCONN hconn,
                                        PRAS_CONNECTIONPARAMS pConnectionParams);

DWORD APIENTRY RasSetConnectionParams ( HCONN hconn,
                                        PRAS_CONNECTIONPARAMS pConnectionParams);

DWORD APIENTRY RasGetConnectionUserData ( HPORT hconn,
                                          DWORD dwTag,
                                          PBYTE pBuf,
                                          LPDWORD lpdwcbBuf);

DWORD APIENTRY RasSetConnectionUserData ( HPORT hconn,
                                          DWORD dwTag,
                                          PBYTE pBuf,
                                          DWORD dwcbBuf);

DWORD APIENTRY RasGetPortUserData ( HPORT hport,
                                    DWORD dwTag,
                                    PBYTE pBuf,
                                    LPDWORD lpdwcbBuf);

DWORD APIENTRY RasSetPortUserData ( HPORT hport,
                                    DWORD dwTag,
                                    PBYTE pBuf,
                                    DWORD dwcbBuf);

DWORD APIENTRY RasAddNotification ( HCONN hconn,
                                    HANDLE hevent,
                                    DWORD dwfFlags);

DWORD APIENTRY RasSignalNewConnection( HCONN hconn);

DWORD APIENTRY RasSetDevConfig( HPORT hport,
                                PCHAR devicetype,
                                PBYTE config,
                                DWORD size);

DWORD APIENTRY RasGetDevConfig( HANDLE hConnection,
                                HPORT hport,
                                PCHAR devicetype,
                                PBYTE config,
                                DWORD* size);

DWORD APIENTRY RasGetTimeSinceLastActivity( HPORT hport,
                                            LPDWORD lpdwTimeSinceLastActivity );

DWORD APIENTRY RasBundleGetStatistics( HANDLE,
                                       HPORT,
                                       PBYTE,
                                       PDWORD);

DWORD APIENTRY RasBundleGetStatisticsEx( HANDLE,
                                         HPORT,
                                         PBYTE,
                                         PDWORD);

DWORD APIENTRY RasBundleClearStatistics(HANDLE,
                                        HPORT);

DWORD APIENTRY RasBundleClearStatisticsEx(HANDLE,
                                          HCONN);

DWORD APIENTRY RasPnPControl( DWORD,
                              HPORT);

DWORD APIENTRY RasSetIoCompletionPort( HPORT,
                                       HANDLE,
                                       PRAS_OVERLAPPED,
                                       PRAS_OVERLAPPED,
                                       PRAS_OVERLAPPED,
                                       PRAS_OVERLAPPED,
                                       HCONN);

DWORD APIENTRY RasSetRouterUsage( HPORT,
                                  BOOL);

DWORD APIENTRY RasServerPortClose( HPORT );

DWORD APIENTRY RasSetRasdialInfo( HPORT,
                                   CHAR *,
                                   CHAR *,
                                   CHAR *,
                                   DWORD,
                                   PBYTE);

DWORD APIENTRY RasSendPppMessageToRasman( HPORT,
                                          LPBYTE);

DWORD APIENTRY RasGetNumPortOpen ();

// DWORD APIENTRY RasNotifyConfigChange();

DWORD _RasmanInit( LPDWORD pNumPorts);

VOID _RasmanEngine();

DWORD APIENTRY RasRegisterPnPEvent ( HANDLE, BOOL );

DWORD APIENTRY RasRegisterPnPHandler ( PAPCFUNC,
                                       HANDLE,
                                       BOOL);

DWORD APIENTRY RasRpcConnect ( LPWSTR,
                               HANDLE *);

DWORD APIENTRY RasRpcDisconnect( HANDLE *);

DWORD APIENTRY RasRpcConnectServer(LPTSTR lpszServer,
                                   HANDLE *pHConnection);

DWORD APIENTRY RasRpcDisconnectServer(HANDLE hConnection);

DWORD APIENTRY RasSetBapPolicy ( HCONN,
                                 DWORD,
                                 DWORD,
                                 DWORD,
                                 DWORD );

DWORD APIENTRY RasPppStarted ( HPORT hPort );

DWORD APIENTRY RasRefConnection ( HCONN hConn,
                                  BOOL AddRef,
                                  DWORD *pdwRefCount );

DWORD APIENTRY RasPppGetEapInfo ( HCONN  hConn,
                                  DWORD  dwSubEntry,
                                  PDWORD pdwContextId,
                                  PDWORD pdwEapTypeId,
                                  PDWORD pdwSizeofEapUIData,
                                  PBYTE  pbdata );

DWORD APIENTRY RasPppSetEapInfo ( HPORT hPort,
                                  DWORD dwSizeOfEapUIdata,
                                  DWORD dwContextId,
                                  PBYTE pbdata);

DWORD APIENTRY RasSetDeviceConfigInfo( HANDLE hConnection,
                                       DWORD  cDevices,
                                       DWORD  cbBuffer,
                                       BYTE   *pbBuffer);

DWORD APIENTRY RasGetDeviceConfigInfo( HANDLE hConnection,
                                       DWORD  *dwVersion,
                                       DWORD  *pcDevices,
                                       DWORD  *pcbdata,
                                       BYTE   *pbBuffer);

DWORD APIENTRY RasFindPrerequisiteEntry(
                            HCONN hConn,
                            HCONN *phConnPrerequisiteEntry);

DWORD APIENTRY RasPortOpenEx(CHAR   *pszDeviceName,
                             DWORD  dwDeviceLineCounter,
                             HPORT  *phport,
                             HANDLE hnotifier,
                             DWORD  *pdwFlags);

DWORD APIENTRY RasLinkGetStatistics( HANDLE hConnection,
                                     HCONN hConn,
                                     DWORD dwSubEntry,
                                     PBYTE pbStats);

DWORD APIENTRY RasConnectionGetStatistics(HANDLE hConnection,
                                          HCONN hConn,
                                          PBYTE pbStats);

DWORD APIENTRY RasGetHportFromConnection(HANDLE hConnection,
                                         HCONN hConn,
                                         HPORT *phport);

DWORD APIENTRY RasReferenceCustomCount(HCONN  hConn,
                                       BOOL   fAddref,
                                       CHAR*  pszPhonebookPath,
                                       CHAR*  pszEntryName,
                                       DWORD* pdwCount);

DWORD APIENTRY RasGetHConnFromEntry(HCONN *phConn,
                                    CHAR  *pszPhonebookPath,
                                    CHAR  *pszEntryName);

DWORD APIENTRY RasGetConnectInfo(
            HPORT            hPort,
            DWORD            *pdwSize,
            RAS_CONNECT_INFO *pConnectInfo
            );

DWORD APIENTRY RasGetDeviceName(
            RASDEVICETYPE   eDeviceType,
            CHAR            *pszDeviceName
            );

DWORD APIENTRY RasGetDeviceNameW(
            RASDEVICETYPE   eDeviceType,
            WCHAR            *pszDeviceName
            );
            
DWORD APIENTRY RasGetCalledIdInfo(
            HANDLE              hConneciton,
            RAS_DEVICE_INFO     *pDeviceInfo,
            DWORD               *pdwSize,
            RAS_CALLEDID_INFO   *pCalledIdInfo
            );

DWORD APIENTRY RasSetCalledIdInfo(
            HANDLE              hConnection,
            RAS_DEVICE_INFO     *pDeviceInfo,
            RAS_CALLEDID_INFO   *pCalledIdInfo,
            BOOL                fWrite
            );


DWORD APIENTRY RasEnableIpSec(HPORT hPort,
                              BOOL  fEnable,
                              BOOL  fServer,
                              RAS_L2TP_ENCRYPTION eDataEncryption
                              );

DWORD APIENTRY RasIsIpSecEnabled(HPORT hPort,
                                 BOOL  *pfIsIpSecEnabled);

DWORD APIENTRY RasGetEapUserInfo(HANDLE hToken,
                                 PBYTE  pbEapInfo,
                                 DWORD  *pdwInfoSize,
                                 GUID   *pGuid,
                                 BOOL   fRouter,
                                 DWORD  dwEapTypeId
                                 );

DWORD APIENTRY RasSetEapUserInfo(HANDLE hToken,
                                 GUID   *pGuid,
                                 PBYTE  pbUserInfo,
                                 DWORD  dwInfoSize,
                                 BOOL   fClear,
                                 BOOL   fRouter,
                                 DWORD  dwEapTypeId
                                 );

DWORD APIENTRY RasSetEapLogonInfo(HPORT hPort,
                                  BOOL fLogon,
                                  RASEAPINFO *pEapInfo);

DWORD APIENTRY RasSendNotification(RASEVENT *pRasEvent);

DWORD APIENTRY RasGetNdiswanDriverCaps(
                HANDLE                  hConnection,
                RAS_NDISWAN_DRIVER_INFO *pInfo);

DWORD APIENTRY RasGetBandwidthUtilization(
                HPORT hPort,
                RAS_GET_BANDWIDTH_UTILIZATION *pUtilization);

DWORD APIENTRY RasGetProtocolInfo(
                      HANDLE hConnection,
                      RASMAN_GET_PROTOCOL_INFO *pInfo);

BOOL IsRasmanProcess();

DWORD APIENTRY RasGetCustomScriptDll(CHAR *pszCustomDll);

DWORD DwRasGetHostByName(CHAR *pszHostName, 
                   DWORD **ppdwAddress, 
                   DWORD *pcAddresses);

DWORD RasIsTrustedCustomDll(
            HANDLE hConnection,
            WCHAR *pwszCustomDll, 
            BOOL *pfResult);

DWORD RasDoIke(
            HANDLE hConnection,
            HPORT  hPort,
            DWORD  *pdwStatus);

#if (WINVER >= 0x501)

DWORD RasSetCommSettings(
            HPORT hPort,
            RASCOMMSETTINGS *pRasCommSettings,
            PVOID pv);
#endif            

DWORD
RasSetKey(
    HANDLE hConnection,
    GUID   *pGuid,
    DWORD  dwMask,
    DWORD  cbkey,
    PBYTE  pbkey);

DWORD
RasGetKey(
    HANDLE hConnection,
    GUID   *pGuid,
    DWORD  dwMask,
    DWORD  *pcbkey,
    PBYTE  pbkey);

DWORD
RasSetAddressDisable(
    WCHAR *pszAddress,
    BOOL   fDisable);

DWORD 
RasGetDevConfigEx( HANDLE hConnection,
                        HPORT hport,
                        PCHAR devicetype,
                        PBYTE config,
                        DWORD* size);

DWORD APIENTRY
RasSendCreds(IN HPORT hport,
                 IN CHAR controlchar);


DWORD APIENTRY
RasGetUnicodeDeviceName(IN HPORT hport,
                        IN WCHAR *wszDeviceName);

DWORD APIENTRY
RasmanUninitialize();
                        
DWORD APIENTRY
RasGetBestInterface( IN DWORD DestAddr,
                     OUT DWORD *pdwBestIf,
                     OUT DWORD *pdwMask);

DWORD APIENTRY
RasIsPulseDial(IN HPORT hport,
               OUT BOOL *pfPulseDial);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\rasppp.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** rasppp.h
** Remote Access PPP
** Public PPP client API and server API header
*/

#ifndef _RASPPP_H_
#define _RASPPP_H_

#include <ras.h>
#include <mprapi.h>     // For definitions of IPADDRESSLEN,IPXADDRESSLEN 
                        // and ATADDRESSLEN
#include <wincrypt.h>   // for DATA_BLOB                        

#define MAXPPPFRAMESIZE 1500
#define PARAMETERBUFLEN 500

/*---------------------------------------------------------------------------
** PPP Engine -> Client/DDM messages
**---------------------------------------------------------------------------
*/

/* Client PPP configuration values set with RasPppStart.
*/
typedef struct _PPP_CONFIG_INFO
{
    DWORD dwConfigMask;
    DWORD dwCallbackDelay;
}
PPP_CONFIG_INFO;

/* dwConfigMask bit values.
**
** Note: Due to the implentation of compression and encryption in the drivers,
**       'UseSwCompression' and 'RequireMsChap' must be set, whenever
**       'RequireEncryption' is set.
*/
#define PPPCFG_UseCallbackDelay         0x00000001
#define PPPCFG_UseSwCompression         0x00000002
#define PPPCFG_ProjectNbf               0x00000004
#define PPPCFG_ProjectIp                0x00000008
#define PPPCFG_ProjectIpx               0x00000010
#define PPPCFG_ProjectAt                0x00000020
#define PPPCFG_NegotiateSPAP            0x00000040
#define PPPCFG_RequireEncryption        0x00000080
#define PPPCFG_NegotiateMSCHAP          0x00000100
#define PPPCFG_UseLcpExtensions         0x00000200
#define PPPCFG_NegotiateMultilink       0x00000400
#define PPPCFG_AuthenticatePeer         0x00000800
#define PPPCFG_RequireStrongEncryption  0x00001000
#define PPPCFG_NegotiateBacp            0x00002000
#define PPPCFG_AllowNoAuthentication    0x00004000
#define PPPCFG_NegotiateEAP             0x00008000
#define PPPCFG_NegotiatePAP             0x00010000
#define PPPCFG_NegotiateMD5CHAP         0x00020000
#define PPPCFG_RequireIPSEC             0x00040000
#define PPPCFG_DisableEncryption        0x00080000
#define PPPCFG_UseLmPassword            0x00200000
#define PPPCFG_AllowNoAuthOnDCPorts     0x00400000
#define PPPCFG_NegotiateStrongMSCHAP    0x00800000
#define PPPCFG_NoCallback               0x01000000
#define PPPCFG_MachineAuthentication    0x02000000
#define PPPCFG_ResumeFromHibernate      0x04000000

/*
**New config flag added for whistler.  This is used
**for ras audio accelerator
*/
#define PPPCFG_AudioAccelerator         0x02000000

#define PPP_FAILURE_REMOTE_DISCONNECT 0x00000001

/* PPP stopped message sent by ppp to bring down the link
*/
typedef struct _PPP_STOPPED
{
    DWORD dwFlags;
}
PPP_STOPPED;

/* PPP error notification returned by RasPppGetInfo.
*/
typedef struct _PPP_FAILURE
{
    DWORD dwError;
    DWORD dwExtendedError;  // 0 if none
}
PPP_FAILURE;


/* PPP control protocol results returned by RasPppGetInfo.
*/
typedef struct _PPP_NBFCP_RESULT
{
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szName[ NETBIOS_NAME_LEN + 1 ];
    WCHAR wszWksta[ NETBIOS_NAME_LEN + 1 ];
}
PPP_NBFCP_RESULT;

typedef struct _PPP_IPCP_RESULT
{
    DWORD dwError;

    BOOL  fSendVJHCompression;
    BOOL  fReceiveVJHCompression;

    DWORD dwLocalAddress;
    DWORD dwLocalWINSAddress;
    DWORD dwLocalWINSBackupAddress;
    DWORD dwLocalDNSAddress;
    DWORD dwLocalDNSBackupAddress;

    DWORD dwRemoteAddress;
    DWORD dwRemoteWINSAddress;
    DWORD dwRemoteWINSBackupAddress;
    DWORD dwRemoteDNSAddress;
    DWORD dwRemoteDNSBackupAddress;
}
PPP_IPCP_RESULT;

typedef struct _PPP_IPXCP_RESULT
{
    DWORD dwError;
    BYTE  bLocalAddress[10];
    BYTE  bRemoteAddress[10];
}
PPP_IPXCP_RESULT;

typedef struct _PPP_ATCP_RESULT
{
    DWORD dwError;
    DWORD dwLocalAddress;
    DWORD dwRemoteAddress;
}
PPP_ATCP_RESULT;

typedef struct _PPP_CCP_RESULT
{
    DWORD dwError;
    DWORD dwSendProtocol;
    DWORD dwSendProtocolData;
    DWORD dwReceiveProtocol;
    DWORD dwReceiveProtocolData;
}
PPP_CCP_RESULT;

#define PPPLCPO_PFC           0x00000001
#define PPPLCPO_ACFC          0x00000002
#define PPPLCPO_SSHF          0x00000004
#define PPPLCPO_DES_56        0x00000008
#define PPPLCPO_3_DES         0x00000010

typedef struct _PPP_LCP_RESULT
{
    /* Valid handle indicates one of the possibly multiple connections to
    ** which this connection is bundled. INVALID_HANDLE_VALUE indicates the
    ** connection is not bundled.
    */
    HPORT hportBundleMember;

    DWORD dwLocalAuthProtocol;
    DWORD dwLocalAuthProtocolData;
    DWORD dwLocalEapTypeId;
    DWORD dwLocalFramingType;
    DWORD dwLocalOptions;               // Look at PPPLCPO_*
    DWORD dwRemoteAuthProtocol;
    DWORD dwRemoteAuthProtocolData;
    DWORD dwRemoteEapTypeId;
    DWORD dwRemoteFramingType;
    DWORD dwRemoteOptions;              // Look at PPPLCPO_*
    CHAR* szReplyMessage;
}
PPP_LCP_RESULT;


typedef struct _PPP_PROJECTION_RESULT
{
    PPP_NBFCP_RESULT nbf;
    PPP_IPCP_RESULT  ip;
    PPP_IPXCP_RESULT ipx;
    PPP_ATCP_RESULT  at;
    PPP_CCP_RESULT   ccp;
    PPP_LCP_RESULT   lcp;
}
PPP_PROJECTION_RESULT;

/* PPP error notification 
*/
typedef struct _PPPDDM_FAILURE
{
    DWORD dwError;
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szLogonDomain[ DNLEN + 1 ];
}
PPPDDM_FAILURE;


/* Call back configuration information received by PPPDDMMSG routine.
*/
typedef struct _PPPDDM_CALLBACK_REQUEST
{
    BOOL  fUseCallbackDelay;
    DWORD dwCallbackDelay;
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
}
PPPDDM_CALLBACK_REQUEST;

/* BAP request to callback the remote peer
*/
typedef struct _PPPDDM_BAP_CALLBACK_REQUEST
{
    HCONN hConnection;
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
}
PPPDDM_BAP_CALLBACK_REQUEST;

/* Authentication information received by PPPDDMMSG routine.
*/
typedef struct _PPPDDM_AUTH_RESULT
{
    CHAR    szUserName[ UNLEN + 1 ];
    CHAR    szLogonDomain[ DNLEN + 1 ];
    BOOL    fAdvancedServer;
}
PPPDDM_AUTH_RESULT;

/* Notification of a new BAP link up
*/
typedef struct _PPPDDM_NEW_BAP_LINKUP
{
    HRASCONN    hRasConn;

}PPPDDM_NEW_BAP_LINKUP;

/* Notification of a new Bundle
*/
typedef struct _PPPDDM_NEW_BUNDLE
{
    PBYTE   pClientInterface;
    PBYTE   pQuarantineIPFilter;
    PBYTE   pFilter;
    BOOL    fQuarantinePresent;

} PPPDDM_NEW_BUNDLE;

/* Client should invoke EAP UI dialog
*/
typedef struct _PPP_INVOKE_EAP_UI
{
    DWORD       dwEapTypeId;
    DWORD       dwContextId;
    PBYTE       pUIContextData;
    DWORD       dwSizeOfUIContextData;

}PPP_INVOKE_EAP_UI;

/* Client should save per-connection data
*/
typedef struct _PPP_SET_CUSTOM_AUTH_DATA
{
    BYTE*       pConnectionData;
    DWORD       dwSizeOfConnectionData;

}PPP_SET_CUSTOM_AUTH_DATA;

/* Notification of port addition\removal\usage change
*/
typedef struct _PPPDDM_PNP_NOTIFICATION 
{
    PNP_EVENT_NOTIF PnPNotification;

} PPPDDM_PNP_NOTIFICATION;

/* Notification of PPP session termination
*/
typedef struct _PPPDDM_STOPPED
{
    DWORD   dwReason;

} PPPDDM_STOPPED;

typedef enum _PPP_MSG_ID
{
    PPPMSG_PppDone = 0,             // PPP negotiated all successfully.
    PPPMSG_PppFailure,              // PPP failure (fatal error including
                                    // authentication failure with no
                                    // retries), disconnect line.
    PPPMSG_AuthRetry,               // Authentication failed, have retries.
    PPPMSG_Projecting,              // Executing specified NCPs.
    PPPMSG_ProjectionResult,        // NCP completion status.
    PPPMSG_CallbackRequest = 5,     // Server needs "set-by-caller" number.
    PPPMSG_Callback,                // Server is about to call you back.
    PPPMSG_ChangePwRequest,         // Server needs new password (expired).
    PPPMSG_LinkSpeed,               // Calculating link speed.
    PPPMSG_Progress,                // A retry or other sub-state of
                                    // progress has been reached in the
                                    // current state.
    PPPMSG_Stopped = 10,            // Response to RasPppStop indicating
                                    // PPP engine has stopped.
    PPPMSG_InvokeEapUI,             // Client should invoke EAP UI dialog
    PPPMSG_SetCustomAuthData,       // Save per-connection data
    PPPDDMMSG_PppDone,              // PPP negotiated successfully.
    PPPDDMMSG_PppFailure,           // PPP server failure (fatal error),
                                    // disconnect line.
    PPPDDMMSG_CallbackRequest = 15, // Callback client now.
    PPPDDMMSG_BapCallbackRequest,   // Callback remote BAP peer.
    PPPDDMMSG_Authenticated,        // Client has been authenticated.
    PPPDDMMSG_Stopped,              // Response to PppDdmStop indicating
                                    // PPP engine has stopped.
    PPPDDMMSG_NewLink,              // Client is a new link in a bundle
    PPPDDMMSG_NewBundle = 20,       // Client is a new bundle
    PPPDDMMSG_NewBapLinkUp,         // Client is a new BAP link in a bundle
    PPPDDMMSG_PnPNotification,      // Port is being added or removed or usage
                                    // is being changed, transport being added
                                    // or removed etc.
    PPPDDMMSG_PortCleanedUp        // PPP port control block is now cleaned up
        
} PPP_MSG_ID;

/* Client/DDM notifications read with RasPppGetInfo.
*/
typedef struct _PPP_MESSAGE
{
    struct _PPP_MESSAGE *   pNext;
    DWORD                   dwError;
    PPP_MSG_ID              dwMsgId;
    HPORT                   hPort;

    union
    {
        /* dwMsgId is PPPMSG_ProjectionResult or PPPDDMMSG_Done.
        */
        PPP_PROJECTION_RESULT ProjectionResult;

        /* dwMsgId is PPPMSG_Failure.
        */
        PPP_FAILURE Failure;

        /*
        */
        PPP_STOPPED Stopped;

        /* dwMsgId is PPPMSG_InvokeEapUI         
        */
        PPP_INVOKE_EAP_UI InvokeEapUI;

        /* dwMsgId is PPPMSG_SetCustomAuthData         
        */
        PPP_SET_CUSTOM_AUTH_DATA SetCustomAuthData;

        /* dwMsgId is PPPDDMMSG_Failure.
        */
        PPPDDM_FAILURE DdmFailure;

        /* dwMsgId is PPPDDMMSG_Authenticated.
        */
        PPPDDM_AUTH_RESULT AuthResult;

        /* dwMsgId is PPPDDMMSG_CallbackRequest.
        */
        PPPDDM_CALLBACK_REQUEST CallbackRequest;

        /* dwMsgId is PPPDDMMSG_BapCallbackRequest.
        */
        PPPDDM_BAP_CALLBACK_REQUEST BapCallbackRequest;

        /* dwMsgId is PPPDDMMSG_NewBapLinkUp         
        */
        PPPDDM_NEW_BAP_LINKUP BapNewLinkUp;

        /* dwMsgId is PPPDDMMSG_NewBundle   
        */
        PPPDDM_NEW_BUNDLE DdmNewBundle;

        /* dwMsgId is PPPDDMMSG_PnPNotification   
        */
        PPPDDM_PNP_NOTIFICATION DdmPnPNotification;

        /* dwMsgId is PPPDDMMSG_Stopped   
        */
        PPPDDM_STOPPED DdmStopped;
    }
    ExtraInfo;
}
PPP_MESSAGE;

/*---------------------------------------------------------------------------
** Client/DDM -> Engine messages
**---------------------------------------------------------------------------
*/

/* Set of interface handles passed from DIM to PPP
*/
typedef struct _PPP_INTERFACE_INFO
{
    ROUTER_INTERFACE_TYPE   IfType;
    HANDLE                  hIPInterface;
    HANDLE                  hIPXInterface;
    CHAR                    szzParameters[ PARAMETERBUFLEN ];
}
PPP_INTERFACE_INFO;

typedef struct _PPP_BAPPARAMS
{
    DWORD               dwDialMode;
    DWORD               dwDialExtraPercent;
    DWORD               dwDialExtraSampleSeconds;
    DWORD               dwHangUpExtraPercent;
    DWORD               dwHangUpExtraSampleSeconds;
}
PPP_BAPPARAMS;

typedef struct _PPP_EAP_UI_DATA
{
    DWORD               dwContextId;
    PBYTE               pEapUIData;
    DWORD               dwSizeOfEapUIData;
}
PPP_EAP_UI_DATA;

#define  PPPFLAGS_DisableNetbt         0x00000001

/* Parameters to start client PPP on a port.
*/
typedef struct _PPP_START
{
    CHAR                szPortName[ MAX_PORT_NAME +1 ];
    CHAR                szUserName[ UNLEN + 1 ];
    CHAR                szPassword[ PWLEN + 1 ];
    CHAR                szDomain[ DNLEN + 1 ];
    LUID                Luid;
    PPP_CONFIG_INFO     ConfigInfo;
    CHAR                szzParameters[ PARAMETERBUFLEN ];
    BOOL                fThisIsACallback;
    BOOL                fRedialOnLinkFailure;
    HANDLE              hEvent;
    DWORD               dwPid;
    PPP_INTERFACE_INFO  PppInterfaceInfo;
    DWORD               dwAutoDisconnectTime;
    PPP_BAPPARAMS       BapParams;    
    CHAR *              pszPhonebookPath;
    CHAR *              pszEntryName;
    CHAR *              pszPhoneNumber;
    HANDLE              hToken;
    PRAS_CUSTOM_AUTH_DATA pCustomAuthConnData;
    DWORD               dwEapTypeId;
    BOOL                fLogon;
    BOOL                fNonInteractive;
    DWORD               dwFlags;
    PRAS_CUSTOM_AUTH_DATA pCustomAuthUserData;
    PPP_EAP_UI_DATA     EapUIData;
    // CHAR                chSeed;         //Seed used to encode the password
    DATA_BLOB           DBPassword;
}
PPP_START;

/* Parameters to stop client/server PPP on a port.
*/
typedef struct _PPP_STOP
{
    DWORD               dwStopReason;
}
PPP_STOP;

/* Parameters to start server PPP on a port.
*/
typedef struct _PPPDDM_START
{
    DWORD               dwAuthRetries;
    CHAR                szPortName[MAX_PORT_NAME+1];
    CHAR                achFirstFrame[ MAXPPPFRAMESIZE ];
    DWORD               cbFirstFrame;
}
PPPDDM_START;

/* Parameters to notify PPP that callback is complete.
*/
typedef struct _PPP_CALLBACK_DONE
{
    CHAR                szCallbackNumber[ MAX_PHONE_NUMBER_LEN + 1 ];
}
PPP_CALLBACK_DONE;

/* Parameters to notify server of "set-by-caller" callback options.
*/
typedef struct _PPP_CALLBACK
{
    CHAR                szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
}
PPP_CALLBACK;


/* Parameters to notify server of new password after it's told client the
** password has expired.  The user name and old password are also provided
** since they are required to support the auto-logon case.
*/
typedef struct _PPP_CHANGEPW
{
    CHAR                szUserName[ UNLEN + 1 ];
    CHAR                szOldPassword[ PWLEN + 1 ];
    CHAR                szNewPassword[ PWLEN + 1 ];
    // CHAR                chSeed;         //Seed used to encode the password
    DATA_BLOB           DBPassword;
    DATA_BLOB           DBOldPassword;
}
PPP_CHANGEPW;


/* Parameters to notify server of new authentication credentials after it's
** told client the original credentials are invalid but a retry is allowed.
*/
typedef struct _PPP_RETRY
{
    CHAR                szUserName[ UNLEN + 1 ];
    CHAR                szPassword[ PWLEN + 1 ];
    CHAR                szDomain[ DNLEN + 1 ];
    // CHAR                chSeed;         //Seed used to encode the password
    DATA_BLOB           DBPassword;
}
PPP_RETRY;

/*
** Parameters to notify PPP that a packet has arrived from the peer
*/
typedef struct _PPP_RECEIVE 
{
    DWORD               dwNumBytes;     // The number of bytes in the buffer
    BYTE*               pbBuffer;       // The data sent by the peer
}
PPP_RECEIVE;

/*
** Parameters to notify PPP that a BAP event (add/drop link) has fired
*/
typedef struct _PPP_BAP_EVENT
{
    BOOL                fAdd;           // Add a link iff TRUE
    BOOL                fTransmit;      // Send threshold iff TRUE
    DWORD               dwSendPercent;  // Send bandwidth utilization
    DWORD               dwRecvPercent;  // Recv bandwidth utilization
}
PPP_BAP_EVENT;

typedef struct _PPP_BAP_CALLBACK_RESULT 
{
    DWORD               dwCallbackResultCode;
}
PPP_BAP_CALLBACK_RESULT;

typedef struct _PPP_DHCP_INFORM 
{
    WCHAR*              wszDevice;
    DWORD               dwNumDNSAddresses;
    DWORD*              pdwDNSAddresses;
    DWORD               dwWINSAddress1;
    DWORD               dwWINSAddress2;
    DWORD               dwSubnetMask;
    CHAR*               szDomainName;
    PBYTE               pbDhcpRoutes;
}
PPP_DHCP_INFORM;

typedef struct _PPP_PROTOCOL_EVENT
{
    USHORT              usProtocolType;
    ULONG               ulFlags;
} 
PPP_PROTOCOL_EVENT;

typedef struct _PPP_IP_ADDRESS_LEASE_EXPIRED
{
    ULONG               nboIpAddr;
}
PPP_IP_ADDRESS_LEASE_EXPIRED;

typedef struct _PPP_POST_LINEDOWN
{
	VOID * 				pPcb;		//This is required because PCB has been already removed from the 
									//table
}PPP_POST_LINE_DOWN;
/* Client/DDM->Engine messages.
*/
typedef struct _PPPE_MESSAGE
{
    DWORD   dwMsgId;
    HPORT   hPort;
    HCONN   hConnection;

    union
    {
        PPP_START           Start;              // PPPEMSG_Start
        PPP_STOP            Stop;               // PPPEMSG_Stop
        PPP_CALLBACK        Callback;           // PPPEMSG_Callback
        PPP_CHANGEPW        ChangePw;           // PPPEMSG_ChangePw
        PPP_RETRY           Retry;              // PPPEMSG_Retry
        PPP_RECEIVE         Receive;            // PPPEMSG_Receive
        PPP_BAP_EVENT       BapEvent;           // PPPEMSG_BapEvent
        PPPDDM_START        DdmStart;           // PPPEMSG_DdmStart
        PPP_CALLBACK_DONE   CallbackDone;       // PPPEMSG_DdmCallbackDone
        PPP_INTERFACE_INFO  InterfaceInfo;      // PPPEMSG_DdmInterfaceInfo
        PPP_BAP_CALLBACK_RESULT 
                            BapCallbackResult;  // PPPEMSG_DdmBapCallbackResult
        PPP_DHCP_INFORM     DhcpInform;         // PPPEMSG_DhcpInform
        PPP_EAP_UI_DATA     EapUIData;          // PPPEMSG_EapUIData
        PPP_PROTOCOL_EVENT  ProtocolEvent;      // PPPEMSG_ProtocolEvent
        PPP_IP_ADDRESS_LEASE_EXPIRED            // PPPEMSG_IpAddressLeaseExpired
                            IpAddressLeaseExpired;
		PPP_POST_LINE_DOWN		PostLineDown;		//PPPEMSG_PostLineDown
                            
    }
    ExtraInfo;
}
PPPE_MESSAGE;

/* PPPE_MESSAGE dwMsgId codes for client and DDM sessions.
*/
typedef enum _PPPE_MSG_ID
{
    PPPEMSG_Start,              // Starts client PPP on a port.
    PPPEMSG_Stop,               // Stops PPP on a port.
    PPPEMSG_Callback,           // Provides "set-by-caller" number to server.
    PPPEMSG_ChangePw,           // Provides new password (expired) to server.
    PPPEMSG_Retry,              // Provides new credentials for authentication.
    PPPEMSG_Receive,            // A packet has arrived.
    PPPEMSG_LineDown,           // The line has gone down.
    PPPEMSG_ListenResult,       // The result of a call to RasPortListen
    PPPEMSG_BapEvent,           // A BAP event (add/drop link) has fired.
    PPPEMSG_DdmStart,           // Starts server PPP on a port.
    PPPEMSG_DdmCallbackDone,    // Notify PPP that callback is complete.
    PPPEMSG_DdmInterfaceInfo,   // Interface handles from DDM
    PPPEMSG_DdmBapCallbackResult,// Result of a BAP callback request.
    PPPEMSG_DhcpInform,         // The result of a DHCPINFORM
    PPPEMSG_EapUIData,          // Data from EAP interactive UI
    PPPEMSG_DdmChangeNotification, // Change notification in DDM
    PPPEMSG_ProtocolEvent,      // Protocol added/removed notification
    PPPEMSG_IpAddressLeaseExpired,  // IP address lease expired. Used by rasiphlp
    PPPEMSG_PostLineDown,			//Accounting completed after linedown
    PPPEMSG_DdmRemoveQuarantine,    // Remove quarantine
    PPPEMSG_ResumeFromHibernate
} PPPE_MSG_ID;

//
// Prototypes of function exported by RASPPP.DLL for use by RASMAN
//

DWORD APIENTRY
StartPPP(
    DWORD NumPorts
    /*,DWORD (*SendPPPMessageToRasman)( PPP_MESSAGE * PppMsg )*/
);

DWORD APIENTRY
StopPPP(
    HANDLE hEventStopPPP
);

DWORD APIENTRY
SendPPPMessageToEngine(
    IN PPPE_MESSAGE* pMessage
);

//
// PPP client side Apis
//

DWORD APIENTRY
RasPppStop(
    IN HPORT                hPort
);

DWORD APIENTRY
RasPppCallback(
    IN HPORT                hPort,
    IN CHAR*                pszCallbackNumber
);

DWORD APIENTRY
RasPppChangePassword(
    IN HPORT                hPort,
    IN CHAR*                pszUserName,
    IN CHAR*                pszOldPassword,
    IN CHAR*                pszNewPassword
);

DWORD APIENTRY
RasPppGetInfo(
    IN  HPORT               hPort,
    OUT PPP_MESSAGE*        pMsg
);

DWORD APIENTRY
RasPppRetry(
    IN HPORT                hPort,
    IN CHAR*                pszUserName,
    IN CHAR*                pszPassword,
    IN CHAR*                pszDomain
);

DWORD APIENTRY
RasPppStart(
    IN HPORT                hPort,
    IN CHAR*                pszPortName,
    IN CHAR*                pszUserName,
    IN CHAR*                pszPassword,
    IN CHAR*                pszDomain,
    IN LUID*                pLuid,
    IN PPP_CONFIG_INFO*     pConfigInfo,
    IN LPVOID               pPppInterfaceInfo,
    IN CHAR*                pszzParameters,
    IN BOOL                 fThisIsACallback,
    IN HANDLE               hEvent,
    IN DWORD                dwAutoDisconnectTime,
    IN BOOL                 fRedialOnLinkFailure,
    IN PPP_BAPPARAMS*       pBapParams,
    IN BOOL                 fNonInteractive,
    IN DWORD                dwEapTypeId,
    IN DWORD                dwFlags
);

//
// DDM API prototypes
//
DWORD
PppDdmInit(
    IN  VOID    (*SendPPPMessageToDdm)( PPP_MESSAGE * PppMsg ),
    IN  DWORD   dwServerFlags,
    IN  DWORD   dwLoggingLevel,
    IN  DWORD   dwNASIpAddress,
    IN  BOOL    fRadiusAuthentication,
    IN  LPVOID  lpfnRasAuthProviderAuthenticateUser,
    IN  LPVOID  lpfnRasAuthProviderFreeAttributes,
    IN  LPVOID  lpfnRasAcctProviderStartAccounting,
    IN  LPVOID  lpfnRasAcctProviderInterimAccounting,
    IN  LPVOID  lpfnRasAcctProviderStopAccounting,
    IN  LPVOID  lpfnRasAcctProviderFreeAttributes,
    IN  LPVOID  lpfnGetNextAccountingSessionId
);

VOID
PppDdmDeInit(
);

DWORD
PppDdmCallbackDone(
    IN HPORT                hPort,
    IN WCHAR*               pwszCallbackNumber
);

DWORD
PppDdmStart(
    IN HPORT                hPort,
    IN WCHAR*               wszPortName,
    IN CHAR*                pchFirstFrame,
    IN DWORD                cbFirstFrame,
    IN DWORD                dwAuthRetries
);

DWORD
PppDdmStop(
    IN HPORT                hPort,
    IN DWORD                dwStopReason 
);

DWORD
PppDdmChangeNotification(
    IN DWORD                dwServerFlags,
    IN DWORD                dwLoggingLevel
);

DWORD
PppDdmSendInterfaceInfo(
    IN HCONN                hConnection,
    IN PPP_INTERFACE_INFO * pInterfaceInfo 
);

DWORD
PppDdmBapCallbackResult(
    IN HCONN                hConnection,
    IN DWORD                dwBapCallbackResultCode
);

DWORD
PppDdmRemoveQuarantine(
    IN HCONN                hConnection
);    

#endif // _RASPPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\rmmgm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: RmMgm.h
//
// History:
//      V Raman	June-24-1997  Created.
//
// Definitions for entry points into IP router manager for MGM
//============================================================================

#ifndef	_RMMGM_H_
#define _RMMGM_H_


//----------------------------------------------------------------------------
// constants used for the field IPMGM_GLOBAL_CONFIG::dwLogLevel
//----------------------------------------------------------------------------

#define IPMGM_LOGGING_NONE      0
#define IPMGM_LOGGING_ERROR     1
#define IPMGM_LOGGING_WARN      2
#define IPMGM_LOGGING_INFO      3


//----------------------------------------------------------------------------
//
// Prototypes for callbacks into IP router manager.
// These callbacks are for setting, deleting and querying MFEs in the 
// kernel mode forwarder.
//
//----------------------------------------------------------------------------


typedef 
DWORD ( * PMGM_ADD_MFE_CALLBACK )(
    IN          PIPMCAST_MFE            pimmEntry
);


typedef 
DWORD ( * PMGM_DELETE_MFE_CALLBACK )(
    IN          PIPMCAST_DELETE_MFE     pimdmEntry
);


typedef
DWORD ( * PMGM_GET_MFE_CALLBACK )(
    IN OUT      PIPMCAST_MFE_STATS      pimmsStats
);


typedef
BOOL ( * PMGM_HAS_BOUNDARY_CALLBACK )(
    IN          DWORD                   dwIfIndex,
    IN          DWORD                   dwGroupAddr
);



//----------------------------------------------------------------------------
// Callbacks supplied by the router manager.
// Hash Table sizes provided by router manager (?) 
//----------------------------------------------------------------------------


typedef struct _ROUTER_MANAGER_CONFIG 
{
    DWORD                               dwLogLevel;
    
    //------------------------------------------------------------------------
    // Hash table constants and callback functions
    //------------------------------------------------------------------------
    
    DWORD                               dwIfTableSize;

    DWORD                               dwGrpTableSize;

    DWORD                               dwSrcTableSize;


    //------------------------------------------------------------------------
    // Callback functions to update MFE entries in the kernel mode forwarder
    //------------------------------------------------------------------------

    PMGM_ADD_MFE_CALLBACK               pfnAddMfeCallback;

    PMGM_DELETE_MFE_CALLBACK            pfnDeleteMfeCallback;

    PMGM_GET_MFE_CALLBACK               pfnGetMfeCallback;

    PMGM_HAS_BOUNDARY_CALLBACK          pfnHasBoundaryCallback;

} ROUTER_MANAGER_CONFIG, *PROUTER_MANAGER_CONFIG;



//----------------------------------------------------------------------------
// prototype declaration for callback into MGM to indicate
// deletion of MFE from the the kernel mode forwarder.  
//
// Used by IP router manager
//----------------------------------------------------------------------------

typedef
DWORD ( * PMGM_INDICATE_MFE_DELETION )(
    IN          DWORD                   dwEntryCount,
    IN          PIPMCAST_DELETE_MFE     pimdmDeletedMfes
);


typedef
DWORD ( * PMGM_NEW_PACKET_INDICATION )(
    IN              DWORD               dwSourceAddr,
    IN              DWORD               dwGroupAddr,
    IN              DWORD               dwInIfIndex,
    IN              DWORD               dwInIfNextHopAddr,
    IN              DWORD               dwHdrSize,
    IN              PBYTE               pbPacketHdr
);


typedef
DWORD ( * PMGM_WRONG_IF_INDICATION )(
    IN              DWORD               dwSourceAddr,
    IN              DWORD               dwGroupAddr,
    IN              DWORD               dwInIfIndex,
    IN              DWORD               dwInIfNextHopAddr,
    IN              DWORD               dwHdrSize,
    IN              PBYTE               pbPacketHdr
);


typedef
DWORD ( * PMGM_BLOCK_GROUPS )(
    IN              DWORD               dwFirstGroup,
    IN              DWORD               dwLastGroup,
    IN              DWORD               dwIfIndex,
    IN              DWORD               dwIfNextHopAddr
);


typedef
DWORD ( * PMGM_UNBLOCK_GROUPS )(
    IN              DWORD               dwFirstGroup,
    IN              DWORD               dwLastGroup,
    IN              DWORD               dwIfIndex,
    IN              DWORD               dwIfNextHopAddr
);


//----------------------------------------------------------------------------
// Callbacks supplied to the router manager.
//
//
//----------------------------------------------------------------------------

typedef struct _MGM_CALLBACKS 
{
    PMGM_INDICATE_MFE_DELETION          pfnMfeDeleteIndication;

    PMGM_NEW_PACKET_INDICATION          pfnNewPacketIndication;

    PMGM_WRONG_IF_INDICATION            pfnWrongIfIndication;
    
    PMGM_BLOCK_GROUPS                   pfnBlockGroups;

    PMGM_UNBLOCK_GROUPS                 pfnUnBlockGroups;
    
} MGM_CALLBACKS, *PMGM_CALLBACKS;



//----------------------------------------------------------------------------
// Initialization routines invoked by router manager
//
//----------------------------------------------------------------------------

DWORD
MgmInitialize(
    IN          PROUTER_MANAGER_CONFIG      prmcRmConfig,
    IN OUT      PMGM_CALLBACKS              pmcCallbacks
);


DWORD
MgmDeInitialize(
);



#endif // _RMMGM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\rtcfg.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    rtcfg.h
//
// History:
//  05/04/96    Abolade-Gbadegesin  Created.
//
// Contains private declarations for the router-configuration access APIs.
//
// The handles supplied by the MprConfig APIs are actually pointers
// to context-blocks defined below. MprConfigServerConnect supplies
// a handle which is a pointer to a SERVERCB. The other handles are pointers
// to contexts which are in lists hanging off the master SERVERCB.
// For instance, when MprConfigInterfaceGetHandle is called, an INTERFACECB
// is allocated and linked into the SERVERCB's list of interfaces,
// and the registry key for the interface is saved in the INTERFACECB.
// When MprConfigServerDisconnect is called, all the open registry keys
// are closed and all the contexts are freed.
// 
// The following shows the structure of the relevant sections of the registry:
//
//  HKLM\System\CurrentControlSet\Services
//      RemoteAccess
//          Parameters
//              RouterType              = REG_DWORD     0x0
//          RouterManagers
//              Stamp                   = REG_DWORD     0x0
//              IP
//                  ProtocolId          = REG_SZ        0x21
//                  DLLPath             = REG_EXPAND_SZ ...
//          Interfaces
//              Stamp                   = REG_DWORD     0x0 
//              0
//                  Stamp               = REG_DWORD     0x0
//                  InterfaceName       = REG_SZ        EPRO1
//                  Type                = REG_DWORD     0x3
//                  IP
//                      ProtocolId      = REG_DWORD     0x21
//
// When modifying this file, respect its coding conventions and organization.
//============================================================================

#ifndef _RTCFG_H_
#define _RTCFG_H_

//----------------------------------------------------------------------------
// Structure:   SERVERCB
//
// Context block created as a handle by 'MprConfigServerConnect'.
//----------------------------------------------------------------------------

typedef struct _SERVERCB {
    //
    // Signiture to validate this structure
    //
    DWORD       dwSigniture;
    //
    // name of router machine
    //
    LPWSTR      lpwsServerName;
    //
    // handle to remote HKEY_LOCAL_MACHINE
    //
    HKEY        hkeyMachine;
    //
    // handle to remote RemoteAccess\Parameters registry key,
    // and last-write-time
    //
    HKEY        hkeyParameters;
    FILETIME    ftParametersStamp;
    //
    // handle to remote RemoteAccess\RouterManagers registry key,
    // and last-write-time
    //
    HKEY        hkeyTransports;
    FILETIME    ftTransportsStamp;
    //
    // handle to remote RemoteAccess\Interfaces registry key,
    // and last-write-time
    //
    HKEY        hkeyInterfaces;
    FILETIME    ftInterfacesStamp;
    //
    // 'RouterType' setting, and flag indicating it is loaded
    //
    DWORD       fRouterType;
    BOOL        bParametersLoaded;
    //
    // head of sorted TRANSPORTCB list, and flag indicating list is loaded
    //
    LIST_ENTRY  lhTransports;
    BOOL        bTransportsLoaded;
    //
    // head of sorted INTERFACECB list, and flag indicating list is loaded
    //
    LIST_ENTRY  lhInterfaces;
    BOOL        bInterfacesLoaded;
    //
    // handle to data used to provide mapping of interface name to guid name
    // and vice versa.
    //
    HANDLE      hGuidMap;
    //
    // reference count to this server control block
    //
    DWORD       dwRefCount;
    
} SERVERCB;



//----------------------------------------------------------------------------
// Structure:   TRANSPORTCB
//
// Context block created as a handle by 'MprConfigTransportGetHandle'.
//----------------------------------------------------------------------------

typedef struct _TRANSPORTCB {

    //
    // transport ID of transport
    //
    DWORD       dwTransportId;
    //
    // name of the registry key for the transport
    //
    LPWSTR      lpwsTransportKey;
    //
    // handle to remote RemoteAccess\RouterManagers subkey for transport
    //
    HKEY        hkey;
    //
    // Deletion flag, set when we detect the transport was removed.
    //
    BOOL        bDeleted;
    //
    // node in the SERVERCB's list of transports
    //
    LIST_ENTRY  leNode;

} TRANSPORTCB;



//----------------------------------------------------------------------------
// Structure:   INTERFACECB
//
// Context block created as a handle by 'MprConfigInterfaceGetHandle'.
//----------------------------------------------------------------------------

typedef struct _INTERFACECB {

    //
    // name of this interface
    //
    LPWSTR      lpwsInterfaceName;
    //
    // name of the registry key for the interface
    //
    LPWSTR      lpwsInterfaceKey;
    //
    // Type of interface (see mprapi.h)
    //
    DWORD       dwIfType;
    //
    // Is this interface marked as persistant?
    //
    BOOL        fEnabled;
    //
    // Dialout hours restriction (optional)
    //
    LPWSTR      lpwsDialoutHoursRestriction;
    //
    // handle to remote RemoteAccess\Interfaces subkey for interface
    //
    HKEY        hkey;
    //
    // Last-write-time for the key, and deletion flag
    //
    FILETIME    ftStamp;
    BOOL        bDeleted;
    //
    // node in the SERVERCB's list of interfaces
    //
    LIST_ENTRY  leNode;
    //
    // head of this interface's sorted IFTRANSPORTCB list,
    // and flag indicating list is loaded
    //
    LIST_ENTRY  lhIfTransports;
    BOOL        bIfTransportsLoaded;

} INTERFACECB;



//----------------------------------------------------------------------------
// Structure:   IFTRANSPORTCB
//
// Context block created as a handle by MprConfigInterfaceGetTransportHandle
//----------------------------------------------------------------------------

typedef struct _IFTRANSPORTCB {

    //
    // transport ID of transport
    //
    DWORD       dwTransportId;
    //
    // name of the registry key for the interface-transport
    //
    LPWSTR      lpwsIfTransportKey;
    //
    // handle to remote RemoteAccess\Interfaces\<interface> subkey for transport
    //
    HKEY        hkey;
    //
    // Deletion flag, set when we detect the interface-transport was removed.
    //
    BOOL        bDeleted;
    //
    // node in an INTERFACECB's list of transports
    //
    LIST_ENTRY  leNode;

} IFTRANSPORTCB;




//----------------------------------------------------------------------------
// Macros:      Malloc
//              Free
//              Free0
//
// Allocations are done from the process-heap using these macros.
//----------------------------------------------------------------------------

#define Malloc(s)           HeapAlloc(GetProcessHeap(), 0, (s))
#define Free(p)             HeapFree(GetProcessHeap(), 0, (p))
#define Free0(p)            ((p) ? Free(p) : TRUE)



//----------------------------------------------------------------------------
// Function:    AccessRouterSubkey
//
// Creates/opens a subkey of the Router service key on 'hkeyMachine'.
// When a key is created, 'lpwsSubkey' must be a child of the Router key.
//----------------------------------------------------------------------------

DWORD
AccessRouterSubkey(
    IN      HKEY            hkeyMachine,
    IN      LPCWSTR          lpwsSubkey,
    IN      BOOL            bCreate,
    OUT     HKEY*           phkeySubkey
    );



//----------------------------------------------------------------------------
// Function:    EnableBackupPrivilege
//
// Enables/disables backup privilege for the current process.
//----------------------------------------------------------------------------

DWORD
EnableBackupPrivilege(
    IN      BOOL            bEnable,
    IN      LPWSTR          pszPrivilege
    );



//----------------------------------------------------------------------------
// Function:    FreeInterface
//
// Frees the context for an interface.
// Assumes the interface is no longer in the list of interfaces.
//----------------------------------------------------------------------------

VOID
FreeInterface(
    IN      INTERFACECB*    pinterface
    );



//----------------------------------------------------------------------------
// Function:    FreeIfTransport
//
// Frees the context for an interface-transport.
// Assumes the interface-transport is no longer in any list.
//----------------------------------------------------------------------------

VOID
FreeIfTransport(
    IN      IFTRANSPORTCB*  piftransport
    );



//----------------------------------------------------------------------------
// Function:    FreeTransport
//
// Frees the context for a transport.
// Assumes the transport is no longer in the list of transports.
//----------------------------------------------------------------------------

VOID
FreeTransport(
    IN      TRANSPORTCB*    ptransport
    );



//----------------------------------------------------------------------------
// Function:    GetLocalMachine
//
// Retrieves the name of the local machine (e.g. "\\MACHINE").
// Assumes the string supplied can hold MAX_COMPUTERNAME_LENGTH + 3 characters.
//----------------------------------------------------------------------------

VOID
GetLocalMachine(
    IN      LPWSTR          lpszMachine
    );


//----------------------------------------------------------------------------
// Function:    GetSizeOfDialoutHoursRestriction
//
// Will return the size of the dialout hours restriction in bytes. This
// is a MULTI_SZ. The count will include the terminating NULL characters.
//----------------------------------------------------------------------------

DWORD
GetSizeOfDialoutHoursRestriction(
    IN LPWSTR   lpwsDialoutHoursRestriction
    );


//----------------------------------------------------------------------------
// Function:    IsNt40Machine
//
// Returns whether the given hkeyMachine belongs to an nt40 registry
//----------------------------------------------------------------------------

DWORD
IsNt40Machine (
    IN      HKEY        hkeyMachine,
    OUT     PBOOL       pbIsNt40
    );


//----------------------------------------------------------------------------
// Function:    LoadIfTransports
//
// Loads all the transports added to an interface.
//----------------------------------------------------------------------------

DWORD
LoadIfTransports(
    IN      INTERFACECB*    pinterface
    );



//----------------------------------------------------------------------------
// Function:    LoadInterfaces
//
// Loads all the interfaces.
//----------------------------------------------------------------------------

DWORD
LoadInterfaces(
    IN      SERVERCB*       pserver
    );



//----------------------------------------------------------------------------
// Function:    LoadParameters
//
// Loads all the parameters
//----------------------------------------------------------------------------

DWORD
LoadParameters(
    IN      SERVERCB*       pserver
    );



//----------------------------------------------------------------------------
// Function:    LoadTransports
//
// Loads all the transports
//----------------------------------------------------------------------------

DWORD
LoadTransports(
    IN      SERVERCB*       pserver
    );



//----------------------------------------------------------------------------
// Function:    QueryValue
//
// Queries the 'hkey' for the value 'lpwsValue', allocating memory
// for the resulting data
//----------------------------------------------------------------------------

DWORD
QueryValue(
    IN      HKEY            hkey,
    IN      LPCWSTR         lpwsValue,
    IN  OUT LPBYTE*         lplpValue,
    OUT     LPDWORD         lpdwSize
    );



//----------------------------------------------------------------------------
// Function:    RegDeleteTree
//
// Removes an entire subtree from the registry.
//----------------------------------------------------------------------------

DWORD
RegDeleteTree(
    IN      HKEY            hkey,
    IN      LPWSTR          lpwsSubkey
    );


//----------------------------------------------------------------------------
// Function:    RestoreAndTranslateInterfaceKey
//
// Restores the interfaces key from the given file and then maps lan interface
// names from friendly versions to their guid equivalents.
//
//----------------------------------------------------------------------------

DWORD 
RestoreAndTranslateInterfaceKey(
    IN SERVERCB * pserver, 
    IN CHAR* pszFileName, 
    IN DWORD dwFlags
    );


//----------------------------------------------------------------------------
// Function:    StrDupW
//
// Returns a heap-allocated copy of the specified string.
//----------------------------------------------------------------------------

LPWSTR
StrDupW(
    IN      LPCWSTR          lpsz
    );



//----------------------------------------------------------------------------
// Function:    TimeStampChanged
//
// Checks the current last-write-time for the given key,
// and returns TRUE if it is different from the given file-time.
// The new last-write-time is saved in 'pfiletime'.
//----------------------------------------------------------------------------

BOOL
TimeStampChanged(
    IN      HKEY            hkey,
    IN  OUT FILETIME*       pfiletime
    );


//----------------------------------------------------------------------------
// Function:    TranslateAndSaveInterfaceKey
//
// Saves the interfaces key in the router's registry into the given file. All
// lan interfaces are stored with friendly interface names.
//
//----------------------------------------------------------------------------

DWORD 
TranslateAndSaveInterfaceKey(
    IN SERVERCB * pserver, 
    IN PWCHAR pwsFileName, 
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );


//----------------------------------------------------------------------------
// Function:    UpdateTimeStamp
//
// Creates (or sets) a value named 'Stamp' under the given key,
// and saves the last-write-time for the key in 'pfiletime'.
//----------------------------------------------------------------------------

DWORD
UpdateTimeStamp(
    IN      HKEY            hkey,
    OUT     FILETIME*       pfiletime
    );

//
// Private ex version of this function that allows you to specify
// whether you want all interfaces loaded, or just those that are 
// up according to pnp. (see MPRFLAG_IF_* for values for dwFlags)
//
DWORD APIENTRY
MprConfigInterfaceEnumInternal(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle,            OPTIONAL
    IN      DWORD                   dwFlags
);


#endif // _RTCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\sainfo.h ===
// Copyright (c) 1998, Microsoft Corporation, all rights reserved
//
// sainfo.h
// Shared Access settings library
// Public header
//
// 10/17/1998   Abolade Gbadegesin

#ifndef _SAINFO_H_
#define _SAINFO_H_

#ifdef __cplusplus
extern "C" {
#endif

#define DEFAULT_SCOPE_ADDRESS   0x0100a8c0
#define DEFAULT_SCOPE_MASK      0x00ffffff

//----------------------------------------------------------------------------
// Data types
//----------------------------------------------------------------------------

// Shared access settings block, containing the application- and server-list
// loaded from the shared access settings file.
//
typedef struct
_SAINFO
{
    // Unsorted list of 'SAAPPLICATION' entries
    //
    LIST_ENTRY ApplicationList;

    // Unsorted list of 'SASERVER' entries
    //
    LIST_ENTRY ServerList;

    // Information on the address and mask used for automatic addressing.
    //
    ULONG ScopeAddress;
    ULONG ScopeMask;
}
SAINFO;


// Application-entry block, constructed for each [Application.<key>] section.
// All fields in memory are stored in network byte-order (i.e., big-endian).
//
typedef struct
_SAAPPLICATION
{
    LIST_ENTRY Link;
    ULONG Key;

    // Display-name of the 'application', a flag indicating
    // whether the application is enabled.
    //
    TCHAR* Title;
    BOOL Enabled;

    // Network identification information
    //
    UCHAR Protocol;
    USHORT Port;

    // Unsorted list of 'SARESPONSE' entries
    //
    LIST_ENTRY ResponseList;

    // Flag indicating whether the application is predefined.
    //
    BOOL BuiltIn;
}
SAAPPLICATION;


// Application response-list entry block.
// All fields in memory are stored in network byte-order (i.e., big-endian).
//
typedef struct
_SARESPONSE
{
    LIST_ENTRY Link;
    UCHAR Protocol;
    USHORT StartPort;
    USHORT EndPort;
} SARESPONSE;


// Server-entry block, constructed for each [Server.<key>] section.
// All fields in memory are stored in network byte-order (i.e., big-endian).
//
typedef struct
_SASERVER
{
    LIST_ENTRY Link;
    ULONG Key;

    // Display-name of the 'server', a flag indicating
    // whether the server is enabled.
    //
    TCHAR* Title;
    BOOL Enabled;

    // Network identification information
    //
    UCHAR Protocol;
    USHORT Port;

    // Internal server information
    //
    TCHAR* InternalName;
    USHORT InternalPort;
    ULONG ReservedAddress;

    // Flag indicating whether the server is predefined.
    //
    BOOL BuiltIn;
}
SASERVER;

//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

VOID APIENTRY
RasFreeSharedAccessSettings(
    IN SAINFO* Info );

SAINFO* APIENTRY
RasLoadSharedAccessSettings(
    BOOL EnabledOnly );

BOOL APIENTRY
RasSaveSharedAccessSettings(
    IN SAINFO* File );

VOID APIENTRY
FreeSharedAccessApplication(
    IN SAAPPLICATION* Application );

VOID APIENTRY
FreeSharedAccessServer(
    IN SASERVER* Server );

TCHAR* APIENTRY
SharedAccessResponseListToString(
    PLIST_ENTRY ResponseList,
    UCHAR Protocol );

BOOL APIENTRY
SharedAccessResponseStringToList(
    UCHAR Protocol,
    TCHAR* ResponseList,
    PLIST_ENTRY ListHead );

#ifdef __cplusplus
}
#endif

#endif // _SAINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\rtmmgmt.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmmgmt.h

Abstract:
    Definitions used in performing management
    functions on Routing Table Manager v2.

Author:

    Chaitanya Kodeboyina (chaitk)   17-Aug-1998

Revision History:

--*/

#ifndef __ROUTING_RTMMGMT_H__
#define __ROUTING_RTMMGMT_H__

#ifdef __cplusplus
extern "C" 
{
#endif

//
// Info related to an RTM instance
// 

typedef struct RTM_INSTANCE_INFO
{
    USHORT            RtmInstanceId;      // Unique ID for this RTM instance
    UINT              NumAddressFamilies; // Num. of addr families supported
} 
RTM_INSTANCE_INFO, *PRTM_INSTANCE_INFO;


//
// Info related to an address family
// (IPv4..) in a certain RTM instance
//

typedef struct _RTM_ADDRESS_FAMILY_INFO
{
    USHORT            RtmInstanceId;    // Unique ID for the owner RTM instance
    USHORT            AddressFamily;    // Address Family for this info block

    RTM_VIEW_SET      ViewsSupported;   // Views supported by this addr family

    UINT              MaxHandlesInEnum; // Max. number of handles returned in
                                        // any RTMv2 call that gives handles 

    UINT              MaxNextHopsInRoute;// Max. number of equal cost next-hops

    UINT              MaxOpaquePtrs;    // Number of opaque ptr slots in dest
    UINT              NumOpaquePtrs;    // Num. of opaque ptrs already in use

    UINT              NumEntities;      // Total number of registered entities

    UINT              NumDests;         // Number of dests in route table
    UINT              NumRoutes;        // Number of routes in route table

    UINT              MaxChangeNotifs;  // Max num. of change notify regns
    UINT              NumChangeNotifs;  // Num of registrations active now
} 
RTM_ADDRESS_FAMILY_INFO, *PRTM_ADDRESS_FAMILY_INFO;


//
// Funcs used to enumerate instances and address families
//

DWORD
WINAPI
RtmGetInstances (
    IN OUT  PUINT                           NumInstances,
    OUT     PRTM_INSTANCE_INFO              InstanceInfos
    );

DWORD
WINAPI
RtmGetInstanceInfo (
    IN      USHORT                          RtmInstanceId,
    OUT     PRTM_INSTANCE_INFO              InstanceInfo,
    IN OUT  PUINT                           NumAddrFamilies,
    OUT     PRTM_ADDRESS_FAMILY_INFO        AddrFamilyInfos OPTIONAL
    );

DWORD
WINAPI
RtmGetAddressFamilyInfo (
    IN      USHORT                          RtmInstanceId,
    IN      USHORT                          AddressFamily,
    OUT     PRTM_ADDRESS_FAMILY_INFO        AddrFamilyInfo,
    IN OUT  PUINT                           NumEntities,
    OUT     PRTM_ENTITY_INFO                EntityInfos OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_RTMMGMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\usrparms.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/

//***
//
// Filename:	usrparms.h
//
// Description:
//
// History:
//

#define	UP_CLIENT_MAC	'm'
#define	UP_CLIENT_DIAL	'd'


//	The 49-byte user params structure is laid out as follows:
// 	NOTE that the buffer is 48 byte + NULL byte.
// 
//	+-+-------------------+-+------------------------+-+
//	|m|Macintosh Pri Group|d|Dial-in CallBack Number | |
//	+-+-------------------+-+------------------------+-+
//	 |		       |			  |
//	 +---------------------+------ Signature	  +- NULL terminator
//

#define	UP_LEN_MAC		( LM20_UNLEN )

#define	UP_LEN_DIAL		( LM20_MAXCOMMENTSZ - 3 - UP_LEN_MAC )

typedef	struct {
	char	up_MACid;
	char	up_PriGrp[UP_LEN_MAC];
	char    up_MAC_Terminater;
	char	up_DIALid;
	char	up_CBNum[UP_LEN_DIAL];
	char    up_Null;
} USER_PARMS;

typedef	USER_PARMS FAR *PUP;

VOID InitUsrParams(
        OUT USER_PARMS *UserParms);
        
USHORT 
SetUsrParams(
    USHORT InfoType,  
    LPWSTR InBuf, 
    LPWSTR OutBuf); 
    
USHORT 
FAR 
APIENTRY
MprGetUsrParams(
    USHORT InfoType, 
    LPWSTR InBuf, 
    LPWSTR OutBuf);

DWORD
APIENTRY
RasPrivilegeAndCallBackNumber(
    IN BOOL         Compress,
    IN PRAS_USER_0  pRasUser0
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\wanpub.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Wanpub.h

Abstract:

    This file contains all public data structures and defines used
    by NdisWan.  It defines the Ioctl interface to NdisWan as well
    as the LineUp/LineDown interface between NdisWan and the transports.

Author:

    Tony Bell   (TonyBe) June 06, 1995

Environment:

    Kernel Mode

Revision History:

    TonyBe      06/06/95        Created

--*/

#ifndef _NDISWAN_PUB_
#define _NDISWAN_PUB_

#ifndef NTSTATUS
typedef LONG    NTSTATUS;
#endif

#ifndef NDIS_HANDLE
typedef PVOID   NDIS_HANDLE, *PNDIS_HANDLE;
#endif

#ifndef NDIS_STRING
typedef UNICODE_STRING NDIS_STRING, *PNDIS_STRING;
#endif

#ifndef NDIS_WAN_QUALITY

#endif

#include <ntddndis.h>

//
// Handle types that ndiswan expects
//
#define LINKHANDLE              0xABB0
#define BUNDLEHANDLE            0xABB1
#define CANCELEDHANDLE          0xABB2

//
// Threshold event types
//
#define UPPER_THRESHOLD         0x00000001
#define LOWER_THRESHOLD         0x00000002

//
// Threshold event data types
//
#define TRANSMIT_DATA       0x00000001
#define RECEIVE_DATA        0x00000002

//
// Unroute a bundle
//
#define PROTOCOL_UNROUTE        0xFFFF

//
// Get Bundle's Idle time
//
#define BUNDLE_IDLE_TIME        0xFFFF

#define MAX_PPP_HEADER          8

#define MAX_NAME_LENGTH         256

//
// NDISWAN_IO_PACKET flags
//
#define PACKET_IS_DIRECT        0x0001
#define PACKET_IS_BROADCAST     0x0002
#define PACKET_IS_MULTICAST     0x0004

//
// Maximum number of protocols we can support
//
#define MAX_PROTOCOLS       32

//
// Ioctl function codes should be kept contiguous.  Dispatch
// table is in io.c.  If a new function is added the dispatch
// table has to be updated!
//
#define FUNC_MAP_CONNECTION_ID          0
#define FUNC_GET_BUNDLE_HANDLE          1
#define FUNC_SET_FRIENDLY_NAME          2
#define FUNC_ROUTE                      3
#define FUNC_ADD_LINK_TO_BUNDLE         4
#define FUNC_ENUM_LINKS_IN_BUNDLE       5
#define FUNC_SET_PROTOCOL_PRIORITY      6
#define FUNC_SET_BANDWIDTH_ON_DEMAND    7
#define FUNC_SET_THRESHOLD_EVENT        8
#define FUNC_FLUSH_THRESHOLD_EVENTS     9
#define FUNC_SEND_PACKET                10
#define FUNC_RECEIVE_PACKET             11
#define FUNC_FLUSH_RECEIVE_PACKETS      12
#define FUNC_GET_STATS                  13
#define FUNC_SET_LINK_INFO              14
#define FUNC_GET_LINK_INFO              15
#define FUNC_SET_COMPRESSION_INFO       16
#define FUNC_GET_COMPRESSION_INFO       17
#define FUNC_SET_BRIDGE_INFO            18
#define FUNC_GET_BRIDGE_INFO            19
#define FUNC_SET_VJ_INFO                20
#define FUNC_GET_VJ_INFO                21
#define FUNC_SET_CIPX_INFO              22
#define FUNC_GET_CIPX_INFO              23
#define FUNC_SET_ENCRYPTION_INFO        24
#define FUNC_GET_ENCRYPTION_INFO        25
#define FUNC_SET_DEBUG_INFO             26
#define FUNC_ENUM_ACTIVE_BUNDLES        27
#define FUNC_GET_NDISWANCB              28
#define FUNC_GET_MINIPORTCB             29
#define FUNC_GET_OPENCB                 30
#define FUNC_GET_BANDWIDTH_UTILIZATION  31
#define FUNC_ENUM_PROTOCOL_UTILIZATION  32
#define FUNC_ENUM_MINIPORTCB            33
#define FUNC_ENUM_OPENCB                34
#define FUNC_GET_WAN_INFO               35
#define FUNC_GET_IDLE_TIME              36
#define FUNC_UNROUTE                    37
#define FUNC_GET_DRIVER_INFO            38
#define FUNC_SET_PROTOCOL_EVENT         39
#define FUNC_GET_PROTOCOL_EVENT         40
#define FUNC_FLUSH_PROTOCOL_EVENT       41
#define FUNC_GET_PROTOCOL_INFO          42
#define FUNC_SET_HIBERNATE_EVENT        43
#define FUNC_FLUSH_HIBERNATE_EVENT      44
#define FUNC_GET_BUNDLE_INFO            45
#define FUNC_UNMAP_CONNECTION_ID        46


#ifdef NT   // NT Specific stuff

#ifdef MY_DEVICE_OBJECT
#define FILE_DEVICE_NDISWAN         0x030
#define NDISWAN_CTL_CODE(_Function) CTL_CODE(FILE_DEVICE_NDISWAN, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)
#else
#define NDISWAN_CTL_CODE(_Function) CTL_CODE(FILE_DEVICE_NETWORK, _Function, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif


#define IOCTL_NDISWAN_MAP_CONNECTION_ID         NDISWAN_CTL_CODE(FUNC_MAP_CONNECTION_ID     )
#define IOCTL_NDISWAN_GET_BUNDLE_HANDLE         NDISWAN_CTL_CODE(FUNC_GET_BUNDLE_HANDLE     )
#define IOCTL_NDISWAN_SET_FRIENDLY_NAME         NDISWAN_CTL_CODE(FUNC_SET_FRIENDLY_NAME     )
#define IOCTL_NDISWAN_ROUTE                     NDISWAN_CTL_CODE(FUNC_ROUTE                 )
#define IOCTL_NDISWAN_ADD_LINK_TO_BUNDLE        NDISWAN_CTL_CODE(FUNC_ADD_LINK_TO_BUNDLE    )
#define IOCTL_NDISWAN_ENUM_LINKS_IN_BUNDLE      NDISWAN_CTL_CODE(FUNC_ENUM_LINKS_IN_BUNDLE  )
#define IOCTL_NDISWAN_SET_PROTOCOL_PRIORITY     NDISWAN_CTL_CODE(FUNC_SET_PROTOCOL_PRIORITY )
#define IOCTL_NDISWAN_SET_BANDWIDTH_ON_DEMAND   NDISWAN_CTL_CODE(FUNC_SET_BANDWIDTH_ON_DEMAND)
#define IOCTL_NDISWAN_SET_THRESHOLD_EVENT       NDISWAN_CTL_CODE(FUNC_SET_THRESHOLD_EVENT   )
#define IOCTL_NDISWAN_FLUSH_THRESHOLD_EVENTS    NDISWAN_CTL_CODE(FUNC_FLUSH_THRESHOLD_EVENTS)
#define IOCTL_NDISWAN_SEND_PACKET               NDISWAN_CTL_CODE(FUNC_SEND_PACKET           )
#define IOCTL_NDISWAN_RECEIVE_PACKET            NDISWAN_CTL_CODE(FUNC_RECEIVE_PACKET        )
#define IOCTL_NDISWAN_FLUSH_RECEIVE_PACKETS     NDISWAN_CTL_CODE(FUNC_FLUSH_RECEIVE_PACKETS )
#define IOCTL_NDISWAN_GET_STATS                 NDISWAN_CTL_CODE(FUNC_GET_STATS             )
#define IOCTL_NDISWAN_SET_LINK_INFO             NDISWAN_CTL_CODE(FUNC_SET_LINK_INFO         )
#define IOCTL_NDISWAN_GET_LINK_INFO             NDISWAN_CTL_CODE(FUNC_GET_LINK_INFO         )
#define IOCTL_NDISWAN_SET_COMPRESSION_INFO      NDISWAN_CTL_CODE(FUNC_SET_COMPRESSION_INFO  )
#define IOCTL_NDISWAN_GET_COMPRESSION_INFO      NDISWAN_CTL_CODE(FUNC_GET_COMPRESSION_INFO  )
#define IOCTL_NDISWAN_SET_BRIDGE_INFO           NDISWAN_CTL_CODE(FUNC_SET_BRIDGE_INFO       )
#define IOCTL_NDISWAN_GET_BRIDGE_INFO           NDISWAN_CTL_CODE(FUNC_GET_BRIDGE_INFO       )
#define IOCTL_NDISWAN_SET_VJ_INFO               NDISWAN_CTL_CODE(FUNC_SET_VJ_INFO           )
#define IOCTL_NDISWAN_GET_VJ_INFO               NDISWAN_CTL_CODE(FUNC_GET_VJ_INFO           )
#define IOCTL_NDISWAN_SET_CIPX_INFO             NDISWAN_CTL_CODE(FUNC_SET_CIPX_INFO         )
#define IOCTL_NDISWAN_GET_CIPX_INFO             NDISWAN_CTL_CODE(FUNC_GET_CIPX_INFO         )
#define IOCTL_NDISWAN_SET_ENCRYPTION_INFO       NDISWAN_CTL_CODE(FUNC_SET_ENCRYPTION_INFO   )
#define IOCTL_NDISWAN_GET_ENCRYPTION_INFO       NDISWAN_CTL_CODE(FUNC_GET_ENCRYPTION_INFO   )
#define IOCTL_NDISWAN_SET_DEBUG_INFO            NDISWAN_CTL_CODE(FUNC_SET_DEBUG_INFO        )
#define IOCTL_NDISWAN_ENUM_ACTIVE_BUNDLES       NDISWAN_CTL_CODE(FUNC_ENUM_ACTIVE_BUNDLES   )
#define IOCTL_NDISWAN_GET_NDISWANCB             NDISWAN_CTL_CODE(FUNC_GET_NDISWANCB         )
#define IOCTL_NDISWAN_GET_MINIPORTCB            NDISWAN_CTL_CODE(FUNC_GET_MINIPORTCB        )
#define IOCTL_NDISWAN_GET_OPENCB                NDISWAN_CTL_CODE(FUNC_GET_OPENCB            )
#define IOCTL_NDISWAN_GET_BANDWIDTH_UTILIZATION NDISWAN_CTL_CODE(FUNC_GET_BANDWIDTH_UTILIZATION)
#define IOCTL_NDISWAN_ENUM_PROTOCOL_UTILIZATION NDISWAN_CTL_CODE(FUNC_ENUM_PROTOCOL_UTILIZATION)
#define IOCTL_NDISWAN_ENUM_MINIPORTCB           NDISWAN_CTL_CODE(FUNC_ENUM_MINIPORTCB       )
#define IOCTL_NDISWAN_ENUM_OPENCB               NDISWAN_CTL_CODE(FUNC_ENUM_OPENCB           )
#define IOCTL_NDISWAN_GET_WAN_INFO              NDISWAN_CTL_CODE(FUNC_GET_WAN_INFO          )
#define IOCTL_NDISWAN_GET_IDLE_TIME             NDISWAN_CTL_CODE(FUNC_GET_IDLE_TIME         )
#define IOCTL_NDISWAN_UNROUTE                   NDISWAN_CTL_CODE(FUNC_UNROUTE               )
#define IOCTL_NDISWAN_GET_DRIVER_INFO           NDISWAN_CTL_CODE(FUNC_GET_DRIVER_INFO       )
#define IOCTL_NDISWAN_SET_PROTOCOL_EVENT        NDISWAN_CTL_CODE(FUNC_SET_PROTOCOL_EVENT    )
#define IOCTL_NDISWAN_GET_PROTOCOL_EVENT        NDISWAN_CTL_CODE(FUNC_GET_PROTOCOL_EVENT    )
#define IOCTL_NDISWAN_FLUSH_PROTOCOL_EVENT      NDISWAN_CTL_CODE(FUNC_FLUSH_PROTOCOL_EVENT  )
#define IOCTL_NDISWAN_GET_PROTOCOL_INFO         NDISWAN_CTL_CODE(FUNC_GET_PROTOCOL_INFO     )
#define IOCTL_NDISWAN_SET_HIBERNATE_EVENT       NDISWAN_CTL_CODE(FUNC_SET_HIBERNATE_EVENT   )
#define IOCTL_NDISWAN_FLUSH_HIBERNATE_EVENT     NDISWAN_CTL_CODE(FUNC_FLUSH_HIBERNATE_EVENT )
#define IOCTL_NDISWAN_GET_BUNDLE_INFO           NDISWAN_CTL_CODE(FUNC_GET_BUNDLE_INFO       )
#define IOCTL_NDISWAN_UNMAP_CONNECTION_ID       NDISWAN_CTL_CODE(FUNC_UNMAP_CONNECTION_ID   )

#endif      // end NT

//
// NdisWan error messages
//
#define NDISWAN_ERROR_BASE                  600
#define NDISWAN_ERROR_INVALID_HANDLE        NDISWAN_ERROR_BASE + 1
#define NDISWAN_ERROR_ALREADY_ROUTED        NDISWAN_ERROR_BASE + 2
#define NDISWAN_ERROR_NO_ROUTE              NDISWAN_ERROR_BASE + 3
#define NDISWAN_ERROR_INVALID_HANDLE_TYPE   NDISWAN_ERROR_BASE + 4
#define NDISWAN_ERROR_INVALID_ADDRESS       NDISWAN_ERROR_BASE + 5
#define NDISWAN_ERROR_NOT_ROUTED            NDISWAN_ERROR_BASE + 6

//
// Structure used to store wan statistics
//
typedef struct _WAN_STATS {
    ULONG   BytesTransmitted;
    ULONG   BytesReceived;
    ULONG   FramesTransmitted;
    ULONG   FramesReceived;

    ULONG   CRCErrors;
    ULONG   TimeoutErrors;
    ULONG   AlignmentErrors;
    ULONG   SerialOverrunErrors;
    ULONG   FramingErrors;
    ULONG   BufferOverrunErrors;

    ULONG   BytesTransmittedUncompressed;
    ULONG   BytesReceivedUncompressed;
    ULONG   BytesTransmittedCompressed;
    ULONG   BytesReceivedCompressed;
} WAN_STATS, *PWAN_STATS;

//
// Structure used to get and set WAN Link Information
// Needs to be kept in sync with NDIS_WAN_SET_LINK_INFO
// and NDIS_WAN_GET_LINK_INFO in ndiswan.h
//
typedef struct _WAN_LINK_INFO {
    IN  ULONG       MaxSendFrameSize;
    IN  ULONG       MaxRecvFrameSize;
    ULONG       HeaderPadding;
    ULONG       TailPadding;
    IN  ULONG       SendFramingBits;
    IN  ULONG       RecvFramingBits;
    IN  ULONG       SendCompressionBits;
    IN  ULONG       RecvCompressionBits;
    IN  ULONG       SendACCM;
    IN  ULONG       RecvACCM;
    IN  ULONG       MaxRSendFrameSize;
    IN  ULONG       MaxRRecvFrameSize;
} WAN_LINK_INFO, *PWAN_LINK_INFO;

//
// Structure used to get general information about
// a wan link
//
typedef struct _WAN_INFO {
    OUT ULONG   MaxFrameSize;
    OUT ULONG   MaxTransmit;
    OUT ULONG   FramingBits;
    OUT ULONG   DesiredACCM;
    OUT ULONG   MaxReconstructedFrameSize;
    OUT ULONG   LinkSpeed;
} WAN_INFO, *PWAN_INFO;

//
// Structure used to get general information about
// a wan bundle
//
typedef struct _BUNDLE_INFO {
    OUT ULONG   SendFramingBits;    // Current send framing bits
    OUT ULONG   SendBundleSpeed;    // Current send speed (bps)
    OUT ULONG   SendMSCompType;     // Current send MPPE/MPPC bits
    OUT ULONG   SendAuthType;       // Current send Auth
    OUT ULONG   RecvFramingBits;    // Current recv framing bits
    OUT ULONG   RecvBundleSpeed;    // Current recv speed (bps)
    OUT ULONG   RecvMSCompType;     // Current recv MPPE/MPPC bits
    OUT ULONG   RecvAuthType;       // Current recv Auth
} BUNDLE_INFO, *PBUNDLE_INFO;

//
// Structure used to set Protocol Utilization
//
typedef struct _PROTOCOL_UTILIZATION {
    USHORT  usProtocolType;
    USHORT  usUtilization;
} PROTOCOL_UTILIZATION, *PPROTOCOL_UTILIZATION;

//
// Encryption key sizes
//
#ifndef MAX_SESSIONKEY_SIZE
#define MAX_SESSIONKEY_SIZE     8
#endif

#ifndef MAX_USERSESSIONKEY_SIZE
#define MAX_USERSESSIONKEY_SIZE 16
#endif

#ifndef MAX_CHALLENGE_SIZE
#define MAX_CHALLENGE_SIZE      8
#endif

#define MAX_NT_RESPONSE         24

#define MAX_EAPKEY_SIZE         256

//
// Defines for COMPRESS_INFO AuthType field
//
#define AUTH_USE_MSCHAPV1       0x00000001
#define AUTH_USE_MSCHAPV2       0x00000002
#define AUTH_USE_EAP            0x00000003

//
// Defines for COMPRESS_INFO flags
//
#define CCP_PAUSE_DATA          0x00000001  // the bit is set if the bundle
                                            // should pause data transfer
                                            // the bit is cleared if the bundle
                                            // should resume data transfer
#define CCP_IS_SERVER           0x00000002  // this bit is set if the bundle
                                            // is the server
                                            // the bit is cleared if the bundle
                                            // is the client
#define CCP_SET_KEYS            0x00000004  // indicates that the key
                                            // information is valid
#define CCP_SET_COMPTYPE        0x00000008  // indicates that the comptype
                                            // bits are valid

//
// Structure used to get and set compression information
//
typedef struct _COMPRESS_INFO {

    UCHAR   LMSessionKey[MAX_SESSIONKEY_SIZE];
    UCHAR   UserSessionKey[MAX_USERSESSIONKEY_SIZE];
    UCHAR   Challenge[MAX_CHALLENGE_SIZE];
    UCHAR   NTResponse[MAX_NT_RESPONSE];

    ULONG   MSCompType;
    ULONG   AuthType;

    UCHAR   CompType;
    USHORT  CompLength;

    union {
        struct {
            UCHAR   CompOUI[3];
            UCHAR   CompSubType;
            UCHAR   CompValues[32];
        } Proprietary;

        struct {
            UCHAR   CompValues[32];
        } Public;
    };

    ULONG   Flags;

    ULONG   EapKeyLength;
    UCHAR   EapKey[MAX_EAPKEY_SIZE];

} COMPRESS_INFO, *PCOMPRESS_INFO;

//
// Flags to identify protocol events
//
#define PROTOCOL_ADDED      0x00000001
#define PROTOCOL_REMOVED    0x00000002

//
// Structure to get protocol event
//
typedef struct _PROTOCOL_EVENT {
    USHORT  usProtocolType;
    USHORT  usReserved;
    ULONG   ulFlags;
} PROTOCOL_EVENT, *PPROTOCOL_EVENT;

//
// Structure used to get protocol info
//
typedef struct _WAN_PROTOCOL_INFO {
    USHORT  ProtocolType;               // protocol's Ethertype
    USHORT  PPPId;                      // protocol's PPP ID
    ULONG   MTU;                        // MTU being used
    ULONG   TunnelMTU;                  // MTU used for tunnels
    ULONG   PacketQueueDepth;           // max depth of packet queue (in seconds)
} WAN_PROTOCOL_INFO, *PWAN_PROTOCOL_INFO;

//
// Structure used to get and set VJ header compression information
//
typedef struct _VJ_INFO {
    USHORT  IPCompressionProtocol;
    UCHAR   MaxSlotID;
    UCHAR   CompSlotID;
} VJ_INFO, *PVJ_INFO;

//
// Structure used to get and set IPX header compression information
//
typedef struct _CIPX_INFO {
    USHORT  IPXCompressionProtocol;
} CIPX_INFO, *PCIPX_INFO;

//
// Structure used to get and set encryption information
//
typedef struct __ENCRYPT_INFO {
    UCHAR   EncryptType;
    USHORT  EncryptLength;

    union {
        struct {
            UCHAR   EncryptOUI[3];
            UCHAR   EncryptSubtype;
            UCHAR   EncryptValues[1];
        } Proprietary;

        struct {
            UCHAR   EncryptValues[1];
        } Public;
    };
} ENCRYPT_INFO, *PENCRYPT_INFO;

//
// Structure used in IOCTL_NDISWAN_MAP_CONNECTION_ID
//
typedef struct _NDISWAN_MAP_CONNECTION_ID {
    OUT NDIS_HANDLE hLinkHandle;
    OUT NDIS_HANDLE hBundleHandle;
    IN  NDIS_HANDLE hConnectionID;
    IN  NDIS_HANDLE hLinkContext;
    IN  NDIS_HANDLE hBundleContext;
    IN  ULONG       ulNameLength;
    IN  CHAR        szName[1];
} NDISWAN_MAP_CONNECTION_ID, *PNDISWAN_MAP_CONNECTION_ID;

//
// Structure used in IOCTL_NDISWAN_GET_BUNDLE_HANDLE
//
typedef struct _NDISWAN_GET_BUNDLE_HANDLE {
    OUT NDIS_HANDLE hBundleHandle;
    IN  NDIS_HANDLE hLinkHandle;
} NDISWAN_GET_BUNDLE_HANDLE, *PNDISWAN_GET_BUNDLE_HANDLE;

//
// Structure used in IOCTL_NDISWAN_SET_FRIENDLY_NAME
//
typedef struct _NDISWAN_SET_FRIENDLY_NAME {
    IN  NDIS_HANDLE hHandle;
    IN  USHORT      usHandleType;
    IN  ULONG       ulNameLength;
    IN  CHAR        szName[1];
} NDISWAN_SET_FRIENDLY_NAME, *PNDISWAN_SET_FRIENDLY_NAME;

//
// Structure used in IOCTL_NDISWAN_ROUTE
//
typedef struct _NDISWAN_ROUTE {
    IN  NDIS_HANDLE hBundleHandle;
    IN  USHORT      usProtocolType;
    IN  USHORT      usBindingNameLength;
    IN  WCHAR       BindingName[MAX_NAME_LENGTH];
    OUT USHORT      usDeviceNameLength;
    OUT WCHAR       DeviceName[MAX_NAME_LENGTH];
    IN  ULONG       ulBufferLength;
    IN  UCHAR       Buffer[1];
} NDISWAN_ROUTE, *PNDISWAN_ROUTE;

//
// Structure used in IOCTL_NDISWAN_UNROUTE
//
typedef struct _NDISWAN_UNROUTE {
    IN  NDIS_HANDLE hBundleHandle;
    IN  USHORT      usProtocolType;
} NDISWAN_UNROUTE, *PNDISWAN_UNROUTE;


//
// Structure used in IOCTL_NDISWAN_ADD_LINK_TO_BUNDLE
//
typedef struct _NDISWAN_ADD_LINK_TO_BUNDLE {
    IN  NDIS_HANDLE hBundleHandle;
    IN  NDIS_HANDLE hLinkHandle;
} NDISWAN_ADD_LINK_TO_BUNDLE, *PNDISWAN_ADD_LINK_TO_BUNDLE;

//
// Structure used in IOCTL_NDISWAN_ENUM_LINKS_IN_BUNDLE
//
typedef struct _NDISWAN_ENUM_LINKS_IN_BUNDLE {
    IN  NDIS_HANDLE hBundleHandle;
    OUT ULONG       ulNumberOfLinks;
    OUT NDIS_HANDLE hLinkHandleArray[1];
} NDISWAN_ENUM_LINKS_IN_BUNDLE, *PNDISWAN_ENUM_LINKS_IN_BUNDLE;

//
// Structure used in IOCTL_NDISWAN_SET_PROTOCOL_PRIORITY
//
typedef struct _NDISWAN_SET_PROTOCOL_PRIORITY {
    IN  NDIS_HANDLE hBundleHandle;
    IN  USHORT      usProtocolType;
    IN  USHORT      usPriority;
} NDISWAN_SET_PROTOCOL_PRIORITY, *PNDISWAN_SET_PROTOCOL_PRIORITY;

//
// Structure used in IOCTL_NDISWAN_SET_BANDWIDTH_ON_DEMAND
//
typedef struct _NDISWAN_SET_BANDWIDTH_ON_DEMAND {
    IN  NDIS_HANDLE hBundleHandle;
    IN  USHORT      usLowerXmitThreshold;
    IN  USHORT      usUpperXmitThreshold;
    IN  ULONG       ulLowerXmitSamplePeriod;
    IN  ULONG       ulUpperXmitSamplePeriod;
    IN  USHORT      usLowerRecvThreshold;
    IN  USHORT      usUpperRecvThreshold;
    IN  ULONG       ulLowerRecvSamplePeriod;
    IN  ULONG       ulUpperRecvSamplePeriod;
} NDISWAN_SET_BANDWIDTH_ON_DEMAND, *PNDISWAN_SET_BANDWIDTH_ON_DEMAND;

//
// Structure used in IOCTL_NDISWAN_SET_THRESHOLD_EVENT
//
typedef struct _NDISWAN_SET_THRESHOLD_EVENT {
    OUT NDIS_HANDLE hBundleContext;
    OUT ULONG       ulDataType;
    OUT ULONG       ulThreshold;
} NDISWAN_SET_THRESHOLD_EVENT, *PNDISWAN_SET_THRESHOLD_EVENT;

//
// Structure used in IOCTL_NDISWAN_SEND_PACKET and IOCTL_NDISWAN_RECEIVE_PACKET
//
typedef struct _NDISWAN_IO_PACKET {
    IN OUT  ULONG       PacketNumber;
    IN OUT  NDIS_HANDLE hHandle;
    IN OUT  USHORT      usHandleType;
    IN OUT  USHORT      usHeaderSize;
    IN OUT  USHORT      usPacketSize;
    IN OUT  USHORT      usPacketFlags;
    IN OUT  UCHAR       PacketData[1];
} NDISWAN_IO_PACKET, *PNDISWAN_IO_PACKET;

//
// Structure used in IOCTL_NDISWAN_GET_STATS
//
typedef struct _NDISWAN_GET_STATS {
    IN  NDIS_HANDLE hHandle;
    IN  USHORT      usHandleType;
    OUT struct _STATS {
        OUT WAN_STATS   BundleStats;
        OUT WAN_STATS   LinkStats;
    } Stats;
} NDISWAN_GET_STATS, *PNDISWAN_GET_STATS;

//
// Structure used in IOCTL_NDISWAN_GET_BANDWIDTH_UTILIZATION
//
typedef struct _NDISWAN_GET_BANDWIDTH_UTILIZATION {
    IN  NDIS_HANDLE hBundleHandle;
    OUT ULONG       ulUpperXmitUtil;
    OUT ULONG      ulLowerXmitUtil;
    OUT ULONG      ulUpperRecvUtil;
    OUT ULONG      ulLowerRecvUtil;
} NDISWAN_GET_BANDWIDTH_UTILIZATION, *PNDISWAN_GET_BANDWIDTH_UTILIZATION;

//
// Structure used in IOCTL_NDISWAN_ENUM_PROTOCOL_UTILIZATION
//
typedef struct _NDISWAN_ENUM_PROTOCOL_UTILIZATION {
    IN  NDIS_HANDLE             hBundleHandle;
    OUT PROTOCOL_UTILIZATION    ProtocolArray[1];
} NDISWAN_ENUM_PROTOCOL_UTILIZATION, *PNDISWAN_ENUM_PROTOCOL_UTILIZATION;

//
// Structure used in IOCTL_NDISWAN_ENUM_ACTIVE_BUNDLES
//
typedef struct _NDISWAN_ENUM_ACTIVE_BUNDLES {
    OUT ULONG   ulNumberOfActiveBundles;
} NDISWAN_ENUM_ACTIVE_BUNDLES, *PNDISWAN_ENUM_ACTIVE_BUNDLES;

//
// Structure used in IOCTL_NDISWAN_SET_LINK_INFO
//
typedef struct _NDISWAN_SET_LINK_INFO {
    IN  NDIS_HANDLE     hLinkHandle;
    IN  WAN_LINK_INFO   LinkInfo;
} NDISWAN_SET_LINK_INFO, *PNDISWAN_SET_LINK_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_LINK_INFO
//
typedef struct _NDISWAN_GET_LINK_INFO {
    IN  NDIS_HANDLE     hLinkHandle;
    OUT WAN_LINK_INFO   LinkInfo;
} NDISWAN_GET_LINK_INFO, *PNDISWAN_GET_LINK_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_WAN_INFO
//
typedef struct _NDISWAN_GET_WAN_INFO {
    IN  NDIS_HANDLE     hLinkHandle;
    OUT WAN_INFO        WanInfo;
} NDISWAN_GET_WAN_INFO, *PNDISWAN_GET_WAN_INFO;

//
// Structure used in IOCTL_NDISWAN_SET_COMPRESSION_INFO
//
typedef struct _NDISWAN_SET_COMPRESSION_INFO {
    IN  NDIS_HANDLE     hLinkHandle;
    IN  COMPRESS_INFO   SendCapabilities;
    IN  COMPRESS_INFO   RecvCapabilities;
} NDISWAN_SET_COMPRESSION_INFO, *PNDISWAN_SET_COMPRESSION_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_COMPRESSION_INFO
//
typedef struct _NDISWAN_GET_COMPRESSION_INFO {
    IN  NDIS_HANDLE     hLinkHandle;
    OUT COMPRESS_INFO   SendCapabilities;
    OUT COMPRESS_INFO   RecvCapabilities;
} NDISWAN_GET_COMPRESSION_INFO, *PNDISWAN_GET_COMPRESSION_INFO;

//
// Structure used in IOCTL_NDISWAN_SET_VJ_INFO
//
typedef struct _NDISWAN_SET_VJ_INFO {
    IN  NDIS_HANDLE hLinkHandle;
    IN  VJ_INFO     SendCapabilities;
    IN  VJ_INFO     RecvCapabilities;
} NDISWAN_SET_VJ_INFO, *PNDISWAN_SET_VJ_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_VJ_INFO
//
typedef struct _NDISWAN_GET_VJ_INFO {
    IN  NDIS_HANDLE hLinkHandle;
    OUT VJ_INFO     SendCapabilities;
    OUT VJ_INFO     RecvCapabilities;
} NDISWAN_GET_VJ_INFO, *PNDISWAN_GET_VJ_INFO;

//
// Structure used in IOCTL_NDISWAN_SET_BRIDGE_INFO
//
typedef struct _NDISWAN_SET_BRIDGE_INFO {
    IN  NDIS_HANDLE hLinkHandle;
    IN  USHORT      LanSegmentNumber;
    IN  UCHAR       BridgeNumber;
    IN  UCHAR       BridgingOptions;
    IN  ULONG       BridgingCapabilities;
    IN  UCHAR       BridgingType;
    IN  UCHAR       MacBytes[6];
} NDISWAN_SET_BRIDGE_INFO, *PNDISWAN_SET_BRIDGE_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_BRIDGE_INFO
//
typedef struct _NDISWAN_GET_BRIDGE_INFO {
    IN  NDIS_HANDLE hLinkHandle;
    OUT USHORT      LanSegmentNumber;
    OUT UCHAR       BridgeNumber;
    OUT UCHAR       BridgingOptions;
    OUT ULONG       BridgingCapabilities;
    OUT UCHAR       BridgingType;
    OUT UCHAR       MacBytes[6];
} NDISWAN_GET_BRIDGE_INFO, *PNDISWAN_GET_BRIDGE_INFO;

//
// Structure used in IOCTL_NDISWAN_SET_CIPX_INFO
//
typedef struct _NDISWAN_SET_CIPX_INFO {
    IN  NDIS_HANDLE hLinkHandle;
    IN  CIPX_INFO   SendCapabilities;
    IN  CIPX_INFO   RecvCapabilities;
} NDISWAN_SET_CIPX_INFO, *PNDISWAN_SET_CIPX_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_CIPX_INFO
//
typedef struct _NDISWAN_GET_CIPX_INFO {
    IN  NDIS_HANDLE hLinkHandle;
    OUT CIPX_INFO   SendCapabilities;
    OUT CIPX_INFO   RecvCapabilities;
} NDISWAN_GET_CIPX_INFO, *PNDISWAN_GET_CIPX_INFO;

//
// Structure used in IOCTL_NDISWAN_SET_ENCRYPTION_INFO
//
typedef struct _NDISWAN_SET_ENCRYPTION_INFO {
    IN  NDIS_HANDLE     hLinkHandle;
    IN  ENCRYPT_INFO    SendCapabilities;
    IN  ENCRYPT_INFO    RecvCapabilities;
} NDISWAN_SET_ENCRYPTION_INFO, *PNDISWAN_SET_ENCRYPTION_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_ENCRYPTION_INFO
//
typedef struct _NDISWAN_GET_ENCRYPTION_INFO {
    IN  NDIS_HANDLE     hLinkHandle;
    IN  ENCRYPT_INFO    SendCapabilities;
    IN  ENCRYPT_INFO    RecvCapabilities;
} NDISWAN_GET_ENCRYPTION_INFO, *PNDISWAN_GET_ENCRYPTION_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_IDLE_TIME
//
typedef struct _NDISWAN_GET_IDLE_TIME {
    IN  NDIS_HANDLE     hBundleHandle;
    IN  USHORT          usProtocolType;
    OUT ULONG           ulSeconds;
} NDISWAN_GET_IDLE_TIME, *PNDISWAN_GET_IDLE_TIME;

//
// Structure used in IOCTL_NDISWAN_SET_DEBUG_INFO
//
typedef struct _NDISWAN_SET_DEBUG_INFO {
    IN  ULONG   ulDebugLevel;
    IN  ULONG   ulDebugMask;
}NDISWAN_SET_DEBUG_INFO, *PNDISWAN_SET_DEBUG_INFO;

//
// Structure used in IOCTL_NDISWAN_ENUM_MINIPORTCB, OPENCB
//
typedef struct _NDISWAN_ENUMCB {
    OUT ULONG   ulNumberOfCBs;
    OUT PVOID   Address[1];
} NDISWAN_ENUMCB, *PNDISWAN_ENUMCB;

//
// Structure used in IOCTL_NDISWAN_GET_NDISWANCB, MINIPORTCB, OPENCB
//
typedef struct _NDISWAN_DUMPCB {
    IN OUT  PVOID   Address;
    OUT     UCHAR   Buffer[1];
} NDISWAN_DUMPCB, *PNDISWAN_DUMPCB;

//
// Defines for DriverCaps
//
#define NDISWAN_128BIT_ENABLED      0x00000001

//
// Structure used in IOCTL_NDISWAN_GET_DRIVER_INFO
//
typedef struct _NDISWAN_DRIVER_INFO {
    OUT     ULONG   DriverCaps;
    OUT     ULONG   Reserved;
} NDISWAN_DRIVER_INFO, *PNDISWAN_DRIVER_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_PROTOCOL_EVENT
//
typedef struct _NDISWAN_GET_PROTOCOL_EVENT {
    OUT ULONG           ulNumProtocols;
    OUT PROTOCOL_EVENT  ProtocolEvent[MAX_PROTOCOLS];
}NDISWAN_GET_PROTOCOL_EVENT, *PNDISWAN_GET_PROTOCOL_EVENT;

//
// Structure used in IOCTL_NDISWAN_GET_PROTOCOL_INFO
//
typedef struct _NDISWAN_GET_PROTOCOL_INFO {
    OUT ULONG               ulNumProtocols;
    OUT WAN_PROTOCOL_INFO   ProtocolInfo[MAX_PROTOCOLS];
}NDISWAN_GET_PROTOCOL_INFO, *PNDISWAN_GET_PROTOCOL_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_BUNDLE_INFO
//
typedef struct _NDISWAN_GET_BUNDLE_INFO {
    IN  NDIS_HANDLE     hBundleHandle;
    OUT BUNDLE_INFO     BundleInfo;
}NDISWAN_GET_BUNDLE_INFO, *PNDISWAN_GET_BUNDLE_INFO;

//
// Structure used in IOCTL_UNNDISWAN_MAP_CONNECTION_ID
//
typedef struct _NDISWAN_UNMAP_CONNECTION_ID {
    IN  NDIS_HANDLE hLinkHandle;
} NDISWAN_UNMAP_CONNECTION_ID, *PNDISWAN_UNMAP_CONNECTION_ID;

#endif          // WAN_PUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\vrrprm.h ===
/*++
Copyright (c) 1998, Microsoft Corporation

Module:
  vrrp\vrrprm.h

Abstract:
  Contains type definitions and declarations for VRRP,
  used by the IP Router Manager.

Revistion History:
  Harry Heymann July-07-1998 Created.
  Peeyush Ranjan Mar-10-1999 Modified.
--*/

#ifndef _VRRPRM_H_
#define _VRRPRM_H_


//---------------------------------------------------------------------------
// CONSTANT DECLARATIONS
//---------------------------------------------------------------------------

#define VRRP_CONFIG_VERSION_500    500

//---------------------------------------------------------------------------
// constants identifying VRRP's MIB tables
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// constants used for the field VRRP_GLOBAL_CONFIG::LoggingLevel
//---------------------------------------------------------------------------

#define VRRP_LOGGING_NONE      0
#define VRRP_LOGGING_ERROR     1
#define VRRP_LOGGING_WARN      2
#define VRRP_LOGGING_INFO      3

//---------------------------------------------------------------------------
// constant for the field VRRP_IF_CONFIG::AuthenticationKey;
//  defines maximum authentication key size
//---------------------------------------------------------------------------

#define VRRP_MAX_AUTHKEY_SIZE           8

//---------------------------------------------------------------------------
// constants for the field VRRP_IF_CONFIG::AuthenticationType
//---------------------------------------------------------------------------

#define VRRP_AUTHTYPE_NONE                  0
#define VRRP_AUTHTYPE_PLAIN                 1
#define VRRP_AUTHTYPE_IPHEAD                2


//---------------------------------------------------------------------------
// STRUCTURE DEFINITIONS
//---------------------------------------------------------------------------

  
//----------------------------------------------------------------------------
// struct:      VRRP_GLOBAL_CONFIG
//
// This MIB entry stores global configuration for VRRP
// There is only one instance, so this entry has no index.
//
//---------------------------------------------------------------------------

typedef struct _VRRP_GLOBAL_CONFIG {
  DWORD       LoggingLevel;
} VRRP_GLOBAL_CONFIG, *PVRRP_GLOBAL_CONFIG;


//---------------------------------------------------------------------------
// struct:  VRRP_VROUTER_CONFIG
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
// After the base structure comes a variable lenght array (IPAddress) of
// IP Addresses for the VRouter
//
// IPCount indicates the size of this array.
//---------------------------------------------------------------------------

typedef struct _VRRP_VROUTER_CONFIG {
    BYTE        VRID;
	BYTE        ConfigPriority;
	BYTE        AdvertisementInterval;
	BOOL        PreemptMode;
	BYTE        IPCount;
    BYTE        AuthenticationType;
    BYTE        AuthenticationData[VRRP_MAX_AUTHKEY_SIZE];
    DWORD       IPAddress[1];
} VRRP_VROUTER_CONFIG, *PVRRP_VROUTER_CONFIG;



//---------------------------------------------------------------------------
// struct:      VRRP_IF_CONFIG
//
// This MIB entry describes per-interface configuration.
// All IP address fields must be in network order.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
// After the base structure comes VrouterCount VRRP_VROUTER_CONFIG structures.
//---------------------------------------------------------------------------

typedef struct _VRRP_IF_CONFIG {
  BYTE                  VrouterCount;
} VRRP_IF_CONFIG, *PVRRP_IF_CONFIG;


//---------------------------------------------------------------------------
// MACRO DECLARATIONS
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// macro: VRRP_IF_CONFIG_SIZE
//
// determines thge space requirements for an interface config block based
// on the number of vrouters and total number of IPAddresses.
//---------------------------------------------------------------------------
#define VRRP_IF_CONFIG_SIZE(VRCount,IPCount) \
  sizeof(VRRP_IF_CONFIG) +                   \
  VRCount * sizeof(VRRP_VROUTER_CONFIG) +    \
  (IPCount-VRCount) * sizeof(DWORD)

#define VRRP_FIRST_VROUTER_CONFIG(pic) ((PVRRP_VROUTER_CONFIG)(pic + 1))
  
#define VRRP_NEXT_VROUTER_CONFIG(pvc)  \
  (PVRRP_VROUTER_CONFIG)((PDWORD)(pvc + 1) + (pvc->IPCount-1))

#define VRRP_VROUTER_CONFIG_SIZE(pvc) \
    (sizeof(VRRP_VROUTER_CONFIG) + \
    (((pvc)->IPCount - 1) * sizeof(DWORD)))
  
#endif // _VRRPRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\api.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    api.h
//
// History:
//      Abolade Gbadegesin  August 31, 1995     Created
//
// Declarations for BOOTP Relay Agent's interface to Router Manager
//============================================================================


#ifndef _API_H_
#define _API_H_



//
// enum:    IPBOOTP_STATUS_CODE
//
// these codes are the possible values for the BOOTP's status.
// they are used in the field IPBOOTP_GLOBALS::IG_Status, and
// when each API or worker-function is entered, the status
// determines whether the function will proceed.
//

typedef enum _IPBOOTP_STATUS_CODE {

    IPBOOTP_STATUS_STARTING = 100,
    IPBOOTP_STATUS_RUNNING  = 101,
    IPBOOTP_STATUS_STOPPING = 102,
    IPBOOTP_STATUS_STOPPED  = 103

} IPBOOTP_STATUS_CODE, *PIPBOOTP_STATUS_CODE;



//
// struct:      IPBOOTP_GLOBALS
//
// When more than one lock must be acquired, the order must be as follows;
// locks for fields listed on the same line should never be owned at once
// by any given thread:
//
//      IG_IfTable.IT_RWL
//      IG_RWL
//      IG_RecvQueue  IG_EventQueue
//      IG_CS
//
typedef struct _IPBOOTP_GLOBALS {

    CRITICAL_SECTION        IG_CS;
    IPBOOTP_STATUS_CODE     IG_Status;
    READ_WRITE_LOCK         IG_RWL;
    DWORD                   IG_TraceID;
    DWORD                   IG_LoggingLevel;
    HANDLE                  IG_LoggingHandle;
    PIPBOOTP_GLOBAL_CONFIG  IG_Config;
    PIF_TABLE               IG_IfTable;
    PSUPPORT_FUNCTIONS      IG_FunctionTable;
    HANDLE                  IG_EventEvent;
    PLOCKED_LIST            IG_EventQueue;
    HANDLE                  IG_GlobalHeap;
    HANDLE                  IG_InputEvent;
    HANDLE                  IG_InputEventHandle;
    PLOCKED_LIST            IG_RecvQueue;
    LONG                    IG_RecvQueueSize;
    LONG                    IG_ActivityCount;
    HANDLE                  IG_ActivitySemaphore;
    DWORD                   IG_DhcpInformServer;

#if DBG
    DWORD                   IG_MibTraceID;
    HANDLE                  IG_MibTimerHandle;
    HANDLE                  IG_TimerQueueHandle;
#endif

} IPBOOTP_GLOBALS, *PIPBOOTP_GLOBALS;


//
// external declaration of the global IPBOOTP struct
//

extern IPBOOTP_GLOBALS ig;


//
// config struct size macros
//

#define GC_SIZEOF(gc)   (sizeof(IPBOOTP_GLOBAL_CONFIG) +    \
                         (gc)->GC_ServerCount * sizeof(DWORD))
#define IC_SIZEOF(ic)   sizeof(IPBOOTP_IF_CONFIG)



//
// IP address conversion macro
//

#define INET_NTOA(addr) myinet_ntoa( *(PIN_ADDR)&(addr) )


//
// memory allocation macros
//

#define BOOTP_ALLOC(size)   HeapAlloc(ig.IG_GlobalHeap, 0, size)
#define BOOTP_FREE(ptr)     HeapFree(ig.IG_GlobalHeap, 0, ptr)




//
// macro invoked when entering API and worker functions
// returns TRUE if API should continue, FALSE otherwise;
//

#define ENTER_BOOTP_API()       EnterBootpAPI()
#define ENTER_BOOTP_WORKER()    EnterBootpWorker()



//
// macro invoked when leaving API and worker functions
//

#define LEAVE_BOOTP_API()       LeaveBootpWorker()
#define LEAVE_BOOTP_WORKER()    LeaveBootpWorker()



//
// Event logging macros
//

#define LOGLEVEL        ig.IG_LoggingLevel
#define LOGHANDLE       ig.IG_LoggingHandle
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData


// Error logging

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPBOOTPLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPBOOTPLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,IPBOOTPLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,IPBOOTPLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,IPBOOTPLOG_ ## msg,4,_asz,(err)); \
        }


// Warning logging

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,IPBOOTPLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,IPBOOTPLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,IPBOOTPLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,IPBOOTPLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,IPBOOTPLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,IPBOOTPLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


// Information logging

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,IPBOOTPLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,IPBOOTPLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,IPBOOTPLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,IPBOOTPLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPBOOTP_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,IPBOOTPLOG_ ## msg,4,_asz,(err)); \
        }



//
// constants and macros used for tracing
//

#define IPBOOTP_TRACE_ANY               ((DWORD)0xffff0000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_ENTER             ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_LEAVE             ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_IF                ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_SEND              ((DWORD)0x00080000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_RECEIVE           ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_CONFIG            ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_REQUEST           ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_REPLY             ((DWORD)0x00800000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_START             ((DWORD)0x01000000 | TRACE_USE_MASK)
#define IPBOOTP_TRACE_STOP              ((DWORD)0x02000000 | TRACE_USE_MASK)


#define TRACEID     ig.IG_TraceID


//
// macros used to generate output; the first argument indicates the
// level of tracing with which the output is associated 
// 
#define TRACE0(l,a)             \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPBOOTP_TRACE_ ## l, a)
#define TRACE1(l,a,b)           \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPBOOTP_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)         \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPBOOTP_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)       \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPBOOTP_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)     \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPBOOTP_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)   \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPBOOTP_TRACE_ ## l, a, b, c, d, e, f)



//
// function declarations for router manager interface:
//

DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );

DWORD 
WINAPI
StartProtocol (
    HANDLE              NotificationEvent,
    SUPPORT_FUNCTIONS   *SupportFunctions,
    LPVOID              GlobalInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    );

DWORD
WINAPI
StartComplete (
    VOID
    );

DWORD
APIENTRY
StopProtocol(
    VOID
    );

DWORD WINAPI
GetGlobalInfo (
    PVOID OutGlobalInfo,
    PULONG GlobalInfoSize,
    PULONG   StructureVersion,
    PULONG   StructureSize,
    PULONG   StructureCount
    );

DWORD WINAPI
SetGlobalInfo (
    PVOID   GlobalInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    );

DWORD WINAPI
AddInterface (
    PWCHAR              pwszInterfaceName,
    ULONG               InterfaceIndex,
    NET_INTERFACE_TYPE  InterfaceType,
    DWORD               MediaType,
    WORD                AccessType,
    WORD                ConnectionType,
    PVOID               InterfaceInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    );

DWORD
APIENTRY
DeleteInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT MESSAGE *pResult
    );

DWORD WINAPI
GetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   OutInterfaceInfo,
    PULONG  InterfaceInfoSize,
    PULONG  StructureVersion,
    PULONG  StructureSize,
    PULONG  StructureCount
    );

DWORD WINAPI
SetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   InterfaceInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    );

DWORD WINAPI
InterfaceStatus(
    ULONG    InterfaceIndex,
    BOOL     InterfaceActive,
    DWORD    StatusType,
    PVOID    StatusInfo
    );

DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );


DWORD
InputThread(
    PVOID pvParam
    );


DWORD
UpdateArpCache(
    DWORD dwIfIndex,
    DWORD dwAddress,
    PBYTE pbMacAddr,
    DWORD dwMacAddrLength,
    BOOL bAddEntry,
    SUPPORT_FUNCTIONS *pFunctions
    );


DWORD
QueueBootpWorker(
    WORKERFUNCTION pWorker,
    PVOID pContext
    );

BOOL
EnterBootpWorker(
    );

VOID
LeaveBootpWorker(
    );

BOOL
EnterBootpAPI(
    );


#endif // _API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\inc\worker.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inc\worker.h

Abstract:
    Header for worker threads for the router process

Revision History:

    Gurdeep Singh Pall          7/28/95  Created

--*/


//* Typedef for the worker function passed in QueueWorkItem API
//
typedef VOID (* WORKERFUNCTION) (PVOID) ;

DWORD QueueWorkItem (WORKERFUNCTION functionptr, PVOID context) ;

// The following defines are included here as a hint on how the worker thread pool is managed:
// The minimum number of threads is Number of processors + 1
// The maximum number of threads is MAX_WORKER_THREADS
// If work queue exceeds MAX_WORK_ITEM_THRESHOLD and we have not hit the max thread limit then another thread is created
// If work queue falls below MIN_WORK_ITEM_THRESHOLD and there are more than minimum threads then threads are killed.
//
// Note: changing these flags will not change anything.
//
#define MAX_WORKER_THREADS          10      // max number of threads at any time
#define MAX_WORK_ITEM_THRESHOLD     30      // backlog work item count at which another thread is kicked off
#define MIN_WORK_ITEM_THRESHOLD     2       // work item count at which extra threads are killed
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\api.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    api.c
//
// History:
//      Abolade Gbadegesin  August 31, 1995     Created
//
// BOOTP Relay Agent's interface to Router Manager
//============================================================================

#include "pchbootp.h"


IPBOOTP_GLOBALS ig;


DWORD
MibGetInternal(
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod,
    PDWORD pdwOutputSize,
    DWORD dwGetMode
    );

BOOL
DllStartup(
    );

BOOL
DllCleanup(
    );

DWORD
ProtocolStartup(
    HANDLE hEventEvent,
    PSUPPORT_FUNCTIONS pFunctionTable,
    PVOID pConfig
    );

DWORD
ProtocolCleanup(
    BOOL bCleanupWinsock
    );

DWORD
BindInterface(
    IN DWORD dwIndex,
    IN PVOID pBinding
    );

DWORD
UnBindInterface(
    IN DWORD dwIndex
    );

DWORD
EnableInterface(
    IN DWORD dwIndex
    );

DWORD
DisableInterface(
    IN DWORD dwIndex
    );


//----------------------------------------------------------------------------
// Function:    DLLMAIN
//
// This is the entry-point for IPBOOTP.DLL.
//----------------------------------------------------------------------------

BOOL
WINAPI
DLLMAIN(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pUnused
    ) {

    BOOL bErr;


    bErr = FALSE;

    switch(dwReason) {
        case DLL_PROCESS_ATTACH:

            DisableThreadLibraryCalls(hInstance);

            bErr = DllStartup();
            break;

        case DLL_PROCESS_DETACH:

            bErr = DllCleanup();
            break;

        default:
            bErr = TRUE;
            break;
    }

    return bErr;
}



//----------------------------------------------------------------------------
// Function:    DllStartup
//
// This function initializes IPBOOTP's global structure
// in preparation for calls to the API functions exported.
// It creates the global critical section, heap, and router-manager
// event message queue.
//----------------------------------------------------------------------------

BOOL
DllStartup(
    ) {

    BOOL bErr;
    DWORD dwErr;


    bErr = FALSE;


    do {

        ZeroMemory(&ig, sizeof(IPBOOTP_GLOBALS));


        try {
            InitializeCriticalSection(&ig.IG_CS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            dwErr = GetExceptionCode();
            break;
        }


        ig.IG_Status = IPBOOTP_STATUS_STOPPED;


        //
        // create the global heap for BOOTP
        //

        ig.IG_GlobalHeap = HeapCreate(0, 0, 0);
        if (ig.IG_GlobalHeap == NULL) {

            dwErr = GetLastError();
            break;
        }


        //
        // allocate space for the Router manager event queue
        //

        ig.IG_EventQueue = BOOTP_ALLOC(sizeof(LOCKED_LIST));

        if (ig.IG_EventQueue == NULL) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }


        //
        // now initialize the locked-list allocated
        //

        try {
            CREATE_LOCKED_LIST(ig.IG_EventQueue);
        }
        except(EXCEPTION_EXECUTE_HANDLER) {

            dwErr = GetExceptionCode();
            break;
        }


        bErr = TRUE;

    } while(FALSE);

    if (!bErr) {
        DllCleanup();
    }

    return bErr;
}



//----------------------------------------------------------------------------
// Function:    DllCleanup
//
// This function is called when the IPBOOTP DLL is being unloaded.
// It releases the resources allocated in DllStartup.
//----------------------------------------------------------------------------

BOOL
DllCleanup(
    ) {

    BOOL bErr;


    bErr = TRUE;

    do {


        //
        // delete and deallocate the event message queue
        //

        if (ig.IG_EventQueue != NULL) {

            if (LOCKED_LIST_CREATED(ig.IG_EventQueue)) {
                DELETE_LOCKED_LIST(ig.IG_EventQueue);
            }

            BOOTP_FREE(ig.IG_EventQueue);
        }



        //
        // destroy the global heap
        //

        if (ig.IG_GlobalHeap != NULL) {

            HeapDestroy(ig.IG_GlobalHeap);
        }


        //
        // delete the global critical section
        //

        DeleteCriticalSection(&ig.IG_CS);


        if (ig.IG_LoggingHandle != NULL)
            RouterLogDeregister(ig.IG_LoggingHandle);
        if (ig.IG_TraceID != INVALID_TRACEID) {
            TraceDeregister(ig.IG_TraceID);
        }

    } while(FALSE);


    return bErr;
}



//----------------------------------------------------------------------------
// Function:    ProtocolStartup
//
// This function is called by the router manager to start IPBOOTP.
// It sets up the data structures needed and starts the input thread.
//----------------------------------------------------------------------------

DWORD
ProtocolStartup(
    HANDLE hEventEvent,
    PSUPPORT_FUNCTIONS pFunctionTable,
    PVOID pConfig
    ) {

    WSADATA wd;
    HANDLE hThread;
    BOOL bCleanupWinsock;
    DWORD dwErr, dwSize, dwThread;
    PIPBOOTP_GLOBAL_CONFIG pgcsrc, pgcdst;


    ig.IG_TraceID = TraceRegister("IPBOOTP");
    ig.IG_LoggingHandle = RouterLogRegister("IPBOOTP");


    //
    // acquire the global critical section
    // while we look at the status code
    //

    EnterCriticalSection(&ig.IG_CS);


    //
    // make sure that BOOTP has not already started up
    //

    if (ig.IG_Status != IPBOOTP_STATUS_STOPPED) {

        TRACE0(START, "StartProtocol() has already been called");
        LOGWARN0(ALREADY_STARTED, 0);

        LeaveCriticalSection(&ig.IG_CS);

        return ERROR_CAN_NOT_COMPLETE;
    }


    //
    // initialize the global structures:
    //


    bCleanupWinsock = FALSE;


    do { // error break-out loop


        TRACE0(START, "IPBOOTP is starting up...");



        //
        // copy the global configuration passed in:
        // find its size, and the allocate space for the copy
        //

        pgcsrc = (PIPBOOTP_GLOBAL_CONFIG)pConfig;
        dwSize = GC_SIZEOF(pgcsrc);

        pgcdst = BOOTP_ALLOC(dwSize);

        if (pgcdst == NULL) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            TRACE2(
                START, "error %d allocating %d bytes for global config",
                dwErr, dwSize
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        RtlCopyMemory(pgcdst, pgcsrc, dwSize);

        ig.IG_Config = pgcdst;
        ig.IG_LoggingLevel = pgcdst->GC_LoggingLevel;



        //
        // initialize Windows Sockets
        //

        dwErr = (DWORD)WSAStartup(MAKEWORD(1,1), &wd);

        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d initializing Windows Sockets", dwErr);
            LOGERR0(INIT_WINSOCK_FAILED, dwErr);

            break;
        }


        bCleanupWinsock = TRUE;


        //
        // create the global structure lock
        //

        try {
            CREATE_READ_WRITE_LOCK(&ig.IG_RWL);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            dwErr = GetExceptionCode();
            TRACE1(START, "error %d creating synchronization object", dwErr);
            LOGERR0(CREATE_RWL_FAILED, dwErr);

            break;
        }


        //
        // initialize the interface table
        //

        ig.IG_IfTable = BOOTP_ALLOC(sizeof(IF_TABLE));

        if (ig.IG_IfTable == NULL) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            TRACE2(
                START, "error %d allocating %d bytes for interface table",
                dwErr, sizeof(IF_TABLE)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }



        //
        // initialize the interface table
        //

        dwErr = CreateIfTable(ig.IG_IfTable);

        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d initializing interface table", dwErr);
            LOGERR0(CREATE_IF_TABLE_FAILED, dwErr);

            break;
        }


        //
        // allocate the receive queue
        //

        ig.IG_RecvQueue = BOOTP_ALLOC(sizeof(LOCKED_LIST));

        if (ig.IG_RecvQueue == NULL) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            TRACE2(
                START, "error %d allocating %d bytes for receive queue",
                dwErr, sizeof(LOCKED_LIST)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the receive queue
        //

        try {
            CREATE_LOCKED_LIST(ig.IG_RecvQueue);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            dwErr = GetExceptionCode();
            TRACE1(START, "exception %d initializing locked list", dwErr);
            LOGERR0(INIT_CRITSEC_FAILED, dwErr);

            break;
        }


        //
        // copy the support-function table and Router Manager event
        //

        ig.IG_FunctionTable = pFunctionTable;

        ig.IG_EventEvent = hEventEvent;



        //
        // initialize count of active threads, and create the semaphore
        // signalled by threads exiting API functions and work functions
        //

        ig.IG_ActivityCount = 0;

        ig.IG_ActivitySemaphore = CreateSemaphore(NULL, 0, 0xfffffff, NULL);

        if (ig.IG_ActivitySemaphore == NULL) {

            dwErr = GetLastError();
            TRACE1(START, "error %d creating semaphore", dwErr);
            LOGERR0(CREATE_SEMAPHORE_FAILED, dwErr);

            break;
        }



        //
        // create the event used to signal on incoming packets
        //

        ig.IG_InputEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (ig.IG_InputEvent == NULL) {

            dwErr = GetLastError();
            TRACE1(START, "error %d creating input-event", dwErr);
            LOGERR0(CREATE_EVENT_FAILED, dwErr);

            break;
        }


        //
        // register the InputEvent with the NtdllWait thread
        //

         
        if (! RegisterWaitForSingleObject(
                  &ig.IG_InputEventHandle,
                  ig.IG_InputEvent,
                  CallbackFunctionNetworkEvents,
                  NULL,      //null context
                  INFINITE,  //no timeout
                  (WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE)
                  )) {

            dwErr = GetLastError();
            TRACE1(
                START, "error %d returned by RegisterWaitForSingleObjectEx",
                dwErr
                );
            LOGERR0(REGISTER_WAIT_FAILED, dwErr);
            break;

        }



        //
        // now set the status to running
        //

        ig.IG_Status = IPBOOTP_STATUS_RUNNING;


#if DBG

        //
        // register a timer queue with the NtdllTimer thread
        //
        ig.IG_TimerQueueHandle = CreateTimerQueue();

        if (!ig.IG_TimerQueueHandle) {

            dwErr = GetLastError();
            TRACE1(START, "error %d returned by CreateTimerQueue()", dwErr);
            LOGERR0(CREATE_TIMER_QUEUE_FAILED, dwErr);

            break;
        }



        //
        // set timer with NtdllTimer thread to display IPBOOTP MIB periodically
        //

        ig.IG_MibTraceID = TraceRegisterEx("IPBOOTPMIB", TRACE_USE_CONSOLE);

        if (ig.IG_MibTraceID != INVALID_TRACEID) {

             
            if (! CreateTimerQueueTimer(
                      &ig.IG_MibTimerHandle,
                      ig.IG_TimerQueueHandle,
                      CallbackFunctionMibDisplay,
                      NULL,           // null context
                      10000,          // display after 10 seconds
                      10000,          // display every 10 seconds
                      0               // execute in timer thread
                      )) {

                dwErr = GetLastError();
                TRACE1(
                    START, "error %d returned by CreateTimerQueueTimer()",
                    dwErr
                    );
                break;
            }
        }

#endif


        TRACE0(START, "IP BOOTP started successfully");

        LOGINFO0(STARTED, 0);


        LeaveCriticalSection(&ig.IG_CS);

        return NO_ERROR;

    } while(FALSE);


    //
    // an error occurred if control-flow brings us here
    //

    TRACE0(START, "IPRIP failed to start");

    ProtocolCleanup(bCleanupWinsock);

    LeaveCriticalSection(&ig.IG_CS);

    return (dwErr == NO_ERROR ? ERROR_CAN_NOT_COMPLETE : dwErr);
}




//----------------------------------------------------------------------------
// Function:    ProtocolCleanup
//
// This function cleans up resources used by IPBOOTP while it is
// in operation. Essentially, everything created in ProtocolStartup
// is cleaned up by the function.
//----------------------------------------------------------------------------

DWORD
ProtocolCleanup(
    BOOL bCleanupWinsock
    ) {

    DWORD dwErr;


    //
    // lock things down while we clean up
    //

    EnterCriticalSection(&ig.IG_CS);

#if DBG

    TraceDeregister(ig.IG_MibTraceID);

#endif


    if (ig.IG_InputEvent != NULL) {

        CloseHandle(ig.IG_InputEvent);
        ig.IG_InputEvent = NULL;
    }


    if (ig.IG_ActivitySemaphore != NULL) {

        CloseHandle(ig.IG_ActivitySemaphore);
        ig.IG_ActivitySemaphore = NULL;
    }


    if (ig.IG_RecvQueue != NULL) {

        if (LOCKED_LIST_CREATED(ig.IG_RecvQueue)) {
            DELETE_LOCKED_LIST(ig.IG_RecvQueue);
        }

        BOOTP_FREE(ig.IG_RecvQueue);
        ig.IG_RecvQueue = NULL;
    }


    if (ig.IG_IfTable != NULL) {

        if (IF_TABLE_CREATED(ig.IG_IfTable)) {
            DeleteIfTable(ig.IG_IfTable);
        }

        BOOTP_FREE(ig.IG_IfTable);
        ig.IG_IfTable = NULL;
    }


    if (READ_WRITE_LOCK_CREATED(&ig.IG_RWL)) {

        try {
            DELETE_READ_WRITE_LOCK(&ig.IG_RWL);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            dwErr = GetExceptionCode();
        }
    }


    if (bCleanupWinsock) {
        WSACleanup();
    }


    if (ig.IG_Config != NULL) {

        BOOTP_FREE(ig.IG_Config);
        ig.IG_Config = NULL;
    }


    ig.IG_Status = IPBOOTP_STATUS_STOPPED;

    LeaveCriticalSection(&ig.IG_CS);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    RegisterProtocol
//
// This function is called by the router manager
// to retrieve information about IPBOOTP's capabilities
//----------------------------------------------------------------------------

DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    )
{
    if(pRoutingChar->dwProtocolId != MS_IP_BOOTP)
    {
        return ERROR_NOT_SUPPORTED;
    }

    pServiceChar->fSupportedFunctionality = 0;

    if(!(pRoutingChar->fSupportedFunctionality & RF_ROUTING))
    {
        return ERROR_NOT_SUPPORTED;
    }

    pRoutingChar->fSupportedFunctionality = RF_ROUTING;

    pRoutingChar->pfnStartProtocol      = StartProtocol;
    pRoutingChar->pfnStartComplete      = StartComplete;
    pRoutingChar->pfnStopProtocol       = StopProtocol;
    pRoutingChar->pfnGetGlobalInfo      = GetGlobalInfo;
    pRoutingChar->pfnSetGlobalInfo      = SetGlobalInfo;
    pRoutingChar->pfnQueryPower         = NULL;
    pRoutingChar->pfnSetPower           = NULL;

    pRoutingChar->pfnAddInterface       = AddInterface;
    pRoutingChar->pfnDeleteInterface    = DeleteInterface;
    pRoutingChar->pfnInterfaceStatus    = InterfaceStatus;
    pRoutingChar->pfnGetInterfaceInfo   = GetInterfaceConfigInfo;
    pRoutingChar->pfnSetInterfaceInfo   = SetInterfaceConfigInfo;

    pRoutingChar->pfnGetEventMessage    = GetEventMessage;

    pRoutingChar->pfnUpdateRoutes       = NULL;

    pRoutingChar->pfnConnectClient      = NULL;
    pRoutingChar->pfnDisconnectClient   = NULL;

    pRoutingChar->pfnGetNeighbors       = NULL;
    pRoutingChar->pfnGetMfeStatus       = NULL;

    pRoutingChar->pfnMibCreateEntry     = MibCreate;
    pRoutingChar->pfnMibDeleteEntry     = MibDelete;
    pRoutingChar->pfnMibGetEntry        = MibGet;
    pRoutingChar->pfnMibSetEntry        = MibSet;
    pRoutingChar->pfnMibGetFirstEntry   = MibGetFirst;
    pRoutingChar->pfnMibGetNextEntry    = MibGetNext;

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    StartProtocol
//
// This function is called by the router manager
// to start IPBOOTP.
//----------------------------------------------------------------------------

DWORD
WINAPI
StartProtocol (
    HANDLE              NotificationEvent,
    SUPPORT_FUNCTIONS   *SupportFunctions,
    LPVOID              GlobalInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    )
{
    return ProtocolStartup(NotificationEvent, SupportFunctions, GlobalInfo);
}



//----------------------------------------------------------------------------
// Function:    StartComplete
//
// This function is called by the router manager
// to start IPBOOTP.
//----------------------------------------------------------------------------

DWORD
WINAPI
StartComplete (
    VOID
    )
{
    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    StopProtocol
//
// This function notifies all active threads to stop, and frees resources
// used by IP BOOTP
//----------------------------------------------------------------------------

DWORD
APIENTRY
StopProtocol(
    VOID
    ) {


    DWORD dwErr;
    LONG lThreadCount;
    HANDLE WaitHandle;
    

    //
    // make sure IPBOOTP has not already stopped
    //

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status != IPBOOTP_STATUS_RUNNING) {

        LeaveCriticalSection(&ig.IG_CS);
        return ERROR_CAN_NOT_COMPLETE;
    }


    TRACE0(ENTER, "entering StopProtocol");



    //
    // update the status to prevent any APIs or worker-functions from running
    //

    ig.IG_Status = IPBOOTP_STATUS_STOPPING;



    //
    // see how many threads are already in API calls
    // or in worker-function code
    //

    lThreadCount = ig.IG_ActivityCount;

    TRACE1(STOP, "%d threads are active in IPBOOTP", lThreadCount);



    LeaveCriticalSection(&ig.IG_CS);



    //
    // wait for active threads to stop
    //

    while (lThreadCount-- > 0) {
        WaitForSingleObject(ig.IG_ActivitySemaphore, INFINITE);
    }


    //
    // deregister the mib timer from the Ntdll threads
    // This has to be done outside IG_CS lock.
    //

#if DBG
    DeleteTimerQueueEx(ig.IG_TimerQueueHandle, INVALID_HANDLE_VALUE);
#endif

    //
    // set the handle to NULL, so that Unregister wont be called
    //

    WaitHandle = InterlockedExchangePointer(&ig.IG_InputEventHandle, NULL);
        
    if (WaitHandle) {
        UnregisterWaitEx( WaitHandle, INVALID_HANDLE_VALUE ) ;
    }



    //
    // enter the critical section and leave,
    // to make certain all the threads have returned from LeaveBootpWorker
    //

    EnterCriticalSection(&ig.IG_CS);
    LeaveCriticalSection(&ig.IG_CS);


    //
    // now all threads have stopped
    //

    TRACE0(STOP, "all threads stopped, BOOTP is cleaning up resources");

    LOGINFO0(STOPPED, 0);


    ProtocolCleanup(TRUE);

    return NO_ERROR;
}





//----------------------------------------------------------------------------
// Function:    GetGlobalInfo
//
// Copies BOOTP's global config into the buffer provided.
//----------------------------------------------------------------------------

DWORD WINAPI
GetGlobalInfo (
    PVOID   OutGlobalInfo,
    PULONG  GlobalInfoSize,
    PULONG  StructureVersion,
    PULONG  StructureSize,
    PULONG  StructureCount
    )
{
    DWORD dwErr = NO_ERROR, dwSize;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(ENTER, "entering GetGlobalInfo: 0x%08x 0x%08x", OutGlobalInfo, GlobalInfoSize);


    //
    // in order to do anything, we need a valid size pointer
    //

    if (GlobalInfoSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {

        //
        // check the size of the config block passed in
        // and copy the config if the buffer is large enough
        //

        ACQUIRE_READ_LOCK(&ig.IG_RWL);

        dwSize = GC_SIZEOF(ig.IG_Config);
        if (*GlobalInfoSize < dwSize) {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        if (OutGlobalInfo != NULL) {

            RtlCopyMemory(
                OutGlobalInfo,
                ig.IG_Config,
                dwSize
                );
        }

        *GlobalInfoSize = dwSize;

        if (StructureSize) *StructureSize = *GlobalInfoSize;
        if (StructureCount) *StructureCount = 1;
        if (StructureVersion) *StructureVersion = BOOTP_CONFIG_VERSION_500;
        
        RELEASE_READ_LOCK(&ig.IG_RWL);
    }

    TRACE1(LEAVE, "leaving GetGlobalInfo: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    SetGlobalInfo
//
// Copies over the specified configuration .
//----------------------------------------------------------------------------

DWORD WINAPI
SetGlobalInfo (
    PVOID   GlobalInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    )
{
    DWORD dwErr, dwSize;
    PIPBOOTP_GLOBAL_CONFIG pgcsrc, pgcdst;

    if (!GlobalInfo || !ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE1(ENTER, "entering SetGlobalInfo: %p", GlobalInfo);


    ACQUIRE_WRITE_LOCK(&ig.IG_RWL);

    pgcsrc = (PIPBOOTP_GLOBAL_CONFIG)GlobalInfo;
    dwSize = GC_SIZEOF(pgcsrc);


    //
    // allocate memory for the new config block, and copy it over
    //

    pgcdst = BOOTP_ALLOC(dwSize);

    if (pgcdst == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        TRACE2(
            CONFIG, "error %d allocating %d bytes for global config",
            dwErr, dwSize
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);
    }
    else {

        RtlCopyMemory(
            pgcdst,
            pgcsrc,
            dwSize
            );

        BOOTP_FREE(ig.IG_Config);
        ig.IG_Config = pgcdst;

        dwErr = NO_ERROR;
    }

    RELEASE_WRITE_LOCK(&ig.IG_RWL);


    TRACE1(LEAVE, "leaving SetGlobalInfo: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    AddInterface
//
// Adds an interface with the specified index and configuration.
//----------------------------------------------------------------------------

DWORD WINAPI
AddInterface (
    PWCHAR              pwszInterfaceName,
    ULONG               InterfaceIndex,
    NET_INTERFACE_TYPE  InterfaceType,
    DWORD               MediaType,
    WORD                AccessType,
    WORD                ConnectionType,
    PVOID               InterfaceInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    )
{
    DWORD dwErr;
    PIF_TABLE pTable;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE3(
        ENTER, "entering AddInterface: %d %d %p",
        InterfaceIndex, InterfaceType, InterfaceInfo
        );


    pTable = ig.IG_IfTable;

    ACQUIRE_WRITE_LOCK(&pTable->IT_RWL);


    dwErr = CreateIfEntry(pTable, InterfaceIndex, InterfaceInfo);


    RELEASE_WRITE_LOCK(&pTable->IT_RWL);


    TRACE1(LEAVE, "leaving AddInterface: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DeleteInterface
//
// Removes the interface with the specified index.
//----------------------------------------------------------------------------
DWORD
APIENTRY
DeleteInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE1(ENTER, "entering DeleteInterface: %d", dwIndex);


    pTable = ig.IG_IfTable;

    ACQUIRE_WRITE_LOCK(&pTable->IT_RWL);


    dwErr = DeleteIfEntry(pTable, dwIndex);


    RELEASE_WRITE_LOCK(&pTable->IT_RWL);


    TRACE1(LEAVE, "leaving DeleteInterface: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    GetEventMessage
//
// Returns the first event in the ROuter Manager event queue, if any.
//----------------------------------------------------------------------------
DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT MESSAGE *pResult
    ) {

    DWORD dwErr;
    PLOCKED_LIST pll;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(ENTER, "entering GetEventMessage: 0x%08x 0x%08x", pEvent, pResult);


    pll = ig.IG_EventQueue;

    ACQUIRE_LIST_LOCK(pll);

    dwErr = DequeueEvent(pll, pEvent, pResult);

    RELEASE_LIST_LOCK(pll);


    TRACE1(LEAVE, "leaving GetEventMessage: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    GetInterfaceConfigInfo
//
// Returns the configuration for the specified interface.
//----------------------------------------------------------------------------

DWORD WINAPI
GetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   OutInterfaceInfo,
    PULONG  InterfaceInfoSize,
    PULONG  StructureVersion,
    PULONG  StructureSize,
    PULONG  StructureCount
    )
{
    PIF_TABLE pTable;
    DWORD dwErr, dwSize;
    PIF_TABLE_ENTRY pite;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE3(
        ENTER, "entering GetInterfaceConfigInfo: %d %p %p",
        InterfaceIndex, InterfaceInfoSize, OutInterfaceInfo
        );


    //
    // in order to do anything, we need a valid size pointer
    //

    if (InterfaceInfoSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {

        pTable = ig.IG_IfTable;

        ACQUIRE_READ_LOCK(&pTable->IT_RWL);


        //
        // retrieve the interface to be re-configured
        //

        pite = GetIfByIndex(pTable, InterfaceIndex);

        if (pite == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else {


            //
            // compute the interface configuration's size,
            // and copy the config to the caller's buffer
            // if the caller's buffer is large enough
            //

            dwSize = IC_SIZEOF(pite->ITE_Config);

            if (*InterfaceInfoSize < dwSize || OutInterfaceInfo == NULL) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

                PIPBOOTP_IF_CONFIG picdst = OutInterfaceInfo;

                CopyMemory(picdst, pite->ITE_Config, dwSize);

                picdst->IC_State = 0;

                if (IF_IS_ENABLED(pite)) {
                    picdst->IC_State |= IPBOOTP_STATE_ENABLED;
                }

                if (IF_IS_BOUND(pite)) {
                    picdst->IC_State |= IPBOOTP_STATE_BOUND;
                }

                dwErr = NO_ERROR;
            }


            *InterfaceInfoSize = dwSize;
            
            if (StructureSize) *StructureSize = *InterfaceInfoSize;
            if (StructureCount) *StructureCount = 1;
            if (StructureVersion) *StructureVersion = BOOTP_CONFIG_VERSION_500;
        
        }

        RELEASE_READ_LOCK(&pTable->IT_RWL);
    }



    TRACE1(LEAVE, "leaving GetInterfaceConfigInfo: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    SetInterfaceConfigInfo
//
// Copies over the specified interface configuration.
//----------------------------------------------------------------------------

DWORD WINAPI
SetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   InterfaceInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    )
{
    PIF_TABLE pTable;
    DWORD dwErr, dwSize;
    PIF_TABLE_ENTRY pite;
    PIPBOOTP_IF_CONFIG picsrc, picdst;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(
        ENTER, "entering SetInterfaceConfigInfo: %d %p", InterfaceIndex, InterfaceInfo
        );


    pTable = ig.IG_IfTable;

    ACQUIRE_WRITE_LOCK(&pTable->IT_RWL);


    dwErr = ConfigureIfEntry(pTable, InterfaceIndex, InterfaceInfo);


    RELEASE_WRITE_LOCK(&pTable->IT_RWL);


    TRACE1(LEAVE, "leaving SetInterfaceConfigInfo: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}


DWORD WINAPI
InterfaceStatus(
    ULONG    InterfaceIndex,
    BOOL     InterfaceActive,
    DWORD    StatusType,
    PVOID    StatusInfo
    )
{
    DWORD   dwResult;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    switch(StatusType)
    {
        case RIS_INTERFACE_ADDRESS_CHANGE:
        {
            PIP_ADAPTER_BINDING_INFO    pBindInfo;

            pBindInfo = (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if(pBindInfo->AddressCount)
            {
                dwResult = BindInterface(InterfaceIndex,
                                         pBindInfo);
            }
            else
            {
                dwResult = UnBindInterface(InterfaceIndex);
            }

            break;
        }

        case RIS_INTERFACE_ENABLED:
        {
            dwResult = EnableInterface(InterfaceIndex);

            break;
        }

        case RIS_INTERFACE_DISABLED:
        {
            dwResult = DisableInterface(InterfaceIndex);

            break;

        }

        default:
        {
            RTASSERT(FALSE);

            dwResult = ERROR_INVALID_PARAMETER;
        }
    }

    LEAVE_BOOTP_API();

    return dwResult;
}



//----------------------------------------------------------------------------
// Function:    BindInterface
//
// Sets the IP address and network mask for the specified interface.
//----------------------------------------------------------------------------

DWORD
APIENTRY
BindInterface(
    IN DWORD dwIndex,
    IN PVOID pBinding
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;


    TRACE2(ENTER, "entering BindInterface: %d 0x%08x", dwIndex, pBinding);


    pTable = ig.IG_IfTable;

    ACQUIRE_WRITE_LOCK(&pTable->IT_RWL);


    dwErr = BindIfEntry(pTable, dwIndex, pBinding);


    RELEASE_WRITE_LOCK(&pTable->IT_RWL);


    TRACE1(LEAVE, "leaving BindInterface: %d", dwErr);


    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    UnBindInterface
//
// Removes the IP address associated with the specified interface
//----------------------------------------------------------------------------

DWORD
APIENTRY
UnBindInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;


    TRACE1(ENTER, "entering UnBindInterface: %d", dwIndex);


    pTable = ig.IG_IfTable;

    ACQUIRE_WRITE_LOCK(&pTable->IT_RWL);


    dwErr = UnBindIfEntry(pTable, dwIndex);


    RELEASE_WRITE_LOCK(&pTable->IT_RWL);


    TRACE1(LEAVE, "leaving UnBindInterface: %d", dwErr);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    EnableInterface
//
//----------------------------------------------------------------------------

DWORD
APIENTRY
EnableInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    TRACE1(ENTER, "entering EnableInterface: %d", dwIndex);


    pTable = ig.IG_IfTable;

    ACQUIRE_WRITE_LOCK(&pTable->IT_RWL);


    dwErr = EnableIfEntry(pTable, dwIndex);


    RELEASE_WRITE_LOCK(&pTable->IT_RWL);


    TRACE1(LEAVE, "leaving EnableInterface: %d", dwErr);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DisableInterface
//
//----------------------------------------------------------------------------

DWORD
APIENTRY
DisableInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;
    PIF_TABLE_ENTRY pite;

    TRACE1(ENTER, "entering DisableInterface: %d", dwIndex);


    pTable = ig.IG_IfTable;

    ACQUIRE_WRITE_LOCK(&pTable->IT_RWL);


    dwErr = DisableIfEntry(pTable, dwIndex);


    RELEASE_WRITE_LOCK(&pTable->IT_RWL);


    TRACE1(LEAVE, "leaving DisableInterface: %d", dwErr);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    DoUpdateRoutes
//
// This API is unsupported since BOOTP is not a routing protocol.
//----------------------------------------------------------------------------

DWORD
APIENTRY
DoUpdateRoutes(
    IN DWORD dwIndex
    ) {

    return ERROR_CAN_NOT_COMPLETE;
}



//----------------------------------------------------------------------------
// Function:    MibCreate
//
// BOOTP does not have create-able MIB fields.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    ) {

    return ERROR_CAN_NOT_COMPLETE;
}



//----------------------------------------------------------------------------
// Function:    MibDelete
//
// BOOTP does not have delete-able MIB fields
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    ) {

    return ERROR_CAN_NOT_COMPLETE;
}



//----------------------------------------------------------------------------
// Function:    MibSet
//
// This is called to modify writable MIB variables.
// The writable entries are the global config and interface config.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    ) {

    DWORD dwErr;
    PIPBOOTP_MIB_SET_INPUT_DATA pimsid;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(ENTER, "entering MibSet: %d 0x%08x", dwInputSize, pInputData);


    dwErr = NO_ERROR;

    do { // breakout loop


        //
        // make certain the parameters are acceptable
        //

        if (pInputData == NULL ||
            dwInputSize < sizeof(IPBOOTP_MIB_SET_INPUT_DATA)) {

            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // see which entry type is to be set
        //

        pimsid = (PIPBOOTP_MIB_SET_INPUT_DATA)pInputData;

        switch(pimsid->IMSID_TypeID) {


            case IPBOOTP_GLOBAL_CONFIG_ID: {

                PIPBOOTP_GLOBAL_CONFIG pigc;


                //
                // make sure the buffer is big enough
                // to hold a global config block
                //

                if (pimsid->IMSID_BufferSize < sizeof(IPBOOTP_GLOBAL_CONFIG)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }


                //
                // call the router manager API to set the config
                //

                dwErr = SetGlobalInfo(pimsid->IMSID_Buffer,
                                      1,
                                      sizeof(IPBOOTP_GLOBAL_CONFIG),
                                      1);

                if (dwErr == NO_ERROR) {

                    //
                    // the set succeeded, so notify the router manager
                    // that the global config has changed and should be saved
                    //

                    MESSAGE msg = {0, 0, 0};

                    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
                    EnqueueEvent(
                        ig.IG_EventQueue,
                        SAVE_GLOBAL_CONFIG_INFO,
                        msg
                        );
                    SetEvent(ig.IG_EventEvent);
                    RELEASE_LIST_LOCK(ig.IG_EventQueue);
                }

                break;
            }

            case IPBOOTP_IF_CONFIG_ID: {

                DWORD dwSize;
                PIF_TABLE pTable;
                PIF_TABLE_ENTRY pite;
                PIPBOOTP_IF_CONFIG pic;


                //
                // make sure the buffer is big enough
                // to hold an interface config block
                //

                if (pimsid->IMSID_BufferSize < sizeof(IPBOOTP_IF_CONFIG)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }


                pic = (PIPBOOTP_IF_CONFIG)pimsid->IMSID_Buffer;

                pTable = ig.IG_IfTable;


                ACQUIRE_WRITE_LOCK(&pTable->IT_RWL);


                //
                // find the interface and update its config
                //

                pite = GetIfByIndex(
                            pTable,
                            pimsid->IMSID_IfIndex
                            );

                if (pite == NULL) {

                    TRACE1(
                        CONFIG, "MibSet: could not find interface %d",
                        pimsid->IMSID_IfIndex
                        );

                    dwErr = ERROR_INVALID_PARAMETER;
                }
                else {

                    //
                    // configure the interface
                    //

                    dwErr = ConfigureIfEntry(pTable, pite->ITE_Index, pic);
                }


                if (dwErr == NO_ERROR) {

                    //
                    // notify Router manager that config has changed
                    //

                    MESSAGE msg = {0, 0, 0};

                    msg.InterfaceIndex = pite->ITE_Index;

                    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
                    EnqueueEvent(
                        ig.IG_EventQueue,
                        SAVE_INTERFACE_CONFIG_INFO,
                        msg
                        );
                    SetEvent(ig.IG_EventEvent);
                    RELEASE_LIST_LOCK(ig.IG_EventQueue);
                }


                RELEASE_WRITE_LOCK(&pTable->IT_RWL);

                break;
            }
            default: {
                dwErr = ERROR_INVALID_PARAMETER;
            }
        }
    } while(FALSE);

    LEAVE_BOOTP_API();

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    MibGet
//
// This function retrieves a MIB entry.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    ) {

    DWORD dwErr;
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid;
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE4(
        ENTER, "entering MibGet: %d 0x%08x 0x%08x 0x%08x",
        dwInputSize, pInputData, pdwOutputSize, pOutputData
        );

    if (pInputData == NULL ||
        dwInputSize < sizeof(IPBOOTP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {

        //
        // invoke the internal function for retrieving the MIB
        //

        pimgid = (PIPBOOTP_MIB_GET_INPUT_DATA)pInputData;
        pimgod = (PIPBOOTP_MIB_GET_OUTPUT_DATA)pOutputData;

        dwErr = MibGetInternal(pimgid, pimgod, pdwOutputSize, GETMODE_EXACT);
    }


    TRACE1(LEAVE, "leaving MibGet: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    MibGetFirst
//
// This function retrieve a MIB entry from one of the MIB tables,
// but it differs from MibGet in that it always returns the first entry
// in the table specified.
//----------------------------------------------------------------------------
DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    ) {

    DWORD dwErr;
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid;
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE4(
        ENTER, "entering MibGetFirst: %d 0x%08x 0x%08x 0x%08x",
        dwInputSize, pInputData, pdwOutputSize, pOutputData
        );


    if (pInputData == NULL ||
        dwInputSize < sizeof(IPBOOTP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {

        pimgid = (PIPBOOTP_MIB_GET_INPUT_DATA)pInputData;
        pimgod = (PIPBOOTP_MIB_GET_OUTPUT_DATA)pOutputData;

        dwErr = MibGetInternal(pimgid, pimgod, pdwOutputSize, GETMODE_FIRST);
    }


    TRACE1(LEAVE, "leaving MibGetFirst: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibGetNext
//
// This function retrieves a MIB entry from one of the MIB tables.
// It differs from MibGet() and MibGetFirst() in that the input
// specifies the index of a MIB entry, and this entry returns the MIB entry
// which is AFTER the entry whose index is specified.
//
// If the index specified is that of the last entry in the specified table,
// this function wraps to the FIRST entry in the NEXT table, where "NEXT"
// here means the table whose ID is one greater than the ID passed in.
// Thus calling MibGetNext() for the last entry in the interface stats table
// will return the first entry in the interface config table.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    ) {

    DWORD dwErr, dwOutSize = 0, dwBufSize = 0;
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid;
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod;

    if (!ENTER_BOOTP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE4(
        ENTER, "entering MibGetNext: %d 0x%08x 0x%08x 0x%08x",
        dwInputSize, pInputData, pdwOutputSize, pOutputData
        );


    if (pInputData == NULL ||
        dwInputSize < sizeof(IPBOOTP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {

        pimgid = (PIPBOOTP_MIB_GET_INPUT_DATA)pInputData;
        pimgod = (PIPBOOTP_MIB_GET_OUTPUT_DATA)pOutputData;

        dwOutSize = *pdwOutputSize;

        dwErr = MibGetInternal(pimgid, pimgod, pdwOutputSize, GETMODE_NEXT);

        if (dwErr == ERROR_NO_MORE_ITEMS) {

            //
            // wrap to the first entry in the next table
            //

            TRACE1(
                CONFIG, "MibGetNext is wrapping to table %d",
                pimgid->IMGID_TypeID + 1
            );


            //
            // restore the size passed in
            //

            *pdwOutputSize = dwOutSize;


            //
            // wrap to the next table by incrementing the type ID
            //

            ++pimgid->IMGID_TypeID;
            dwErr = MibGetInternal(
                        pimgid, pimgod, pdwOutputSize, GETMODE_FIRST
                        );
            --pimgid->IMGID_TypeID;
        }
    }

    TRACE1(LEAVE, "leaving MibGetNext: %d", dwErr);

    LEAVE_BOOTP_API();

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    MibGetInternal
//
// This function handles the structure queries necessary to read MIB data.
// Each table exposed by IPBOOTP supports three types of queries:
// EXACT, FIRST, and NEXT, which correspond to the functions MibGet(),
// MibGetFirst(), and MibGetNext() respectively.
//----------------------------------------------------------------------------

DWORD
MibGetInternal(
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod,
    PDWORD pdwOutputSize,
    DWORD dwGetMode
    ) {

    DWORD dwErr, dwBufSize, dwSize;
    ULONG   ulVersion, ulSize,ulCount;

    dwErr = NO_ERROR;


    //
    // first we use pdwOutputSize  to compute the size of the buffer
    // available (i.e. the size of IMGOD_Buffer
    //

    if (pimgod == NULL ||
        *pdwOutputSize < sizeof(IPBOOTP_MIB_GET_OUTPUT_DATA)) {
        dwBufSize = 0;
    }
    else {
        dwBufSize = *pdwOutputSize - sizeof(IPBOOTP_MIB_GET_OUTPUT_DATA) + 1;
    }

    *pdwOutputSize = 0;


    //
    // determine which type of data is to be returned
    //

    switch (pimgid->IMGID_TypeID) {

        case IPBOOTP_GLOBAL_CONFIG_ID: {

            //
            // the global config struct is variable-length,
            // so we wait until it has been retrieved before setting the size;
            // GETMODE_NEXT is invalid since there is only one global config
            //

            if (pimgod) { pimgod->IMGOD_TypeID = IPBOOTP_GLOBAL_CONFIG_ID; }

            if (dwGetMode == GETMODE_NEXT) {
                dwErr = ERROR_NO_MORE_ITEMS;
                break;
            }


            //
            // Use GetGlobalInfo to retrieve the global information;
            // It will decide whether the buffer is large enough,
            // and it will set the required size. Then all we need to do
            // is write out the size set by GetGlobalInfo.
            //

            if (pimgod == NULL) {
                dwErr = GetGlobalInfo(NULL, &dwBufSize, NULL, NULL, NULL);
            }
            else {

                dwErr = GetGlobalInfo(
                            pimgod->IMGOD_Buffer, &dwBufSize, &ulVersion, &ulSize, &ulCount
                            );
            }

            *pdwOutputSize = sizeof(IPBOOTP_MIB_GET_OUTPUT_DATA) - 1 +
                             dwBufSize;

            break;
        }


        case IPBOOTP_IF_STATS_ID: {

            //
            // the interface stats struct is fixed-length,
            // with as many entries as there are interfaces
            //

            PIF_TABLE pTable;
            PIF_TABLE_ENTRY pite;
            PIPBOOTP_IF_STATS pissrc, pisdst;


            //
            // set the size needed right away
            //

            *pdwOutputSize = sizeof(IPBOOTP_MIB_GET_OUTPUT_DATA) - 1 +
                             sizeof(IPBOOTP_IF_STATS);
            if (pimgod) { pimgod->IMGOD_TypeID = IPBOOTP_IF_STATS_ID; }


            pTable = ig.IG_IfTable;


            ACQUIRE_READ_LOCK(&pTable->IT_RWL);

            pite  = GetIfByListIndex(
                        pTable,
                        pimgid->IMGID_IfIndex,
                        dwGetMode,
                        &dwErr
                        );

            //
            // if the interface was not found, it may mean
            // the specified index was invalid, or it may mean that
            // GETMODE_NEXT was attempted on the last interface,
            // in which case dwErr contains ERROR_NO_MORE_ITEMS.
            // In any case, we make sure dwErr contains an error code
            // and then return.
            //

            if (pite == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_INVALID_PARAMETER; }
            }
            else
            if (pimgod == NULL) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

                //
                // write the index of the interface
                // whose stats are to be returned
                //

                pimgod->IMGOD_IfIndex = pite->ITE_Index;


                //
                // if the buffer is large enough, copy the stats to it
                //

                if (dwBufSize < sizeof(IPBOOTP_IF_STATS)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {

                    //
                    // since access to this structure is not synchronized
                    // we must copy it field by field
                    //

                    pissrc = &pite->ITE_Stats;
                    pisdst = (PIPBOOTP_IF_STATS)pimgod->IMGOD_Buffer;

                    pisdst->IS_State = 0;

                    if (IF_IS_ENABLED(pite)) {
                        pisdst->IS_State |= IPBOOTP_STATE_ENABLED;
                    }

                    if (IF_IS_BOUND(pite)) {
                        pisdst->IS_State |= IPBOOTP_STATE_BOUND;
                    }

                    pisdst->IS_SendFailures =
                            pissrc->IS_SendFailures;
                    pisdst->IS_ReceiveFailures =
                            pissrc->IS_ReceiveFailures;
                    pisdst->IS_ArpUpdateFailures =
                            pissrc->IS_ArpUpdateFailures;
                    pisdst->IS_RequestsReceived =
                            pissrc->IS_RequestsReceived;
                    pisdst->IS_RequestsDiscarded =
                            pissrc->IS_RequestsDiscarded;
                    pisdst->IS_RepliesReceived =
                            pissrc->IS_RepliesReceived;
                    pisdst->IS_RepliesDiscarded =
                            pissrc->IS_RepliesDiscarded;
                }
            }

            RELEASE_READ_LOCK(&pTable->IT_RWL);


            break;
        }

        case IPBOOTP_IF_CONFIG_ID: {


            PIF_TABLE pTable;
            PIF_TABLE_ENTRY pite;
            PIPBOOTP_IF_CONFIG picsrc, picdst;

            if (pimgod) { pimgod->IMGOD_TypeID = IPBOOTP_IF_CONFIG_ID; }

            pTable = ig.IG_IfTable;

            ACQUIRE_READ_LOCK(&pTable->IT_RWL);


            //
            // retrieve the interface whose config is to be read
            //

            pite = GetIfByListIndex(
                        pTable, pimgid->IMGID_IfIndex, dwGetMode, &dwErr
                        );

            //
            // if the interface was not found, it may mean that the index
            // specified was invalid, or it may mean that a GETMODE_NEXT
            // retrieval was attempted on the last interface, in which case
            // ERROR_NO_MORE_ITEMS would have been returned
            //

            if (pite == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_INVALID_PARAMETER; }
            }
            else {

                picsrc = pite->ITE_Config;
                dwSize = IC_SIZEOF(picsrc);
                *pdwOutputSize = sizeof(IPBOOTP_MIB_GET_OUTPUT_DATA) - 1 +
                                 dwSize;

                //
                // if no buffer was specified, indicate one should be allocated
                //

                if (pimgod == NULL) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {

                    //
                    // if the buffer is not large enough,
                    // indicate that it should be enlarged
                    //

                    if (dwBufSize < dwSize) {
                        dwErr = ERROR_INSUFFICIENT_BUFFER;
                    }
                    else {

                        //
                        // copy the configuration
                        //

                        picdst = (PIPBOOTP_IF_CONFIG)pimgod->IMGOD_Buffer;
                        CopyMemory(picdst, picsrc, dwSize);

                        picdst->IC_State = 0;

                        if (IF_IS_ENABLED(pite)) {
                            picdst->IC_State |= IPBOOTP_STATE_ENABLED;
                        }

                        if (IF_IS_BOUND(pite)) {
                            picdst->IC_State |= IPBOOTP_STATE_BOUND;
                        }
                    }

                    pimgod->IMGOD_IfIndex = pite->ITE_Index;
                }

            }

            RELEASE_READ_LOCK(&pTable->IT_RWL);

            break;
        }

        case IPBOOTP_IF_BINDING_ID: {

            PIF_TABLE pTable;
            PIF_TABLE_ENTRY pite;
            PIPBOOTP_IF_BINDING pibsrc, pibdst;

            if (pimgod) { pimgod->IMGOD_TypeID = IPBOOTP_IF_BINDING_ID; }

            pTable = ig.IG_IfTable;

            ACQUIRE_READ_LOCK(&pTable->IT_RWL);


            //
            // retrieve the interface whose binding is to be read
            //

            pite = GetIfByListIndex(
                        pTable, pimgid->IMGID_IfIndex, dwGetMode, &dwErr
                        );

            //
            // if the interface was not found, it may mean that the index
            // specified was invalid, or it may mean that a GETMODE_NEXT
            // retrieval was attempted on the last interface, in which case
            // ERROR_NO_MORE_ITEMS would have been returned
            //

            if (pite == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_INVALID_PARAMETER; }
            }
            else {

                pibsrc = pite->ITE_Binding;
                
                if (pibsrc == NULL ) {
                    TRACE1(
                        IF, "MibGetInternal: interface %d not bound", 
                        pimgid->IMGID_IfIndex
                        );

                    dwErr = ERROR_INVALID_PARAMETER;
                }
                else {

                    dwSize = (pibsrc ? IPBOOTP_IF_BINDING_SIZE(pibsrc)
                                     : sizeof(IPBOOTP_IF_BINDING));
                    *pdwOutputSize = sizeof(IPBOOTP_MIB_GET_OUTPUT_DATA) - 1 +
                                     dwSize;

                    //
                    // if no buffer was specified, indicate one should be allocated
                    //

                    if (pimgod == NULL) {
                        dwErr = ERROR_INSUFFICIENT_BUFFER;
                    }
                    else {

                        //
                        // if the buffer is not large enough,
                        // indicate that it should be enlarged
                        //

                        if (dwBufSize < dwSize) {
                            dwErr = ERROR_INSUFFICIENT_BUFFER;
                        }
                        else {

                            //
                            // copy the binding
                            //

                            pibdst = (PIPBOOTP_IF_BINDING)pimgod->IMGOD_Buffer;
                            if (pibsrc) { CopyMemory(pibdst, pibsrc, dwSize); }
                            else { pibdst->IB_AddrCount = 0; }

                            pibdst->IB_State = 0;

                            if (IF_IS_ENABLED(pite)) {
                                pibdst->IB_State |= IPBOOTP_STATE_ENABLED;
                            }

                            if (IF_IS_BOUND(pite)) {
                                pibdst->IB_State |= IPBOOTP_STATE_BOUND;
                            }
                        }

                        pimgod->IMGOD_IfIndex = pite->ITE_Index;
                    }

                }

            }

            RELEASE_READ_LOCK(&pTable->IT_RWL);

            break;
        }

        default: {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    return dwErr;
}


//----------------------------------------------------------------------------
// Function:    EnableDhcpInformServer
//
// Called to supply the address of a server to whom DHCP inform messages
// will be redirected. Note that this is an exported routine, invoked
// in the context of the caller's process, whatever that might be;
// the assumption is that it will be called from within the router process.
//
// If the relay-agent is configured, then this sets an address which will
// be picked up in 'ProcessRequest' for every incoming request.
// If the relay-agent is not configured, the routine has no effect.
// If the relay-agent is configured *after* this routine is called,
// then the DHCP inform server will be encountered as soon as the relay-agent
// starts, since it is saved directly into the relay-agents 'IPBOOTP_GLOBALS'.
//----------------------------------------------------------------------------

VOID APIENTRY
EnableDhcpInformServer(
    DWORD DhcpInformServer
    ) {
    InterlockedExchange(&ig.IG_DhcpInformServer, DhcpInformServer);
}

//----------------------------------------------------------------------------
// Function:    DisableDhcpInformServer
//
// Called to clear the previously-enabled DHCP inform server, if any.
//----------------------------------------------------------------------------

VOID APIENTRY
DisableDhcpInformServer(
    VOID
    ) {
    InterlockedExchange(&ig.IG_DhcpInformServer, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\arp.cxx ===
extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <ipexport.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <routprot.h>
#include <iprtrmib.h>


DWORD
UpdateArpCache(
    DWORD dwIfIndex,
    DWORD dwAddress,
    PBYTE pbMacAddr,
    DWORD dwMacAddrLength,
    BOOL bAddEntry,
    SUPPORT_FUNCTIONS *pFunctions
    ) {

    DWORD dwErr, dwSize;

    if (bAddEntry) {
        DEFINE_MIB_BUFFER(pInfo, MIB_IPNETROW, pinme);

        if ( dwMacAddrLength > sizeof(pinme->bPhysAddr) ) {
            return ERROR_INVALID_PARAMETER;
        }
        
        pInfo->dwId = IP_NETROW;
    
        pinme->dwIndex = dwIfIndex;
        pinme->dwAddr = dwAddress;
        pinme->dwPhysAddrLen = dwMacAddrLength;
        RtlCopyMemory(
            pinme->bPhysAddr,
            pbMacAddr,
            dwMacAddrLength
            );

        dwSize = MIB_INFO_SIZE(MIB_IPNETROW);

        pinme->dwType = INME_TYPE_DYNAMIC;

        dwErr = pFunctions->MIBEntryCreate(
                    IPRTRMGR_PID,
                    dwSize,
                    pInfo
                    );
    
    }
    else {
        PMIB_OPAQUE_QUERY lproqQuery;
        BYTE pBuffer[
            FIELD_OFFSET(MIB_OPAQUE_QUERY, rgdwVarIndex) + 2 * sizeof(DWORD)
            ];

        lproqQuery = (PMIB_OPAQUE_QUERY)pBuffer;
        lproqQuery->dwVarId = IP_NETROW;
        lproqQuery->rgdwVarIndex[0] = dwIfIndex;
        lproqQuery->rgdwVarIndex[1] = dwAddress;

        dwSize = sizeof(pBuffer);

        dwErr = pFunctions->MIBEntryDelete(
                    IPRTRMGR_PID,
                    dwSize,
                    (PVOID)lproqQuery
                    );
    }
    
    return dwErr;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\defs.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    defs.h
//
// History:
//      Abolade Gbadegesin  September 8, 1995     Created
//
// Contains miscellaneous declarations and definitions
//============================================================================


#ifndef _DEFS_H_
#define _DEFS_H_

//----------------------------------------------------------------------------
// TYPE DEFINITIONS FOR IPBOOTP NETWORK PACKET TEMPLATES
//


// constants defining maximum lengths for array fields
//
#define MAX_MACADDR_LENGTH      16
#define MAX_HOSTNAME_LENGTH     64
#define MAX_BOOTFILENAME_LENGTH 128


#include <pshpack1.h>

// the structure of the BOOTP packet, as defined by RFC 1542;
// the option field which appears at the end of each packet
// is excluded since the relay agent does no options-processing
//
typedef struct _IPBOOTP_PACKET {
    BYTE    IP_Operation;
    BYTE    IP_MacAddrType;
    BYTE    IP_MacAddrLength;
    BYTE    IP_HopCount;
    DWORD   IP_TransactionID;
    WORD    IP_SecondsSinceBoot;
    WORD    IP_Flags;
    DWORD   IP_ClientAddress;
    DWORD   IP_OfferedAddress;
    DWORD   IP_ServerAddress;
    DWORD   IP_AgentAddress;
    BYTE    IP_MacAddr[16];
    BYTE    IP_HostName[64];
    BYTE    IP_BootFileName[128];
} IPBOOTP_PACKET, *PIPBOOTP_PACKET;

typedef struct _DHCP_PACKET {
    UCHAR   Cookie[4];
    UCHAR   Tag;
    UCHAR   Length;
    UCHAR   Option[];
} DHCP_PACKET, *PDHCP_PACKET;

#include <poppack.h>

// constants for the IBP_Operation field
//
#define IPBOOTP_OPERATION_REQUEST   1
#define IPBOOTP_OPERATION_REPLY     2

//
#define IPBOOTP_MAX_HOP_COUNT       16

// constants for the IBP_Flags field
//
#define IPBOOTP_FLAG_BROADCAST      0x8000

// constants for the DHCP portion of the packet
//
#define DHCP_MAGIC_COOKIE       ((99 << 24) | (83 << 16) | (130 << 8) | (99))
#define DHCP_TAG_MESSAGE_TYPE   53
#define DHCP_MESSAGE_INFORM     8

// structure size constants
//
#define MIN_PACKET_SIZE         (sizeof(IPBOOTP_PACKET) + 64)
#define MAX_PACKET_SIZE         4096

// INET constants
//
#define IPBOOTP_SERVER_PORT     67
#define IPBOOTP_CLIENT_PORT     68


// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument
//
#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = (((a) & 0xff000000) - ((b) & 0xff000000))) ? (c) : (c)))))


#endif // _DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\log.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    log.h
//
// History:
//  Abolade Gbadegesin  Jan-12-1996     Created.
//
// This file is processed by mapmsg to produce a .mc file,
// then the .mc file is compiled by the message compiler,
// and the resulting binary is included in IPBOOTP's resource file.
//
// Don't change the comments following the manifest constants
// without understanding how mapmsg works.
//============================================================================


#define IPBOOTPLOG_BASE                             30000

#define IPBOOTPLOG_INIT_CRITSEC_FAILED              (IPBOOTPLOG_BASE + 1)
/*
 * IPBOOTP was unable to initialize a critical section.
 * The data is the exception code.
 */

#define IPBOOTPLOG_HEAP_CREATE_FAILED               (IPBOOTPLOG_BASE + 2)
/*
 * IPBOOTP was unable to create a heap for memory allocation.
 * The data is the error code.
 */

#define IPBOOTPLOG_HEAP_ALLOC_FAILED                (IPBOOTPLOG_BASE + 3)
/*
 * IPBOOTP was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define IPBOOTPLOG_ALREADY_STARTED                  (IPBOOTPLOG_BASE + 4)
/*
 * IPBOOTP was called to start when it was already running.
 */

#define IPBOOTPLOG_INIT_WINSOCK_FAILED              (IPBOOTPLOG_BASE + 5)
/*
 * IPBOOTP was unable to initialize Windows Sockets.
 * The data is the error code.
 */

#define IPBOOTPLOG_CREATE_RWL_FAILED                (IPBOOTPLOG_BASE + 6)
/*
 * IPBOOTP was unable to create a synchronization object.
 * The data is the exception code.
 */

#define IPBOOTPLOG_CREATE_IF_TABLE_FAILED           (IPBOOTPLOG_BASE + 7)
/*
 * IPBOOTP was unable to create a table to hold interface information.
 * The data is the error code.
 */

#define IPBOOTPLOG_CREATE_SEMAPHORE_FAILED          (IPBOOTPLOG_BASE + 8)
/*
 * IPBOOTP was unable to create a semaphore.
 * The data is the error code.
 */

#define IPBOOTPLOG_CREATE_EVENT_FAILED              (IPBOOTPLOG_BASE + 9)
/*
 * IPBOOTP was unable to create an event.
 * The data is the error code.
 */

#define IPBOOTPLOG_CREATE_TIMER_QUEUE_FAILED        (IPBOOTPLOG_BASE + 10)
/*
 * IPBOOTP was unable to create a timer queue using CreateTimerQueue.
 * The data is the error code.
 */

#define IPBOOTPLOG_STARTED                          (IPBOOTPLOG_BASE + 11)
/*
 * IPBOOTP started successfully.
 */

#define IPBOOTPLOG_STOPPED                          (IPBOOTPLOG_BASE + 12)
/*
 * IPBOOTP has stopped.
 */

#define IPBOOTPLOG_BIND_IF_FAILED                   (IPBOOTPLOG_BASE + 13)
/*
 * IPBOOTP was unable to bind to IP address %1.
 * Please make sure TCP/IP is installed and configured correctly.
 * The data is the error code.
 */

#define IPBOOTPLOG_ACTIVATE_IF_FAILED               (IPBOOTPLOG_BASE + 14)
/*
 * IPBOOTP was unable to activate the interface with IP address %1.
 * The data is the error code.
 */

#define IPBOOTPLOG_EVENTSELECT_FAILED               (IPBOOTPLOG_BASE + 15)
/*
 * IPBOOTP was unable to request notification of events
 * on the socket for the local interface with IP address %1.
 * The data is the error code.
 */

#define IPBOOTPLOG_HOP_COUNT_TOO_HIGH               (IPBOOTPLOG_BASE + 16)
/*
 * IPBOOTP has discarded a packet received on the local interface
 * with IP address %1. The packet had a hop-count of %2, which is
 * greater than the maximum value allowed in packets received for
 * this interface.
 * The hop-count field in a DHCP REQUEST packet indicates how many times
 * the packet has been forwarded from one relay-agent to another.
 */

#define IPBOOTPLOG_SECS_SINCE_BOOT_TOO_LOW          (IPBOOTPLOG_BASE + 17)
/*
 * IPBOOTP has discarded a packet received on the local interface
 * with IP address %1. The packet had a seconds-since-boot of %2,
 * which is less than the minimum value needed for packets to be
 * forwarded on this interface.
 * The seconds-since-boot field in a DHCP REQUEST packet indicates
 * how long the DHCP client machine which sent the packet has been
 * trying to obtain an IP address.
 */

#define IPBOOTPLOG_RELAY_REQUEST_FAILED             (IPBOOTPLOG_BASE + 18)
/*
 * IPBOOTP was unable to relay a DHCP REQUEST packet on the local interface
 * with IP address %1; the REQUEST was to have been relayed to
 * the DHCP server with IP address %2.
 * The data is the error code.
 */

#define IPBOOTPLOG_RELAY_REPLY_FAILED               (IPBOOTPLOG_BASE + 19)
/*
 * IPBOOTP was unable to relay a DHCP REPLY packet on the local interface
 * with IP address %1; the REPLY was to have been relayed to
 * the DHCP client with hardware address %2.
 * The data is the error code.
 */

#define IPBOOTPLOG_ENUM_NETWORK_EVENTS_FAILED       (IPBOOTPLOG_BASE + 20)
/*
 * IPBOOTP was unable to enumerate network events on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IPBOOTPLOG_INPUT_RECORD_ERROR               (IPBOOTPLOG_BASE + 21)
/*
 * IPBOOTP detected an error on the local interface with IP address %1.
 * The error occurred while the interface was receiving packets.
 * The data is the error code.
 */

#define IPBOOTPLOG_RECVFROM_FAILED                  (IPBOOTPLOG_BASE + 22)
/*
 * IPBOOTP was unable to receive an incoming message on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IPBOOTPLOG_PACKET_TOO_SMALL                 (IPBOOTPLOG_BASE + 23)
/*
 * IPBOOTP received a packet which was smaller than the minimum size
 * allowed for DHCP packets. The packet has been discarded.
 * It was received on the local interface with IP address %1, 
 * and it came from a machine with IP address %2.
 */

#define IPBOOTPLOG_PACKET_OPCODE_INVALID            (IPBOOTPLOG_BASE + 24)
/*
 * IPBOOTP received a packet containing an invalid op-code.
 * The packet has been discarded. It was received on the local interface
 * with IP address %1, and it came from a machine with IP address %2.
 */

#define IPBOOTPLOG_QUEUE_PACKET_FAILED              (IPBOOTPLOG_BASE + 25)
/*
 * IPBOOTP could not schedule the processing of a packet received
 * on the local interface with IP address %1. The packet was received
 * from a machine with IP address %2.
 * This error may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define IPBOOTPLOG_QUEUE_WORKER_FAILED              (IPBOOTPLOG_BASE + 26)
/*
 * IPBOOTP could not schedule a task to be executed.
 * This error may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define IPBOOTPLOG_CREATE_SOCKET_FAILED             (IPBOOTPLOG_BASE + 27)
/*
 * IPBOOTP could not create a socket for the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IPBOOTPLOG_ENABLE_BROADCAST_FAILED          (IPBOOTPLOG_BASE + 28)
/*
 * IPBOOTP could not enable broadcasting on the socket for
 * the local interface with IP address %1.
 * The data is the error code.
 */

#define IPBOOTPLOG_REGISTER_WAIT_FAILED             (IPBOOTPLOG_BASE + 29)
/*
 * IPBOOTP was unable to register an event with the ntdll wait threads.
 * The data is the error code.
 */

#define IPBOOTPLOG_INVALID_IF_CONFIG                (IPBOOTPLOG_BASE + 30)
/*
 * IPBOOTP could not be configured on the interface.
 * The invalid parameter is: %1, value: %2
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\makefile.inc ===
$(O)\bootpmsg.mc: log.h
    mapmsg NET IPBOOTPLOG_BASE log.h > $(O)\bootpmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\pchbootp.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: pchbootp.h
//
// History:
//      Abolade Gbadegesin  September-8-1995  Created.
//
// Precompiled header for IPBOOTP
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#define FD_SETSIZE      256
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
// #include <rtm.h>
#include <routprot.h>
#include <rtutils.h>
#include <ipbootp.h>
#include "log.h"
#include "defs.h"
#include "sync.h"
#include "table.h"
#include "queue.h"
#include "api.h"
#include "work.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\queue.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: queue.c
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// timer queue, change queue, and event message queue implementation
//============================================================================

#include "pchbootp.h"



//----------------------------------------------------------------------------
// Function:    EnqueueEvent
//
// This function adds an entry to the end of the queue of
// Router Manager events. It assumes the queue is locked.
//----------------------------------------------------------------------------

DWORD
EnqueueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS Event,
    MESSAGE Result
    ) {

    DWORD dwErr;
    PLIST_ENTRY phead;
    PEVENT_QUEUE_ENTRY peqe;

    phead = &pQueue->LL_Head;

    peqe = BOOTP_ALLOC(sizeof(EVENT_QUEUE_ENTRY));
    if (peqe == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        TRACE2(
            ANY, "error %d allocating %d bytes for event queue",
            dwErr, sizeof(EVENT_QUEUE_ENTRY)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }

    peqe->EQE_Event = Event;
    peqe->EQE_Result = Result;

    InsertTailList(phead, &peqe->EQE_Link);

    return NO_ERROR;
}


//----------------------------------------------------------------------------
// Function:    DequeueEvent
//
// This function removes an entry from the head of the queue
// of Router Manager events. It assumes the queue is locked
//----------------------------------------------------------------------------

DWORD
DequeueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS *pEvent,
    PMESSAGE pResult
    ) {

    PLIST_ENTRY phead, ple;
    PEVENT_QUEUE_ENTRY peqe;

    phead = &pQueue->LL_Head;
    if (IsListEmpty(phead)) {
        return ERROR_NO_MORE_ITEMS;
    }

    ple = RemoveHeadList(phead);
    peqe = CONTAINING_RECORD(ple, EVENT_QUEUE_ENTRY, EQE_Link);

    *pEvent = peqe->EQE_Event;
    *pResult = peqe->EQE_Result;

    BOOTP_FREE(peqe);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    EnqueueRecvEntry
//
// assumes that recv queue is locked and that global config is locked
// for reading or writing
//----------------------------------------------------------------------------

DWORD
EnqueueRecvEntry(
    PLOCKED_LIST pQueue,
    DWORD dwCommand,
    PBYTE pRoutes
    ) {

    DWORD dwErr;
    PLIST_ENTRY phead;
    PRECV_QUEUE_ENTRY prqe;


    //
    // check that the max queue size is not exceeded
    //

    if ((DWORD)ig.IG_RecvQueueSize >= ig.IG_Config->GC_MaxRecvQueueSize) {

        TRACE2(
            RECEIVE,
            "dropping route: recv queue size is %d bytes and max is %d bytes",
            ig.IG_RecvQueueSize, ig.IG_Config->GC_MaxRecvQueueSize
            );

        return ERROR_INSUFFICIENT_BUFFER;
    }


    phead = &pQueue->LL_Head;

    prqe = BOOTP_ALLOC(sizeof(RECV_QUEUE_ENTRY));
    if (prqe == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        TRACE2(
            ANY, "error %d allocating %d bytes for recv-queue entry",
            dwErr, sizeof(RECV_QUEUE_ENTRY)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }

    prqe->RQE_Routes = pRoutes;
    prqe->RQE_Command = dwCommand;

    InsertTailList(phead, &prqe->RQE_Link);

    ig.IG_RecvQueueSize += sizeof(RECV_QUEUE_ENTRY);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    DequeueRecvEntry
//
// assumes that recv queue is locked 
//----------------------------------------------------------------------------

DWORD
DequeueRecvEntry(
    PLOCKED_LIST pQueue,
    PDWORD pdwCommand,
    PBYTE *ppRoutes
    ) {

    PLIST_ENTRY ple, phead;
    PRECV_QUEUE_ENTRY prqe;


    phead = &pQueue->LL_Head;

    if (IsListEmpty(phead)) { return ERROR_NO_MORE_ITEMS; }

    ple = RemoveHeadList(phead);

    prqe = CONTAINING_RECORD(ple, RECV_QUEUE_ENTRY, RQE_Link);

    *ppRoutes = prqe->RQE_Routes;
    *pdwCommand = prqe->RQE_Command;

    BOOTP_FREE(prqe);

    ig.IG_RecvQueueSize -= sizeof(RECV_QUEUE_ENTRY);
    if (ig.IG_RecvQueueSize < 0) { ig.IG_RecvQueueSize = 0; }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\queue.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: queue.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains structures and macros used for various queues.
//============================================================================

#ifndef _QUEUE_H_
#define _QUEUE_H_


//----------------------------------------------------------------------------
// type definitions for event message queue
//

typedef struct _EVENT_QUEUE_ENTRY {
    LIST_ENTRY              EQE_Link;
    ROUTING_PROTOCOL_EVENTS EQE_Event;
    MESSAGE                 EQE_Result;
} EVENT_QUEUE_ENTRY, *PEVENT_QUEUE_ENTRY;

DWORD EnqueueEvent(PLOCKED_LIST pQueue,
                   ROUTING_PROTOCOL_EVENTS Event,
                   MESSAGE Result);
DWORD DequeueEvent(PLOCKED_LIST pQueue,
                   ROUTING_PROTOCOL_EVENTS *pEvent,
                   PMESSAGE pResult);


//
// type definitions for the receive queue
//

typedef struct _RECV_QUEUE_ENTRY {
    LIST_ENTRY  RQE_Link;
    PBYTE       RQE_Routes;
    DWORD       RQE_Command;
} RECV_QUEUE_ENTRY, *PRECV_QUEUE_ENTRY;


DWORD
EnqueueRecvEntry(
    PLOCKED_LIST pQueue,
    DWORD dwCommand,
    PBYTE pRoutes
    );

DWORD
DequeueRecvEntry(
    PLOCKED_LIST pQueue,
    PDWORD dwCommand,
    PBYTE *ppRoutes
    );




#endif // _QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\work.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    work.c
//
// History:
//      Abolade Gbadegesin  August 31, 1995     Created
//
// Worker function implementation
//============================================================================


#include "pchbootp.h"

#define STRSAFE_NO_DEPRECATE 
#include <strsafe.h>



//----------------------------------------------------------------------------
// Function:    CallbackFunctionNetworkEvents
//
// This function runs in the context of the ntdll wait thread. Using 
// QueueBootpWorker ensures that the bootp dll is running
//----------------------------------------------------------------------------
VOID
CallbackFunctionNetworkEvents(
    PVOID   pvContext,
    BOOLEAN NotUsed
    ) {

    HANDLE WaitHandle;

    if (!ENTER_BOOTP_API()) { return; }

    
    //
    // set the handle to NULL, so that Unregister wont be called
    //

    WaitHandle = InterlockedExchangePointer(&ig.IG_InputEventHandle, NULL);
        
    if (WaitHandle) {
        UnregisterWaitEx( WaitHandle, NULL ) ;
    }


    QueueBootpWorker(WorkerFunctionNetworkEvents, pvContext);


    LEAVE_BOOTP_API();
    
    return;
}



//----------------------------------------------------------------------------
// Function:    WorkerFunctionNetworkEvents
//
// This function enumerates the input events on each interface and processes
// any incoming input packets. Queued by CallbackFunctionNetworkEvents
//----------------------------------------------------------------------------

VOID
WorkerFunctionNetworkEvents(
    PVOID pvContextNotused
    ) {

    DWORD i, dwErr;
    PIF_TABLE pTable;
    PIPBOOTP_IF_CONFIG pic;
    PIPBOOTP_IF_BINDING pib;
    PIPBOOTP_IP_ADDRESS paddr;
    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, phead;
    WSANETWORKEVENTS wsane;


    if (!ENTER_BOOTP_WORKER()) { return; }

    
    pTable = ig.IG_IfTable;

    ACQUIRE_READ_LOCK(&pTable->IT_RWL);

    //
    // go through the list of active interfaces
    // processing sockets which are read-ready
    //

    phead = &pTable->IT_ListByAddress;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

        pic = pite->ITE_Config;
        pib = pite->ITE_Binding;
        paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);

        for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
    
            if (pite->ITE_Sockets[i] == INVALID_SOCKET) { continue; }
    
            //
            // enumerate network events to see whether
            // any packets have arrived on this interface
            //
    
            dwErr = WSAEnumNetworkEvents(pite->ITE_Sockets[i], NULL, &wsane);
            if (dwErr != NO_ERROR) {
    
                LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
                TRACE3(
                    RECEIVE, "error %d checking for input on interface %d (%s)",
                    dwErr, pite->ITE_Index, lpszAddr
                    );
                LOGWARN1(ENUM_NETWORK_EVENTS_FAILED, lpszAddr, dwErr);
    
                continue;
            }
    
    
            //
            // see if the input bit is set
            //
    
            if (!(wsane.lNetworkEvents & FD_READ)) { continue; }
    
    
            //
            // the input flag is set, now see if there was an error
            //
    
            if (wsane.iErrorCode[FD_READ_BIT] != NO_ERROR) {
    
                LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
                TRACE3(
                    RECEIVE, "error %d in input record for interface %d (%s)",
                    wsane.iErrorCode[FD_READ_BIT], pite->ITE_Index, lpszAddr
                    );
                LOGWARN1(INPUT_RECORD_ERROR, lpszAddr, dwErr);
    
                continue;
            }
    
    
            //
            // there is no error, so process the socket
            //
    
            ProcessSocket(pite, i, pTable);
        }
    }

    RELEASE_READ_LOCK(&pTable->IT_RWL);



    //
    // register the InputEvent with the NtdllWait Thread again (only if the 
    // dll is not stopping). I use this model of registering the event with
    // ntdll every time, to prevent the worker function from being called for
    // every packet received (when packets are received at the same time).
    //

    if (ig.IG_Status != IPBOOTP_STATUS_STOPPING) {

        
        if (! RegisterWaitForSingleObject(
                      &ig.IG_InputEventHandle,
                      ig.IG_InputEvent,
                      CallbackFunctionNetworkEvents,
                      NULL,     //null context
                      INFINITE, //no timeout
                      (WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE)
                      )) {

            dwErr = GetLastError();
            TRACE1(
                START, "error %d returned by RegisterWaitForSingleObjectEx",
                dwErr
                );
            LOGERR0(REGISTER_WAIT_FAILED, dwErr);
        }
    }

    
    LEAVE_BOOTP_WORKER();
    return;
}



//----------------------------------------------------------------------------
// Function:    ProcessSocket
//
// This function processes a packet on an interface, queueing
// the packet for processing by a worker function after doing some
// basic validation.
//----------------------------------------------------------------------------

DWORD
ProcessSocket(
    PIF_TABLE_ENTRY pite,
    DWORD dwAddrIndex,
    PIF_TABLE pTable
    ) {

    BOOL bFreePacket;
    WORKERFUNCTION pwf;
    PINPUT_CONTEXT pwc;
    PIPBOOTP_IF_STATS pis;
    PIPBOOTP_IF_CONFIG pic;
    PIPBOOTP_IP_ADDRESS paddr;
    PIPBOOTP_PACKET pibp;
    PLIST_ENTRY ple;
    DWORD dwErr, dwInputSource;
    SOCKADDR_IN sinInputSource;
    PIPBOOTP_GLOBAL_CONFIG pigc;
    INT iInputLength, iAddrLength;
    PBYTE pInputPacket;

    pigc = ig.IG_Config;



    pis = &pite->ITE_Stats;
    paddr = IPBOOTP_IF_ADDRESS_TABLE(pite->ITE_Binding) + dwAddrIndex;


    //
    // the descriptor for this interface is set,
    // so allocate space for the packet
    //

    pwc = BOOTP_ALLOC(sizeof(INPUT_CONTEXT));
    if (pwc == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        TRACE2(
            RECEIVE, "error %d allocating %d bytes for incoming packet",
            dwErr, sizeof(INPUT_CONTEXT)
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }


    pInputPacket = pwc->IC_InputPacket;

    dwErr = NO_ERROR;
    bFreePacket = TRUE;

    do {

        CHAR szSource[20];


        //
        // receive the packet
        //

        iAddrLength = sizeof(SOCKADDR_IN);

        iInputLength = recvfrom(
                            pite->ITE_Sockets[dwAddrIndex], pInputPacket,
                            MAX_PACKET_SIZE, 0, (PSOCKADDR)&sinInputSource,
                            &iAddrLength
                            );

        if (iInputLength == 0 || iInputLength == SOCKET_ERROR) {

            LPSTR lpszAddr;

            dwErr = WSAGetLastError();
            lpszAddr = INET_NTOA(paddr->IA_Address);
            TRACE3(
                RECEIVE, "error %d receiving on interface %d (%s)",
                dwErr, pite->ITE_Index, lpszAddr
                );
            LOGERR1(RECVFROM_FAILED, lpszAddr, dwErr);

            InterlockedIncrement(&pis->IS_ReceiveFailures);
            break;
        }


        dwInputSource = sinInputSource.sin_addr.s_addr;


        //
        // filter out packets we sent ourselves
        //

        if (GetIfByAddress(pTable, dwInputSource, NULL)) {
            break;
        }

        {
            PCHAR pStr1, pStr2;
            pStr1 = INET_NTOA(dwInputSource);
            if (pStr1) 
                lstrcpy(szSource, pStr1);

            pStr2 = INET_NTOA(paddr->IA_Address);

            if (pStr1 && pStr2) {

                TRACE4(
                    RECEIVE, "received %d-byte packet from %s on interface %d (%s)",
                    iInputLength, szSource, pite->ITE_Index,
                    pStr2
                    );
            }
        }


        //
        // cast packet as a BOOTP message
        //

        pibp = (PIPBOOTP_PACKET)pInputPacket;



        //
        // consistency check 1: length of packet must exceed the length
        //  of the BOOTP header
        //

        if (iInputLength < sizeof(IPBOOTP_PACKET)) {

            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
            TRACE3(
                RECEIVE,
                "minimum BOOTP data is %d bytes, dropping %d byte packet from %s",
                sizeof(IPBOOTP_PACKET), iInputLength, szSource
                );
            LOGWARN2(PACKET_TOO_SMALL, lpszAddr, szSource, 0);

            break;
        }



        //
        // consistency check 2: op field must be either BOOTP_REQUEST
        //  or BOOTP_REPLY
        //
        if (pibp->IP_Operation != IPBOOTP_OPERATION_REQUEST &&
            pibp->IP_Operation != IPBOOTP_OPERATION_REPLY) {

            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
            TRACE2(
                RECEIVE,
                "dropping packet from %s due to unknown operation field %d",
                szSource, pibp->IP_Operation
                );
            LOGWARN2(PACKET_OPCODE_INVALID, lpszAddr, szSource, 0);

            break;
        }


        //
        // update statistics on incoming packets
        //

        switch (pibp->IP_Operation) {

            case IPBOOTP_OPERATION_REQUEST:
                InterlockedIncrement(&pis->IS_RequestsReceived);
                break;

            case IPBOOTP_OPERATION_REPLY:
                InterlockedIncrement(&pis->IS_RepliesReceived);
                break;
        }


        //
        // finish initializing the work context
        //

        pwc->IC_InterfaceIndex = pite->ITE_Index;
        pwc->IC_AddrIndex = dwAddrIndex;
        pwc->IC_InputSource = sinInputSource;
        pwc->IC_InputLength = iInputLength;


        //
        // place the packet on the receive queue
        //

        ACQUIRE_READ_LOCK(&ig.IG_RWL);
        ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);

        dwErr = EnqueueRecvEntry(
                    ig.IG_RecvQueue, (DWORD)pibp->IP_Operation, (PBYTE)pwc
                    );

        RELEASE_LIST_LOCK(ig.IG_RecvQueue);
        RELEASE_READ_LOCK(&ig.IG_RWL);

        if (dwErr != NO_ERROR) {

            LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
            TRACE4(
                RECEIVE, "error %d queueing packet from %s on interface %d (%s)",
                dwErr, szSource, pite->ITE_Index, lpszAddr
                );
            LOGERR2(QUEUE_PACKET_FAILED, lpszAddr, szSource, dwErr);

            break;
        }


        //
        // queue the function to handle the packet
        //

        dwErr = QueueBootpWorker(WorkerFunctionProcessInput, NULL);

        if (dwErr != NO_ERROR) {

            PLIST_ENTRY phead;

            TRACE2(
                RECEIVE, "error %d queueing packet from %s for processing",
                dwErr, szSource
                );
            LOGERR0(QUEUE_WORKER_FAILED, dwErr);

            ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);

            phead = &ig.IG_RecvQueue->LL_Head;
            RemoveTailList(phead);
            ig.IG_RecvQueueSize -= sizeof(RECV_QUEUE_ENTRY);
            
            RELEASE_LIST_LOCK(ig.IG_RecvQueue);

            break;
        }

        //
        // all went well, so we let the input processor free the packet
        //

        bFreePacket = FALSE;

    } while(FALSE);


    if (bFreePacket) { BOOTP_FREE(pwc); }


    return dwErr;
}

//----------------------------------------------------------------------------
// Function:    WorkerFunctionProcessInput
//
// This function processes an incoming packet.
//----------------------------------------------------------------------------

VOID
WorkerFunctionProcessInput(
    PVOID pContext
    ) {

    PINPUT_CONTEXT pwc;
    DWORD dwErr, dwCommand;

    if (!ENTER_BOOTP_WORKER()) { return; }

    TRACE0(ENTER, "entering WorkerFunctionProcessInput");


    do {


        ACQUIRE_LIST_LOCK(ig.IG_RecvQueue);
        dwErr = DequeueRecvEntry(ig.IG_RecvQueue, &dwCommand, (PBYTE *)&pwc);
        RELEASE_LIST_LOCK(ig.IG_RecvQueue);
    
        if (dwErr != NO_ERROR) {
            TRACE1(
                RECEIVE, "error %d dequeueing packet from receive queue", dwErr
                );
            break;
        }
    

        switch (dwCommand) {

            case IPBOOTP_OPERATION_REQUEST:
                ProcessRequest(pwc);
                break;

            case IPBOOTP_OPERATION_REPLY:
                ProcessReply(pwc);
                break;
        }


    } while(FALSE);


    TRACE0(LEAVE, "leaving WorkerFunctionProcessInput");

    LEAVE_BOOTP_WORKER();

}



//----------------------------------------------------------------------------
// Function:    ProcessRequest
//
// This function handles the processing of BOOT_REQUEST messages
//----------------------------------------------------------------------------

VOID
ProcessRequest(
    PVOID pContext
    ) {

    INT iErr;
    PIF_TABLE pTable;
    PINPUT_CONTEXT pwc;
    SOCKADDR_IN sinsrv;
    PIPBOOTP_PACKET pibp;
    PIF_TABLE_ENTRY pite;
    PIPBOOTP_IF_STATS pis;
    PIPBOOTP_IF_CONFIG pic;
    PIPBOOTP_IP_ADDRESS paddr;
    PIPBOOTP_GLOBAL_CONFIG pigc;
    DWORD dwErr, dwIndex, dwDhcpInformServer;
    PDWORD pdwAddr, pdwEnd;
    PDHCP_PACKET pdp;

    TRACE0(ENTER, "entering ProcessRequest");


    pwc = (PINPUT_CONTEXT)pContext;

    pTable = ig.IG_IfTable;

    ACQUIRE_READ_LOCK(&pTable->IT_RWL);

    do { // error breakout loop


        //
        // find the interface on which the input arrived
        //

        dwIndex = pwc->IC_InterfaceIndex;
        pite = GetIfByIndex(pTable, dwIndex);
        if (pite == NULL) {

            TRACE1(
                REQUEST, "processing request: interface %d not found", dwIndex
                );

            break;
        }


        pis = &pite->ITE_Stats;
        pic = pite->ITE_Config;

        //
        // Check if interface still bound to an IP address
        //

        if (pite->ITE_Binding == NULL) {

            TRACE1(
                REQUEST, "processing request: interface %d not bound", 
                dwIndex
                );

            break;
        }
        
        paddr = IPBOOTP_IF_ADDRESS_TABLE(pite->ITE_Binding) + pwc->IC_AddrIndex;
        
        //
        // if we are not configured to relay, do nothing
        //

        if (pic->IC_RelayMode == IPBOOTP_RELAY_DISABLED) { break; }

        pibp = (PIPBOOTP_PACKET)pwc->IC_InputPacket;


        //
        // check the hop-count field to see if it is over the max hop-count
        // configured for this interface
        //

        if (pibp->IP_HopCount > IPBOOTP_MAX_HOP_COUNT ||
            pibp->IP_HopCount > pic->IC_MaxHopCount) {

            //
            // discard and log
            //

            CHAR szHops[12], *lpszAddr = INET_NTOA(paddr->IA_Address);

            _ltoa(pibp->IP_HopCount, szHops, 10);
            TRACE4(
                REQUEST,
                "dropping REQUEST with hop-count %d: max hop-count is %d on interface %d (%s)",
                pibp->IP_HopCount, pic->IC_MaxHopCount, dwIndex, lpszAddr
                );
            LOGWARN2(HOP_COUNT_TOO_HIGH, lpszAddr, szHops, 0);

            InterlockedIncrement(&pis->IS_RequestsDiscarded);
            break;
        }



        //
        // check the seconds threshold to make sure it is up to the minimum
        //

        if (pibp->IP_SecondsSinceBoot < pic->IC_MinSecondsSinceBoot) {

            //
            // discard and log
            //

            CHAR szSecs[12], *lpszAddr = INET_NTOA(paddr->IA_Address);

            _ltoa(pibp->IP_SecondsSinceBoot, szSecs, 10);
            TRACE3(
                REQUEST,
                "dropping REQUEST with secs-since-boot %d on interface %d (%s)",
                pibp->IP_SecondsSinceBoot, dwIndex, lpszAddr
                );
            LOGINFO2(SECS_SINCE_BOOT_TOO_LOW, lpszAddr, szSecs, 0);

            InterlockedIncrement(&pis->IS_RequestsDiscarded);
            break;
        }
                

        //
        // increment the hop-count
        //

        ++pibp->IP_HopCount;



        //
        // fill in relay agent IP address if it is empty
        //

        if (pibp->IP_AgentAddress == 0) {
            pibp->IP_AgentAddress = paddr->IA_Address;
        }


        //
        // if a dhcp-inform server has been set,
        // and this packet is a dhcp inform packet,
        // we will forward it to the dhcp-inform server.
        //

        pdp = (PDHCP_PACKET)(pibp + 1);
        if (!(dwDhcpInformServer = ig.IG_DhcpInformServer) ||
            pwc->IC_InputLength <
            sizeof(IPBOOTP_PACKET) + sizeof(DHCP_PACKET) + 1 ||
            *(DWORD UNALIGNED *)pdp->Cookie != DHCP_MAGIC_COOKIE ||
            pdp->Tag != DHCP_TAG_MESSAGE_TYPE ||
            pdp->Length != 1 ||
            pdp->Option[0] != DHCP_MESSAGE_INFORM
            ) {
            dwDhcpInformServer = 0;
        }

        //
        // relay the request to all configured BOOTP servers
        //

        ACQUIRE_READ_LOCK(&ig.IG_RWL);
    
        pigc = ig.IG_Config;
        if (dwDhcpInformServer) {
            pdwAddr = &dwDhcpInformServer;
            pdwEnd = pdwAddr + 1;
        }
        else {
            pdwAddr = (PDWORD)((PBYTE)pigc + sizeof(IPBOOTP_GLOBAL_CONFIG));
            pdwEnd = pdwAddr + pigc->GC_ServerCount;
        }

        for ( ; pdwAddr < pdwEnd; pdwAddr++) {

            sinsrv.sin_family = AF_INET;
            sinsrv.sin_port = htons(IPBOOTP_SERVER_PORT);
            sinsrv.sin_addr.s_addr = *pdwAddr;

            iErr = sendto(
                        pite->ITE_Sockets[pwc->IC_AddrIndex],
                        pwc->IC_InputPacket, pwc->IC_InputLength, 0,
                        (PSOCKADDR)&sinsrv, sizeof(SOCKADDR_IN)
                        );

            if (iErr == SOCKET_ERROR || iErr < (INT)pwc->IC_InputLength) {

                CHAR szSrv[20], *lpszAddr;

                dwErr = WSAGetLastError();
                if ((lpszAddr = INET_NTOA(*pdwAddr)) != NULL) {
                    lstrcpy(szSrv, lpszAddr);
                    lpszAddr = INET_NTOA(paddr->IA_Address);
                    if (lpszAddr != NULL) {
                        TRACE4(
                            REQUEST,
                            "error %d relaying REQUEST to server %s on interface %d (%s)",
                            dwErr, szSrv, dwIndex, lpszAddr
                            );
                        LOGERR2(RELAY_REQUEST_FAILED, lpszAddr, szSrv, dwErr);
                    }
                }
                InterlockedIncrement(&pis->IS_SendFailures);
            }
        }

        RELEASE_READ_LOCK(&ig.IG_RWL);

    } while(FALSE);


    RELEASE_READ_LOCK(&pTable->IT_RWL);

    BOOTP_FREE(pwc);


    TRACE0(LEAVE, "leaving ProcessRequest");

    return;
}



//----------------------------------------------------------------------------
// Function:    ProcessReply
//
// This function handles the relaying of BOOT_REPLY packets
//----------------------------------------------------------------------------

VOID
ProcessReply(
    PVOID pContext
    ) {

    INT iErr;
    PIF_TABLE pTable;
    BOOL bArpUpdated;
    SOCKADDR_IN sincli;
    PINPUT_CONTEXT pwc;
    PIPBOOTP_PACKET pibp;
    PIPBOOTP_IP_ADDRESS paddrin, paddrout;
    PIPBOOTP_IF_STATS pisin, pisout;
    PIF_TABLE_ENTRY pitein, piteout;
    DWORD dwErr, dwIndex, dwAddress, dwAddrIndexOut;
    

    TRACE0(ENTER, "entering ProcessReply");


    pwc = (PINPUT_CONTEXT)pContext;

    pTable = ig.IG_IfTable;

    ACQUIRE_READ_LOCK(&pTable->IT_RWL);


    do { // error breakout loop
    

        //
        // get the interface on which the packet was received
        //

        dwIndex = pwc->IC_InterfaceIndex;

        pitein = GetIfByIndex(pTable, dwIndex);

        if (pitein == NULL) {

            TRACE1(REPLY, "processing REPLY: interface %d not found", dwIndex);

            break;
        }

        if (pitein->ITE_Binding == NULL) {
        
            TRACE1(REPLY, "processing REPLY: interface %d not bound", dwIndex);
            
            break;
        }
        
        paddrin = IPBOOTP_IF_ADDRESS_TABLE(pitein->ITE_Binding) +
                    pwc->IC_AddrIndex;


        //
        // if we are not configured t relay on this interface, do nothing
        //

        if (pitein->ITE_Config->IC_RelayMode == IPBOOTP_RELAY_DISABLED) {

            TRACE2(
                REPLY,
                "dropping REPLY: relaying on interface %d (%s) is disabled",
                pitein->ITE_Index, INET_NTOA(paddrin->IA_Address)
                );

            break;
        }



        pisin = &pitein->ITE_Stats;


        //
        // place a template over the packet, and retrieve
        // the AgentAddress field; this contains the address
        // of the relay agent responsible for relaying this REPLY 
        //

        pibp = (PIPBOOTP_PACKET)pwc->IC_InputPacket;
        dwAddress = pibp->IP_AgentAddress;
        
        //
        // see if the address in the reply matches any local interface
        //

        piteout = GetIfByAddress(pTable, dwAddress, &dwAddrIndexOut);

        if (piteout == NULL) {

            CHAR szAddress[20];
            PCHAR pStr1, pStr2;
            
            pStr1 = INET_NTOA(dwAddress);
            if (pStr1)
                lstrcpy(szAddress, pStr1);

            pStr2 = INET_NTOA(paddrin->IA_Address);

            if (pStr1 && pStr2) {
                TRACE3(
                    REPLY,
                    "dropping REPLY packet on interface %d (%s); no interfaces have address %s",
                    pitein->ITE_Index, pStr2, szAddress
                    );
            }
            
            InterlockedIncrement(&pisin->IS_RepliesDiscarded);
            break;
        }

        if (piteout->ITE_Binding == NULL) {
        
            TRACE1(REPLY, "processing REPLY: outgoing interface %d is not bound", dwIndex);
            
            break;
        }
            
            
        paddrout = IPBOOTP_IF_ADDRESS_TABLE(piteout->ITE_Binding) +
                    dwAddrIndexOut;


        //
        // only relay if relay is enabled on the outgoing interface
        //

        if (piteout->ITE_Config->IC_RelayMode == IPBOOTP_RELAY_DISABLED) {

            TRACE2(
                REPLY,
                "dropping REPLY: relaying on interface %d (%s) is disabled",
                piteout->ITE_Index, INET_NTOA(paddrout->IA_Address)
                );

            break;
        }


        pisout = &piteout->ITE_Stats;


        //
        // the message must be relayed on the interface whose address
        // was specifed in the packet;
        //

        //
        // if the broadcast bit is not set and the clients IP address
        // is in the packet, add an entry to the ARP cache for the client
        // and then relay the packet by unicast 
        //

        sincli.sin_family = AF_INET;
        sincli.sin_port = htons(IPBOOTP_CLIENT_PORT);

        if ((pibp->IP_Flags & htons(IPBOOTP_FLAG_BROADCAST)) != 0 ||
            pibp->IP_OfferedAddress == 0) {

            //
            // the broadcast bit is set of the offered address is 0,
            // which is not an address we can add to the ARP cache;
            // in this case, send by broadcast
            //

            bArpUpdated = FALSE;
            sincli.sin_addr.s_addr = INADDR_BROADCAST;
        }
        else {
            

            //
            // attempt to seed the ARP cache with the address
            // offered to the client in the packet we are about
            // to send to the client.
            //

            dwErr = UpdateArpCache(
                        piteout->ITE_Index, pibp->IP_OfferedAddress,
                        (PBYTE)pibp->IP_MacAddr, pibp->IP_MacAddrLength,
                        TRUE, ig.IG_FunctionTable
                        );

            if (dwErr == NO_ERROR) {

                bArpUpdated = TRUE;
                sincli.sin_addr.s_addr = pibp->IP_OfferedAddress;
            }
            else {

                //
                // okay, that didn't work,
                // so fall back on broadcasting the packet
                //

                TRACE3(
                    REPLY,
                    "error %d adding entry to ARP cache on interface %d (%s)",
                    dwErr, piteout->ITE_Index, INET_NTOA(paddrout->IA_Address)
                    );

                bArpUpdated = FALSE;
                sincli.sin_addr.s_addr = INADDR_BROADCAST;

                InterlockedIncrement(&pisout->IS_ArpUpdateFailures);
            }
        }



        //
        // relay the packet
        //

        iErr = sendto(
                    piteout->ITE_Sockets[dwAddrIndexOut], pwc->IC_InputPacket,
                    pwc->IC_InputLength, 0,
                    (PSOCKADDR)&sincli, sizeof(SOCKADDR_IN)
                    );

        if (iErr == SOCKET_ERROR || iErr < (INT)pwc->IC_InputLength) {

            INT i;
            BYTE *pb;
            CHAR szCli[64], *psz, *lpszAddr, szDigits[] = "0123456789ABCDEF";

            dwErr = WSAGetLastError();
            lpszAddr = INET_NTOA(paddrout->IA_Address);

            //
            // format the client's hardware address
            //
            for (i = 0, psz = szCli, pb = pibp->IP_MacAddr;
                 i < 16 && i < pibp->IP_MacAddrLength;
                 i++, pb++) {
                *psz++ = szDigits[*pb / 16];
                *psz++ = szDigits[*pb % 16];
                *psz++ = ':';
            }

            (psz == szCli) ? (*psz = '\0') : (*(psz - 1) = '\0');


            TRACE4(
                REPLY,
                "error %d relaying REPLY to client %s on interface %d (%s)",
                dwErr, szCli, dwIndex, lpszAddr
                );
            LOGERR2(RELAY_REPLY_FAILED, lpszAddr, szCli, dwErr);

            InterlockedIncrement(&pisout->IS_SendFailures);
        }


        //
        // remove the ARP entry if one was added
        //

        if (bArpUpdated) {

            dwErr = UpdateArpCache(
                        piteout->ITE_Index, pibp->IP_OfferedAddress,
                        (PBYTE)pibp->IP_MacAddr, pibp->IP_MacAddrLength,
                        FALSE, ig.IG_FunctionTable
                        );

            if (dwErr != NO_ERROR) {
                InterlockedIncrement(&pisout->IS_ArpUpdateFailures);
            }
        }

    } while(FALSE);

    RELEASE_READ_LOCK(&pTable->IT_RWL);

    BOOTP_FREE(pwc);



    TRACE0(LEAVE, "leaving ProcessReply");

    return;
}


#define ClearScreen(h) {                                                    \
    DWORD _dwin,_dwout;                                                     \
    COORD _c = {0, 0};                                                      \
    CONSOLE_SCREEN_BUFFER_INFO _csbi;                                       \
    GetConsoleScreenBufferInfo(h,&_csbi);                                   \
    _dwin = _csbi.dwSize.X * _csbi.dwSize.Y;                                \
    FillConsoleOutputCharacter(h,' ',_dwin,_c,&_dwout);                     \
}

VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod
    );

VOID
PrintIfConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod
    );

VOID
PrintIfBinding(
    HANDLE hConsole,
    PCOORD pc,
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod
    );

VOID
PrintIfStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod
    );



#if DBG

VOID
CallbackFunctionMibDisplay(
    PVOID   pContext,
    BOOLEAN NotUsed
    ) {

    // enter/leaveBootpWorker not required as timer queue is persistent

    QueueBootpWorker(WorkerFunctionMibDisplay, pContext);

    return;
}


VOID
WorkerFunctionMibDisplay(
    PVOID pContext
    ) {
    COORD c;
    INT iErr;
    FD_SET fdsRead;
    HANDLE hConsole;
    TIMEVAL tvTimeout;
    DWORD dwErr, dwTraceID;
    DWORD dwExactSize, dwInSize, dwOutSize;
    IPBOOTP_MIB_GET_INPUT_DATA imgid;
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod;

    if (!ENTER_BOOTP_WORKER()) { return; }

    TraceGetConsole(ig.IG_MibTraceID, &hConsole);
    if (hConsole == NULL) {
        LEAVE_BOOTP_WORKER();
        return;
    }

    ClearScreen(hConsole);

    c.X = c.Y = 0;

    dwInSize = sizeof(imgid);
    imgid.IMGID_TypeID = IPBOOTP_GLOBAL_CONFIG_ID;
    dwOutSize = 0;
    pimgod = NULL;


    dwErr = MibGetFirst(dwInSize, &imgid, &dwOutSize, pimgod);

    if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

        pimgod = BOOTP_ALLOC(dwOutSize);
        if (pimgod) {
            dwErr = MibGetFirst(dwInSize, &imgid, &dwOutSize, pimgod);
        }
    }

    while (dwErr == NO_ERROR) {

        switch(pimgod->IMGOD_TypeID) {
            case IPBOOTP_GLOBAL_CONFIG_ID:
                PrintGlobalConfig(hConsole, &c, &imgid, pimgod);
                break;
            case IPBOOTP_IF_CONFIG_ID:
                PrintIfConfig(hConsole, &c, &imgid, pimgod);
                break;
            case IPBOOTP_IF_BINDING_ID:
                PrintIfBinding(hConsole, &c, &imgid, pimgod);
                break;
            case IPBOOTP_IF_STATS_ID:
                PrintIfStats(hConsole, &c, &imgid, pimgod);
                break;
            default:
                break;
        }


        //
        // move to next line
        //

        ++c.Y;

        dwOutSize = 0;
        if (pimgod) { BOOTP_FREE(pimgod); pimgod = NULL; } 

        dwErr = MibGetNext(dwInSize, &imgid, &dwOutSize, pimgod);

        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

            pimgod = BOOTP_ALLOC(dwOutSize);
            if (pimgod) {
                dwErr = MibGetNext(dwInSize, &imgid, &dwOutSize, pimgod);
            }
        }
    }

    if (pimgod != NULL) { BOOTP_FREE(pimgod); }

    
    LEAVE_BOOTP_WORKER();

    return;
}
#endif //if DBG

#define WriteLine(h,c,fmt,arg) {                                            \
    DWORD _dw;                                                              \
    CHAR _sz[200];                                                          \
    _dw = StringCchPrintf(_sz, 200, fmt, arg);                              \
    if ( SUCCEEDED(_dw) ) {                                                  \
        WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);             \
        ++(c).Y;                                                            \
    }                                                                       \
}


VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PDWORD pdwsrv, pdwsrvend;
    PIPBOOTP_GLOBAL_CONFIG pgc;

    pgc = (PIPBOOTP_GLOBAL_CONFIG)pimgod->IMGOD_Buffer;

    WriteLine(
        hConsole,
        *pc,
        "Logging Level:                         %d",
        pgc->GC_LoggingLevel
        );
    WriteLine(
        hConsole,
        *pc,
        "Max Receive Queue Size:                %d",
        pgc->GC_MaxRecvQueueSize
        );
    WriteLine(
        hConsole,
        *pc,
        "BOOTP Server Count:                    %d",
        pgc->GC_ServerCount
        );
    pdwsrv = (PDWORD)(pgc + 1);
    pdwsrvend = pdwsrv + pgc->GC_ServerCount;
    for ( ; pdwsrv < pdwsrvend; pdwsrv++) {
        WriteLine(
            hConsole,
            *pc,
            "BOOTP Server:                          %s",
            INET_NTOA(*pdwsrv)
            );
    }

    pimgid->IMGID_TypeID = IPBOOTP_GLOBAL_CONFIG_ID;
}


VOID
PrintIfConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    CHAR szMode[20];
    PIPBOOTP_IF_CONFIG pic;

    pic = (PIPBOOTP_IF_CONFIG)pimgod->IMGOD_Buffer;

    switch (pic->IC_RelayMode) {
        case IPBOOTP_RELAY_ENABLED:
            strcpy(szMode, "enabled"); break;
        case IPBOOTP_RELAY_DISABLED:
            strcpy(szMode, "disabled"); break;
        default:
            break;
    }


    WriteLine(
        hConsole,
        *pc,
        "Interface Index:                       %d",
        pimgod->IMGOD_IfIndex
        );
    WriteLine(
        hConsole,
        *pc,
        "Relay Mode:                            %s",
        szMode
        );
    WriteLine(
        hConsole,
        *pc,
        "Max Hop Count:                         %d",
        pic->IC_MaxHopCount
        );
    WriteLine(
        hConsole,
        *pc,
        "Min Seconds Since Boot:                %d",
        pic->IC_MinSecondsSinceBoot
        );

    pimgid->IMGID_TypeID = IPBOOTP_IF_CONFIG_ID;
    pimgid->IMGID_IfIndex = pimgod->IMGOD_IfIndex;
}


VOID
PrintIfBinding(
    HANDLE hConsole,
    PCOORD pc,
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    DWORD i;
    CHAR szAddr[64];
    PIPBOOTP_IF_BINDING pib;
    PIPBOOTP_IP_ADDRESS paddr;

    pib = (PIPBOOTP_IF_BINDING)pimgod->IMGOD_Buffer;
    paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);

    WriteLine(
        hConsole, *pc, "Interface Index:                  %d",
        pimgod->IMGOD_IfIndex
        );
    WriteLine(
        hConsole, *pc, "Address Count:                    %d",
        pib->IB_AddrCount
        );
    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
        LPSTR szTemp;
        szTemp = INET_NTOA(paddr->IA_Address);
        if (szTemp != NULL) {
            lstrcpy(szAddr, szTemp);
            lstrcat(szAddr, " - ");
            szTemp = INET_NTOA(paddr->IA_Netmask);
            if ( szTemp != NULL ) { lstrcat(szAddr, szTemp); }
            WriteLine(
                hConsole, *pc, "Address Entry:                    %s",
                szAddr
                );
        }
    }

    pimgid->IMGID_TypeID = IPBOOTP_IF_BINDING_ID;
    pimgid->IMGID_IfIndex = pimgod->IMGOD_IfIndex;
}



VOID
PrintIfStats(
    HANDLE hConsole,
    PCOORD pc,
    PIPBOOTP_MIB_GET_INPUT_DATA pimgid,
    PIPBOOTP_MIB_GET_OUTPUT_DATA pimgod
    ) {

    PIPBOOTP_IF_STATS pis;

    pis = (PIPBOOTP_IF_STATS)pimgod->IMGOD_Buffer;

    WriteLine(
        hConsole,
        *pc,
        "Interface Index:                       %d",
        pimgod->IMGOD_IfIndex
        );
    WriteLine(
        hConsole,
        *pc,
        "Send Failures:                         %d",
        pis->IS_SendFailures
        );
    WriteLine(
        hConsole,
        *pc,
        "Receive Failures:                      %d",
        pis->IS_ReceiveFailures
        );
    WriteLine(
        hConsole,
        *pc,
        "ARP Cache Update Failures:             %d",
        pis->IS_ArpUpdateFailures
        );
    WriteLine(
        hConsole,
        *pc,
        "Requests Received:                     %d",
        pis->IS_RequestsReceived
        );
    WriteLine(
        hConsole,
        *pc,
        "Requests Discarded:                    %d",
        pis->IS_RequestsDiscarded
        );
    WriteLine(
        hConsole,
        *pc,
        "Replies Received:                      %d",
        pis->IS_RepliesReceived
        );
    WriteLine(
        hConsole,
        *pc,
        "Replies Discarded:                     %d",
        pis->IS_RepliesDiscarded
        );

    pimgid->IMGID_TypeID = IPBOOTP_IF_STATS_ID;
    pimgid->IMGID_IfIndex = pimgod->IMGOD_IfIndex;
}

char * 
myinet_ntoa(
    struct in_addr in
    ) {

    char *rv;

    rv = inet_ntoa(in);
    return rv ? rv : UNKNOWN_ADDRESS_STR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\sync.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: sync.h
//
// History:
//      Abolade Gbadegesin  September-8-1995  Created.
//
// Contains structures and macros used to implement synchronization.
//============================================================================

#ifndef _SYNC_H_
#define _SYNC_H_


//----------------------------------------------------------------------------
// struct:      READ_WRITE_LOCK
//
// This implements a multiple-reader/single-writer locking scheme
//
typedef RTL_RESOURCE READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
            RtlInitializeResource((pRWL))
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
            RtlDeleteResource((pRWL))
#define READ_WRITE_LOCK_CREATED(pRWL)   (TRUE)
#define ACQUIRE_READ_LOCK(pRWL)                                             \
            RtlAcquireResourceShared((pRWL),TRUE)
#define RELEASE_READ_LOCK(pRWL)                                             \
            RtlReleaseResource((pRWL))
#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
            RtlAcquireResourceExclusive((pRWL),TRUE)
#define RELEASE_WRITE_LOCK(pRWL)                                            \
            RtlReleaseResource((pRWL))
#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
            RtlConvertSharedToExclusive((pRWL))
#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
            RtlConvertExclusiveToShared((pRWL))


//----------------------------------------------------------------------------
// struct:      LOCKED_LIST
//
// type definition for generic locked list
// access is sychronized with a critical section
// the LIST_ENTRY field must be the first field in structs linked
// together by this construct, in order for the destruction of the
// list to work correctly (i.e. in order for HeapFree(RemoveHeadList(l))
// to free the correct pointer).
//
typedef struct _LOCKED_LIST {
    LIST_ENTRY          LL_Head;
    CRITICAL_SECTION    LL_Lock;
    DWORD               LL_Created;
} LOCKED_LIST, *PLOCKED_LIST;

// macro functions for manipulating the locked list
//
#define CREATE_LOCKED_LIST(pLL)                                             \
            InitializeListHead(&(pLL)->LL_Head);                            \
            InitializeCriticalSection(&(pLL)->LL_Lock);                     \
            (pLL)->LL_Created = 0x12345678
#define LOCKED_LIST_CREATED(pLL)                            \
            ((pLL)->LL_Created == 0x12345678)
#define DELETE_LOCKED_LIST(pLL) {                           \
            PLIST_ENTRY _ple;                               \
            (pLL)->LL_Created = 0;                          \
            DeleteCriticalSection(&(pLL)->LL_Lock);         \
            while (!IsListEmpty(&(pLL)->LL_Head)) {         \
                _ple = RemoveHeadList(&(pLL)->LL_Head);     \
                BOOTP_FREE(_ple);                           \
            }                                               \
        }
#define ACQUIRE_LIST_LOCK(pLL)                              \
            EnterCriticalSection(&(pLL)->LL_Lock)
#define RELEASE_LIST_LOCK(pLL)                              \
            LeaveCriticalSection(&(pLL)->LL_Lock)


#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\table.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    table.h
//
// History:
//      Abolade Gbadegesin  August 31, 1995     Created
//
// Interface table and stats tables declarations
//============================================================================


#ifndef _TABLE_H_
#define _TABLE_H_


#define GETMODE_EXACT   0
#define GETMODE_FIRST   1
#define GETMODE_NEXT    2


//
// TYPE DEFINITIONS FOR INTERFACE MANAGEMENT
//


//
// struct:      IF_TABLE_ENTRY
//
// declares the components of an interface table entry
//

typedef struct _IF_TABLE_ENTRY {

    LIST_ENTRY          ITE_LinkByAddress;
    LIST_ENTRY          ITE_LinkByIndex;
    LIST_ENTRY          ITE_HTLinkByIndex;
    DWORD               ITE_Index;
    DWORD               ITE_Flags;
    IPBOOTP_IF_STATS    ITE_Stats;
    PIPBOOTP_IF_CONFIG  ITE_Config;
    PIPBOOTP_IF_BINDING ITE_Binding;
    SOCKET             *ITE_Sockets;

} IF_TABLE_ENTRY, *PIF_TABLE_ENTRY;


#define ITEFLAG_BOUND               ((DWORD)0x00000001)
#define ITEFLAG_ENABLED             ((DWORD)0x00000002)



//
// macros and definitions used by interface tables
//

#define IF_HASHTABLE_SIZE       29
#define IF_HASHVALUE(i)                     \
        (((i) + ((i) >> 8) + ((i) >> 16) + ((i) >> 24)) % IF_HASHTABLE_SIZE)

#define IF_IS_BOUND(i)      \
        ((i)->ITE_Flags & ITEFLAG_BOUND)
#define IF_IS_ENABLED(i)    \
        ((i)->ITE_Flags & ITEFLAG_ENABLED)
#define IF_IS_ACTIVE(i)     \
        (IF_IS_BOUND(i) && IF_IS_ENABLED(i))

#define IF_IS_UNBOUND(i)    !IF_IS_BOUND(i)
#define IF_IS_DISABLED(i)   !IF_IS_ENABLED(i)
#define IF_IS_INACTIVE(i)   !IF_IS_ACTIVE(i)


//
// struct:      IF_TABLE
//
// declares the structure of an interface table. consists of a hash-table
// of IF_TABLE_ENTRY structures hashed on interface index, and a list
// of all activated interfaces ordered by IP address
//

typedef struct _IF_TABLE {

    DWORD               IT_Created;
    LIST_ENTRY          IT_ListByAddress;
    LIST_ENTRY          IT_ListByIndex;
    LIST_ENTRY          IT_HashTableByIndex[IF_HASHTABLE_SIZE];
    READ_WRITE_LOCK     IT_RWL;

} IF_TABLE, *PIF_TABLE;

#define IF_TABLE_CREATED(pTable)    ((pTable)->IT_Created == 0x12345678)

DWORD
CreateIfTable(
    PIF_TABLE pTable
    );

DWORD
DeleteIfTable(
    PIF_TABLE pTable
    );

DWORD
CreateIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PVOID pConfig
    );

DWORD
DeleteIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

DWORD
ValidateIfConfig(
    PIPBOOTP_IF_CONFIG pic
    );

DWORD
CreateIfSocket(
    PIF_TABLE_ENTRY pITE
    );

DWORD
DeleteIfSocket(
    PIF_TABLE_ENTRY pITE
    );

DWORD
BindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    );

DWORD
UnBindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

DWORD
EnableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

DWORD
DisableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

DWORD
ConfigureIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PVOID pConfig
    );

PIF_TABLE_ENTRY
GetIfByIndex(
    PIF_TABLE pTable,
    DWORD dwIndex
    );

PIF_TABLE_ENTRY
GetIfByAddress(
    PIF_TABLE pTable,
    DWORD dwAddress,
    PDWORD pdwAddrIndex
    );

PIF_TABLE_ENTRY
GetIfByListIndex(
    PIF_TABLE pTable,
    DWORD dwIndex,
    DWORD dwGetMode,
    PDWORD pdwErr
    );
                             
DWORD
InsertIfByAddress(
    PIF_TABLE pTable,
    PIF_TABLE_ENTRY pITE
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\work.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    work.h
//
// History:
//      Abolade Gbadegesin  August 31, 1995     Created
//
// Worker function declarations
//============================================================================


#ifndef _WORK_H_
#define _WORK_H_

#define UNKNOWN_ADDRESS_STR     "Unknown address"

typedef struct _INPUT_CONTEXT {
    DWORD       IC_InterfaceIndex;
    DWORD       IC_AddrIndex;
    SOCKADDR_IN IC_InputSource;
    DWORD       IC_InputLength;
    BYTE        IC_InputPacket[MAX_PACKET_SIZE];
} INPUT_CONTEXT, *PINPUT_CONTEXT;



VOID
CallbackFunctionNetworkEvents(
    PVOID   pvContext,
    BOOLEAN NotUsed
    );

VOID
WorkerFunctionNetworkEvents(
    PVOID pvContextNotused
    );

DWORD
ProcessSocket(
    PIF_TABLE_ENTRY pite,
    DWORD dwAddrIndex,
    PIF_TABLE pTable
    );
    
VOID
WorkerFunctionProcessInput(
    PVOID pContext
    );

VOID
ProcessRequest(
    PVOID pContext
    );

VOID
ProcessReply(
    PVOID pContext
    );

char * 
myinet_ntoa(
    struct in_addr in
    );


#if DBG

VOID
CallbackFunctionMibDisplay(
    PVOID   pContext,
    BOOLEAN NotUsed
    );

    
VOID
WorkerFunctionMibDisplay(
    PVOID pContext
    );

#endif //if DBG

#endif // _WORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\table.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    table.c
//
// History:
//      Abolade Gbadegesin  August 31, 1995     Created
//
// Interface table and stats tables management routines
//============================================================================

#include "pchbootp.h"


//----------------------------------------------------------------------------
// Function:    CreateIfTable
//
// Initializes an interface table.
//----------------------------------------------------------------------------

DWORD
CreateIfTable(
    PIF_TABLE pTable
    ) {

    DWORD dwErr;
    PLIST_ENTRY ple, plend;


    //
    // return an error if the table is already created
    //

    if ( IF_TABLE_CREATED(pTable) ) {

        TRACE0( IF, "interface table already initialized" );

        return ERROR_ALREADY_EXISTS;
    }


    //
    // initialize the by-address and by-index lists of interfaces
    //

    InitializeListHead( &pTable->IT_ListByAddress );
    InitializeListHead(&pTable->IT_ListByIndex);


    //
    // initialize the by-index hash-table of interfaces
    //

    plend = pTable->IT_HashTableByIndex + IF_HASHTABLE_SIZE;

    for ( ple = pTable->IT_HashTableByIndex; ple < plend; ple++ ) {
        InitializeListHead( ple );
    }


    //
    // initialize the lock which will protect the table
    //

    dwErr = NO_ERROR;

    try {
        CREATE_READ_WRITE_LOCK( &pTable->IT_RWL );
    }
    except ( EXCEPTION_EXECUTE_HANDLER ) {

        dwErr = GetExceptionCode( );

        TRACE1( IF, "error %d initializing interface table lock", dwErr );

    }


    if ( dwErr == NO_ERROR ) {
        pTable->IT_Created = 0x12345678;
    }

    return dwErr;

}



//----------------------------------------------------------------------------
// Function:    DeleteIfTable
//
// Deinitializes an interface table, and releases all resources used.
// Assumes the table is locked exclusively
//----------------------------------------------------------------------------

DWORD
DeleteIfTable(
    PIF_TABLE pTable
    ) {

    DWORD dwErr;
    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, plend, phead;

    //
    // clear the creation flag on the table
    //
    pTable->IT_Created = 0;



    //
    // free memory used by all entries
    //

    plend = pTable->IT_HashTableByIndex + IF_HASHTABLE_SIZE;

    for ( phead = pTable->IT_HashTableByIndex; phead < plend; phead++ ) {

        while ( !IsListEmpty( phead ) ) {

            ple = RemoveHeadList( phead );
            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_HTLinkByIndex);

            if (IF_IS_BOUND(pite)) {

                DeleteIfSocket(pite);

                if (IF_IS_ENABLED(pite)) {
                    RemoveEntryList(&pite->ITE_LinkByAddress);
                }

                BOOTP_FREE(pite->ITE_Binding);
            }
            
            if (pite->ITE_Config) {
                BOOTP_FREE(pite->ITE_Config);
            }

            BOOTP_FREE( pite );
        }
    }


    dwErr = NO_ERROR;

    try {
        DELETE_READ_WRITE_LOCK( &pTable->IT_RWL );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {

        dwErr = GetExceptionCode( );

        TRACE1( IF, "error %d deleting interface table lock", dwErr );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    CreateIfEntry
//
// Allocates and initializes an entry for an interface in the table,
// using the supplied configuration. Assumes table is locked exclusively.
//----------------------------------------------------------------------------

DWORD
CreateIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PVOID pConfig
    ) {

    DWORD dwErr, dwSize;
    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, phead;
    PIPBOOTP_IF_CONFIG picsrc, picdst;

    dwErr = NO_ERROR;

    do {    // error breakout loop


        //
        // see if the interface already exists
        //

        pite = GetIfByIndex( pTable, dwIndex );

        if ( pite != NULL ) {

            TRACE1( IF, "interface %d already exists", dwIndex );

            dwErr = ERROR_ALREADY_EXISTS; pite = NULL; break;
        }


        //
        // now allocate memory for the interface
        //

        pite = BOOTP_ALLOC( sizeof(IF_TABLE_ENTRY) );
    
        if ( pite == NULL ) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            TRACE2(
                IF, "error %d allocating %d bytes for interface entry",
                dwErr, sizeof(IF_TABLE_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize struct fields
        //

        pite->ITE_Index = dwIndex;

        //
        // We come up in disabled state
        //

        pite->ITE_Flags = 0;

        pite->ITE_Sockets = NULL;
        pite->ITE_Config = NULL;


        //
        // get the size of the configuration block
        //

        picsrc = (PIPBOOTP_IF_CONFIG)pConfig;

        dwSize = IC_SIZEOF( picsrc );


        //
        // validate the configuration parameters
        //

        dwErr = ValidateIfConfig(pConfig);
        if (dwErr != NO_ERROR) {
            TRACE1(IF, "invalid config specified for interface %d", dwIndex);
            break;
        }


        //
        // allocate space for the configuration
        //

        picdst = BOOTP_ALLOC( dwSize );

        if ( picdst == NULL ) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            TRACE2(
                IF, "error %d allocating %d bytes for interface configuration",
                dwErr, dwSize
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            pite->ITE_Config = NULL; break;
        }


        //
        // copy the configuration
        //

        CopyMemory(picdst, picsrc, dwSize);

        pite->ITE_Config = picdst;


        //
        // initialize binding information and interface stats
        //

        pite->ITE_Binding = NULL;
        ZeroMemory(&pite->ITE_Stats, sizeof(IPBOOTP_IF_STATS));


        //
        // insert the interface in the hash table
        //

        phead = pTable->IT_HashTableByIndex + IF_HASHVALUE( dwIndex );

        InsertHeadList( phead, &pite->ITE_HTLinkByIndex );


        //
        // insert the interface in the list ordered by index
        //

        phead = &pTable->IT_ListByIndex;
        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
            PIF_TABLE_ENTRY ptemp;

            ptemp = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByIndex);
            if (pite->ITE_Index < ptemp->ITE_Index) { break; }
        }


        InsertTailList(ple, &pite->ITE_LinkByIndex);


    } while( FALSE );


    if ( dwErr != NO_ERROR && pite != NULL ) {

        if ( pite->ITE_Config != NULL ) {
            BOOTP_FREE( pite->ITE_Config );
        }

        BOOTP_FREE( pite );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DeleteIfEntry
//
// Removes an interface from the interface table.
// Assumes the table is locked exclusively.
//----------------------------------------------------------------------------

DWORD
DeleteIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE_ENTRY pite;

    //
    // make certain the interface exists
    //
    pite = GetIfByIndex( pTable, dwIndex );

    if ( pite == NULL ) {
        TRACE1( IF, "deleting interface: interface %d not found", dwIndex );
        return ERROR_INVALID_PARAMETER;
    }



    //
    // cleanup the socket depending on its state
    //

    if (IF_IS_BOUND(pite)) {

        DeleteIfSocket(pite);

        if (IF_IS_ENABLED(pite)) {
            RemoveEntryList(&pite->ITE_LinkByAddress);
        }

        BOOTP_FREE(pite->ITE_Binding);
    }



    //
    // remove the entry from the hash table and the list sorted by index
    //

    RemoveEntryList( &pite->ITE_HTLinkByIndex );
    RemoveEntryList( &pite->ITE_LinkByIndex );

    BOOTP_FREE( pite->ITE_Config );
    BOOTP_FREE( pite );

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    ValidateIfConfig
//
// Validates the contents of the specified IPBOOTP_IF_CONFIG structure.
//----------------------------------------------------------------------------

DWORD
ValidateIfConfig(
    PIPBOOTP_IF_CONFIG pic
    ) {

    CHAR szStr[12];


    if (pic->IC_RelayMode != IPBOOTP_RELAY_ENABLED &&
        pic->IC_RelayMode != IPBOOTP_RELAY_DISABLED) {

        TRACE1(
            IF, "Invalid value for relay mode %d",
            pic->IC_RelayMode
            );

        _ltoa(pic->IC_RelayMode, szStr, 10);

        LOGERR2(
            INVALID_IF_CONFIG, "Relay Mode", szStr, 
            ERROR_INVALID_PARAMETER
            );
            
        return ERROR_INVALID_PARAMETER;
    }

    if (pic->IC_MaxHopCount > IPBOOTP_MAX_HOP_COUNT) {
    
        TRACE1(
            IF, "Invalid value for max hop count %d",
            pic->IC_MaxHopCount
            );

        _ltoa(pic->IC_MaxHopCount, szStr, 10);

        LOGERR2(
            INVALID_IF_CONFIG, "Max Hop Count", szStr,
            ERROR_INVALID_PARAMETER
            );
            
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    CreateIfSocket
//
// Initializes the socket for an interface. Assumes the interface table lock
// is held exclusively.
//----------------------------------------------------------------------------

DWORD
CreateIfSocket(
    PIF_TABLE_ENTRY pITE
    ) {

    SOCKADDR_IN sinaddr;
    PIPBOOTP_IF_BINDING pib;
    PIPBOOTP_IP_ADDRESS paddr;
    DWORD i, dwErr, dwOption;

    pib = pITE->ITE_Binding;
    paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);


    //
    // allocate memory for the array of sockets
    //

    pITE->ITE_Sockets = BOOTP_ALLOC(pib->IB_AddrCount * sizeof(SOCKET));

    if (pITE->ITE_Sockets == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        TRACE3(
            IF, "error %d allocating %d bytes for sockets on interface %d",
            dwErr, pib->IB_AddrCount * sizeof(SOCKET), pITE->ITE_Index
            );
        LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
    }


    //
    // initialize the array
    //

    for (i = 0; i < pib->IB_AddrCount; i++) {
        pITE->ITE_Sockets[i] = INVALID_SOCKET;
    }



    //
    // go through the table of addresses in the binding, 
    // creating a socket for each address
    //

    for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {

        //
        // create a socket
        //

        pITE->ITE_Sockets[i] = WSASocket( AF_INET, SOCK_DGRAM, 0, NULL, 0, 0 );

        if (pITE->ITE_Sockets[i] == INVALID_SOCKET) {

            LPSTR lpszAddr;

            dwErr = WSAGetLastError( );
            lpszAddr = INET_NTOA( paddr->IA_Address );
            TRACE3(
                IF, "error %d creating socket for interface %d (%s)",
                dwErr, pITE->ITE_Index, lpszAddr
                );
            LOGERR1(CREATE_SOCKET_FAILED, lpszAddr, dwErr);

            break;
        }


        //
        // enable address re-use on this socket
        //

        dwOption = 1;
        dwErr = setsockopt(
                    pITE->ITE_Sockets[i], SOL_SOCKET, SO_REUSEADDR,
                    (PBYTE)&dwOption, sizeof( DWORD )
                    );

        if ( dwErr == SOCKET_ERROR ) {

            //
            // this is a non-fatal error, so print a warning,
            // but continue initializing the socket
            //

            dwErr = WSAGetLastError( );
            TRACE3(
                IF, "error %d enabling address re-use for interface %d (%s)",
                dwErr, pITE->ITE_Index, INET_NTOA( paddr->IA_Address )
                );
        }



        //
        // enable broadcasting on the socket
        //

        dwOption = 1;
        dwErr = setsockopt(
                    pITE->ITE_Sockets[i], SOL_SOCKET, SO_BROADCAST, 
                    (PBYTE)&dwOption, sizeof( DWORD )
                    );

        if ( dwErr == SOCKET_ERROR ) {

            LPSTR lpszAddr;

            dwErr = WSAGetLastError( );
            lpszAddr = INET_NTOA( paddr->IA_Address );
            TRACE3(
                IF, "error %d enabling broadcast for interface %d (%s)",
                dwErr, pITE->ITE_Index, lpszAddr
                );
            LOGERR1(ENABLE_BROADCAST_FAILED, lpszAddr, dwErr);

            break;
        }



        //
        // bind to the address and the BOOTP Server port
        //

        sinaddr.sin_port = htons( IPBOOTP_SERVER_PORT );
        sinaddr.sin_family = AF_INET;
        sinaddr.sin_addr.s_addr = paddr->IA_Address;
        
        dwErr = bind(
                    pITE->ITE_Sockets[i], (PSOCKADDR)&sinaddr,
                    sizeof(SOCKADDR_IN)
                    );

        if ( dwErr == SOCKET_ERROR ) {

            dwErr = WSAGetLastError( );
            TRACE3(
                IF, "error %d binding interface %d (%s) to BOOTP port",
                dwErr, pITE->ITE_Index, INET_NTOA( paddr->IA_Address )
                );

            break;
        }

        dwErr = NO_ERROR;

    }

    if ( i < pib->IB_AddrCount ) {

        //
        // an error occurred, so clean up
        //

        DeleteIfSocket( pITE );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DeleteIfSocket
//
// This function closes the socket used by an interface.
// It assumes the interface table lock is held exclusively.
//----------------------------------------------------------------------------

DWORD
DeleteIfSocket(
    PIF_TABLE_ENTRY pITE
    ) {

    DWORD i, dwErr = NO_ERROR;
    PIPBOOTP_IF_BINDING pib;
    PIPBOOTP_IP_ADDRESS paddr;

    pib = pITE->ITE_Binding;
    if (!pib) { return ERROR_INVALID_PARAMETER; }

    paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);

    for (i = 0; i < pib->IB_AddrCount; i++) {

        if ( pITE->ITE_Sockets[i] == INVALID_SOCKET ) { continue; }

        dwErr = closesocket( pITE->ITE_Sockets[i] );
    
        if ( dwErr == SOCKET_ERROR ) {
    
            dwErr = WSAGetLastError( );
            TRACE3(
                IF, "error %d closing socket for interface %d (%s)",
                dwErr, pITE->ITE_Index, INET_NTOA( paddr->IA_Address )
                );
        }
    }

    BOOTP_FREE(pITE->ITE_Sockets);
    pITE->ITE_Sockets = NULL;

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    BindIfEntry
//
// This function updates the binding information for an interface.
// It assumes the interface table is locked for writing.
//----------------------------------------------------------------------------

DWORD
BindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    ) {

    DWORD i, dwErr = NO_ERROR, dwSize;
    PIF_TABLE_ENTRY pite        = (PIF_TABLE_ENTRY) NULL;
    PIPBOOTP_IF_BINDING pib     = (PIPBOOTP_IF_BINDING) NULL;
    PIPBOOTP_IP_ADDRESS paddr   = (PIPBOOTP_IP_ADDRESS) NULL;

    do {

        //
        // retrieve the interface to be bound
        //

        pite = GetIfByIndex( pTable, dwIndex );

        if ( pite == NULL ) {

            TRACE1( IF, "binding interface: interface %d not found", dwIndex );
            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }
    

        //
        // make sure the interface is not bound
        //
    
        if ( IF_IS_BOUND(pite) ) {

            TRACE1( IF, "interface %d is already bound", dwIndex );

            break;
        }
    

        //
        // make sure there is at least one address
        //

        if (pBinding->AddressCount == 0) { break; }

        dwSize = sizeof(IPBOOTP_IF_BINDING) +
                    pBinding->AddressCount * sizeof(IPBOOTP_IP_ADDRESS);


        //
        // allocate memory to store the binding
        // in our format
        //

        pib = BOOTP_ALLOC(dwSize);

        if (pib == NULL) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            TRACE3(
                IF, "error %d allocating %d bytes for binding on interface %d",
                dwErr, dwSize, dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // convert the binding into our format
        //

        pib->IB_AddrCount = pBinding->AddressCount;
        paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);
        
        for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
            paddr->IA_Address = pBinding->Address[i].Address;
            paddr->IA_Netmask = pBinding->Address[i].Mask;
        }


        //
        // save the binding in the interface entry
        //

        pite->ITE_Binding = pib;

    
        dwErr = CreateIfSocket(pite);

        if (dwErr != NO_ERROR) { break; }


        pite->ITE_Flags |= ITEFLAG_BOUND;



        //
        // if the interface is also enabled, it is now active
        // so we put it on the active list
        //

        if (IF_IS_ENABLED(pite)) {


            //
            // place interface on the list of active interfaces
            //

            dwErr = InsertIfByAddress(pTable, pite);

            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d inserting interface %d in active list",
                    dwErr, dwIndex
                    );

                pite->ITE_Flags &= ~ITEFLAG_BOUND;
                DeleteIfSocket( pite );

                break;
            }


            //
            // request notification of input events from Winsock
            //

            paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);

            for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {

                dwErr = WSAEventSelect(
                            pite->ITE_Sockets[i], ig.IG_InputEvent, FD_READ
                            );

                if (dwErr != NO_ERROR) {
    
                    LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);
                    TRACE3(
                        IF, "WSAEventSelect returned %d for interface %d (%s)",
                        dwErr, dwIndex, lpszAddr
                        );
                    LOGERR1(EVENTSELECT_FAILED, lpszAddr, dwErr);
    
                    RemoveEntryList(&pite->ITE_LinkByAddress);
                    pite->ITE_Flags &= ~ITEFLAG_BOUND;

                    DeleteIfSocket( pite );
    
                    break;
                }
            }

            if (i < pib->IB_AddrCount) { break; }
        }

    } while(FALSE);


    if (dwErr != NO_ERROR) {

        if (pib) { BOOTP_FREE(pib); }

        if (pite) { pite->ITE_Binding = NULL; }
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    UnBindIfEntry
//
// removes the binding for the specified interface.
// Assumes the interface table is locked for writing.
//----------------------------------------------------------------------------

DWORD
UnBindIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE_ENTRY pite;

    dwErr = NO_ERROR;

    do {

        //
        // retrieve the interface to be unbound
        //

        pite = GetIfByIndex( pTable, dwIndex );
        if ( pite == NULL ) {

            TRACE1(IF, "unbinding interface: interface %d not found", dwIndex);
            return ERROR_INVALID_PARAMETER;
        }
    

        //
        // quit if interface is already unbound
        //

        if ( IF_IS_UNBOUND( pite ) ) {

            TRACE1( IF, "interface %d is already unbound", dwIndex );

            break;
        }
    


        //
        // if the interface was active (i.e. bound and enabled)
        // it is no longer, so remove it from the active list
        //

        if ( IF_IS_ENABLED( pite ) ) {

            RemoveEntryList( &pite->ITE_LinkByAddress );
        }
    
        pite->ITE_Flags &= ~ITEFLAG_BOUND;
        DeleteIfSocket( pite );

        BOOTP_FREE(pite->ITE_Binding);
        pite->ITE_Binding = NULL;

    } while(FALSE);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    EnableIfEntry
//
// This function initiates BOOTP relay activity on the specified interface.
// It assumes the interface table lock is held exclusively.
//----------------------------------------------------------------------------

DWORD
EnableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD i, dwErr;
    PIF_TABLE_ENTRY pite;
    PIPBOOTP_IF_BINDING pib;
    PIPBOOTP_IP_ADDRESS paddr;

    dwErr = NO_ERROR;

    do {

        //
        // make certain the interface exists
        //

        pite = GetIfByIndex( pTable, dwIndex );
        if ( pite == NULL ) {

            TRACE1( IF, "enabling interface: interface %d not found", dwIndex );
            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }
    

        //
        // make certain the interface is disabled
        //

        if ( IF_IS_ENABLED( pite ) ) {

            TRACE1( IF, "interface %d is already enabled", dwIndex );

            //
            // He shouldnt call us twice but we will still handle it
            //

            break;
        }
    
    
        pite->ITE_Flags |= ITEFLAG_ENABLED;
    

        //
        // if the interface was already bound, it is now active,
        // so place it on the active list
        //

        if ( IF_IS_BOUND( pite ) ) {
    
            //
            // insert the interface in the by-address list of interfaces
            //

            dwErr = InsertIfByAddress( pTable, pite );

            if (dwErr != NO_ERROR) {

                TRACE2(
                    IF, "error %d inserting interface %d in active list",
                    dwErr, dwIndex
                    );

                pite->ITE_Flags &= ~ITEFLAG_ENABLED;

                break;
            }


            pib = pite->ITE_Binding;
            paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);



            //
            // request notification of input events from Winsock
            //

            for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {

                dwErr = WSAEventSelect(
                            pite->ITE_Sockets[i], ig.IG_InputEvent, FD_READ
                            );
                if (dwErr != NO_ERROR) {
    
                    INT j;
                    LPSTR lpszAddr = INET_NTOA(paddr->IA_Address);

                    TRACE3(
                        IF, "WSAEventSelect returned %d for interface %d (%s)",
                        dwErr, dwIndex, lpszAddr
                        );
                    LOGERR1(EVENTSELECT_FAILED, lpszAddr, dwErr);
    
                    RemoveEntryList(&pite->ITE_LinkByAddress);
                    pite->ITE_Flags &= ~ITEFLAG_ENABLED;
    
                    //
                    // clear the requests for events
                    //

                    for (j = i - 1; j >= 0; j--) {
                        dwErr = WSAEventSelect(
                                    pite->ITE_Sockets[j], ig.IG_InputEvent, 0
                                    );
                    }

                    break;
                }
            }

            if (i < pib->IB_AddrCount) { break; }
        }
    
    } while(FALSE);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    ConfigureIfEntry
//
// modifies the configuration for an already-existing interface.
// This assumes the table is locked for writing.
//----------------------------------------------------------------------------

DWORD
ConfigureIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex,
    PVOID pConfig
    ) {

    DWORD dwErr, dwSize;
    PIF_TABLE_ENTRY pite;
    PIPBOOTP_IF_CONFIG picsrc, picdst;


    //
    // retrieve the interface to be reconfigured
    //

    pite = GetIfByIndex(pTable, dwIndex);
    if (pite == NULL) {

        TRACE1( IF, "configuring interface: interface %d not found", dwIndex );

        return ERROR_INVALID_PARAMETER;
    }



    do { // breakout loop


        //
        // compute the size needed to store the new configuration
        //

        picsrc = (PIPBOOTP_IF_CONFIG)pConfig;
        dwSize = IC_SIZEOF(picsrc);


        //
        // make sure the new parameters are valid
        //

        dwErr = ValidateIfConfig(pConfig);
        if (dwErr != NO_ERROR) {
            TRACE1(IF, "invalid config specified for interface %d", dwIndex);
            break;
        }


        //
        // allocate space for the new configuration
        //

        picdst = BOOTP_ALLOC(dwSize);
        if (picdst == NULL) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            TRACE3(
                IF, "error %d allocating %d bytes for interface %d config",
                dwErr, dwSize, dwIndex
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }

        CopyMemory(picdst, picsrc, dwSize);

        if (pite->ITE_Config) { BOOTP_FREE(pite->ITE_Config); }
        pite->ITE_Config = picdst;

        dwErr = NO_ERROR;

    } while(FALSE);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DisableIfEntry
//
// This function stops RIP activaty on the specified interface.
// It assumes the interface table is locked for writing.
//----------------------------------------------------------------------------

DWORD
DisableIfEntry(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {


    DWORD i, dwErr;
    PIF_TABLE_ENTRY pite;
    PIPBOOTP_IF_BINDING pib;
    PIPBOOTP_IP_ADDRESS paddr;

    dwErr = NO_ERROR;

    do {
    
        //
        // make certain the interface exists
        //

        pite = GetIfByIndex( pTable, dwIndex );
        if ( pite == NULL ) {

            TRACE1( IF, "disabling interface: interface %d not found", dwIndex );

            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    

        //
        // make certain the interface is enabled
        //

        if ( IF_IS_DISABLED( pite ) ) {

            TRACE1( IF, "interface %d is already disabled", dwIndex );

            //
            // This is NOT AN ERROR.
            //

            break;
        }
    

        //
        // if the interface was active (i.e. bound and enabled)
        // it isn't anymore, so deactivate it here.
        //
    
        if ( IF_IS_BOUND( pite ) ) {

            //
            // remove the interface from the by-address list
            //

            RemoveEntryList( &pite->ITE_LinkByAddress );


            //  
            // tell Winsock to stop notifying us of input events
            //

            pib = pite->ITE_Binding;
            paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);

            for (i = 0; i < pib->IB_AddrCount; i++) {
                WSAEventSelect(pite->ITE_Sockets[i], ig.IG_InputEvent, 0);
            }
        }


        //
        // clear the enabled flag on the interface
        //

        pite->ITE_Flags &= ~ITEFLAG_ENABLED;

    } while(FALSE);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    GetIfByIndex
//
// returns the interface with the given index.
// Assumes the table is locked.
//----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByIndex(
    PIF_TABLE pTable,
    DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE_ENTRY pite, pitefound = NULL;
    PLIST_ENTRY ple, phead;

    phead = pTable->IT_HashTableByIndex + IF_HASHVALUE( dwIndex );

    for ( ple = phead->Flink; ple != phead; ple = ple->Flink ) {
        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_HTLinkByIndex);
        if (pite->ITE_Index == dwIndex ) { pitefound = pite; break; }
    }

    return pitefound;
}



//----------------------------------------------------------------------------
// Function:    GetIfByAddress
//
// Returns the interface bound with the given address.
// Assumes the table is locked for reading or writing.
//----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByAddress(
    PIF_TABLE pTable,
    DWORD dwAddress,
    PDWORD pdwAddrIndex
    ) {

    INT cmp;
    DWORD i, dwErr;
    PLIST_ENTRY ple, phead;
    PIPBOOTP_IF_BINDING pib;
    PIPBOOTP_IP_ADDRESS paddr;
    PIF_TABLE_ENTRY pite, pitefound = NULL;


    if ( pdwAddrIndex ) { *pdwAddrIndex = 0; }

    phead = &pTable->IT_ListByAddress;

    for ( ple = phead->Flink; ple != phead; ple = ple->Flink ) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByAddress);

        pib = pite->ITE_Binding;

        paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);

        for (i = 0; i < pib->IB_AddrCount; i++, paddr++) {
            if ( dwAddress == paddr->IA_Address ) { pitefound = pite; break; }
        }

        if (pitefound) {
            if (pdwAddrIndex) { *pdwAddrIndex = i; }
            break;
        }
    }


    return pitefound;
}



//----------------------------------------------------------------------------
// Function:    GetIfByListIndex
//
// This function is similar to GetIfByAddress in that it supports
// three modes of retrieval, but it is different in that it looks
// in the list of interfaces sorted by index.
//----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByListIndex(
    PIF_TABLE pTable,
    DWORD dwIndex,
    DWORD dwGetMode,
    PDWORD pdwErr
    ) {

    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY ple, phead;

    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }

    phead = &pTable->IT_ListByIndex;
    pite = NULL;

    //
    // return record at head of list if mode is GETMODE_FIRST;
    // if list is empty, return NULL.
    //

    if (dwGetMode == GETMODE_FIRST) {
        if (phead->Flink == phead) { return NULL; }
        else {
            ple = phead->Flink;
            return CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByIndex);
        }
    }


    //
    // get the entry requested
    //

    pite = GetIfByIndex(pTable, dwIndex);


    //
    // if mode is GETMODE_NEXT, return the item after the one retrieved
    //

    if (dwGetMode == GETMODE_NEXT && pite != NULL) {

        ple = &pite->ITE_LinkByIndex;

        //
        // if entry found is last one, return NULL,
        // otherwise return the following entry
        //

        if (ple->Flink == phead) {
            if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
            pite = NULL;
        }
        else {
            ple = ple->Flink;
            pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, ITE_LinkByIndex);
        }
    }


    return pite;
}




//----------------------------------------------------------------------------
// Function:    InsertIfByAddress
//
// This function inserts an interface in the list sorted by index
// Assumes the table is locked for writing.
//----------------------------------------------------------------------------

DWORD
InsertIfByAddress(
    PIF_TABLE pTable,
    PIF_TABLE_ENTRY pITE
    ) {

    INT cmp;
    PIF_TABLE_ENTRY pite;
    PIPBOOTP_IF_BINDING pib;
    PIPBOOTP_IP_ADDRESS paddr;
    PLIST_ENTRY pfl, phead;
    DWORD dwAddress, dwEntryAddr;

    if ( pITE == NULL || pITE->ITE_Binding == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    pib = pITE->ITE_Binding;
    paddr = IPBOOTP_IF_ADDRESS_TABLE(pib);
    dwAddress = paddr->IA_Address;

    phead = &pTable->IT_ListByAddress;

    for ( pfl = phead->Flink; pfl != phead; pfl = pfl->Flink ) {

        pite = CONTAINING_RECORD( pfl, IF_TABLE_ENTRY, ITE_LinkByAddress );

        paddr = IPBOOTP_IF_ADDRESS_TABLE(pite->ITE_Binding);
        dwEntryAddr = paddr->IA_Address;
        if ( INET_CMP( dwAddress, dwEntryAddr, cmp ) < 0 ) { break; }
        else
        if (cmp == 0) { return ERROR_ALREADY_EXISTS; }
        
    }

    InsertTailList( pfl, &pITE->ITE_LinkByAddress );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\btpagnt\defs.h ===
#ifndef __DEFS_H__
#define __DEFS_H__

//------------------------------------------------------------------------------
// Global config default values
//------------------------------------------------------------------------------
#define     IPBOOTP_DEF_LOG_LEVEL       d_globalLoggingLevel_error
#define     IPBOOTP_DEF_RECV_Q_SIZE     1024 * 1024

#define     IP_ADDRESS_LEN  4

//------------------------------------------------------------------------------
// Interface Config default values
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Memory allocation/deallocation macros
//------------------------------------------------------------------------------

#define     BOOTP_MIB_ALLOC( x )          HeapAlloc( GetProcessHeap(), 0, (x) )
#define     BOOTP_MIB_FREE( x )           HeapFree( GetProcessHeap(), 0, (x) )

//------------------------------------------------------------------------------
// Macro to simplify use of DIM MIB functions
//------------------------------------------------------------------------------
#define     CONNECT_TO_ROUTER(res)                                          \
    (res) = ( g_hMIBServer ) ? NO_ERROR : ConnectToRouter()

#define     MIB_GET(type, w, x, y, z, res)                                  \
{                                                                           \
    CONNECT_TO_ROUTER(res);                                                 \
                                                                            \
    if ( (res) == NO_ERROR )                                                \
    {                                                                       \
        (res) = MprAdminMIBEntry ## type(                                   \
                    g_hMIBServer,                                           \
                    PID_IP,                                                 \
                    MS_IP_BOOTP,                                            \
                    (LPVOID) (w),                                           \
                    (x),                                                    \
                    (LPVOID *) (y),                                         \
                    (z)                                                     \
                );                                                          \
    }                                                                       \
}

#define     BOOTP_MIB_SET(x, y, res)                                        \
{                                                                           \
    CONNECT_TO_ROUTER(res);                                                 \
                                                                            \
    if ( (res) == NO_ERROR )                                                \
    {                                                                       \
        (res) = MprAdminMIBEntrySet(                                        \
                    g_hMIBServer,                                           \
                    PID_IP,                                                 \
                    MS_IP_BOOTP,                                            \
                    (LPVOID) (x),                                           \
                    (y)                                                     \
                );                                                          \
    }                                                                       \
}

#define     BOOTP_MIB_GET(w, x, y, z, res)                                  \
{                                                                           \
    MIB_GET(Get, w, x, y, z, res)                                           \
                                                                            \
    if ( ( (res) == RPC_S_SERVER_UNAVAILABLE ) ||                           \
         ( (res) == RPC_S_UNKNOWN_IF )         ||                           \
         ( (res) == ERROR_CAN_NOT_COMPLETE ) )                              \
    {                                                                       \
        TraceError( (res) );                                                \
        (res) = MIB_S_ENTRY_NOT_FOUND;                                      \
    }                                                                       \
}    

    
#define     BOOTP_MIB_GETFIRST(w, x, y, z, res)                             \
{                                                                           \
    MIB_GET(GetFirst, w, x, y, z, res)                                      \
                                                                            \
    if ( ( (res) == RPC_S_SERVER_UNAVAILABLE ) ||                           \
         ( (res) == RPC_S_UNKNOWN_IF )         ||                           \
         ( (res) == ERROR_CAN_NOT_COMPLETE ) )                              \
    {                                                                       \
        TraceError( (res) );                                                \
        (res) = MIB_S_NO_MORE_ENTRIES;                                      \
    }                                                                       \
}

    
#define     BOOTP_MIB_GETNEXT(w, x, y, z, res)                              \
{                                                                           \
    MIB_GET(GetNext, w, x, y, z, res)                                       \
                                                                            \
    if ( ( (res) == RPC_S_SERVER_UNAVAILABLE ) ||                           \
         ( (res) == RPC_S_UNKNOWN_IF )         ||                           \
         ( (res) == ERROR_CAN_NOT_COMPLETE ) )                              \
    {                                                                       \
        TraceError( (res) );                                                \
        (res) = MIB_S_NO_MORE_ENTRIES;                                      \
    }                                                                       \
}


//------------------------------------------------------------------------------
// Macros to simplify opertions on address tables
//------------------------------------------------------------------------------
#define     FIND_SERVER_ENTRY(Item, Count, Table, Index)                    \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < (Count); __dwInd++ )                                  \
    {                                                                       \
        DWORD   __dwTmp;                                                    \
        if ( !InetCmp( (Item), (Table)[ __dwInd ], __dwTmp ) ) { break; }   \
    }                                                                       \
    (Index) = __dwInd;                                                      \
}

#define     DELETE_SERVER_ENTRY(Index, Count, Src, Dst)                     \
{                                                                           \
    DWORD   __dwSrc = 0, __dwDst = 0;                                       \
    for ( ; __dwSrc < (Count); __dwSrc++ )                                  \
    {                                                                       \
        if ( __dwSrc == (Index) ) { continue; }                             \
        (Dst)[ __dwDst++ ] = (Src)[ __dwSrc ];                              \
    }                                                                       \
}

//------------------------------------------------------------------------------
// Macros to simplify opertions on IP address table
//------------------------------------------------------------------------------
#define     FIND_IP_ADDRESS(Addr, Count, Table, Index)                      \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < (Count); __dwInd++ )                                  \
    {                                                                       \
        DWORD __dwTmp;                                                      \
        if ( !InetCmp(                                                      \
                (Addr).IA_Address,                                          \
                (Table)[ __dwInd].IA_Address,                               \
                __dwTmp                                                     \
              ) &&                                                          \
             !InetCmp(                                                      \
                (Addr).IA_Netmask,                                          \
                (Table)[__dwInd].IA_Netmask,                                \
                __dwTmp                                                     \
              ) )                                                           \
        { break; }                                                          \
    }                                                                       \
    Index = __dwInd;                                                        \
}


//------------------------------------------------------------------------------
// Macros to convert between Asn and Win32 data types
//------------------------------------------------------------------------------

#define SetAsnInteger(dstBuf,val){                          \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_INTEGER);             \
	    (dstBuf)->asnValue.number = (AsnInteger)(val);      \
    }                                                       \
}

#define ForceSetAsnInteger(dstBuf,val){                     \
    (dstBuf)->asnType = ASN_INTEGER;                        \
    (dstBuf)->asnValue.number = (AsnInteger)(val);          \
}

#define SetAsnCounter(dstBuf,val){                          \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_COUNTER);     \
        (dstBuf)->asnValue.counter = (AsnCounter)(val);     \
    }                                                       \
}

#define SetAsnGauge(dstBuf,val){                            \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_GAUGE);       \
        (dstBuf)->asnValue.gauge = (AsnGauge)(val);         \
    }                                                       \
}

#define SetAsnTimeTicks(dstBuf,val){                        \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_TIMETICKS);   \
        (dstBuf)->asnValue.ticks = (AsnTimeticks)(val);     \
    }                                                       \
}

#define SetAsnOctetString(dstBuf,buffer,src,len){           \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);         \
        (dstBuf)->asnValue.string.length = len;             \
        (dstBuf)->asnValue.string.stream = (BYTE*)memcpy(buffer,src,len);\
        (dstBuf)->asnValue.string.dynamic = FALSE;          \
    }                                                       \
}

#define SetAsnIPAddr( dstBuf, val )                             \
{                                                               \
    if ((dstBuf)->asnType)			                            \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if( (dstBuf)->asnValue.address.stream)                  \
        {                                                       \
            (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;\
        }                                                       \
    }                                                           \
}

#define SetAsnIPAddress(dstBuf,buffer,val){                     \
    if ((dstBuf)->asnType)			                            \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if(!(dstBuf)->asnValue.address.stream)                  \
        {                                                       \
           (dstBuf)->asnValue.address.stream = (PBYTE)buffer;   \
           (dstBuf)->asnValue.address.dynamic = FALSE;          \
        }                                                       \
        (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;   \
    }                                                           \
}

#define ForceSetAsnIPAddress(dstBuf,buffer,val){                \
    (dstBuf)->asnType = ASN_RFC1155_IPADDRESS;                  \
    (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;         \
    if(!((dstBuf)->asnValue.address.stream))                    \
    {                                                           \
       (dstBuf)->asnValue.address.stream = (PBYTE)buffer;       \
       (dstBuf)->asnValue.address.dynamic = FALSE;              \
    }                                                           \
    (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;       \
}

#define SetAsnUshort(dstBuf,buffer,val){                   \
    if ((dstBuf)->asnType)			 \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);        \
        (dstBuf)->asnValue.string.length = 2;              \
        (buffer)[0] = (BYTE)(val&0xFF);                    \
        (buffer)[1] = (BYTE)((val>>8)&0xFF);               \
        (dstBuf)->asnValue.string.stream = (BYTE *)buffer; \
        (dstBuf)->asnValue.string.dynamic = FALSE;         \
    }                                                      \
}
#define SetAsnDispString(dstBuf,buffer,src,len){           \
    if ((dstBuf)->asnType)			 \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_RFC1213_DISPSTRING); \
        (dstBuf)->asnValue.string.length = strlen(src);    \
        if ((dstBuf)->asnValue.string.length>len)          \
        {                                                  \
            (dstBuf)->asnValue.string.length = len;        \
            (dstBuf)->asnValue.string.stream = (BYTE *)strncpy (buffer,src,\
                                                            (dstBuf)->asnValue.string.length);\
            (dstBuf)->asnValue.string.dynamic = FALSE;     \
        }                                                  \
    }                                                      \
}

#define SetToZeroOid(dstBuf,buffer){                       \
    if ((dstBuf)->asnType)			 \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OBJECTIDENTIFIER);   \
        (dstBuf)->asnValue.object.idLength = NULL_OID_LEN; \
        (dstBuf)->asnValue.object.ids = buffer;            \
        (dstBuf)->asnValue.object.ids[0]   = 0;            \
        (dstBuf)->asnValue.object.ids[1]   = 0;            \
    }                                                      \
}

#define GetAsnInteger(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.number):(defVal))

#define GetAsnCounter(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.counter):(defVal))

#define GetAsnTimeTicks(srcBuf, defval) \
    ( ( (srcBuf)-> asnType ) ? (srcBuf)-> asnValue.ticks : (defval) )

#define GetAsnOctetString(dst,srcBuf)                                                   \
    (((srcBuf)->asnType)?		                                                        \
     (memcpy(dst,(srcBuf)->asnValue.string.stream,(srcBuf)->asnValue.string.length))    \
     :NULL)	

#define GetAsnIPAddress(srcBuf,defVal)                                  \
    (DWORD)(((srcBuf)->asnType && (srcBuf)->asnValue.string.length)?    \
            (*(DWORD*)((srcBuf)->asnValue.address.stream)) : (defVal))	

                
#define IsAsnTypeNull(asnObj) (!((asnObj)->asnType))
#define IsAsnIPAddressTypeNull(asnObj) (!((asnObj)->asnType && (asnObj)->asnValue.address.length))



//------------------------------------------------------------------------------
// IP address / port comparison macros
//------------------------------------------------------------------------------

//
// LONG
// Cmp(DWORD dwFirst, DWORD dwSecond, LONG lResult)
//

#define Cmp(dwFirst,dwSecond,lResult) ((LONG)((lResult) = ((dwFirst) - (dwSecond))))

//
// LONG
// PortCmp(DWORD wPort1, DWORD wPort2, LONG lResult)
//

#define PortCmp(dwPort1, dwPort2,lResult) ((LONG)((lResult) = ((ntohs((WORD)dwPort1)) - (ntohs((WORD)dwPort2)))))

// The addresses are in Network order

//
// LONG
// InetCmp(DWORD IpAddr1, DWORD IpAddr2, LONG lResult)
//

#define InetCmp(dwIpAddr1,dwIpAddr2,res)                                                    \
    ((LONG)(((res) = (((dwIpAddr1) & 0x000000ff) - ((dwIpAddr2) & 0x000000ff))) ? (res)   : \
            (((res) = (((dwIpAddr1) & 0x0000ff00) - ((dwIpAddr2) & 0x0000ff00))) ? (res)  : \
             (((res) = (((dwIpAddr1) & 0x00ff0000) - ((dwIpAddr2) & 0x00ff0000))) ? (res) : \
              (((dwIpAddr1) & 0xff000000) - ((dwIpAddr2) & 0xff000000))))))                  


//------------------------------------------------------------------------------
// Debug tracing macros
//------------------------------------------------------------------------------

#ifdef MIB_DEBUG
#define TRACE0(Z)             TracePrintf(g_dwTraceId,Z)
#define TRACE1(Y,Z)           TracePrintf(g_dwTraceId,Y,Z)
#define TRACE2(X,Y,Z)         TracePrintf(g_dwTraceId,X,Y,Z)
#define TRACE3(W,X,Y,Z)       TracePrintf(g_dwTraceId,W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)     TracePrintf(g_dwTraceId,V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)   TracePrintf(g_dwTraceId,U,W,X,Y,Z)

#define TRACEW0(Z)            TracePrintfW(g_dwTraceId,Z)

#define TraceEnter(X)         TracePrintf(g_dwTraceId,"Entering " X)
#define TraceLeave(X)         TracePrintf(g_dwTraceId,"Leaving " X "\n")

#define TraceError(X) \
    TracePrintf( g_dwTraceId, "MprAdminMIB API returned : %d", (X) ); 

#define TraceError1(x)                              \
{                                                   \
    LPWSTR  __lpwszErr = NULL;                      \
                                                    \
    TRACE1( "MprAdminMIB API returned : %d", (x) ); \
    MprAdminGetErrorString( (x), &__lpwszErr );     \
                                                    \
    if ( __lpwszErr )                               \
    {                                               \
        TRACEW0( __lpwszErr );                      \
        LocalFree( __lpwszErr );                    \
    }                                               \
}                                               

#else
#define TRACE0(Z)
#define TRACE1(Y,Z)  
#define TRACE2(X,Y,Z)
#define TRACE3(W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)
#define TRACEW0(Z)            
#define TraceEnter(X) 
#define TraceLeave(X)
#define TraceError(x)
#endif


#define EnterReader(X)
#define ReleaseLock(X)
#define ReaderToWriter(X)
#define EnterWriter(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\btpagnt\load.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    testdll.c

Abstract:

    Sample SNMP subagent.

--*/

#include "precomp.h"
#pragma hdrstop

#if defined( MIB_DEBUG )

DWORD               g_dwTraceId     = INVALID_TRACEID;

#endif

MIB_SERVER_HANDLE   g_hMIBServer    = ( MIB_SERVER_HANDLE) NULL;

//
// Critical Section to control access to variable g_hMIBServer
// 

CRITICAL_SECTION    g_CS;


// Extension Agent DLLs need access to elapsed time agent has been active.
// This is implemented by initializing the Extension Agent with a time zero
// reference, and allowing the agent to compute elapsed time by subtracting
// the time zero reference from the current system time.  

DWORD g_uptimeReference = 0;

//
// Handle to Subagent Framework 
//

SnmpTfxHandle g_tfxHandle;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Subagent entry points                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL 
SnmpExtensionInit(
    IN     DWORD                 uptimeReference,
       OUT HANDLE *              lpPollForTrapEvent,
       OUT AsnObjectIdentifier * lpFirstSupportedView
    )
{
    DWORD       dwRes   = (DWORD) -1;


#if defined( MIB_DEBUG )

    //
    // tracing for DEBUG
    //
    
    g_dwTraceId = TraceRegister( "BOOTP Subagent" );
#endif


    // save uptime reference
    g_uptimeReference = uptimeReference;

    // obtain handle to subagent framework
    g_tfxHandle = SnmpTfxOpen(1,&v_msipbootp);

    // validate handle
    if (g_tfxHandle == NULL) {
        return FALSE;
    }

    // pass back first view identifier to master
    *lpFirstSupportedView = v_msipbootp.viewOid;

    // traps not supported yet
    *lpPollForTrapEvent = NULL;


    //
    // Verify router service is running
    //

    if ( !MprAdminIsServiceRunning( NULL ) )
    {   
        return TRUE;
    }

    //
    // Connect to router
    //
            
    dwRes = MprAdminMIBServerConnect(
                NULL,
                &g_hMIBServer
            );

    if ( dwRes != NO_ERROR )
    {
        return FALSE;
    }

    return TRUE;    
}


BOOL 
SnmpExtensionQuery(
    IN     BYTE                 requestType,
    IN OUT RFC1157VarBindList * variableBindings,
       OUT AsnInteger *         errorStatus,
       OUT AsnInteger *         errorIndex
    )
{
    // forward to framework
    return SnmpTfxQuery(
                g_tfxHandle,
                requestType,
                variableBindings,
                errorStatus,
                errorIndex
                );
}


BOOL 
SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger *genericTrap,
    OUT AsnInteger *specificTrap,
    OUT AsnTimeticks *timeStamp,
    OUT RFC1157VarBindList *variableBindings
    )
{
    // no traps
    return FALSE;
}


BOOL WINAPI
DllMain(
    HINSTANCE       hInstDLL,
    DWORD           fdwReason,
    LPVOID          pReserved
)
{
 
    switch ( fdwReason )
    {
        case DLL_PROCESS_ATTACH :
        {
            DisableThreadLibraryCalls( hInstDLL );


            InitializeCriticalSection( &g_CS );
            

            break;
        }
        
        case DLL_PROCESS_DETACH :
        {
            //
            // Disconnect from router
            //

            if ( g_hMIBServer )
            {
                MprAdminMIBServerDisconnect( g_hMIBServer );
            }

            DeleteCriticalSection( &g_CS );
            
#if defined( MIB_DEBUG )

            if ( g_dwTraceId != INVALID_TRACEID )
            {
                TraceDeregister( g_dwTraceId );
            }
#endif              

            break;
         }
         
         default :
         {
            break;
         }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\bootp\sync.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    sync.c
//
// History:
//  Abolade Gbadegesin  Jan-12-1996     Created.
//
// Synchronization routines used by IPBOOTP.
//============================================================================


#include "pchbootp.h"




//----------------------------------------------------------------------------
// Function:    QueueBootpWorker  
//
// This function is called to queue a BOOTP function in a safe fashion;
// if cleanup is in progress or if RIP has stopped, this function
// discards the work-item.
//----------------------------------------------------------------------------

DWORD
QueueBootpWorker(
    WORKERFUNCTION pFunction,
    PVOID pContext
    ) {

    DWORD dwErr = NO_ERROR;

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status != IPBOOTP_STATUS_RUNNING) {

        //
        // cannot queue a work function when RIP has quit or is quitting
        //

        dwErr = ERROR_CAN_NOT_COMPLETE;
    }
    else {

        BOOL bSuccess;
        
        ++ig.IG_ActivityCount;

        bSuccess = QueueUserWorkItem(
                       (LPTHREAD_START_ROUTINE)pFunction,
                        pContext, 0
                        );

        if (!bSuccess) {
            dwErr = GetLastError();
            --ig.IG_ActivityCount;
        }
    }

    LeaveCriticalSection(&ig.IG_CS);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    EnterBootpAPI
//
// This function is called to when entering a BOOTP api, as well as
// when entering the input thread and timer thread.
// It checks to see if BOOTP has stopped, and if so it quits; otherwise
// it increments the count of active threads.
//----------------------------------------------------------------------------

BOOL
EnterBootpAPI(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status == IPBOOTP_STATUS_RUNNING) {

        //
        // BOOTP is running, so the API may continue
        //

        ++ig.IG_ActivityCount;

        bEntered = TRUE;
    }
    else {

        //
        // BOOTP is not running, so the API exits quietly
        //

        bEntered = FALSE;
    }

    LeaveCriticalSection(&ig.IG_CS);

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    EnterBootpWorker
//
// This function is called when entering a BOOTP worker-function.
// Since there is a lapse between the time a worker-function is queued
// and the time the function is actually invoked by a worker thread,
// this function must check to see if BOOTP has stopped or is stopping;
// if this is the case, then it decrements the activity count, 
// releases the activity semaphore, and quits.
//----------------------------------------------------------------------------

BOOL
EnterBootpWorker(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&ig.IG_CS);

    if (ig.IG_Status == IPBOOTP_STATUS_RUNNING) {

        //
        // BOOTP is running, so the function may continue
        //

        bEntered = TRUE;
    }
    else
    if (ig.IG_Status == IPBOOTP_STATUS_STOPPING) {

        //
        // BOOTP is not running, but it was, so the function must stop.
        // 

        --ig.IG_ActivityCount;

        ReleaseSemaphore(ig.IG_ActivitySemaphore, 1, NULL);

        bEntered = FALSE;
    }
    else {

        //
        // BOOTP probably never started. quit quietly
        //

        bEntered = FALSE;
    }

    LeaveCriticalSection(&ig.IG_CS);

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    LeaveBootpWorker
//
// This function is called when leaving a BOOTP API or worker function.
// It decrements the activity count, and if it detects that BOOTP has stopped
// or is stopping, it releases the activity semaphore.
//----------------------------------------------------------------------------

VOID
LeaveBootpWorker(
    ) {

    EnterCriticalSection(&ig.IG_CS);

    --ig.IG_ActivityCount;

    if (ig.IG_Status == IPBOOTP_STATUS_STOPPING) {

        ReleaseSemaphore(ig.IG_ActivitySemaphore, 1, NULL);
    }

    LeaveCriticalSection(&ig.IG_CS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\btpagnt\mibfuncs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibfuncs.h

Abstract:

    Sample subagent instrumentation callbacks.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#ifndef _MIBFUNCS_H_
#define _MIBFUNCS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group (1.3.6.1.4.1.311.1.12.1)                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_global {
    AsnAny globalLoggingLevel;
    AsnAny globalMaxRecQueueSize;
    AsnAny globalServerCount;
} buf_global;

typedef struct _sav_global {
    AsnAny globalLoggingLevel;
    AsnAny globalMaxRecQueueSize;
} sav_global;

#define gf_globalLoggingLevel                   get_global
#define gf_globalMaxRecQueueSize                get_global
#define gf_globalServerCount                    get_global

#define gb_globalLoggingLevel                   buf_global
#define gb_globalMaxRecQueueSize                buf_global
#define gb_globalServerCount                    buf_global

#define sf_globalLoggingLevel                   set_global
#define sf_globalMaxRecQueueSize                set_global

#define sb_globalLoggingLevel                   sav_global
#define sb_globalMaxRecQueueSize                sav_global

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalBOOTPServerEntry table (1.3.6.1.4.1.311.1.12.1.4.1)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_globalBOOTPServerEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_globalBOOTPServerEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_globalBOOTPServerEntry {
    AsnAny globalBOOTPServerAddr;
    AsnAny globalBOOTPServerTag; 
    DWORD  dwServerAddr;
} buf_globalBOOTPServerEntry;

typedef struct _sav_globalBOOTPServerEntry {
    AsnAny globalBOOTPServerAddr;
    AsnAny globalBOOTPServerTag; 
} sav_globalBOOTPServerEntry;

#define gf_globalBOOTPServerAddr                get_globalBOOTPServerEntry
#define gf_globalBOOTPServerTag                 get_globalBOOTPServerEntry

#define gb_globalBOOTPServerAddr                buf_globalBOOTPServerEntry
#define gb_globalBOOTPServerTag                 buf_globalBOOTPServerEntry

#define sf_globalBOOTPServerAddr                set_globalBOOTPServerEntry
#define sf_globalBOOTPServerTag                 set_globalBOOTPServerEntry

#define sb_globalBOOTPServerAddr                sav_globalBOOTPServerEntry
#define sb_globalBOOTPServerTag                 sav_globalBOOTPServerEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// interface group (1.3.6.1.4.1.311.1.12.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.12.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifStatsEntry {
    AsnAny ifSEIndex;
    AsnAny ifSEState;
    AsnAny ifSESendFailures;
    AsnAny ifSEReceiveFailures;
    AsnAny ifSEArpUpdateFailures;
    AsnAny ifSERequestReceiveds;
    AsnAny ifSERequestDiscards;
    AsnAny ifSEReplyReceiveds;
    AsnAny ifSEReplyDiscards;
} buf_ifStatsEntry;

#define gf_ifSEIndex                        get_ifStatsEntry
#define gf_ifSEState                        get_ifStatsEntry
#define gf_ifSESendFailures                 get_ifStatsEntry
#define gf_ifSEReceiveFailures              get_ifStatsEntry
#define gf_ifSEArpUpdateFailures            get_ifStatsEntry
#define gf_ifSERequestReceiveds             get_ifStatsEntry
#define gf_ifSERequestDiscards              get_ifStatsEntry
#define gf_ifSEReplyReceiveds               get_ifStatsEntry
#define gf_ifSEReplyDiscards                get_ifStatsEntry

#define gb_ifSEIndex                        buf_ifStatsEntry
#define gb_ifSEState                        buf_ifStatsEntry
#define gb_ifSESendFailures                 buf_ifStatsEntry
#define gb_ifSEReceiveFailures              buf_ifStatsEntry
#define gb_ifSEArpUpdateFailures            buf_ifStatsEntry
#define gb_ifSERequestReceiveds             buf_ifStatsEntry
#define gb_ifSERequestDiscards              buf_ifStatsEntry
#define gb_ifSEReplyReceiveds               buf_ifStatsEntry
#define gb_ifSEReplyDiscards                buf_ifStatsEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.12.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
UINT
get_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifConfigEntry {
    AsnAny ifCEIndex;            
    AsnAny ifCEState;            
    AsnAny ifCERelayMode;        
    AsnAny ifCEMaxHopCount;      
    AsnAny ifCEMinSecondsSinceBoot;
} buf_ifConfigEntry;

typedef struct _sav_ifConfigEntry {
    AsnAny ifCEIndex;
    AsnAny ifCERelayMode;        
    AsnAny ifCEMaxHopCount;      
    AsnAny ifCEMinSecondsSinceBoot;
} sav_ifConfigEntry;
                                                  
#define gf_ifCEIndex                        get_ifConfigEntry
#define gf_ifCEState                        get_ifConfigEntry
#define gf_ifCERelayMode                    get_ifConfigEntry
#define gf_ifCEMaxHopCount                  get_ifConfigEntry
#define gf_ifCEMinSecondsSinceBoot          get_ifConfigEntry

#define gb_ifCEIndex                        buf_ifConfigEntry
#define gb_ifCEState                        buf_ifConfigEntry
#define gb_ifCERelayMode                    buf_ifConfigEntry
#define gb_ifCEMaxHopCount                  buf_ifConfigEntry
#define gb_ifCEMinSecondsSinceBoot          buf_ifConfigEntry

#define sf_ifCERelayMode                    set_ifConfigEntry
#define sf_ifCEMaxHopCount                  set_ifConfigEntry
#define sf_ifCEMinSecondsSinceBoot          set_ifConfigEntry

#define sb_ifCERelayMode                    sav_ifConfigEntry
#define sb_ifCEMaxHopCount                  sav_ifConfigEntry
#define sb_ifCEMinSecondsSinceBoot          sav_ifConfigEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.12.2.3.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
UINT
get_ifBindingEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifBindingEntry {
    AsnAny ifBindingIndex;    
    AsnAny ifBindingState;    
    AsnAny ifBindingAddrCount;
} buf_ifBindingEntry;

#define gf_ifBindingIndex                      get_ifBindingEntry
#define gf_ifBindingState                      get_ifBindingEntry
#define gf_ifBindingAddrCount                  get_ifBindingEntry

#define gb_ifBindingIndex                      buf_ifBindingEntry
#define gb_ifBindingState                      buf_ifBindingEntry
#define gb_ifBindingAddrCount                  buf_ifBindingEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.12.2.4.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
UINT
get_ifAddressEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ifAddressEntry {
    AsnAny ifAEIfIndex;
    AsnAny ifAEAddress;
    AsnAny ifAEMask;   
    DWORD  dwIfAEAddr;
    DWORD  dwIfAEMask;
} buf_ifAddressEntry;

#define gf_ifAEIfIndex          get_ifAddressEntry
#define gf_ifAEAddress          get_ifAddressEntry
#define gf_ifAEMask             get_ifAddressEntry

#define gb_ifAEIfIndex          buf_ifAddressEntry
#define gb_ifAEAddress          buf_ifAddressEntry
#define gb_ifAEMask             buf_ifAddressEntry

#endif // _MIBFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\btpagnt\precomp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
        precomp.h

Abstract:
        Precompiled header for the RIP-2 subagent 

Author:
        V Raman ( vraman )

Revision History:

        V Raman Aug-1-1996  Created

--*/

#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <TCHAR.H>
#include <winsock.h>
#include <snmp.h>
#include <snmpexts.h>
#include <mprapi.h>
#include <routprot.h>
#include <ipbootp.h>

#if defined( MIB_DEBUG )

#include <rtutils.h>
extern DWORD   g_dwTraceId;

#endif

#include "mibentry.h"
#include "mibfuncs.h"
#include "defs.h"

extern      MIB_SERVER_HANDLE       g_hMIBServer;
extern      CRITICAL_SECTION        g_CS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\btpagnt\mibentry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibentry.c

Abstract:

    Sample subagent mib structures.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#include <snmp.h>
#include <snmpexts.h>
#include "mibfuncs.h"
#include "mibentry.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_msipbootp[]                           = {1,3,6,1,4,1,311,1,12};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group (1.3.6.1.4.1.311.1.12.1)                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_global[]                              = {1,0};
static UINT ids_globalLoggingLevel[]                  = {1,1,0};
static UINT ids_globalMaxRecQueueSize[]               = {1,2,0};
static UINT ids_globalServerCount[]                   = {1,3,0};
static UINT ids_globalBOOTPServerTable[]              = {1,4,0};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalBOOTPServerEntry table (1.3.6.1.4.1.311.1.12.1.4.1)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_globalBOOTPServerEntry[]              = {1,4,1};  
static UINT ids_globalBOOTPServerAddr[]               = {1,4,1,1}; 
static UINT ids_globalBOOTPServerTag[]                = {1,4,1,2}; 

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// interface group (1.3.6.1.4.1.311.1.12.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_interface[]                           = {2,0};
static UINT ids_ifStatsTable[]                        = {2,1,0};
static UINT ids_ifConfigTable[]                       = {2,2,0};
static UINT ids_ifBindingTable[]                      = {2,3,0};  
static UINT ids_ifAddressTable[]                      = {2,4,0};  

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.12.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_ifStatsEntry[]                        = {2,1,1};
static UINT ids_ifSEIndex[]                           = {2,1,1,1};  
static UINT ids_ifSEState[]                           = {2,1,1,2};
static UINT ids_ifSESendFailures[]                    = {2,1,1,3};
static UINT ids_ifSEReceiveFailures[]                 = {2,1,1,4};
static UINT ids_ifSEArpUpdateFailures[]               = {2,1,1,5};
static UINT ids_ifSERequestReceiveds[]                = {2,1,1,6};
static UINT ids_ifSERequestDiscards[]                 = {2,1,1,7};
static UINT ids_ifSEReplyReceiveds[]                  = {2,1,1,8};
static UINT ids_ifSEReplyDiscards[]                   = {2,1,1,9};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.12.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
static UINT ids_ifConfigEntry[]                       = {2,2,1};
static UINT ids_ifCEIndex[]                           = {2,2,1,1};
static UINT ids_ifCEState[]                           = {2,2,1,2};
static UINT ids_ifCERelayMode[]                       = {2,2,1,3};
static UINT ids_ifCEMaxHopCount[]                     = {2,2,1,4};
static UINT ids_ifCEMinSecondsSinceBoot[]             = {2,2,1,5};
                                                      
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.12.2.3.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
static UINT ids_ifBindingEntry[]                      = {2,3,1};
static UINT ids_ifBindingIndex[]                      = {2,3,1,1};
static UINT ids_ifBindingState[]                      = {2,3,1,2};
static UINT ids_ifBindingAddrCount[]                  = {2,3,1,3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.12.2.4.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
static UINT ids_ifAddressEntry[]                      = {2,4,1};
static UINT ids_ifAEIfIndex[]                         = {2,4,1,1};
static UINT ids_ifAEAddress[]                         = {2,4,1,2};
static UINT ids_ifAEMask[]                            = {2,4,1,3};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_msipbootp[] = {
    MIB_GROUP(global),
        MIB_INTEGER_RW(globalLoggingLevel),
        MIB_INTEGER_RW(globalMaxRecQueueSize),
        MIB_INTEGER(globalServerCount),
        MIB_TABLE_ROOT(globalBOOTPServerTable), 
            MIB_TABLE_ENTRY(globalBOOTPServerEntry),
                MIB_IPADDRESS_RW(globalBOOTPServerAddr),
                MIB_INTEGER_RW(globalBOOTPServerTag),
    MIB_GROUP(interface),
        MIB_TABLE_ROOT(ifStatsTable), 
            MIB_TABLE_ENTRY(ifStatsEntry),
                MIB_INTEGER(ifSEIndex),
                MIB_INTEGER(ifSEState),
                MIB_COUNTER(ifSESendFailures),
                MIB_COUNTER(ifSEReceiveFailures),
                MIB_COUNTER(ifSEArpUpdateFailures),
                MIB_COUNTER(ifSERequestReceiveds),
                MIB_COUNTER(ifSERequestDiscards),
                MIB_COUNTER(ifSEReplyReceiveds),
                MIB_COUNTER(ifSEReplyDiscards),
        MIB_TABLE_ROOT(ifConfigTable), 
            MIB_TABLE_ENTRY(ifConfigEntry),
                MIB_INTEGER(ifCEIndex),
                MIB_INTEGER(ifCEState),
                MIB_INTEGER_RW(ifCERelayMode),
                MIB_INTEGER_RW_L(ifCEMaxHopCount,1,16),
                MIB_INTEGER_RW(ifCEMinSecondsSinceBoot),
        MIB_TABLE_ROOT(ifBindingTable), 
            MIB_TABLE_ENTRY(ifBindingEntry),
                MIB_INTEGER(ifBindingIndex),
                MIB_INTEGER(ifBindingState),
                MIB_INTEGER(ifBindingAddrCount),
        MIB_TABLE_ROOT(ifAddressTable), 
            MIB_TABLE_ENTRY(ifAddressEntry),
                MIB_INTEGER(ifAEIfIndex),
                MIB_IPADDRESS(ifAEAddress),
                MIB_IPADDRESS(ifAEMask),
    MIB_END()
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_msipbootp[] = {
    MIB_TABLE(msipbootp,globalBOOTPServerEntry,NULL),
    MIB_TABLE(msipbootp,ifStatsEntry,NULL),
    MIB_TABLE(msipbootp,ifConfigEntry,NULL),
    MIB_TABLE(msipbootp,ifBindingEntry,NULL),
    MIB_TABLE(msipbootp,ifAddressEntry,NULL)
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib view                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibView v_msipbootp = MIB_VIEW(msipbootp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\btpagnt\mibentry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibentry.h

Abstract:

    Sample subagent mib structures.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#ifndef _MIBENTRY_H_
#define _MIBENTRY_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry indices                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define mi_global                           0
#define mi_globalLoggingLevel               mi_global+1                 
#define mi_globalMaxRecQueueSize            mi_globalLoggingLevel+1 
#define mi_globalServerCount                mi_globalMaxRecQueueSize+1 
#define mi_globalBOOTPServerTable           mi_globalServerCount+1 
#define mi_globalBOOTPServerEntry           mi_globalBOOTPServerTable+1  
#define mi_globalBOOTPServerAddr            mi_globalBOOTPServerEntry+1 
#define mi_globalBOOTPServerTag             mi_globalBOOTPServerAddr+1 
#define mi_interface                        mi_globalBOOTPServerTag+1 
#define mi_ifStatsTable                     mi_interface+1 
#define mi_ifStatsEntry                     mi_ifStatsTable+1  
#define mi_ifSEIndex                        mi_ifStatsEntry+1 
#define mi_ifSEState                        mi_ifSEIndex+1 
#define mi_ifSESendFailures                 mi_ifSEState+1 
#define mi_ifSEReceiveFailures              mi_ifSESendFailures+1 
#define mi_ifSEArpUpdateFailures            mi_ifSEReceiveFailures+1 
#define mi_ifSERequestReceiveds             mi_ifSEArpUpdateFailures+1 
#define mi_ifSERequestDiscards              mi_ifSERequestReceiveds+1 
#define mi_ifSEReplyReceiveds               mi_ifSERequestDiscards+1 
#define mi_ifSEReplyDiscards                mi_ifSEReplyReceiveds+1 
#define mi_ifConfigTable                    mi_ifSEReplyDiscards+1 
#define mi_ifConfigEntry                    mi_ifConfigTable+1  
#define mi_ifCEIndex                        mi_ifConfigEntry+1 
#define mi_ifCEState                        mi_ifCEIndex+1 
#define mi_ifCERelayMode                    mi_ifCEState+1 
#define mi_ifCEMaxHopCount                  mi_ifCERelayMode+1 
#define mi_ifCEMinSecondsSinceBoot          mi_ifCEMaxHopCount+1 
#define mi_ifBindingTable                   mi_ifCEMinSecondsSinceBoot+1 
#define mi_ifBindingEntry                   mi_ifBindingTable+1  
#define mi_ifBindingIndex                   mi_ifBindingEntry+1 
#define mi_ifBindingState                   mi_ifBindingIndex+1 
#define mi_ifBindingAddrCount               mi_ifBindingState+1 
#define mi_ifAddressTable                   mi_ifBindingAddrCount+1 
#define mi_ifAddressEntry                   mi_ifAddressTable+1  
#define mi_ifAEIfIndex                      mi_ifAddressEntry+1 
#define mi_ifAEAddress                      mi_ifAEIfIndex+1 
#define mi_ifAEMask                         mi_ifAEAddress+1 
                                            
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalBOOTPServerEntry table (1.3.6.1.4.1.311.1.12.1.4.1)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_globalBOOTPServerEntry           2
#define ni_globalBOOTPServerEntry           1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.12.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifStatsEntry                     9
#define ni_ifStatsEntry                     1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.12.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
#define ne_ifConfigEntry                    5
#define ni_ifConfigEntry                    1
                                                      
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.12.2.3.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
#define ne_ifBindingEntry                   3
#define ni_ifBindingEntry                   1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.12.2.4.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_ifAddressEntry                   3
#define ni_ifAddressEntry                   3

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Other definitions                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
                             
#define d_globalLoggingLevel_none               1
#define d_globalLoggingLevel_error              2
#define d_globalLoggingLevel_warning            3    
#define d_globalLoggingLevel_information        4
#define d_globalBOOTPServerTag_create           1
#define d_globalBOOTPServerTag_delete           2
#define d_ifSEState_enabled                     1
#define d_ifSEState_bound                       2
#define d_ifCEState_enabled                     1
#define d_ifCEState_bound                       2
#define d_ifCERelayMode_disabled                1
#define d_ifCERelayMode_enabled                 2
#define d_ifBindingState_enabled                1
#define d_ifBindingState_bound                  2

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Declaration of supported view                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern SnmpMibView v_msipbootp; 

#endif // _MIBENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\btpagnt\mibfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibfuncs.c

Abstract:

    Sample subagent instrumentation callbacks.

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
ConnectToRouter();

DWORD
UpdateGlobalInfo(
    IN  AsnAny *                        objectArray
);


DWORD
GetGlobalConfigInfo(
    OUT PIPBOOTP_MIB_GET_OUTPUT_DATA *  ppimgod,
    OUT PDWORD                          pdwSize
);

DWORD
UpdateBOOTPServerTable(
    IN  sav_globalBOOTPServerEntry *    psgbse
);

DWORD
AddBOOTPServerEntry(
    IN  DWORD                           dwServerAddr,
    IN  PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData
);

DWORD
DeleteBOOTPServerEntry(
    IN  DWORD                           dwIndex,
    IN  PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData
);

DWORD
GetInterfaceInfo( 
    IN  UINT                            actionId,
    IN  PIPBOOTP_MIB_GET_INPUT_DATA     pimgidInData,
    OUT PIPBOOTP_MIB_GET_OUTPUT_DATA*   ppimgod,
    OUT PDWORD                          pdwOutSize
);


DWORD
ValidateInterfaceConfig(
    IN  AsnAny *        objectArray
);


DWORD
SetInterfaceConfig(
    IN  AsnAny *    objectArray
);


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group (1.3.6.1.4.1.311.1.12.1)                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes               = (DWORD) -1,
                                    dwConfigSize        = 0;
    
    buf_global*                     pbgBuffer           = NULL;

    PIPBOOTP_GLOBAL_CONFIG          pigcGlbConfig       = NULL;
    
    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodConfigData    = NULL;

    IPBOOTP_MIB_GET_INPUT_DATA      imgidInData;
    
    
    
    TraceEnter( "get_global" );

    switch ( actionId )
    {
    case MIB_ACTION_GET:
    case MIB_ACTION_GETFIRST:

        //
        // Retrieve global config.
        //

        imgidInData.IMGID_TypeID = IPBOOTP_GLOBAL_CONFIG_ID;
        
        BOOTP_MIB_GET(
            &imgidInData,
            sizeof( IPBOOTP_MIB_GET_INPUT_DATA ),
            &pimgodConfigData,
            &dwConfigSize,
            dwRes
        );
                
        break;
    
    case MIB_ACTION_GETNEXT:
    default:
    
            TRACE1( "Wrong Action", actionId );
            
            return MIB_S_INVALID_PARAMETER;
    }

    //
    // if error print error message and free allocations
    //

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );

        if ( pimgodConfigData ) { MprAdminMIBBufferFree ( pimgodConfigData ); }

        return dwRes;
    }

    
    //
    // Set the return data.
    //

    pbgBuffer       = (buf_global*) objectArray;

    //
    // Global config Data
    //
    
    pigcGlbConfig   = (PIPBOOTP_GLOBAL_CONFIG) pimgodConfigData-> IMGOD_Buffer;
    
    SetAsnInteger(
        &( pbgBuffer-> globalMaxRecQueueSize ),
        pigcGlbConfig-> GC_MaxRecvQueueSize 
    );

    SetAsnInteger(
        &( pbgBuffer-> globalServerCount ),
        pigcGlbConfig-> GC_ServerCount
    );

    //
    // +1 added to adjust value to enumeration values in asn.
    // Enumeration in asn cannot have a value of 0. Causes a warning
    // to be generated by the asn compiler.
    //
    
    SetAsnInteger( 
        &(pbgBuffer-> globalLoggingLevel),
        pigcGlbConfig-> GC_LoggingLevel + 1
    );


    if ( pimgodConfigData ) { MprAdminMIBBufferFree ( pimgodConfigData ); }

    TraceLeave( "get_global" );

    return MIB_S_SUCCESS;
}


UINT
set_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes           = MIB_S_SUCCESS,
                                    dwLogLevel      = 0;
    
    sav_global*                     psgBuffer       = NULL; 

    
    TraceEnter( "set_global" );

    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :

        psgBuffer = (sav_global *) objectArray;

        //
        // verify log level setting
        //
        
        dwLogLevel = GetAsnInteger( &( psgBuffer-> globalLoggingLevel ), 0 );

        if ( dwLogLevel < d_globalLoggingLevel_none ||
             dwLogLevel > d_globalLoggingLevel_information )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE1( "Invalid logging level value : %d", dwLogLevel );
        }

        break;

    case MIB_ACTION_SET :

        dwRes = UpdateGlobalInfo( objectArray );
        
        break;

    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE1( "Invalid action specified : %d", actionId );
        
        break;
    }

    TraceEnter( "set_global" );

    return dwRes;
    
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// globalBOOTPServerEntry table (1.3.6.1.4.1.311.1.12.1.4.1)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_globalBOOTPServerEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwCurrentAddr = INADDR_NONE,
                                    dwIndex     = 0,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    PDWORD                          pdwAddrTable= NULL;
    
    buf_globalBOOTPServerEntry *    pbgbse      = NULL;

    PIPBOOTP_GLOBAL_CONFIG          pigc        = NULL;
    
    PIPBOOTP_MIB_SET_INPUT_DATA     pimsidInData= NULL;

    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData = NULL;
    
    IPBOOTP_MIB_GET_INPUT_DATA      imgidInData;


    
    TraceEnter( "get_globalBOOTPServerEntry" );
    
    pbgbse = (buf_globalBOOTPServerEntry *) objectArray;
    
    
    //
    // retrive the BOOTP server table
    //

    imgidInData.IMGID_TypeID = IPBOOTP_GLOBAL_CONFIG_ID;
    
    BOOTP_MIB_GET(
        &imgidInData,
        sizeof( IPBOOTP_MIB_GET_INPUT_DATA ),
        &pimgodOutData,
        &dwGetSize,
        dwRes
    );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    pigc = (PIPBOOTP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

    if ( !pigc-> GC_ServerCount )
    {
        TRACE0( "No BOOTP Server Entries" );
        return MIB_S_NO_MORE_ENTRIES;
    }
    
    pdwAddrTable = IPBOOTP_GLOBAL_SERVER_TABLE( pigc );

    
    //
    // Locate current entry in global server table
    //

    dwCurrentAddr = GetAsnIPAddress( &( pbgbse-> globalBOOTPServerAddr ), 0 );

    FIND_SERVER_ENTRY( 
        dwCurrentAddr, 
        pigc-> GC_ServerCount, 
        pdwAddrTable,
        dwIndex
    );
    

    //
    // get requested entry
    //
    
    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    
    case MIB_ACTION_GET :

        //
        // This is an idempotent case, since retieving a server address
        // requires the server address as index.
        // It is only useful to verify the presence of a particular server.
        // 
        
        if ( dwIndex >= pigc-> GC_ServerCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0(  "BOOTP Server Entry not found" );
        }

        break;

    case MIB_ACTION_GETFIRST :

        //
        // get entry at index 0 (if available )
        //
        
        dwIndex = 0;
        
        if ( !pigc-> GC_ServerCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "BOOTP Server Entry not found" );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        //
        // check if entry was found.
        // dwCurrentAddr == 0 is taken to mean that the next server entry
        // starting from the beginning of the table is requested.
        //
        
        if ( ( dwIndex >= pigc-> GC_ServerCount ) && 
             ( dwCurrentAddr != 0 ) )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "BOOTP Server Entry not found" );
            break;
        }
        
        //
        // try and get next
        //
        
        dwIndex = ( dwCurrentAddr ) ? dwIndex++ : 0;

        TRACE3( "GET_NEXT : Current addr : %x, server index : %d, Server count : %d", dwCurrentAddr, dwIndex, pigc-> GC_ServerCount );
        
        if ( dwIndex >= pigc-> GC_ServerCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;
            TRACE0( "No more BOOTP Server Entries" );
            break;
        }

        break;

    default :

        TRACE0( " get_globalServerEntry - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;

        break;
    }


    //
    // set index for next retrieval
    //
    
    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnIPAddress( 
            &( pbgbse-> globalBOOTPServerAddr ),
            &( pbgbse-> dwServerAddr ),
            pdwAddrTable[ dwIndex ]
        );
    }
    
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( "get_globalBOOTPServerCount" );

    return dwRes;

}


UINT
set_globalBOOTPServerEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes   = (DWORD) -1,
                                    dwAddr  = INADDR_NONE,
                                    dwOp    = 0;
    
    sav_globalBOOTPServerEntry *    psgbse  = NULL;


    TraceEnter( "set_globalBOOTPServerEntry" );

    psgbse = (sav_globalBOOTPServerEntry *) objectArray;
    

    switch ( actionId )
    {
    case MIB_ACTION_VALIDATE :
    
        //
        // Verify if the specified IP address is valid.
        //

        dwAddr = GetAsnIPAddress( 
                    &( psgbse-> globalBOOTPServerAddr ), 
                    INADDR_NONE 
                 );

        if ( !dwAddr || dwAddr == INADDR_NONE )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Server address specified" );
        }

        //
        // Verify operation tag
        //

        dwRes = GetAsnInteger( &( psgbse-> globalBOOTPServerTag ), 0 );

        if ( dwRes != d_globalBOOTPServerTag_create && 
             dwRes != d_globalBOOTPServerTag_delete )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
            TRACE0( " Invalid Operation specified" );
            break;
        }
        
        dwRes = MIB_S_SUCCESS;
        
        break;

        
    case MIB_ACTION_SET :

        dwRes = UpdateBOOTPServerTable( psgbse );
        
        break;


    case MIB_ACTION_CLEANUP :

        dwRes = MIB_S_SUCCESS;
        
        break;

    default :
        dwRes = MIB_S_INVALID_PARAMETER;
        
        TRACE0 ( " set_globalBOOTPServerEntry - Wrong Action " );
        
        break;
    }

    TraceLeave( " set_globalBOOTPServerEntry " );
    
    return dwRes;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// interface group (1.3.6.1.4.1.311.1.12.2)                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifStatsEntry table (1.3.6.1.4.1.311.1.12.2.1.1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ifStatsEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    buf_ifStatsEntry *              pbifse      = NULL;

    PIPBOOTP_IF_STATS               piis        = NULL;

    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData = NULL;
    
    IPBOOTP_MIB_GET_INPUT_DATA      imgidInData;


    TraceEnter( "get_ifStatsEntry" );
    
    //
    // Retrieve Specified interface info.
    //

    pbifse                      = (buf_ifStatsEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPBOOTP_IF_STATS_ID;

    imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                    &( pbifse-> ifSEIndex ), 
                                    0
                                  );

    //
    // When walking the mib using a sequence of getnext operations
    // the first getnext operation is translated into a getfirst
    // operation.
    //
 
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
   dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );
            
    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }


    //
    // Set interface stats in return buffer
    //

    piis = (PIPBOOTP_IF_STATS) (pimgodOutData-> IMGOD_Buffer);

    SetAsnInteger( &( pbifse-> ifSEState ), piis-> IS_State );

    SetAsnCounter( &( pbifse-> ifSESendFailures ), piis-> IS_SendFailures );
    
    SetAsnCounter( 
        &( pbifse-> ifSEReceiveFailures ), 
        piis-> IS_ReceiveFailures 
    );

    SetAsnCounter( 
        &( pbifse-> ifSEArpUpdateFailures ),
        piis-> IS_ArpUpdateFailures 
    );

    SetAsnCounter( 
        &( pbifse-> ifSERequestReceiveds ), 
        piis-> IS_RequestsReceived 
    );

    SetAsnCounter( 
        &( pbifse-> ifSERequestDiscards ), 
        piis-> IS_RequestsDiscarded 
    );

    SetAsnCounter( 
        &( pbifse-> ifSEReplyReceiveds ), 
        piis-> IS_RepliesReceived 
    );

    SetAsnCounter( 
        &( pbifse-> ifSEReplyDiscards ), 
        piis-> IS_RepliesDiscarded
    );

    //
    // set index for following getnext operation, (if any)
    //
    
    ForceSetAsnInteger( 
        &( pbifse-> ifSEIndex ), 
        pimgodOutData-> IMGOD_IfIndex
    );
    

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    TraceLeave( "get_ifStatsEntry" );
    
    return MIB_S_SUCCESS ;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifConfigEntry table (1.3.6.1.4.1.311.1.12.2.2.1)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
UINT
get_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifConfigEntry*              pbifce      = NULL;

    PIPBOOTP_IF_CONFIG              piic        = NULL;

    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData = NULL;
    
    IPBOOTP_MIB_GET_INPUT_DATA      imgidInData;



    TraceEnter( " get_ifConfigEntry " );

    //
    // retrieve interface config.
    //
    
    pbifce                      = (buf_ifConfigEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPBOOTP_IF_CONFIG_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( &( pbifce-> ifCEIndex ), 0 );
                                    
    //
    // When walking the mib using a sequence of getnext operations
    // the first getnext operation is translated into a getfirst
    // operation.
    //
 
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR || pimgodOutData == NULL )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // set requiste fields
    //
    
    piic = (PIPBOOTP_IF_CONFIG) (pimgodOutData-> IMGOD_Buffer);
    
    SetAsnInteger( &( pbifce-> ifCEState ), piic-> IC_State );

    SetAsnInteger( &( pbifce-> ifCERelayMode ), piic-> IC_RelayMode + 1 );

    SetAsnInteger( &( pbifce-> ifCEMaxHopCount ), piic-> IC_MaxHopCount );

    SetAsnInteger( 
        &( pbifce-> ifCEMinSecondsSinceBoot ), 
        piic-> IC_MinSecondsSinceBoot 
    );

    //
    // set index for following getnext operation, (if any)
    //
    
    ForceSetAsnInteger( 
        &( pbifce-> ifCEIndex ), 
        pimgodOutData-> IMGOD_IfIndex
    );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifConfigEntry " );

    return MIB_S_SUCCESS;
}



UINT
set_ifConfigEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD           dwRes       = (DWORD) -1;


    TraceEnter( " set_ifConfigEntry " );

    switch ( actionId )
    {
    
    case MIB_ACTION_VALIDATE :
    
        dwRes = ValidateInterfaceConfig( objectArray );
        
        break;


    case MIB_ACTION_SET :

        dwRes = SetInterfaceConfig( objectArray );
        
        break;


    case MIB_ACTION_CLEANUP :
    
        dwRes = MIB_S_SUCCESS;
        
        break;


    default :
    
        TRACE0( " set_ifConfigEntry - wrong action " );

        dwRes = MIB_S_INVALID_PARAMETER;

        break;
    }

    
    TraceLeave( "set_ifConfigEntry" );

    return dwRes ;

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifBindingEntry table (1.3.6.1.4.1.311.1.12.2.3.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
UINT
get_ifBindingEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifBindingEntry *            pbifb       = NULL;

    PIPBOOTP_IF_BINDING             piib        = NULL;

    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData = NULL;
    
    IPBOOTP_MIB_GET_INPUT_DATA      imgidInData;

    

    TraceEnter( " get_ifBindingEntry " );

    //
    // retrieve interface binding info.
    //
    
    pbifb                       = (buf_ifBindingEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPBOOTP_IF_BINDING_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                    &( pbifb-> ifBindingIndex ), 
                                    0 
                                  );
                                    
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR || pimgodOutData == NULL )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // set requiste fields
    //
    
    piib = (PIPBOOTP_IF_BINDING) (pimgodOutData-> IMGOD_Buffer);
    
    SetAsnInteger( &( pbifb-> ifBindingState ), piib-> IB_State );

    SetAsnInteger( &( pbifb-> ifBindingAddrCount ), piib-> IB_AddrCount );

    ForceSetAsnInteger(
        &( pbifb-> ifBindingIndex ),
        pimgodOutData-> IMGOD_IfIndex
    );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifBindingEntry " );

    return MIB_S_SUCCESS ;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ifAddressEntry table (1.3.6.1.4.1.311.1.12.2.4.1)                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
UINT
get_ifAddressEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwIndex     = (DWORD) -1,
                                    dwGetSize   = 0;

    buf_ifAddressEntry *            pbifae      = NULL;

    PIPBOOTP_IF_BINDING             piib        = NULL;

    PIPBOOTP_IP_ADDRESS             pia         = NULL;

    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData = NULL;

    IPBOOTP_IP_ADDRESS              ipa;
    
    IPBOOTP_MIB_GET_INPUT_DATA      imgidInData;

    

    TraceEnter( " get_ifAddressEntry " );

    //
    // retrieve interface binding info.
    //
    
    pbifae                      = (buf_ifAddressEntry*) objectArray;
    
    imgidInData.IMGID_TypeID    = IPBOOTP_IF_BINDING_ID;
    
    imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                    &( pbifae-> ifAEIfIndex ), 
                                    0 
                                  );
                                    
    if ( actionId == MIB_ACTION_GETNEXT &&
         !imgidInData.IMGID_IfIndex )
    {
        actionId = MIB_ACTION_GETFIRST;
    }
    
    dwRes = GetInterfaceInfo(
                actionId,
                &imgidInData,
                &pimgodOutData,
                &dwGetSize
            );

    if ( dwRes != NO_ERROR )
    {
        TraceError( dwRes );
        return dwRes;
    }

    //
    // retrieve IPAddress from IP Address table
    //

    ipa.IA_Address  = GetAsnIPAddress(
                        &( pbifae-> ifAEAddress),
                        INADDR_NONE
                      );

    ipa.IA_Netmask  = GetAsnIPAddress(
                        &( pbifae-> ifAEMask),
                        INADDR_NONE
                      );
                      
    piib            = (PIPBOOTP_IF_BINDING) pimgodOutData-> IMGOD_Buffer;

    pia             = (PIPBOOTP_IP_ADDRESS) IPBOOTP_IF_ADDRESS_TABLE( piib );

    FIND_IP_ADDRESS(
        ipa,
        piib-> IB_AddrCount,
        pia,
        dwIndex
    );


    //
    // set appr fields
    //

    dwRes = MIB_S_SUCCESS;
    
    switch ( actionId )
    {
    case MIB_ACTION_GET :

        //
        // idempotent case.  Only possible use is to verify 
        // specific peer present.
        //

        if ( dwIndex >= piib-> IB_AddrCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "IP address entry not found" );
        }
        
        break;


    case MIB_ACTION_GETFIRST :

        //
        // get entry at index 0 if available
        //

        dwIndex = 0;
        
        if ( !piib-> IB_AddrCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more IP address Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );
        }
        
        break;

    case MIB_ACTION_GETNEXT :

        //
        // check if entry was found
        //
        
        if ( dwIndex >= piib-> IB_AddrCount )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
            TRACE0( "IP address Entry not found " );
            break;
        }
        
        //
        // try and get next
        //
        
        dwIndex++;

        if ( dwIndex >= piib-> IB_AddrCount )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            TRACE1( 
                "No more IP address Entries for interface : %d",
                imgidInData.IMGID_IfIndex
            );

            break;
        }

        dwRes = MIB_S_SUCCESS;
        
        break;
        
    default :
    
        TRACE0( " get_globalPeerFilterEntry - Wrong Action " );

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    }

    //
    // set index for next retieval
    //

    if ( dwRes == MIB_S_SUCCESS )
    {
        ForceSetAsnInteger(
            &( pbifae-> ifAEIfIndex ),
            pimgodOutData-> IMGOD_IfIndex
        );

        ForceSetAsnIPAddress(
            &( pbifae-> ifAEAddress ),
            &( pbifae-> dwIfAEAddr ),
            pia[ dwIndex ].IA_Address
        );

        ForceSetAsnIPAddress(
            &( pbifae-> ifAEMask ),
            &( pbifae-> dwIfAEMask ),
            pia[ dwIndex ].IA_Netmask
        );
    }
    
    if ( pimgodOutData )  { MprAdminMIBBufferFree( pimgodOutData ); }
    
    TraceLeave( " get_ifAddressEntry " );

    return dwRes;
}


DWORD
UpdateGlobalInfo(
    IN  AsnAny *    objectArray
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    sav_global*                     psg         = NULL;

    PIPBOOTP_GLOBAL_CONFIG          pigc        = NULL;
    
    PIPBOOTP_MIB_SET_INPUT_DATA     pimsidInData= NULL;

    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData = NULL;


    do
    {
        //
        // Retrieve the global config Data first
        //

        dwRes = GetGlobalConfigInfo( 
                    &pimgodOutData,
                    &dwGetSize
                );
                
        if ( dwRes != NO_ERROR )
        {
            break;
        }

        pigc    = (PIPBOOTP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;
    

        psg     = (sav_global*) objectArray;
        
        //
        // Allocate set info buffer
        //
        
        dwSetSize = sizeof( IPBOOTP_MIB_SET_INPUT_DATA ) - 1 +
                    IPBOOTP_GLOBAL_CONFIG_SIZE( pigc );

        pimsidInData = 
            (PIPBOOTP_MIB_SET_INPUT_DATA) BOOTP_MIB_ALLOC( dwSetSize );
        
        if ( pimsidInData == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "SetGlobalData - Mem. alloc failed" );
            break;
        }
        
        pimsidInData-> IMSID_TypeID     = IPBOOTP_GLOBAL_CONFIG_ID;

        pimsidInData-> IMSID_IfIndex    = (DWORD) -1;

        pimsidInData-> IMSID_BufferSize = IPBOOTP_GLOBAL_CONFIG_SIZE( pigc );


        //
        // Set config info fields.
        //

        //
        // if a variable is not specified, the corresp. value in the 
        // config is left unchanged (by setting it to itself).
        //

        pigc-> GC_MaxRecvQueueSize      = GetAsnInteger(
                                            &( psg-> globalMaxRecQueueSize ),
                                            pigc-> GC_MaxRecvQueueSize
                                          );


        //
        // -1 is subtracted from the enumerated fields to adjust
        // the ASN enumeration values to the actual log level values.
        // This is required since the enumeration cannot have 
        // a zero value as per the ASN compiler.
        //
        // as a caveat, if the enumerated field is not specified in 
        // this set operation, to preserve the value of the field
        // in the config, we first increment it.  This way on the 
        // -1 operation the value is restored.  
        //
        
        pigc-> GC_LoggingLevel++;
        
        pigc-> GC_LoggingLevel          = GetAsnInteger( 
                                            &( psg-> globalLoggingLevel ), 
                                            pigc-> GC_LoggingLevel
                                          ) - 1;

        CopyMemory( 
            (PVOID) pimsidInData-> IMSID_Buffer, 
            (PVOID*) pigc, 
            IPBOOTP_GLOBAL_CONFIG_SIZE( pigc ) 
        );

        //
        // Save the info. in the MIB
        //
        
        BOOTP_MIB_SET(
            pimsidInData,
            dwSetSize,
            dwRes
        );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        dwRes = MIB_S_SUCCESS;
        
    } while ( FALSE );

    //
    // Free allocations
    //
    
    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    if ( pimsidInData ) { BOOTP_MIB_FREE( pimsidInData ); }
    
    return dwRes;
}


DWORD
GetGlobalConfigInfo(
    OUT PIPBOOTP_MIB_GET_OUTPUT_DATA *  ppimgod,
    OUT PDWORD                          pdwSize
)
{

    DWORD                           dwRes           = (DWORD) -1;
    
    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData   = NULL;
    
    IPBOOTP_MIB_GET_INPUT_DATA      imgidInData;

    
    do
    {
        //
        // retrieve global config 
        //

        *ppimgod = NULL;

        imgidInData.IMGID_TypeID    = IPBOOTP_GLOBAL_CONFIG_ID;
        
        BOOTP_MIB_GET(
            &imgidInData,
            sizeof( IPBOOTP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwSize,
            dwRes
        );

        if (!pimgodOutData)
            return ERROR_NOT_ENOUGH_MEMORY;


        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        *ppimgod = pimgodOutData;
        
    } while ( FALSE );

    return dwRes;
}


DWORD
UpdateBOOTPServerTable(
    IN  sav_globalBOOTPServerEntry *    psgbse
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwInd       = 0,
                                    dwOp        = 0,
                                    dwServerAddr= INADDR_NONE,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    PDWORD                          pdwAddrTable= 0;                                    

    PIPBOOTP_GLOBAL_CONFIG          pigc        = NULL;
    
    PIPBOOTP_MIB_SET_INPUT_DATA     pimsid      = NULL;

    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData = NULL;


    do
    {
        //
        // Get global info
        //

        dwRes = GetGlobalConfigInfo( 
                    &pimgodOutData,
                    &dwGetSize
                );
                
        if ( dwRes != NO_ERROR )
        {
            break;
        }

                
        //
        // Find server entry
        //

        dwServerAddr  = GetAsnIPAddress( 
                        &( psgbse-> globalBOOTPServerAddr ), 
                        0 
                      );
        
        pigc        = (PIPBOOTP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

        pdwAddrTable= IPBOOTP_GLOBAL_SERVER_TABLE( pigc );

        FIND_SERVER_ENTRY(
            dwServerAddr,
            pigc-> GC_ServerCount,
            pdwAddrTable,
            dwInd
        );

        //
        // if operation is server add
        //

        dwOp = GetAsnInteger( &( psgbse-> globalBOOTPServerTag ), 0 );
        
        switch( dwOp )
        {
        case d_globalBOOTPServerTag_create :

            //
            // if server already present, quit
            //
            
            if ( pigc-> GC_ServerCount &&
                 dwInd < pigc-> GC_ServerCount )
            {
                dwRes = MIB_S_SUCCESS;
                break;
            }

            else
            {
                dwRes = AddBOOTPServerEntry( 
                            dwServerAddr, 
                            pimgodOutData
                        );
            }

            break;

        case d_globalBOOTPServerTag_delete :

            //
            // operation is server delete
            //

            //
            // if server is not present quit.
            //
        
            if ( !pigc-> GC_ServerCount ||
                 dwInd >= pigc-> GC_ServerCount )
            {
                dwRes = MIB_S_SUCCESS;
                break;
            }

            dwRes = DeleteBOOTPServerEntry(
                        dwInd,
                        pimgodOutData
                    );
            break;

        default :

            dwRes = MIB_S_INVALID_PARAMETER;
            
            TRACE0( "Invalid action specified : logic error " );

            break;
        }
                
    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    return dwRes;

}



DWORD
AddBOOTPServerEntry(
    IN  DWORD                           dwServerAddr,
    IN  PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwSetSize   = 0;

    PDWORD                          pdwAddrTable= NULL;
    
    PIPBOOTP_GLOBAL_CONFIG          pigc        = NULL;

    PIPBOOTP_MIB_SET_INPUT_DATA     pimsid      = NULL;


    
    do
    {
        //
        // BOOTP Server needs to be added.
        //
        
        //
        // compute buffer size required
        //
        
        pigc        = (PIPBOOTP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize   = sizeof( IPBOOTP_MIB_SET_INPUT_DATA ) - 1 +
                      IPBOOTP_GLOBAL_CONFIG_SIZE( pigc ) + sizeof( DWORD );

        pimsid      = (PIPBOOTP_MIB_SET_INPUT_DATA) BOOTP_MIB_ALLOC( dwSetSize );

        if ( !pimsid )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "AddBOOTPServerEntry - out of memory" );
            break;
        }

        //
        // Add server
        //

        pimsid-> IMSID_TypeID       = IPBOOTP_GLOBAL_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = (DWORD) -1;

        pimsid-> IMSID_BufferSize   = IPBOOTP_GLOBAL_CONFIG_SIZE( pigc ) +
                                      sizeof( DWORD );
    
        CopyMemory( 
            (PVOID) &( pimsid-> IMSID_Buffer ), 
            (VOID *) pigc, 
            IPBOOTP_GLOBAL_CONFIG_SIZE( pigc )
        );

        pigc = (PIPBOOTP_GLOBAL_CONFIG) pimsid-> IMSID_Buffer;

        pdwAddrTable = IPBOOTP_GLOBAL_SERVER_TABLE( pigc );        

        pdwAddrTable[ pigc-> GC_ServerCount ] = dwServerAddr;

        pigc-> GC_ServerCount++;

        //
        // Update MIB
        //
        
        BOOTP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );
        
    } while ( FALSE );     

    if ( pimsid ) { BOOTP_MIB_FREE( pimsid ); }
    
    return dwRes;
}




DWORD
DeleteBOOTPServerEntry(
    IN  DWORD                           dwIndex,
    IN  PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwSetSize   = 0,
                                    dwSrc       = 0,
                                    dwDst       = 0;

    PDWORD                          pdwSrcTable = NULL,
                                    pdwDstTable = NULL;
    
    PIPBOOTP_GLOBAL_CONFIG          pigc        = NULL;

    PIPBOOTP_MIB_SET_INPUT_DATA     pimsid      = NULL;


    
    do
    {
        //
        // Server needs to be deleted.
        //
        
        //
        // compute buffer size required
        //
        
        pigc        = (PIPBOOTP_GLOBAL_CONFIG) pimgodOutData-> IMGOD_Buffer;

        dwSetSize   = sizeof( IPBOOTP_MIB_SET_INPUT_DATA ) - 1 +
                      IPBOOTP_GLOBAL_CONFIG_SIZE( pigc ) - sizeof( DWORD );

        pimsid      = (PIPBOOTP_MIB_SET_INPUT_DATA) BOOTP_MIB_ALLOC( dwSetSize );

        if ( !pimsid )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( "DeleteBOOTPServerEntry - out of memory" );
            break;
        }

        //
        // Delete server
        //

        //
        // Copy base global config structure
        //
        
        pimsid-> IMSID_TypeID       = IPBOOTP_GLOBAL_CONFIG_ID;

        pimsid-> IMSID_IfIndex      = (DWORD) -1;

        pimsid-> IMSID_BufferSize   = IPBOOTP_GLOBAL_CONFIG_SIZE( pigc ) -
                                      sizeof( DWORD );
    
        CopyMemory( 
            (PVOID) &( pimsid-> IMSID_Buffer ), 
            (VOID *) pigc, 
            sizeof( IPBOOTP_GLOBAL_CONFIG )
        );

        //
        // Copy peer table. Skip entry to be deleted
        //
        
        pdwSrcTable = IPBOOTP_GLOBAL_SERVER_TABLE( pigc );

        pigc        = ( PIPBOOTP_GLOBAL_CONFIG ) pimsid-> IMSID_Buffer;

        pdwDstTable = IPBOOTP_GLOBAL_SERVER_TABLE( pigc );

        DELETE_SERVER_ENTRY(
            dwIndex,
            pigc-> GC_ServerCount,
            pdwSrcTable,
            pdwDstTable
        );
        
        
        pigc-> GC_ServerCount--;

        //
        // Update MIB
        //
        
        BOOTP_MIB_SET(
            pimsid,
            dwSetSize,
            dwRes
        );
        
    } while ( FALSE );     

    if ( pimsid ) { BOOTP_MIB_FREE( pimsid ); }
    
    return dwRes;
}


DWORD
GetInterfaceInfo( 
    IN  UINT                            actionId,
    IN  PIPBOOTP_MIB_GET_INPUT_DATA     pimgidInData,
    OUT PIPBOOTP_MIB_GET_OUTPUT_DATA*   ppimgod,
    OUT PDWORD                          pdwOutSize
)
{

    DWORD                           dwRes           = (DWORD) -1;
    
    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData   = NULL;

    
    *ppimgod = NULL;
    

    switch ( actionId )
    {
    case MIB_ACTION_GET :

        BOOTP_MIB_GET(
            pimgidInData,
            sizeof( IPBOOTP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
        }

        break;

    case MIB_ACTION_GETFIRST :

        BOOTP_MIB_GETFIRST(
            pimgidInData,
            sizeof( IPBOOTP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;
        }

        break;

    case MIB_ACTION_GETNEXT :
    
        BOOTP_MIB_GETNEXT(
            pimgidInData,
            sizeof( IPBOOTP_MIB_GET_INPUT_DATA ),
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER || pimgodOutData == NULL)
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            break;
        }

        //
        // Get Next wraps to the next table at the end of the
        // entries in the current table.  To flag the end of a table,
        // check the end of the table.
        //
    
        if ( pimgidInData-> IMGID_TypeID != pimgodOutData-> IMGOD_TypeID )
        {
            MprAdminMIBBufferFree( pimgodOutData );
        
            dwRes = MIB_S_NO_MORE_ENTRIES;
        }

        break;

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    
    }

    if ( dwRes == NO_ERROR )
    {
        *ppimgod = pimgodOutData;
    }

    return dwRes;
}


DWORD
ValidateInterfaceConfig(
    IN  AsnAny *        objectArray
)
{
    DWORD                   dwRes       = MIB_S_INVALID_PARAMETER,
                            dwCount     = (DWORD) -1,
                            dwMode      = (DWORD) -1;
    
    sav_ifConfigEntry*      psifce      = (sav_ifConfigEntry*) objectArray;

    
    do
    {
        //
        // verify relay mode
        //

        dwMode = GetAsnInteger( &( psifce-> ifCERelayMode ), (DWORD) -1 );

        if ( dwMode != d_ifCERelayMode_disabled &&
             dwMode != d_ifCERelayMode_enabled )
        {
            TRACE1( " Invalid update mode (%d) specified ", dwMode );
            break;
        }
        
        dwRes = MIB_S_SUCCESS;
        
    } while ( FALSE );

    return dwRes;
}


DWORD
SetInterfaceConfig(
    IN  AsnAny *    objectArray
)
{

    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0;

    sav_ifConfigEntry*              psifce      = NULL;

    PIPBOOTP_IF_CONFIG              piic        = NULL;
    PIPBOOTP_MIB_SET_INPUT_DATA     pimsidInData= NULL;

    PIPBOOTP_MIB_GET_OUTPUT_DATA    pimgodOutData = NULL;
    IPBOOTP_MIB_GET_INPUT_DATA      imgidInData;


    do
    {
        //
        // Retrieve existing interface config
        //

        psifce                      = (sav_ifConfigEntry*) objectArray;

        imgidInData.IMGID_TypeID    = IPBOOTP_IF_CONFIG_ID;

        imgidInData.IMGID_IfIndex   = GetAsnInteger( 
                                        &( psifce-> ifCEIndex ),
                                        (DWORD) -1
                                      );

        dwRes = GetInterfaceInfo(
                    MIB_ACTION_GET,
                    &imgidInData,
                    &pimgodOutData,
                    &dwGetSize
                );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        //
        // Update fields
        //

        piic = (PIPBOOTP_IF_CONFIG) (pimgodOutData-> IMGOD_Buffer);

        piic-> IC_RelayMode++;
        piic-> IC_RelayMode = GetAsnInteger( 
                                &( psifce-> ifCERelayMode ),
                                piic-> IC_RelayMode
                              ) - 1;

        piic-> IC_MaxHopCount = GetAsnInteger( 
                                    &( psifce-> ifCEMaxHopCount ),
                                    piic-> IC_MaxHopCount
                                );

        piic-> IC_MinSecondsSinceBoot = GetAsnInteger(
                                    &( psifce-> ifCEMinSecondsSinceBoot ),
                                    piic-> IC_MinSecondsSinceBoot
                                );
        BOOTP_MIB_SET(
            pimsidInData,
            dwSetSize,
            dwRes
        );

        if ( dwRes != NO_ERROR )
        {
            TraceError( dwRes );
            break;
        }

        dwRes = MIB_S_SUCCESS;
        
    } while ( FALSE );

    if ( pimgodOutData ) { MprAdminMIBBufferFree( pimgodOutData ); }

    if ( pimsidInData ) { BOOTP_MIB_FREE( pimsidInData ); }

    return dwRes;
}


DWORD
ConnectToRouter()
{
    DWORD       dwRes = (DWORD) -1;
    

    EnterCriticalSection( &g_CS );

    do
    {
        MPR_SERVER_HANDLE hTmp;

        if ( g_hMIBServer )
        {
            dwRes = NO_ERROR;
            break;
        }

        dwRes = MprAdminMIBServerConnect( NULL, &hTmp );

        if ( dwRes == NO_ERROR )
        {
            InterlockedExchangePointer( &g_hMIBServer, hTmp );
        }
        else
        {
            TRACE1( 
                "Error %d setting up DIM connection to MIB Server\n", 
                dwRes
            );
        }
        
    } while ( FALSE );

    LeaveCriticalSection( &g_CS );

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\debug.c ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// Module Name: debug.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

#include "pchdvmrp.h"
#pragma hdrstop



VOID
DebugPrintGlobalConfig(
    PDVMRP_GLOBAL_CONFIG pGlobalConfig
    )
{
    Trace0(CONFIG, "\n================================================");
    Trace0(CONFIG, "Printing Dvmrp Global Config");
    Trace1(CONFIG, "MajorVersion:               0x%x",
        pGlobalConfig->MajorVersion);

    Trace1(CONFIG, "MinorVersion:               0x%x",
        pGlobalConfig->MinorVersion);

    Trace1(CONFIG, "LoggingLevel:               %d",
        pGlobalConfig->LoggingLevel);

    Trace1(CONFIG, "RouteReportInterval:        %d",
        pGlobalConfig->RouteReportInterval);

    Trace1(CONFIG, "RouteExpirationInterval:    %d",
        pGlobalConfig->RouteExpirationInterval);

    Trace1(CONFIG, "RouteHolddownInterval:      %d",
        pGlobalConfig->RouteHolddownInterval);

    Trace1(CONFIG, "PruneLifetimeInterval:      %d",
        pGlobalConfig->PruneLifetimeInterval);

    return;
}


VOID
DebugPrintIfConfig(
    ULONG IfIndex,
    PDVMRP_IF_CONFIG pIfConfig
    )
{
    DWORD i;
    PDVMRP_PEER_FILTER pPeerFilter;

    
    Trace0(CONFIG, "\n================================================");
    Trace1(CONFIG, "Printing Dvmrp Config for Interface:%d", IfIndex);
    
    Trace1(CONFIG, "Metric:                             %d",
        pIfConfig->Metric);

    Trace1(CONFIG, "ProbeInterval:                      %d",
        pIfConfig->ProbeInterval);

    Trace1(CONFIG, "PeerTimeoutInterval:                %d",
        pIfConfig->PeerTimeoutInterval);

    Trace1(CONFIG, "MinTriggeredUpdateInterval:         %d",
        pIfConfig->MinTriggeredUpdateInterval);

    Trace1(CONFIG, "PeerFilterMode:                     %d",
        pIfConfig->PeerFilterMode);

    Trace1(CONFIG, "NumPeerFilters:                     %d",
        pIfConfig->NumPeerFilters);


    pPeerFilter = GET_FIRST_DVMRP_PEER_FILTER(pIfConfig);
    
    for (i=0;  i<pIfConfig->NumPeerFilters;  i++,pPeerFilter++) {

        CHAR Str[16];
        
        sprintf(Str, "%d.%d.%d.%d", PRINT_IPADDR(pPeerFilter->IpAddr));
        
        Trace2(CONFIG, "      %-16s %d.%d.%d.%d", Str, pPeerFilter->Mask);
        
    }

    return;
    
}//end _DebugPrintIfConfig

//----------------------------------------------------------------------------
// 
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\defines.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// Module Name: defines.h
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

//
// IPADDR typedef
// 

#ifndef IPADDR
typedef DWORD   IPADDR;
#endif


//
// instead of using goto:end to go to the end of the block, use the following
//
#define BEGIN_BREAKOUT_BLOCK1    do
#define GOTO_END_BLOCK1          goto END_BREAKOUT_BLOCK_1
#define END_BREAKOUT_BLOCK1      while(FALSE); END_BREAKOUT_BLOCK_1:
#define BEGIN_BREAKOUT_BLOCK2    do
#define GOTO_END_BLOCK2          goto END_BREAKOUT_BLOCK_2
#define END_BREAKOUT_BLOCK2      while(FALSE); END_BREAKOUT_BLOCK_2:


//-----------------------------------------------------------------------------
// memory allocation/deallocation macros, error macros
//-----------------------------------------------------------------------------

#define DVMRP_ALLOC(sz)           HeapAlloc(Globals1.Heap,0,(sz))
#define DVMRP_ALLOC_AND_ZERO(sz) \
        HeapAlloc(Globals1.Heap,HEAP_ZERO_MEMORY,(sz))
#define DVMRP_FREE(p)             HeapFree(Globals1.Heap, 0, (p))
#define DVMRP_FREE_AND_NULL(p)    {\
    if (p) HeapFree(Globals1.Heap, 0, (p));\
    (p) = NULL; \
    }
#define DVMRP_FREE_NOT_NULL(p)    ((p) ? DVMRP_FREE(p) : TRUE)

#define PROCESS_ALLOC_FAILURE1(ptr, Error,arg2, GotoStmt) \
    if (ptr==NULL) {\
        Error = GetLastError();\
        Trace3(ERR, "Error %d allocating %d bytes",Error,arg2);\
        Logerr0(HEAP_ALLOC_FAILED, Error);\
        GotoStmt;\
    }


#define PROCESS_ALLOC_FAILURE2(ptr, Name, Error,arg2,GotoStmt) \
    if (ptr==NULL) {\
        Error = GetLastError();\
        Trace3(ERR, "Error %d allocating %d bytes for %s", \
            Error, arg2, Name); \
        Logerr0(HEAP_ALLOC_FAILED, Error);\
        GotoStmt;\
    }

#define PROCESS_ALLOC_FAILURE3(ptr, Format, Error,arg2,arg3, GotoStmt) \
    if (ptr==NULL) {\
        Error = GetLastError();\
        Trace3(ERR, "Error %d allocating %d bytes for " ## Format, \
            Error, arg2, arg3); \
        Logerr0(HEAP_ALLOC_FAILED, Error);\
        GotoStmt;\
    }


#define HANDLE_CRITICAL_SECTION_EXCEPTION(Error, GotoStmt)          \
    except (EXCEPTION_EXECUTE_HANDLER) {                            \
                                                                    \
        Error = GetExceptionCode();                                 \
        Trace1(ERR, "Error initializing critical section", Error);  \
                                                                    \
        Logerr0(INIT_CRITSEC_FAILED, Error);                        \
        GotoStmt;                                                   \
    }



//-----------------------------------------------------------------------------
// general ip address macros
//-----------------------------------------------------------------------------


#define ALL_DVMRP_ROUTERS_MCAST_GROUP 0x040000E0


//
// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument.
//

#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = ((((a)>>8) & 0x00ff0000) - (((b)>>8) & 0x00ff0000)))))))

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),\
    (((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)


//
// assert macros
//

#if DBG

#define IgmpAssert(exp){                                                \
    if(!(exp))                                                          \
    {                                                                   \
        TracePrintf(TRACEID,                                            \
                    "Assertion failed in %s : %d \n",__FILE__,__LINE__);\
        RouterAssert(#exp,__FILE__,__LINE__,NULL);                      \
    }                                                                   \
}
#else
#define IgmpAssert(exp)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\if.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: if.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

#include "pchdvmrp.h"
#pragma hdrstop

//----------------------------------------------------------------------------
//      _AddInterface
//----------------------------------------------------------------------------

DWORD
WINAPI
AddInterface(
    IN PWCHAR               pInterfaceName,//not used
    IN ULONG                IfIndex,
    IN NET_INTERFACE_TYPE   IfType,
    IN DWORD                MediaType,
    IN WORD                 AccessType,
    IN WORD                 ConnectionType,
    IN PVOID                pConfig,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    )
{
    DWORD       Error = NO_ERROR;

    Trace1(ENTER, "entering AddInterface(): IfIndex:%d", IfIndex);

    ACQUIRE_IF_LIST_LOCK("_AddInterface");
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_AddInterface");

    Error = AddIfEntry(IfIndex, pConfig, StructureSize);

    RELEASE_IF_LIST_LOCK("_AddInterface");
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_AddInterface");


    Trace2(LEAVE, "leaving AddInterface(%d): %d\n", IfIndex, Error);
    
    return Error;
}


//----------------------------------------------------------------------------
//      _AddIfEntry
//----------------------------------------------------------------------------

DWORD
AddIfEntry(
    ULONG IfIndex,
    PVOID pConfig,
    ULONG StructureSize
    )
{
    DWORD   Error = NO_ERROR;
    PIF_CONFIG pIfConfig = (PIF_CONFIG) pConfig;
    PIF_TABLE_ENTRY pite = NULL;
    
    
    //
    // validate interface config
    //
    
    Error = ValidateIfConfig(IfIndex, pIfConfig, StructureSize);
    
    if (Error != NO_ERROR) {
        Trace1(ERR,
            "AddInterface(%d) failed due to invalid configuration",
            IfIndex);
    
        return Error;
    }

    
    BEGIN_BREAKOUT_BLOCK1 {
    
        //
        // fail if the interface exists.
        //
        
        pite = GetIfEntry(IfIndex);

        if (pite != NULL) {
            Trace1(ERR, "interface %d already exists", IfIndex);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }

        //
        // allocate memory for the new interface and its different fields
        //

        // allocate memory for IfTable
        
        pite = DVMRP_ALLOC_AND_ZERO(sizeof(IF_TABLE_ENTRY));

        PROCESS_ALLOC_FAILURE3(pite, "interface %d", Error,
            sizeof(IF_TABLE_ENTRY), IfIndex, GOTO_END_BLOCK1);


        InitializeListHead(&pite->Link);
        InitializeListHead(&pite->HTLink);
        pite->IfIndex = IfIndex;


        // set interface status (neither bound, enabled or activated)

        pite->Status = IF_CREATED_FLAG;


        // set base refcount to 1
        
        pite->RefCount = 1;
        
        
        //
        // allocate memory for IfConfig and copy it.
        //
        
        pite->pConfig = DVMRP_ALLOC_AND_ZERO(DVMRP_IF_CONFIG_SIZE(pIfConfig));

        PROCESS_ALLOC_FAILURE3(pite, "interface %d", Error,
            DVMRP_IF_CONFIG_SIZE(pIfConfig), IfIndex, GOTO_END_BLOCK1);

        memcpy(pite->pConfig, pIfConfig, DVMRP_IF_CONFIG_SIZE(pIfConfig));

        
        
        // allocate memory for IfInfo
        
        pite->pInfo = DVMRP_ALLOC_AND_ZERO(sizeof(IF_INFO));

        PROCESS_ALLOC_FAILURE3(pite, "interface %d", Error,
            sizeof(IF_INFO), IfIndex, GOTO_END_BLOCK1);


        //
        // allocate memory for Socket data
        //
        
        pite->pSocketData = DVMRP_ALLOC_AND_ZERO(sizeof(ASYNC_SOCKET_DATA));

        PROCESS_ALLOC_FAILURE3(pite, "interface %d", Error,
            sizeof(ASYNC_SOCKET_DATA), IfIndex, GOTO_END_BLOCK1);


        pite->pSocketData->WsaBuf.buf = DVMRP_ALLOC(PACKET_BUFFER_SIZE);

        PROCESS_ALLOC_FAILURE3(pite, "interface %d", Error,
            PACKET_BUFFER_SIZE, IfIndex, GOTO_END_BLOCK1);

        pite->pSocketData->WsaBuf.len = PACKET_BUFFER_SIZE;
        
        pite->pSocketData->pite = pite;

        
    } END_BREAKOUT_BLOCK1;

    
    // initialize the sockets to invalid_socket
    
    pite->Socket = INVALID_SOCKET;


    //  insert the interface in the hash table at the end.

    InsertTailList(&G_pIfTable->IfHashTable[IF_HASH_VALUE(IfIndex)],
                    &pite->HTLink);


    //
    // insert the entry into the interface list
    //
    
    {
        PIF_TABLE_ENTRY piteTmp;
        PLIST_ENTRY pHead, ple;
        
        pHead = &G_pIfTable->IfList;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            piteTmp = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, Link);
            if (pite->IfIndex < piteTmp->IfIndex)
                break;
        }
        
        InsertTailList(ple, &pite->Link);
    }

    if ( (Error!=NO_ERROR)&&(pite!=NULL) ) {
        DeleteIfEntry(pite);
    }
    
    return Error;
    
}//end AddIfEntry


//-----------------------------------------------------------------------------
// _DeleteIfEntry
//-----------------------------------------------------------------------------

VOID
DeleteIfEntry(
    PIF_TABLE_ENTRY pite
    )
{
    if (!pite)
        return;

    //
    // delete peers
    //


    //
    // remove the entry from the interface list, and hashTable
    //

    RemoveEntryList(&pite->Link);
    RemoveEntryList(&pite->HTLink);

    if (pite->Socket != INVALID_SOCKET) {
        closesocket(pite->Socket);
    }

    DVMRP_FREE(pite->pInfo);
    DVMRP_FREE(pite->pBinding);
    DVMRP_FREE(pite->pConfig);
    
    return;
    
}//end _DeleteIfEntry



//----------------------------------------------------------------------------
// _DeleteInterface
//----------------------------------------------------------------------------

DWORD
DeleteInterface(
    IN DWORD IfIndex
    )
{
    DWORD       Error = NO_ERROR;

    return Error;
    
}//end _DeleteInterface

//----------------------------------------------------------------------------
// _InterfaceStatus
//----------------------------------------------------------------------------

DWORD
WINAPI
InterfaceStatus(
    ULONG IfIndex,
    BOOL  IsIfActive,
    DWORD StatusType,
    PVOID pStatusInfo
    )
{
    DWORD       Error = NO_ERROR;

    switch(StatusType)
    {
        case RIS_INTERFACE_ADDRESS_CHANGE:
        {
            PIP_ADAPTER_BINDING_INFO pBindInfo
                                    = (PIP_ADAPTER_BINDING_INFO)pStatusInfo;

            if(pBindInfo->AddressCount)
            {
                Error = BindInterface(IfIndex, pBindInfo);
            }
            else
            {
                Error = UnBindInterface(IfIndex);
            }

            break;
        }

        case RIS_INTERFACE_ENABLED:
        {
            Error = EnableInterface(IfIndex);
            break;
        }

        case RIS_INTERFACE_DISABLED:
        {
            Error = DisableInterface(IfIndex);
            break;
        }

    }

    return Error;
}


//----------------------------------------------------------------------------
// _BindInterface
//----------------------------------------------------------------------------

DWORD
BindInterface(
    ULONG IfIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    )
{
    DWORD               Error = NO_ERROR;
    PIF_TABLE_ENTRY     pite = NULL;
    DWORD               i, Size, AddrCount;
    IPADDR              MinAddr;
    PDVMRP_ADDR_MASK    pAddrBinding;
    INT                 cmp;
    IPADDR              ConfigAddr  = 0;
    
    
    Trace1(ENTER1, "entering BindInterface: %d", IfIndex);
    Trace1(IF, "binding interface %d", IfIndex);


    // pBinding should not be NULL

    if (pBinding == NULL) {

        Trace0(IF, "error: binding struct pointer is NULL");
        Trace1(LEAVE, "leaving BindInterface: %d", ERROR_INVALID_PARAMETER);

        return ERROR_INVALID_PARAMETER;
    }


    //
    // take exclusive interface lock
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_BindInterface");


    BEGIN_BREAKOUT_BLOCK1 {

        AddrCount = pBinding->AddressCount;

        
        //
        // retrieve the interface entry
        //

        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        //
        // If the interface is already bound then return error.
        // todo: do I need to check if the bindings are same
        //
        
        if (IS_IF_BOUND(pite)) {
            Trace1(IF, "interface %d is already bound", IfIndex);
            GOTO_END_BLOCK1;
        }


        //
        // make sure there is at least one address.
        //
        
        if (AddrCount==0) {

            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }


        //
        // if an effective address is already configured, make sure it 
        // is present in the list of address bindings
        //

        ConfigAddr = pite->pConfig->ConfigIpAddr;
        
        if (ConfigAddr) {

            BOOL Found = FALSE;
            
            for (i=0;  i<AddrCount;  i++) {

                if (ConfigAddr == pBinding->Address[i].Address) {
                    Found = TRUE;
                    break;
                }
            }

            if (!Found) {
    
                Trace2(ERR,
                    "Configured effective IP Address:%d.%d.%d.%d on interface"
                    ":%d not part of address bindings",
                    PRINT_IPADDR(ConfigAddr), IfIndex);

                Error = ERROR_CAN_NOT_COMPLETE;

                GOTO_END_BLOCK1;
            }
        }
        
            
        //
        // allocate memory to store the binding
        //
        
        Size = AddrCount * sizeof(DVMRP_ADDR_MASK);

        pAddrBinding = DVMRP_ALLOC(Size);

        PROCESS_ALLOC_FAILURE3(pAddrBinding, "binding on interface %d",
            Error, Size, IfIndex, GOTO_END_BLOCK1);


        //
        // copy the bindings
        //

        MinAddr = ~0;
        
        for (i=0;  i<AddrCount;  i++,pAddrBinding++) {

            pAddrBinding->IpAddr = pBinding->Address[i].Address;
            pAddrBinding->Mask = pBinding->Address[i].Mask;

            if (!ConfigAddr && (INET_CMP(MinAddr, pAddrBinding->IpAddr, cmp)>0))
                MinAddr = pAddrBinding->IpAddr;
        }

        
        //
        // set the Interface effective address to the smallest bound address
        //
        
        pite->IpAddr = ConfigAddr ? ConfigAddr : MinAddr;


        //
        // save the binding in the interface entry
        //
        
        pite->pBinding = pAddrBinding;

        pite->NumAddrBound = pBinding->AddressCount;


        //
        // mark the interface as being bound
        //
        
        pite->Status |= IF_BOUND_FLAG;


        //
        // if interface is also enabled, it is now active
        // so activate it
        //

        if (IS_IF_ENABLED_BOUND(pite)) {

            //
            // Activate the Interface
            //
            
            Error = ActivateInterface(pite);


            //
            // if could not activate the interface then undo the binding
            //
            if (Error != NO_ERROR) {

                Trace1(ERR,
                    "Unbinding interface(%d) as it could not be activated",
                    IfIndex);

                Error = ERROR_CAN_NOT_COMPLETE;
                GOTO_END_BLOCK1;
            }
         }
        

    } END_BREAKOUT_BLOCK1;

    //
    // if there was any error, then set the status to unbound (pite is null
    // if interface was not found)
    //
    
    if ((Error!=NO_ERROR)&&(pite!=NULL)) {

        pite->Status &= ~IF_BOUND_FLAG;

        if (pite->pBinding)
            DVMRP_FREE_AND_NULL(pite->pBinding);

        pite->NumAddrBound = 0;
        
        pite->IpAddr = 0;
    }
        
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_BindInterface");

    Trace2(LEAVE1, "leaving _BindInterface(%d): %d\n", IfIndex, Error);

    return Error;
}



//-----------------------------------------------------------------------------
//                _EnableInterface
//
// sets the status to enabled. If interface is also bound and enabled in
// config, then activate the interface.
//
// Locks: Exclusive IfLock
//-----------------------------------------------------------------------------

DWORD
EnableInterface(
    IN DWORD IfIndex
    )
{
    DWORD Error = NO_ERROR;


    Trace1(ENTER1, "entering _EnableInterface(%d):", IfIndex);
    Trace1(IF, "enabling interface %d", IfIndex);


    //
    // enable the interface
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_EnableInterface");

    Error = EnableIfEntry(IfIndex, TRUE); //enabled by RtrMgr

    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_EnableInterface");



    Trace2(LEAVE1, "leaving _EnableInterface(%d): %d\n", IfIndex, Error);

    return Error;
}


//-----------------------------------------------------------------------------
//                _EnableIfEntry
//-----------------------------------------------------------------------------

DWORD
EnableIfEntry(
    DWORD   IfIndex,
    BOOL    bChangedByRtrmgr // changed by rtrmg or SetInterfaceConfigInfo
    )
{
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         ple, phead;
    PIF_TABLE_ENTRY     pite = NULL;


    BEGIN_BREAKOUT_BLOCK1 {

        //
        // retrieve the interface
        //
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Trace1(IF, "could not find interface %d",IfIndex);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        if (bChangedByRtrmgr) {
            //
            // quit if the interface is already enabled by the router manager
            //
            if (IS_IF_ENABLED_BY_RTRMGR(pite)) {
                Trace1(IF, "interface %d is already enabled by RtrMgr",
                        IfIndex);
                Error = NO_ERROR;
                GOTO_END_BLOCK1;
            }


            // set the flag to enabled by router manager

            pite->Status |= IF_ENABLED_FLAG;

            // print trace if enabled flag not set in the Config.
            if (!IS_IF_ENABLED_IN_CONFIG(pite)) {
                Trace1(IF,
                    "Interface(%d) enabled by router manager but not enabled"
                    "in the Config", pite->IfIndex);
            }
        }

        else {
            //
            // quit if the interface is already enabled in config
            //
            if (IS_IF_ENABLED_IN_CONFIG(pite)) {
                Trace1(IF, "interface %d is already enabled in Config",
                        IfIndex);
                Error = NO_ERROR;
                GOTO_END_BLOCK1;
            }

            // set the config flag to enabled

            pite->pConfig->Flags |= DVMRP_IF_ENABLED_IN_CONFIG;


            // print trace if interface not enabled by router manager

            if (!IS_IF_ENABLED_BY_RTRMGR(pite)) {
                Trace1(IF,
                    "Interface(%d) enabled in config but not by RtrMgr",
                    IfIndex);
                Error = NO_ERROR;
                GOTO_END_BLOCK1;
            }
        }

        //
        // if interface is already bound, it should be activated
        // if the bInterfaceEnabled flag is also set in config (by the UI)
        //

        if (IS_IF_ENABLED_BOUND(pite)) {

            //
            // Activate the Interface
            //
            Error = ActivateInterface(pite);

            //
            // if could not activate the interface then disable it again
            //
            if (Error != NO_ERROR) {

                Trace1(ERR,
                    "Disabling interface(%d) as it could not be activated",
                    IfIndex);

                Error = ERROR_CAN_NOT_COMPLETE;
                
                GOTO_END_BLOCK1;
            }

         }

    } END_BREAKOUT_BLOCK1;

    //
    // if an error occured somewhere, set the interface back to the previous
    // disabled state.(pite may be null if interface was not found).
    //
    if ((Error!=NO_ERROR)&&(pite!=NULL)) {

        if (bChangedByRtrmgr)
            pite->Status &= ~IF_ENABLED_FLAG;
        else
            pite->pConfig->Flags &= DVMRP_IF_ENABLED_IN_CONFIG;
    }


    return Error;
    
}//end _EnableIfEntry


//-----------------------------------------------------------------------------
//            _DisableInterface
//
// If interface is activated, then deactivates it.
// Locks: Runs completely in exclusive interface lock.
// Calls: _DisableIfEntry()
//-----------------------------------------------------------------------------

DWORD
DisableInterface(
    IN DWORD IfIndex
    )
{
    DWORD Error;

    Trace1(ENTER, "entering DisableInterface(%d):", IfIndex);

    //
    // disable the interface
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_DisableInterface");

    Error = DisableIfEntry(IfIndex, TRUE); //disabled by RtrMgr

    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_DisableInterface");


    Trace2(LEAVE, "leaving DisableInterface(%d): %d\n", IfIndex, Error);

    return Error;
}


//-----------------------------------------------------------------------------
//          _DisableIfEntry
//
// Called by: _DisableInterface()
//-----------------------------------------------------------------------------

DWORD
DisableIfEntry(
    DWORD IfIndex,
    BOOL  bChangedByRtrmgr
    )
{
    DWORD                   Error = NO_ERROR;
    PIF_TABLE_ENTRY         pite, piteNew;
    BOOL                    bProxy;


    BEGIN_BREAKOUT_BLOCK1 {

        //
        // retrieve the interface to be disabled
        //
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Trace1(IF, "could not find interface %d", IfIndex);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        if (bChangedByRtrmgr) {
        
            //
            // quit if already disabled by router manager
            //
            if (!IS_IF_ENABLED_BY_RTRMGR(pite)) {
                Trace1(IF, "interface %d already disabled by router manager",
                        IfIndex);
                Error = ERROR_INVALID_PARAMETER;
                GOTO_END_BLOCK1;
            }
        }

        else {
            //
            // quit if already disabled in Config
            //
            if (!IS_IF_ENABLED_IN_CONFIG(pite)) {
                Trace1(IF, "interface %d already disabled in config",
                        IfIndex);
                Error = ERROR_INVALID_PARAMETER;
                GOTO_END_BLOCK1;
            }
        }


        //
        // if IF activated (ie also enabled), deactivate it
        // note: check for activated flag, and not for enabled flag
        //

        if (IS_IF_ACTIVATED(pite)) {
            DeactivateInterface(pite);
        }


        //
        // clear the enabled flag
        //
        if (bChangedByRtrmgr)
            pite->Status &= ~IF_ENABLED_FLAG;
        else
            pite->pConfig->Flags &= ~DVMRP_IF_ENABLED_IN_CONFIG;


    } END_BREAKOUT_BLOCK1;


    return Error;

} //end _DisableIfEntry


//-----------------------------------------------------------------------------
//          _CreateIfSockets
//-----------------------------------------------------------------------------

DWORD
CreateIfSockets(
    PIF_TABLE_ENTRY pite
    )
{
    DWORD           Error = NO_ERROR;

    DWORD           Retval, SockType;
    DWORD           IpAddr = pite->IpAddr;
    DWORD           IfIndex = pite->IfIndex;
    SOCKADDR_IN     saLocalIf;

    BEGIN_BREAKOUT_BLOCK1 {

        //
        // create input socket
        //
        
        pite->Socket = WSASocket(AF_INET, SOCK_RAW, IPPROTO_IGMP, NULL, 0, 0);

        if (pite->Socket == INVALID_SOCKET) {
            LPSTR lpszAddr;
            Error = WSAGetLastError();
            lpszAddr = INET_NTOA(IpAddr);
            Trace3(IF,
                "error %d creating socket for interface %d (%d.%d.%d.%d)",
                Error, IfIndex, PRINT_IPADDR(IpAddr));
            Logerr1(CREATE_SOCKET_FAILED_2, "%S", lpszAddr, Error);

            GOTO_END_BLOCK1;
        }


        //
        // bind socket to local interface. If I dont bind multicast may
        // not work.
        //

        ZeroMemory(&saLocalIf, sizeof(saLocalIf));
        saLocalIf.sin_family = PF_INET;
        saLocalIf.sin_addr.s_addr = IpAddr;
        saLocalIf.sin_port = 0;        //port shouldnt matter


        // bind the input socket

        Error = bind(pite->Socket, (SOCKADDR FAR *)&saLocalIf,
                    sizeof(SOCKADDR));

        if (Error == SOCKET_ERROR) {
            LPSTR lpszAddr;
            Error = WSAGetLastError();
            lpszAddr = INET_NTOA(IpAddr);
            Trace3(IF, "error %d binding on socket for interface %d (%d.%d.%d.%d)",
                Error, IfIndex, PRINT_IPADDR(IpAddr));
            Logerr1(BIND_FAILED, "S", lpszAddr, Error);

            GOTO_END_BLOCK1;
        }

        // set ttl to 1: not required as it is set to 1 by default.

        McastSetTtl(pite->Socket, 1);


        //
        // disable multicast packets from being loopedback.
        //

        {
            BOOL bLoopBack = FALSE;
            DWORD   Retval;

            Retval = setsockopt(pite->Socket, IPPROTO_IP, IP_MULTICAST_LOOP,
                                   (char *)&bLoopBack, sizeof(BOOL));

            if (Retval==SOCKET_ERROR) {
                Trace2(ERR, "error %d disabling multicast loopBack on IfIndex %d",
                    WSAGetLastError(), IfIndex);
            }
        }


        //
        // set the interface on which multicasts must be sent
        //

        Retval = setsockopt(pite->Socket, IPPROTO_IP, IP_MULTICAST_IF,
                            (PBYTE)&saLocalIf.sin_addr, sizeof(IN_ADDR));

        if (Retval == SOCKET_ERROR) {
            LPSTR lpszAddr;
            Error = WSAGetLastError();
            lpszAddr = INET_NTOA(pite->IpAddr);
            Trace3(IF, "error %d setting interface %d (%s) to send multicast",
                    Error, IfIndex, lpszAddr);
            Logerr1(SET_MCAST_IF_FAILED, "%S", lpszAddr, Error);
            Error = Retval;
            GOTO_END_BLOCK1;
        }


        //
        // join dvmrp multicast group
        //
        
        JoinMulticastGroup(pite->Socket, ALL_DVMRP_ROUTERS_MCAST_GROUP,
            pite->IfIndex, pite->IpAddr);
            

        //  bind socket to io completion port
        
        BindIoCompletionCallback((HANDLE)pite->Socket,
            ProcessAsyncReceivePacket, 0);


        // increment refcount corresponding to the pending IO requests
        
        pite->RefCount++;

        
        // post async Read request

#if 0
        // kslksl
        PostAsyncRead(pite);
#endif 

        
    } END_BREAKOUT_BLOCK1;

    if (Error!=NO_ERROR)
        DeleteIfSockets(pite);

    return Error;

} //end _CreateIfSockets        

VOID
DeleteIfSockets(
    PIF_TABLE_ENTRY pite
    )
{

    return;
}



//-----------------------------------------------------------------------------
//             _ActivateInterface
//
// an interface is activated: when it is bound, enabled by RtrMgr & in config
// When activated,
// (1) call is made to MGM to take interface ownership,
// (2) timers set and input socket is activated.
//
// Called by: _BindIfEntry, _EnableIfEntry,
//-----------------------------------------------------------------------------
    
DWORD
ActivateInterface(
    PIF_TABLE_ENTRY pite
    )
{
    DWORD               Error = NO_ERROR, IfIndex = pite->IfIndex;
    LONGLONG            CurTime = GetCurrentDvmrpTime();

    

    Trace2(ENTER, "entering ActivateInterface(%d:%d.%d.%d.%d)",
                IfIndex, PRINT_IPADDR(pite->IpAddr));


    BEGIN_BREAKOUT_BLOCK1 {

        //
        // set time when it is activated
        //
        pite->pInfo->TimeWhenActivated = CurTime;


        //
        // create sockets for interface
        //
        
        Error = CreateIfSockets(pite);

        if (Error != NO_ERROR) {

            Trace2(IF, "error %d initializing sockets for interface %d",
                Error, pite->IfIndex);
            GOTO_END_BLOCK1;
        }

        pite->CreationFlags |= IF_FLAGS_SOCKETS_CREATED;

        

        //
        // register the protocol with mgm if it is the first active IF
        //

        if (!G_pIfTable->NumActiveIfs++) {
        
            Error = RegisterDvmrpWithMgm();
            if (Error!=NO_ERROR) {
                G_pIfTable->NumActiveIfs--;
                GOTO_END_BLOCK1;
            }
        }
        pite->CreationFlags |= IF_FLAGS_PROTO_REGISTERED_WITH_MGM;
        


        //
        // take interface ownership with MGM
        //
        
        Error = MgmTakeInterfaceOwnership(Globals.MgmDvmrpHandle, IfIndex, 0);

        if (Error!=NO_ERROR) {
            Trace1(MGM, "MgmTakeInterfaceOwnership rejected for interface %d",
                IfIndex);
            Logerr0(MGM_TAKE_IF_OWNERSHIP_FAILED, Error);
            GOTO_END_BLOCK1;
        }
        else {
            Trace1(MGM,
                "MgmTakeInterfaceOwnership successful for interface %d",
                IfIndex);
        }
        pite->CreationFlags |= IF_FLAGS_IF_REGISTERED_WITH_MGM;


        //
        // dvmrp does a (*,*) join
        //

        Error = MgmAddGroupMembershipEntry(Globals.MgmDvmrpHandle, 0, 0, 0, 0,
                                           IfIndex, 0);
        if (Error!=NO_ERROR) {
            Trace1(ERR,
                "Dvmrp failed to add *,* entry to MGM on interface %d",
                IfIndex);
            GOTO_END_BLOCK1;
        }

       Trace0(MGM, "Dvmrp added *,* entry to MGM");


       //
       // create required timers
       //


       
    } END_BREAKOUT_BLOCK1;


    //
    // if error, deactivate interface
    //
    
    if (Error!=NO_ERROR) {

        DeactivateInterface(pite);

        pite->Status &= ~IF_ACTIVATED_FLAG;

    }
    else {

        //
        // set interface status to activated
        //
        
        pite->Status |= IF_ACTIVATED_FLAG;

    }
    
    Trace1(LEAVE, "leaving ActivateInterface():%d\n", Error);

    return Error;

} //end _ActivateInterface



DWORD
DeactivateInterface(
    PIF_TABLE_ENTRY pite
    )
{
    DWORD Error;

    // zero info

    Error = NO_ERROR;
    
    return Error;
}




//-----------------------------------------------------------------------------
//            UnBindInterface
//-----------------------------------------------------------------------------

DWORD
UnBindInterface(
    IN DWORD IfIndex
    )
{
    DWORD Error;
    PIF_TABLE_ENTRY pite, piteNew;

    
    Trace1(ENTER, "entering UnBindInterface(%d):", IfIndex);

    //
    // unbind the interface
    //

    //
    // acquire exclusive interface lock
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_UnBindInterface");



    BEGIN_BREAKOUT_BLOCK1 {

        //
        // retrieve the interface specified
        //
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Trace1(ERR, "UnbindInterface called for non existing If(%d)",
                IfIndex);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        //
        // quit if the interface is already unbound
        //
        if (!IS_IF_BOUND(pite)) {

            Error = ERROR_INVALID_PARAMETER;
            Trace1(ERR, "interface %d is already unbound", IfIndex);
            GOTO_END_BLOCK1;
        }


        //
        // clear the "bound" flag
        //
        pite->Status &= ~IF_BOUND_FLAG;


        
        //
        // if IF activated (ie also enabled), deactivate it
        // note: check for activated flag, and not for enabled flag
        //
        
        if (IS_IF_ACTIVATED(pite)) {

            DeactivateInterface(pite);
        }


        //
        //  unbind IF
        //

        DVMRP_FREE_AND_NULL(pite->pBinding);
        pite->NumAddrBound = 0;
        pite->IpAddr = 0;


    } END_BREAKOUT_BLOCK1;

    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_UnBindInterface");


    Trace2(LEAVE, "leaving UnBindInterface(%d): %d\n", IfIndex, Error);

    return Error;

}

//----------------------------------------------------------------------------
// _SetInterfaceConfigInfo
//----------------------------------------------------------------------------

DWORD
WINAPI
SetInterfaceConfigInfo(
    IN DWORD IfIndex,
    IN PVOID pvConfig,
    IN ULONG ulStructureVersion,
    IN ULONG ulStructureSize,
    IN ULONG ulStructureCount
    )
{
    DWORD       Error = NO_ERROR;
    return Error;
}



//----------------------------------------------------------------------------
// _GetInterfaceConfigInfo
//----------------------------------------------------------------------------

DWORD
WINAPI
GetInterfaceConfigInfo(
    IN     DWORD  IfIndex,
    IN OUT PVOID  pvConfig,
    IN OUT PDWORD pdwSize,
    IN OUT PULONG pulStructureVersion,
    IN OUT PULONG pulStructureSize,
    IN OUT PULONG pulStructureCount
    )
{

    DWORD       Error = NO_ERROR;
    return Error;
}


//----------------------------------------------------------------------------
//      _ValidateIfConfig
//----------------------------------------------------------------------------

DWORD
ValidateIfConfig(
    ULONG IfIndex,
    PDVMRP_IF_CONFIG pIfConfig,
    ULONG StructureSize
    )
{
    //
    // check IfConfig size
    //
    
    if (StructureSize < sizeof(DVMRP_IF_CONFIG) 
        || (StructureSize != DVMRP_IF_CONFIG_SIZE(pIfConfig))
        ){
    
        Trace1(ERR, "Dvmrp config structure for interface:%d too small.\n",
            IfIndex);

        return ERROR_INVALID_DATA;
    }

    DebugPrintIfConfig(IfIndex, pIfConfig);

    //
    // check Probe Interval
    //

    if (pIfConfig->ProbeInterval != DVMRP_PROBE_INTERVAL) {

        Trace2(CONFIG,
            "ProbeInterval being set to %d. Suggested value:%d",
            pIfConfig->ProbeInterval, DVMRP_PROBE_INTERVAL);
    }


    if (pIfConfig->ProbeInterval < 1000) {

        Trace2(ERR,
            "ProbeInterval has very low value:%d, suggested:%d",
            pIfConfig->ProbeInterval, DVMRP_PROBE_INTERVAL);
            
        return ERROR_INVALID_DATA;
    }


    //
    // check Peer timeout interval
    //

    if (pIfConfig->PeerTimeoutInterval != PEER_TIMEOUT_INTERVAL) {

        Trace2(CONFIG,
            "PeerTimeoutInterval being set to %d. Suggested value:%d",
            pIfConfig->PeerTimeoutInterval, PEER_TIMEOUT_INTERVAL);
    }


    if (pIfConfig->PeerTimeoutInterval < 1000) {

        Trace2(ERR,
            "PeerTimeoutInterval has very low value:%d, suggested:%d",
            pIfConfig->PeerTimeoutInterval, PEER_TIMEOUT_INTERVAL);
            
        return ERROR_INVALID_DATA;
    }


    //
    // check MinTriggeredUpdateInterval
    //

    if (pIfConfig->MinTriggeredUpdateInterval
        != MIN_TRIGGERED_UPDATE_INTERVAL
        ) {

        Trace2(CONFIG,
            "MinTriggeredUpdateInterval being set to %d. Suggested value:%d",
            pIfConfig->MinTriggeredUpdateInterval,
            MIN_TRIGGERED_UPDATE_INTERVAL);
    }

    //
    // check PeerFilterMode
    //

    switch(pIfConfig->PeerFilterMode) {
    
        case DVMRP_FILTER_DISABLED:
        case DVMRP_FILTER_INCLUDE:
        case DVMRP_FILTER_EXCLUDE:
        {
            break;
        }

        default:
        {
            Trace2(ERR, "Invalid value:%d for PeerFilterMode on Interface:%d",
                pIfConfig->PeerFilterMode, IfIndex);
                
            return ERROR_INVALID_DATA;
        }
    }
        
    
} //end _ValidateIfConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\debug.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// Module Name: debug.h
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================


VOID
DebugPrintGlobalConfig(
    PDVMRP_GLOBAL_CONFIG pGlobalConfig
    );

VOID
DebugPrintIfConfig(
    ULONG IfIndex,
    PDVMRP_IF_CONFIG pIfConfig
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\dvmrp.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: dvmrp.h
//
// Abstract:
//      Contains type definitions and declarations for Dvmrp
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//
// Revision History:
//=============================================================================

#ifndef _DVMRP_H_
#define _DVMRP_H_



//----------------------------------------------------------------------------
// constants identifying DVMRPs MIB tables. The "TypeId" is set to this value
//
// DVMRP_GLOBAL_CONFIG_ID : returns the global config
// DVMRP_GLOBAL_STATS_ID  : returns the global statistics
// DVMRP_IF_BINDING_ID    : returns list of bindings for each interface
// DVMRP_IF_CONFIG_ID     : returns the config info for an interface
// DVMRP_IF_STATS_ID      : returns the stats for an interface
//----------------------------------------------------------------------------

#define DVMRP_GLOBAL_CONFIG_ID              0
#define DVMRP_GLOBAL_STATS_ID               1
#define DVMRP_IF_BINDING_ID                 2
#define DVMRP_IF_CONFIG_ID                  3
#define DVMRP_IF_STATS_ID                   4
#define DVMRP_LAST_TABLE_ID                 7



//----------------------------------------------------------------------------
// constants used for the field DVMRP_GLOBAL_CONFIG::LoggingLevel
//----------------------------------------------------------------------------

#define DVMRP_LOGGING_NONE                  0
#define DVMRP_LOGGING_ERROR                 1
#define DVMRP_LOGGING_WARN                  2
#define DVMRP_LOGGING_INFO                  3


//----------------------------------------------------------------------------
// DVMRP_GLOBAL_CONFIG
//----------------------------------------------------------------------------

typedef struct _DVMRP_GLOBAL_CONFIG {

    USHORT      MajorVersion;
    USHORT      MinorVersion;
    DWORD       LoggingLevel;
    DWORD       RouteReportInterval;
    DWORD       RouteExpirationInterval;
    DWORD       RouteHolddownInterval;
    DWORD       PruneLifetimeInterval;
    
} DVMRP_GLOBAL_CONFIG, *PDVMRP_GLOBAL_CONFIG;

// defaults

#define DVMRP_ROUTE_REPORT_INTERVAL          60000
#define DVMRP_ROUTE_EXPIRATION_INTERVAL     140000
#define DVMRP_ROUTE_HOLDDOWN_INTERVAL       (2*DVMRP_ROUTE_REPORT_INTERVAL)
#define DVMRP_PRUNE_LIFETIME_INTERVAL      7200000


//----------------------------------------------------------------------------
// DVMRP_ADDR_MASK, DVMRP_PEER_FILTER
//----------------------------------------------------------------------------

typedef struct _DVMRP_ADDR_MASK {
    DWORD       IpAddr;
    DWORD       Mask;
} DVMRP_ADDR_MASK, *PDVMRP_ADDR_MASK;

typedef DVMRP_ADDR_MASK   DVMRP_PEER_FILTER;
typedef PDVMRP_ADDR_MASK  PDVMRP_PEER_FILTER;


//----------------------------------------------------------------------------
// DVMRP_IF_CONFIG
//----------------------------------------------------------------------------

typedef struct _DVMRP_IF_CONFIG {

    DWORD       ConfigIpAddr;   // effective addr can be assigned in config
    DWORD       Status;         // Read only
    DWORD       Flags;
    DWORD       Metric;
    DWORD       ProbeInterval;
    DWORD       PeerTimeoutInterval;
    DWORD       MinTriggeredUpdateInterval;
    DWORD       PeerFilterMode;
    DWORD       NumPeerFilters;
    
} DVMRP_IF_CONFIG, *PDVMRP_IF_CONFIG;


#define GET_FIRST_DVMRP_PEER_FILTER(pIfConfig) \
    (PDVMRP_PEER_FILTER) (((PDVMRP_IF_CONFIG) pIfConfig) + 1)


#define DVMRP_IF_CONFIG_SIZE(pIfConfig) \
    (sizeof(DVMRP_IF_CONFIG) \
    + (pIfConfig->NumPeerFilters*sizeof(DVMRP_PEER_FILTER)))
    

#define DVMRP_PROBE_INTERVAL                10000
#define PEER_TIMEOUT_INTERVAL               35000
#define MIN_TRIGGERED_UPDATE_INTERVAL        5000


//
// values for Flags
//

#define DVMRP_IF_ENABLED_IN_CONFIG 0x0001

#define IS_DVMRP_IF_ENABLED_FLAG_SET(Flags) \
                ((Flags) & DVMRP_IF_ENABLED_IN_CONFIG)



//----------------------------------------------------------------------------
// Constants used for DVMRP_IF_CONFIG.PeerFilterMode
//----------------------------------------------------------------------------

#define DVMRP_FILTER_DISABLED               0
#define DVMRP_FILTER_INCLUDE                1
#define DVMRP_FILTER_EXCLUDE                2


/*
 * DVMRP message types and flag values shamelessly stolen from
 * mrouted/dvmrp.h.
 */
#define DVMRP_PROBE         1   /* for finding neighbors */
#define DVMRP_REPORT        2   /* for reporting some or all routes */
#define DVMRP_ASK_NEIGHBORS 3   /* sent by mapper, asking for a list */
                                /*
                                 * of this router's neighbors
                                 */
    
#define DVMRP_NEIGHBORS     4   /* response to such a request */
#define DVMRP_ASK_NEIGHBORS2 5  /* as above, want new format reply */
#define DVMRP_NEIGHBORS2	6
#define DVMRP_PRUNE         7   /* prune message */
#define DVMRP_GRAFT         8   /* graft message */
#define DVMRP_GRAFT_ACK     9   /* graft acknowledgement */    

    
#endif // _DVMRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\dvmrptimer.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: igmptimer.c
//
// Abstract: This module implements the igmptimer
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================



#include "pchigmp.h"


#if DEBUG_TIMER_LEVEL & DEBUG_TIMER_TIMERID
    DWORD TimerId =0;
#endif


//------------------------------------------------------------------------------
//
// FUNCTION PROTOTYPES USED ONLY IN THIS FILE
//

VOID
SetNextTime(
    LONGLONG     llCurTime,
    DWORD        dwLowIndex
    );

VOID 
ResyncTimerBuckets( 
    LONGLONG llCurTime
    );
VOID    
InsertTimerInSortedList(
    PIGMP_TIMER_ENTRY    pteNew,
    PLIST_ENTRY          pHead
    );


//------------------------------------------------------------------------------
//
// #DEFINES USED ONLY IN THIS FILE
//

//
//approx 16 secs in each bucket: 
//it is approx not accurate as I divide by 2^10 instead of 1000
//TIMER_BUCKET_GRANULARITY should be 2^TIMER_BUCKET_GRANULARITY_SHIFT
//
#define TIMER_BUCKET_GRANULARITY        16
#define TIMER_BUCKET_GRANULARITY_SHIFT   4


#define SEC_CONV_SHIFT                  10
#define TIMER_BUCKET_GRANULARITY_ABS    \
        ((LONGLONG) (1 << (TIMER_BUCKET_GRANULARITY_SHIFT + SEC_CONV_SHIFT) ))


#define MAP_TO_BUCKET(dwBucket, ilTime) \
    dwBucket = (DWORD) (((ilTime)-g_TimerStruct.SyncTime) \
                        >> (TIMER_BUCKET_GRANULARITY_SHIFT+SEC_CONV_SHIFT)); \
    dwBucket = dwBucket>NUM_TIMER_BUCKETS-1? NUM_TIMER_BUCKETS-1:  dwBucket


// I fire a timer even if it is set to 10 millisec in the future.
#define FORWARD_TIMER_FIRED 10

//------------------------------------------------------------------------------



    
//------------------------------------------------------------------------------
//          _InsertTimer
//
// Inserts a timer into the local timer queue. Time should always be relative.
//
// Locks: Assumes lock taken on ptg->CS
//------------------------------------------------------------------------------

DWORD
InsertTimer (
    PIGMP_TIMER_ENTRY    pte,
    LONGLONG             llNewTime,
    BOOL                 bResync
    )
{
    LONGLONG             llCurTime = GetCurrentIgmpTime();
    PIGMP_TIMER_GLOBAL   ptg;
    DWORD                dwBucket, Error = NO_ERROR;
    

    // InsertTimer shouldnt be called when time is active
    
    if (pte->Status & TIMER_STATUS_ACTIVE) {
        Trace0(ERR, "ERROR: INSERT TIMER BEING CALLED INSTEAD OF UPDATE TIMER");
        UpdateLocalTimer(pte, llNewTime);
        return NO_ERROR;
    }


    
    Trace0(ENTER1, "_InsertTimer()");


    // print the queue before inserting the timer
    
    #if DEBUG_TIMER_INSERTTIMER1
        Trace0(TIMER1, "Printing Timer Queue before InsertTimer");
        DebugPrintTimerQueue();
    #endif


    ptg = &g_TimerStruct;
    


    // convert relative time to absolute time
    llNewTime += llCurTime;

    
    pte->Timeout = llNewTime;

    
    MAP_TO_BUCKET(dwBucket, pte->Timeout);


    // print info about the timer being inserted
    
    #if DEBUG_TIMER_ACTIVITY
    {    
        DWORD   dwBucket, dwDiffTime;
        CHAR    str1[20], str2[20];

        MAP_TO_BUCKET(dwBucket, pte->Timeout);
        GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

        Trace7(TIMER, "Inserting timer  <%d><%d><%d> Timeout:%lu   <%s> "
                "<%s> Status:%d", dwBucket, pte->Id, pte->Id2, dwDiffTime, 
                str1, str2, pte->Status);
    }
    #endif

    
    //
    // insert timer in appropriate list
    //
    
    if (dwBucket==0) {    // bucket 0 contains a sorted list
    
        InsertTimerInSortedList(pte, &ptg->TimesTable[0]);
    }
    else {
        InsertTailList(&ptg->TimesTable[dwBucket], &pte->Link);

    }



    ptg->NumTimers++;
    ptg->TableLowIndex = ptg->TableLowIndex<dwBucket
                            ? ptg->TableLowIndex : dwBucket;


    //resynchronize timer list
    
    if (bResync) {
        if ( (ptg->TableLowIndex!=0) 
                && (ptg->SyncTime + TIMER_BUCKET_GRANULARITY_ABS < llCurTime) ) {
            
            ResyncTimerBuckets(llCurTime);
        }
    }


    //
    // if time being inserted is lower than the minimum, then update wait timer
    //
    if ((IS_TIMER_INFINITE(ptg->WTTimeout)) || (pte->Timeout<=ptg->WTTimeout)) {
        ptg->WTTimeout = pte->Timeout;

        if (!IS_TIMER_INFINITE(ptg->WTTimeout)) {

            BOOL bSuccess ;
            
            bSuccess = ChangeTimerQueueTimer(ptg->WTTimer, ptg->WTTimer1,
                        (ULONG) ((ptg->WTTimeout - llCurTime)),
                        1000000                   // set a periodic timer
                        );
            if (!bSuccess) {
                Error = GetLastError();
                Trace1(ERR, "ChangeTimerQueueTimer returned error:%d", Error);
            }
            else
                Trace1(TIMER1, "ChangeTimerQueueTimer set to %lu",
                            (ULONG) ((ptg->WTTimeout - llCurTime))/1000);
        }
    }

    pte->Status = TIMER_STATUS_ACTIVE;


    #if EXTEND_DEBUG_INSERTTIMER2
        Trace0(TIMER1, "Printing Timer Queue after _InsertTimer");
        DebugPrintTimerQueue();
    #endif

    
    Trace0(LEAVE1, "Leaving _InsertTimer()");
    return NO_ERROR;
    
} //end _InsertTimer



//------------------------------------------------------------------------------
//            _UpdateLocalTimer
//
// Change the time in a timer structure and (re)insert it in the timer queue.
// Locks: Assumes lock on the global timer
//------------------------------------------------------------------------------

VOID    
UpdateLocalTimer (
    PIGMP_TIMER_ENTRY    pte,
    LONGLONG             llNewTime
    )
{

    Trace0(ENTER1, "_UpdateLocalTimer():");


    if (!(pte->Status&TIMER_STATUS_ACTIVE))
        Trace0(ERR, "ERROR: UPDATE BEING CALLED INSTEAD OF INSERT TIMER");



    // print info about the timer being updated
    
    #if DEBUG_TIMER_ACTIVITY
    {    
        DWORD       dwBucket, dwDiffTime;
        CHAR        str1[20], str2[20];
        LONGLONG    llCurTime = GetCurrentIgmpTime();

        
        MAP_TO_BUCKET(dwBucket, pte->Timeout);
        GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

        Trace8(TIMER, "Updating timer  <%d><%d><%d> Timeout:%lu   <%s> <%s> "
                    "to %d Status:%d", dwBucket, pte->Id, pte->Id2, dwDiffTime,
                    str1, str2, (DWORD)llNewTime, pte->Status);
    }
    #endif


    // first remote the timer
    
    if (pte->Status&TIMER_STATUS_ACTIVE) {
        RemoveTimer(pte);
    }


    // now insert the timer back into the timer queue. Resync flag is set
    
    InsertTimer(pte, llNewTime, TRUE);

   

    Trace0(LEAVE1, "_UpdateLocalTimer()");
    return;    
}




//------------------------------------------------------------------------------
//            _RemoveTimer
//
// Removes the timer from the list. Changes the status of the timer to CREATED.
// Assumes global timer lock.
//------------------------------------------------------------------------------

VOID
RemoveTimer (
    PIGMP_TIMER_ENTRY    pte
    )
{
    LONGLONG            llCurTime = GetCurrentIgmpTime();
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    

    Trace0(ENTER1, "_RemoveTimer()");
    

    // print info about the timer being removed
    
    #if DEBUG_TIMER_REMOVETIMER1
    {    
        DWORD   dwBucket, dwDiffTime;
        CHAR    str1[20], str2[20];

        
        MAP_TO_BUCKET(dwBucket, pte->Timeout);
        GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

        Trace7(TIMER, "Removing timer  <%d><%d><%d> Timeout:%lu   <%s> <%s> "
                    "Status:%d", dwBucket, pte->Id, pte->Id2, dwDiffTime, str1, 
                    str2, pte->Status);
    }
    #endif
    


    // remove the timer from the timer queue and decrement the number of timers
    
    RemoveEntryList(&pte->Link);
    ptg->NumTimers--;
    


    // reset the minimum timeout for the timer queue, if this timer was the min
    
    if (pte->Timeout==ptg->WTTimeout) {
        
        SetNextTime(llCurTime, ptg->TableLowIndex);
    }


    // reset the timer status to created
    
    pte->Status = TIMER_STATUS_CREATED;


    // print timer queue
    
    #if DEBUG_TIMER_REMOVETIMER2
        Trace0(TIMER1, "Printing Timer Queue after _RemoveTimer");
        DebugPrintTimerQueue();
    #endif

    
    Trace0(LEAVE1, "Leaving _RemoveTimer()");
    return;
}


//------------------------------------------------------------------------------
//          _SetNextTime
// called when a timer==WTTimeout has been removed or fired,used to set the
// next min time.
//------------------------------------------------------------------------------
VOID
SetNextTime (
    LONGLONG     llCurTime,
    DWORD        dwLowIndex
    )
{
    PIGMP_TIMER_GLOBAL    ptg = &g_TimerStruct;
    PIGMP_TIMER_ENTRY     pte, pteMin;
    LONGLONG              ilMinTime;
    PLIST_ENTRY           pHead, ple;
    DWORD                 Error = NO_ERROR;
    

    Trace0(ENTER1, "entering _SetNextTime()");

    
    //
    // if timer list empty, set lowIndex, and timer to infinite, and return.
    //
    if (ptg->NumTimers==0) {
        ptg->TableLowIndex = (DWORD)~0;
        SET_TIMER_INFINITE(ptg->WTTimeout);
        ptg->Status = TIMER_STATUS_INACTIVE;    
        return;
    }



    //
    // find lowest table index having an entry
    //
    if (dwLowIndex>NUM_TIMER_BUCKETS-1) 
        dwLowIndex = 0;

    for (;  dwLowIndex<=NUM_TIMER_BUCKETS-1;  dwLowIndex++) {
        if (IsListEmpty(&ptg->TimesTable[dwLowIndex]) )
            continue;
        else
            break;
    }

    ptg->TableLowIndex = dwLowIndex;

    

    //
    // find timer entry with the lowest time
    //
    if (dwLowIndex==0) {
        pteMin = CONTAINING_RECORD(ptg->TimesTable[0].Flink, 
                                    IGMP_TIMER_ENTRY, Link);
    }
    else {

        // except bucket[0], other buckets are not sorted
        
        pHead = &ptg->TimesTable[dwLowIndex];
        ilMinTime = (((LONGLONG)0x7FFFFFF)<<32)+ ~0;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            pte = CONTAINING_RECORD(ptg->TimesTable[dwLowIndex].Flink, 
                                    IGMP_TIMER_ENTRY, Link);
            if (pte->Timeout<ilMinTime) {
                ilMinTime = pte->Timeout;
                pteMin = pte;
            }
        }
    }


    //
    // update global time
    //
    if ((IS_TIMER_INFINITE(ptg->WTTimeout)) 
            || (pteMin->Timeout<=ptg->WTTimeout)) 
    {
        ptg->WTTimeout = pteMin->Timeout;


        if (!IS_TIMER_INFINITE(ptg->WTTimeout)) {

            BOOL bSuccess ;
            
            bSuccess = ChangeTimerQueueTimer(ptg->WTTimer, ptg->WTTimer1,
                        (ULONG) ((ptg->WTTimeout - llCurTime)),
                        1000000                   // set a periodic timer
                        );
            if (!bSuccess) {
                Error = GetLastError();
                Trace1(ERR, "ChangeTimerQueueTimer returned error:%d in SetNextTime",
                        Error);
            }
            else
                Trace1(TIMER1, "ChangeTimerQueueTimer set to %lu",
                            (ULONG) ((ptg->WTTimeout - llCurTime))/1000);
        }
            
        ptg->Status = TIMER_STATUS_ACTIVE;
    }


    //
    // resynchronize timer list if required
    //
    if ( (ptg->TableLowIndex!=0) 
            && (ptg->SyncTime + TIMER_BUCKET_GRANULARITY_ABS > llCurTime) ) {
        
        ResyncTimerBuckets(llCurTime);
    }


    Trace0(LEAVE1, "_SetNextTime()");
    return; 
    
} //end _SetNextTime



//------------------------------------------------------------------------------
//          _InitializeIgmpTime
// Initialize the igmp absolute timer
//------------------------------------------------------------------------------

VOID
InitializeIgmpTime(
    )
{
    g_TimerStruct.CurrentTime.HighPart = 0;
    g_TimerStruct.CurrentTime.LowPart = GetTickCount();
    return;
}


//------------------------------------------------------------------------------
//          _GetCurrentIgmpTimer
// uses GetTickCount(). converts it into 64 bit absolute timer.
//------------------------------------------------------------------------------
LONGLONG
GetCurrentIgmpTime(
    )
{
    ULONG   ulCurTimeLow = GetTickCount();


    //
    // see if timer has wrapped
    //
    // since multi-threaded, it might get preempted and CurrentTime
    // might get lower than the global variable g_TimerStruct.CurrentTime.LowPart
    // which might be set by another thread. So we also explicitly verify the
    // switch from a very large DWORD to a small one.
    // (code thanks to murlik&jamesg)
    //
    
    if ( (ulCurTimeLow < g_TimerStruct.CurrentTime.LowPart) 
        && ((LONG)g_TimerStruct.CurrentTime.LowPart < 0)
        && ((LONG)ulCurTimeLow > 0) )
    {


        // use global CS instead of creating a new CS
        
        ACQUIRE_GLOBAL_LOCK("_GetCurrentIgmpTime");


        // make sure that the global timer has not been updated meanwhile
        
        if ( (LONG)g_TimerStruct.CurrentTime.LowPart < 0) 
        {
            g_TimerStruct.CurrentTime.HighPart++;
            g_TimerStruct.CurrentTime.LowPart = ulCurTimeLow;
        }
        
        RELEASE_GLOBAL_LOCK("_GetCurrentIgmpTime");
    
    }    
    g_TimerStruct.CurrentTime.LowPart = ulCurTimeLow;


    return g_TimerStruct.CurrentTime.QuadPart;
}



//------------------------------------------------------------------------------
//        _WF_ProcessTimerEvent
//
// Processes the timer queue, firing events and sets the next timer at the end.
// Is queued by the Wait Server Thread.
// 
// Locks: Acquires global timer lock before entering into the timer queue.
//------------------------------------------------------------------------------
VOID
WF_ProcessTimerEvent (
    PVOID    pContext
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    LONGLONG            ilDiffTime, llCurTime = GetCurrentIgmpTime();
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         pHead, ple;
    PIGMP_TIMER_ENTRY   pte;
    LONGLONG            llFiredTimeout;

    
    if (!EnterIgmpWorker()) {return;}
    
    Trace0(ENTER1, "Entering _WF_ProcessTimerEvent");


    // acquire timer lock
    
    ACQUIRE_TIMER_LOCK("_WF_ProcessTimerEvent");


    // print the timer queue

    #if  DEBUG_TIMER_PROCESSQUEUE1
        Trace0(TIMER1, "Printing Timer Queue before processing the timer queue");
        DebugPrintTimerQueue();
    #endif
    

    BEGIN_BREAKOUT_BLOCK1 {
    
            
        // I fire a timer if it is set to within + FORWARD_TIMER_FIRED from now
        llFiredTimeout = llCurTime + FORWARD_TIMER_FIRED;
        
        

        // if there are no timers, then I am done
        
        if (ptg->NumTimers<1) {
            Trace1(TIMER1, "Num timers%d less than 1 in _WF_ProcessTimerEvent", 
                    ptg->NumTimers);
            GOTO_END_BLOCK1;
        }


        
        //
        // find all the timers with lower timeouts and fire callbacks in my context
        //
        for ( ;  ptg->TableLowIndex <= NUM_TIMER_BUCKETS-1;  ptg->TableLowIndex++) {

            pHead = &ptg->TimesTable[ptg->TableLowIndex];
        
            for (ple=pHead->Flink;  ple!=pHead;  ) {
            
                pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
                
                ple = ple->Flink;

                // this timer is fired
                if (pte->Timeout < llFiredTimeout) {
                
                    RemoveEntryList(&pte->Link);
                    pte->Status = TIMER_STATUS_FIRED;
                    ptg->NumTimers --;

                    //or should i queue to other worker threads
                            
                    (pte->Function)(pte->Context);
                    
                }
                else {

                    if (ptg->TableLowIndex==0) //only the 1st bucket is sorted
                        break;
                }
            }

            // if any bucket is empty, then I am done, as I start with LowIndex
            if (!IsListEmpty(&ptg->TimesTable[ptg->TableLowIndex])) 
                break;  
                
        } //end for loop


        if ( (ptg->TableLowIndex!=0) 
                && (ptg->SyncTime + TIMER_BUCKET_GRANULARITY_ABS < llCurTime) ) {
            
            ResyncTimerBuckets(llCurTime);
        }

        
        //
        // set the next lowest time
        //
        SET_TIMER_INFINITE(ptg->WTTimeout);
        SetNextTime(llCurTime, ptg->TableLowIndex);


    } END_BREAKOUT_BLOCK1;


    // print the timer queue

    #if  DEBUG_TIMER_PROCESSQUEUE2
        Trace0(TIMER1, "Printing Timer Queue after processing the timer queue");
        DebugPrintTimerQueue();
    #endif

                
    RELEASE_TIMER_LOCK("_WF_ProcessTimerEvent");

    Trace0(LEAVE1, "Leaving _WF_ProcessTimerEvent()");
    LeaveIgmpWorker();
    return ;
    
} //end _WF_ProcessTimerEvent



//------------------------------------------------------------------------------
//                WT_ProcessTimerEvent
// 
// Callback: fired when the timer set by this dll is timed out by the NtdllTimer
//------------------------------------------------------------------------------

VOID
WT_ProcessTimerEvent (
    PVOID    pContext,
    BOOLEAN  Unused
    )
{    
    //enter/leaveIgmpApi not required as the timer queue is persistent

    Trace0(ENTER1, "Entering _WT_ProcessTimerEvent()");

    QueueIgmpWorker((LPTHREAD_START_ROUTINE)WF_ProcessTimerEvent, pContext);
    
    Trace0(LEAVE1, "Leaving _WT_ProcessTimerEvent()");

    return;
}



//------------------------------------------------------------------------------
//            _InsertTimerInSortedList
// Used to insert a timer in the sorted bucket=0 
//------------------------------------------------------------------------------
VOID    
InsertTimerInSortedList(
    PIGMP_TIMER_ENTRY    pteNew,
    PLIST_ENTRY          pHead
    )
{
    PLIST_ENTRY             ple;
    PIGMP_TIMER_ENTRY       pte;
    LONGLONG                llNewTime;


    llNewTime = pteNew->Timeout;
    
    
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
        pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
        if (llNewTime<= pte->Timeout)
            break;
    }

    InsertTailList(ple, &pteNew->Link);

    return;
}



//------------------------------------------------------------------------------
//          _ResyncTimerBuckets
//
// Called during insert: when the 1st bucket is empty, and other buckets have
// to be moved left   
//------------------------------------------------------------------------------

VOID 
ResyncTimerBuckets( 
    LONGLONG llCurTime
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    PLIST_ENTRY         pHead, ple, pleCur;
    LIST_ENTRY          le;
    PIGMP_TIMER_ENTRY   pte;
    LONGLONG            lastBucketTime;
    DWORD               numShift, dwCount, dwBucket, i, j;

    TraceEnter("_ResyncTimerBuckets()");


    //
    // SyncTime should always be <= to currentTime
    //
    numShift = 0;
    while (ptg->SyncTime+TIMER_BUCKET_GRANULARITY_ABS <= llCurTime) {
        if (!IsListEmpty(&ptg->TimesTable[numShift]))
            break;
            
        ptg->SyncTime += TIMER_BUCKET_GRANULARITY_ABS;
        numShift++;
    }

    if (numShift==0)
        return;


    //
    // shift all buckets left, except for the last bucket and reinitialize the 
    // list heads
    //
    for (i=0,j=numShift;  i<NUM_TIMER_BUCKETS-1-numShift;  i++,j++) {
        if (IsListEmpty(&ptg->TimesTable[j])) {
            ptg->TimesTable[j].Flink = ptg->TimesTable[j].Blink 
                                         = &ptg->TimesTable[i];
        }
        else {
            ptg->TimesTable[j].Flink->Blink = &ptg->TimesTable[i];
            ptg->TimesTable[j].Blink->Flink = &ptg->TimesTable[i];
        }
    }

    
    MoveMemory( (PVOID)&(ptg->TimesTable[0]),  
                (VOID *)&(ptg->TimesTable[numShift]),
                 (sizeof(LIST_ENTRY) * (NUM_TIMER_BUCKETS-1-numShift))
                 );

    for (dwCount=1;  dwCount<=numShift;  dwCount++)
        InitializeListHead(&ptg->TimesTable[NUM_TIMER_BUCKETS-1-dwCount]);



    //
    // go through the last bucket and redistribute it
    //
    lastBucketTime = ptg->SyncTime
                        + (TIMER_BUCKET_GRANULARITY_ABS*(NUM_TIMER_BUCKETS-1));
    
    pHead = &ptg->TimesTable[NUM_TIMER_BUCKETS-1];

    for (ple=pHead->Flink;  ple!=pHead;  ) {
        pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
        pleCur = ple;
        ple = ple->Flink;

        if (pte->Timeout<lastBucketTime) {
            RemoveEntryList(pleCur);
            MAP_TO_BUCKET(dwBucket, pte->Timeout);
            if (dwBucket==0) {
                InsertTimerInSortedList(pte, &ptg->TimesTable[0]);
            }
            else {
                InsertTailList(&ptg->TimesTable[dwBucket], pleCur);
            }
        }
    }
    


    //    
    // sort the times in the first bucket
    //
    InitializeListHead(&le);
    InsertHeadList(&ptg->TimesTable[0], &le);
    RemoveEntryList(&ptg->TimesTable[0]);
    InitializeListHead(&ptg->TimesTable[0]);

    for (ple=le.Flink; ple!=&le;  ) {
        pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
        RemoveEntryList(ple);
        ple = ple->Flink;
        InsertTimerInSortedList(pte, &ptg->TimesTable[0]);
    }



    //
    // set the TableLowIndex
    //
    if (ptg->TableLowIndex>=NUM_TIMER_BUCKETS-1) {
        for (ptg->TableLowIndex=0;  ptg->TableLowIndex<=NUM_TIMER_BUCKETS-1;  
                    ptg->TableLowIndex++) 
        {
            if (IsListEmpty(&ptg->TimesTable[ptg->TableLowIndex]) )
                continue;
            else
                break;
        }
        
    } 
    else 
        ptg->TableLowIndex -= numShift;



    #if DEBUG_TIMER_RESYNCTIMER
    Trace0(TIMER1, "Printing Timer Queue after _ResyncTimerBuckets");
    DebugPrintTimerQueue();
    #endif


    
    Trace0(LEAVE1, "_ResyncTimerBuckets()");
    return;
    
} //end _ResyncTimerBuckets



//------------------------------------------------------------------------------
//          _InitializeTimerGlobal
//
// create the timer CS and WaitTimer. registers a queue and timer with NtdllTimer.
// 
// Called by: _StartProtocol()    
// Locks: no locks taken here.
//------------------------------------------------------------------------------

DWORD
InitializeTimerGlobal (
    )
{
    DWORD               Error = NO_ERROR, i;
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    BOOL                bErr;
    LONGLONG            llCurTime = GetTickCount();

    
    
    Trace0(ENTER1, "Entering _InitializeTimerGlobal()");

    
    bErr = TRUE;
    
    BEGIN_BREAKOUT_BLOCK1 {


        // initialize igmp timer used to get tick count

        InitializeIgmpTime();


        
        //
        // initialize timer critical section
        //
        try {
            InitializeCriticalSection(&ptg->CS);
         }
         except (EXCEPTION_EXECUTE_HANDLER) {
             Error = GetExceptionCode();
             Trace1(
                 ANY, "exception %d initializing global timer critical section",
                 Error
                 );
             Logerr0(INIT_CRITSEC_FAILED, Error);

             GOTO_END_BLOCK1;
         }

        
        // create WaitTimer for igmp
        ptg->WTTimer = CreateTimerQueue();
        
        if ( ! ptg->WTTimer) {
            Error = GetLastError();
            Trace1(ERR, "CreateTimerQueue() failed:%d", Error);
            GOTO_END_BLOCK1;
        }
        


        //
        // create a periodic timer which does not get deletd
        //
        
        if (! CreateTimerQueueTimer(
                    &ptg->WTTimer1,
                    ptg->WTTimer, WT_ProcessTimerEvent,
                    NULL, //context
                    1000000,
                    1000000,
                    0
                    ))
        {
            Error = GetLastError();
            Trace1(ERR, "CreateTimerQueue() failed:%d", Error);
            GOTO_END_BLOCK1;
        }


        
        // set initial timeout to infinite, and SyncTime to the current time
        
        SET_TIMER_INFINITE(ptg->WTTimeout);
        ptg->SyncTime = llCurTime;
        ptg->CurrentTime.QuadPart = llCurTime;

        ptg->NumTimers = 0;



        // initialize the timer buckets
        
        for (i=0;  i<NUM_TIMER_BUCKETS;  i++) {
            InitializeListHead(&ptg->TimesTable[i]);
        }


        // set the TableLowIndex
        ptg->TableLowIndex = (DWORD)~0;


        // set the status of the global timer
        ptg->Status = TIMER_STATUS_CREATED;
        
        bErr = FALSE;

    } END_BREAKOUT_BLOCK1;

    if (bErr) {
        DeInitializeTimerGlobal();
        Trace0(LEAVE1, "Leaving. Could not _InitializeTimerGlobal():");
        return ERROR_CAN_NOT_COMPLETE;
    } 
    else {
        Trace0(LEAVE1, "Leaving _InitializeTimerGlobal()");
        return NO_ERROR;
    }
    
} //end _InitializeTimerGlobal



//------------------------------------------------------------------------------
//        _DeInitializeTimerGlobal
//
// deinitializes the timer CS, and deletes the timer queue with Rtl
//------------------------------------------------------------------------------
VOID
DeInitializeTimerGlobal (
    )
{
    
    DeleteCriticalSection(&g_TimerStruct.CS);


    DeleteTimerQueueEx(g_TimerStruct.WTTimer, NULL);

    
    return;
    
} //end _DeInitializeTimerGlobal



//------------------------------------------------------------------------------
//              _DebugPrintTimerEntry
//
// Assumes DEBUG_TIMER_TIMERID is true
//------------------------------------------------------------------------------
VOID
DebugPrintTimerEntry (
    PIGMP_TIMER_ENTRY   pte,
    DWORD               dwBucket,
    LONGLONG            llCurTime
    )
{
    DWORD               dwDiffTime;
    CHAR                str1[20], str2[20];
    
    #if DEBUG_TIMER_TIMERID

    
    if (dwBucket==(DWORD)~0) {
        MAP_TO_BUCKET(dwBucket, pte->Timeout);
    }

    GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

    
    if (pte->Timeout - llCurTime > 0) {
        Trace7(TIMER, "----  <%2d><%d><%d> Timeout:%lu   <%s> <%s> Status:%d",
                dwBucket, pte->Id, pte->Id2, dwDiffTime, str1, str2, pte->Status);
    }
    else {
        Trace7(TIMER, "----  <%d><%d><%d> Timeout:--%lu <%s> <%s> Status:%d",
                dwBucket, pte->Id, pte->Id2, dwDiffTime, str1, str2, pte->Status);
    }

    #endif //#if DEBUG_TIMER_TIMERID

    return;
}


//------------------------------------------------------------------------------
//          _GetTimerDebugInfo
//
// returns info regarding what type of timer it is
//------------------------------------------------------------------------------

VOID
GetTimerDebugInfo(
    CHAR                str1[20],
    CHAR                str2[20],
    DWORD              *pdwDiffTime,
    PIGMP_TIMER_ENTRY   pte,
    LONGLONG            llCurTime
    )
{
    LONGLONG    diffTime;

#if DEBUG_TIMER_TIMERID

    diffTime = (pte->Timeout - llCurTime > 0)
                ? pte->Timeout - llCurTime 
                : llCurTime - pte->Timeout;

        
    diffTime /= (LONGLONG)1000; //in seconds
    *pdwDiffTime = (DWORD)diffTime;


    strcpy(str2, "          ");
    switch (pte->Id) {
        case 110: 
        case 120: strcpy(str1, "iGenQuery   "); break;
        case 210: 
        case 220: strcpy(str1, "iOtherQry   "); break;
        case 211: strcpy(str1, "iOtherQry*  "); break;
        case 331:
        case 321: strcpy(str1, "gMemTimer*  "); lstrcpy(str2, INET_NTOA(pte->Group)); break;
        case 300:
        case 320:
        case 330:
        case 340: strcpy(str1, "gMemTimer   "); lstrcpy(str2, INET_NTOA(pte->Group)); break;
        case 400:
        case 410: 
        case 420: strcpy(str1, "gGrpSpQry   "); lstrcpy(str2, INET_NTOA(pte->Group)); break;
        case 510: 
        case 520: strcpy(str1, "gLstV1Rpt   "); lstrcpy(str2, INET_NTOA(pte->Group)); break;
        case 511: strcpy(str1, "gLstV1Rpt*  "); lstrcpy(str2, INET_NTOA(pte->Group)); break;
        case 720: 
        case 740: strcpy(str1, "iV1Router   "); break;
        case 741: strcpy(str1, "iV1Router*  "); break;
        case 920:
        case 910: strcpy(str1, "_MibTimer   "); break;
            
        default:  strcpy(str1, "????        "); break;
    
    }

#endif //DEBUG_TIMER_TIMERID

    return;
}


    
//------------------------------------------------------------------------------
//          _DebugPrintTimerQueue
// takes the timer lock
//------------------------------------------------------------------------------
VOID
APIENTRY
DebugPrintTimerQueue (
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    PIGMP_TIMER_ENTRY   pte;
    PLIST_ENTRY         pHead, ple;
    LONGLONG            llCurTime = GetCurrentIgmpTime();
    DWORD               Error=NO_ERROR, i, count;


    if (g_Info.CurrentGroupMemberships > 40)
        return;
        

#if DEBUG_TIMER_TIMERID
    
    ENTER_CRITICAL_SECTION(&g_CS, "g_CS", "_DebugPrintTimerQueue");
    if (g_RunningStatus != IGMP_STATUS_RUNNING) {
        Error = ERROR_CAN_NOT_COMPLETE;
    }
    else {
        ++g_ActivityCount;
    }
    LEAVE_CRITICAL_SECTION(&g_CS, "g_CS", "_DebugPrintTimerQueue");
    if (Error!=NO_ERROR)
        return;


    if (!EnterIgmpWorker()) {return;}
    


    ACQUIRE_TIMER_LOCK("_DebugPrintTimerQueue");

    
    if (g_TimerStruct.NumTimers==0) {
        Trace0(TIMER, "No timers present in the timer queue");

    }
    else {
        Trace0(TIMER, "---------------------LOCAL-TIMER-QUEUE-------------------------");
        Trace4(TIMER, "-- WTTimeout<%d:%lu>    SyncTime<%d:%lu>", 
                TIMER_HIGH(ptg->WTTimeout), TIMER_LOW(ptg->WTTimeout), 
                TIMER_HIGH(ptg->SyncTime), TIMER_LOW(ptg->SyncTime) );
        Trace3(TIMER, "--  NumTimers:<%d>     TableLowIndex:<%lu>        Status:<%d>",
                ptg->NumTimers, ptg->TableLowIndex, ptg->Status);
        Trace0(TIMER, "---------------------------------------------------------------");

        count =0;
        for (i=0;  i<NUM_TIMER_BUCKETS;  i++) {
            
            pHead = &ptg->TimesTable[i];
            if (IsListEmpty(pHead)) 
                continue;
            else {    
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                    pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
                    DebugPrintTimerEntry(pte, i, llCurTime);
                    count ++;
                }
            }
        }

        Trace0(TIMER, "---------------------------------------------------------------");
    }
    RELEASE_TIMER_LOCK("_DebugPrintTimerQueue");


    LeaveIgmpWorker();

#endif //DEBUG_TIMER_TIMERID

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\dvmrpmsg.h ===
//
// Net error file for basename DVMRPLOG_BASE = 41000
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: DVMRPLOG_INIT_CRITSEC_FAILED
//
// MessageText:
//
//  DVMRP was unable to initialize a critical section.
//  The data is the exception code.
//
#define DVMRPLOG_INIT_CRITSEC_FAILED     0x0000A029L

//
// MessageId: DVMRPLOG_HEAP_CREATE_FAILED
//
// MessageText:
//
//  DVMRP was unable to create a heap.
//  The data is the error code.
//
#define DVMRPLOG_HEAP_CREATE_FAILED      0x0000A02AL

//
// MessageId: DVMRPLOG_HEAP_ALLOC_FAILED
//
// MessageText:
//
//  DVMRP was unable to allocate memory from its heap.
//  The data is the error code.
//
#define DVMRPLOG_HEAP_ALLOC_FAILED       0x0000A02BL

//
// MessageId: DVMRPLOG_DVMRP_ALREADY_STARTED
//
// MessageText:
//
//  DVMRP received a start request when it was already running.
//
#define DVMRPLOG_DVMRP_ALREADY_STARTED   0x0000A02CL

//
// MessageId: DVMRPLOG_WSASTARTUP_FAILED
//
// MessageText:
//
//  DVMRP was unable to start Windows Sockets.
//  The data is the error code.
//
#define DVMRPLOG_WSASTARTUP_FAILED       0x0000A02DL

//
// MessageId: DVMRPLOG_CREATE_RWL_FAILED
//
// MessageText:
//
//  DVMRP was unable to create a synchronization object.
//  The data is the error code.
//
#define DVMRPLOG_CREATE_RWL_FAILED       0x0000A02EL

//
// MessageId: DVMRPLOG_CREATE_EVENT_FAILED
//
// MessageText:
//
//  DVMRP was unable to create an event.
//  The data is the error code.
//
#define DVMRPLOG_CREATE_EVENT_FAILED     0x0000A02FL

//
// MessageId: DVMRPLOG_CREATE_SEMAPHORE_FAILED
//
// MessageText:
//
//  DVMRP was unable to create a semaphore.
//  The data is the error code.
//
#define DVMRPLOG_CREATE_SEMAPHORE_FAILED 0x0000A030L

//
// MessageId: DVMRPLOG_CREATE_SOCKET_FAILED
//
// MessageText:
//
//  DVMRP was unable to create a socket.
//  The data is the error code.
//
#define DVMRPLOG_CREATE_SOCKET_FAILED    0x0000A031L

//
// MessageId: DVMRPLOG_DVMRP_STARTED
//
// MessageText:
//
//  DVMRP has started successfully.
//
#define DVMRPLOG_DVMRP_STARTED           0x0000A032L

//
// MessageId: DVMRPLOG_QUEUE_WORKER_FAILED
//
// MessageText:
//
//  DVMRP could not schedule a task to be executed.
//  This may have been caused by a memory allocation failure.
//  The data is the error code.
//
#define DVMRPLOG_QUEUE_WORKER_FAILED     0x0000A033L

//
// MessageId: DVMRPLOG_RECVFROM_FAILED
//
// MessageText:
//
//  DVMRP was unable to receive an incoming message
//  on the local interface with IP address %1.
//  The data is the error code.
//
#define DVMRPLOG_RECVFROM_FAILED         0x0000A034L

//
// MessageId: DVMRPLOG_PACKET_TOO_SMALL
//
// MessageText:
//
//  DVMRP received a packet which was smaller than the minimum size
//  allowed for DVMRP packets. The packet has been discarded.
//  It was received on the local interface with IP address %1,
//  and it came from the neighboring router with IP address %2.
//
#define DVMRPLOG_PACKET_TOO_SMALL        0x0000A035L

//
// MessageId: DVMRPLOG_PACKET_VERSION_INVALID
//
// MessageText:
//
//  DVMRP received a packet with an invalid version in its header.
//  The packet has been discarded. It was received on the local interface
//  with IP address %1, and it came from the neighboring router
//  with IP address %2.
//
#define DVMRPLOG_PACKET_VERSION_INVALID  0x0000A036L

//
// MessageId: DVMRPLOG_PACKET_HEADER_CORRUPT
//
// MessageText:
//
//  DVMRP received a packet with an invalid header. The packet has been
//  discarded. It was received on the local interface with IP address %1,
//  and it came from the neighboring router with IP address %2.
//
#define DVMRPLOG_PACKET_HEADER_CORRUPT   0x0000A037L

//
// MessageId: DVMRPLOG_QUERY_FROM_RAS_CLIENT
//
// MessageText:
//
//  Router received a general query from RAS Client(%1) on interface
//  with IP address %2.
//  RAS clients are not supposed to send queries.
//
#define DVMRPLOG_QUERY_FROM_RAS_CLIENT   0x0000A038L

//
// MessageId: DVMRPLOG_VERSION1_QUERY
//
// MessageText:
//
//  Router configured for version-2. Version-1 router with IP Address %1
//  exists on the interface with IP address %2.
//
#define DVMRPLOG_VERSION1_QUERY          0x0000A039L

//
// MessageId: DVMRPLOG_VERSION2_QUERY
//
// MessageText:
//
//  Router configured for version-1. Version-2 router with IP Address %1
//  exists on the interface with IP address %2.
//
#define DVMRPLOG_VERSION2_QUERY          0x0000A03AL

//
// MessageId: DVMRPLOG_SENDTO_FAILED
//
// MessageText:
//
//  DVMRP was unable to send a packet from the interface with IP address %1
//  to the IP address %2.
//  The data is the error code.
//
#define DVMRPLOG_SENDTO_FAILED           0x0000A03BL

//
// MessageId: DVMRPLOG_PACKET_VERSION_MISMATCH
//
// MessageText:
//
//  DVMRP discarded a version %1 packet received on the interface
//  with IP address %2 from a neighbor with IP address %3.
//  The above interface is configured to accept only version %4 packets.
//
#define DVMRPLOG_PACKET_VERSION_MISMATCH 0x0000A03CL

//
// MessageId: DVMRPLOG_ENUM_NETWORK_EVENTS_FAILED
//
// MessageText:
//
//  DVMRPv2 was unable to enumerate network events on the local interface
//  with IP address %1.
//  The data is the error code.
//
#define DVMRPLOG_ENUM_NETWORK_EVENTS_FAILED 0x0000A03DL

//
// MessageId: DVMRPLOG_INPUT_RECORD_ERROR
//
// MessageText:
//
//  DVMRPv2 detected an error on the local interface with IP address %1.
//  The error occurred while the interface was receiving packets.
//  The data is the error code.
//
#define DVMRPLOG_INPUT_RECORD_ERROR      0x0000A03EL

//
// MessageId: DVMRPLOG_EVENTSELECT_FAILED
//
// MessageText:
//
//  DVMRPv2 was unable to request notification of events
//  on the socket for the local interface with IP address %1.
//  The data is the error code.
//
#define DVMRPLOG_EVENTSELECT_FAILED      0x0000A03FL

//
// MessageId: DVMRPLOG_CREATE_SOCKET_FAILED_2
//
// MessageText:
//
//  DVMRP was unable to create a socket for the local interface
//  with IP address %1.
//  The data is the error code.
//
#define DVMRPLOG_CREATE_SOCKET_FAILED_2  0x0000A040L

//
// MessageId: DVMRPLOG_BIND_FAILED
//
// MessageText:
//
//  DVMRP could not bind to port 520 on the socket for
//  the local interface with IP address %1.
//  The data is the error code.
//
#define DVMRPLOG_BIND_FAILED             0x0000A041L

//
// MessageId: DVMRPLOG_CONNECT_FAILED
//
// MessageText:
//
//  DVMRP could not connect Ras Client %1 to the interface with
//  index %2.
//  The data is the error code.
//
#define DVMRPLOG_CONNECT_FAILED          0x0000A042L

//
// MessageId: DVMRPLOG_DISCONNECT_FAILED
//
// MessageText:
//
//  DVMRP could not disconnect Ras Client %1 from the interface with
//  index %2.
//  The data is the error code.
//
#define DVMRPLOG_DISCONNECT_FAILED       0x0000A043L

//
// MessageId: DVMRPLOG_SET_MCAST_IF_FAILED
//
// MessageText:
//
//  DVMRP could not request multicasting on the local interface
//  with IP address %1.
//  The data is the error code.
//
#define DVMRPLOG_SET_MCAST_IF_FAILED     0x0000A044L

//
// MessageId: DVMRPLOG_SET_ROUTER_ALERT_FAILED
//
// MessageText:
//
//  DVMRP could not set router alert option on the local interface
//  with IP address %1.
//  The data is the error code.
//
#define DVMRPLOG_SET_ROUTER_ALERT_FAILED 0x0000A045L

//
// MessageId: DVMRPLOG_SET_HDRINCL_FAILED
//
// MessageText:
//
//  DVMRP could not set the IP header include option on interface
//  with IP address %1.
//  The data is the error code.
//
#define DVMRPLOG_SET_HDRINCL_FAILED      0x0000A046L

//
// MessageId: DVMRPLOG_JOIN_GROUP_FAILED
//
// MessageText:
//
//  DVMRP could not join the multicast group %1
//  on the local interface with IP address %2.
//  The data is the error code.
//
#define DVMRPLOG_JOIN_GROUP_FAILED       0x0000A047L

//
// MessageId: DVMRPLOG_LEAVE_GROUP_FAILED
//
// MessageText:
//
//  DVMRP could not leave the multicast group %1
//  on the local interface with IP address %2.
//  The data is the error code.
//
#define DVMRPLOG_LEAVE_GROUP_FAILED      0x0000A048L

//
// MessageId: DVMRPLOG_PROTO_ALREADY_STOPPING
//
// MessageText:
//
//  StopProtocol() called to stop DVMRP when it is 
//  already being stopped.
//  The data is the error code.
//
#define DVMRPLOG_PROTO_ALREADY_STOPPING  0x0000A049L

//
// MessageId: DVMRPLOG_PROXY_IF_EXISTS
//
// MessageText:
//
//  AddInterface() called to add an DVMRP Proxy interface.
//  DVMRP proxy already owns another interface.
//  The data is the error code.
//
#define DVMRPLOG_PROXY_IF_EXISTS         0x0000A04AL

//
// MessageId: DVMRPLOG_RAS_IF_EXISTS
//
// MessageText:
//
//  AddInterface() called to add an DVMRP Ras interface.
//  Ras Server cannot exist on multiple interfaces.
//  The data is the error code.
//
#define DVMRPLOG_RAS_IF_EXISTS           0x0000A04BL

//
// MessageId: DVMRPLOG_MGM_REGISTER_FAILED
//
// MessageText:
//
//  DVMRP Router failed to register with MGM.
//  The data is the error code.
//
#define DVMRPLOG_MGM_REGISTER_FAILED     0x0000A04CL

//
// MessageId: DVMRPLOG_MGM_PROXY_REGISTER_FAILED
//
// MessageText:
//
//  DVMRP Proxy failed to register with MGM.
//  The data is the error code.
//
#define DVMRPLOG_MGM_PROXY_REGISTER_FAILED 0x0000A04DL

//
// MessageId: DVMRPLOG_MGM_TAKE_IF_OWNERSHIP_FAILED
//
// MessageText:
//
//  MgmTakeInterfaceOwnership() failed.
//  The data is the error code.
//
#define DVMRPLOG_MGM_TAKE_IF_OWNERSHIP_FAILED 0x0000A04EL

//
// MessageId: DVMRPLOG_ROBUSTNESS_VARIABLE_EQUAL_1
//
// MessageText:
//
//  The robustness variable is being set to 1 for DVMRP router 
//  on Interface %1.
//  You should avoid setting it to 1.
//
#define DVMRPLOG_ROBUSTNESS_VARIABLE_EQUAL_1 0x0000A04FL

//
// MessageId: DVMRPLOG_INVALID_VALUE
//
// MessageText:
//
//  One of the values passed to DVMRP is invalid.
//  %1
//
#define DVMRPLOG_INVALID_VALUE           0x0000A050L

//
// MessageId: DVMRPLOG_REGISTER_WAIT_SERVER_FAILED
//
// MessageText:
//
//  The wait-events-timers could not be registered with the 
//  wait server thread. Alertable threads might not have 
//  been initialized in Rtutils.
//  The data is the error code.
//
#define DVMRPLOG_REGISTER_WAIT_SERVER_FAILED 0x0000A051L

//
// MessageId: DVMRPLOG_DVMRP_STOPPED
//
// MessageText:
//
//  DVMRP has stopped.
//
#define DVMRPLOG_DVMRP_STOPPED           0x0000A052L

//
// MessageId: DVMRPLOG_CAN_NOT_COMPLETE
//
// MessageText:
//
//  Fatal error. Could not complete.
//  The data is the error code.
//
#define DVMRPLOG_CAN_NOT_COMPLETE        0x0000A053L

//
// MessageId: DVMRPLOG_INVALID_VERSION
//
// MessageText:
//
//  The version field %1 in DVMRP config is invalid.
//  Delete and create the DVMRP config again.
//  The data is the error code.
//
#define DVMRPLOG_INVALID_VERSION         0x0000A054L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\if1.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: if.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

#include "pchdvmrp.h"
#pragma hdrstop

//-----------------------------------------------------------------------------
//      _InitializeIfTable
//-----------------------------------------------------------------------------

DWORD
InitializeIfTable(
    )
{
    DWORD Error = NO_ERROR;
    DWORD i;

    
    BEGIN_BREAKOUT_BLOCK1 {    
    
        //
        // allocate memory for the interface table
        //
        
        G_pIfTable = DVMRP_ALLOC_AND_ZERO(sizeof(DVMRP_IF_TABLE));

        PROCESS_ALLOC_FAILURE2(G_pIfTable, "interface table",
            Error, sizeof(DVMRP_IF_TABLE), GOTO_END_BLOCK1);


        // Initialize IfTable list

        InitializeListHead(&G_pIfTable->IfList);


        //
        // Initialize the IfList_CS and PeerLists_CS
        //

        try {
            InitializeCriticalSection(&G_pIfTable->IfList_CS);
            InitializeCriticalSection(&G_pIfTable->PeerLists_CS);
        }
        HANDLE_CRITICAL_SECTION_EXCEPTION(Error, GOTO_END_BLOCK1);


        //
        // allocate memory for the different buckets
        //
        
        G_pIfTable->IfHashTable
            = DVMRP_ALLOC(sizeof(LIST_ENTRY)*IF_HASHTABLE_SIZE);

        PROCESS_ALLOC_FAILURE2(G_pIfTable->IfHashTable, "interface table",
            Error, sizeof(LIST_ENTRY)*IF_HASHTABLE_SIZE, GOTO_END_BLOCK1);


        //
        // allocate memory for the array of pointers to If dynamic RWLs
        //
        
        G_pIfTable->aIfDRWL
            = DVMRP_ALLOC(sizeof(PDYNAMIC_RW_LOCK)*IF_HASHTABLE_SIZE);

        PROCESS_ALLOC_FAILURE2(G_pIfTable->aIfDRWL, "interface table",
            Error, sizeof(PDYNAMIC_RW_LOCK)*IF_HASHTABLE_SIZE,
            GOTO_END_BLOCK1);


        //
        // init locks to NULL, implying that the dynamic locks have not been
        // acquired. and initialize the list heads.
        //
        
        for (i=0;  i<IF_HASHTABLE_SIZE;  i++) {

            InitializeListHead(&G_pIfTable->IfHashTable[i]);

            G_pIfTable->aIfDRWL[i] = NULL;
        }

    } END_BREAKOUT_BLOCK1;

    if (Error != NO_ERROR) {

        DeinitializeIfTable();
    }

    return Error;
    
}//end _InitializeIfTable


//-----------------------------------------------------------------------------
//        _DeInitializeIfTable
//-----------------------------------------------------------------------------

VOID
DeinitializeIfTable(
    )
{
    PLIST_ENTRY         pHead, ple;
    PIF_TABLE_ENTRY     pite;


    if (G_pIfTable==NULL)
        return;


    //
    // go through the interface list and delete all interfaces
    //
    
    pHead = &G_pIfTable->IfList;

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

        ple = ple->Flink;
        
        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, Link);

        DeleteInterface(pite->IfIndex);
    }



    // delete the IfList_CS and PeerLists_CS
    
    DeleteCriticalSection(&G_pIfTable->IfList_CS);
    DeleteCriticalSection(&G_pIfTable->PeerLists_CS);


    // free array of If buckets and If DRWLocks, and the IfTable
    
    DVMRP_FREE(G_pIfTable->IfHashTable);
    DVMRP_FREE(G_pIfTable->aIfDRWL);
    DVMRP_FREE_AND_NULL(G_pIfTable);
    
    return;
}

//-----------------------------------------------------------------------------
//          _GetIfEntry
//
// returns the interface with the given index.
// assumes the interface bucket is either read or write locked
//-----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfEntry(
    DWORD    IfIndex
    )
{
    PIF_TABLE_ENTRY pite = NULL;
    PLIST_ENTRY     pHead, ple;


    pHead = GET_IF_HASH_BUCKET(Index);

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, HTLink);

        if (pite->IfIndex == IfIndex) {
            break;
        }
    }

    return  (ple == pHead) ?  NULL:   pite;
}


//-----------------------------------------------------------------------------
//          _GetIfByIndex
//
// returns the interface with the given index.
// assumes the interface bucket is either read or write locked
//-----------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByIndex(
    DWORD    IfIndex
    )
{
    PIF_TABLE_ENTRY pite = NULL;
    PLIST_ENTRY     pHead, ple;


    pHead = &G_pIfTable->IfHashTable[IF_HASH_VALUE(IfIndex)];

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, HTLink);

        if (pite->IfIndex == IfIndex) {
            break;
        }
    }

    return  (ple == pHead) ?  NULL:   pite;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\if1.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// Module Name: main.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================


DWORD
InitializeIfTable(
    );

VOID
DeinitializeIfTable(
    );
    
PIF_TABLE_ENTRY
GetIfEntry(
    DWORD    IfIndex
    );

PIF_TABLE_ENTRY
GetIfByIndex(
    DWORD    IfIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\if.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File Name: if.h
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================




//
// API's
//

DWORD
WINAPI
AddInterface(
    IN PWCHAR               pwszInterfaceName,//not used
    IN ULONG                IfIndex,
    IN NET_INTERFACE_TYPE   dwIfType,
    IN DWORD                dwMediaType,
    IN WORD                 wAccessType,
    IN WORD                 wConnectionType,
    IN PVOID                pvConfig,
    IN ULONG                ulStructureVersion,
    IN ULONG                ulStructureSize,
    IN ULONG                ulStructureCount
    );

DWORD
DeleteInterface(
    IN DWORD IfIndex
    );

DWORD
WINAPI
InterfaceStatus(
    ULONG IfIndex,
    BOOL  bIfActive,
    DWORD dwStatusType,
    PVOID pvStatusInfo
    );

DWORD
WINAPI
SetInterfaceConfigInfo(
    IN DWORD IfIndex,
    IN PVOID pvConfig,
    IN ULONG ulStructureVersion,
    IN ULONG ulStructureSize,
    IN ULONG ulStructureCount
    );

DWORD
WINAPI
GetInterfaceConfigInfo(
    IN     DWORD  IfIndex,
    IN OUT PVOID  pvConfig,
    IN OUT PDWORD pdwSize,
    IN OUT PULONG pulStructureVersion,
    IN OUT PULONG pulStructureSize,
    IN OUT PULONG pulStructureCount
    );


    
//
// local prototypes
//

DWORD
AddIfEntry(
    ULONG IfIndex,
    PVOID pConfigOpaque,
    ULONG StructureSize
    );

DWORD
ValidateIfConfig(
    ULONG IfIndex,
    PVOID pConfigOpaque,
    ULONG StructureSize
    );

VOID
DeleteIfEntry(
    PIF_TABLE_ENTRY pite
    );

DWORD
BindInterface(
    ULONG IfIndex,
    PIP_ADAPTER_BINDING_INFO pBindInfo
    );

DWORD
ActivateInterface(
    PIF_TABLE_ENTRY pite
    );

DWORD
EnableInterface(
    IN DWORD IfIndex
    );
    
DWORD
EnableIfEntry(
    DWORD   IfIndex,
    BOOL    bChangedByRtrmgr
    );

DWORD
UnBindInterface(
    IN DWORD IfIndex
    );

DWORD
DeactivateInterface(
    PIF_TABLE_ENTRY pite
    );

DWORD
DisableInterface(
    IN DWORD IfIndex
    );

DWORD
DisableIfEntry(
    DWORD IfIndex,
    BOOL  bChangedByRtrmgr
    );

DWORD
CreateIfSockets(
    PIF_TABLE_ENTRY pite
    );
    
VOID
DeleteIfSockets(
    PIF_TABLE_ENTRY pite
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\makefile.inc ===
$(O)\dvmrpmsg.mc: log.h
    mapmsg NET DVMRPLOG_BASE log.h > $(O)\dvmrpmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\main.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// Module Name: main.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

//
// forward declarations
//

struct _DVMRP_IF_TABLE;
struct _ASYNC_SOCKET_DATA;


//-----------------------------------------------------------------------------
// globals structure
//-----------------------------------------------------------------------------

typedef struct _GLOBALS1 {
    ULONG               RunningStatus;
    ULONG               InitFlags;
    CRITICAL_SECTION    WorkItemCS;
    HANDLE              Heap;
    LOCKED_LIST         RtmQueue;    
    
} GLOBALS1;


typedef struct _GLOBALS {
    HANDLE              LogHandle;          //logging handle
    DWORD               TraceId;            //tracing handle
    
    DWORD               ActivityCount;      //count of pending work items
    HANDLE              ActivityEvent;      //signal it to notify 0 work items

    HANDLE              RtmNotifyEvent;     //signal it to notify Rtm

    DYNAMIC_LOCKS_STORE DynamicCSStore;     //global store for dynamic CS
    DYNAMIC_LOCKS_STORE DynamicRWLStore;    //global store for dynamic RWL

    struct _DVMRP_IF_TABLE    *pIfTable;           //interface table

    LARGE_INTEGER       CurrentTime;        //keeps current 64 bit tick time
    HANDLE              MgmDvmrpHandle;     //handle returned by MGM

    
} GLOBALS;


typedef DVMRP_GLOBAL_CONFIG  GLOBAL_CONFIG;
typedef PDVMRP_GLOBAL_CONFIG PGLOBAL_CONFIG;

typedef DVMRP_IF_CONFIG      IF_CONFIG;
typedef PDVMRP_IF_CONFIG     PIF_CONFIG;


//-----------------------------------------------------------------------------
// DVMRP_IF_TABLE
//-----------------------------------------------------------------------------

typedef struct _DVMRP_IF_TABLE {

    LIST_ENTRY          IfList;         // in order of increasing index
    CRITICAL_SECTION    IfList_CS;      // CS protecting IfList

    DWORD               NumInterfaces;

    PLIST_ENTRY         IfHashTable;
    PDYNAMIC_RW_LOCK   *aIfDRWL;

    CRITICAL_SECTION    PeerLists_CS;   // common lock for add/remove peers

    DWORD               NumActiveIfs;
    
} DVMRP_IF_TABLE, *PDVMRP_IF_TABLE;

#define IF_HASHTABLE_SIZE 50


//-----------------------------------------------------------------------------
// IF_TABLE_ENTRY
//-----------------------------------------------------------------------------

typedef struct _IF_TABLE_ENTRY {

    LIST_ENTRY          Link;
    LIST_ENTRY          HTLink;

    DWORD               IfIndex;
    IPADDR              IpAddr;

    DWORD               Status;
    DWORD               CreationFlags;
    DWORD               RefCount;
    
    PIF_CONFIG          pConfig;
    DWORD               NumAddrBound;
    PDVMRP_ADDR_MASK    pBinding;
    struct _IF_INFO     *pInfo;

    DWORD               NumPeers;           // peers in PeerList
    LIST_ENTRY          PeerList;           // list of peers being created
    LIST_ENTRY          DeletedPeerList;    // list of peers being deleted

    SOCKET              Socket;
    struct _ASYNC_SOCKET_DATA  *pSocketData;

    RTM_ENTITY_HANDLE   RtmHandle;          // register with Rtm
    
} IF_TABLE_ENTRY, *PIF_TABLE_ENTRY;



#define IF_CREATED_FLAG     0x00000001
#define IF_BOUND_FLAG       0x00000002
#define IF_ENABLED_FLAG     0x00000004
#define IF_ACTIVATED_FLAG   0x00000008
#define IF_DELETED_FLAG     0x80000000


#define IS_IF_BOUND(pite) \
        ((pite)->Status&IF_BOUND_FLAG)

#define IS_IF_ENABLED_BY_RTRMGR(pite) \
        ((pite)->Status&IF_ENABLED_FLAG)

#define IS_IF_ENABLED_IN_CONFIG(pite) \
        (IS_DVMRP_IF_ENABLED_FLAG_SET((pite)->pConfig->Flags))

#define IS_IF_ENABLED(pite) \
        ( IS_IF_ENABLED_BY_RTRMGR(pite) && IS_IF_ENABLED_IN_CONFIG(pite) )

#define IS_IF_ENABLED_BOUND(pite) \
        (IS_IF_ENABLED(pite)&&IS_IF_BOUND(pite))
        
#define IS_IF_DELETED(pite) \
        ((pite)->Status&IF_DELETED_FLAG)

#define IS_IF_ACTIVATED(pite) \
        ( !((pite)->Status&IF_DELETED_FLAG) \
            && ((pite)->Status & IF_ACTIVATED_FLAG) )


#define IF_FLAGS_SOCKETS_CREATED            0x00000001
#define IF_FLAGS_PROTO_REGISTERED_WITH_MGM  0x00000002
#define IF_FLAGS_IF_REGISTERED_WITH_MGM     0x00000004


//-----------------------------------------------------------------------------
// IF_INFO
//-----------------------------------------------------------------------------

typedef struct _IF_INFO {

    LONGLONG        TimeWhenActivated;
    
} IF_INFO, *PIF_INFO;



//-----------------------------------------------------------------------------
// type definitions for event message queue
//-----------------------------------------------------------------------------

typedef struct _EVENT_QUEUE_ENTRY {

    ROUTING_PROTOCOL_EVENTS EventType;
    MESSAGE                 Msg;

    LIST_ENTRY              Link;

} EVENT_QUEUE_ENTRY, *PEVENT_QUEUE_ENTRY;


//
// extern variables
//

extern GLOBALS          Globals;
extern GLOBALS1         Globals1;
extern GLOBAL_CONFIG    GlobalConfig;
#define G_pIfTable      (Globals.pIfTable)



//
// defines
//

//-----------------------------------------------------------------------------
// #defines for global structure
//-----------------------------------------------------------------------------

//
// various codes describing states of dvmrp
//

typedef enum {
    DVMRP_STATUS_STARTING   = 100,
    DVMRP_STATUS_RUNNING    = 101,
    DVMRP_STATUS_STOPPING   = 102,
    DVMRP_STATUS_STOPPED    = 103
} DVMRP_STATUS_CODE;

//
// WorkItemCS lock macros
//

#define ACQUIRE_WORKITEM_LOCK(proc) EnterCriticalSection(&Globals1.WorkItemCS)
#define RELEASE_WORKITEM_LOCK(proc) LeaveCriticalSection(&Globals1.WorkItemCS)


//-----------------------------------------------------------------------------
// #defines for global config
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// macros for IfTable
//-----------------------------------------------------------------------------

#define IF_HASH_VALUE(_index) ((_index) % IF_HASHTABLE_SIZE)


#define GET_IF_HASH_BUCKET(Index) \
    &G_pIfTable->IfHashTable[IF_HASH_VALUE(IfIndex)];


// macros for If DRW lock

#define ACQUIRE_IF_LOCK_EXCLUSIVE(_IfIndex, _proc) \
        AcquireDynamicRWLock( \
            &G_pIfTable->aIfDRWL[IF_HASH_VALUE(_IfIndex)], \
            LOCK_MODE_WRITE, &Globals.DynamicRWLStore)
            
#define RELEASE_IF_LOCK_EXCLUSIVE(_IfIndex, _proc) \
        ReleaseDynamicRWLock( \
            &G_pIfTable->aIfDRWL[IF_HASH_VALUE(_IfIndex)],\
            LOCK_MODE_WRITE, &Globals.DynamicRWLStore)

#define ACQUIRE_IF_LOCK_SHARED(_IfIndex, _proc) \
        AcquireDynamicRWLock( \
            &G_pIfTable->aIfDRWL[IF_HASH_VALUE(_IfIndex)],\
            LOCK_MODE_READ, &Globals.DynamicRWLStore)
            
#define RELEASE_IF_LOCK_SHARED(_IfIndex, _proc) \
        ReleaseDynamicRWLock( \
            &G_pIfTable->aIfDRWL[IF_HASH_VALUE(_IfIndex)], \
            LOCK_MODE_READ, &Globals.DynamicRWLStore)



// macros for IfList_CS lock

#define ACQUIRE_IF_LIST_LOCK(_proc) \
        ENTER_CRITICAL_SECTION(&G_pIfTable->IfList_CS, "G_IfListCS", _proc);

#define RELEASE_IF_LIST_LOCK(_proc) \
        LEAVE_CRITICAL_SECTION(&G_pIfTable->IfList_CS, "G_IfListCS", _proc);



// macros for PeerLists_CS lock (see in peer.h)


//
// local prototypes
//

DWORD
WINAPI
StartProtocol(
    IN HANDLE               hRtmNotifyEvent,
    IN PSUPPORT_FUNCTIONS   pSupportFunctions,
    IN PVOID                pGlobalConfig,
    IN ULONG                ulStructureVersion,
    IN ULONG                ulStructureSize,
    IN ULONG                ulStructureCount
    );

DWORD
APIENTRY
StartComplete(
    VOID
    );

DWORD
APIENTRY
StopProtocol(
    VOID
    );

DWORD
WINAPI
GetGlobalInfo(
    IN OUT PVOID    pvConfig,
    IN OUT PDWORD   pdwSize,
    IN OUT PULONG   pulStructureVersion,
    IN OUT PULONG   pulStructureSize,
    IN OUT PULONG   pulStructureCount
    );

DWORD
WINAPI
SetGlobalInfo(
    IN PVOID pvConfig,
    IN ULONG ulStructureVersion,
    IN ULONG ulStructureSize,
    IN ULONG ulStructureCount
    );

DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEventType,
    OUT PMESSAGE                pMessage
    );





DWORD
EnqueueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS EventType,
    MESSAGE Msg
    );

DWORD
DequeueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS *pEventType,
    PMESSAGE pResult
    );

BOOL
DllStartup(
    );

BOOL
DllCleanup(
    );

VOID
ProtocolCleanup(
    );
    
DWORD
ValidateGlobalConfig(
    PDVMRP_GLOBAL_CONFIG pGlobalConfig,
    DWORD StructureSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\log.h ===
#define DVMRPLOG_BASE                           41000

#define DVMRPLOG_INIT_CRITSEC_FAILED            (DVMRPLOG_BASE + 1)
/*
 * DVMRP was unable to initialize a critical section.
 * The data is the exception code.
 */

#define DVMRPLOG_HEAP_CREATE_FAILED             (DVMRPLOG_BASE + 2)
/*
 * DVMRP was unable to create a heap.
 * The data is the error code.
 */

#define DVMRPLOG_HEAP_ALLOC_FAILED              (DVMRPLOG_BASE + 3)
/*
 * DVMRP was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define DVMRPLOG_DVMRP_ALREADY_STARTED           (DVMRPLOG_BASE + 4)
/*
 * DVMRP received a start request when it was already running.
 */

#define DVMRPLOG_WSASTARTUP_FAILED              (DVMRPLOG_BASE + 5)
/*
 * DVMRP was unable to start Windows Sockets.
 * The data is the error code.
 */

#define DVMRPLOG_CREATE_RWL_FAILED              (DVMRPLOG_BASE + 6)
/*
 * DVMRP was unable to create a synchronization object.
 * The data is the error code.
 */

#define DVMRPLOG_CREATE_EVENT_FAILED            (DVMRPLOG_BASE + 7)
/*
 * DVMRP was unable to create an event.
 * The data is the error code.
 */

#define DVMRPLOG_CREATE_SEMAPHORE_FAILED        (DVMRPLOG_BASE + 8)
/*
 * DVMRP was unable to create a semaphore.
 * The data is the error code.
 */

#define DVMRPLOG_CREATE_SOCKET_FAILED           (DVMRPLOG_BASE + 9)
/*
 * DVMRP was unable to create a socket.
 * The data is the error code.
 */

#define DVMRPLOG_DVMRP_STARTED                   (DVMRPLOG_BASE + 10)
/*
 * DVMRP has started successfully.
 */

#define DVMRPLOG_QUEUE_WORKER_FAILED            (DVMRPLOG_BASE + 11)
/*
 * DVMRP could not schedule a task to be executed.
 * This may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define DVMRPLOG_RECVFROM_FAILED                (DVMRPLOG_BASE + 12)
/*
 * DVMRP was unable to receive an incoming message
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define DVMRPLOG_PACKET_TOO_SMALL               (DVMRPLOG_BASE + 13)
/*
 * DVMRP received a packet which was smaller than the minimum size
 * allowed for DVMRP packets. The packet has been discarded.
 * It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define DVMRPLOG_PACKET_VERSION_INVALID         (DVMRPLOG_BASE + 14)
/*
 * DVMRP received a packet with an invalid version in its header.
 * The packet has been discarded. It was received on the local interface
 * with IP address %1, and it came from the neighboring router
 * with IP address %2.
 */ 

#define DVMRPLOG_PACKET_HEADER_CORRUPT          (DVMRPLOG_BASE + 15)
/*
 * DVMRP received a packet with an invalid header. The packet has been
 * discarded. It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define DVMRPLOG_QUERY_FROM_RAS_CLIENT          (DVMRPLOG_BASE + 16)
/*
 * Router received a general query from RAS Client(%1) on interface
 * with IP address %2.
 * RAS clients are not supposed to send queries.
 */

#define DVMRPLOG_VERSION1_QUERY                 (DVMRPLOG_BASE + 17)
/*
 * Router configured for version-2. Version-1 router with IP Address %1
 * exists on the interface with IP address %2.
 */
 
#define DVMRPLOG_VERSION2_QUERY                 (DVMRPLOG_BASE + 18)
/*
 * Router configured for version-1. Version-2 router with IP Address %1
 * exists on the interface with IP address %2.
 */
 
#define DVMRPLOG_SENDTO_FAILED                  (DVMRPLOG_BASE + 19)
/*
 * DVMRP was unable to send a packet from the interface with IP address %1
 * to the IP address %2.
 * The data is the error code.
 */

#define DVMRPLOG_PACKET_VERSION_MISMATCH        (DVMRPLOG_BASE + 20)
/*
 * DVMRP discarded a version %1 packet received on the interface
 * with IP address %2 from a neighbor with IP address %3.
 * The above interface is configured to accept only version %4 packets.
 */

#define DVMRPLOG_ENUM_NETWORK_EVENTS_FAILED     (DVMRPLOG_BASE + 21)
/*
 * DVMRPv2 was unable to enumerate network events on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define DVMRPLOG_INPUT_RECORD_ERROR             (DVMRPLOG_BASE + 22)
/*
 * DVMRPv2 detected an error on the local interface with IP address %1.
 * The error occurred while the interface was receiving packets.
 * The data is the error code.
 */

#define DVMRPLOG_EVENTSELECT_FAILED             (DVMRPLOG_BASE + 23)
/*
 * DVMRPv2 was unable to request notification of events
 * on the socket for the local interface with IP address %1.
 * The data is the error code.
 */
 
#define DVMRPLOG_CREATE_SOCKET_FAILED_2         (DVMRPLOG_BASE + 24)
/*
 * DVMRP was unable to create a socket for the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define DVMRPLOG_BIND_FAILED                    (DVMRPLOG_BASE + 25)
/*
 * DVMRP could not bind to port 520 on the socket for
 * the local interface with IP address %1.
 * The data is the error code.
 */

#define DVMRPLOG_CONNECT_FAILED                 (DVMRPLOG_BASE + 26)
/*
 * DVMRP could not connect Ras Client %1 to the interface with
 * index %2.
 * The data is the error code.
 */
 
#define DVMRPLOG_DISCONNECT_FAILED              (DVMRPLOG_BASE + 27)
/*
 * DVMRP could not disconnect Ras Client %1 from the interface with
 * index %2.
 * The data is the error code.
 */
 
#define DVMRPLOG_SET_MCAST_IF_FAILED            (DVMRPLOG_BASE + 28)
/*
 * DVMRP could not request multicasting on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define DVMRPLOG_SET_ROUTER_ALERT_FAILED        (DVMRPLOG_BASE + 29)
/*
 * DVMRP could not set router alert option on the local interface
 * with IP address %1.
 * The data is the error code.
 */
 
#define DVMRPLOG_SET_HDRINCL_FAILED             (DVMRPLOG_BASE + 30)
/*
 * DVMRP could not set the IP header include option on interface
 * with IP address %1.
 * The data is the error code.
 */
 
#define DVMRPLOG_JOIN_GROUP_FAILED              (DVMRPLOG_BASE + 31)
/*
 * DVMRP could not join the multicast group %1
 * on the local interface with IP address %2.
 * The data is the error code.
 */
 
#define DVMRPLOG_LEAVE_GROUP_FAILED             (DVMRPLOG_BASE + 32)
/*
 * DVMRP could not leave the multicast group %1
 * on the local interface with IP address %2.
 * The data is the error code.
 */

#define DVMRPLOG_PROTO_ALREADY_STOPPING         (DVMRPLOG_BASE + 33)
/*
 * StopProtocol() called to stop DVMRP when it is 
 * already being stopped.
 * The data is the error code.
 */

#define DVMRPLOG_PROXY_IF_EXISTS                (DVMRPLOG_BASE + 34)
/*
 * AddInterface() called to add an DVMRP Proxy interface.
 * DVMRP proxy already owns another interface.
 * The data is the error code.
 */

#define DVMRPLOG_RAS_IF_EXISTS                  (DVMRPLOG_BASE + 35)
/*
 * AddInterface() called to add an DVMRP Ras interface.
 * Ras Server cannot exist on multiple interfaces.
 * The data is the error code.
 */

#define DVMRPLOG_MGM_REGISTER_FAILED             (DVMRPLOG_BASE + 36)
/*
 * DVMRP Router failed to register with MGM.
 * The data is the error code.
 */

#define DVMRPLOG_MGM_PROXY_REGISTER_FAILED       (DVMRPLOG_BASE + 37)
/*
 * DVMRP Proxy failed to register with MGM.
 * The data is the error code.
 */


 #define DVMRPLOG_MGM_TAKE_IF_OWNERSHIP_FAILED   (DVMRPLOG_BASE + 38)
/*
 * MgmTakeInterfaceOwnership() failed.
 * The data is the error code.
 */

 #define DVMRPLOG_ROBUSTNESS_VARIABLE_EQUAL_1    (DVMRPLOG_BASE + 39)
/*
 * The robustness variable is being set to 1 for DVMRP router 
 * on Interface %1.
 * You should avoid setting it to 1.
 */

 #define DVMRPLOG_INVALID_VALUE                 (DVMRPLOG_BASE + 40)
/*
 * One of the values passed to DVMRP is invalid.
 * %1
 */

#define DVMRPLOG_REGISTER_WAIT_SERVER_FAILED    (DVMRPLOG_BASE + 41)
/*
 * The wait-events-timers could not be registered with the 
 * wait server thread. Alertable threads might not have 
 * been initialized in Rtutils.
 * The data is the error code.
 */

#define DVMRPLOG_DVMRP_STOPPED                   (DVMRPLOG_BASE + 42)
/*
 * DVMRP has stopped.
 */
 
 #define DVMRPLOG_CAN_NOT_COMPLETE              (DVMRPLOG_BASE + 43)
 /*
  * Fatal error. Could not complete.
  * The data is the error code.
  */






 #define DVMRPLOG_INVALID_VERSION               (DVMRPLOG_BASE + 44)
 /*
  * The version field %1 in DVMRP config is invalid.
  * Delete and create the DVMRP config again.
  * The data is the error code.
  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\main.c ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File Name: main.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================


#include "pchdvmrp.h"
#pragma hdrstop


GLOBALS Globals;
GLOBALS1 Globals1;
GLOBAL_CONFIG GlobalConfig;


//----------------------------------------------------------------------------
//      _DLLMAIN
//
// Called when the dll is being loaded/unloaded
//----------------------------------------------------------------------------

BOOL
WINAPI
DLLMAIN (
    HINSTANCE   Module,
    DWORD       Reason,
    LPVOID      Reserved
    )
{
    BOOL    NoError;


    switch (Reason) {

        case DLL_PROCESS_ATTACH:
        {
            DisableThreadLibraryCalls(Module);


            // create and initialize global data
            
            NoError = DllStartup();

            break;
        }


        case DLL_PROCESS_DETACH:
        {
            // free global data
            
            NoError = DllCleanup();

            break;
        }


        default:
        {
            NoError = TRUE;
            break;
        }
    }
    
    return NoError;

} //end _DLLMAIN



//----------------------------------------------------------------------------
//      _DllStartup
//
// Initializes Globals1 structure
//----------------------------------------------------------------------------

BOOL
DllStartup(
    )
{
    
    BEGIN_BREAKOUT_BLOCK1 {

        //
        // create a private heap for dvmrp
        //
        
        Globals1.Heap = HeapCreate(0, 0, 0);

        if (Globals1.Heap == NULL) {
            GOTO_END_BLOCK1;
        }


        try {

            // initialize the Router Manager event queue

            CREATE_LOCKED_LIST(&Globals1.RtmQueue);
            

            // create WorkItem CS
            
            InitializeCriticalSection(&Globals1.WorkItemCS);
        }

        except (EXCEPTION_EXECUTE_HANDLER) {
            GOTO_END_BLOCK1;
        }


        // if reached here, then return no error.
        
        return TRUE;
        
    } END_BREAKOUT_BLOCK1;


    // there was some error. Cleanup before returning error.
    
    DllCleanup();
    
    return FALSE;
}


//----------------------------------------------------------------------------
//      _DllCleanup
//
// This function is called when the dll is being unloaded. It frees any global
// structures set in _DllStartup
//----------------------------------------------------------------------------

BOOL
DllCleanup(
    )
{
    // destroy the router manager event queue

    if (LOCKED_LIST_CREATED(&Globals1.RtmQueue)) {

         DELETE_LOCKED_LIST(&Globals1.RtmQueue, EVENT_QUEUE_ENTRY, Link);
    }


    // delete WorkItem CS

    DeleteCriticalSection(&Globals1.WorkItemCS);


    // destroy private heap

    if (Globals1.Heap != NULL) {
        HeapDestroy(Globals1.Heap);
    }


    return TRUE;
}



//----------------------------------------------------------------------------
//      _RegisterProtocol
//
// This function is called after the Dll is loaded, and before StartProtocol
// is called. It checks to ensure that the correct version is being configured
// 
// No deinitialization is required for this function call.
//----------------------------------------------------------------------------

DWORD
WINAPI
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    )
{
    DWORD Error = NO_ERROR;


    //
    // initialize tracing and error logging
    //

    INITIALIZE_TRACING_LOGGING();


    Trace0(ENTER, "RegisterProtocol()");


    //
    // The Router Manager should be calling us to register our protocol.
    // The Router Manager must be atleast the version we are compiled with
    // The Router Manager must support routing and multicast.
    //

#ifdef MS_IP_DVMRP    
    if(pRoutingChar->dwProtocolId != MS_IP_DVMRP)
        return ERROR_NOT_SUPPORTED;
#endif
    
    if(pRoutingChar->dwVersion < MS_ROUTER_VERSION)
        return ERROR_NOT_SUPPORTED;

    if(!(pRoutingChar->fSupportedFunctionality & RF_ROUTING)
        || !(pRoutingChar->fSupportedFunctionality & RF_MULTICAST) )
        return ERROR_NOT_SUPPORTED;



    //
    // We setup our characteristics and function pointers
    // All pointers should be set to NULL by the caller.
    //

    pServiceChar->fSupportedFunctionality = 0;

    pRoutingChar->fSupportedFunctionality = RF_MULTICAST | RF_ROUTING;
    pRoutingChar->pfnStartProtocol    = StartProtocol;
    pRoutingChar->pfnStartComplete    = StartComplete;
    pRoutingChar->pfnStopProtocol     = StopProtocol;
    pRoutingChar->pfnAddInterface     = AddInterface;
    pRoutingChar->pfnDeleteInterface  = DeleteInterface;
    pRoutingChar->pfnInterfaceStatus  = InterfaceStatus;
    pRoutingChar->pfnGetEventMessage  = GetEventMessage;
    pRoutingChar->pfnGetInterfaceInfo = GetInterfaceConfigInfo;
    pRoutingChar->pfnSetInterfaceInfo = SetInterfaceConfigInfo;
    pRoutingChar->pfnGetGlobalInfo    = GetGlobalInfo;
    pRoutingChar->pfnSetGlobalInfo    = SetGlobalInfo;
    pRoutingChar->pfnMibCreateEntry   = MibCreate;
    pRoutingChar->pfnMibDeleteEntry   = MibDelete;
    pRoutingChar->pfnMibGetEntry      = MibGet;
    pRoutingChar->pfnMibSetEntry      = MibSet;
    pRoutingChar->pfnMibGetFirstEntry = MibGetFirst;
    pRoutingChar->pfnMibGetNextEntry  = MibGetNext;
    pRoutingChar->pfnUpdateRoutes     = NULL;
    pRoutingChar->pfnConnectClient    = NULL;
    pRoutingChar->pfnDisconnectClient = NULL;
    pRoutingChar->pfnGetNeighbors     = NULL;
    pRoutingChar->pfnGetMfeStatus     = NULL;
    pRoutingChar->pfnQueryPower       = NULL;
    pRoutingChar->pfnSetPower         = NULL;

    Trace0(LEAVE, "Leaving RegisterProtocol():\n");
    return NO_ERROR;

} //end _RegisterProtocol



//----------------------------------------------------------------------------
//      _StartProtocol
//
// Initializes global structures
//----------------------------------------------------------------------------

DWORD
WINAPI
StartProtocol(
    IN HANDLE               RtmNotifyEvent,    //notify Rtm when dvmrp stopped
    IN PSUPPORT_FUNCTIONS   pSupportFunctions, //NULL
    IN PVOID                pDvmrpGlobalConfig,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    )
{
    DWORD       Error=NO_ERROR;
    BOOL        IsError;
    

    //
    // initialize tracing and error logging if StartProtocol called after
    // StopProtocol
    //

    INITIALIZE_TRACING_LOGGING();

    //
    // acquire global lock
    //
    
    ACQUIRE_WORKITEM_LOCK("_StartProtocol");


    //
    // make certain dvmrp is not already running (StartProtocol might get
    // called before StopProtocol completes)
    //
    
    if (Globals1.RunningStatus != DVMRP_STATUS_STOPPED) {

        Trace0(ERR,
            "Error: _StartProtocol called when dvmrp is already running");
        Logwarn0(DVMRP_ALREADY_STARTED, NO_ERROR);

        RELEASE_WORKITEM_LOCK("_StartProtocol");

        return ERROR_CAN_NOT_COMPLETE;
    }


    IsError = TRUE;

    
    BEGIN_BREAKOUT_BLOCK1 {

        // save the Router Manager notification event

        Globals.RtmNotifyEvent = RtmNotifyEvent;


        //
        // set the Global Config (after validating it)
        //

        if(pDvmrpGlobalConfig == NULL) {

            Trace0(ERR, "_StartProtocol: Called with NULL global config");
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }
        {
            PDVMRP_GLOBAL_CONFIG pGlobalConfig;

            pGlobalConfig = (PDVMRP_GLOBAL_CONFIG) pDvmrpGlobalConfig;


            // Check the global config, and correct if values are not correct.
            // Not a fatal error.

            if (! ValidateGlobalConfig(pGlobalConfig, StructureSize)) {
                Error = ERROR_INVALID_PARAMETER;
                GOTO_END_BLOCK1;
            }

            memcpy(&GlobalConfig, pGlobalConfig, sizeof(GlobalConfig));
        }



        //
        // Initialize Winsock version 2.0
        //

        {
            WSADATA WsaData;
            
            Error = (DWORD)WSAStartup(MAKEWORD(2,0), &WsaData);

            if ( (Error!=0) || (LOBYTE(WsaData.wVersion)<2) ) {

                Trace1(ERR,
                    "StartProtocol:Error %d:could not initialize winsock v-2",
                    Error);
                Logerr0(WSASTARTUP_FAILED, Error);

                if (LOBYTE(WsaData.wVersion)<2)
                    WSACleanup();

                GOTO_END_BLOCK1;
            }
        }

        //
        // Initialise the Dynamic CS and ReadWrite locks main struct
        //

        Error = InitializeDynamicLocks(&Globals.DynamicCSStore);
        if (Error!=NO_ERROR) {
            GOTO_END_BLOCK1;
        }

        
        Error = InitializeDynamicLocks(&Globals.DynamicRWLStore);
        if (Error!=NO_ERROR) {
            GOTO_END_BLOCK1;
        }


        //
        // Initialize Interface Table
        //
        
        InitializeIfTable();


        IsError = FALSE;
        
    } END_BREAKOUT_BLOCK1;


    if (IsError) {
        Trace1(START, "Dvmrp could not be started: %d", Error);
        ProtocolCleanup();
    }
    else {
        Trace0(START, "Dvmrp started successfully");
        Loginfo0(DVMRP_STARTED, NO_ERROR);
    }


    RELEASE_WORKITEM_LOCK("_StartProtocol()");

    Trace1(LEAVE, "Leaving StartProtocol():%d\n", Error);    
    return Error;
    
} //end _StartProtocol


//----------------------------------------------------------------------------
//      _ValidateGlobalConfig
//----------------------------------------------------------------------------

DWORD
ValidateGlobalConfig(
    PDVMRP_GLOBAL_CONFIG pGlobalConfig,
    DWORD StructureSize
    )
{
    //
    // check structure size
    //
    
    if (StructureSize != sizeof(DVMRP_GLOBAL_CONFIG)) {

        Trace1(ERR, "Dvmrp global config size too small.\n", StructureSize);        
            
        return ERROR_INVALID_DATA;
    }

    DebugPrintGlobalConfig(pGlobalConfig);


    //
    // check version
    //
    
    if (pGlobalConfig->MajorVersion != 3) {

        Trace1(ERR, "Invalid version:%d in global config.",
            pGlobalConfig->MajorVersion);

        Logerr1(INVALID_VERSION, "%d", pGlobalConfig->MajorVersion,
            ERROR_INVALID_DATA);

        return ERROR_INVALID_DATA;
    }


    // check loggingLevel

    switch (pGlobalConfig->LoggingLevel) {
        case DVMRP_LOGGING_NONE :
        case DVMRP_LOGGING_ERROR :
        case DVMRP_LOGGING_WARN :
        case DVMRP_LOGGING_INFO :
            break;

        default :
        {
            Trace1(ERR, "Invalid value:%d for LoggingLevel in global config.",
                pGlobalConfig->LoggingLevel);

            return ERROR_INVALID_DATA;
        }
    }


    //
    // check RouteReportInterval (min 10 sec)
    //
    
    if (pGlobalConfig->RouteReportInterval != DVMRP_ROUTE_REPORT_INTERVAL) {

        Trace2(CONFIG,
            "RouteReportInterval being set to %d. Suggested value:%d",
            pGlobalConfig->RouteReportInterval, DVMRP_ROUTE_REPORT_INTERVAL);
    }


    if (pGlobalConfig->RouteReportInterval < 10000) {

        Trace2(ERR,
            "RouteReportInterval has very low value:%d, suggested:%d",
            pGlobalConfig->RouteReportInterval, DVMRP_ROUTE_REPORT_INTERVAL);
            
        return ERROR_INVALID_DATA;
    }


    //
    // check RouteExpirationInterval (min 40)
    //
    
    if (pGlobalConfig->RouteExpirationInterval
        != DVMRP_ROUTE_EXPIRATION_INTERVAL
        ) {

        Trace2(CONFIG,
            "RouteExpirationInterval being set to %d. Suggested value:%d",
            pGlobalConfig->RouteExpirationInterval,
            DVMRP_ROUTE_EXPIRATION_INTERVAL);
    }

    if (pGlobalConfig->RouteExpirationInterval < (2*10 + 20)) {

        Trace2(ERR,
            "RouteExpirationInterval has very low value:%d, suggested:%d",
            pGlobalConfig->RouteExpirationInterval,
            DVMRP_ROUTE_EXPIRATION_INTERVAL);

        return ERROR_INVALID_DATA;
    }


    //
    // check RouteHolddownInterval
    //
    
    if (pGlobalConfig->RouteHolddownInterval != DVMRP_ROUTE_HOLDDOWN_INTERVAL
        ) {

        Trace2(CONFIG,
            "RouteHolddownInterval being set to %d. Suggested value:%d",
            pGlobalConfig->RouteHolddownInterval,
            DVMRP_ROUTE_HOLDDOWN_INTERVAL);
    }


    //
    // check PruneLifetimeInterval
    //
    
    if (pGlobalConfig->PruneLifetimeInterval != DVMRP_PRUNE_LIFETIME_INTERVAL
        ) {

        Trace2(CONFIG,
            "PruneLifetimeInterval being set to %d. Suggested value:%d\n",
            pGlobalConfig->PruneLifetimeInterval,
            DVMRP_PRUNE_LIFETIME_INTERVAL);
    }

    if (pGlobalConfig->PruneLifetimeInterval < 600000) {

        Trace2(ERR,
            "PruneLifeTime has very low value:%d, suggested:%d",
            pGlobalConfig->PruneLifetimeInterval,
            DVMRP_PRUNE_LIFETIME_INTERVAL);

        return ERROR_INVALID_DATA;
    }
    
    return NO_ERROR;
    
} //end _ValidateGlobalConfig



DWORD
APIENTRY
StartComplete(
    VOID
    )
{
    return NO_ERROR;
}

/*-----------------------------------------------------------------------------
Functions to display the MibTable on the TraceWindow periodically
Locks:
Arguments:
Return Values:
-----------------------------------------------------------------------------*/

DWORD
APIENTRY
StopProtocol(
    VOID
    )
{


    
    return NO_ERROR;
}


VOID
WF_StopProtocolComplete(
    )
{


    
    //
    // deregister tracing/error logging if they were
    // registered in RegisterProtocol/StartProtocol call
    //

    DEINITIALIZE_TRACING_LOGGING();    


    return;
}





VOID
ProtocolCleanup(
    )
{
    if (Globals.ActivityEvent) {

        CloseHandle(Globals.ActivityEvent);
    }

    ZeroMemory(&Globals, sizeof(Globals));
    ZeroMemory(&GlobalConfig, sizeof(GlobalConfig));

}


DWORD
WINAPI
GetGlobalInfo(
    IN OUT PVOID    pvConfig,
    IN OUT PDWORD   pdwSize,
    IN OUT PULONG   pulStructureVersion,
    IN OUT PULONG   pulStructureSize,
    IN OUT PULONG   pulStructureCount
    )
{
    DWORD       Error = NO_ERROR;
    return Error;
}

DWORD
WINAPI
SetGlobalInfo(
    IN PVOID pvConfig,
    IN ULONG ulStructureVersion,
    IN ULONG ulStructureSize,
    IN ULONG ulStructureCount
    )
{
    DWORD       Error = NO_ERROR;
    return Error;
}


DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT PMESSAGE                pResult
    )
{
    DWORD Error;

    //
    // Note: _GetEventMessage() does not use the
    // EnterIgmpApi()/LeaveIgmpApi() mechanism,
    // since it may be called after Igmp has stopped, when the
    // Router Manager is retrieving the ROUTER_STOPPED message
    //

    Trace2(ENTER, "entering _GetEventMessage: pEvent(%08x) pResult(%08x)",
                pEvent, pResult);



    ACQUIRE_LIST_LOCK(&Globals1.RtmQueue, "RtmQueue", "_GetEventMessage");

    Error = DequeueEvent(&Globals1.RtmQueue, pEvent, pResult);

    RELEASE_LIST_LOCK(&Globals1.RtmQueue, "RtmQueue", "_GetEventMessage");



    Trace1(LEAVE, "leaving _GetEventMessage: %d\n", Error);

    return Error;
}

DWORD
DequeueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS *pEventType,
    PMESSAGE pMsg
    )
{
    PLIST_ENTRY pHead, pLe;
    PEVENT_QUEUE_ENTRY pEqe;

    pHead = &pQueue->Link;
    if (IsListEmpty(pHead)) {
        return ERROR_NO_MORE_ITEMS;
    }

    pLe = RemoveHeadList(pHead);
    pEqe = CONTAINING_RECORD(pLe, EVENT_QUEUE_ENTRY, Link);

    *pEventType = pEqe->EventType;
    *pMsg = pEqe->Msg;

    DVMRP_FREE(pEqe);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\mib.c ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File: mib.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

#include "pchdvmrp.h"
#pragma hdrstop



//-----------------------------------------------------------------------------
// Functions to display the MibTable on the TraceWindow periodically
//-----------------------------------------------------------------------------


#ifdef MIB_DEBUG



#define ClearScreen(h) {                                                    \
    DWORD _dwin,_dwout;                                                     \
    COORD _c = {0, 0};                                                      \
    CONSOLE_SCREEN_BUFFER_INFO _csbi;                                       \
    GetConsoleScreenBufferInfo(h,&_csbi);                                   \
    _dwin = _csbi.dwSize.X * _csbi.dwSize.Y;                                \
    FillConsoleOutputCharacter(h,' ',_dwin,_c,&_dwout);                     \
}

#define WRITELINE(h,c,fmt,arg) {                                            \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg);                                                 \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITE_NEWLINE(h,c)      \
    WRITELINE(                  \
        hConsole, c, "%s",      \
        ""                      \
        );

#define WRITELINE2(h,c,fmt,arg1, arg2) {                                    \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2);                                          \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE3(h,c,fmt,arg1, arg2, arg3) {                              \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3);                                    \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE4(h,c,fmt,arg1, arg2, arg3, arg4) {                        \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4);                              \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE5(h,c,fmt,arg1, arg2, arg3, arg4, arg5) {                  \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5);                        \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE6(h,c,fmt,arg1, arg2, arg3, arg4, arg5, arg6) {            \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6);                  \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE9(h,c,fmt,arg1, arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)  {\
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#endif MIB_DEBUG



DWORD
APIENTRY
MibGet(
    IN     DWORD  dwInputSize,
    IN     PVOID  pInputData,
    IN OUT PDWORD pdwOutputSize,
       OUT PVOID  pOutputData
    )
{
    DWORD       Error = NO_ERROR;
    return Error;
}

DWORD
APIENTRY
MibGetFirst(
    IN     DWORD  dwInputSize,
    IN     PVOID  pInputData,
    IN OUT PDWORD pdwOutputSize,
       OUT PVOID  pOutputData
    )
{
    DWORD                       Error=NO_ERROR;
    return Error;
}

DWORD
APIENTRY
MibGetNext(
    IN     DWORD  dwInputSize,
    IN     PVOID  pInputData,
    IN OUT PDWORD pdwOutputSize,
       OUT PVOID  pOutputData
    )
{
    DWORD                       Error = NO_ERROR;
    return Error;
}


DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    )
{

      //
    // Not supported
    //

    return NO_ERROR;

}


DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    )
{
    //
    // Not supported
    //

    return NO_ERROR;
}

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    )
{
    //
    // Not supported
    //

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\mib.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File: mib.h
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

#ifndef _MIB_H_
#define _MIB_H_


DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );


#endif //_MIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\packet.c ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File Name: packet.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================


#include "pchdvmrp.h"
#pragma hdrstop

VOID
ProcessDvmrpProbe(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    );

VOID
ProcessDvmrpReport(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    );

VOID
ProcessDvmrpPrune(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    );

VOID
ProcessDvmrpGraft(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    );

VOID
ProcessDvmrpGraftAck(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    );


//-----------------------------------------------------------------------------
//            _JoinMulticastGroup
//-----------------------------------------------------------------------------
DWORD
JoinMulticastGroup (
    SOCKET    Sock,
    DWORD    Group,
    DWORD    IfIndex,
    IPADDR   IpAddr
    )
{
    struct ip_mreq   imOption;
    DWORD            Error = NO_ERROR;
    DWORD            Retval;
    LPSTR lpszGroup = "tobefilled";
    LPSTR lpszAddr = "tobefilled";

    imOption.imr_multiaddr.s_addr = Group;
    imOption.imr_interface.s_addr = IpAddr;

    Retval = setsockopt(Sock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                        (PBYTE)&imOption, sizeof(imOption));

    if (Retval == SOCKET_ERROR) {

        Error = WSAGetLastError();

        Trace4(ERR,
            "error %d joining multicast group(%d.%d.%d.%d) on interface "
            "(%d) %d.%d.%d.%d",
            Error, PRINT_IPADDR(Group), IfIndex, PRINT_IPADDR(IpAddr));

        Logerr2(JOIN_GROUP_FAILED, "%s,%s", lpszGroup, lpszAddr, Error);
    }

    return Error;
}

//-----------------------------------------------------------------------------
//          _PostAsyncRecv
//-----------------------------------------------------------------------------

DWORD
PostAsyncRecv(
    PIF_TABLE_ENTRY pite
    )
{
    DWORD   Error = NO_ERROR;
    PASYNC_SOCKET_DATA pSocketData = pite->pSocketData;

    pSocketData->Flags = 0;
    pSocketData->FromLen = sizeof(SOCKADDR);
    
    Error = WSARecvFrom(pite->Socket, &pSocketData->WsaBuf, 1,
                &pSocketData->NumBytesReceived, &pSocketData->Flags,
                (SOCKADDR FAR *)&pSocketData->SrcAddress,
                &pSocketData->FromLen, &pSocketData->Overlapped, NULL);


    if (Error!=SOCKET_ERROR) {
        Trace0(RECEIVE, "the WSAReceiveFrom returned immediately\n");
    }
    else {
        Error = WSAGetLastError();
        if (Error!=WSA_IO_PENDING) {
            Trace1(RECEIVE,
                "WSARecvFrom returned in PostAsyncRecv() with error code:%0x",
                 Error);
            Logerr0(RECVFROM_FAILED, Error);
        }
        else
            Trace0(RECEIVE, "WSARecvFrom() returned WSA_IO_PENDING in ???");
    }

    return Error;
}

//-----------------------------------------------------------------------------
//          _McastSetTtl
// set the ttl value for multicast data. the default ttl for multicast is 1.
//-----------------------------------------------------------------------------

DWORD
McastSetTtl(
    SOCKET sock,
    UCHAR ttl
    )
{
    INT         dwTtl = ttl;
    DWORD       Error=NO_ERROR;

    Error = setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL,
                                        (char *)&dwTtl, sizeof(dwTtl));
    if (Error != 0) {
        Error = WSAGetLastError();
        Trace1(ERR, "error:%d: unable to set ttl value", Error);
        return Error;
    }

    return Error;
}

//-----------------------------------------------------------------------------
//          _ProcessAsyncReceivePacket
//-----------------------------------------------------------------------------

VOID
ProcessAsyncReceivePacket(
    DWORD           ErrorCode,
    DWORD           NumBytesRecv,
    LPOVERLAPPED    pOverlapped
    )
{
    PASYNC_SOCKET_DATA  pSocketData;
    DWORD               IfIndex, Error;
    IPADDR              SrcAddr, DstnAddr;
    CHAR                SrcAddrString[20];    
    DWORD               PacketSize, IpHdrLen;
    UCHAR               *pPacket;
    LPBYTE              Buffer;
    DVMRP_HEADER UNALIGNED   *pDvmrpHdr;
    PIF_TABLE_ENTRY     pite = NULL;
    PIP_HEADER          pIpHdr;
    UCHAR               PacketType;
    
    //
    // kslksl
    // How to get pite?
    //
    
    IfIndex = pite->IfIndex;
    
    //
    // if the IO completed due to socket being closed, check if the
    // refcount is down to 0, in which case safely delete the pite entry
    //
    
    if ( (ErrorCode != NO_ERROR) || (NumBytesRecv == 0)) {

        //
        // kslksl
        //
        
        if (InterlockedDecrement(&pite->RefCount) == 0)
            DVMRP_FREE(pite);

        return;
    }

    pSocketData = CONTAINING_RECORD(pOverlapped, ASYNC_SOCKET_DATA,
                      Overlapped);

    
    
    //
    // get interface read lock
    //

    ACQUIRE_IF_LOCK_SHARED(pite->IfIndex, "ProcessAsyncReceivePacket");


    BEGIN_BREAKOUT_BLOCK1 {
    
        // if interface is not active, then free pite if required and return

        if (!IS_IF_ACTIVATED(pite)) {
            
            if (InterlockedDecrement(&pite->RefCount) == 0) {
                DVMRP_FREE(pite);
            }

            Trace1(RECEIVE,
                "Received packet on inactive interface:%d", IfIndex);

            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }


        // set source addr of packet
        
        SrcAddr = pSocketData->SrcAddress.sin_addr.s_addr;
        lstrcpy(SrcAddrString, INET_NTOA(SrcAddr));


        // check that the packet has min length

        if (NumBytesRecv < MIN_PACKET_SIZE) {
            LPSTR lpszAddr = "<tbd>";
               
            Trace2(RECEIVE,
                "Received very short packet of length:%d from:%s",
                IfIndex, SrcAddrString);
                
            Logwarn2(PACKET_TOO_SMALL, lpszAddr, SrcAddrString, NO_ERROR);
            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }


        //
        // set packet ptr, IpHdr ptr, dwNumBytes, DstnMcastAddr
        //

        Buffer = pSocketData->WsaBuf.buf;
        IpHdrLen = (Buffer[0]&0x0F)*4;
        pIpHdr = (PIP_HEADER)Buffer;
        pPacket = &Buffer[IpHdrLen];
        PacketSize = NumBytesRecv - IpHdrLen;
        DstnAddr = (ULONG)pIpHdr->Dstn.s_addr;
        pDvmrpHdr = (DVMRP_HEADER UNALIGNED *) pPacket;
        

        //
        // verify that the packet has igmp type
        //
        
        if (pIpHdr->Protocol!=0x2) {
            Trace4(RECEIVE,
                "Packet received with IpDstnAddr(%d.%d.%d.%d) from (%s) on "
                "interface:%d is not of Igmp type(%d)",
                PRINT_IPADDR(pIpHdr->Dstn.s_addr),
                SrcAddrString, pite->IfIndex, pIpHdr->Protocol
                );
            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }


        //
        // verify that the packet has dvmrp type field
        //

        if ( pDvmrpHdr->Vertype != 0x13) {

            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }

#if 0
        // kslksl
        
        //
        // Verify Igmp checksum
        //
        if (xsum(pDvmrpHdr, sizeof(DVMRP_HEADER)) != 0xffff) {
            Trace0(RECEIVE, "Wrong checksum packet received");
            GOTO_END_BLOCK1
        }
#endif
        
        //
        // verify that the packet has correct code
        //

        PacketType = pDvmrpHdr->Code;

        switch (PacketType) {

            case DVMRP_PROBE:
            {
                ProcessDvmrpProbe(pite, pPacket, PacketSize, SrcAddr);
                break;
            }
            
            case DVMRP_REPORT:
            {
                ProcessDvmrpReport(pite, pPacket, PacketSize, SrcAddr);
                break;
            }
            
            case DVMRP_PRUNE:
            {
                ProcessDvmrpPrune(pite, pPacket, PacketSize, SrcAddr);
                break;
            }
            
            case DVMRP_GRAFT:
            {
                ProcessDvmrpGraft(pite, pPacket, PacketSize, SrcAddr);
                break;
            }
            
            case DVMRP_GRAFT_ACK:
            {
                ProcessDvmrpGraftAck(pite, pPacket, PacketSize, SrcAddr);
                break;
            }
            
        }
        
    } END_BREAKOUT_BLOCK1;

    PostAsyncRecv(pite);

    
}//end ProcessAsyncReceive


VOID
ProcessDvmrpProbe(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    )
{
}

VOID
ProcessDvmrpReport(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    )
{
}

VOID
ProcessDvmrpPrune(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    )
{
}

VOID
ProcessDvmrpGraft(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    )
{
}

VOID
ProcessDvmrpGraftAck(
    PIF_TABLE_ENTRY pite,
    UCHAR *Packet,
    ULONG PacketSize,
    IPADDR SrcAddr
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\pchdvmrp.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// Module Name: pchdvmrp.c
// Abstract:
//      Precompiled header for Dvmrp
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define FD_SETSIZE      256
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <rtm.h>
#include <rtmv2.h>
#include <routprot.h>
#include <mprerror.h>
#include <rtutils.h>
#include <crt\stddef.h>
#include <TCHAR.H>
#include <iprtrmib.h>
#include <mstcpip.h>
#include <mgm.h>
#include <igmprm.h>
#include <dvmrp.h>
#include "trace.h"
#include "log.h"
#include "defines.h"
#include "sync.h"
#include "main.h"
#include "if.h"
#include "if1.h"
#include "mib.h"
#include "debug.h"
#include "peer.h"
#include "work.h"
#include "packet.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\packet.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File Name: packet.h
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================



//-----------------------------------------------------------------------------
// ASYNC_SOCKET_DATA structure is used to pass / receive back data from an
// asynchronous wait recv from call
//-----------------------------------------------------------------------------

typedef struct _ASYNC_SOCKET_DATA {

    OVERLAPPED      Overlapped;
    WSABUF          WsaBuf;

    SOCKADDR_IN     SrcAddress;
    DWORD           FromLen;
    DWORD           NumBytesReceived;
    DWORD           Flags;
    DWORD           Status;

    PIF_TABLE_ENTRY pite;               //pite is valid as long as recvFrom is pending
    
} ASYNC_SOCKET_DATA, *PASYNC_SOCKET_DATA;


#define PACKET_BUFFER_SIZE  4000


#pragma pack(1)

//-----------------------------------------------------------------------------
// DVMRP_HEADER
//-----------------------------------------------------------------------------

typedef struct _DVMRP_HEADER {

    UCHAR       Vertype;
    UCHAR       Code;
    USHORT      Xsum;
    USHORT      Reserved;
    UCHAR       MinorVersion;
    UCHAR       MajorVersion;

} DVMRP_HEADER, *PDVMRP_HEADER;


#define MIN_PACKET_SIZE     sizeof(DVMRP_HEADER)
#define IPVERSION           4


//-----------------------------------------------------------------------------
// IP_HEADER
//-----------------------------------------------------------------------------

typedef struct _IP_HEADER {

    UCHAR              Hl;              // Version and length.
    UCHAR              Tos;             // Type of service.
    USHORT             Len;             // Total length of datagram.
    USHORT             Id;              // Identification.
    USHORT             Offset;          // Flags and fragment offset.
    UCHAR              Ttl;             // Time to live.
    UCHAR              Protocol;        // Protocol.
    USHORT             Xsum;            // Header checksum.
    struct in_addr     Src;             // Source address.
    struct in_addr     Dstn;            // Destination address.

} IP_HEADER, *PIP_HEADER;

#pragma pack()


//
// prototypes
//

DWORD
JoinMulticastGroup (
    SOCKET    Sock,
    DWORD    Group,
    DWORD    IfIndex,
    IPADDR   IpAddr
    );

DWORD
PostAsyncRead(
    PIF_TABLE_ENTRY pite
    );

DWORD
McastSetTtl(
    SOCKET sock,
    UCHAR ttl
    );

VOID
ProcessAsyncReceivePacket(
    DWORD           ErrorCode,
    DWORD           NumBytesRecv,
    LPOVERLAPPED    pOverlapped
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\peer.c ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File Name: main.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

#include "pchdvmrp.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\peer.h ===
//-----------------------------------------------------------------------------
// PEER_ENTRY
//-----------------------------------------------------------------------------

typedef struct _PEER_ENTRY {

    LIST_ENTRY          Link;           // link all peers for that IF

    IPADDR              IpAddr;
    DWORD               Status;
    DWORD               MajorVersion;
    DWORD               MinorVersion;
    DWORD               GenerationId;
    
    PDYNAMIC_RW_LOCK    DRWL;           // DRWL for the peer
    

} _PEER_ENTRY, *PPEER_ENTRY;


//
// macros for G_PeerLists_CS lock
//

#define ACQUIRE_PEER_LISTS_LOCK(_proc) \
        ENTER_CRITICAL_SECTION(&G_pIfTable->PeerLists_CS, \
            "G_PeerListsCS", _proc);

#define RELEASE_PEER_LISTS_LOCK(_proc) \
        LEAVE_CRITICAL_SECTION(&G_pIfTable->PeerLists_CS, \
            "G_PeerListsCS", _proc);


//
// macros for PeerEntry->DRWL
//

#define ACQUIRE_PEER_LOCK_EXCLUSIVE(PeerEntry, _proc) \
        ACQUIRE_DYNAMIC_WRITE_LOCK( \
            &PeerEntry->DRWL, &Globals.DynamicRWLStore)
            
#define RELEASE_PEER_LOCK_EXCLUSIVE(PeerEntry, _proc) \
        RELEASE_DYNAMIC_WRITE_LOCK( \
            &PeerEntry->DRWL, &Globals.DynamicRWLStore)

#define ACQUIRE_PEER_LOCK_SHARED(PeerEntry, _proc) \
        ACQUIRE_DYNAMIC_READ_LOCK( \
            &PeerEntry->DRWL, &Globals.DynamicRWLStore)
            
#define RELEASE_PEER_LOCK_SHARED(PeerEntry, _proc) \
        RELEASE_DYNAMIC_READ_LOCK( \
            &PeerEntry->DRWL, &Globals.DynamicRWLStore)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\sync.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
// File: sync.h
//
// History:
//      Abolade Gbadegesin
//      K.S.Lokesh (added Dynamic Locking)
//
// Contains structures and macros used to implement synchronization.
//============================================================================

#ifndef _SYNC_H_
#define _SYNC_H_


//
// type definition for multiple-reader/single-writer lock
// Note: there is a similar facility provided by nturtl.h
// through the structure RTL_RESOURCE and several functions.
// However, that implementation has the potential for starving
// a thread trying to acquire write accesss, if there are a large
// number of threads interested in acquiring read access.
// Such a scenario is avoided in the implementation given in this
// header. However, a mapping is also given to the RTL_RESOURCE
// functionality, so that DVMRP can be compiled to use either form
//

#ifdef DVMRP_RWL

//
// use DVMRP's definitions
//

typedef struct _READ_WRITE_LOCK {

    CRITICAL_SECTION    RWL_ReadWriteBlock;
    LONG                RWL_ReaderCount;
    HANDLE              RWL_ReaderDoneEvent;

} READ_WRITE_LOCK, *PREAD_WRITE_LOCK;


DWORD CreateReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID DeleteReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireReadLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseReadLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireWriteLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseWriteLock(PREAD_WRITE_LOCK pRWL);


//
// macro functions for manipulating a read-write lock
//

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
    CreateReadWriteLock(pRWL)
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
    DeleteReadWriteLock(pRWL)

#define READ_WRITE_LOCK_CREATED(pRWL)                                       \
            ((pRWL)->RWL_ReaderDoneEvent != NULL)


// print locks.
#ifdef LOCK_DBG

#define ACQUIRE_READ_LOCK(pRWL, type, proc)   {\
    Trace2(CS,"----to AcquireReadLock %s in %s", type, proc); \
    AcquireReadLock(pRWL); \
    Trace2(CS,"----GotReadLock %s in %s", type, proc); \
    }


#define RELEASE_READ_LOCK(pRWL, type, proc)    {\
    Trace2(CS,"----Released ReadLock %s in %s", type, proc); \
    ReleaseReadLock(pRWL); \
    }
    

#define ACQUIRE_WRITE_LOCK(pRWL, type, proc)      {\
    Trace2(CS,"----to AcquireWriteLock %s in %s", type, proc); \
    AcquireWriteLock(pRWL);    \
    Trace2(CS,"----AcquiredWriteLock %s in %s", type, proc);\
    }
    

#define RELEASE_WRITE_LOCK(pRWL, type, proc)     {\
    Trace2(CS,"----Released WriteLock %s in %s", type, proc); \
    ReleaseWriteLock(pRWL);\
    }


#else //LOCK_DBG
#define ACQUIRE_READ_LOCK(pRWL, type, proc)   \
    AcquireReadLock(pRWL)


#define RELEASE_READ_LOCK(pRWL, type, proc)    \
    ReleaseReadLock(pRWL)
    

#define ACQUIRE_WRITE_LOCK(pRWL, type, proc)      \
    AcquireWriteLock(pRWL)
    

#define RELEASE_WRITE_LOCK(pRWL, type, proc)     \
    ReleaseWriteLock(pRWL)


#endif //LOCK_DBG
#define READ_LOCK_TO_WRITE_LOCK(pRWL, type, proc)                                       \
    (RELEASE_READ_LOCK(pRWL, type, proc), ACQUIRE_WRITE_LOCK(pRWL, type, proc))

#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
    (RELEASE_WRITE_LOCK(pRWL, type, proc), ACQUIRE_READ_LOCK(pRWL, type, proc))

#else // i.e. !DVMRP_RWL


//
// use the RTL_RESOURCE mechanism
//

typedef RTL_RESOURCE READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
            RtlInitializeResource((pRWL))
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
            RtlDeleteResource((pRWL))
#define READ_WRITE_LOCK_CREATED(pRWL)   (TRUE)
#define ACQUIRE_READ_LOCK(pRWL)                                             \
            RtlAcquireResourceShared((pRWL),TRUE)
#define RELEASE_READ_LOCK(pRWL)                                             \
            RtlReleaseResource((pRWL))
#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
            RtlAcquireResourceExclusive((pRWL),TRUE)
#define RELEASE_WRITE_LOCK(pRWL)                                            \
            RtlReleaseResource((pRWL))
#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
            RtlConvertSharedToExclusive((pRWL))
#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
            RtlConvertExclusiveToShared((pRWL))

#endif // DVMRP_RWL



//
// type definition for generic locked list
// access is sychronized with a critical section
//

typedef struct _LOCKED_LIST {
    LIST_ENTRY          Link;
    CRITICAL_SECTION    Lock;
    DWORD               CreatedFlag;
} LOCKED_LIST, *PLOCKED_LIST;



//
// macro functions for manipulating the locked list
//

#define CREATE_LOCKED_LIST(pLL)      {\
            InitializeListHead(&(pLL)->Link);        \
            InitializeCriticalSection(&(pLL)->Lock);  \
            (pLL)->CreatedFlag = 0x12345678; \
            }

#define LOCKED_LIST_CREATED(pLL)                            \
            ((pLL)->CreatedFlag == 0x12345678)

#define DELETE_LOCKED_LIST(pLL,type,field) {                \
            PLIST_ENTRY _ple;                               \
            (pLL)->CreatedFlag = 0;                          \
            DeleteCriticalSection(&(pLL)->Lock);         \
            while (!IsListEmpty(&(pLL)->Link)) {         \
                _ple = RemoveHeadList(&(pLL)->Link);     \
                DVMRP_FREE(CONTAINING_RECORD(_ple,type,field));\
            }                                               \
        }

        

#define ACQUIRE_LIST_LOCK(pLL, type, name)                              \
            ENTER_CRITICAL_SECTION(&(pLL)->Lock, type, name)

#define RELEASE_LIST_LOCK(pLL, type, name)                              \
            LEAVE_CRITICAL_SECTION(&(pLL)->Lock, type, name)

















// for debugging, Set ids for each dynamic lock

#ifdef LOCK_DBG
    extern DWORD    DynamicCSLockId;
    extern DWORD    DynamicRWLockId;
#endif;

typedef enum {
    LOCK_TYPE_CS, LOCK_TYPE_RW, LOCK_MODE_READ, LOCK_MODE_WRITE
} LOCK_TYPE; 

    
//-----------------------------------------------------------------
//          struct DYNAMIC_CS_LOCK
//
// the dynamic lock struct which is allocated to anyone requesting it
//-----------------------------------------------------------------
typedef struct _DYNAMIC_CS_LOCK {

    CRITICAL_SECTION    CS;

    union {
        DWORD           Count; // number of threads waiting
        LIST_ENTRY      Link;  // link in list of free entries
    };
    
    #ifdef LOCK_DBG
    DWORD               Id;
    #endif
    
} DYNAMIC_CS_LOCK, *PDYNAMIC_CS_LOCK;


//---------------------------------------
// DYNAMICALLY_LOCKED_HASH_TABLE
// AcquireDynamicCSLockedList and ReleaseDynamicCSLock depend on this struct defn
//---------------------------------------
typedef struct _DYNAMIC_CS_LOCKED_LIST {

    LIST_ENTRY          Link;
    PDYNAMIC_CS_LOCK    pDCSLock;

} DYNAMIC_CS_LOCKED_LIST, *PDYNAMIC_CS_LOCKED_LIST;



#define InitDynamicCSLockedList(pDCSLockedList) { \
            InitializeListHead(&(pDCSLockedList)->Link); \
            (pDCSLockedList)->pDCSLock = NULL; \
        } 


        
//
// if more than DYNAMIC_LOCKS_CS_HIGH_THRESHOLD CS locks allocated
// then any locks that are freed are destroyed
//
#define DYNAMIC_LOCKS_CS_HIGH_THRESHOLD 7



//-----------------------------------------------------------------
//          struct DYNAMIC_LOCKS_STORE
//
// Contains the store of free dynamic CS locks which can be 
// allocated when required. Protected by a CS
//-----------------------------------------------------------------
typedef struct _DYNAMIC_LOCKS_STORE {

    CRITICAL_SECTION    CS;
    LIST_ENTRY          ListOfFreeLocks;

    DWORD               CountAllocated;
    DWORD               CountFree;
    
} DYNAMIC_LOCKS_STORE, *PDYNAMIC_LOCKS_STORE;



#define AcquireDynamicCSLockedList(pDCSLockedList, pDCSStore) \
            AcquireDynamicCSLock(&((pDCSLockedList)->pDCSLock), pDCSStore)

#define ReleaseDynamicCSLockedList(pDCSLockedList, pDCSStore) \
            ReleaseDynamicCSLock(&(pDCSLockedList)->pDCSLock, pDCSStore)






//
// if more than DYNAMIC_LOCKS_CS_HIGH_THRESHOLD CS locks allocated
// then any locks that are freed are destroyed
//
#define DYNAMIC_LOCKS_CS_HIGH_THRESHOLD 7


//-----------------------------------------------------------------
//          struct DYNAMIC_RW_LOCK
//
// the dynamic lock struct which is allocated to anyone requesting it
//-----------------------------------------------------------------
typedef struct _DYNAMIC_RW_LOCK {

    READ_WRITE_LOCK     RWL;

    union {
        DWORD           Count; // number of threads waiting
        LIST_ENTRY      Link;  // link in list of free entries
    };
    
    #ifdef LOCK_DBG
    DWORD               Id;
    #endif
    
} DYNAMIC_RW_LOCK, *PDYNAMIC_RW_LOCK;


//---------------------------------------
// DYNAMICALLY_LOCKED_HASH_TABLE
// AcquireDynamicRWLockedList and ReleaseDynamicRWLock depend on this struct defn
//---------------------------------------
typedef struct _DYNAMIC_RW_LOCKED_LIST {

    LIST_ENTRY          Link;
    PDYNAMIC_RW_LOCK    pDRWLock;

} DYNAMIC_RW_LOCKED_LIST, *PDYNAMIC_RW_LOCKED_LIST;



#define InitDynamicRWLockedList(pDRWLockedList) { \
            InitializeListHead(&(pDRWLockedList)->Link); \
            (pDRWLockedList)->pDRWLock = NULL; \
        } 


#define AcquireDynamicRWLockedList(pDRWLockedList, pDRWStore) \
            AcquireDynamicCSLock(&((pDRWLockedList)->pDRWLock), pDRWStore)

#define ReleaseDynamicRWLockedList(pDRWLockedList, pDRWStore) \
            ReleaseDynamicRWLock(&(pDRWLockedList)->pDRWLock, pDRWStore)





//
// PROTOTYPES
//

DWORD
InitializeDynamicLocks (
    PDYNAMIC_LOCKS_STORE    pDLStore //ptr to Dynamic CS Store
    );

VOID
DeInitializeDynamicLocks (
    PDYNAMIC_LOCKS_STORE    pDCSStore,
    LOCK_TYPE               LockType  //if True, then store of CS, else of RW locks
    );

DWORD
AcquireDynamicCSLock (
    PDYNAMIC_CS_LOCK        *ppDCSLock,
    PDYNAMIC_LOCKS_STORE    pDCSStore
    );

PDYNAMIC_CS_LOCK
GetDynamicCSLock (
    PDYNAMIC_LOCKS_STORE    pDCSStore
    );

VOID
ReleaseDynamicCSLock (
    PDYNAMIC_CS_LOCK        *ppDCSLock,
    PDYNAMIC_LOCKS_STORE    pDCSStore
    );

VOID
FreeDynamicCSLock (
    PDYNAMIC_CS_LOCK        pDCSLock,
    PDYNAMIC_LOCKS_STORE    pDCSStore
    );


DWORD
AcquireDynamicRWLock (
    PDYNAMIC_RW_LOCK        *ppDRWLock,
    LOCK_TYPE               LockMode,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    );


#define ACQUIRE_DYNAMIC_READ_LOCK(RWL, Store) \
    AcquireDynamicRWLock(DRWL, LOCK_MODE_READ, Store)

#define RELEASE_DYNAMIC_READ_LOCK(RWL, Store) \
    ReleaseDynamicRWLock(DRWL,LOCK_MODE_READ, Store)

#define ACQUIRE_DYNAMIC_WRITE_LOCK(RWL, Store) \
    AcquireDynamicRWLock(DRWL,LOCK_MODE_WRITE, Store)

#define RELEASE_DYNAMIC_WRITE_LOCK(RWL, Store) \
    ReleaseDynamicRWLock(DRWL,LOCK_MODE_WRITE, Store)


            
PDYNAMIC_RW_LOCK
GetDynamicRWLock (
    PDYNAMIC_LOCKS_STORE   pDRWStore
    );

VOID
ReleaseDynamicRWLock (
    PDYNAMIC_RW_LOCK        *ppDRWLock,
    LOCK_TYPE               LockMode,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    );
    
VOID
FreeDynamicRWLock (
    PDYNAMIC_RW_LOCK        pDRWLock,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    );
    
DWORD QueueDvmrpWorker();
BOOL  EnterDvmrpWorker();
VOID  LeaveDvmrpWorker();









#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\sync.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
// File:    sync.c
//
// History:
//  Abolade Gbadegesin
//  K.S.Lokesh (added Dynamic locking)
//
// Synchronization routines used by DVMRP.
//============================================================================

#include "pchdvmrp.h"
#pragma hdrstop


// for debugging, Set ids for each dynamic lock

#ifdef LOCK_DBG
    DWORD   DynamicCSLockId;
    DWORD   DynamicRWLockId;
#endif;


//----------------------------------------------------------------------------
//      _QueueDvmrpWorker
//
// This function is called to queue a Dvmrp function in a safe fashion;
// If cleanup is in progress or if Dvmrp has stopped, this function
// discards the work-item. So dont use this function if you want the
// work item to be executed when the protocol is being stopped.
//----------------------------------------------------------------------------

DWORD
QueueDvmrpWorker(
    LPTHREAD_START_ROUTINE pFunction,
    PVOID pContext
    )
{

    DWORD Error = NO_ERROR;
    BOOL  Success;

    
    EnterCriticalSection(&Globals1.WorkItemCS);

    if (Globals1.RunningStatus != DVMRP_STATUS_RUNNING) {

        //
        // cannot queue a work function when dvmrp has quit or is quitting
        //

        Error = ERROR_CAN_NOT_COMPLETE;
    }
    else {

        ++Globals.ActivityCount;
        Success = QueueUserWorkItem(pFunction, pContext, 0);

        if (!Success) {

            Error = GetLastError();
            Trace1(ERR, "Error: Attempt to queue work item returned:%d",    
                    Error);
            if (--Globals.ActivityCount == 0) {
                SetEvent(Globals.ActivityEvent);
            }
        }
    }

    LeaveCriticalSection(&Globals1.WorkItemCS);

    return Error;
}



//----------------------------------------------------------------------------
//      _EnterDvmrpWorker
//
// This function is called when entering a dvmrp worker-function.
// Since there is a lapse between the time a worker-function is queued
// and the time the function is actually invoked by a worker thread,
// this function must check to see if dvmrp has stopped or is stopping;
// if this is the case, then it decrements the activity count, 
// sets ActivityEvent if outstanding work items == 0, and quits.
//----------------------------------------------------------------------------

BOOL
EnterDvmrpWorker(
    )
{
    BOOL Entered;


    EnterCriticalSection(&Globals1.WorkItemCS);

    if (Globals1.RunningStatus == DVMRP_STATUS_RUNNING) {

        // dvmrp is running, so the function may continue

        Entered = TRUE;
    }
    else if (Globals1.RunningStatus == DVMRP_STATUS_STOPPING) {

        // dvmrp is not running, but it was, so the function must stop.

        if (--Globals.ActivityCount == 0) {
            SetEvent(Globals.ActivityEvent);
        }

        Entered = FALSE;
    }

    LeaveCriticalSection(&Globals1.WorkItemCS);

    return Entered;
}



//----------------------------------------------------------------------------
//      _LeaveDvmrpWorker
//
// This function is called when leaving a dvmrp worker function.
// It decrements the activity count, and sets the ActivityEvent if
// dvmrp is stopping and there are no pending work items.
//----------------------------------------------------------------------------

VOID
LeaveDvmrpWorker(
    )
{

    EnterCriticalSection(&Globals1.WorkItemCS);

    if (--Globals.ActivityCount == 0) {

        SetEvent(Globals.ActivityEvent);
    }

    LeaveCriticalSection(&Globals1.WorkItemCS);
}



//----------------------------------------------------------------------------
//      _CreateReadWriteLock
//
// Initializes a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{

    pRWL->RWL_ReaderCount = 0;

    try {
        InitializeCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    pRWL->RWL_ReaderDoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (pRWL->RWL_ReaderDoneEvent != NULL) {
        return GetLastError();
    }

    return NO_ERROR;
}



//----------------------------------------------------------------------------
//      _DeleteReadWriteLock
//
// Frees resources used by a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    CloseHandle(pRWL->RWL_ReaderDoneEvent);
    pRWL->RWL_ReaderDoneEvent = NULL;
    DeleteCriticalSection(&pRWL->RWL_ReadWriteBlock);
    pRWL->RWL_ReaderCount = 0;
}



//----------------------------------------------------------------------------
//      _AcquireReadLock
//
// Secures shared ownership of the lock object for the caller.
//
// readers enter the read-write critical section, increment the count,
// and leave the critical section
//----------------------------------------------------------------------------

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock); 
    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&pRWL->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
//      _ReleaseReadLock
//
// Relinquishes shared ownership of the lock object.
//
// the last reader sets the event to wake any waiting writers
//----------------------------------------------------------------------------

VOID
ReleaseReadLock (
    PREAD_WRITE_LOCK pRWL
    )
{
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) < 0) {
        SetEvent(pRWL->RWL_ReaderDoneEvent); 
    }
}



//----------------------------------------------------------------------------
//      _AcquireWriteLock
//
// Secures exclusive ownership of the lock object.
//
// the writer blocks other threads by entering the ReadWriteBlock section,
// and then waits for any thread(s) owning the lock to finish
//----------------------------------------------------------------------------

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock);
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) >= 0) { 
        WaitForSingleObject(pRWL->RWL_ReaderDoneEvent, INFINITE);
    }
}



//----------------------------------------------------------------------------
//      _ReleaseWriteLock
//
// Relinquishes exclusive ownership of the lock object.
//
// the writer releases the lock by setting the count to zero
// and then leaving the ReadWriteBlock critical section
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL
    )
{
    pRWL->RWL_ReaderCount = 0;
    LeaveCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
//      _InitializeDynamicLocks
//
// Initialize the global struct from which dynamic CS / RW locks are allocated
//----------------------------------------------------------------------------

DWORD
InitializeDynamicLocks (
    PDYNAMIC_LOCKS_STORE   pDLStore //ptr to Dynamic Locks store
    )
{
    DWORD Error=NO_ERROR;

    BEGIN_BREAKOUT_BLOCK1 {

        //
        // initialize the main CS lock which protects the list of free locks
        //

        try {
            InitializeCriticalSection(&pDLStore->CS);
        }
        HANDLE_CRITICAL_SECTION_EXCEPTION(Error, GOTO_END_BLOCK1);


        // initialize list of free locks
        
        InitializeListHead(&pDLStore->ListOfFreeLocks);


        // initialize counts for number of locks free and allocated to 0.
        
        pDLStore->CountAllocated = pDLStore->CountFree = 0;

        
    } END_BREAKOUT_BLOCK1;

    return Error;
}


//----------------------------------------------------------------------------
//          _DeInitializeDynamicLocksStore
//
// Delete the main CS lock and the other free locks. Print warning if any
// locks have been allocated and not freed.
//----------------------------------------------------------------------------
VOID
DeInitializeDynamicLocks (
    PDYNAMIC_LOCKS_STORE    pDLStore,
    LOCK_TYPE               LockType  //LOCK_TYPE_CS,LOCK_TYPE_RW
    )
{
    PDYNAMIC_CS_LOCK    pDCSLock;
    PDYNAMIC_RW_LOCK    pDRWLock;
    PLIST_ENTRY         pHead, pLe;

    
    Trace0(ENTER1, "Entering _DeInitializeDynamicLocksStore()");
    
    if (pDLStore==NULL)
        return;


        
    // delete the main CS lock
    
    DeleteCriticalSection(&pDLStore->CS);


    // print warning if any dynamic lock has not been freed
    
    if (pDLStore->CountFree>0) {
        Trace1(ERR, 
            "%d Dynamic locks have not been freed during Deinitialization",
            pDLStore->CountFree);
    }



    //
    // delete all dynamic CS/RW locks. I dont free memory(left to heapDestroy)
    //
    
    pHead = &pDLStore->ListOfFreeLocks;
    for (pLe=pHead->Flink;  pLe!=pHead;  pLe=pLe->Flink) {

        // if bCSLocks flag, then it is a store of CS locks
        if (LockType==LOCK_TYPE_CS) {
        
            pDCSLock = CONTAINING_RECORD(pLe, DYNAMIC_CS_LOCK, Link);

            DeleteCriticalSection(&pDCSLock->CS);
        }

        // delete the RW lock
        else {
        
            pDRWLock = CONTAINING_RECORD(pLe, DYNAMIC_RW_LOCK, Link);

            DELETE_READ_WRITE_LOCK(&pDRWLock->RWL);
        }
    }

    Trace0(LEAVE1, "Leaving _DeInitializeDynamicLocksStore()");
    return;
}



//----------------------------------------------------------------------------
//          _AcquireDynamicCSLock
//
// Acquires the MainLock associated with the table, Acquires a new dynamic
// lock if required, increments the count, releases the MainLock and 
// locks the LockedList.
//----------------------------------------------------------------------------

DWORD
AcquireDynamicCSLock (
    PDYNAMIC_CS_LOCK        *ppDCSLock,
    PDYNAMIC_LOCKS_STORE    pDCSStore
    )
{
    // acquire the main lock for the Dynamic CS store
    
    ENTER_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
        "_AcquireDynamicCSLock");


    //
    // If it is not already locked then allocate a lock
    //
    
    if (*ppDCSLock==NULL) {

        *ppDCSLock = GetDynamicCSLock(pDCSStore);


        // if could not get a lock, then igmp is in serious trouble
        
        if (*ppDCSLock==NULL) {
        
            LEAVE_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
                "_AcquireDynamicCSLock");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    
    // increment Count in the Dynamic Lock

    (*ppDCSLock)->Count++;



    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
                            "_AcquireDynamicCSLock");


    //
    // enter dynamic lock's CS lock
    //
    ENTER_CRITICAL_SECTION(&(*ppDCSLock)->CS, "pDynamicLock", 
        "_AcquireDynamicCSLock");
        
    
    return NO_ERROR;
    
} //end _AcquireDynamicCSLock



//----------------------------------------------------------------------------
//          _GetDynamicCSLock
//
// If a free lock is available, returns it. Else allocates a new CS lock
// Lock: Assumes the DCSStore MainLock
// Called by: _AcquireDynamicCSLock
//----------------------------------------------------------------------------

PDYNAMIC_CS_LOCK
GetDynamicCSLock (
    PDYNAMIC_LOCKS_STORE   pDCSStore
    )
{
    PDYNAMIC_CS_LOCK    pDCSLock;
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         pLe;
    
    
    //
    // free dynamic lock available. Return it
    //
    
    if (!IsListEmpty(&pDCSStore->ListOfFreeLocks)) {

        pDCSStore->CountFree--;

        pLe = RemoveTailList(&pDCSStore->ListOfFreeLocks);

        pDCSLock = CONTAINING_RECORD(pLe, DYNAMIC_CS_LOCK, Link);
        
        Trace1(DYNLOCK, "Leaving GetDynamicCSLock.1(%d):reusing lock", 
            pDCSLock->Id);
        
        return pDCSLock;
    }


    // allocate memory for a new dynamic lock
    
    pDCSLock = DVMRP_ALLOC(sizeof(DYNAMIC_CS_LOCK));

    PROCESS_ALLOC_FAILURE2(pDCSLock, "dynamic CS lock",
        Error, sizeof(DYNAMIC_CS_LOCK), return NULL);


    pDCSStore->CountAllocated++;

    //
    // initialize the fields
    //
    
    try {
        InitializeCriticalSection(&pDCSLock->CS);
    }
    HANDLE_CRITICAL_SECTION_EXCEPTION(Error, return NULL);


    // no need to initialize the link field
    //InitializeListEntry(&pDCSLock->List);
    
    pDCSLock->Count = 0;
    #ifdef LOCK_DBG
        pDCSLock->Id = ++DynamicCSLockId;
    #endif


    Trace1(DYNLOCK, "Leaving _GetDynamicCSLock(%d):new lock",
        DynamicCSLockId);

    return pDCSLock;
    
} //end _GetDynamicCSLock




//----------------------------------------------------------------------------
//          _ReleaseDynamicCSLock
//
// Acquires the MainLock associated with the table, decrements the count, 
// releases the DynamicLock if count becomes 0 and releases the MainLock.
//----------------------------------------------------------------------------

VOID
ReleaseDynamicCSLock (
    PDYNAMIC_CS_LOCK    *ppDCSLock,
    PDYNAMIC_LOCKS_STORE   pDCSStore
    )
{
    PDYNAMIC_CS_LOCK    pDCSLock = *ppDCSLock;
    
    
    // acquire the main lock for the Dynamic CS store
    
    ENTER_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
                        "_ReleaseDynamicCSLock");



    // leave the dynamic lock CS
    
    LEAVE_CRITICAL_SECTION(&pDCSLock->CS, "pDynamicLock", 
                        "_ReleaseDynamicCSLock");


          
    // Decrement Count in the Dynamic Lock. Free the dynamic lock if count==0
  
    if (--pDCSLock->Count==0) {

        FreeDynamicCSLock(pDCSLock, pDCSStore);

        // make the pDCSLock NULL so that it is known that it is not locked
        *ppDCSLock = NULL;
        
    }


    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
            "_ReleaseDynamicCSLock");

            
    //Trace0(LEAVE1, "Leaving _ReleaseDynamicCSLock()");

    return;
    
} //end _ReleaseDynamicCSLock


//----------------------------------------------------------------------------
//          _FreeDynamicCSLock
// Called by: _ReleaseDynamicCSLock
//----------------------------------------------------------------------------

VOID
FreeDynamicCSLock (
    PDYNAMIC_CS_LOCK    pDCSLock,
    PDYNAMIC_LOCKS_STORE   pDCSStore
    )
{
    // decrement count of allocated locks
    
    pDCSStore->CountAllocated--;


    // if there are too many dynamic CS locks, then free this lock
    
    if (pDCSStore->CountAllocated+pDCSStore->CountFree+1 
        > DYNAMIC_LOCKS_CS_HIGH_THRESHOLD) 
    {
        DeleteCriticalSection(&pDCSLock->CS);
        DVMRP_FREE(pDCSLock);
    }

    // else put it into the list of free locks
    
    else {
        InsertHeadList(&pDCSStore->ListOfFreeLocks, &pDCSLock->Link);
        pDCSStore->CountFree++;
    }

    return;
}


    

//----------------------------------------------------------------------------
//          _AcquireDynamicRWLock
//
// Acquires the MainLock associated with the table, Acquires a new dynamic
// lock if required, increments the count, releases the MainLock and 
// locks the LockedList.
//----------------------------------------------------------------------------
DWORD
AcquireDynamicRWLock (
    PDYNAMIC_RW_LOCK        *ppDRWLock,
    LOCK_TYPE               LockMode,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    )
{
    //Trace0(ENTER1, "Entering _AcquireDynamicRWLock()");


    // acquire the main lock for the Dynamic RW store
    
    ENTER_CRITICAL_SECTION(&pDRWStore->CS, "pDRWStore->CS", 
            "AcquireDynamicRWLock");


    //
    // If it is not already locked then allocate a lock
    //
    if (*ppDRWLock==NULL) {

        *ppDRWLock = GetDynamicRWLock(pDRWStore);

    //Trace1(DYNLOCK, "Acquired dynamicRWLock(%d)", (*ppDRWLock)->Id);


        // if could not get a lock, then igmp is in serious trouble
        
        if (*ppDRWLock==NULL) {
        
            LEAVE_CRITICAL_SECTION(&pDRWStore->CS, "pDRWStore->CS", 
                    "AcquireDynamicRWLock");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    else
        ;//Trace1(DYNLOCK, "Acquired existing dynamicRWLock(%d)", (*ppDRWLock)->Id);

    
    // increment Count in the Dynamic Lock

    (*ppDRWLock)->Count++;



    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDRWStore->CS, "pDRWStore->CS", 
                        "_AcquireDynamicRWLock");


    //
    // acquire dynamic lock
    //
    if (LockMode==LOCK_MODE_READ) {
        ACQUIRE_READ_LOCK(&(*ppDRWLock)->RWL, "pDynamicLock(Read)", 
            "_AcquireDynamicRWLock");
    }
    else {
        ACQUIRE_WRITE_LOCK(&(*ppDRWLock)->RWL, "pDynamicLock(Write)", 
            "_AcquireDynamicRWLock");
    }
    
    return NO_ERROR;
    
} //end _AcquireDynamicRWLock


//----------------------------------------------------------------------------
//          _GetDynamicRWLock
//
// If a free lock is available, returns it. Else allocates a new CS lock
// Lock: assumes the DRWStore MainLock
//----------------------------------------------------------------------------
PDYNAMIC_RW_LOCK
GetDynamicRWLock (
    PDYNAMIC_LOCKS_STORE   pDRWStore
    )
{
    PDYNAMIC_RW_LOCK    pDRWLock;
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         pLe;
    

    //
    // free dynamic lock available. Return it
    //
    if (!IsListEmpty(&pDRWStore->ListOfFreeLocks)) {

        pDRWStore->CountFree--;

        pLe = RemoveTailList(&pDRWStore->ListOfFreeLocks);

        pDRWLock = CONTAINING_RECORD(pLe, DYNAMIC_RW_LOCK, Link);

        /*Trace1(LEAVE1, "Leaving GetDynamicRWLock(%d):reusing lock", 
                pDRWLock->Id);
        Trace2(DYNLOCK, "-------------%d %d", pDRWLock->Id, DynamicRWLockId);
        */
        return pDRWLock;
    }


    // allocate memory for a new dynamic lock
    
    pDRWLock = DVMRP_ALLOC(sizeof(DYNAMIC_RW_LOCK));

    PROCESS_ALLOC_FAILURE2(pDRWLock, "dynamic RW lock",
        Error, sizeof(DYNAMIC_RW_LOCK), return NULL);


    pDRWStore->CountAllocated++;


    //
    // initialize the fields
    //
    
    try {
        CREATE_READ_WRITE_LOCK(&pDRWLock->RWL);
    }
    HANDLE_CRITICAL_SECTION_EXCEPTION(Error, return NULL);

    // no need to initialize the link field
    //InitializeListEntry(&pDRWLock->List);
    
    pDRWLock->Count = 0;
    #ifdef LOCK_DBG
        pDRWLock->Id = ++DynamicRWLockId;
    #endif


    //Trace1(LEAVE1, "Leaving GetDynamicRWLock(%d):new lock", DynamicRWLockId);
    //Trace2(DYNLOCK, "--------------------%d %d", pDRWLock->Id, DynamicRWLockId);

    return pDRWLock;
    
} //end _GetDynamicRWLock




//------------------------------------------------------------------------------
//          _ReleaseDynamicRWLock
//
// Acquires the MainLock associated with the table, decrements the count, 
// releases the DynamicLock if count becomes 0 and releases the MainLock.
//------------------------------------------------------------------------------

VOID
ReleaseDynamicRWLock (
    PDYNAMIC_RW_LOCK        *ppDRWLock,
    LOCK_TYPE               LockMode,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    )
{
    PDYNAMIC_RW_LOCK    pDRWLock = *ppDRWLock;
    
    
    // acquire the main lock for the Dynamic RW store
    
    ENTER_CRITICAL_SECTION(&pDRWStore->CS, "pDRWStore->CS", 
                            "_ReleaseDynamicRWLock");

    IgmpAssert(pDRWLock!=NULL);
    #if DBG
    if (pDRWLock==NULL)
        DbgBreakPoint();
    #endif

    
    // leave the dynamic RW lock
    if (LockMode==LOCK_MODE_READ) {
        RELEASE_READ_LOCK(&pDRWLock->RWL, "pDynamicLock(read)", 
                            "_ReleaseDynamicRWLock");
    }
    else {
        RELEASE_WRITE_LOCK(&pDRWLock->RWL, "pDynamicLock(write)", 
                            "_ReleaseDynamicRWLock");
    }                        
          
    // Decrement Count in the Dynamic Lock. Free the dynamic lock if count==0
  
    if (--pDRWLock->Count==0) {

        FreeDynamicRWLock(pDRWLock, pDRWStore);

        // make the pDRWLock NULL so that it is known that it is not locked
        *ppDRWLock = NULL;
        
    }


    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDRWStore->CS, "pDCSStore->CS", 
            "_ReleaseDynamicRWLock");

    return;
    
} //end _ReleaseDynamicRWLock


//------------------------------------------------------------------------------
//          _FreeDynamicRWLock
//------------------------------------------------------------------------------

VOID
FreeDynamicRWLock (
    PDYNAMIC_RW_LOCK        pDRWLock,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    )
{
    // decrement count of allocated locks
    
    pDRWStore->CountAllocated--;


    // if there are too many dynamic RW locks, then free this lock
    
    if (pDRWStore->CountAllocated+pDRWStore->CountFree+1 
            > DYNAMIC_LOCKS_CS_HIGH_THRESHOLD) 
    {
        DELETE_READ_WRITE_LOCK(&pDRWLock->RWL);
        DVMRP_FREE(pDRWLock);
    }

    // else put it into the list of free locks
    
    else {
        InsertHeadList(&pDRWStore->ListOfFreeLocks, &pDRWLock->Link);
        pDRWStore->CountFree++;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\trace.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File Name: trace.h
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================

#ifndef _DVMRPTRACE_H_
#define _DVMRPTRACE_H_

#ifdef MIB_DEBUG
    #if !DBG 
    #undef MIB_DEBUG
    #endif
#endif


// constants and macros used for tracing 
//

#define DVMRP_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)

#define DVMRP_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)

#define DVMRP_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define DVMRP_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define DVMRP_TRACE_START           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define DVMRP_TRACE_STOP            ((DWORD)0x00020000 | TRACE_USE_MASK)

#define DVMRP_TRACE_IF              ((DWORD)0x00040000 | TRACE_USE_MASK)
#define DVMRP_TRACE_CONFIG          ((DWORD)0x00040000 | TRACE_USE_MASK)
#define DVMRP_TRACE_RECEIVE         ((DWORD)0x00100000 | TRACE_USE_MASK)
#define DVMRP_TRACE_SEND            ((DWORD)0x00200000 | TRACE_USE_MASK)
#define DVMRP_TRACE_QUERIER         ((DWORD)0x00400000 | TRACE_USE_MASK)
#define DVMRP_TRACE_GROUP           ((DWORD)0x00400000 | TRACE_USE_MASK) 
#define DVMRP_TRACE_MGM             ((DWORD)0x00800000 | TRACE_USE_MASK)

#if DBG

#define DVMRP_TRACE_KSL             ((DWORD)0x01000000 | TRACE_USE_MASK)

#define DVMRP_TRACE_WORKER          ((DWORD)0x01000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_ENTER1          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_LEAVE1          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_MIB             ((DWORD)0x04000000 | TRACE_USE_MASK) 

#define DVMRP_TRACE_DYNLOCK         ((DWORD)0x08000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_TIMER           ((DWORD)0x10000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_CS              ((DWORD)0x20000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_TIMER1          ((DWORD)0x40000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_CS1             ((DWORD)0x80000000 | TRACE_USE_MASK)

#else

#define DVMRP_TRACE_KSL             ((DWORD)0x00000000 | TRACE_USE_MASK)

#define DVMRP_TRACE_WORKER          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_ENTER1          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_LEAVE1          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_MIB             ((DWORD)0x00000000 | TRACE_USE_MASK) 

#define DVMRP_TRACE_DYNLOCK         ((DWORD)0x00000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_TIMER           ((DWORD)0x00000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_CS              ((DWORD)0x00000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_TIMER1          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define DVMRP_TRACE_CS1             ((DWORD)0x00000000 | TRACE_USE_MASK)

#endif




#ifdef LOCK_DBG

#define ENTER_CRITICAL_SECTION(pcs, type, proc)             \
            Trace2(CS,"----To enter %s in %s", type, proc);    \
            EnterCriticalSection(pcs);                         \
            Trace2(CS1,"----Entered %s in %s", type, proc)
            
#define LEAVE_CRITICAL_SECTION(pcs, type, proc)         \
            Trace2(CS1,"----Left %s in %s", type, proc);    \
            LeaveCriticalSection(pcs)

#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
        Trace2(EVENT, "++++To wait for singleObj %s in %s", type, proc);    \
        WaitForSingleObject(event, time);    \
        Trace2(EVENT, "++++WaitForSingleObj returned %s in %s", type, proc)

#define SET_EVENT(event, type, proc) \
        Trace2(EVENT, "++++SetEvent %s in %s", type, proc);    \
        SetEvent(event)
        
#else 
#define ENTER_CRITICAL_SECTION(pcs, type, proc) \
            EnterCriticalSection(pcs)
            
#define LEAVE_CRITICAL_SECTION(pcs, type, proc)    \
            LeaveCriticalSection(pcs)
            
#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
        WaitForSingleObject(event, time)
        
#define SET_EVENT(event, type, proc) \
        SetEvent(event)
            
#endif // LOCK_DBG


#define TRACEID         Globals.TraceId


#define Trace0(l,a)             \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g)   \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a, b, c, d, e, f,g)
#define Trace7(l,a,b,c,d,e,f,g,h)   \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a, b, c, d, e, f,g,h)
#define Trace8(l,a,b,c,d,e,f,g,h,i)   \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a, b, c, d, e, f,g,h,i)
#define Trace9(l,a,b,c,d,e,f,g,h,i,j)   \
            if (TRACEID) TracePrintfEx(TRACEID, DVMRP_TRACE_ ## l, a, b, c, d, e, f,g,h,i,j)


#define TRACEDUMP(l,a,b,c)      \
            TraceDumpEx(TRACEID,l,a,b,c,TRUE)
            



#ifdef ENTER_DBG

#define TraceEnter(X)  TracePrintfEx(TRACEID, DVMRP_TRACE_ENTER, "Entered: "X)
#define TraceLeave(X)  TracePrintfEx(TRACEID, DVMRP_TRACE_ENTER, "Leaving: "X"\n")
#else   

#define TraceEnter(X)
#define TraceLeave(X)

#endif // ENTER_DBG

//
// Event logging macros
//

#define LOGLEVEL        GlobalConfig.LoggingLevel
#define LOGHANDLE       Globals.LogHandle
#define LOGERR          RouterLogError
#define LOGERRDATA      RouterLogErrorData
#define LOGWARN         RouterLogWarning
#define LOGWARNDATA     RouterLogWarningData
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData


// Error logging

#define Logerr0(msg,err) {\
        if (LOGLEVEL >= DVMRP_LOGGING_ERROR) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err), DVMRPLOG_ ## msg, ""); \
        }

#define Logerr1(msg,Format, a,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_ERROR) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err), DVMRPLOG_ ## msg, Format, (a))

#define Logerr2(msg,Format, a, b, err) \
        if (LOGLEVEL >= DVMRP_LOGGING_ERROR) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err), DVMRPLOG_ ## msg, Format,(a),(b))

#define Logerr3(msg,Format, a, b, c, err) \
        if (LOGLEVEL >= DVMRP_LOGGING_ERROR) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err), DVMRPLOG_ ## msg, Format,(a),(b), (c))

#define Logerr4(msg,Format, a, b, c, d, err) \
        if (LOGLEVEL >= DVMRP_LOGGING_ERROR) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err), DVMRPLOG_ ## msg, Format,(a),(b), (c), (d))


// Warning logging

#define Logwarn0(msg,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,DVMRPLOG_ ## msg,0,NULL,(err))
#define Logwarn1(msg,a,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,DVMRPLOG_ ## msg,1,&(a),(err))
#define Logwarn2(msg,a,b,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,DVMRPLOG_ ## msg,2,_asz,(err)); \
        }
#define Logwarn3(msg,a,b,c,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,DVMRPLOG_ ## msg,3,_asz,(err)); \
        }
#define Logwarn4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,DVMRPLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= DVMRP_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,DVMRPLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


// Information logging

#define Loginfo0(msg,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,DVMRPLOG_ ## msg,0,NULL,(err))
#define Loginfo1(msg,a,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,DVMRPLOG_ ## msg,1,&(a),(err))
#define Loginfo2(msg,a,b,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,DVMRPLOG_ ## msg,2,_asz,(err)); \
        }
#define Loginfo3(msg,a,b,c,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,DVMRPLOG_ ## msg,3,_asz,(err)); \
        }
#define Loginfo4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= DVMRP_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,DVMRPLOG_ ## msg,4,_asz,(err)); \
        }

//-----------------------------------------------------------------------------
// INITIALIZE_TRACING_LOGGING
//-----------------------------------------------------------------------------

//
// also set the default logging level. It will be reset during
// StartProtocol(), when logging level is set as part of global config
//

#define INITIALIZE_TRACING_LOGGING() {\
    if (!Globals.TraceId) {                             \
        Globals.TraceId = TraceRegister("Dvmrp");       \
    }                                                   \
                                                        \
    if (!Globals.LogHandle) {                           \
        Globals.LogHandle = RouterLogRegister("Dvmrp"); \
        GlobalConfig.LoggingLevel = DVMRP_LOGGING_WARN; \
    }                                                   \
    }        

//-----------------------------------------------------------------------------
// DEINITIALIZE_TRACING_LOGGING
//-----------------------------------------------------------------------------

#define DEINITIALIZE_TRACING_LOGGING() {                \
    if (!Globals.TraceId) {                             \
        TraceDeregister(Globals.TraceId);               \
        Globals.TraceId = 0;                            \
    }                                                   \
                                                        \
    if (!Globals.LogHandle) {                           \
        RouterLogDeregister(Globals.LogHandle);         \
        Globals.LogHandle = NULL;                       \
    }                                                   \
    }



//
// IP address conversion macro:
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//

#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )


#endif // _DVMRPTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\work.c ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File Name: work.c
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================


#include "pchdvmrp.h"
#pragma hdrstop


DWORD
DvmrpRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           *dwInIfIndex,
    DWORD           *dwInIfNextHopAddr,
    DWORD           *dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    );

DWORD
ProxyCreationAlertCallback(
    IN              DWORD           dwSourceAddr,
    IN              DWORD           dwSourceMask,
    IN              DWORD           dwGroupAddr,
    IN              DWORD           dwGroupMask,
    IN              DWORD           dwInIfIndex,
    IN              DWORD           dwInIfNextHopAddr,
    IN              DWORD           dwIfCount,
    IN  OUT         PMGM_IF_ENTRY   pmieOutIfList
    )
{
    return ERROR_CAN_NOT_COMPLETE;
}

DWORD
ProxyDeletionAlertCallback(
    IN              DWORD           dwSourceAddr,
    IN              DWORD           dwSourceMask,
    IN              DWORD           dwGroupAddr,
    IN              DWORD           dwGroupMask,
    IN              DWORD           dwIfIndex,
    IN              DWORD           dwIfNextHopAddr,
    IN              BOOL            bMemberDelete,           
    IN  OUT         PDWORD          pdwTimeout
)
{
    return ERROR_CAN_NOT_COMPLETE;
}


DWORD
ProxyNewMemberCallback(
    IN              DWORD           dwSourceAddr,
    IN              DWORD           dwSourceMask,
    IN              DWORD           dwGroupAddr,
    IN              DWORD           dwGroupMask
)
{
    return ERROR_CAN_NOT_COMPLETE;
}


//-----------------------------------------------------------------------------
//          _GetCurrentDvmrpTimer
// uses GetTickCount(). converts it into 64 bit absolute timer.
//-----------------------------------------------------------------------------

LONGLONG
GetCurrentDvmrpTime(
    )
{
    ULONG   ulCurTimeLow = GetTickCount();


    //
    // see if timer has wrapped
    //
    // since multi-threaded, it might get preempted and CurrentTime
    // might get lower than the global variable g_TimerStruct.CurrentTime.LowPart
    // which might be set by another thread. So we also explicitly verify the
    // switch from a very large DWORD to a small one.
    // (code thanks to murlik&jamesg)
    //

    if ( (ulCurTimeLow < Globals.CurrentTime.LowPart)
        && ((LONG)Globals.CurrentTime.LowPart < 0)
        && ((LONG)ulCurTimeLow > 0) )
    {

        // use global CS instead of creating a new CS

        ACQUIRE_WORKITEM_LOCK("_GetCurrentDvmrpTime");


        // make sure that the global timer has not been updated meanwhile

        if ( (LONG)Globals.CurrentTime.LowPart < 0)
        {
            Globals.CurrentTime.HighPart++;
            Globals.CurrentTime.LowPart = ulCurTimeLow;
        }

        RELEASE_WORKITEM_LOCK("_GetCurrentDvmrpTime");
    }

    
    Globals.CurrentTime.LowPart = ulCurTimeLow;


    return Globals.CurrentTime.QuadPart;
}


//-----------------------------------------------------------------------------
//              RegisterDvmrpWithMgm
//-----------------------------------------------------------------------------
DWORD
RegisterDvmrpWithMgm(
    )
{
    DWORD Error = NO_ERROR;
    ROUTING_PROTOCOL_CONFIG     rpiInfo;
    HANDLE g_MgmProxyHandle;
    
    rpiInfo.dwCallbackFlags = 0;
    rpiInfo.pfnRpfCallback
                = (PMGM_RPF_CALLBACK)DvmrpRpfCallback;
    rpiInfo.pfnCreationAlertCallback
                = (PMGM_CREATION_ALERT_CALLBACK)ProxyCreationAlertCallback;
    rpiInfo.pfnDeletionAlertCallback
                = (PMGM_DELETION_ALERT_CALLBACK)ProxyDeletionAlertCallback;
    rpiInfo.pfnNewMemberCallback
                = (PMGM_NEW_MEMBER_CALLBACK)ProxyNewMemberCallback;
    rpiInfo.pfnWrongIfCallback
                = NULL;
    rpiInfo.pfnIgmpJoinCallback
                = NULL;
    rpiInfo.pfnIgmpLeaveCallback
                = NULL;


    Error = MgmRegisterMProtocol(
        &rpiInfo, PROTO_IP_IGMP, // must be PROTO_IP_IGMP_PROXY
        IGMP_PROXY,
        &g_MgmProxyHandle);

    if (Error!=NO_ERROR) {
        Trace1(ERR, "Error:%d registering Igmp Proxy with Mgm", Error);
        Logerr0(MGM_PROXY_REGISTER_FAILED, Error);
        return Error;
    }

    return Error;
}



//-----------------------------------------------------------------------------
//          ProxyRpfCallback
//-----------------------------------------------------------------------------
DWORD
DvmrpRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           *dwInIfIndex,
    DWORD           *dwInIfNextHopAddr,
    DWORD           *dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    )
{
    DWORD   Error = NO_ERROR;

#if 0
    PRTM_DEST_INFO
    RtmGetMostSpecificDest(RtmHandle, dwSourceAddr, IP_PROTO_IGMP,
        RTM_VIEW_ID_MCAST
        );
#endif

    return ERROR_CAN_NOT_COMPLETE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\defs.h ===
/*++ 

Copyright (c) Microsoft Corporation

Module Name:

    .h

Abstract:


Author:



Revision History:

--*/

#ifndef __DEFS__
#define __DEFS__

#define is ==
#define isnot !=
#define and &&
#define or ||

typedef unsigned long DWORD; 
typedef DWORD  *PDWORD;

typedef unsigned short WORD;
typedef WORD  *PWORD;

typedef unsigned char  BYTE;
typedef BYTE *PBYTE;

typedef int  BOOL;
typedef BOOL *PBOOL;

#define IN_FILTER_SET   0
#define OUT_FILTER_SET  1

#define UNKNOWN_IP_INDEX  MAXULONG

typedef struct _MRSW_LOCK 
{
    NDIS_RW_LOCK    NdisLock;
}MRSW_LOCK, *PMRSW_LOCK;


//
// NOTE. The following structure is superimposed on top of IPAddressEntry.
// See the code in GetIpStackIndex. If you add anything to this make
// sure that it can still overly an IPAddressEntry. If it can't then
// you've some real work on your hands.
//

typedef struct _AddressArray
{
    ULONG           ulAddress;
    ULONG           ulIndex;
    ULONG           ulSubnetBcastAddress;
    struct _AddressArray * pNext;
    struct _AddressArray * pNextSubnet;
} ADDRESSARRAY, *PADDRESSARRAY;

#define InitializeMRSWLock(pLock) {                       \
    NdisInitializeReadWriteLock(&((pLock)->NdisLock));    \
}

#define AcquireReadLock(pLock,pLockState) {                             \
    NdisAcquireReadWriteLock(&((pLock)->NdisLock),FALSE,(pLockState));  \
}

#define ReleaseReadLock(pLock,pLockState) {                       \
    NdisReleaseReadWriteLock(&((pLock)->NdisLock),(pLockState));  \
}

#define AcquireWriteLock(pLock,pLockState) {                           \
    NdisAcquireReadWriteLock(&((pLock)->NdisLock),TRUE,(pLockState));  \
}

#define ReleaseWriteLock(pLock,pLockState) {                      \
    NdisReleaseReadWriteLock(&((pLock)->NdisLock),(pLockState));  \
}


#define UnLockLogDpc(pLog)  KeReleaseSpinLockFromDpcLevel(&pLog->LogLock)
#define UnLockLog(pLog, kIrql)  KeReleaseSpinLock(&pLog->LogLock, kIrql)

#define SRC_ADDR   uliSrcDstAddr.LowPart
#define DEST_ADDR  uliSrcDstAddr.HighPart
#define SRC_MASK   uliSrcDstMask.LowPart
#define DEST_MASK  uliSrcDstMask.HighPart
#define PROTO      uliProtoSrcDstPort.LowPart

//
// Flags passed to SetFilters
//

// none defined


#define FREE_LIST_SIZE 16



//
// Nominal size of the address hash table. 
//
#define ADDRHASHLOW 31
#define ADDRHASHLOWLEVEL 16
#define ADDRHASHMED 257
#define ADDRHASHMEDLEVEL 130
#define ADDRHASHHIGH 511

#define ADDRHASHX(x)  (x % AddrModulus)

#define SIZEOF_FILTERS1(X) (((((X)->dwNumInFilters + (X)->dwNumOutFilters) is 0)?0:((X)->dwNumInFilters + (X)->dwNumOutFilters - 1) * sizeof(FILTER_STATS)))

#define SIZEOF_FILTERS(X) (sizeof(FILTER_DRIVER_GET_FILTERS) + SIZEOF_FILTERS1(X))


#ifdef DRIVER_DEBUG
#define TRACE0(X)        DbgPrint(X)
#define TRACE1(X,Y)      DbgPrint(X,(Y))
#define TRACE2(X,Y,Z)    DbgPrint(X,(Y),(Z))
#define TRACE3(W,X,Y,Z)         DbgPrint(W,(X),(Y),(Z))
#define TRACE4(V,W,X,Y,Z)       DbgPrint(V,(W),(X),(Y),(Z))
#define TRACE5(U,V,W,X,Y,Z)     DbgPrint(U,(V),(W),(X),(Y),(Z))
#else
#define TRACE0(X)        
#define TRACE1(X,Y)      
#define TRACE2(X,Y,Z)    
#define TRACE3(W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)
#endif


//
// protocol definitions
//

#define ICMP_DEST_UNREACH 3
#define ICMP_REDIRECT     5

#define ANYWILDFILTER(x) (x->dwFlags &  \
                         (FILTER_FLAGS_SRCWILD | FILTER_FLAGS_DSTWILD))

#define MCASTSTART  224
#define MCASTEND    239
#define BCASTADDR   0xffffffff

//
// Fragments cache related constants.
//

#define INACTIVITY_PERIOD           (2 * 60)
#define TIMER_IN_MILLISECS          (2 * 60 * 1000)
#define SYS_UNITS_IN_ONE_MILLISEC   (1000 * 10)
#define MAX_FRAG_ALLOCS             2000

#define MILLISECS_TO_TICKS(ms)          \
    ((ULONGLONG)(ms) * SYS_UNITS_IN_ONE_MILLISEC / KeQueryTimeIncrement())

#define SECS_TO_TICKS(s)               \
    ((ULONGLONG)MILLISECS_TO_TICKS((s) * 1000))


//
// Kernel-debugger output definitions
//

#undef ERROR

 

#if DBG
#define TRACE(Class,Args) \
    if ((TRACE_CLASS_ ## Class) & (TraceClassesEnabled)) { DbgPrint Args; }
#define ERROR(Args)             DbgPrint Args
#define CALLTRACE(Args)         TRACE(CALLS, Args)
#else
#define TRACE(Class,Args)
#define ERROR(Args)
#define CALLTRACE(Args)
#endif


#define TRACE_CLASS_CALLS       0x00000001
#define TRACE_CLASS_CONFIG      0x00000002
#define TRACE_CLASS_ACTION      0x00000004
#define TRACE_CLASS_CACHE       0x00000008
#define TRACE_CLASS_FRAG        0x00000010
#define TRACE_CLASS_LOGGER      0x00000020
#define TRACE_CLASS_LOOKUP      0x00000040
#define TRACE_CLASS_TIMER       0x00000080
#define TRACE_CLASS_FLDES       0x00000100

#define TRACE_CLASS_SPECIAL     (TRACE_CLASS_CONFIG)

#define TRACE_FILTER_DESCRIPTION(p) \
        if ((((PBYTE) &((p)->uliProtoSrcDstPort))[0]  == 0x6) || (((PBYTE) &((p)->uliProtoSrcDstPort))[0] == 0x11)) {                                       \
    		TRACE(FLDES,(" TCP/UDP Filter <%d:%d>  %d.%d.%d.%d:%d * %d.%d.%d.%d:%d -> %d.%d.%d.%d:%d * %d.%d.%d.%d:%d\n",                                   \
            		((PBYTE) &((p)->uliProtoSrcDstPort))[0],                                                                                                \
            		((PBYTE) &((p)->uliProtoSrcDstMask))[0],                                                                                                \
                    ((PBYTE) &((p)->uliSrcDstAddr))[0],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[1],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[2],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[3],                                                                                                     \
                    ((ULONG)(((PBYTE) &((p)->uliProtoSrcDstPort))[4]) << 8) + ((PBYTE) &((p)->uliProtoSrcDstPort))[5],                                      \
                    ((PBYTE) &(p->uliSrcDstMask))[0],                                                                                                       \
                    ((PBYTE) &(p->uliSrcDstMask))[1],                                                                                                       \
                    ((PBYTE) &(p->uliSrcDstMask))[2],                                                                                                       \
                    ((PBYTE) &(p->uliSrcDstMask))[3],                                                                                                       \
                    ((ULONG)(((PBYTE) &((p)->uliProtoSrcDstMask))[4]) << 8) + ((PBYTE) &((p)->uliProtoSrcDstMask))[5],                                      \
                    ((PBYTE) &((p)->uliSrcDstAddr))[4],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[5],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[6],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[7],                                                                                                     \
                    ((ULONG)(((PBYTE) &((p)->uliProtoSrcDstPort))[6]) << 8) + ((PBYTE) &((p)->uliProtoSrcDstPort))[7],                                      \
                    ((PBYTE) &((p)->uliSrcDstMask))[4],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[5],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[6],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[7],                                                                                                     \
                    ((ULONG)(((PBYTE) &((p)->uliProtoSrcDstMask))[6]) << 8) + ((PBYTE) &((p)->uliProtoSrcDstMask))[7]                                       \
                    ));                                                                                                                                     \
        } else if (((PBYTE) &((p)->uliProtoSrcDstPort))[0]  == 0x1) {                                                                                       \
            TRACE(FLDES,(" ICMP filter <%d:%d>  %d.%d.%d.%d * %d.%d.%d.%d -> %d.%d.%d.%d * %d.%d.%d.%d, Type/Code: %d/%d * %d/%d\n",                        \
            		((PBYTE) &((p)->uliProtoSrcDstPort))[0],                                                                                                \
            		((PBYTE) &((p)->uliProtoSrcDstMask))[0],                                		                                                        \
                    ((PBYTE) &((p)->uliSrcDstAddr))[0],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[1],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[2],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[3],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[0],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[1],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[2],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[3],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[4],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[5],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[6],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[7],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[4],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[5],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[6],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[7],                                                                                                     \
                    ((PBYTE) &((p)->uliProtoSrcDstPort))[4],                                                                                                \
                    ((PBYTE) &((p)->uliProtoSrcDstPort))[5],                                                                                                \
                    ((PBYTE) &((p)->uliProtoSrcDstMask))[4],                                                                                                \
                    ((PBYTE) &((p)->uliProtoSrcDstMask))[5]                                                                                                 \
                    ));                                                                                                                                     \
        } else {                                                                                                                                            \
            TRACE(FLDES,(" filter <%d:%d>  %d.%d.%d.%d * %d.%d.%d.%d -> %d.%d.%d.%d * %d.%d.%d.%d\n",                                                       \
            		((PBYTE) &((p)->uliProtoSrcDstPort))[0],                                                                                                \
            		((PBYTE) &((p)->uliProtoSrcDstMask))[0],                                                                                                \
                    ((PBYTE) &((p)->uliSrcDstAddr))[0],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[1],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[2],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[3],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[0],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[1],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[2],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[3],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[4],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[5],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[6],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstAddr))[7],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[4],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[5],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[6],                                                                                                     \
                    ((PBYTE) &((p)->uliSrcDstMask))[7]                                                                                                      \
                    ));                                                                                                                                     \
        }                                                                                                                                                       
                                                                                                                                                            

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\driver.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\fltrdrvr\driver.c

Abstract:


Revision History:



--*/

#include "globals.h"
#include <ipinfo.h>
#include <ntddtcp.h>
#include <tdiinfo.h>

#define DEFAULT_DIRECTORY       L"DosDevices"
#define DEFAULT_FLTRDRVR_NAME   L"IPFILTERDRIVER"

typedef enum
{
    NULL_INTERFACE = 0,
    OLD_INTERFACE,
    NEW_INTERFACE
} INTTYPE, *PINTTTYPE;

FILTER_DRIVER   g_filters;
DWORD           g_dwCacheSize;
DWORD           g_dwHashLists;
BOOL            g_bDriverRunning;
KSPIN_LOCK      g_lOutFilterLock;
KSPIN_LOCK      g_lInFilterLock;
KSPIN_LOCK      g_FcbSpin;
MRSW_LOCK       g_IpTableLock;
LIST_ENTRY      g_freeOutFilters;
LIST_ENTRY      g_freeInFilters;
LIST_ENTRY      g_leFcbs;
DWORD           g_dwMakingNewTable;
DWORD           g_dwNumHitsDefaultIn;
DWORD           g_dwNumHitsDefaultOut;
DWORD           g_FragThresholdSize = MINIMUM_FRAGMENT_OFFSET;
ULONG           AddrModulus;
IPAddrEntry     *AddrTable;
PADDRESSARRAY * AddrHashTable;
PADDRESSARRAY * AddrSubnetHashTable;
NPAGED_LOOKASIDE_LIST filter_slist;
PAGED_LOOKASIDE_LIST  paged_slist;
ERESOURCE       FilterAddressLock;
EXTENSION_DRIVER   g_Extension;
ULONG            g_ulBoundInterfaceCount;

//
// Fragment cache related variables & globals.
//

KTIMER   g_ktTimer;
KDPC     g_kdTimerDpc;

NPAGED_LOOKASIDE_LIST   g_llFragCacheBlocks;
LONGLONG                g_llInactivityTime;
KSPIN_LOCK              g_kslFragLock;
DWORD                   g_dwFragTableSize;
PLIST_ENTRY             g_pleFragTable;
DWORD                   g_dwNumFragsAllocs;

//
// Variables to control the debug output.
//

ULONG                   TraceClassesEnabled = 0;
WCHAR                   TraceClassesEnabledName[] = L"TraceClassesEnabled";
WCHAR                   ParametersName[] = L"Parameters";



#ifdef DRIVER_PERF
DWORD          g_dwNumPackets,g_dwFragments,g_dwCache1,g_dwCache2;
DWORD          g_dwWalk1,g_dwWalk2,g_dwForw,g_dwWalkCache;
KSPIN_LOCK     g_slPerfLock;
LARGE_INTEGER  g_liTotalTime;
#endif

VOID ClearFragCache();

VOID
FragCacheTimerRoutine(
    PKDPC   Dpc,
    PVOID   DeferredContext,
    PVOID   SystemArgument1,
    PVOID   SystemArgument2
    );

NTSTATUS
OpenRegKey(
    PHANDLE             phRegHandle,
    PUNICODE_STRING     pusKeyName
    );

NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    );

//
// Forward references.
//
NTSTATUS
OpenNewHandle(PFILE_OBJECT FileObject);

NTSTATUS
CloseFcb(PPFFCB Fcb, PFILE_OBJECT FileObject);

PPAGED_FILTER_INTERFACE
FindInterfaceOnHandle(PFILE_OBJECT FileObject,
                      PVOID    pvValue);

DWORD
LocalIpLook(DWORD Addr);

BOOLEAN
PfFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

NTSTATUS
LockFcb(
    IN struct _FILE_OBJECT *FileObject);

VOID
PFReadRegistryParameters(PUNICODE_STRING RegistryPath);

NTSTATUS
InitFragCacheParameters(
            IN PUNICODE_STRING RegistryPath
            );

VOID
UnLockFcb(
    IN struct _FILE_OBJECT *FileObject);

NTSTATUS
GetSynCountTotal(PFILTER_DRIVER_GET_SYN_COUNT OutputBuffer);

NTSTATUS
DeleteByHandle(
           IN PPFFCB                      Fcb,
           IN PPAGED_FILTER_INTERFACE     pPage,
           IN PVOID *                     ppHandles,
           IN DWORD                       dwLength);


FAST_IO_DISPATCH PfFastIoDispatch =
{
    11,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    PfFastIoDeviceControl
};

#pragma alloc_text(PAGED, DoIpIoctl)
//#pragma alloc_text(PAGED, OpenNewHandle)
#pragma alloc_text(PAGED, FindInterfaceOnHandle)
#pragma alloc_text(PAGED, PfFastIoDeviceControl)
#pragma alloc_text(INIT, DriverEntry, PFReadRegistryParameters)


VOID
FcbLockDown(PPFFCB Fcb)
{
    KIRQL kirql;

    KeAcquireSpinLock(&g_FcbSpin, &kirql);
    if(!(Fcb->dwFlags & PF_FCB_CLOSED))
    {
        InterlockedDecrement(&Fcb->UseCount);
        Fcb->dwFlags |= PF_FCB_CLOSED;
    }
    KeReleaseSpinLock(&g_FcbSpin, kirql);
}

BOOLEAN FASTCALL
ValidateHeader(
    PRTR_INFO_BLOCK_HEADER Header,
    ULONG Size
    )

/*++

Routine Description:

    Copied from NAT driver sources. Author: AboladeG

    This routine is invoked to ensure that the given header is consistent.
    This is the case if
    * the header's size is less than or equal to 'Size'
    * each entry in the header is contained in 'Header->Size'.
    * the data for each entry is contained in 'Header->Size'.

Arguments:

    Header - the header to be validated

    Size - the size of the buffer in which 'Header' appears

Return Value:

    BOOLEAN - TRUE if valid, FALSE otherwise.

--*/

{
    ULONG i;
    ULONG64 Length;

    //
    // Check that the base structure is present
    //

    if (Size < FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry) ||
        Size < Header->Size) {
        return FALSE;
    }

    //
    // Check that the table of contents is present
    //

    Length = (ULONG64)Header->TocEntriesCount * sizeof(RTR_TOC_ENTRY);
    if (Length > MAXLONG) {
        return FALSE;
    }

    Length += FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry);
    if (Length > Header->Size) {
        return FALSE;
    }

    //
    // Check that all the data is present
    //

    for (i = 0; i < Header->TocEntriesCount; i++) {
        Length =
            (ULONG64)Header->TocEntry[i].Count * Header->TocEntry[i].InfoSize;
        if (Length > MAXLONG) {
            return FALSE;
        }
        if ((Length + Header->TocEntry[i].Offset) > Header->Size) {
            return FALSE;
        }
    }

    return TRUE;

} // ValidateHeader

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT  DriverObject,
            IN PUNICODE_STRING RegistryPath
            )
/*++
  Routine Description
       Called when the driver is loaded. It creates the device object and sets up the DOS name.
       Also does the initialization of standard entry points and its own global data

  Arguments
       DriverObject
       RegistryPath

  Return Value
       NTSTATUS

--*/
{
    INT		        i;
    PDEVICE_OBJECT  deviceObject = NULL;
    NTSTATUS        ntStatus;
    WCHAR	        deviceNameBuffer[] = DD_IPFLTRDRVR_DEVICE_NAME;
    UNICODE_STRING  deviceNameUnicodeString;
    UNICODE_STRING  String;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE          ParametersKey;
    HANDLE          ServiceKey;


    TRACE0("Filter Driver: Entering DriverEntry\n") ;

    #if DBG

    //
    // Open the registry key
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntStatus = ZwOpenKey(&ServiceKey, KEY_READ, &ObjectAttributes);
    if (NT_SUCCESS(ntStatus)) {
        RtlInitUnicodeString(&String, ParametersName);
        InitializeObjectAttributes(
            &ObjectAttributes,
            &String,
            OBJ_CASE_INSENSITIVE,
            ServiceKey,
            NULL
            );
        ntStatus = ZwOpenKey(&ParametersKey, KEY_READ, &ObjectAttributes);
        ZwClose(ServiceKey);
        if (NT_SUCCESS(ntStatus)) {
            UCHAR Buffer[32];
            ULONG BytesRead;
            PKEY_VALUE_PARTIAL_INFORMATION Value;
            RtlInitUnicodeString(&String, TraceClassesEnabledName);
            ntStatus =
                ZwQueryValueKey(
                    ParametersKey,
                    &String,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION)Buffer,
                    sizeof(Buffer),
                    &BytesRead
                    );
            if (NT_SUCCESS(ntStatus) &&
                ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Type == REG_DWORD
                ) {
                TraceClassesEnabled =
                    *(PULONG)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data;
            }
            DbgPrint("MSPFLTEX: TraceClassesEnabled=0x%08x\n", TraceClassesEnabled);

            ZwClose(ParametersKey);


        }
    }
#endif


    //
    // Initialize the lock and the list
    //

    InitializeMRSWLock(&g_filters.ifListLock);
    InitializeListHead(&g_filters.leIfListHead);
    InitializeListHead(&g_leFcbs);
    g_filters.ppInCache = NULL;
    g_filters.ppOutCache = NULL;
    g_bDriverRunning = FALSE;
    InitializeMRSWLock(&g_IpTableLock);
    KeInitializeSpinLock(&g_lOutFilterLock);
    KeInitializeSpinLock(&g_lInFilterLock);
    KeInitializeSpinLock(&g_FcbSpin);
    InitializeListHead(&g_freeOutFilters);
    InitializeListHead(&g_freeInFilters);
    g_dwNumHitsDefaultIn = g_dwNumHitsDefaultOut = 0;

#ifdef DRIVER_PERF
    g_dwFragments = g_dwCache1 = g_dwCache2 = g_dwNumPackets = 0;
    g_dwWalk1 = g_dwWalk2 = g_dwForw = g_dwWalkCache = 0;
    g_liTotalTime.HighPart = g_liTotalTime.LowPart = 0;
    KeInitializeSpinLock(&g_slPerfLock);
#endif

    //
    // Initialize interface cache.
    //

    g_ulBoundInterfaceCount = 0;
    g_filters.pInterfaceCache = (PCACHE_ENTRY)
                   ExAllocatePoolWithTag(
                                     NonPagedPool,
                                     (CACHE_SIZE * sizeof(CACHE_ENTRY)),
                                     'hCnI'
                                     );
    if(g_filters.pInterfaceCache == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    InitializeCache(g_filters.pInterfaceCache);

    //
    // Initialize fragment cache.
    //

    InitFragCacheParameters(RegistryPath);

    //
    // Initialize Extension Data
    //

    InitializeMRSWLock(&g_Extension.ExtLock);
    g_Extension.ExtPointer = NULL;
    g_Extension.ExtFileObject = NULL;

    //
    // Create a device object
    //

    RtlInitUnicodeString (&deviceNameUnicodeString, deviceNameBuffer);

    __try
    {
        ntStatus = IoCreateDevice (DriverObject,
                                   0,
                                   &deviceNameUnicodeString,
                                   FILE_DEVICE_NETWORK,
                                   FILE_DEVICE_SECURE_OPEN,
                                   FALSE,               // Exclusive
                                   &deviceObject
                                   );

        if (NT_SUCCESS(ntStatus))
        {
            //
            // Initialize the driver object
            //

            DriverObject->DriverUnload   = FilterDriverUnload;
            DriverObject->FastIoDispatch = &PfFastIoDispatch;
            DriverObject->DriverStartIo  = NULL;

            for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
            {
                DriverObject->MajorFunction[i] = FilterDriverDispatch;
            }
        }
        else
        {
            ERROR((
                "IPFLTDRV: Couldn't get device pointer to Filt Driver 0x%08x\n",
                ntStatus
                ));
            __leave;
        }

        SetupExternalNaming (&deviceNameUnicodeString) ;
    }
    __finally
    {
        if(!NT_SUCCESS(ntStatus))
        {
            ERROR(("IPFLTDRV: Error in DriverEntry routine\n"));

        }
        else
        {
            ExInitializeResourceLite ( &FilterListResourceLock );
            ExInitializeResourceLite ( &FilterAddressLock );
            CALLTRACE(("IPFLTDRV: DriverEntry routine successful\n"));
        }

        if(NT_SUCCESS(ntStatus))
        {
            PFReadRegistryParameters(RegistryPath);
        }
    }
    return ntStatus;
}


NTSTATUS
FilterDriverDispatch(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     )
/*++
  Routine Description
        Dispatch Routine for the filter driver. Gets the current irp stack location, validates
        the parameters and calls the necessary routing (which is ioctl.c)

  Arguments
        DeviceObject
        Irp

  Return Value
        Status as returned by the worker functions

--*/
{
    PIO_STACK_LOCATION	irpStack;
    PVOID		        pvIoBuffer;
    ULONG		        inputBufferLength;
    ULONG		        outputBufferLength;
    ULONG		        ioControlCode;
    NTSTATUS		    ntStatus;
    DWORD               dwSize = 0;

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    pvIoBuffer         = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    CALLTRACE(("IPFLTDRV: FilterDriverDispatch\n"));

    switch (irpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
        {
            TRACE(CONFIG,(
                "IPFLTDRV: IRP_MJ_CREATE, FileObject=%08x\n",
                irpStack->FileObject
                ));

            //
            // Initialize the driver. The first time it gets a create IRP, it starts up the
            // filtering.
            //

            ntStatus = STATUS_SUCCESS;

            if(!g_bDriverRunning)
            {
                KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite( &FilterListResourceLock, TRUE);

                if (g_bDriverRunning || InitFilterDriver())
                {
                    g_bDriverRunning = TRUE;
                }
                else
                {
                    ntStatus = STATUS_UNSUCCESSFUL ;
                }
                ExReleaseResourceLite( &FilterListResourceLock );
                KeLeaveCriticalRegion();
            }
            if(NT_SUCCESS(ntStatus))
            {
                ntStatus = OpenNewHandle(irpStack->FileObject);
            }

            break;
        }

        case IRP_MJ_CLEANUP:

        {
            CALLTRACE(("IPFLTDRV: IRP_MJ_CLEANUP\n"));

            //
            // Closing the file handle to the driver doesnt shut the driver down
            //

            ntStatus = STATUS_SUCCESS;

            break;
        }

        case IRP_MJ_CLOSE:

        {
            //
            // All done with this file object and this FCB. Run
            // down the interfaces getting rid of them
            //

            ntStatus = LockFcb(irpStack->FileObject);
            if(NT_SUCCESS(ntStatus))
            {
                PPFFCB Fcb = irpStack->FileObject->FsContext2;

                FcbLockDown(Fcb);
                UnLockFcb(irpStack->FileObject);
            }
            break;
        }

        case IRP_MJ_DEVICE_CONTROL:
        {
            CALLTRACE(("IPFLTDRV: IRP_MJ_DEVICE_CONTROL\n"));

            ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

            switch (ioControlCode)
            {

#if FWPF
                case IOCTL_CLEAR_INTERFACE_BINDING:
                {
                    PINTERFACEBINDING pBind;
                    PPAGED_FILTER_INTERFACE pPage;

                    CALLTRACE(("IPFLTDRV: IOCTL_CLEAR_INTERFACE_BINDING called\n"));

                    dwSize = sizeof(*pBind);

                    if(inputBufferLength < sizeof(*pBind))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength < sizeof(*pBind))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pBind = (PINTERFACEBINDING)pvIoBuffer;

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }

                    pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                  pBind->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        ntStatus = ClearInterfaceBinding(pPage, pBind);
                    }

                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_SET_INTERFACE_BINDING:
                {
                    PINTERFACEBINDING pBind;
                    PPAGED_FILTER_INTERFACE pPage;

                    CALLTRACE(("IPFLTDRV: IOCTL_SET_INTERFACE_BINDING called\n"));

                    dwSize = sizeof(*pBind);

                    if(inputBufferLength < sizeof(*pBind))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength < sizeof(*pBind))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pBind = (PINTERFACEBINDING)pvIoBuffer;

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                  pBind->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        ntStatus = SetInterfaceBinding(pBind, pPage);
                    }
                    UnLockFcb(irpStack->FileObject);
                    break;
                }

                case IOCTL_SET_INTERFACE_BINDING2:
                {
                    PINTERFACEBINDING2 pBind2;
                    PPAGED_FILTER_INTERFACE pPage;

                    CALLTRACE(("IPFLTDRV: IOCTL_SET_INTERFACE_BINDING2 called\n"));

                    dwSize = sizeof(*pBind2);

                    if(inputBufferLength < sizeof(*pBind2))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength < sizeof(*pBind2))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pBind2 = (PINTERFACEBINDING2)pvIoBuffer;

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                  pBind2->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        ntStatus = SetInterfaceBinding2(pBind2, pPage);
                    }
                    UnLockFcb(irpStack->FileObject);
                    break;
                }

                case IOCTL_PF_GET_INTERFACE_PARAMETERS:
                {
                    PPFGETINTERFACEPARAMETERS pp;
                    PPAGED_FILTER_INTERFACE pPage;

                    CALLTRACE(("IPFLTDRV: GET_INTERFACE_PARAMETERS called\n"));

                    dwSize = sizeof(*pp);


                    if(inputBufferLength < (sizeof(*pp) - sizeof(FILTER_STATS_EX)))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength < (sizeof(*pp) - sizeof(FILTER_STATS_EX)))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pp = (PPFGETINTERFACEPARAMETERS)pvIoBuffer;
                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }

                    if(pp->dwFlags & GET_BY_INDEX)
                    {
                        pPage = 0;
                    }
                    else
                    {
                        pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                      pp->pvDriverContext);
                        if(!pPage)
                        {
                            ntStatus = STATUS_INVALID_PARAMETER;
                            UnLockFcb(irpStack->FileObject);
                            break;
                        }
                    }

                    dwSize = outputBufferLength;
                    ntStatus = GetInterfaceParameters(pPage,
                                                      pp,
                                                      &dwSize);
                    UnLockFcb(irpStack->FileObject);
                    break;
                }

                case IOCTL_PF_CREATE_AND_SET_INTERFACE_PARAMETERS:
                {
                    //
                    // create a new style interface.
                    //


                    PPFINTERFACEPARAMETERS pInfo;

                    CALLTRACE(("IPFLTDRV: IOCTL_CREATE_AND_SET called\n"));

                    dwSize = sizeof(PFINTERFACEPARAMETERS);

                    //
                    // Both input and output Buffer lengths should be the same a nd
                    //

                    if(inputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pInfo = (PPFINTERFACEPARAMETERS)pvIoBuffer;

                    //
                    // now establish the interface
                    //

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    ntStatus = AddNewInterface(pInfo,
                                               irpStack->FileObject->FsContext2);
                    UnLockFcb(irpStack->FileObject);
                    break;
                }

                case IOCTL_PF_CREATE_LOG:

                {
                    PPFPAGEDLOG pPage;
                    PPFLOG ppfLog;

                    CALLTRACE(("IPFLTDRV: IOCTL_PF_CREATE_LOG\n"));

                    //
                    // Check the size
                    //

                    dwSize = sizeof(PFLOG);

                    if((inputBufferLength < dwSize)
                               ||
                       (outputBufferLength < dwSize))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ppfLog = (PPFLOG)pvIoBuffer;

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    ntStatus = PfLogCreateLog(
                                 ppfLog,
                                 irpStack->FileObject->FsContext2,
                                 Irp);
                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_PF_DELETE_LOG:
                {
                    CALLTRACE(("IPFLTDRV: IOCTL_PF_DELETE_LOG\n"));

                    //
                    // Check the size
                    //

                    dwSize = sizeof(PFDELETELOG);

                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    ntStatus = PfDeleteLog(
                                 (PPFDELETELOG)pvIoBuffer,
                                 irpStack->FileObject->FsContext2);
                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_SET_LOG_BUFFER:
                {
                    CALLTRACE(("IPFLTDRV: IOCTL_SET_LOG_BUFFER\n"));

                    //
                    // Check the size
                    //

                    dwSize = sizeof(PFSETBUFFER);

                    if((inputBufferLength < dwSize)
                               ||
                       (outputBufferLength < dwSize))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    ntStatus = PfLogSetBuffer(
                                 (PPFSETBUFFER)pvIoBuffer,
                                 irpStack->FileObject->FsContext2,
                                 Irp);

                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_PF_DELETE_BY_HANDLE:
                {
                    PPAGED_FILTER_INTERFACE pPage;

                    CALLTRACE(("IPFLTDRV: IOCTL_PF_DELETE_BY_HANDLE\n"));

                    if(inputBufferLength < sizeof(PFDELETEBYHANDLE))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(
                            irpStack->FileObject,
                            ((PPFDELETEBYHANDLE)pvIoBuffer)->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        ntStatus = DeleteByHandle(
                                     (PPFFCB)irpStack->FileObject->FsContext2,
                                     pPage,
                                     &((PPFDELETEBYHANDLE)pvIoBuffer)->pvHandles[0],
                                     inputBufferLength - sizeof(PVOID));
                    }

                    UnLockFcb(irpStack->FileObject);
                    break;
                }

                case IOCTL_DELETE_INTERFACE_FILTERS_EX:
                {
                    PPAGED_FILTER_INTERFACE pPage;

                    CALLTRACE(("IPFLTDRV: IOCTL_UNSET_INTERFACE_FILTERSEX\n"));

                    //
                    // The minimum size is without any TOCs
                    //

                    dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);

                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    //
                    // Verify the sizes if individual entries in the buffer.
                    //

                    if (!ValidateHeader(
                                 &((PFILTER_DRIVER_SET_FILTERS)pvIoBuffer)->ribhInfoBlock,
                                 inputBufferLength -
                                     FIELD_OFFSET(FILTER_DRIVER_SET_FILTERS, ribhInfoBlock)
                                 )) {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(
                     irpStack->FileObject,
                     ((PFILTER_DRIVER_SET_FILTERS)pvIoBuffer)->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        ntStatus = UnSetFiltersEx(
                                     (PPFFCB)irpStack->FileObject->FsContext2,
                                     pPage,
                                     inputBufferLength,
                                     (PFILTER_DRIVER_SET_FILTERS)pvIoBuffer);
                    }
                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_SET_INTERFACE_FILTERS_EX:
                {
                    PPAGED_FILTER_INTERFACE pPage;

                    CALLTRACE(("IPFLTDRV: IOCTL_SET_INTERFACE_FILTERSEX\n"));

                    //
                    // The minimum size is without any TOCs
                    //

                    dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);

                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    //
                    // Verify the sizes if individual entries in the buffer.
                    //

                    if (!ValidateHeader(
                                 &((PFILTER_DRIVER_SET_FILTERS)pvIoBuffer)->ribhInfoBlock,
                                 inputBufferLength -
                                     FIELD_OFFSET(FILTER_DRIVER_SET_FILTERS, ribhInfoBlock)
                                 )) {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(
                     irpStack->FileObject,
                     ((PFILTER_DRIVER_SET_FILTERS)pvIoBuffer)->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        ntStatus = SetFiltersEx(
                                     (PPFFCB)irpStack->FileObject->FsContext2,
                                     pPage,
                                     inputBufferLength,
                                     (PFILTER_DRIVER_SET_FILTERS)pvIoBuffer);
                    }
                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_DELETE_INTERFACEEX:
                {
                    PFILTER_DRIVER_DELETE_INTERFACE pDel;
                    PPAGED_FILTER_INTERFACE pPage;

                    CALLTRACE(("IPFLTDRV: IOCTL_DELETE_INTERFACE\n"));

                    pDel = (PFILTER_DRIVER_DELETE_INTERFACE)pvIoBuffer;

                    dwSize = sizeof(FILTER_DRIVER_DELETE_INTERFACE);

                    if(inputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }


                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                  pDel->pvDriverContext);
                    if(pPage)
                    {
                        RemoveEntryList(&pPage->leIfLink);
                        ntStatus = DeletePagedInterface(
                                      (PPFFCB)irpStack->FileObject->FsContext2,
                                      pPage);
                    }
                    else
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }

                    UnLockFcb(irpStack->FileObject);
                    break;
                }

                case IOCTL_SET_LATE_BOUND_FILTERSEX:
                {
                    PFILTER_DRIVER_BINDING_INFO pBindInfo;
                    PPAGED_FILTER_INTERFACE pPage;

                    CALLTRACE(("FilterDriver: IOCTL_SET_LATE_BOUND_FILTERS\n"));

                    pBindInfo = (PFILTER_DRIVER_BINDING_INFO)pvIoBuffer;

                    dwSize = sizeof(FILTER_DRIVER_BINDING_INFO);

                    if(inputBufferLength isnot dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                  pBindInfo->pvDriverContext);

                    if(pPage)
                    {
                        ntStatus = UpdateBindingInformationEx(pBindInfo,
                                                              pPage);
                    }
                    else
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    UnLockFcb(irpStack->FileObject);

                    break;
                }

#endif                // FWPF

#if STEELHEAD
                case IOCTL_CREATE_INTERFACE:
                {
                    //
                    // the old style of creating an interface.
                    // just pass it through to the underlying code
                    //
                    PFILTER_DRIVER_CREATE_INTERFACE pInfo;

                    CALLTRACE(("IPFLTDRV: IOCTL_CREATE_INTERFACE\n"));

                    dwSize = sizeof(FILTER_DRIVER_CREATE_INTERFACE);


                    //
                    // Both input and output Buffer lengths should be the same and
                    //

                    if(inputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pInfo = (PFILTER_DRIVER_CREATE_INTERFACE)pvIoBuffer;

                    ntStatus = AddInterface(
                                            pInfo->pvRtrMgrContext,
                                            pInfo->dwIfIndex,
                                            pInfo->dwAdapterId,
                                            irpStack->FileObject->FsContext2,
                                            &pInfo->pvDriverContext);

                    if(NT_SUCCESS(ntStatus))
                    {
                        dwSize = sizeof(FILTER_DRIVER_CREATE_INTERFACE);
                    }

                    break;
                }

                case IOCTL_SET_INTERFACE_FILTERS:
                {
                    CALLTRACE(("IPFLTDRV: IOCTL_SET_INTERFACE_FILTERS\n"));

                    //
                    // The minimum size is without any TOCs
                    //

                    dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);

                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ntStatus = SetFilters((PFILTER_DRIVER_SET_FILTERS)pvIoBuffer);

                    break;
                }

                case IOCTL_SET_LATE_BOUND_FILTERS:
                {
                    PFILTER_DRIVER_BINDING_INFO pBindInfo;

                    CALLTRACE(("IPFLTDRV: IOCTL_SET_LATE_BOUND_FILTERS\n"));

                    pBindInfo = (PFILTER_DRIVER_BINDING_INFO)pvIoBuffer;

                    dwSize = sizeof(FILTER_DRIVER_BINDING_INFO);

                    if(inputBufferLength isnot dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    ntStatus = UpdateBindingInformation(pBindInfo,
                                                        pBindInfo->pvDriverContext);

                    break;
                }

                case IOCTL_DELETE_INTERFACE:
                {
                    PFILTER_DRIVER_DELETE_INTERFACE pDel;

                    CALLTRACE(("IPFLTDRV: IOCTL_DELETE_INTERFACE\n"));

                    pDel = (PFILTER_DRIVER_DELETE_INTERFACE)pvIoBuffer;

                    dwSize = sizeof(FILTER_DRIVER_DELETE_INTERFACE);

                    if(inputBufferLength isnot dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    ntStatus = DeleteInterface(pDel->pvDriverContext);

                    break;
                }

#endif                 // STEELHEAD


                case IOCTL_TEST_PACKET:
                {
                    PFILTER_DRIVER_TEST_PACKET  pPacketInfo;
                    PPAGED_FILTER_INTERFACE     pInPage, pOutPage;
                    FORWARD_ACTION  eaResult;
                    UNALIGNED IPHeader *pHeader;
                    DWORD    dwSizeOfHeader;
                    PBYTE    pbRest;
                    DWORD    dwSizeOfData;

                    CALLTRACE(("IPFLTDRV IOCTL_TEST_PACKET\n"));

                    pPacketInfo = (PFILTER_DRIVER_TEST_PACKET)pvIoBuffer;

                    dwSize = FIELD_OFFSET(FILTER_DRIVER_TEST_PACKET,
                                          bIpPacket[0]);

                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    if(outputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    pHeader = (IPHeader*)(pPacketInfo->bIpPacket);

                    dwSizeOfHeader = ((pHeader->iph_verlen)&0x0f)<<2;

                    pbRest = (PBYTE)pHeader + dwSizeOfHeader;


                    //
                    // make sure the header fits
                    //
                    dwSizeOfData = inputBufferLength - dwSize;

                    if(dwSizeOfData < dwSizeOfHeader)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    //
                    // it does. Make sure the data fits
                    //

                    if(dwSizeOfData < RtlUshortByteSwap(pHeader->iph_length))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    dwSizeOfData -= dwSizeOfHeader;


                    //
                    // Find the paged interface corresponding to the
                    // context
                    //

                    ntStatus = LockFcb(irpStack->FileObject);

                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }

                    pInPage = FindInterfaceOnHandle(
                                irpStack->FileObject,
                                pPacketInfo->pvInInterfaceContext
                                );

                    pOutPage = FindInterfaceOnHandle(
                                irpStack->FileObject,
                                pPacketInfo->pvOutInterfaceContext
                                );

                    //
                    // pInPage and pOutPage can be NULL
                    //


                    eaResult = MatchFilterp(
                                    pHeader,
                                    pbRest,
                                    dwSizeOfData,
                                    INVALID_IF_INDEX,
                                    INVALID_IF_INDEX,
                                    NULL_IP_ADDR,
                                    NULL_IP_ADDR,
                                    pInPage  ? pInPage->pFilter : NULL,
                                    pOutPage ? pOutPage->pFilter : NULL,
                                    FALSE,
                                    TRUE
                                    );

                    UnLockFcb(irpStack->FileObject);

                    ntStatus = STATUS_SUCCESS;

                    pPacketInfo->eaResult = eaResult;

                    //
                    // We dont need to copy the full packet out
                    //

                    dwSize = sizeof(FILTER_DRIVER_TEST_PACKET);

                    break;
                }

                case IOCTL_PF_SET_EXTENSION_POINTER:
                {

                    PPF_SET_EXTENSION_HOOK_INFO ExtensionInfo;

                    TRACE(CONFIG,(
                        "ipfltdrv: IOCTL_PF_SET_EXTENSION_POINTER Called, inputLength=%d\n",
                         inputBufferLength
                         ));

                    if (Irp->RequestorMode != KernelMode)
                    {
                        ntStatus = STATUS_ACCESS_DENIED;
                        break;
                    }
                    ExtensionInfo = (PPF_SET_EXTENSION_HOOK_INFO)pvIoBuffer;
                    if (inputBufferLength < sizeof(PF_SET_EXTENSION_HOOK_INFO))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ntStatus = SetExtensionPointer(
                                               ExtensionInfo,
                                               irpStack->FileObject
                                               );
                    break;
                }


#if STEELHEAD
                case IOCTL_GET_FILTER_INFO:
                {
                    PFILTER_DRIVER_GET_FILTERS  pInfo;
                    PFILTER_INTERFACE           pIf;
                    LOCK_STATS                  LockState;

                    CALLTRACE(("IPFLTDRV: IOCTL_GET_FILTER_INFO\n"));


                    pInfo = (PFILTER_DRIVER_GET_FILTERS)pvIoBuffer;

                    pIf = (PFILTER_INTERFACE)(pInfo->pvDriverContext);

                    //
                    // If we cant even report the number of filters, lets get out
                    //

                    if(inputBufferLength < (sizeof(FILTER_DRIVER_GET_FILTERS) - sizeof(FILTER_STATS)))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    if(outputBufferLength < (sizeof(FILTER_DRIVER_GET_FILTERS) - sizeof(FILTER_STATS)))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    //
                    // Ok we have enough space to plug in the number of filters
                    //

                    AcquireReadLock(&g_filters.ifListLock,&LockState);

                    pInfo->interfaces.eaInAction  = pIf->eaInAction;
                    pInfo->interfaces.eaOutAction = pIf->eaOutAction;

                    pInfo->interfaces.dwNumInFilters  = pIf->dwNumInFilters;
                    pInfo->interfaces.dwNumOutFilters = pIf->dwNumOutFilters;

                    dwSize = SIZEOF_FILTERS(pIf);

                    if(inputBufferLength < dwSize)
                    {
                        dwSize = sizeof(FILTER_DRIVER_GET_FILTERS) - sizeof(FILTER_STATS);

                        ntStatus = STATUS_SUCCESS;

                        ReleaseReadLock(&g_filters.ifListLock,&LockState);

                        break;
                    }

                    if(outputBufferLength < dwSize)
                    {
                        dwSize = sizeof(FILTER_DRIVER_GET_FILTERS) - sizeof(FILTER_STATS);

                        ntStatus = STATUS_SUCCESS;

                        ReleaseReadLock(&g_filters.ifListLock,&LockState);

                        break;
                    }

                    ntStatus = GetFilters(pIf,
                                          FALSE,
                                          &(pInfo->interfaces));

                    pInfo->dwDefaultHitsIn  = g_dwNumHitsDefaultIn;
                    pInfo->dwDefaultHitsOut = g_dwNumHitsDefaultOut;

                    ReleaseReadLock(&g_filters.ifListLock,kIrql);

                    break;
                }
#endif

                case IOCTL_GET_FILTER_TIMES:
                {
                    PFILTER_DRIVER_GET_TIMES    pInfo;
                    PFILTER_INTERFACE           pIf;
                    KIRQL                       kIrql;

                    CALLTRACE(("IPFLTDRV: IOCTL_GET_FILTER_TIMES\n"));

                    dwSize = sizeof(FILTER_DRIVER_GET_TIMES);

                    if(outputBufferLength < sizeof(FILTER_DRIVER_GET_TIMES))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    pInfo = (PFILTER_DRIVER_GET_TIMES)pvIoBuffer;

#ifdef DRIVER_PERF
                    pInfo->dwFragments  = g_dwFragments;
                    pInfo->dwCache1     = g_dwCache1;
                    pInfo->dwCache2     = g_dwCache2;
                    pInfo->dwNumPackets = g_dwNumPackets;
                    pInfo->dwWalk1      = g_dwWalk1;
                    pInfo->dwWalk2      = g_dwWalk2;
                    pInfo->dwForw       = g_dwForw;
                    pInfo->dwWalkCache  = g_dwWalkCache;

                    pInfo->liTotalTime.HighPart = g_liTotalTime.HighPart;
                    pInfo->liTotalTime.LowPart  = g_liTotalTime.LowPart;
#else
                    pInfo->dwFragments  = 0;
                    pInfo->dwCache1     = 0;
                    pInfo->dwCache2     = 0;
                    pInfo->dwNumPackets = 0;
                    pInfo->dwWalk1      = 0;
                    pInfo->dwWalk2      = 0;
                    pInfo->dwForw       = 0;
                    pInfo->dwWalkCache  = 0;

                    pInfo->liTotalTime.HighPart = 0;
                    pInfo->liTotalTime.LowPart  = 0;
#endif
                    ntStatus = STATUS_SUCCESS;

                    break;
                }

                default:
                {
                    ERROR(("IPFLTDRV: unknown IOCTL\n"));

                    ntStatus = STATUS_INVALID_PARAMETER;

                    break;
                }
            }

            break;
        }

        default:
        {
            ERROR(("IPFLTDRV:: unknown IRP_MJ_XXX\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    if(ntStatus != STATUS_PENDING)
    {
        Irp->IoStatus.Status = ntStatus;

        Irp->IoStatus.Information = dwSize;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return(ntStatus);
}

VOID
FilterDriverUnload(
                   IN PDRIVER_OBJECT DriverObject
                   )
/*++
  Routine Description
        Called when the driver is unloaded. This shuts down the filtering (if it hasnt been shut
        down already) and removes the DOS name

  Arguments
        DriverObject

  Return Value
        None
--*/
{
    CALLTRACE(("IPFLTDRV: FilterDriverUnload\n"));

    CloseFilterDriver();

    TearDownExternalNaming();

    IoDeleteDevice(DriverObject->DeviceObject);
}



VOID
SetupExternalNaming (
                     IN PUNICODE_STRING ntname
                     )
/*++
  Routine Description
        Inserts the input name as the DOS name

  Arguments
        ntname - Name of driver

  Return Value
        None
--*/
{
    UNICODE_STRING  ObjectDirectory;
    UNICODE_STRING  SymbolicLinkName;
    UNICODE_STRING  fullLinkName;
    BYTE      	    buffer[100] ;

    //
    // Form the full symbolic link name we wish to create.
    //

    RtlInitUnicodeString (&fullLinkName, NULL);

    RtlInitUnicodeString (&ObjectDirectory, DEFAULT_DIRECTORY);

    RtlInitUnicodeString(&SymbolicLinkName, DEFAULT_FLTRDRVR_NAME);

    fullLinkName.MaximumLength = (sizeof(L"\\")*2) + ObjectDirectory.Length
      + SymbolicLinkName.Length + sizeof(WCHAR);

    fullLinkName.Buffer = (WCHAR *)buffer ;

    RtlZeroMemory (fullLinkName.Buffer, fullLinkName.MaximumLength);

    RtlAppendUnicodeToString (&fullLinkName, L"\\");

    RtlAppendUnicodeStringToString (&fullLinkName, &ObjectDirectory);

    RtlAppendUnicodeToString (&fullLinkName, L"\\");

    RtlAppendUnicodeStringToString (&fullLinkName, &SymbolicLinkName);

    if (!NT_SUCCESS(IoCreateSymbolicLink (&fullLinkName, ntname)))
    {
        ERROR((
            "IPFLTDRV: ERROR win32 device name could not be created \n"
            ));
    }

}


VOID
TearDownExternalNaming()
/*++
  Routine Description
      Removes the DOS name from the registry
      Called when the driver is unloaded

  Arguments
      None

  Return Value
      None

--*/
{
    UNICODE_STRING  ObjectDirectory;
    UNICODE_STRING  SymbolicLinkName;
    UNICODE_STRING  fullLinkName;
    BYTE      	    buffer[100] ;

    RtlInitUnicodeString (&fullLinkName, NULL);

    RtlInitUnicodeString (&ObjectDirectory, DEFAULT_DIRECTORY);

    RtlInitUnicodeString(&SymbolicLinkName, DEFAULT_FLTRDRVR_NAME);

    fullLinkName.MaximumLength = (sizeof(L"\\")*2) + ObjectDirectory.Length
      + SymbolicLinkName.Length + sizeof(WCHAR);

    fullLinkName.Buffer = (WCHAR *)buffer ;

    RtlZeroMemory (fullLinkName.Buffer, fullLinkName.MaximumLength);

    RtlAppendUnicodeToString (&fullLinkName, L"\\");

    RtlAppendUnicodeStringToString (&fullLinkName, &ObjectDirectory);

    RtlAppendUnicodeToString (&fullLinkName, L"\\");

    RtlAppendUnicodeStringToString (&fullLinkName, &SymbolicLinkName);

    if (!NT_SUCCESS(IoDeleteSymbolicLink (&fullLinkName)))
    {
        ERROR((
            "IPFLTDRV: ERROR win32 device name could not be deleted\n"
            ));
    }
}

BOOL
InitFilterDriver()
/*++
  Routine Description
       Starts the driver. Allocates memory for the cache and cache entries. Clears the entries
       Sends an IOCTL to the Forwarder to set up its entry point (which starts the filtering
       process in the forwarder)

  Arguments
       None

  Return Value
       TRUE if successful

--*/
{
    NTSTATUS status;
    BOOL bRet;
    SYSTEM_BASIC_INFORMATION PerfInfo;

    status = ZwQuerySystemInformation(
                SystemBasicInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );

    //
    // adjust cache and hash sizes based on the memory
    //

    if(PerfInfo.NumberOfPhysicalPages <= 8000)
    {
        //
        // 32 MB or smaller. A very chincy server
        //

        g_dwCacheSize = 257;
        g_dwHashLists = 127;
    }
    else if(PerfInfo.NumberOfPhysicalPages < 16000)
    {
        //
        // 32-64 MB. Better.
        //

        g_dwCacheSize = 311;
        g_dwHashLists = 311;
    }
    else if(PerfInfo.NumberOfPhysicalPages < 32000)
    {
        //
        // 64 - 128 MB.
        //

        g_dwCacheSize = 511;
        g_dwHashLists = 511;
    }
    else
    {
        //
        //  big machine
        //

        g_dwCacheSize = 511;
        g_dwHashLists = 1023;
    }


    InitLogs();

    __try
    {

        bRet = TRUE;

        if(!AllocateCacheStructures())
        {
            ERROR(("IPFLTDRV: Couldnt allocate cache structures\n"));

            bRet = FALSE;

            __leave;
        }

        //
        // Clean the cache
        //

        ClearCache();

        //
        // Now send and Irp to IP Forwarder and give him our entry point
        // Do it twice, once to make sure it is cleared and to
        // erase any previous filter contexts and once to do what
        // we want it to do.
        //

        status = SetForwarderEntryPoint(NULL);
        status = SetForwarderEntryPoint(MatchFilter);

        if(status isnot STATUS_SUCCESS)
        {
            ERROR((
                "IPFLTDRV: IOCTL to IP Forwarder failed - status \n",
                status
                ));

            bRet = FALSE;

            __leave;
        }

    }
    __finally
    {

        LARGE_INTEGER   liDueTime;

        if(!bRet)
        {
            FreeExistingCache();
        }
        else
        {
            ExInitializeNPagedLookasideList(
                       &filter_slist,
                       ExAllocatePoolWithTag,
                       ExFreePool,
                       0,
                       sizeof(FILTER),
                       (ULONG)'2liF',
                       100);
            ExInitializePagedLookasideList(
                       &paged_slist,
                       ExAllocatePoolWithTag,
                       ExFreePool,
                       0,
                       sizeof(PAGED_FILTER),
                       (ULONG)'2liF',
                       100);

            ExInitializeNPagedLookasideList(
                       &g_llFragCacheBlocks,
                       NULL,
                       NULL,
                       0,
                       sizeof(FRAG_INFO),
                       'ftlF',
                       32);

            //
            // Set the timer for fragment cache.
            //

            KeInitializeDpc(
                       &g_kdTimerDpc,
                       FragCacheTimerRoutine,
                       NULL);

            KeInitializeTimer(&g_ktTimer);

            liDueTime.QuadPart = (ULONGLONG)TIMER_IN_MILLISECS * (ULONGLONG)SYS_UNITS_IN_ONE_MILLISEC;

            liDueTime.QuadPart = -liDueTime.QuadPart;

            KeSetTimerEx(
                      &g_ktTimer,
                      liDueTime,
                      TIMER_IN_MILLISECS,
                      &g_kdTimerDpc);
        }
    }
    return bRet;
}

BOOL
CloseFilterDriver()
/*++
  Routine Description
       Shuts down the driver.

  Arguments


  Return Value
--*/
{

    NTSTATUS    status;
    LOCK_STATE  LockState;
    PLIST_ENTRY pleHead;
    BOOL        bStopForw = TRUE;
    PFREEFILTER pFree, pFree1;
    PPFFCB Fcb;

    //
    // The first thing to do is send an IOCTL to forwarder to tell him to stop sending
    // us anymore packets.
    //

    status = SetForwarderEntryPoint(NULL);

    if(!NT_SUCCESS(status))
    {
        //
        // This means we could not tell IP Forwarder
        // to stop filtering packets so we cant go away.
        //

       ERROR((
           "IPFLTDRV: CloseFilterDriver - SetForwardEntryPoint() was UNSUCCESSFUL, Error-0x%08x\n",
           status
           ));

        bStopForw = FALSE;

    }

    //
    // remove the FCBS
    //

    while(TRUE)
    {
        NTSTATUS ntStatus;
        FILE_OBJECT fo;
        KIRQL kirql;
        BOOL fDone = TRUE;

        KeAcquireSpinLock(&g_FcbSpin, &kirql);
        for(pleHead = g_leFcbs.Flink;
            pleHead != &g_leFcbs;
            pleHead = pleHead->Flink)
        {
            Fcb = CONTAINING_RECORD(pleHead, PFFCB, leList);
            //
            // This can happen if some other thread is closing the FCB.
            //
            if(Fcb->dwFlags & PF_FCB_CLOSED)
            {
                continue;
            }
            KeReleaseSpinLock(&g_FcbSpin, kirql);
            fDone = FALSE;
            fo.FsContext2 = (PVOID)Fcb;
            ntStatus = LockFcb(&fo);
            if(!NT_SUCCESS(ntStatus))
            {
                break;
            }
            FcbLockDown(Fcb);
            UnLockFcb(&fo);
            break;
        }
        if(fDone)
        {
            KeReleaseSpinLock(&g_FcbSpin, kirql);
            break;
        }
    }

    ExDeleteResourceLite ( &FilterListResourceLock );
    ExDeleteResourceLite ( &FilterAddressLock );

    AcquireWriteLock(&(g_filters.ifListLock),&LockState);

    while(!IsListEmpty(&g_filters.leIfListHead))
    {
        PFILTER_INTERFACE pIf;

        pleHead = g_filters.leIfListHead.Flink;

        pIf = CONTAINING_RECORD(pleHead,FILTER_INTERFACE,leIfLink);

        DeleteFilters(pIf,
                      IN_FILTER_SET);

        DeleteFilters(pIf,
                      OUT_FILTER_SET);

        //
        // Set the number of filters to 0 and the default action to forward so
        // that if we havent been able to stop the forwarder from calling us,
        // atleast no packets get filtered
        //

        pIf->dwNumInFilters = 0;
        pIf->dwNumOutFilters = 0;
        pIf->eaInAction = FORWARD;
        pIf->eaOutAction = FORWARD;

        if(bStopForw)
        {
            //
            // We could stop the forwarder so lets blow away the interface
            //

            RemoveHeadList(&g_filters.leIfListHead);

            ExFreePool(pIf);
        }
    }

    ClearCache();

    if(bStopForw)
    {
        //
        // If we could stop the forwarder, blow away the cache
        //

        FreeExistingCache();


    }

    ReleaseWriteLock(&g_filters.ifListLock,&LockState);


    if(g_bDriverRunning)
    {

        //
        // Fragment cache related cleanup.
        // remove the timer
        //

        if(KeCancelTimer(&g_ktTimer) is FALSE)
        {
             //
             // Tmer was not in the system queue. Maybe we should sleep
             // or something
             //

             ERROR(("IPFLTDRV: Timer NOT in system queue\n"));
             DbgBreakPoint();
        }

        ExDeleteNPagedLookasideList( &filter_slist );
        ExDeletePagedLookasideList( &paged_slist );
        ExDeleteNPagedLookasideList(&g_llFragCacheBlocks);

    }

    if(AddrTable)
    {
        ExFreePool(AddrTable);
        AddrTable = 0;
    }

    if(AddrHashTable)
    {
        ExFreePool(AddrHashTable);
        AddrHashTable = 0;
    }


    if(AddrSubnetHashTable)
    {
        ExFreePool(AddrSubnetHashTable);
        AddrSubnetHashTable = 0;
    }

    if (g_pleFragTable)
    {
       ExFreePool(g_pleFragTable);
       g_pleFragTable = 0;
    }

    if(g_filters.pInterfaceCache)
    {
        ExFreePool(g_filters.pInterfaceCache);
        g_filters.pInterfaceCache = NULL;
    }

    TRACE(CONFIG,(
        "IPFLTDRV: BoundInterfaceCnt=%d\n", 
        g_ulBoundInterfaceCount
        ));

    if(bStopForw)
    {
        CALLTRACE(("IPFLTDRV: CloseFilterDriver - returning SUCCESS\n"));
        return STATUS_SUCCESS;
    }
    else
    {
        ERROR(("CloseFilterDriver - returning UNSUCCESSFUL\n"));
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
SetForwarderEntryPoint(
                       IN   IPPacketFilterPtr pfnMatch
                       )
/*++
  Routine Description
       Sets the entry point to IP Forwarder. Used to start and stop the forwarding code in
       the forwarder

  Arguments
       pfnMatch  Pointer to the function that implements the filter matching code
                 NULL will stop forwarding, while any other value will cause the forwarder to
                 invoke the function pointed to. Thus if on stopping, the IOCTL to the
                 forwarder doesnt succeed, and the filter driver goes away, the system will
                 blue screen

  Return Value
      NTSTATUS
--*/
{
    NTSTATUS                status;
    IP_SET_FILTER_HOOK_INFO functionInfo;

    functionInfo.FilterPtr = pfnMatch;
    status = DoIpIoctl(
                       DD_IP_DEVICE_NAME,
                       IOCTL_IP_SET_FILTER_POINTER,
                       (PVOID)&functionInfo,
                       sizeof(functionInfo),
                       NULL,
                       0,
                       NULL);
    return(status);
}

NTSTATUS
DoIpIoctl(
          IN  PWCHAR        DriverName,
          IN  DWORD         Ioctl,
          IN  PVOID         pvInArg,
          IN  DWORD         dwInSize,
          IN  PVOID         pvOutArg,
          IN  DWORD         dwOutSize,
          OUT PDWORD        pdwInfo OPTIONAL)
/*++
Routine Description:
    Do an IOCTL to the stack. Used for a varity of purposes
--*/
{
    NTSTATUS                status;
    UNICODE_STRING          nameString;
    OBJECT_ATTRIBUTES       Atts;
    IO_STATUS_BLOCK         ioStatusBlock;
    HANDLE                  Handle;

    PAGED_CODE();

    RtlInitUnicodeString(&nameString, DriverName);

    InitializeObjectAttributes(&Atts,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

   status = ZwCreateFile(&Handle,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &Atts,
                         &ioStatusBlock,
                         NULL,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN_IF,
                         0,
                         NULL,
                         0);

    if (!NT_SUCCESS(status))
    {
        ERROR(("IPFLTDRV: Couldnt open IP Forwarder - status %d\n",status));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Submit the request to the forwarder
    //

    status = ZwDeviceIoControlFile(
                      Handle,
                      NULL,
                      NULL,
                      NULL,
                      &ioStatusBlock,
                      Ioctl,
                      pvInArg,
                      dwInSize,
                      pvOutArg,
                      dwOutSize);

    if(!NT_SUCCESS(status))
    {
        ERROR((
            "IPFLTDRV: DoIpIoctl: IOCTL request failed - status %x\n",
            status
            ));
    }
    else
    {
        if(pdwInfo)
        {
            *pdwInfo = (DWORD)ioStatusBlock.Information;
        }
    }

    //
    // Close the device.
    //

    ZwClose(Handle);

    return status;
}

BOOL
AllocateCacheStructures()
/*++
  Routine Description
        Allocates the necessary memory for cache (which is an array of pointers to
            cache entries)
        Allocates necessary number of cache entries (but doesnt initialize them)
        Allocates a small number of entries and puts them on the free list (doesnt
            initialize these either)

  Arguments
        None

  Return Value
        True if the function completely succeeds, else FALSE.  If FALSE, it is upto
            the CALLER to do a rollback and clear any allocated memory
--*/
{
    DWORD i;
    KIRQL   kiCurrIrql;

    CALLTRACE(("IPFLTDRV: AllocateCacheStructures\n"));

    g_filters.ppInCache = ExAllocatePoolWithTag(NonPagedPool,
                                               g_dwCacheSize * sizeof(PFILTER_INCACHE),
                                               'hCnI');

    if(g_filters.ppInCache is NULL)
    {
        ERROR(("IPFLTDRV: Couldnt allocate memory for Input Cache\n"));
        return FALSE;
    }

    g_filters.ppOutCache = ExAllocatePoolWithTag(NonPagedPool,
                                                g_dwCacheSize * sizeof(PFILTER_OUTCACHE),
                                                'CtuO');

    if(g_filters.ppOutCache is NULL)
    {
        ERROR(("IPFLTDRV: Couldnt allocate memory for Output Cache\n"));
        return FALSE;
    }

    for(i = 0; i < g_dwCacheSize; i++)
    {
        g_filters.ppInCache[i] = NULL;
        g_filters.ppOutCache[i] = NULL;
    }

    for(i = 0; i < g_dwCacheSize; i++)
    {
        PFILTER_INCACHE  pTemp1;
        PFILTER_OUTCACHE pTemp2;

        pTemp1 = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(FILTER_INCACHE),
                                       'NI');
        if(pTemp1 is NULL)
        {
            return FALSE;
        }

        g_filters.ppInCache[i] = pTemp1;

        pTemp2 = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(FILTER_OUTCACHE),
                                       'TUO');
        if(pTemp2 is NULL)
        {
            return FALSE;
        }

        g_filters.ppOutCache[i] = pTemp2;
    }

    TRACE(CACHE,("IPFLTDRV: Allocated cache structures\n"));

    TRACE(CACHE,("IPFLTDRV: Creating in and out free list..."));

    for(i = 0; i < FREE_LIST_SIZE; i++)
    {
        PFILTER_INCACHE  pTemp1;
        PFILTER_OUTCACHE pTemp2;

        pTemp1 = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(FILTER_INCACHE),
                                       'FNI');
        if(pTemp1 is NULL)
        {
            return FALSE;
        }

        InitializeListHead(&pTemp1->leFreeLink);

        InsertHeadList(&g_freeInFilters,&pTemp1->leFreeLink);

        pTemp2 = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(FILTER_OUTCACHE),
                                       'FTUO');
        if(pTemp2 is NULL)
        {
            return FALSE;
        }

        InitializeListHead(&pTemp2->leFreeLink);

        InsertHeadList(&g_freeOutFilters,&pTemp2->leFreeLink);
    }

    KeAcquireSpinLock(
              &g_kslFragLock,
              &kiCurrIrql);

    g_pleFragTable = ExAllocatePoolWithTag(
                            NonPagedPool,
                            g_dwFragTableSize * sizeof(LIST_ENTRY),
                            '2tlF');

    if(!g_pleFragTable)
    {
       ERROR(("IPFLTDRV: Couldnt allocate frag table\n"));

       KeReleaseSpinLock(
                 &g_kslFragLock,
                 kiCurrIrql);

       return FALSE;
    }

    TRACE(FRAG,("IPFLTDRV: Initializing fragment cache\n"));

    for(i = 0; i < g_dwFragTableSize; i++)
    {
        InitializeListHead(&(g_pleFragTable[i]));
    }

    KeReleaseSpinLock(
             &g_kslFragLock,
             kiCurrIrql);

    CALLTRACE(("IPFLTDRV: AllocateCacheStructures Done\n"));
    return TRUE;
}

VOID
FreeExistingCache()
/*++
  Routine Description
       Frees all the cache entries, free entries and cache pointer array

  Arguments
      None

  Return Value
      None
--*/
{
    DWORD i;
    KIRQL   kiCurrIrql;


    CALLTRACE(("IPFLTDRV: FreeExistingCache\n"));

    if(g_filters.ppInCache isnot NULL)
    {
        for(i = 0; i < g_dwCacheSize; i ++)
        {
            if(g_filters.ppInCache[i] isnot NULL)
            {
                ExFreePool(g_filters.ppInCache[i]);
            }
        }

        ExFreePool(g_filters.ppInCache);
        g_filters.ppInCache = NULL;
    }

    TRACE(CACHE,("IPFLTDRV: Done freeing In cache\n"));

    TRACE(CACHE,("IPFLTDRV: Freeing existing out cache\n"));

    if(g_filters.ppOutCache isnot NULL)
    {
        for(i = 0; i < g_dwCacheSize; i ++)
        {
            if(g_filters.ppOutCache[i] isnot NULL)
            {
                ExFreePool(g_filters.ppOutCache[i]);
            }
        }

        ExFreePool(g_filters.ppOutCache);
        g_filters.ppOutCache = NULL;
    }

    TRACE(CACHE,("IPFLTDRV: Done freeing Out cache\n"));

    TRACE(CACHE,("IPFLTDRV: Freeing free in filters\n"));

    while(!IsListEmpty(&g_freeInFilters))
    {
        PFILTER_INCACHE pIn;
        PLIST_ENTRY     pleHead;

        pleHead = RemoveHeadList(&g_freeInFilters);

        pIn = CONTAINING_RECORD(pleHead,FILTER_INCACHE,leFreeLink);

        ExFreePool(pIn);
    }

    TRACE(CACHE,("IPFLTDRV: Done freeing free in filters\n"));

    TRACE(CACHE,("IPFLTDRV: Freeing free out filters\n"));

    while(!IsListEmpty(&g_freeOutFilters))
    {
        PFILTER_OUTCACHE pOut;
        PLIST_ENTRY     pleHead;

        pleHead = RemoveHeadList(&g_freeOutFilters);

        pOut = CONTAINING_RECORD(pleHead,FILTER_OUTCACHE,leFreeLink);

        ExFreePool(pOut);
    }

    TRACE(CACHE,("IPFLTDRV: Done freeing free out filters\n"));

    TRACE(FRAG,("IPFLTDRV: Freeing fragment cache\n"));

    ClearFragCache();

    TRACE(CACHE,("IPFLTDRV: Done freeing fragment cache\n"));

    CALLTRACE(("IPFLTDRV: FreeExistingCache Done\n"));
}


NTSTATUS
OpenNewHandle(PFILE_OBJECT FileObject)
/*++
Routine Description:
    Open a new handle to the driver. Allocate FCB from the paged pool
    and initialize it. If no memory available, fail. If success
    store the FCB pointer into the file object.
--*/
{
    PPFFCB Fcb;
    KIRQL kirql;

    //
    // Allocate an FCB for this handle.
    //

    Fcb = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(*Fcb),
                                'pfFC');
    if(Fcb)
    {
        FileObject->FsContext2 = (PVOID)Fcb;
        Fcb->dwFlags = 0;
        Fcb->UseCount = 1;
        InitializeListHead(&Fcb->leInterfaces);
        InitializeListHead(&Fcb->leLogs);
        ExInitializeResourceLite ( &Fcb->Resource );
        ExAcquireSpinLock(&g_FcbSpin, &kirql);
        InsertTailList(&g_leFcbs, &Fcb->leList);
        ExReleaseSpinLock(&g_FcbSpin, kirql);
        return(STATUS_SUCCESS);
    }
    return(STATUS_NO_MEMORY);
}

PPAGED_FILTER_INTERFACE
FindInterfaceOnHandle(PFILE_OBJECT FileObject,
                      PVOID pvValue)

/*++
   Routine Description:

   Find the paged interface for the call. If none found
   return a NULL. Uses the caller-supplied DriverContext to
   search the contexts on this handle. In general, there should
   not be many such handles.
--*/
{
    PPFFCB Fcb = FileObject->FsContext2;
    PPAGED_FILTER_INTERFACE pPage;

    PAGED_CODE();


    for(pPage = (PPAGED_FILTER_INTERFACE)Fcb->leInterfaces.Flink;
        (PLIST_ENTRY)pPage != &Fcb->leInterfaces;
        pPage = (PPAGED_FILTER_INTERFACE)pPage->leIfLink.Flink)
    {
        if(pPage->pvDriverContext == pvValue)
        {
            return(pPage);
        }
    }
    return(NULL);
}

NTSTATUS
CloseFcb(PPFFCB Fcb, PFILE_OBJECT FileObject)
/*++
   Routine Description:

      Called when an FCB has no more references. The caller must
      have removed the FCB from the master list. It is immaterial whether
      the CB resource is locked.
--*/
{
    PPAGED_FILTER_INTERFACE pPage;
    PFREEFILTER pList, pList1;
    NTSTATUS ntStatus;

    TRACE(CONFIG,(
     "IPFLTDRV: CloseFcb, Fcb=0x%08x, FileObject=0x%08x\n", Fcb, FileObject
     ));


    //
    // First clean up the logs
    //
    while(!IsListEmpty(&Fcb->leLogs))
    {
        PFDELETELOG DelLog;

        DelLog.pfLogId = (PFLOGGER)Fcb->leLogs.Flink;
        (VOID)PfDeleteLog(&DelLog, Fcb);
    }

    //
    // Next, clean up the interfaces
    //
    while(!IsListEmpty(&Fcb->leInterfaces))
    {
        TRACE(CONFIG,("IPFLTDRV: Removing interface\n"));
        pPage = (PPAGED_FILTER_INTERFACE)RemoveHeadList(&Fcb->leInterfaces);
        (VOID)DeletePagedInterface(Fcb, pPage);
    }

#if 0
    //
    // Can't do this because can't get the filter context from the stack.
    //

    if(Fcb->dwFlags & PF_FCB_OLD)
    {
        DeleteOldInterfaces(Fcb);
    }
#endif

    //
    // Free the Fcb
    //

    ExDeleteResourceLite ( &Fcb->Resource );
    ExFreePool(Fcb);
    if(FileObject)
    {
        FileObject->FsContext2 = NULL;
    }
    return(STATUS_SUCCESS);
}

DWORD
GetIpStackIndex(IPAddr Addr, BOOL fNew)
/*++
  Routine Description:
     Get the stack index for the corresponding address and mask
--*/
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;
    NTSTATUS                           Status;
    IPSNMPInfo                         IPSnmpInfo;
    IPAddrEntry                        *AddrTable1;
    DWORD                              dwSpace, dwIpIndex;
    DWORD                              dwFinalAddrSize;
    DWORD                              dwFinalSize, dwX;
    PADDRESSARRAY                      pa;
    LOCK_STATE                         LockState;


    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite( &FilterAddressLock, TRUE);
    if(!AddrTable || fNew)
    {
        ExReleaseResourceLite(&FilterAddressLock );
        ExAcquireResourceExclusiveLite( &FilterAddressLock, TRUE);

        if(fNew && AddrTable)
        {
            //
            // acquire the spin lock to synchronize with Match
            // code running at DPC so we can "lock out"
            // the table while we do the rest of this. Note
            // we can't hold a spin lock while building the table
            // because the calls into the IP stack hit pageable
            // code
            //
            
            AcquireWriteLock(&g_IpTableLock, &LockState);
            g_dwMakingNewTable = TRUE;
            ReleaseWriteLock(&g_IpTableLock, &LockState);
            ExFreePool( AddrTable );
            AddrTable = 0;
        }
    }

    if(!AddrTable)
    {
        dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

        dwOutBufLen = sizeof(IPSNMPInfo);

        ID = &(trqiInBuf.ID);
        ID->toi_entity.tei_entity = CL_NL_ENTITY;
        ID->toi_entity.tei_instance = 0;
        ID->toi_class = INFO_CLASS_PROTOCOL;
        ID->toi_type = INFO_TYPE_PROVIDER;
        ID->toi_id = IP_MIB_STATS_ID;

        Context = (BYTE *) &(trqiInBuf.Context[0]);
        RtlZeroMemory(Context, CONTEXT_SIZE);

        Status = DoIpIoctl(
                       DD_TCP_DEVICE_NAME,
                       IOCTL_TCP_QUERY_INFORMATION_EX,
                       (PVOID)&trqiInBuf,
                       sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                       (PVOID)&IPSnmpInfo,
                       dwOutBufLen,
                       NULL);

       if(NT_SUCCESS(Status))
       {


            //
            // allocate some memory to fetch the address table.
            //

            dwSpace = IPSnmpInfo.ipsi_numaddr + 10;

            dwOutBufLen = dwSpace * sizeof(IPAddrEntry);

            if(!AddrHashTable)
            {
                //
                // the hash table size was not specified in the
                // registry. Compute it based on the number of
                // addresses. Try to keep the hash table less than
                // half full.
                //
                if(!AddrModulus)
                {
                    if(IPSnmpInfo.ipsi_numaddr < ADDRHASHLOWLEVEL)
                    {
                        AddrModulus = ADDRHASHLOW;
                    }
                    else if(IPSnmpInfo.ipsi_numaddr < ADDRHASHMEDLEVEL)
                    {
                        AddrModulus = ADDRHASHMED;
                    }
                    else
                    {
                        AddrModulus = ADDRHASHHIGH;
                    }
                }
                AddrHashTable = (PADDRESSARRAY *)ExAllocatePoolWithTag(
                                              NonPagedPool,
                                              AddrModulus *
                                               sizeof(PADDRESSARRAY),
                                              'pfAh');
                if(!AddrHashTable)
                {
                    ERROR(("IPFLTDRV: Could not allocate AddrHashTable"));
                    g_dwMakingNewTable = FALSE;
                    ExReleaseResourceLite(&FilterAddressLock );
                    KeLeaveCriticalRegion();
                    return(UNKNOWN_IP_INDEX);
                }
            }

            if(!AddrSubnetHashTable)
            {
                AddrSubnetHashTable = (PADDRESSARRAY *)ExAllocatePoolWithTag(
                                              NonPagedPool,
                                              AddrModulus *
                                               sizeof(PADDRESSARRAY),
                                              'pfAh');
                if(!AddrSubnetHashTable)
                {
                    ERROR(("IPFLTDRV: Could not allocate AddrSubnetHashTable"));
                    g_dwMakingNewTable = FALSE;
                    ExReleaseResourceLite(&FilterAddressLock );
                    KeLeaveCriticalRegion();
                    return(UNKNOWN_IP_INDEX);
                }
            }

            RtlZeroMemory(AddrHashTable, AddrModulus * sizeof(PADDRESSARRAY));
            RtlZeroMemory(AddrSubnetHashTable,
                          AddrModulus * sizeof(PADDRESSARRAY));

            AddrTable = (IPAddrEntry *)ExAllocatePoolWithTag(
                                              NonPagedPool,
                                              dwOutBufLen,
                                              'pfAt');

            if(!AddrTable)
            {
                ERROR((
                    "IPFLTDRV: Could not allocate AddrTable of size %d\n",
                    dwSpace
                    ));
                g_dwMakingNewTable = FALSE;
                ExReleaseResourceLite(&FilterAddressLock );
                KeLeaveCriticalRegion();
                return(UNKNOWN_IP_INDEX);
            }
        }
        else
        {
            ERROR((
                "IPFLTDRV: GetIpStackIndex: DoIpIoctl failed, Status=%08x\n", 
                Status
                ));
            g_dwMakingNewTable = FALSE;
            ExReleaseResourceLite(&FilterAddressLock );
            KeLeaveCriticalRegion();
            return(UNKNOWN_IP_INDEX);
        }


        ID->toi_type = INFO_TYPE_PROVIDER;
        ID->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
        RtlZeroMemory( Context, CONTEXT_SIZE );

        Status = DoIpIoctl(
                              DD_TCP_DEVICE_NAME,
                              IOCTL_TCP_QUERY_INFORMATION_EX,
                              (PVOID)&trqiInBuf,
                              dwInBufLen,
                              (PVOID)AddrTable,
                              dwOutBufLen,
                              &dwFinalAddrSize);

        if(!NT_SUCCESS(Status))
        {
            ERROR(("IPFLTDRV: Reading IP addr table failed %x\n", Status));
            ExFreePool(AddrTable);
            AddrTable = 0;
            g_dwMakingNewTable = FALSE;
            ExReleaseResourceLite(&FilterAddressLock );
            KeLeaveCriticalRegion();
            return(UNKNOWN_IP_INDEX);
        }

        //
        // Now to get sleazy. Convert each IPAddrEntry into an ADDRESSARRAY
        // entry and hash it into the AddrHashTable. Note this depends
        // on the structures having common definitions and on
        // IPAddrEntry to be at least as large as ADDRESSARRAY. So be
        // careful.
        //

        dwFinalSize = dwFinalAddrSize / sizeof(IPAddrEntry);

        for(AddrTable1 = AddrTable;
            dwFinalSize;
            dwFinalSize--, AddrTable1++)
        {
            dwX = ADDRHASHX(AddrTable1->iae_addr);

            pa = (PADDRESSARRAY)AddrTable1;

            pa->ulSubnetBcastAddress = AddrTable1->iae_addr |
                                        ~AddrTable1->iae_mask;

            //
            // Now hash it into the hash table
            //

            pa->pNext = AddrHashTable[dwX];
            AddrHashTable[dwX] = pa;

            //
            // and do a hash on the subnet address as well
            //

            dwX = ADDRHASHX(pa->ulSubnetBcastAddress);
            pa->pNextSubnet = AddrSubnetHashTable[dwX];
            AddrSubnetHashTable[dwX] = pa;
        }

        //
        // allow the DPC match code to use the table. Note
        // this does not require interlocking since storing
        // memory is atomic.
        //
        g_dwMakingNewTable = FALSE;
    }

    //
    // search the table for the address.
    //

    dwIpIndex = LocalIpLook(Addr);

    ExReleaseResourceLite(&FilterAddressLock );
    KeLeaveCriticalRegion();
    return(dwIpIndex);
}

BOOL
MatchLocalLook(DWORD Addr, DWORD dwIndex)
/*++
Routine Description:
  Called from the Match code, probably at DPC level, to
  check an address. If the address table is being rebuilt
  just return success. See inner comment for more on this
--*/
{
    BOOL fRet;
    LOCK_STATE LockState;
    

    if(!BMAddress(Addr))
    {
        //
        // Look it up.  Note that if the table is being rebuilt,
        // this succeeds. This is a security hole but it is very
        // small and nearly impossible to exploit effectively and
        // the alternative, denying this, is even worse.
        //  ArnoldM 19-Sept-1997.
        //

        AcquireReadLock(&g_IpTableLock, &LockState);
        if(AddrTable && !g_dwMakingNewTable)
        {
            DWORD dwLookupIndex = LocalIpLook(Addr);

            //
            // the address is acceptable if it belongs to
            // the arriving interface or if it belongs to
            // no interfaces. The latter is the route-through case.
            //
            if((dwIndex == dwLookupIndex)
                         ||
               (dwLookupIndex == UNKNOWN_IP_INDEX) )
            {
                fRet = TRUE;
            }
            else
            {
                fRet = FALSE;
            }
        }
        else
        {
            fRet = TRUE;
        }
        ReleaseReadLock(&g_IpTableLock, &LockState);
        
    }
    else
    {
        fRet = TRUE;
    }
    return(fRet);
}

DWORD
LocalIpLook(DWORD Addr)
/*++
Routine Description:
  Called to lookup an address in the address hash tables. The caller
  either must hold the g_IpTableLock read sping lock or must hold
  the FilterAddressLock resource. This should never be called
  while the address table is being built and holding one of
  these locks insures this.
--*/
{
    DWORD dwIpIndex, dwX;
    PADDRESSARRAY  pa;

    dwX = ADDRHASHX(Addr);

    for(pa = AddrHashTable[dwX]; pa; pa = pa->pNext)
    {
        if(pa->ulAddress == Addr)
        {
            dwIpIndex = pa->ulIndex;
            goto alldone;   // ugly but faster than a break and another test.
        }
    }

    for(pa = AddrSubnetHashTable[dwX]; pa; pa = pa->pNextSubnet)
    {
        if(pa->ulSubnetBcastAddress == Addr)
        {
            dwIpIndex = pa->ulIndex;
            goto alldone;
        }
    }

    //
    // not found. Deliver the bad news.
    //
    dwIpIndex = UNKNOWN_IP_INDEX;

alldone:
    return(dwIpIndex);
}

BOOLEAN
PfFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    DWORD dwSize;
    PPAGED_FILTER_INTERFACE pPage;
    NTSTATUS ntStatus;
    BOOL fLockedFcb = FALSE;
    MODE PreviousMode;
    
    
    PreviousMode = ExGetPreviousMode();

    try {

        if (InputBufferLength) {
            if (PreviousMode != KernelMode) {
                ProbeForRead(InputBuffer, InputBufferLength, sizeof(UCHAR));
            }
        }

        switch(IoControlCode)
        {
            default:
                return(FALSE);

            case IOCTL_PF_IP_ADDRESS_LOOKUP:

                //
                // do a dummy fetch to make it recompute.
                //
                if((InputBufferLength < sizeof(DWORD))
                             ||
                   (OutputBufferLength < sizeof(DWORD)) )
                {
                    return(FALSE);
                }

                *(PDWORD)OutputBuffer = GetIpStackIndex(*(PDWORD)InputBuffer, TRUE);
                ntStatus = STATUS_SUCCESS;
                break;

            case IOCTL_PF_DELETE_BY_HANDLE:
                if(InputBufferLength < sizeof(PFDELETEBYHANDLE))
                {
                    return(FALSE);
                }

                ntStatus = LockFcb(FileObject);
                if(!NT_SUCCESS(ntStatus))
                {
                    return(FALSE);
                }

                fLockedFcb = TRUE;
                pPage = FindInterfaceOnHandle(
                        FileObject,
                        ((PPFDELETEBYHANDLE)InputBuffer)->pvDriverContext);

                if(!pPage)
                {
                    UnLockFcb(FileObject);
                    return(FALSE);
                }
                ntStatus = DeleteByHandle(
                                     (PPFFCB)FileObject->FsContext2,
                                     pPage,
                                     &((PPFDELETEBYHANDLE)InputBuffer)->pvHandles[0],
                                     InputBufferLength - sizeof(PVOID));

                UnLockFcb(FileObject);
                fLockedFcb = FALSE;
                break;

            case IOCTL_DELETE_INTERFACE_FILTERS_EX:
            {

                //
                // The minimum size is without any TOCs
                //

                dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);

                if(InputBufferLength < dwSize)
                {
                    return(FALSE);
                }

                ntStatus = LockFcb(FileObject);
                if(!NT_SUCCESS(ntStatus))
                {
                    return(FALSE);
                }

                fLockedFcb = TRUE;
                pPage = FindInterfaceOnHandle(
                        FileObject,
                        ((PFILTER_DRIVER_SET_FILTERS)InputBuffer)->pvDriverContext);

                if(!pPage)
                {
                    UnLockFcb(FileObject);
                    return(FALSE);
                }
                ntStatus = UnSetFiltersEx(
                                     (PPFFCB)FileObject->FsContext2,
                                     pPage,
                                     InputBufferLength,
                                     (PFILTER_DRIVER_SET_FILTERS)InputBuffer);

                UnLockFcb(FileObject);
                fLockedFcb = FALSE;
                break;
            }

            case IOCTL_GET_SYN_COUNTS:
            {
                if(OutputBufferLength < sizeof(FILTER_DRIVER_GET_SYN_COUNT))
                {
                    return(FALSE);
                }

                ntStatus = GetSynCountTotal(
                             (PFILTER_DRIVER_GET_SYN_COUNT)OutputBuffer);
                break;

            }

            case IOCTL_SET_INTERFACE_FILTERS_EX:
            {

                //
                // Make sure the caller is using symmetric buffers. If not
                // do it the slow way
                //
                if((InputBuffer != OutputBuffer)
                            ||
                   (InputBufferLength != OutputBufferLength))
                {
                    return(FALSE);
                }

                //
                // The minimum size is without any TOCs
                //

                dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);

                if(InputBufferLength < dwSize)
                {
                    return(FALSE);
                }

                ntStatus = LockFcb(FileObject);
                if(!NT_SUCCESS(ntStatus))
                {
                    return(FALSE);
                }

                fLockedFcb = TRUE;
                pPage = FindInterfaceOnHandle(
                        FileObject,
                        ((PFILTER_DRIVER_SET_FILTERS)InputBuffer)->pvDriverContext);

                if(!pPage)
                {
                    UnLockFcb(FileObject);
                    return(FALSE);
                }
                ntStatus = SetFiltersEx(
                                        (PPFFCB)FileObject->FsContext2,
                                        pPage,
                                        InputBufferLength,
                                        (PFILTER_DRIVER_SET_FILTERS)InputBuffer);
                UnLockFcb(FileObject);
                fLockedFcb = FALSE;
                break;
            }
        }

        IoStatus->Status = ntStatus;
        IoStatus->Information = OutputBufferLength;
        return(TRUE);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (fLockedFcb) {
            UnLockFcb(FileObject);
        }
        return(FALSE);
    }

}

NTSTATUS
LockFcb(
    IN struct _FILE_OBJECT *FileObject)
/*++
  Routine Description:
     Lock an FCB. Check if the FCB is on the master list and if
     it is still valid. On success, returns with the FCB resource locked
     and the FCB referenced.
--*/
{
    PPFFCB Fcb = (PPFFCB)FileObject->FsContext2;
    KIRQL kirql;
    PLIST_ENTRY List;
    PPFFCB Fcb1 = 0;

    if ( Fcb == NULL )
    	return(STATUS_INVALID_PARAMETER);

    KeAcquireSpinLock(&g_FcbSpin, &kirql);

    for(List = g_leFcbs.Flink;
        List != &g_leFcbs;
        List = List->Flink)
    {
        Fcb1 = CONTAINING_RECORD(List, PFFCB, leList);

        //
        // use it if it is not being closed
        //
        if(Fcb1 == Fcb)
        {
            if( !(Fcb->dwFlags & PF_FCB_CLOSED) )
            {
                InterlockedIncrement(&Fcb->UseCount);
            }
            else
            {
                Fcb1 = 0;
            }
            break;
        }
    }

    KeReleaseSpinLock(&g_FcbSpin, kirql);

    if(Fcb != Fcb1)
    {
        //
        // didn't find it.
        //

        return(STATUS_INVALID_PARAMETER);
    }

    //
    // found it. Lock it up.
    //

    KeEnterCriticalRegion();    
    ExAcquireResourceExclusiveLite( &Fcb->Resource, TRUE );

    //
    // must look one more time to see if it has been closed. This can
    // happen if the closer sneaked in. So we have to become the closer.
    //
    if(Fcb->dwFlags & PF_FCB_CLOSED)
    {
        //
        // it was. Unlock it and return an error
        //
        UnLockFcb(FileObject);
        return(STATUS_INVALID_PARAMETER);
    }
    return(STATUS_SUCCESS);
}

VOID
UnLockFcb(
    IN struct _FILE_OBJECT *FileObject)
/*++
  Routine Description:
    Unlock and derefence an FCB. If the reference count becomes zero,
    remove the FCB from the master list and close it.
--*/
{
    PPFFCB Fcb = (PPFFCB)FileObject->FsContext2;
    KIRQL kirql;

    KeAcquireSpinLock(&g_FcbSpin, &kirql);
    if(InterlockedDecrement(&Fcb->UseCount) <= 0)
    {
        ASSERT(Fcb->dwFlags & PF_FCB_CLOSED);
        RemoveEntryList(&Fcb->leList);
        KeReleaseSpinLock(&g_FcbSpin, kirql);
        ExReleaseResourceLite( &Fcb->Resource );
        KeLeaveCriticalRegion();
        CloseFcb(Fcb, FileObject);
    }
    else
    {
        KeReleaseSpinLock(&g_FcbSpin, kirql);
        ExReleaseResourceLite( &Fcb->Resource );
        KeLeaveCriticalRegion();
    }
}

NTSTATUS
InitFragCacheParameters(
            IN PUNICODE_STRING RegistryPath
            )
/*++
  Routine Description
       Called when the driver is loaded. It read the registry for the overrides
       related to fragment cache

  Arguments
       RegistryPath

  Return Value
       NTSTATUS

--*/
{
    INT		        i;
    USHORT          usRegLen;
    PWCHAR          pwcBuffer;
    HANDLE          hRegKey;
    DWORD           dwCheck;
    NTSTATUS        ntStatus;
    UNICODE_STRING  usParamString, usTempString;

    CALLTRACE(("IPFLTDRV: InitFragCacheParams\n"));

    //
    // Fragment cache related intialiazation.
    //

    g_llInactivityTime  = SECS_TO_TICKS(INACTIVITY_PERIOD);
    g_dwFragTableSize   = 127;

    //
    // Read the registry for parameters
    //

    usRegLen = RegistryPath->Length +
               (sizeof(WCHAR) * (wcslen(L"\\Parameters") + 2));

    pwcBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                      usRegLen,
                                      '1tlF');

    if(!pwcBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pwcBuffer, usRegLen);

    usParamString.MaximumLength = usRegLen;
    usParamString.Buffer        = pwcBuffer;

    RtlCopyUnicodeString(&usParamString, RegistryPath);
    RtlInitUnicodeString(&usTempString, L"\\Parameters");
    RtlAppendUnicodeStringToString(&usParamString, &usTempString);

    ntStatus = OpenRegKey(&hRegKey, &usParamString);

    ExFreePool(pwcBuffer);

    if(NT_SUCCESS(ntStatus))
    {
        dwCheck = 0;
        ntStatus = GetRegDWORDValue(
                           hRegKey,
                           L"FragmentLifetime",
                           &dwCheck);

        if(NT_SUCCESS(ntStatus))
        {
            if(dwCheck > INACTIVITY_PERIOD)
            {
                g_llInactivityTime = SECS_TO_TICKS(dwCheck);
            }
        }

        dwCheck = 0;
        ntStatus = GetRegDWORDValue(hRegKey,
                                    L"FragmentCacheSize",
                                    &dwCheck);

        if(NT_SUCCESS(ntStatus))
        {
            if(dwCheck > 127)
            {
                g_dwFragTableSize = dwCheck;
            }
        }

        ZwClose(hRegKey);
    }

    TRACE(FRAG,(
        "Filter:LifeTime %d.%d Cache Size %d\n",
        ((PLARGE_INTEGER)&g_llInactivityTime)->HighPart,
        ((PLARGE_INTEGER)&g_llInactivityTime)->LowPart,
        g_dwFragTableSize
        ));

    KeInitializeSpinLock(&g_kslFragLock);
    return(STATUS_SUCCESS);
}

VOID
PFReadRegistryParameters(PUNICODE_STRING RegistryPath)
/*++
  Routine Description:
    Called when the driver is loaded. Reads registry paramters
    for configuring the driver
--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE PFHandle;
    HANDLE PFParHandle;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ULONG Storage[8];
    PKEY_VALUE_PARTIAL_INFORMATION Value =
               (PKEY_VALUE_PARTIAL_INFORMATION)Storage;

    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,               // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey (&PFHandle, KEY_READ, &ObjectAttributes);

    RtlInitUnicodeString(&UnicodeString, L"Parameters");

    if(NT_SUCCESS(Status))
    {

        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            PFHandle,
            NULL
            );


        Status = ZwOpenKey (&PFParHandle, KEY_READ, &ObjectAttributes);

        ZwClose(PFHandle);

        if(NT_SUCCESS(Status))
        {
            ULONG BytesRead;

            RtlInitUnicodeString(&UnicodeString, L"AddressHashSize");

            Status = ZwQueryValueKey(
                            PFParHandle,
                            &UnicodeString,
                            KeyValuePartialInformation,
                            Value,
                            sizeof(Storage),
                            &BytesRead);

            if(NT_SUCCESS(Status)
                   &&
               (Value->Type == REG_DWORD) )
            {
                AddrModulus = *(PULONG)Value->Data;
            }

            RtlInitUnicodeString(&UnicodeString, L"FragmentThreshold");

            Status = ZwQueryValueKey(
                            PFParHandle,
                            &UnicodeString,
                            KeyValuePartialInformation,
                            Value,
                            sizeof(Storage),
                            &BytesRead);

            if(NT_SUCCESS(Status)
                   &&
               (Value->Type == REG_DWORD) )
            {
                g_FragThresholdSize = *(PULONG)Value->Data;
            }

            ZwClose(PFParHandle);
        }
    }
}


#pragma alloc_text(PAGE, GetRegDWORDValue)

NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    )
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR                       keybuf[128];
    UNICODE_STRING              UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));


    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             128,
                             &resultLength);

    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_DWORD) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((ULONG UNALIGNED *)((PCHAR)keyValueFullInformation +
                             keyValueFullInformation->DataOffset));
        }
    }

    return status;
}

#pragma alloc_text(PAGE, OpenRegKey)

NTSTATUS
OpenRegKey(
    PHANDLE             phRegHandle,
    PUNICODE_STRING     pusKeyName
    )
{
    NTSTATUS           Status;
    OBJECT_ATTRIBUTES ObjectAttributes;

    PAGED_CODE();

    RtlZeroMemory(&ObjectAttributes,
                  sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(&ObjectAttributes,
                               pusKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(phRegHandle,
                       KEY_READ,
                       &ObjectAttributes);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\cache.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    cache.h

Abstract:

    This module contains declarations for a simple cache system.
    Cache entries are stored as void pointers with 2 32-bit keys.

Author:

    Abolade Gbadegesin (aboladeg)   19-Feb-1998

Revision History:

    rajeshd : 17-Sep-1999 : Modified the cache parameters.

Notes:

    This code is copied from the NAT's implementation  of cache and modified to accept
    two cache keys.


--*/

#ifndef _CACHE_H_
#define _CACHE_H_

#define CACHE_SHIFT     0
#define CACHE_SIZE      (1 << (8 - CACHE_SHIFT))
//#define CACHE_INDEX(k1,k2)  (((unsigned char)(k1) & (0xF)) | (((unsigned char)(k2) & (0xF)) << 4))
#define CACHE_INDEX(k1,k2)  \
    (unsigned char)(( ((DWORD)(k1)&0xff) + (((k1)>>8)&0xff) + ((k2)&0xff) + \
    (((k2)>>8)&0xff) + (((k2)>>16)&0xff) + (((k2)>>24)&0xff)) & 0xff) 

typedef struct _CACHE_ENTRY {
    unsigned long Key1;
    unsigned long Key2;
    void* Value;
    long Hits;
    long Misses;
} CACHE_ENTRY, *PCACHE_ENTRY;


__inline
void
InitializeCache(
    CACHE_ENTRY Cache[]
    )
{
    memset(Cache, 0, CACHE_SIZE * sizeof(CACHE_ENTRY));
    TRACE2("ipfltdrv: CacheSize=%d, CacheEntry=%d\n", CACHE_SIZE, sizeof(CACHE_ENTRY));
}

__inline
void
CleanCache(
    CACHE_ENTRY Cache[],
    unsigned long Key1,
    unsigned long Key2
    )
{
    long Index = CACHE_INDEX(Key1, Key2);
    TRACE3("ipfltdrv: Clearing Cache at Index=%d, Key1=%d, Key2=%d\n", Index, Key1, Key2);
    Cache[Index].Key1 = 0;
    Cache[Index].Key2 = 0;
    Cache[Index].Value = 0;
    Cache[Index].Hits = 0;
    Cache[Index].Misses = 0;
}


__inline
void*
ProbeCache(
    CACHE_ENTRY Cache[],
    unsigned long Key1,
    unsigned long Key2
    )
{
    long Index = CACHE_INDEX(Key1, Key2);
    //TRACE3("ipfltdrv: Probing Cache at Index=%d, Key1=%d, Key2=%d\n", Index, Key1, Key2);
    if ((Key1 == Cache[Index].Key1) && (Key2 == Cache[Index].Key2)) {
        Cache[Index].Hits++;
        //TRACE1("ipfltdrv: Probing Cache, Found Value=%8x\n", Cache[Index].Value);
        return Cache[Index].Value;
    }
    Cache[Index].Misses++;
    return NULL;
}

__inline
int
UpdateCache(
    CACHE_ENTRY Cache[],
    unsigned long Key1,
    unsigned long Key2,
    void* Value
    )
{
    long Index = CACHE_INDEX(Key1, Key2);
    TRACE3("ipfltdrv: Updating Cache at Index=%d, Key1=%d, Key2=%d\n", Index, Key1, Key2);
    if (((Key1 == Cache[Index].Key1) && (Key2 == Cache[Index].Key2)) ||
        Cache[Index].Hits >=
            (Cache[Index].Misses - (Cache[Index].Misses >> 2))) { return 0; }
    Cache[Index].Key1 = Key1;
    Cache[Index].Key2 = Key2;
    Cache[Index].Value = Value;
    Cache[Index].Hits = 0;
    Cache[Index].Misses = 0;
    return 1;
}


__inline
void
InterlockedCleanCache(
    CACHE_ENTRY Cache[],
    unsigned long Key1,
    unsigned long Key2
    )
{
    long Index = CACHE_INDEX(Key1, Key2);
    TRACE3("ipfltdrv: ILocked Clearing Cache at Index=%d, Key1=%d, Key2=%d\n", Index, Key1, Key2);
    InterlockedExchange(&Cache[Index].Key1, 0);
    InterlockedExchange(&Cache[Index].Key2, 0);
    InterlockedExchangePointer(&Cache[Index].Value, 0);
    InterlockedExchange(&Cache[Index].Hits, 0);
    InterlockedExchange(&Cache[Index].Misses, 0);
}


__inline
void*
InterlockedProbeCache(
    CACHE_ENTRY Cache[],
    unsigned long Key1,
    unsigned long Key2
    )
{
    long Index = CACHE_INDEX(Key1, Key2);
    //TRACE3("ipfltdrv: ILocked Probing Cache at Index=%d, Key1=%d, Key2=%d\n", Index, Key1, Key2);
    if ((Key1 == Cache[Index].Key1) && (Key2 == Cache[Index].Key2)) {
        InterlockedIncrement(&Cache[Index].Hits);
        //TRACE1("ipfltdrv: ILocked Probing Cache, Found Value=%8x\n", Cache[Index].Value);
        return Cache[Index].Value;
    }
    InterlockedIncrement(&Cache[Index].Misses);
    return NULL;
}

__inline
int
InterlockedUpdateCache(
    CACHE_ENTRY Cache[],
    unsigned long Key1,
    unsigned long Key2,
    void* Value
    )
{
    long Index = CACHE_INDEX(Key1, Key2);
    TRACE4("ipfltdrv: ILocked Updating Cache at Index=%d, Key1=%d, Key2=%d, Value=%08x\n", Index, Key1, Key2, Value);
    if (((Key1 == Cache[Index].Key1) && (Key2 == Cache[Index].Key2)) ||
        Cache[Index].Hits >=
            (Cache[Index].Misses - (Cache[Index].Misses >> 2))) { return 0; }
    InterlockedExchange(&Cache[Index].Key1, Key1);
    InterlockedExchange(&Cache[Index].Key2, Key2);
    InterlockedExchangePointer(&Cache[Index].Value, Value);
    InterlockedExchange(&Cache[Index].Hits, 0);
    InterlockedExchange(&Cache[Index].Misses, 0);
    return 1;
}

#endif // _CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\dvmrp\work.h ===
//=============================================================================
// Copyright (c) 1998 Microsoft Corporation
// File Name: work.h
// Abstract:
//
// Author: K.S.Lokesh (lokeshs@)   1-1-98
//=============================================================================


LONGLONG
GetCurrentDvmrpTime(
    );

DWORD
RegisterDvmrpWithMgm(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\filter.h ===
/*++ 

Copyright (c) Microsoft Corporation

Module Name:

    filter.h

Abstract:


Author:



Revision History:

--*/

#ifndef __FILTER__
#define __FILTER__


//
// The smallest fragment offset, other than 0, allowable. This is
// large enough to protect the IP, UDP and TCP headers. 
//

#define MINIMUM_FRAGMENT_OFFSET   2

//
// isolate the protocol from the flags. It is in the low byte of the
// ULONG. The next byte contains the "connection established" flag.
//
#define PROTOCOLPART(x) (LOBYTE(x))

#define HANDLE_HASH_SIZE        127

typedef enum _FragLists
{
    FRAG_ICMP=0,
    FRAG_UDP,
    FRAG_TCP,
    FRAG_OTHER,
    FRAG_NUMBEROFENTRIES
} FRAGLISTS, *PFRAGLISTS;


//
// taken from oscfg.h 
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#else
#define net_short(x) ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))
#endif

struct _FILTER_INTERFACE;

#define ClearInCacheEntry(pInCache) {            \
    (pInCache)->lCount = 0;                      \
    (pInCache)->uliSrcDstAddr.LowPart = 0;       \
    (pInCache)->uliSrcDstAddr.HighPart = 0;      \
    (pInCache)->uliProtoSrcDstPort.LowPart = 0;  \
    (pInCache)->uliProtoSrcDstPort.HighPart = 0; \
    (pInCache)->pInContext = NULL;               \
    (pInCache)->pOutContext= NULL;               \
    (pInCache)->pInFilter  = NULL;               \
    (pInCache)->pOutFilter = NULL;               \
    InitializeListHead(&(pInCache)->leFreeLink); \
  }

#define ClearOutCacheEntry(pOutCache) {           \
    (pOutCache)->lCount = 0;                      \
    (pOutCache)->uliSrcDstAddr.LowPart = 0;       \
    (pOutCache)->uliSrcDstAddr.HighPart = 0;      \
    (pOutCache)->uliProtoSrcDstPort.LowPart = 0;  \
    (pOutCache)->uliProtoSrcDstPort.HighPart = 0; \
    (pOutCache)->pOutContext= NULL;               \
    (pOutCache)->pOutFilter = NULL;               \
    InitializeListHead(&(pOutCache)->leFreeLink); \
  }

#define ClearInFreeEntry(pInCache) {             \
    (pInCache)->lCount = 0;                      \
    (pInCache)->uliSrcDstAddr.LowPart = 0;       \
    (pInCache)->uliSrcDstAddr.HighPart = 0;      \
    (pInCache)->uliProtoSrcDstPort.LowPart = 0;  \
    (pInCache)->uliProtoSrcDstPort.HighPart = 0; \
    (pInCache)->pInContext = NULL;               \
    (pInCache)->pOutContext= NULL;               \
    (pInCache)->pInFilter  = NULL;               \
    (pInCache)->pOutFilter = NULL;               \
  }

#define ClearOutFreeEntry(pOutCache) {            \
    (pOutCache)->lCount = 0;                      \
    (pOutCache)->uliSrcDstAddr.LowPart = 0;       \
    (pOutCache)->uliSrcDstAddr.HighPart = 0;      \
    (pOutCache)->uliProtoSrcDstPort.LowPart = 0;  \
    (pOutCache)->uliProtoSrcDstPort.HighPart = 0; \
    (pOutCache)->pOutContext= NULL;               \
    (pOutCache)->pOutFilter = NULL;               \
  }

#define INADDR_SPECIFIC 0xffffffff

#include <packon.h>
//* Structure of a TCP packet header.

typedef struct TCPHeader {
    USHORT              tcp_src;            // Source port.
    USHORT              tcp_dest;           // Destination port.
    INT                 tcp_seq;            // Sequence number.
    INT                 tcp_ack;            // Ack number.
    USHORT              tcp_flags;          // Flags and data offset.
    USHORT              tcp_window;         // Window offered.
    USHORT              tcp_xsum;           // Checksum.
    USHORT              tcp_urgent;         // Urgent pointer.
} TCPHeader, *PTCPHeader;
#include <packoff.h>

//* Definitions for header flags.
#define TCP_FLAG_FIN    0x00000100
#define TCP_FLAG_SYN    0x00000200
#define TCP_FLAG_RST    0x00000400
#define TCP_FLAG_PUSH   0x00000800
#define TCP_FLAG_ACK    0x00001000
#define TCP_FLAG_URG    0x00002000

//
// Pictorially TCP_FLAGS are
//
// 0                 15 16
// |----|----|----|----|----|----|----|----|
// |            UA|PRSF|                   |
//
// For an established connection, either ack or rst is good
//

#define TCP_RESET_FLAG_POS      10
#define TCP_ACK_FLAG_POS        12

#define ESTAB_FLAGS     0x1
#define ESTAB_MASK      0x1


typedef struct _CountThreshold
{
    LONG     lCount;
    LONG     lInUse;
} COUNTTHRESHOLD, *PCOUNTTHRESHOLD;

#define MAX_FREE_PAGED_FILTERS   40

typedef struct _FreeFilter
{
    struct _FreeFilter *pNext;
} FREEFILTER, *PFREEFILTER;

//
// track interfaces defined on the handle. This is
// always in paged pool.
//
typedef struct _PfFcb
{
    LIST_ENTRY  leInterfaces;
    LIST_ENTRY  leLogs;
    LIST_ENTRY  leList;          // global FCB list
    DWORD       dwFlags;
    LONG        UseCount;
    ERESOURCE   Resource;
} PFFCB , *PPFFCB;

#define PF_FCB_OLD               0x1
#define PF_FCB_NEW               0x2
#define PF_FCB_CLOSED            0x4

typedef struct _FILTER
{
    LIST_ENTRY      pleFilters;
    LIST_ENTRY      pleHashList;
#if DOFRAGCHECKING
    LIST_ENTRY      leFragList;
#endif
    ULARGE_INTEGER  uliSrcDstAddr;
    ULARGE_INTEGER  uliSrcDstMask;
    ULARGE_INTEGER  uliProtoSrcDstPort;
    ULARGE_INTEGER  uliProtoSrcDstMask;
    WORD            wSrcPortHigh;
    WORD            wDstPortHigh;
    DWORD           fLateBound;
    DWORD           dwFlags;
    DWORD           dwFilterRule;
    DWORD           dwEpoch;
    COUNTTHRESHOLD  Count;
}FILTER, *PFILTER;

//
// flags for above
//

#define FILTER_FLAGS_INFILTER   0x80000000
#define FILTER_FLAGS_OLDFILTER  0x40000000
#define FILTER_FLAGS_SRCWILD    0x20000000
#define FILTER_FLAGS_DSTWILD    0x10000000
#define FILTER_FLAGS_PORTWILD   0x08000000
#define FILTER_FLAGS_NOSYN      0x1
#define FILTER_FLAGS_LOGALL     0x2

typedef struct _PagedFILTER
{
    struct _PagedFILTER * pFilters;
    LIST_ENTRY      leSpecialList;
    PFETYPE         type;
    PFILTER         pMatchFilter;
    ULARGE_INTEGER  uliSrcDstAddr;
    ULARGE_INTEGER  uliSrcDstMask;
    ULARGE_INTEGER  uliProtoSrcDstPort;
    ULARGE_INTEGER  uliProtoSrcDstMask;
    WORD            wSrcPortHigh;
    WORD            wDstPortHigh;
    DWORD           fLateBound;
    DWORD           dwFlags;
    DWORD           dwHashIndex;
    DWORD           dwInUse;
    DWORD           dwEpoch;
    LIST_ENTRY      leHandleHash;
    LIST_ENTRY      leHash;
}PAGED_FILTER, *PPAGED_FILTER;


//
// Two filter interface definitions. The first is the definition for the
// non-paged filter that is used by the matching engine. This is not
// associated with a handle except by refcount
// The second is per handle and is linked off of the FCB for that handle
//
typedef struct _FILTER_INTERFACE
{
    LIST_ENTRY        leIfLink;
    DWORD             dwNumInFilters;
    DWORD             dwNumOutFilters;
    LIST_ENTRY        pleInFilterSet;
    LIST_ENTRY        pleOutFilterSet;
    LARGE_INTEGER     liSYNCount;
    LARGE_INTEGER     liLoggedFrames;
    FORWARD_ACTION    eaInAction;
    FORWARD_ACTION    eaOutAction;
    DWORD             dwUpdateEpoch;
    DWORD             dwBindEpoch;
    PVOID             pvHandleContext;
    PVOID             pvRtrMgrContext;
    DWORD             dwRtrMgrIndex;
    DWORD             dwGlobalEnables;
    DWORD             dwIpIndex;
    DWORD             dwLinkIpAddress;
    DWORD             dwName;
    LONG              lInUse;               // use count
    LONG              lTotalInDrops;
    LONG              lTotalOutDrops;
    DWORD             dwDropThreshold;
    LONG              lEpoch;
    DWORD             dwLostFrames;
    LONG              lNotify;
    COUNTTHRESHOLD    CountSpoof;
    COUNTTHRESHOLD    CountSynOrFrag;
    COUNTTHRESHOLD    CountUnused;
    COUNTTHRESHOLD    CountCtl;
    COUNTTHRESHOLD    CountFullDeny;
    COUNTTHRESHOLD    CountNoFrag;
    COUNTTHRESHOLD    CountStrongHost;
    COUNTTHRESHOLD    CountFragCache;
#if WILDHASH
    DWORD             dwWilds;
#endif
    PPFLOGINTERFACE   pLog;
    LIST_ENTRY        FragLists[FRAG_NUMBEROFENTRIES];
    LIST_ENTRY        HashList[1];
}FILTER_INTERFACE, *PFILTER_INTERFACE;

//
// global enable flags
//

#define FI_ENABLE_OLD      0x1
#define FI_ENABLE_UNIQUE   0x2

typedef struct _PAGED_FILTER_INTERFACE
{
    LIST_ENTRY      leIfLink;
    DWORD           dwNumInFilters;
    DWORD           dwNumOutFilters;
    LIST_ENTRY      leSpecialFilterList;
    FORWARD_ACTION  eaInAction;
    FORWARD_ACTION  eaOutAction;
    PVOID           pvRtrMgrContext;
    DWORD           dwRtrMgrIndex;
    DWORD           dwGlobalEnables;
    PVOID           pvDriverContext;
    DWORD           dwUpdateEpoch;
    PFILTER_INTERFACE pFilter;
    PPFLOGINTERFACE  pLog;
    LIST_ENTRY      HashList[1];
}PAGED_FILTER_INTERFACE, *PPAGED_FILTER_INTERFACE;


typedef struct _FILTER_INCACHE
{
    LIST_ENTRY        leFreeLink;
    LONG              lCount;
    ULARGE_INTEGER    uliSrcDstAddr;
    ULARGE_INTEGER    uliProtoSrcDstPort;
    PFILTER_INTERFACE pInContext;
    FORWARD_ACTION    eaInAction;
    PFILTER_INTERFACE pOutContext;
    FORWARD_ACTION    eaOutAction;
    LONG              lOutEpoch;
    PFILTER           pInFilter;
    PFILTER           pOutFilter;
}FILTER_INCACHE, *PFILTER_INCACHE;

typedef struct _FILTER_OUTCACHE
{
    LIST_ENTRY        leFreeLink;
    INT               lCount;
    ULARGE_INTEGER    uliSrcDstAddr;
    ULARGE_INTEGER    uliProtoSrcDstPort;
    FORWARD_ACTION    eaOutAction;
    PFILTER_INTERFACE pOutContext;
    PFILTER           pOutFilter;
}FILTER_OUTCACHE, *PFILTER_OUTCACHE;

typedef struct _FRAG_INFO
{
    LIST_ENTRY          leCacheLink;
    ULARGE_INTEGER      uliSrcDstAddr;
    LONGLONG            llLastAccess;
    DWORD               dwId;
    PVOID               pvInContext;
    PVOID               pvOutContext;
    FORWARD_ACTION      faAction;
}FRAG_INFO, *PFRAG_INFO;

typedef struct _FILTER_DRIVER
{
    LIST_ENTRY        leIfListHead;
    MRSW_LOCK         ifListLock;
    CACHE_ENTRY       *pInterfaceCache;
    PFILTER_INCACHE   *ppInCache;
    PFILTER_OUTCACHE  *ppOutCache;
}FILTER_DRIVER, *PFILTER_DRIVER;

typedef struct _EXTENSION_DRIVER
{
    MRSW_LOCK                   ExtLock;
    PacketFilterExtensionPtr    ExtPointer;
    PFILE_OBJECT                ExtFileObject;
}EXTENSION_DRIVER, *PEXTENSION_DRIVER;
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\filtest.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:


Abstract:

Revision History:

    Amritansh Raghav

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntioapi.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <ntosp.h>
#include <ndis.h>
#include <windef.h>
//#include <ntddk.h>
#include <ipexport.h>
#include "defs.h"
#include <cxport.h>
#include <ip.h>
#include "ipfltdrv.h"
//#include "filter.h"


#include <winsock.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <tcpinfo.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include <ntddip.h>

#define is ==
#define isnot !=
#define and &&
#define or ||


DWORD InitializeFilter();
VOID DoAddInterface();
VOID DoSetFilters();
VOID DoFilterPacket();
VOID DoGetInfo();
VOID DoDeleteInterface();
VOID DoStopFilter();
VOID DoAddRoute();
VOID DoAddForwarderIf();
DWORD GetIpStatsFromStack(IPSNMPInfo *IPSnmpInfo);
DWORD GetIpAddrTableFromStack(IPAddrEntry *lpipaeTable, LPDWORD lpdwNumEntries);
VOID CloseHandles();

typedef struct _USER_IF
{
    LIST_ENTRY ifLink;
    PVOID   pvIfContext;
    CHAR    pszName[80];
}USER_IF, *PUSER_IF;

LIST_ENTRY g_ifList;
HANDLE g_FilterDriverHandle;
HANDLE g_IpDriverHandle;
HANDLE g_TcpDriverHandle;

INT _cdecl main()
{
    NTSTATUS ntStatus;
    WORD wVersion = MAKEWORD(1,1);
    WSADATA wsaData;

    if(WSAStartup(wVersion,&wsaData) isnot NO_ERROR)
    {
        printf("WSAStartup failed\n");
        return(1);
    }

    ntStatus = InitializeFilter();

    if(ntStatus isnot STATUS_SUCCESS)
    {
        printf("Couldnt init filter - error %x\n",ntStatus);

        exit(1);
    }

    InitializeListHead(&g_ifList);

    while(TRUE)
    {
        CHAR cInput[10];

        printf("\n----- USER MODE IP FILTER DRIVER TEST -----\n");
        printf("1.\tAdd Interface\n");
        printf("2.\tSet Filters\n");
        printf("3.\tFilter Packet\n");
        printf("4.\tGet Info\n");
        printf("5.\tDelete Interface\n");
        printf("6.\tStop Filter\n");
        printf("7.\tAdd Route to Forwarder\n");
        printf("8.\tAdd Interface to Forwarder\n");
        printf("99.\tQuit\n");

        printf("Selection:\t");
        gets(cInput);
        printf("\n");
        switch(atoi(cInput))
        {
            case 1:
            {
                DoAddInterface();
                break;
            }
            case 2:
            {
                DoSetFilters();
                break;
            }
            case 3:
            {
                DoFilterPacket();
                break;
            }
            case 4:
            {
                DoGetInfo();
                break;
            }
            case 5:
            {
                DoDeleteInterface();
                break;
            }
            case 6:
            {
                DoStopFilter();
                break;
            }
            case 7:
            {
                DoAddRoute();
                break;
            }
            case 8:
            {
                DoAddForwarderIf();
                break;
            }
            case 99:
            {
                DoStopFilter();
                WSACleanup();
                return(0);
            }
            default:
            {
                continue;
            }
        }
    }
    return(0);
}


VOID
DoAddInterface()
{
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    IoStatusBlock;
    CHAR cName[70];
    FILTER_DRIVER_CREATE_INTERFACE inBuffer;
    DWORD dwInBufLen = sizeof(FILTER_DRIVER_CREATE_INTERFACE);
    PUSER_IF pIf;

    if((pIf = HeapAlloc(GetProcessHeap(),0,sizeof(USER_IF))) is NULL)
    {
        printf("Couldnt allocate memory\n");
    }

    printf("Enter new interface name: ");
    gets(pIf->pszName);
    printf("\n");

    InitializeListHead(&pIf->ifLink);

    inBuffer.dwIfIndex = 0;
    inBuffer.pvRtrMgrContext = NULL;

    ntStatus = NtDeviceIoControlFile(g_FilterDriverHandle,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_CREATE_INTERFACE,
                                     (PVOID)&inBuffer,
                                     dwInBufLen,
                                     (PVOID)&inBuffer,
                                     dwInBufLen);

    if (!NT_SUCCESS(ntStatus))
    {
        printf("IOCTL failed - status %x \n", ntStatus);
        HeapFree(GetProcessHeap(),0,pIf);
        return;
    }

    printf("Added interface, context %x\n",(UINT_PTR)inBuffer.pvDriverContext);
    pIf->pvIfContext = inBuffer.pvDriverContext;
    InsertHeadList(&g_ifList,&(pIf->ifLink));

    return;
}

VOID
DoSetFilters()
{
    NTSTATUS                    ntStatus;
    IO_STATUS_BLOCK             IoStatusBlock;
    PFILTER_INFO                pInfo;
    PFILTER_DRIVER_SET_FILTERS  pIo;
    DWORD                       i,dwNumInFilters = 0,dwNumOutFilters = 0,dwInBufLen;
    PLIST_ENTRY                 currentList;
    BYTE                        cAddr[50];
    PUSER_IF                    pIf;
    BOOL                        bSetInput,bSetOutput,bDelInput,bDelOutput;
    FORWARD_ACTION              faOutAction,faInAction;
    DWORD                       dwInIndex,dwOutIndex;

    currentList = g_ifList.Flink;

    i = 1;

    printf("\nCurrent Interfaces\n");

    while(currentList isnot &g_ifList)
    {
        pIf = CONTAINING_RECORD(currentList,USER_IF,ifLink);

        printf("\t%d. %s\n",i++,pIf->pszName);
        currentList = currentList->Flink;
    }

    printf("Input Interface index: ");
    gets(cAddr);
    printf("\n");

    currentList = g_ifList.Flink;

    i = 1;

    pIf = NULL;

    while(currentList isnot &g_ifList)
    {
        if(i is (DWORD)atoi(cAddr))
        {
            pIf = CONTAINING_RECORD(currentList,USER_IF,ifLink);
            break;
        }
        i++;
        currentList = currentList->Flink;
    }

    if(pIf is NULL)
    {
        printf("Couldnt find interface block\n");
        return;
    }

    printf("Setting filters for %s with context %#08x\n",pIf->pszName,
                                            (UINT_PTR)pIf->pvIfContext);

    dwInBufLen = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);

    printf("Do you want to modify input filters? (0/1): ");
    gets(cAddr);
    printf("\n");

    if(atoi(cAddr) is 1)
    {
        dwInBufLen += sizeof(RTR_TOC_ENTRY);

        bSetInput = TRUE;
    }
    else
    {
        bSetInput = FALSE;
    }

    printf("Do you want to modify output filters? (0/1): ");
    gets(cAddr);
    printf("\n");

    if(atoi(cAddr) is 1)
    {
        dwInBufLen += sizeof(RTR_TOC_ENTRY);

        bSetOutput = TRUE;
    }
    else
    {
        bSetOutput = FALSE;
    }

    if(bSetInput)
    {
        printf("Do you want to delete all in filters?(0/1): ");
        gets(cAddr);
        printf("\n");

        if(atoi(cAddr) is 0)
        {
            printf("How many input filters (0 will remove filters but allow a default action)?: ");
            gets(cAddr);
            printf("\n");

            dwNumInFilters = atoi(cAddr);

            printf("Default in action (0 - FORWARD, 1 - DROP): ");
            gets(cAddr);
            printf("\n");
            faInAction = (FORWARD_ACTION)atoi(cAddr);

            dwInBufLen += sizeof(FILTER_DESCRIPTOR) - sizeof(FILTER_INFO);
            bDelInput = FALSE;
        }
        else
        {
            bDelInput = TRUE;
        }
    }

    if(bSetOutput)
    {
        printf("Do you want to delete all out filters?(0/1): ");
        gets(cAddr);
        printf("\n");

        if(atoi(cAddr) is 0)
        {
            printf("How many out filters (0 will remove filters but allow a default action)?: ");
            gets(cAddr);
            printf("\n");

            dwNumInFilters = atoi(cAddr);

            printf("Default in action (0 - FORWARD, 1 - DROP): ");
            gets(cAddr);
            printf("\n");
            faOutAction = (FORWARD_ACTION)atoi(cAddr);

            dwInBufLen += sizeof(FILTER_DESCRIPTOR) - sizeof(FILTER_INFO);
            bDelOutput = FALSE;
        }
        else
        {
            bDelOutput = TRUE;
        }
    }

    if(!(bSetInput or bSetOutput) )
    {
        return;
    }

    dwInBufLen += ((dwNumInFilters + dwNumOutFilters -1) * sizeof(FILTER_INFO));

    pIo = HeapAlloc(GetProcessHeap(),0,dwInBufLen);

    if(pIo is NULL)
    {
        printf("Couldnt allocate memory\n");
        return;
    }

    pIo->pvDriverContext = (PVOID)pIf;

    dwInIndex = 0;
    dwOutIndex = 1;

    if(!bSetInput)
    {
        dwOutIndex = 0;
    }

    pIo->ribhInfoBlock.Version  = IP_FILTER_DRIVER_VERSION;
    pIo->ribhInfoBlock.Size     = dwInBufLen - FIELD_OFFSET(FILTER_DRIVER_SET_FILTERS,
                                                            ribhInfoBlock);

    pIo->ribhInfoBlock.TocEntriesCount = 0;

    if(bSetInput)
    {
        pIo->ribhInfoBlock.TocEntry[dwInIndex].InfoType = IP_FILTER_DRIVER_IN_FILTER_INFO;

        if(bDelInput)
        {
            pIo->ribhInfoBlock.TocEntry[dwInIndex].InfoSize = 0;
            pIo->ribhInfoBlock.TocEntry[dwInIndex].Offset   = 0;
            pIo->ribhInfoBlock.TocEntry[dwInIndex].Count    = 0;
        }
        else
        {
            pIo->ribhInfoBlock.TocEntry[dwInIndex].InfoSize = sizeof(FILTER_DESCRIPTOR) -
                sizeof(FILTER_INFO) + (dwNumInFilters * sizeof(FILTER_INFO));

            if(bSetOutput)
            {
                pIo->ribhInfoBlock.TocEntry[dwInIndex].Offset = (ULONG) (((PBYTE)&pIo->ribhInfoBlock.TocEntry[2] - (PBYTE)&pIo->ribhInfoBlock));
            }
            else
            {
                pIo->ribhInfoBlock.TocEntry[dwInIndex].Offset = (ULONG) (((PBYTE)&pIo->ribhInfoBlock.TocEntry[1] - (PBYTE)&pIo->ribhInfoBlock));
            }

            pIo->ribhInfoBlock.TocEntry[dwInIndex].Count    = 1;
        }
    }

    if(bSetOutput)
    {
        pIo->ribhInfoBlock.TocEntry[dwOutIndex].InfoType = IP_FILTER_DRIVER_OUT_FILTER_INFO;

        if(bDelOutput)
        {
            pIo->ribhInfoBlock.TocEntry[dwOutIndex].InfoSize = 0;
            pIo->ribhInfoBlock.TocEntry[dwOutIndex].Offset   = 0;
            pIo->ribhInfoBlock.TocEntry[dwOutIndex].Count    = 0;
        }
        else
        {
            pIo->ribhInfoBlock.TocEntry[dwOutIndex].InfoSize = sizeof(FILTER_DESCRIPTOR) -
                sizeof(FILTER_INFO) + (dwNumOutFilters * sizeof(FILTER_INFO));


            if(bSetInput)
            {
                pIo->ribhInfoBlock.TocEntry[dwOutIndex].Offset = (ULONG) (((PBYTE)&pIo->ribhInfoBlock.TocEntry[2] + pIo->ribhInfoBlock.TocEntry[1].InfoSize - (PBYTE)&pIo->ribhInfoBlock));
            }
            else
            {
                pIo->ribhInfoBlock.TocEntry[dwOutIndex].Offset = (ULONG) (((PBYTE)&pIo->ribhInfoBlock.TocEntry[1] - (PBYTE)&pIo->ribhInfoBlock));
            }

            pIo->ribhInfoBlock.TocEntry[dwOutIndex].Count    = 1;
        }
    }


    if(bSetInput and !bDelInput)
    {
        pInfo = ((PFILTER_DESCRIPTOR)((PBYTE)&pIo->ribhInfoBlock + pIo->ribhInfoBlock.TocEntry[dwInIndex].Offset))->fiFilter;

        ((PFILTER_DESCRIPTOR)((PBYTE)&pIo->ribhInfoBlock + pIo->ribhInfoBlock.TocEntry[dwInIndex].Offset))->dwVersion = IP_FILTER_DRIVER_VERSION;
        ((PFILTER_DESCRIPTOR)((PBYTE)&pIo->ribhInfoBlock + pIo->ribhInfoBlock.TocEntry[dwInIndex].Offset))->dwNumFilters = dwNumInFilters;
        ((PFILTER_DESCRIPTOR)((PBYTE)&pIo->ribhInfoBlock + pIo->ribhInfoBlock.TocEntry[dwInIndex].Offset))->faDefaultAction = faInAction;


        printf("Input Filters - addresses and mask in dotted decimal\n");

        for(i = 0; i < dwNumInFilters; i++)
        {
            printf("Enter source addr: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwSrcAddr = inet_addr(cAddr);

            printf("Enter source mask: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwSrcMask = inet_addr(cAddr);

            printf("Enter dest addr: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwDstAddr = inet_addr(cAddr);

            printf("Enter dest mask: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwDstMask = inet_addr(cAddr);

            printf("Enter protocol id - 0 for any: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwProtocol = atoi(cAddr);

            pInfo[i].wSrcPort = pInfo[i].wDstPort = 0x00000000;

            switch(pInfo[i].dwProtocol)
            {
                case 1:
                {
                    printf("Enter type - 255 for any");
                    gets(cAddr);
                    printf("\n");
                    pInfo[i].wSrcPort = (BYTE)atoi(cAddr);

                    printf("Enter code - 255 for any");
                    gets(cAddr);
                    printf("\n");
                    pInfo[i].wDstPort = (BYTE)atoi(cAddr);

                    break;
                }
                case 6:
                case 17:
                {
                    printf("Enter source port - 0 for any: ");
                    gets(cAddr);
                    printf("\n");
                    pInfo[i].wSrcPort = htons((WORD)atoi(cAddr));

                    printf("Enter Dst Port - 0 for any: ");
                    gets(cAddr);
                    printf("\n");
                    pInfo[i].wDstPort = htons((WORD)atoi(cAddr));
                    break;
                }
            }
        }
    }


    if(bSetOutput and !bDelOutput)
    {
        pInfo = ((PFILTER_DESCRIPTOR)((PBYTE)&pIo->ribhInfoBlock + pIo->ribhInfoBlock.TocEntry[dwOutIndex].Offset))->fiFilter;

        ((PFILTER_DESCRIPTOR)((PBYTE)&pIo->ribhInfoBlock + pIo->ribhInfoBlock.TocEntry[dwOutIndex].Offset))->dwVersion = IP_FILTER_DRIVER_VERSION;
        ((PFILTER_DESCRIPTOR)((PBYTE)&pIo->ribhInfoBlock + pIo->ribhInfoBlock.TocEntry[dwOutIndex].Offset))->dwNumFilters = dwNumOutFilters;
        ((PFILTER_DESCRIPTOR)((PBYTE)&pIo->ribhInfoBlock + pIo->ribhInfoBlock.TocEntry[dwOutIndex].Offset))->faDefaultAction = faOutAction;

        printf("Output Filters - addresses and mask in dotted decimal\n");

        for(i = 0; i < dwNumOutFilters; i++)
        {
            printf("Enter source addr: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwSrcAddr = inet_addr(cAddr);

            printf("Enter source mask: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwSrcMask = inet_addr(cAddr);

            printf("Enter dest addr: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwDstAddr = inet_addr(cAddr);

            printf("Enter dest mask: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwDstMask = inet_addr(cAddr);

            printf("Enter protocol id - 0 for any: ");
            gets(cAddr);
            printf("\n");
            pInfo[i].dwProtocol = atoi(cAddr);

            pInfo[i].wSrcPort = pInfo[i].wDstPort = 0x00000000;

            switch(pInfo[i].dwProtocol)
            {
                case 1:
                {
                    printf("Enter type - 255 for any");
                    gets(cAddr);
                    printf("\n");
                    pInfo[i].wSrcPort = (BYTE)atoi(cAddr);

                    printf("Enter code - 255 for any");
                    gets(cAddr);
                    printf("\n");
                    pInfo[i].wDstPort = (BYTE)atoi(cAddr);

                    break;
                }
                case 6:
                case 17:
                {
                    printf("Enter source port - 0 for any: ");
                    gets(cAddr);
                    printf("\n");
                    pInfo[i].wSrcPort = htons((WORD)atoi(cAddr));

                    printf("Enter Dst Port - 0 for any: ");
                    gets(cAddr);
                    printf("\n");
                    pInfo[i].wDstPort = htons((WORD)atoi(cAddr));
                }
            }
        }
    }


    ntStatus = NtDeviceIoControlFile(g_FilterDriverHandle,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_SET_INTERFACE_FILTERS,
                                     (PVOID)pIo,
                                     dwInBufLen,
                                     NULL,
                                     0);

    if (!NT_SUCCESS(ntStatus))
    {
        printf("IOCTL failed - status %x \n", ntStatus);
    }

    printf("Filters set\n");
    HeapFree(GetProcessHeap(),0,pIo);
    return;

}


VOID
DoFilterPacket()
{
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    IoStatusBlock;
    DWORD i,dwInBufLen;
    BYTE  cAddr[40];
    PFILTER_DRIVER_TEST_PACKET pTest;
    IPHeader *pIph;
    PWORD pwPort;
    PLIST_ENTRY currentList;
    PUSER_IF pInIf = NULL, pOutIf = NULL, pIf;

    dwInBufLen = sizeof(FILTER_DRIVER_TEST_PACKET) + sizeof(IPHeader) + 2*sizeof(DWORD);

    pTest = HeapAlloc(GetProcessHeap(),0,dwInBufLen);

    if(pTest is NULL)
    {
        printf("Couldnt allocate memory for the packet\n");
        return;
    }

    pIph = (IPHeader*)(pTest->bIpPacket);

    pwPort = (PWORD)((PBYTE)pIph + sizeof(IPHeader));

    currentList = g_ifList.Flink;
    i=1;

    printf("\nCurrent Interfaces\n");
    while(currentList isnot &g_ifList)
    {
        pIf = CONTAINING_RECORD(currentList,USER_IF,ifLink);

        printf("\t%d. %s\n",i++,pIf->pszName);
        currentList = currentList->Flink;
    }

    printf("Index of input Interface <enter for none>: ");
    gets(cAddr);
    printf("\n");

    if(strlen(cAddr) isnot 0)
    {
        DWORD dwInIf = atoi(cAddr);

        currentList = g_ifList.Flink;

        i = 1;

        while(currentList isnot &g_ifList)
        {
            if(i is dwInIf)
            {
                pInIf = CONTAINING_RECORD(currentList,USER_IF,ifLink);
                break;
            }
            i++;
            currentList = currentList->Flink;
        }

    }

    printf("Index of output Interface <enter for none>: ");
    gets(cAddr);
    printf("\n");

    if(strlen(cAddr) isnot 0)
    {
        DWORD dwOutIf = atoi(cAddr);

        currentList = g_ifList.Flink;

        i = 1;

        while(currentList isnot &g_ifList)
        {
            if(i is dwOutIf)
            {
                pOutIf = CONTAINING_RECORD(currentList,USER_IF,ifLink);
                break;
            }
            i++;
            currentList = currentList->Flink;
        }
    }

    printf("Input if is %s and output if is %s\n",
           (pInIf is NULL)? "NULL":pInIf->pszName,
           (pOutIf is NULL)?"NULL":pOutIf->pszName);

    pTest->pvInInterfaceContext = (pInIf is NULL)?NULL:pInIf->pvIfContext;
    pTest->pvOutInterfaceContext = (pOutIf is NULL)?NULL:pOutIf->pvIfContext;
    printf("Enter packet header\n\n");

    printf("Enter source addr: ");
    gets(cAddr);
    printf("\n");
    pIph->iph_src = (IPAddr)inet_addr(cAddr);

    printf("Enter dest addr: ");
    gets(cAddr);
    printf("\n");
    pIph->iph_dest = (IPAddr)inet_addr(cAddr);

    printf("Enter Protocol id - 0 for any: ");
    gets(cAddr);
    printf("\n");
    pIph->iph_protocol = (UCHAR)LOBYTE(atoi(cAddr));

    printf("Is this a fragment? (1 - yes 0 - no): ");
    gets(cAddr);
    printf("\n");
    if(atoi(cAddr) is 0)
    {
        printf("Enter source port - 0 for any: ");
        gets(cAddr);
        printf("\n");
        pwPort[0] = htons((WORD)atoi(cAddr));

        printf("Enter Dst Port - 0 for any: ");
        gets(cAddr);
        printf("\n");
        pwPort[1] = htons((WORD)atoi(cAddr));

        pIph->iph_offset = 0x0000; // no flags , no fragment
    }
    else
    {
        // Lets give it a frag offset of 100 - 64h
        pIph->iph_offset = 0x6400;
    }

    //
    // Fill up the rest of the packet with some meaningful info
    //

    pIph->iph_verlen = '\x45'; //Version = 4 Hdr Len = 5*4bytes
    pIph->iph_tos    = '\x0f'; //TOS signature for mem dumps
    pIph->iph_length = htons((WORD)(sizeof(IPHeader)+2*sizeof(DWORD))); //Length in bytes
    pIph->iph_id = 0xcdab; //ID another signature
    pIph->iph_ttl = 0xef; // TTL
    pIph->iph_xsum = 0xcdab; //Checksum;


    ntStatus = NtDeviceIoControlFile(g_FilterDriverHandle,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_TEST_PACKET,
                                     (PVOID)pTest,
                                     dwInBufLen,
                                     (PVOID)pTest,
                                     dwInBufLen);


    if (!NT_SUCCESS(ntStatus))
    {
        printf("IOCTL failed - status %x \n", ntStatus);
        return;
    }

    if(pTest->eaResult is DROP)
    {
        printf("Packet rejected\n");
    }
    else
    {
        printf("Packet accepted\n");
    }

    HeapFree(GetProcessHeap(),0,pTest);
    return;
}

VOID
DoDeleteInterface()
{
}

VOID
DoStopFilter()
{
    CloseHandles();
}

VOID
DoGetInfo()
{
}

VOID
DoAddRoute()
{
    TDIObjectID        *lpObject;
    IPRouteEntry       *lpentry;
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    IoStatusBlock;
    CHAR               szIPAddr[20];
    DWORD              dwInBufLen;

    TCP_REQUEST_SET_INFORMATION_EX *lptrsiBuffer;
    BYTE buffer[sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry)];

    lptrsiBuffer = (TCP_REQUEST_SET_INFORMATION_EX *)buffer;

    lptrsiBuffer->BufferSize = sizeof(IPRouteEntry);

    lpObject = &lptrsiBuffer->ID;
    lpObject->toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    lpentry = (IPRouteEntry *)lptrsiBuffer->Buffer;



    dwInBufLen = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry) - 1;

    printf("Enter Address (Dotted Decimal Form): ");
    gets(szIPAddr);
    printf("\n");
    lpentry->ire_dest = inet_addr(szIPAddr);

    printf("Enter IF (numerical):");
    gets(szIPAddr);
    printf("\n");
    lpentry->ire_index = atoi(szIPAddr);

    printf("Enter Next Hop (Dotted Decimal Form): ");
    gets(szIPAddr);
    printf("\n");
    lpentry->ire_nexthop = inet_addr(szIPAddr);

    printf("Enter Mask (Dotted Decimal Form): ");
    gets(szIPAddr);
    printf("\n");
    lpentry->ire_mask = inet_addr(szIPAddr);

    printf("Enter Metric 1: ");
    gets(szIPAddr);
    printf("\n");
    lpentry->ire_metric1 = atoi(szIPAddr);

    lpentry->ire_metric2 =
    lpentry->ire_metric3 =
    lpentry->ire_metric4 =
    lpentry->ire_metric5 = IRE_METRIC_UNUSED;

    lpentry->ire_age = 0;

    printf("Enter type 2 - invalid 3 - direct 4 - indirect: ");
    gets(szIPAddr);
    printf("\n");
    lpentry->ire_type = atoi(szIPAddr);

    lpentry->ire_proto = IRE_PROTO_LOCAL;

    ntStatus = NtDeviceIoControlFile(g_TcpDriverHandle,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatusBlock,
                                     IOCTL_TCP_SET_INFORMATION_EX,
                                     (PVOID)lptrsiBuffer,
                                     dwInBufLen,
                                     NULL,
                                     0);

    if(ntStatus is STATUS_PENDING)
    {
        ntStatus = NtWaitForSingleObject(g_TcpDriverHandle, FALSE, NULL );
        ntStatus = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS(ntStatus))
    {
        printf("IOCTL failed to get set route - error %x\n",ntStatus);
    }

}

VOID
DoAddForwarderIf()
{
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    IoStatusBlock;
    DWORD              dwResult;
    DWORD              dwSpace,dwId,dwIf,i;
    IPSNMPInfo	       ipsiInfo;
    IPAddrEntry        *pAddrTable;
    PLIST_ENTRY        currentList;
    PUSER_IF           pIf;
    IP_SET_IF_CONTEXT_INFO info;
    CHAR               cAddr1[20],cAddr2[20];

    dwResult = GetIpStatsFromStack(&ipsiInfo);

    if(dwResult isnot NO_ERROR)
    {
        printf("Couldnt get Ip Snmp info from stack for num addr error %x\n",dwResult);
        return;
    }

    dwSpace = ipsiInfo.ipsi_numaddr + 10;

    pAddrTable = HeapAlloc(GetProcessHeap(),0,dwSpace * sizeof(IPAddrEntry));

    if(pAddrTable is NULL)
    {
        printf("Couldnt allocate space for ipAddr table\n");
        return;
    }

    dwResult = GetIpAddrTableFromStack(pAddrTable,&dwSpace);

    if(dwResult isnot NO_ERROR)
    {
        printf("Couldnt get addr table from stack %x\n",dwResult);
        HeapFree(GetProcessHeap(),0,pAddrTable);
        return;
    }


    printf("\nForwarder Interfaces\n");
    printf("Index\tAddress\t\tMask\n");

    for(i = 0; i < dwSpace; i++)
    {
        struct in_addr addr;
        addr.s_addr = pAddrTable[i].iae_addr;
        strcpy(cAddr1,inet_ntoa(addr));
        addr.s_addr = pAddrTable[i].iae_mask;
        strcpy(cAddr2,inet_ntoa(addr));
        printf("%d.\t%s\t\t%s\n",pAddrTable[i].iae_index,cAddr1,cAddr2);
    }

    printf("\nFilter Interfaces\n");

    currentList = g_ifList.Flink;

    i = 1;

    while(currentList isnot &g_ifList)
    {
        pIf = CONTAINING_RECORD(currentList,USER_IF,ifLink);

        printf("\t%d. %s\n",i++,pIf->pszName);
        currentList = currentList->Flink;
    }

    while(TRUE)
    {
        printf("Enter Forwarder index (99 to exit): ");
        gets(cAddr1);
        printf("\n");

        dwId = atoi(cAddr1);
        if(dwId is 99)
          break;

        printf("Enter Interface Index to associate with: ");
        gets(cAddr1);
        printf("\n");
        dwIf = atoi(cAddr1);

        currentList = g_ifList.Flink;
        i   = 1;
        pIf = NULL;

        while(currentList isnot &g_ifList)
        {
            if(i is dwIf)
            {
                pIf = CONTAINING_RECORD(currentList,USER_IF,ifLink);
                break;
            }
            i++;
            currentList = currentList->Flink;
        }

        if(pIf is NULL)
        {
            printf("Couldnt find filter interface\n");
            continue;
        }

        info.Index   = dwId;
        info.Context = pIf->pvIfContext;

        ntStatus = NtDeviceIoControlFile(g_IpDriverHandle,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         IOCTL_IP_SET_IF_CONTEXT,
                                         (PVOID)&info,
                                         sizeof(IP_SET_IF_CONTEXT_INFO),
                                         NULL,
                                         0);
        if(!NT_SUCCESS(ntStatus))
        {
            printf("Couldnt set context\n");
        }
        else
        {
            printf("Set context successfully\n");
        }
    }

    HeapFree(GetProcessHeap(),0,pAddrTable);
    return;
}


DWORD
InitializeFilter()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;

    RtlInitUnicodeString(&nameString,DD_IPFLTRDRVR_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes, &nameString,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(&g_FilterDriverHandle,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0);

    if(!NT_SUCCESS(status))
    {
        printf("Couldnt create filter driver handle\n");
        return(status);
    }

    RtlInitUnicodeString(&nameString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes, &nameString,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(&g_IpDriverHandle,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0);

    if(!NT_SUCCESS(status))
    {
        printf("Couldnt create ip driver handle\n");
        return(status);
    }

    RtlInitUnicodeString(&nameString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes, &nameString,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(&g_TcpDriverHandle,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0);

    if(!NT_SUCCESS(status))
    {
        printf("Couldnt create tcp driver handle\n");
    }

    return (status);
}


//* CloseHandles()
//
// Function: Close TCPIP stack handle.
//
// Returns:  0
//*

VOID
CloseHandles ()
{
    CloseHandle(g_FilterDriverHandle);
    CloseHandle(g_IpDriverHandle);
    CloseHandle(g_TcpDriverHandle);
}

DWORD
GetIpAddrTableFromStack(IPAddrEntry *lpipaeTable, LPDWORD lpdwNumEntries)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    DWORD                              i,j;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;
    NTSTATUS                           Status;
    IO_STATUS_BLOCK                    IoStatusBlock;

    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = (*lpdwNumEntries) * sizeof( IPAddrEntry );

    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory( Context, CONTEXT_SIZE );

    Status = NtDeviceIoControlFile(g_TcpDriverHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_TCP_QUERY_INFORMATION_EX,
                                   (PVOID)&trqiInBuf,
                                   dwInBufLen,
                                   lpipaeTable,
                                   dwOutBufLen);

    if(Status is STATUS_PENDING)
    {
        Status = NtWaitForSingleObject(g_TcpDriverHandle, FALSE, NULL );
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS( Status ))
    {
        printf("IOCTL failed to get address table\n");
        *lpdwNumEntries = 0;
        return ( Status );
    }

    *lpdwNumEntries = (ULONG)(((UINT_PTR)IoStatusBlock.Information / sizeof(IPAddrEntry)));

    return (NO_ERROR);
}

DWORD
GetIpStatsFromStack(IPSNMPInfo *IPSnmpInfo)
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;
    NTSTATUS                           Status;
    IO_STATUS_BLOCK                    IoStatusBlock;

    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

    dwOutBufLen = sizeof(IPSNMPInfo);

    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class = INFO_CLASS_PROTOCOL;
    ID->toi_type = INFO_TYPE_PROVIDER;
    ID->toi_id = IP_MIB_STATS_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    ZeroMemory(Context, CONTEXT_SIZE);

    Status = NtDeviceIoControlFile(g_TcpDriverHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_TCP_QUERY_INFORMATION_EX,
                                   (PVOID)&trqiInBuf,
                                   sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                                   IPSnmpInfo,
                                   dwOutBufLen);


    if(Status is STATUS_PENDING)
    {
        Status = NtWaitForSingleObject(g_TcpDriverHandle, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS(Status))
    {
        printf("IOCTL failed to get SNMP info\n");
        return (Status);
    }

    return (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\logger.h ===
/*++ 

Copyright (c) Microsoft Corporation

Module Name:

    logger.h

Abstract:


Author:



Revision History:

--*/

#ifndef __LOGGER_H__
#define __LOGGER_H__

#define MAX_NOMINAL_LOG_MAP   (4096 * 4)
#define MAX_ABSORB_LOG_MAP    (4096 * 15)
#define LOG_PRIO_BOOST 2

#define LOG_DATA_SIZE   80     // nominal # of bytes to log

#define DOLOGAPC 0

#define SignalLogThreshold(pLog)                               \
         if(pLog->Event)                                      \
         {                                                     \
             KeSetEvent(pLog->Event, LOG_PRIO_BOOST, FALSE);  \
         }

typedef struct _PfLogInterface
{
    LIST_ENTRY NextLog;
    DWORD      dwLoggedEntries;
    DWORD      dwEntriesThreshold;
    DWORD      dwFlags;                 // see below
    PFLOGGER   pfLogId;
    DWORD      dwMapWindowSize;
    DWORD      dwMapWindowSize2;
    DWORD      dwMapWindowSizeFloor;
    PBYTE      pUserAddress;            // Current user VA
    DWORD      dwTotalSize;
    DWORD      dwPastMapped;            // bytes used and no longer mapped
    PBYTE      pCurrentMapPointer;      // kernel VA of mapping
    DWORD      dwMapCount;
    DWORD      dwMapOffset;             // offset into the mapped segment
    PMDL       Mdl;                     // MDL for the mapping
    PIRP       Irp;
    PRKEVENT   Event;
    DWORD      dwLostEntries;
    LONG       UseCount;
    DWORD      dwSignalThreshold;
    LONG       lApcInProgress;
    NTSTATUS   MapStatus;
    KSPIN_LOCK LogLock;
#if DOLOGAPC
    DWORD      ApcInited;
    KAPC       Apc;
#endif
    ERESOURCE  Resource;
} PFLOGINTERFACE, *PPFLOGINTERFACE;

//
// flags
//

#define LOG_BADMEM        0x1        // an error occurred mapping the memory
#define LOG_OUTMEM        0x2        // buffer exhausted
#define LOG_CANTMAP       0x4        // nothing more to map


typedef struct _PfPagedLog
{
    LIST_ENTRY  Next;
    PPFLOGINTERFACE pLog;
} PFPAGEDLOG, *PPFPAGEDLOG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\foo.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\fltrdrvr\driver.c

Abstract:


Revision History:



--*/

#include "globals.h"
#include <ipinfo.h>
#include <ntddtcp.h>
#include <tdiinfo.h>

#define DEFAULT_DIRECTORY       L"DosDevices"
#define DEFAULT_FLTRDRVR_NAME   L"IPFILTERDRIVER"

typedef enum
{
    NULL_INTERFACE = 0,
    OLD_INTERFACE,
    NEW_INTERFACE
} INTTYPE, *PINTTTYPE;

FILTER_DRIVER   g_filters;
DWORD           g_dwCacheSize;
DWORD           g_dwHashLists;
BOOL            g_bDriverRunning;
KSPIN_LOCK      g_lOutFilterLock;
KSPIN_LOCK      g_lInFilterLock;
KSPIN_LOCK      g_FcbSpin;
MRSW_LOCK       g_IpTableSpin;
LIST_ENTRY      g_freeOutFilters;
LIST_ENTRY      g_freeInFilters;
LIST_ENTRY      g_leFcbs;
DWORD           g_dwMakingNewTable;
DWORD           g_dwNumHitsDefaultIn;
DWORD           g_dwNumHitsDefaultOut;
DWORD           g_FragThresholdSize = MINIMUM_FRAGMENT_OFFSET;
ULONG           AddrModulus;
IPAddrEntry     *AddrTable;
PADDRESSARRAY * AddrHashTable;
PADDRESSARRAY * AddrSubnetHashTable;
NPAGED_LOOKASIDE_LIST filter_slist;
PAGED_LOOKASIDE_LIST  paged_slist;
ERESOURCE       FilterAddressLock;


#ifdef DRIVER_PERF
DWORD          g_dwNumPackets,g_dwFragments,g_dwCache1,g_dwCache2;
DWORD          g_dwWalk1,g_dwWalk2,g_dwForw,g_dwWalkCache;
KSPIN_LOCK     g_slPerfLock;
LARGE_INTEGER  g_liTotalTime;
#endif

//
// Forward references.
//
NTSTATUS
OpenNewHandle(PFILE_OBJECT FileObject);

NTSTATUS
CloseFcb(PPFFCB Fcb, PFILE_OBJECT FileObject);

PPAGED_FILTER_INTERFACE
FindInterfaceOnHandle(PFILE_OBJECT FileObject,
                      PVOID    pvValue);

DWORD
LocalIpLook(DWORD Addr);

BOOLEAN
PfFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

NTSTATUS
LockFcb(
    IN struct _FILE_OBJECT *FileObject);

VOID
PFReadRegistryParameters(PUNICODE_STRING RegistryPath);

VOID
UnLockFcb(
    IN struct _FILE_OBJECT *FileObject);

NTSTATUS
GetSynCountTotal(PFILTER_DRIVER_GET_SYN_COUNT OutputBuffer);

NTSTATUS
DeleteByHandle(
           IN PPFFCB                      Fcb,
           IN PPAGED_FILTER_INTERFACE     pPage,
           IN PVOID *                     ppHandles,
           IN DWORD                       dwLength);


FAST_IO_DISPATCH PfFastIoDispatch =
{
    11,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    PfFastIoDeviceControl
};

#pragma alloc_text(PAGED, DoIpIoctl)
//#pragma alloc_text(PAGED, OpenNewHandle)
#pragma alloc_text(PAGED, FindInterfaceOnHandle)
#pragma alloc_text(PAGED, PfFastIoDeviceControl)
#pragma alloc_text(INIT, DriverEntry, PFReadRegistryParameters)


VOID
FcbLockDown(PPFFCB Fcb)
{
    KIRQL kirql;

    KeAcquireSpinLock(&g_FcbSpin, &kirql);
    if(!(Fcb->dwFlags & PF_FCB_CLOSED))
    {
        InterlockedDecrement(&Fcb->UseCount);
        Fcb->dwFlags |= PF_FCB_CLOSED;
    }
    KeReleaseSpinLock(&g_FcbSpin, kirql);
}

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT  DriverObject,
            IN PUNICODE_STRING RegistryPath
            )
/*++
  Routine Description
       Called when the driver is loaded. It creates the device object and sets up the DOS name.
       Also does the initialization of standard entry points and its own global data
          
  Arguments
       DriverObject
       RegistryPath
          
  Return Value
       NTSTATUS

--*/
{
    INT		        i;
    PDEVICE_OBJECT  deviceObject = NULL;
    NTSTATUS        ntStatus;
    WCHAR	        deviceNameBuffer[] = DD_IPFLTRDRVR_DEVICE_NAME;
    UNICODE_STRING  deviceNameUnicodeString;
    
    TRACE0("Filter Driver: Entering DriverEntry\n") ;
    
     
    //
    // Initialize the lock and the list
    //
    
    InitializeMRSWLock(&g_filters.ifListLock);
    InitializeListHead(&g_filters.leIfListHead);
    InitializeListHead(&g_leFcbs);
    g_filters.ppInCache = NULL;
    g_filters.ppOutCache = NULL;
    g_bDriverRunning = FALSE;
    InitializeMRSWLock(&g_IpTableSpin);
    KeInitializeSpinLock(&g_lOutFilterLock);
    KeInitializeSpinLock(&g_lInFilterLock);
    KeInitializeSpinLock(&g_FcbSpin);
    InitializeListHead(&g_freeOutFilters);
    InitializeListHead(&g_freeInFilters);
    g_dwNumHitsDefaultIn = g_dwNumHitsDefaultOut = 0;
    
#ifdef DRIVER_PERF
    g_dwFragments = g_dwCache1 = g_dwCache2 = g_dwNumPackets = 0;
    g_dwWalk1 = g_dwWalk2 = g_dwForw = g_dwWalkCache = 0;
    g_liTotalTime.HighPart = g_liTotalTime.LowPart = 0; 
    KeInitializeSpinLock(&g_slPerfLock);
#endif

    //
    // Create a device object 
    //
     
    RtlInitUnicodeString (&deviceNameUnicodeString, deviceNameBuffer);
    
    __try
    {
        ntStatus = IoCreateDevice (DriverObject,
                                   0,
                                   &deviceNameUnicodeString,
                                   FILE_DEVICE_NETWORK,
                                   0,
                                   FALSE,               // Exclusive
                                   &deviceObject
                                   );
        
        if (NT_SUCCESS(ntStatus)) 
        {
            //
            // Initialize the driver object
            //

            DriverObject->DriverUnload   = FilterDriverUnload;
            DriverObject->FastIoDispatch = &PfFastIoDispatch;
            DriverObject->DriverStartIo  = NULL;
    
            for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
            {
                DriverObject->MajorFunction[i] = FilterDriverDispatch;
            }
        } 
        else 
        {
            DbgPrint("Filter Driver: IoCreateDevice failed\n") ;
            __leave;
        }
        
        SetupExternalNaming (&deviceNameUnicodeString) ;
    }
    __finally
    {
        if(!NT_SUCCESS(ntStatus))
        {
            DbgPrint("Filter Driver: Error in DriverEntry routine\n");
        }
        else
        {
            ExInitializeResource ( &FilterListResourceLock );
            ExInitializeResource ( &FilterAddressLock );
            TRACE0("Filter Driver: DriverEntry routine successful\n");
        }
        
        if(NT_SUCCESS(ntStatus))
        {
            PFReadRegistryParameters(RegistryPath);
        }
        return ntStatus;
    }
}


NTSTATUS
FilterDriverDispatch(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     )
/*++
  Routine Description
        Dispatch Routine for the filter driver. Gets the current irp stack location, validates
        the parameters and calls the necessary routing (which is ioctl.c)
        
  Arguments
        DeviceObject
        Irp
          
  Return Value
        Status as returned by the worker functions
        
--*/
{
    PIO_STACK_LOCATION	irpStack;
    PVOID		        pvIoBuffer;
    ULONG		        inputBufferLength;
    ULONG		        outputBufferLength;
    ULONG		        ioControlCode;
    NTSTATUS		    ntStatus;
    DWORD               dwSize = 0;

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    
    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    
    //
    // Get the pointer to the input/output buffer and it's length
    //
    
    pvIoBuffer         = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    TRACE0("FilterDriver: Request received\n");

    switch (irpStack->MajorFunction) 
    {
        case IRP_MJ_CREATE:
        {
            TRACE0("FilterDriver: IRP_MJ_CREATE\n");
            
            //
            // Initialize the driver. The first time it gets a create IRP, it starts up the 
            // filtering.
            //
            
            ntStatus = STATUS_SUCCESS;
            
            if(!g_bDriverRunning)
            {
                ExAcquireResourceExclusive( &FilterListResourceLock, TRUE);
               
                if (g_bDriverRunning || InitFilterDriver())
                {
                    g_bDriverRunning = TRUE;
                }
                else
                {
                    ntStatus = STATUS_UNSUCCESSFUL ;
                }
                ExReleaseResourceLite( &FilterListResourceLock );
            }
            if(NT_SUCCESS(ntStatus))
            {
                ntStatus = OpenNewHandle(irpStack->FileObject);
            }
            
            break;
        }
        
        case IRP_MJ_CLEANUP:
            
        {
            TRACE0("FilterDriver: IRP_MJ_CLEANUP\n");
            
            //
            // Closing the file handle to the driver doesnt shut the driver down
            //
            
            ntStatus = STATUS_SUCCESS;
            
            break;
        }
              
        case IRP_MJ_CLOSE:

        {
            //
            // All done with this file object and this FCB. Run
            // down the interfaces getting rid of them
            //

            ntStatus = LockFcb(irpStack->FileObject);
            if(NT_SUCCESS(ntStatus))
            {
                PPFFCB Fcb = irpStack->FileObject->FsContext2;

                FcbLockDown(Fcb);
                UnLockFcb(irpStack->FileObject);
            }
            break;
        }

        case IRP_MJ_DEVICE_CONTROL:
        {
            TRACE0("FilterDriver: IRP_MJ_DEVICE_CONTROL\n");
            
            ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
            
            switch (ioControlCode) 
            {

#if FWPF
                case IOCTL_CLEAR_INTERFACE_BINDING:
                {
                    PINTERFACEBINDING pBind;
                    PPAGED_FILTER_INTERFACE pPage;

                    TRACE0("FilterDriver: IOCTL_CLEAR_INTERFACE_BINDING called\n");

                    dwSize = sizeof(*pBind);

                    if(inputBufferLength < sizeof(*pBind))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength < sizeof(*pBind))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pBind = (PINTERFACEBINDING)pvIoBuffer;

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
          
                    pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                  pBind->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {                   
                        ntStatus = ClearInterfaceBinding(pPage, pBind);
                    }

                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_SET_INTERFACE_BINDING:
                {
                    PINTERFACEBINDING pBind;
                    PPAGED_FILTER_INTERFACE pPage;

                    TRACE0("FilterDriver: IOCTL_SET_INTERFACE_BINDING called\n");

                    dwSize = sizeof(*pBind);

                    if(inputBufferLength < sizeof(*pBind))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength < sizeof(*pBind))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pBind = (PINTERFACEBINDING)pvIoBuffer;

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                  pBind->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {                   
                        ntStatus = SetInterfaceBinding(pBind, pPage);
                    }
                    UnLockFcb(irpStack->FileObject);
                    break;
                }

                case IOCTL_PF_GET_INTERFACE_PARAMETERS:
                {
                    PPFGETINTERFACEPARAMETERS pp;
                    PPAGED_FILTER_INTERFACE pPage;

                    TRACE0("FilterDriver: GET_INTERFACE_PARAMETERS called\n");

                    dwSize = sizeof(*pp);


                    if(inputBufferLength < (sizeof(*pp) - sizeof(FILTER_STATS_EX)))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength < (sizeof(*pp) - sizeof(FILTER_STATS_EX)))
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pp = (PPFGETINTERFACEPARAMETERS)pvIoBuffer;
                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }

                    if(pp->dwFlags & GET_BY_INDEX)
                    {
                        pPage = 0;
                    }
                    else
                    {
                        pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                      pp->pvDriverContext);
                        if(!pPage)
                        {
                            ntStatus = STATUS_INVALID_PARAMETER;
                            UnLockFcb(irpStack->FileObject);
                            break;
                        }
                    }

                    dwSize = outputBufferLength;
                    ntStatus = GetInterfaceParameters(pPage,
                                                      pp,
                                                      &dwSize);
                    UnLockFcb(irpStack->FileObject);
                    break;
                }

                case IOCTL_PF_CREATE_AND_SET_INTERFACE_PARAMETERS:
                {
                    //
                    // create a new style interface.
                    //


                    PPFINTERFACEPARAMETERS pInfo;

                    TRACE0("FilterDriver: IOCTL_CREATE_AND_SET called\n");

                    dwSize = sizeof(PFINTERFACEPARAMETERS);

                    //
                    // Both input and output Buffer lengths should be the same a nd
                    //

                    if(inputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    if(outputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    pInfo = (PPFINTERFACEPARAMETERS)pvIoBuffer;

                    //
                    // now establish the interface
                    //

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    ntStatus = AddNewInterface(pInfo,
                                               irpStack->FileObject->FsContext2);
                    UnLockFcb(irpStack->FileObject);
                    break;
                }
                
                case IOCTL_PF_CREATE_LOG:

                {
                    PPFPAGEDLOG pPage;
                    PPFLOG ppfLog;

                    TRACE0("FilterDriver: IOCTL_PF_CREATE_LOG\n");

                    //
                    // Check the size
                    //
                    
                    dwSize = sizeof(PFLOG);
                    
                    if((inputBufferLength < dwSize)
                               ||
                       (outputBufferLength < dwSize))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ppfLog = (PPFLOG)pvIoBuffer;

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    ntStatus = PfLogCreateLog(
                                 ppfLog,
                                 irpStack->FileObject->FsContext2,
                                 Irp);
                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_PF_DELETE_LOG:
                {
                    TRACE0("FilterDriver: IOCTL_PF_DELETE_LOG\n");

                    //
                    // Check the size
                    //
                    
                    dwSize = sizeof(PFDELETELOG);
                    
                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    ntStatus = PfDeleteLog(
                                 (PPFDELETELOG)pvIoBuffer,
                                 irpStack->FileObject->FsContext2);
                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_SET_LOG_BUFFER:
                {
                    TRACE0("FilterDriver: IOCTL_SET_LOG_BUFFER\n");

                    //
                    // Check the size
                    //
                    
                    dwSize = sizeof(PFSETBUFFER);
                    
                    if((inputBufferLength < dwSize)
                               ||
                       (outputBufferLength < dwSize))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    ntStatus = PfLogSetBuffer(
                                 (PPFSETBUFFER)pvIoBuffer,
                                 irpStack->FileObject->FsContext2,
                                 Irp);
                                 
                    UnLockFcb(irpStack->FileObject);

                    break;
                }

                case IOCTL_PF_DELETE_BY_HANDLE:
                {
                    PPAGED_FILTER_INTERFACE pPage;

                    if(inputBufferLength < sizeof(PFDELETEBYHANDLE))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(
                            irpStack->FileObject,
                            ((PPFDELETEBYHANDLE)pvIoBuffer)->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        ntStatus = DeleteByHandle(
                                     (PPFFCB)irpStack->FileObject->FsContext2,
                                     pPage,
                                     &((PPFDELETEBYHANDLE)pvIoBuffer)->pvHandles[0],
                                     inputBufferLength - sizeof(PVOID));
                    }

                    UnLockFcb(irpStack->FileObject);
                    break;
                }
                    
                case IOCTL_DELETE_INTERFACE_FILTERS_EX:
                {
                    PPAGED_FILTER_INTERFACE pPage;

                    TRACE0("FilterDriver: IOCTL_UNSET_INTERFACE_FILTERSEX\n");

                    //
                    // The minimum size is without any TOCs
                    //
                    
                    dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);
                    
                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    
                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(
                     irpStack->FileObject,
                     ((PFILTER_DRIVER_SET_FILTERS)pvIoBuffer)->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else                    
                    {
                        ntStatus = UnSetFiltersEx(
                                     (PPFFCB)irpStack->FileObject->FsContext2,
                                     pPage,
                                     inputBufferLength,
                                     (PFILTER_DRIVER_SET_FILTERS)pvIoBuffer);
                    }
                    UnLockFcb(irpStack->FileObject);
                    
                    break;
                }

                case IOCTL_SET_INTERFACE_FILTERS_EX:
                {
                    PPAGED_FILTER_INTERFACE pPage;

                    TRACE0("FilterDriver: IOCTL_SET_INTERFACE_FILTERSEX\n");

                    //
                    // The minimum size is without any TOCs
                    //
                    
                    dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);
                    
                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    
                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(
                     irpStack->FileObject,
                     ((PFILTER_DRIVER_SET_FILTERS)pvIoBuffer)->pvDriverContext);

                    if(!pPage)
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    else                    
                    {
                        ntStatus = SetFiltersEx(
                                     (PPFFCB)irpStack->FileObject->FsContext2,
                                     pPage,
                                     inputBufferLength,
                                     (PFILTER_DRIVER_SET_FILTERS)pvIoBuffer);
                    }
                    UnLockFcb(irpStack->FileObject);
                    
                    break;
                }

                case IOCTL_DELETE_INTERFACEEX:
                {
                    PFILTER_DRIVER_DELETE_INTERFACE pDel;
                    PPAGED_FILTER_INTERFACE pPage;
                    
                    TRACE0("FilterDriver: IOCTL_DELETE_INTERFACE\n");
                    
                    pDel = (PFILTER_DRIVER_DELETE_INTERFACE)pvIoBuffer;

                    dwSize = sizeof(FILTER_DRIVER_DELETE_INTERFACE);
                    
                    if(inputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }


                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                  pDel->pvDriverContext);
                    if(pPage)
                    {
                        RemoveEntryList(&pPage->leIfLink);
                        ntStatus = DeletePagedInterface(
                                      (PPFFCB)irpStack->FileObject->FsContext2,
                                      pPage);
                    }
                    else
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    
                    UnLockFcb(irpStack->FileObject);
                    break;
                }
                
                case IOCTL_SET_LATE_BOUND_FILTERSEX:
                {
                    PFILTER_DRIVER_BINDING_INFO pBindInfo;
                    PPAGED_FILTER_INTERFACE pPage;

                    TRACE0("FilterDriver: IOCTL_SET_LATE_BOUND_FILTERS\n");

                    pBindInfo = (PFILTER_DRIVER_BINDING_INFO)pvIoBuffer;

                    dwSize = sizeof(FILTER_DRIVER_BINDING_INFO);

                    if(inputBufferLength isnot dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    ntStatus = LockFcb(irpStack->FileObject);
                    if(!NT_SUCCESS(ntStatus))
                    {
                        break;
                    }
                    pPage = FindInterfaceOnHandle(irpStack->FileObject,
                                                  pBindInfo->pvDriverContext);

                    if(pPage)
                    {
                        ntStatus = UpdateBindingInformationEx(pBindInfo,
                                                              pPage);
                    }
                    else
                    {
                        ntStatus = STATUS_INVALID_PARAMETER;
                    }
                    UnLockFcb(irpStack->FileObject);

                    break;
                }
                    
#endif                // FWPF

#if STEELHEAD
                case IOCTL_CREATE_INTERFACE:
                {
                    //
                    // the old style of creating an interface.
                    // just pass it through to the underlying code
                    //
                    PFILTER_DRIVER_CREATE_INTERFACE pInfo;
                    
                    TRACE0("FilterDriver: IOCTL_CREATE_INTERFACE\n");

                    dwSize = sizeof(FILTER_DRIVER_CREATE_INTERFACE);

                    
                    //
                    // Both input and output Buffer lengths should be the same and
                    //
                    
                    if(inputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }
                    
                    if(outputBufferLength != dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }
                    
                    pInfo = (PFILTER_DRIVER_CREATE_INTERFACE)pvIoBuffer;
                    
                    ntStatus = AddInterface(
                                            pInfo->pvRtrMgrContext,
                                            pInfo->dwIfIndex,
                                            pInfo->dwAdapterId,
                                            irpStack->FileObject->FsContext2,
                                            &pInfo->pvDriverContext);
                    
                    if(NT_SUCCESS(ntStatus))
                    {
                        dwSize = sizeof(FILTER_DRIVER_CREATE_INTERFACE);
                    }

                    break;
                }
            
                case IOCTL_SET_INTERFACE_FILTERS:
                {
                    TRACE0("FilterDriver: IOCTL_SET_INTERFACE_FILTERS\n");

                    //
                    // The minimum size is without any TOCs
                    //
                    
                    dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);
                    
                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    
                    ntStatus = SetFilters((PFILTER_DRIVER_SET_FILTERS)pvIoBuffer);
                    
                    break;
                }

                case IOCTL_SET_LATE_BOUND_FILTERS:
                {
                    PFILTER_DRIVER_BINDING_INFO pBindInfo;

                    TRACE0("FilterDriver: IOCTL_SET_LATE_BOUND_FILTERS\n");

                    pBindInfo = (PFILTER_DRIVER_BINDING_INFO)pvIoBuffer;

                    dwSize = sizeof(FILTER_DRIVER_BINDING_INFO);

                    if(inputBufferLength isnot dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    ntStatus = UpdateBindingInformation(pBindInfo,
                                                        pBindInfo->pvDriverContext);

                    break;
                }
                    
                case IOCTL_DELETE_INTERFACE:
                {
                    PFILTER_DRIVER_DELETE_INTERFACE pDel;
                    
                    TRACE0("FilterDriver: IOCTL_DELETE_INTERFACE\n");
                    
                    pDel = (PFILTER_DRIVER_DELETE_INTERFACE)pvIoBuffer;

                    dwSize = sizeof(FILTER_DRIVER_DELETE_INTERFACE);
                    
                    if(inputBufferLength isnot dwSize)
                    {
                        ntStatus = STATUS_INVALID_BUFFER_SIZE;
                        break;
                    }

                    ntStatus = DeleteInterface(pDel->pvDriverContext);
                    
                    break;
                }

#endif                 // STEELHEAD

                
                case IOCTL_TEST_PACKET:
                {
                    PFILTER_DRIVER_TEST_PACKET pPacketInfo;
                    FORWARD_ACTION  eaResult;
                    UNALIGNED IPHeader *pHeader;
                    DWORD    dwSizeOfHeader;
                    PBYTE    pbRest;
                    DWORD    dwSizeOfData;
                    
                    TRACE0("FilterDriver: IOCTL_TEST_PACKET\n");
                    
                    pPacketInfo = (PFILTER_DRIVER_TEST_PACKET)pvIoBuffer;
                    
                    dwSize = sizeof(FILTER_DRIVER_TEST_PACKET);
                    
                    if(inputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    
                    if(outputBufferLength < dwSize)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    
                    pHeader = (IPHeader*)(pPacketInfo->bIpPacket);
                    
                    dwSizeOfHeader = ((pHeader->iph_verlen)&0x0f)<<2;
                    
                    pbRest = (PBYTE)pHeader + dwSizeOfHeader;

                    //
                    // make sure the header fits
                    //
                    dwSizeOfData = inputBufferLength - sizeof(FILTER_DRIVER_TEST_PACKET) - 1;

                    if(dwSizeOfData < dwSizeOfHeader)
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    //
                    // it does. Make sure the data fits
                    //

                    dwSizeOfData -= dwSizeOfHeader;

                    if(dwSizeOfData < (UINT)pHeader->iph_length)                   
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    eaResult = MatchFilter(pHeader,
                                           pbRest,
                                           (UINT)pHeader->iph_length,
                                           pPacketInfo->pvInInterfaceContext,
                                           pPacketInfo->pvOutInterfaceContext);

                    ntStatus = STATUS_SUCCESS;
                    
                    pPacketInfo->eaResult = eaResult;
                    
                    //
                    // We dont need to copy the full packet out
                    //
                    
                    dwSize = sizeof(FILTER_DRIVER_TEST_PACKET);
            
                    break;
                }
                
#if STEELHEAD
                case IOCTL_GET_FILTER_INFO:
                {
                    PFILTER_DRIVER_GET_FILTERS  pInfo;
                    PFILTER_INTERFACE           pIf;
                    KIRQL                       kIrql;

                    TRACE0("FilterDriver: IOCTL_GET_FILTER_INFO\n");
                    
                    
                    pInfo = (PFILTER_DRIVER_GET_FILTERS)pvIoBuffer;
                       
                    pIf = (PFILTER_INTERFACE)(pInfo->pvDriverContext);
                    
                    //
                    // If we cant even report the number of filters, lets get out
                    //
                    
                    if(inputBufferLength < (sizeof(FILTER_DRIVER_GET_FILTERS) - sizeof(FILTER_STATS)))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    
                    if(outputBufferLength < (sizeof(FILTER_DRIVER_GET_FILTERS) - sizeof(FILTER_STATS)))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    
                    //
                    // Ok we have enough space to plug in the number of filters
                    //
                    
                    AcquireReadLock(&g_filters.ifListLock,&kIrql);
                    
                    pInfo->interfaces.eaInAction  = pIf->eaInAction;
                    pInfo->interfaces.eaOutAction = pIf->eaOutAction;

                    pInfo->interfaces.dwNumInFilters  = pIf->dwNumInFilters;
                    pInfo->interfaces.dwNumOutFilters = pIf->dwNumOutFilters;
                    
                    dwSize = SIZEOF_FILTERS(pIf);

                    if(inputBufferLength < dwSize)
                    {
                        dwSize = sizeof(FILTER_DRIVER_GET_FILTERS) - sizeof(FILTER_STATS);

                        ntStatus = STATUS_SUCCESS;

                        ReleaseReadLock(&g_filters.ifListLock,kIrql);
                        
                        break;
                    }
                    
                    if(outputBufferLength < dwSize)
                    {
                        dwSize = sizeof(FILTER_DRIVER_GET_FILTERS) - sizeof(FILTER_STATS);
                        
                        ntStatus = STATUS_SUCCESS;

                        ReleaseReadLock(&g_filters.ifListLock,kIrql);
                        
                        break;
                    }
                    
                    ntStatus = GetFilters(pIf,
                                          FALSE,
                                          &(pInfo->interfaces));
                    
                    pInfo->dwDefaultHitsIn  = g_dwNumHitsDefaultIn;
                    pInfo->dwDefaultHitsOut = g_dwNumHitsDefaultOut;
                    
                    ReleaseReadLock(&g_filters.ifListLock,kIrql);
                    
                    break;
                }
#endif
                
                case IOCTL_GET_FILTER_TIMES:
                {
                    PFILTER_DRIVER_GET_TIMES    pInfo;
                    PFILTER_INTERFACE           pIf;
                    KIRQL                       kIrql;
                    
                    TRACE0("FilterDriver: IOCTL_GET_FILTER_TIMES\n");
                    
                    dwSize = sizeof(FILTER_DRIVER_GET_TIMES);
                    
                    if(outputBufferLength < sizeof(FILTER_DRIVER_GET_TIMES))
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                    
                    pInfo = (PFILTER_DRIVER_GET_TIMES)pvIoBuffer;
                    
#ifdef DRIVER_PERF                  
                    pInfo->dwFragments  = g_dwFragments;
                    pInfo->dwCache1     = g_dwCache1;
                    pInfo->dwCache2     = g_dwCache2;
                    pInfo->dwNumPackets = g_dwNumPackets;
                    pInfo->dwWalk1      = g_dwWalk1;
                    pInfo->dwWalk2      = g_dwWalk2;
                    pInfo->dwForw       = g_dwForw;
                    pInfo->dwWalkCache  = g_dwWalkCache;
                    
                    pInfo->liTotalTime.HighPart = g_liTotalTime.HighPart;
                    pInfo->liTotalTime.LowPart  = g_liTotalTime.LowPart;
#else
                    pInfo->dwFragments  = 0;
                    pInfo->dwCache1     = 0;
                    pInfo->dwCache2     = 0;
                    pInfo->dwNumPackets = 0;
                    pInfo->dwWalk1      = 0;
                    pInfo->dwWalk2      = 0;
                    pInfo->dwForw       = 0;
                    pInfo->dwWalkCache  = 0;
                    
                    pInfo->liTotalTime.HighPart = 0;
                    pInfo->liTotalTime.LowPart  = 0;
#endif
                    ntStatus = STATUS_SUCCESS;
                    
                    break;
                }
                
                default:
                {
                    DbgPrint ("Filter Driver: unknown IOCTL\n");

                    ntStatus = STATUS_INVALID_PARAMETER;
                    
                    break;
                }
            }
            
            break ;
        }

        default:
        {
            DbgPrint ("Filter Driver: unknown IRP_MJ_XXX\n");
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    if(ntStatus != STATUS_PENDING)
    {
        Irp->IoStatus.Status = ntStatus;
    
        Irp->IoStatus.Information = dwSize;
      
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    
    return(ntStatus);
}

VOID
FilterDriverUnload(
                   IN PDRIVER_OBJECT DriverObject
                   )
/*++
  Routine Description
        Called when the driver is unloaded. This shuts down the filtering (if it hasnt been shut
        down already) and removes the DOS name
  
  Arguments
        DriverObject
          
  Return Value
        None
--*/
{
    TRACE0("Filter Driver: unloading\n");
    
    CloseFilterDriver();
    
    TearDownExternalNaming();
    
    IoDeleteDevice(DriverObject->DeviceObject);
}



VOID
SetupExternalNaming (
                     IN PUNICODE_STRING ntname
                     )
/*++
  Routine Description
        Inserts the input name as the DOS name       
        
  Arguments
        ntname - Name of driver
          
  Return Value
        None
--*/
{
    UNICODE_STRING  ObjectDirectory;
    UNICODE_STRING  SymbolicLinkName;
    UNICODE_STRING  fullLinkName;
    BYTE      	    buffer[100] ;

    //
    // Form the full symbolic link name we wish to create.
    //

    RtlInitUnicodeString (&fullLinkName, NULL);
    
    RtlInitUnicodeString (&ObjectDirectory, DEFAULT_DIRECTORY);
   
    RtlInitUnicodeString(&SymbolicLinkName, DEFAULT_FLTRDRVR_NAME);
    
    fullLinkName.MaximumLength = (sizeof(L"\\")*2) + ObjectDirectory.Length 
      + SymbolicLinkName.Length + sizeof(WCHAR);
    
    fullLinkName.Buffer = (WCHAR *)buffer ;
    
    RtlZeroMemory (fullLinkName.Buffer, fullLinkName.MaximumLength);
    
    RtlAppendUnicodeToString (&fullLinkName, L"\\");
    
    RtlAppendUnicodeStringToString (&fullLinkName, &ObjectDirectory);
    
    RtlAppendUnicodeToString (&fullLinkName, L"\\");
    
    RtlAppendUnicodeStringToString (&fullLinkName, &SymbolicLinkName);
    
    if (!NT_SUCCESS(IoCreateSymbolicLink (&fullLinkName, ntname)))
    {
        DbgPrint ("Filter Driver: ERROR win32 device name could not be created \n") ;
    }
   
}


VOID
TearDownExternalNaming()
/*++
  Routine Description
      Removes the DOS name from the registry
      Called when the driver is unloaded
      
  Arguments
      None
          
  Return Value
      None

--*/
{
    UNICODE_STRING  ObjectDirectory;
    UNICODE_STRING  SymbolicLinkName;
    UNICODE_STRING  fullLinkName;
    BYTE      	    buffer[100] ;
    
    RtlInitUnicodeString (&fullLinkName, NULL);
    
    RtlInitUnicodeString (&ObjectDirectory, DEFAULT_DIRECTORY);
    
    RtlInitUnicodeString(&SymbolicLinkName, DEFAULT_FLTRDRVR_NAME);
   
    fullLinkName.MaximumLength = (sizeof(L"\\")*2) + ObjectDirectory.Length 
      + SymbolicLinkName.Length + sizeof(WCHAR);
    
    fullLinkName.Buffer = (WCHAR *)buffer ;
    
    RtlZeroMemory (fullLinkName.Buffer, fullLinkName.MaximumLength);
    
    RtlAppendUnicodeToString (&fullLinkName, L"\\");
    
    RtlAppendUnicodeStringToString (&fullLinkName, &ObjectDirectory);
    
    RtlAppendUnicodeToString (&fullLinkName, L"\\");
    
    RtlAppendUnicodeStringToString (&fullLinkName, &SymbolicLinkName);
    
    if (!NT_SUCCESS(IoDeleteSymbolicLink (&fullLinkName)))
    {
        DbgPrint ("Filter Driver: ERROR win32 device name could not be deleted\n") ;
    }
}

BOOL
InitFilterDriver()
/*++
  Routine Description
       Starts the driver. Allocates memory for the cache and cache entries. Clears the entries
       Sends an IOCTL to the Forwarder to set up its entry point (which starts the filtering
       process in the forwarder)
          
  Arguments
       None
          
  Return Value
       TRUE if successful
       
--*/
{
    NTSTATUS status;
    BOOL bRet;
    SYSTEM_BASIC_INFORMATION PerfInfo;

    status = ZwQuerySystemInformation(
                SystemBasicInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );

    //
    // adjust cache and hash sizes based on the memory
    //

    if(PerfInfo.NumberOfPhysicalPages <= 8000)
    {
        //
        // 32 MB or smaller. A very chincy server
        //

        g_dwCacheSize = 257;
        g_dwHashLists = 127;
    }
    else if(PerfInfo.NumberOfPhysicalPages < 16000)
    {
        //
        // 32-64 MB. Better.
        //

        g_dwCacheSize = 311;
        g_dwHashLists = 311;
    }
    else if(PerfInfo.NumberOfPhysicalPages < 32000)
    {
        //
        // 64 - 128 MB.
        //

        g_dwCacheSize = 511;
        g_dwHashLists = 511;
    }
    else
    {
        //
        //  big machine
        //

        g_dwCacheSize = 511;
        g_dwHashLists = 1023;
    }
    
    
    InitLogs();

    __try
    {
        
        bRet = TRUE;

        if(!AllocateCacheStructures())
        {
            DbgPrint("Couldnt allocate cache structures\n");

            bRet = FALSE;

            __leave;
        }
        
        //
        // Clean the cache
        //
        
        ClearCache();
        
        //
        // Now send and Irp to IP Forwarder and give him our entry point
        // Do it twice, once to make sure it is cleared and to
        // erase any previous filter contexts and once to do what
        // we want it to do.
        //
        
        status = SetForwarderEntryPoint(NULL);
        status = SetForwarderEntryPoint(MatchFilter);
        
        if(status isnot STATUS_SUCCESS)
        {
            DbgPrint("IOCTL to IP Forwarder failed - status \n",status);

            bRet = FALSE;

            __leave;
        }
        
    }
    __finally
    {
        if(!bRet)
        {
            FreeExistingCache();
        }
        else
        {
            ExInitializeNPagedLookasideList(
                       &filter_slist,
                       ExAllocatePoolWithTag,
                       ExFreePool,
                       0,
                       sizeof(FILTER),
                       (ULONG)'2liF',
                       100);
            ExInitializePagedLookasideList(
                       &paged_slist,
                       ExAllocatePoolWithTag,
                       ExFreePool,
                       0,
                       sizeof(PAGED_FILTER),
                       (ULONG)'2liF',
                       100);
        }
        return bRet;
    }
}

BOOL
CloseFilterDriver()
/*++
  Routine Description
       Shuts down the driver. 
          
  Arguments
         
          
  Return Value
--*/
{
    
    NTSTATUS    status;
    KIRQL       kIrql;
    PLIST_ENTRY pleHead;
    BOOL        bStopForw = TRUE;
    PFREEFILTER pFree, pFree1;
    PPFFCB Fcb;
    KIRQL kirql;

    //
    // The first thing to do is send an IOCTL to forwarder to tell him to stop sending
    // us anymore packets. 
    //
    
    status = SetForwarderEntryPoint(NULL);
       
    if(!NT_SUCCESS(status))
    {
        //
        // This means we could not tell IP Forwarder 
        // to stop filtering packets so we cant go away.
        //
        
        DbgPrint("Couldnt IOCTL IP Forwarder to stop filtering - cant unload\n");
        
        bStopForw = FALSE;
        
    }

    //
    // remove the FCBS
    //

    while(TRUE)
    {
        NTSTATUS ntStatus;
        FILE_OBJECT fo;
        KIRQL kirql;
        BOOL fDone = TRUE;

        KeAcquireSpinLock(&g_FcbSpin, &kirql);
        for(pleHead = g_leFcbs.Flink;
            pleHead != &g_leFcbs;
            pleHead = pleHead->Flink)
        {
            Fcb = CONTAINING_RECORD(pleHead, PFFCB, leList);
            //
            // This can happen if some other thread is closing the FCB.
            //
            if(Fcb->dwFlags & PF_FCB_CLOSED)
            {
                continue;
            }
            KeReleaseSpinLock(&g_FcbSpin, kirql);
            fDone = FALSE;
            fo.FsContext2 = (PVOID)Fcb;
            ntStatus = LockFcb(&fo);
            if(!NT_SUCCESS(ntStatus))
            {
                break;
            }
            FcbLockDown(Fcb);
            UnLockFcb(&fo);
            break;
        }
        if(fDone)
        {
            KeReleaseSpinLock(&g_FcbSpin, kirql);
            break;
        }
    }

    ExDeleteResource ( &FilterListResourceLock );
    ExDeleteResource ( &FilterAddressLock );

    AcquireWriteLock(&(g_filters.ifListLock),&kIrql);
    
    while(!IsListEmpty(&g_filters.leIfListHead))
    {
        PFILTER_INTERFACE pIf;
        
        pleHead = g_filters.leIfListHead.Flink;
        
        pIf = CONTAINING_RECORD(pleHead,FILTER_INTERFACE,leIfLink);
        
        DeleteFilters(pIf,
                      IN_FILTER_SET);
 
        DeleteFilters(pIf,
                      OUT_FILTER_SET);

        //
        // Set the number of filters to 0 and the default action to forward so 
        // that if we havent been able to stop the forwarder from calling us, 
        // atleast no packets get filtered
        // 
        
        pIf->dwNumInFilters = 0;
        pIf->dwNumOutFilters = 0;
        pIf->eaInAction = FORWARD;
        pIf->eaOutAction = FORWARD;
 
        if(bStopForw)
        {
            //
            // We could stop the forwarder so lets blow away the interface
            //
            
            RemoveHeadList(&g_filters.leIfListHead);
            
            ExFreePool(pIf);
        }
    }   
    
    ClearCache();
    
    if(bStopForw)
    {
        //
        // If we could stop the forwarder, blow away the cache
        //
        
        FreeExistingCache();
    }

    ReleaseWriteLock(&g_filters.ifListLock,kIrql);
    
    if(g_bDriverRunning)
    {
        ExDeleteNPagedLookasideList( &filter_slist );
        ExDeletePagedLookasideList( &paged_slist );
    }

    if(AddrTable)
    {
        ExFreePool(AddrTable);
        AddrTable = 0;
    }

    if(AddrHashTable)
    {
        ExFreePool(AddrHashTable);
        AddrHashTable = 0;
    }


    if(AddrSubnetHashTable)
    {
        ExFreePool(AddrSubnetHashTable);
        AddrSubnetHashTable = 0;
    }
   
    if(bStopForw)
    {
        return STATUS_SUCCESS;
    }
    else
    {
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
SetForwarderEntryPoint(
                       IN   IPPacketFilterPtr pfnMatch
                       )
/*++
  Routine Description
       Sets the entry point to IP Forwarder. Used to start and stop the forwarding code in
       the forwarder
          
  Arguments
       pfnMatch  Pointer to the function that implements the filter matching code
                 NULL will stop forwarding, while any other value will cause the forwarder to
                 invoke the function pointed to. Thus if on stopping, the IOCTL to the
                 forwarder doesnt succeed, and the filter driver goes away, the system will
                 blue screen
                 
  Return Value
      NTSTATUS 
--*/
{
    NTSTATUS                status;
    IP_SET_FILTER_HOOK_INFO functionInfo;

    functionInfo.FilterPtr = pfnMatch;
    status = DoIpIoctl(
                       DD_IP_DEVICE_NAME,
                       IOCTL_IP_SET_FILTER_POINTER,
                       (PVOID)&functionInfo,
                       sizeof(functionInfo),
                       NULL,
                       0,
                       NULL);
    return(status);
}
                       
NTSTATUS
DoIpIoctl(
          IN  PWCHAR        DriverName,
          IN  DWORD         Ioctl,
          IN  PVOID         pvInArg,
          IN  DWORD         dwInSize,
          IN  PVOID         pvOutArg,
          IN  DWORD         dwOutSize,
          OUT PDWORD        pdwInfo OPTIONAL)
/*++
Routine Description:
    Do an IOCTL to the stack. Used for a varity of purposes
--*/
{
    NTSTATUS                status;
    UNICODE_STRING          nameString;
    OBJECT_ATTRIBUTES       Atts;
    IO_STATUS_BLOCK         ioStatusBlock;
    HANDLE                  Handle;
    
    PAGED_CODE();

    RtlInitUnicodeString(&nameString, DriverName);
        
    InitializeObjectAttributes(&Atts,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
             
   status = ZwCreateFile(&Handle,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &Atts,
                         &ioStatusBlock,
                         NULL,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN_IF,
                         0,
                         NULL,
                         0);

    if (!NT_SUCCESS(status))
    {
        DbgPrint("Couldnt open IP Forwarder - status %d\n",status);
        return STATUS_UNSUCCESSFUL;
    }
    
    //
    // Submit the request to the forwarder
    //
        
    status = ZwDeviceIoControlFile(
                      Handle,
                      NULL,
                      NULL,
                      NULL,
                      &ioStatusBlock,
                      Ioctl,
                      pvInArg,
                      dwInSize,
                      pvOutArg,
                      dwOutSize);
                      
    if(!NT_SUCCESS(status))
    {
        DbgPrint("IOCTL request failed - status %x\n",status);
    }
    else
    {
        if(pdwInfo)
        {
            *pdwInfo = ioStatusBlock.Information;
        }
    }

    //
    // Close the device.
    //
    
    ZwClose(Handle);
    
    return status;
}

BOOL 
AllocateCacheStructures()
/*++
  Routine Description
        Allocates the necessary memory for cache (which is an array of pointers to 
            cache entries)
        Allocates necessary number of cache entries (but doesnt initialize them)
        Allocates a small number of entries and puts them on the free list (doesnt 
            initialize these either)
          
  Arguments
        None
          
  Return Value
        True if the function completely succeeds, else FALSE.  If FALSE, it is upto 
            the CALLER to do a rollback and clear any allocated memory
--*/
{
    DWORD i;
    
    TRACE0("Allocating cache\n");
    
    g_filters.ppInCache = ExAllocatePoolWithTag(NonPagedPool,
                                               g_dwCacheSize * sizeof(PFILTER_INCACHE),
                                               'hCnI');
    
    if(g_filters.ppInCache is NULL)
    {
        DbgPrint("Couldnt allocate memory for Input Cache\n");
        return FALSE;
    }
    
    g_filters.ppOutCache = ExAllocatePoolWithTag(NonPagedPool,
                                                g_dwCacheSize * sizeof(PFILTER_OUTCACHE),
                                                'CtuO');
    
    if(g_filters.ppOutCache is NULL)
    {
        DbgPrint("Couldnt allocate memory for Output Cache\n");
        return FALSE;
    }
        
    for(i = 0; i < g_dwCacheSize; i++)
    {
        g_filters.ppInCache[i] = NULL;
        g_filters.ppOutCache[i] = NULL;
    }
    
    for(i = 0; i < g_dwCacheSize; i++)
    {
        PFILTER_INCACHE  pTemp1;
        PFILTER_OUTCACHE pTemp2;
        
        pTemp1 = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(FILTER_INCACHE),
                                       'NI');
        if(pTemp1 is NULL)
        {
            return FALSE;
        }
        
        g_filters.ppInCache[i] = pTemp1;
            
        pTemp2 = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(FILTER_OUTCACHE),
                                       'TUO');
        if(pTemp2 is NULL)
        {
            return FALSE;
        }
        
        g_filters.ppOutCache[i] = pTemp2;
    }            
    
    TRACE0("Allocated cache structures\n");
    
    TRACE0("Creating in and out free list...");
    
    for(i = 0; i < FREE_LIST_SIZE; i++)
    {
        PFILTER_INCACHE  pTemp1;
        PFILTER_OUTCACHE pTemp2;
        
        pTemp1 = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(FILTER_INCACHE),
                                       'FNI');
        if(pTemp1 is NULL)
        {
            return FALSE;
        }
        
        InitializeListHead(&pTemp1->leFreeLink);
        
        InsertHeadList(&g_freeInFilters,&pTemp1->leFreeLink);
        
        pTemp2 = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(FILTER_OUTCACHE),
                                       'FTUO');
        if(pTemp2 is NULL)
        {
            return FALSE;
        }
        
        InitializeListHead(&pTemp2->leFreeLink);
        
        InsertHeadList(&g_freeOutFilters,&pTemp2->leFreeLink);
    }
    
    TRACE0("Done\n");
    return TRUE;
}
        
VOID
FreeExistingCache()
/*++
  Routine Description
       Frees all the cache entries, free entries and cache pointer array 
          
  Arguments
      None
          
  Return Value
      None
--*/
{
    DWORD i;
    
    TRACE0("Freeing existing in cache...");
    
    if(g_filters.ppInCache isnot NULL)
    {
        for(i = 0; i < g_dwCacheSize; i ++)
        {
            if(g_filters.ppInCache[i] isnot NULL)
            {
                ExFreePool(g_filters.ppInCache[i]);
            }
        }

        ExFreePool(g_filters.ppInCache);
        g_filters.ppInCache = NULL;
    }
    
    TRACE0("Done\n");

    TRACE0("Freeing existing out cache...");
 
    if(g_filters.ppOutCache isnot NULL)
    {
        for(i = 0; i < g_dwCacheSize; i ++)
        {
            if(g_filters.ppOutCache[i] isnot NULL)
            {
                ExFreePool(g_filters.ppOutCache[i]);
            }       
        }
        
        ExFreePool(g_filters.ppOutCache);
        g_filters.ppOutCache = NULL;
    }
   
    TRACE0("Done\n");
 
    TRACE0("Freeing existing in free list entries...");
    
    while(!IsListEmpty(&g_freeInFilters))
    {
        PFILTER_INCACHE pIn;
        PLIST_ENTRY     pleHead;
        
        pleHead = RemoveHeadList(&g_freeInFilters);
        
        pIn = CONTAINING_RECORD(pleHead,FILTER_INCACHE,leFreeLink);
        
        ExFreePool(pIn);
    }
   
    TRACE0("Done\n");
 
    TRACE0("Freeing existing out free list entries...");
    
    while(!IsListEmpty(&g_freeOutFilters))
    {
        PFILTER_OUTCACHE pOut;
        PLIST_ENTRY     pleHead;
        
        pleHead = RemoveHeadList(&g_freeOutFilters);
        
        pOut = CONTAINING_RECORD(pleHead,FILTER_OUTCACHE,leFreeLink);
                
        ExFreePool(pOut);
    }
    
    TRACE0("Done\n");
}


NTSTATUS
OpenNewHandle(PFILE_OBJECT FileObject)
/*++
Routine Description:
    Open a new handle to the driver. Allocate FCB from the paged pool
    and initialize it. If no memory available, fail. If success
    store the FCB pointer into the file object.
--*/
{
    PPFFCB Fcb;
    KIRQL kirql;

    //
    // Allocate an FCB for this handle.
    //

    Fcb = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(*Fcb),
                                'pfFC');
    if(Fcb)
    {
        FileObject->FsContext2 = (PVOID)Fcb;
        Fcb->dwFlags = 0;
        Fcb->UseCount = 1;
        InitializeListHead(&Fcb->leInterfaces);
        InitializeListHead(&Fcb->leLogs);
        ExInitializeResource ( &Fcb->Resource );
        ExAcquireSpinLock(&g_FcbSpin, &kirql);
        InsertTailList(&g_leFcbs, &Fcb->leList);
        ExReleaseSpinLock(&g_FcbSpin, kirql);
        return(STATUS_SUCCESS);
    }
    return(STATUS_NO_MEMORY);
}

PPAGED_FILTER_INTERFACE
FindInterfaceOnHandle(PFILE_OBJECT FileObject,
                      DWORD dwValue)
                     
/*++
   Routine Description:

   Find the paged interface for the call. If none found
   return a NULL. Uses the caller-supplied DriverContext to
   search the contexts on this handle. In general, there should
   not be many such handles.
--*/
{
    PPFFCB Fcb = FileObject->FsContext2;
    PPAGED_FILTER_INTERFACE pPage;

    PAGED_CODE();

    
    for(pPage = (PPAGED_FILTER_INTERFACE)Fcb->leInterfaces.Flink;
        (PLIST_ENTRY)pPage != &Fcb->leInterfaces;
        pPage = (PPAGED_FILTER_INTERFACE)pPage->leIfLink.Flink)
    {
        if(pPage->pvDriverContext == pvValue)
        {
            return(pPage);
        }
    }
    return(NULL);
}

NTSTATUS
CloseFcb(PPFFCB Fcb, PFILE_OBJECT FileObject)
/*++
   Routine Description:

      Called when an FCB has no more references. The caller must
      have removed the FCB from the master list. It is immaterial whether
      the CB resource is locked.
--*/
{
    PPAGED_FILTER_INTERFACE pPage;
    PFREEFILTER pList, pList1;
    NTSTATUS ntStatus;

    //
    // First clean up the logs
    //
    while(!IsListEmpty(&Fcb->leLogs))
    {
        PFDELETELOG DelLog;

        DelLog.pfLogId = (PFLOGGER)Fcb->leLogs.Flink;
        (VOID)PfDeleteLog(&DelLog, Fcb);
    }

    //
    // Next, clean up the interfaces
    //
    while(!IsListEmpty(&Fcb->leInterfaces))
    {
        pPage = (PPAGED_FILTER_INTERFACE)RemoveHeadList(&Fcb->leInterfaces);
        (VOID)DeletePagedInterface(Fcb, pPage);
    }

#if 0
    //
    // Can't do this because can't get the filter context from the stack.
    //

    if(Fcb->dwFlags & PF_FCB_OLD)
    {
        DeleteOldInterfaces(Fcb);
    }
#endif

    //
    // Free the Fcb
    //

    ExDeleteResource ( &Fcb->Resource );
    ExFreePool(Fcb);
    if(FileObject)
    {
        FileObject->FsContext2 = NULL;
    }
    return(STATUS_SUCCESS);   
}

DWORD
GetIpStackIndex(IPAddr Addr, BOOL fNew)
/*++
  Routine Description:
     Get the stack index for the corresponding address and mask
--*/
{
    DWORD                              dwResult;
    DWORD                              dwInBufLen;
    DWORD                              dwOutBufLen;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    BYTE                               *Context;
    NTSTATUS                           Status;
    IPSNMPInfo                         IPSnmpInfo;
    IPAddrEntry                        *AddrTable1;
    DWORD                              dwSpace, dwIpIndex;
    DWORD                              dwFinalAddrSize;
    DWORD                              dwFinalSize, dwX;
    PADDRESSARRAY                      pa;
    KIRQL                              kirql;


    ExAcquireResourceShared( &FilterAddressLock, TRUE);
    if(!AddrTable || fNew)
    {
        ExReleaseResource(&FilterAddressLock );
        ExAcquireResourceExclusive( &FilterAddressLock, TRUE);

        if(fNew && AddrTable)
        {
            //
            // acquire the spin lock to synchronize with Match
            // code running at DPC so we can "lock out"
            // the table while we do the rest of this. Note
            // we can't hold a spin lock while building the table
            // because the calls into the IP stack hit pageable
            // code
            //
            AcquireWriteLock(&g_IpTableSpin, &kirql);
            g_dwMakingNewTable = TRUE;
            ReleaseWriteLock(&g_IpTableSpin, kirql);
            ExFreePool( AddrTable );
            AddrTable = 0;
        }
    }

    if(!AddrTable)
    {
        dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

        dwOutBufLen = sizeof(IPSNMPInfo);

        ID = &(trqiInBuf.ID);
        ID->toi_entity.tei_entity = CL_NL_ENTITY;
        ID->toi_entity.tei_instance = 0;
        ID->toi_class = INFO_CLASS_PROTOCOL;
        ID->toi_type = INFO_TYPE_PROVIDER;
        ID->toi_id = IP_MIB_STATS_ID;

        Context = &(trqiInBuf.Context[0]);
        RtlZeroMemory(Context, CONTEXT_SIZE);

        Status = DoIpIoctl(
                       DD_TCP_DEVICE_NAME,
                       IOCTL_TCP_QUERY_INFORMATION_EX,
                       (PVOID)&trqiInBuf,
                       sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                       (PVOID)&IPSnmpInfo,
                       dwOutBufLen,
                       NULL);  

       if(NT_SUCCESS(Status))
       {


            //
            // allocate some memory to fetch the address table.
            //

            dwSpace = IPSnmpInfo.ipsi_numaddr + 10;

            dwOutBufLen = dwSpace * sizeof(IPAddrEntry);

            if(!AddrHashTable)
            {
                //
                // the hash table size was not specified in the
                // registry. Compute it based on the number of
                // addresses. Try to keep the hash table less than
                // half full.
                //
                if(!AddrModulus)
                {
                    if(IPSnmpInfo.ipsi_numaddr < ADDRHASHLOWLEVEL)
                    {
                        AddrModulus = ADDRHASHLOW;
                    }
                    else if(IPSnmpInfo.ipsi_numaddr < ADDRHASHMEDLEVEL)
                    {
                        AddrModulus = ADDRHASHMED;
                    }
                    else
                    {
                        AddrModulus = ADDRHASHHIGH;
                    }
                }
                AddrHashTable = (PADDRESSARRAY *)ExAllocatePoolWithTag(
                                              NonPagedPool,
                                              AddrModulus *
                                               sizeof(PADDRESSARRAY),
                                              'pfAh');
                if(!AddrHashTable)
                {
                    DbgPrint("Could not allocate AddrHashTable");
                    g_dwMakingNewTable = FALSE;
                    ExReleaseResource(&FilterAddressLock );
                    return(UNKNOWN_IP_INDEX);
                }
            }

            if(!AddrSubnetHashTable)
            {
                AddrSubnetHashTable = (PADDRESSARRAY *)ExAllocatePoolWithTag(
                                              NonPagedPool,
                                              AddrModulus *
                                               sizeof(PADDRESSARRAY),
                                              'pfAh');
                if(!AddrSubnetHashTable)
                {
                    DbgPrint("Could not allocate AddrSubnetHashTable");
                    g_dwMakingNewTable = FALSE;
                    ExReleaseResource(&FilterAddressLock );
                    return(UNKNOWN_IP_INDEX);
                }
            }

            RtlZeroMemory(AddrHashTable, AddrModulus * sizeof(PADDRESSARRAY));
            RtlZeroMemory(AddrSubnetHashTable,
                          AddrModulus * sizeof(PADDRESSARRAY));

            AddrTable = (IPAddrEntry *)ExAllocatePoolWithTag(
                                              NonPagedPool,
                                              dwOutBufLen,
                                              'pfAt');

            if(!AddrTable)
            {
                DbgPrint("Could not allocate AddrTable of size %d\n",
                               dwSpace);
                g_dwMakingNewTable = FALSE;
                ExReleaseResource(&FilterAddressLock );
                return(UNKNOWN_IP_INDEX);
            }
        }

        ID->toi_type = INFO_TYPE_PROVIDER;
        ID->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
        RtlZeroMemory( Context, CONTEXT_SIZE );

        Status = DoIpIoctl(
                              DD_TCP_DEVICE_NAME,
                              IOCTL_TCP_QUERY_INFORMATION_EX,
                              (PVOID)&trqiInBuf,
                              dwInBufLen,
                              (PVOID)AddrTable,
                              dwOutBufLen,
                              &dwFinalAddrSize); 

        if(!NT_SUCCESS(Status))
        {
            DbgPrint("Reading IP addr table failed %x\n", Status);
            ExFreePool(AddrTable);
            AddrTable = 0;
            g_dwMakingNewTable = FALSE;
            ExReleaseResource(&FilterAddressLock );
            return(UNKNOWN_IP_INDEX);
        }

        //
        // Now to get sleazy. Convert each IPAddrEntry into an ADDRESSARRAY
        // entry and hash it into the AddrHashTable. Note this depends
        // on the structures having common definitions and on
        // IPAddrEntry to be at least as large as ADDRESSARRAY. So be
        // careful.
        //

        dwFinalSize = dwFinalAddrSize / sizeof(IPAddrEntry);

        for(AddrTable1 = AddrTable;
            dwFinalSize;
            dwFinalSize--, AddrTable1++)
        {
            dwX = ADDRHASHX(AddrTable1->iae_addr);

            pa = (PADDRESSARRAY)AddrTable1;

            pa->ulSubnetBcastAddress = AddrTable1->iae_addr |
                                        ~AddrTable1->iae_mask;

            //
            // Now hash it into the hash table
            //

            pa->pNext = AddrHashTable[dwX];
            AddrHashTable[dwX] = pa;

            //
            // and do a hash on the subnet address as well
            //

            dwX = ADDRHASHX(pa->ulSubnetBcastAddress);
            pa->pNextSubnet = AddrSubnetHashTable[dwX];
            AddrSubnetHashTable[dwX] = pa;
        }

        //
        // allow the DPC match code to use the table. Note
        // this does not require interlocking since storing
        // memory is atomic.
        //
        g_dwMakingNewTable = FALSE;
    }

    //
    // search the table for the address.
    //

    dwIpIndex = LocalIpLook(Addr);

    ExReleaseResource(&FilterAddressLock );
    return(dwIpIndex);
}

BOOL
MatchLocalLook(DWORD Addr, DWORD dwIndex)
/*++
Routine Description:
  Called from the Match code, probably at DPC level, to
  check an address. If the address table is being rebuilt
  just return success. See inner comment for more on this
--*/
{
    BOOL fRet;
    KIRQL kirql;

    if(!BMAddress(Addr))
    {
        //
        // Look it up.  Note that if the table is being rebuilt,
        // this succeeds. This is a security hole but it is very
        // small and nearly impossible to exploit effectively and
        // the alternative, denying this, is even worse.
        //  ArnoldM 19-Sept-1997.
        //
        AcquireReadLock(&g_IpTableSpin, &kirql);
        if(AddrTable && !g_dwMakingNewTable)
        {
            DWORD dwLookupIndex = LocalIpLook(Addr);

            //
            // the address is acceptable if it belongs to
            // the arriving interface or if it belongs to
            // no interfaces. The latter is the route-through case.
            //
            if((dwIndex == dwLookupIndex)
                         ||
               (dwLookupIndex == UNKNOWN_IP_INDEX) )
            {
                fRet = TRUE;
            }
            else
            {
                fRet = FALSE;
            }
        }
        else
        {
            fRet = TRUE;
        }
        ReleaseReadLock(&g_IpTableSpin, kirql);
    }
    else
    {
        fRet = TRUE;
    }
    return(fRet);
}
        
DWORD
LocalIpLook(DWORD Addr)
/*++
Routine Description:
  Called to lookup an address in the address hash tables. The caller
  either must hold the g_IpTableSpin read sping lock or must hold
  the FilterAddressLock resource. This should never be called
  while the address table is being built and holding one of
  these locks insures this.
--*/
{
    DWORD dwIpIndex, dwX;
    PADDRESSARRAY  pa;

    dwX = ADDRHASHX(Addr);

    for(pa = AddrHashTable[dwX]; pa; pa = pa->pNext)
    {
        if(pa->ulAddress == Addr)
        {
            dwIpIndex = pa->ulIndex;
            goto alldone;   // ugly but faster than a break and another test.
        }
    }

    for(pa = AddrSubnetHashTable[dwX]; pa; pa = pa->pNextSubnet)
    {
        if(pa->ulSubnetBcastAddress == Addr)
        {
            dwIpIndex = pa->ulIndex;
            goto alldone;
        }
    }

    //
    // not found. Deliver the bad news.
    //
    dwIpIndex = UNKNOWN_IP_INDEX;

alldone:
    return(dwIpIndex);
}

BOOLEAN
PfFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    DWORD dwSize;
    PPAGED_FILTER_INTERFACE pPage;
    NTSTATUS ntStatus;

    switch(IoControlCode)
    {
        default:
            return(FALSE);

        case IOCTL_PF_IP_ADDRESS_LOOKUP:

            //
            // do a dummy fetch to make it recompute.
            //
            if((InputBufferLength < sizeof(DWORD))
                         ||
               (OutputBufferLength < sizeof(DWORD)) )
            {
                return(FALSE);
            }
 
            *(PDWORD)OutputBuffer = GetIpStackIndex(*(PDWORD)InputBuffer, TRUE);
            ntStatus = STATUS_SUCCESS;
            break;

        case IOCTL_PF_DELETE_BY_HANDLE:
            if(InputBufferLength < sizeof(PFDELETEBYHANDLE))
            {
                return(FALSE);
            }

            ntStatus = LockFcb(FileObject);
            if(!NT_SUCCESS(ntStatus))
            {
                return(FALSE);
            }
            pPage = FindInterfaceOnHandle(
                    FileObject,
                    ((PPFDELETEBYHANDLE)InputBuffer)->pvDriverContext);

            if(!pPage)
            {
                UnLockFcb(FileObject);
                return(FALSE);
            }
            ntStatus = DeleteByHandle(
                                 (PPFFCB)FileObject->FsContext2,
                                 pPage,
                                 &((PPFDELETEBYHANDLE)InputBuffer)->pvHandles[0],
                                 InputBufferLength - sizeof(PVOID));

            UnLockFcb(FileObject);
            break;

        case IOCTL_DELETE_INTERFACE_FILTERS_EX:
        {

            //
            // The minimum size is without any TOCs
            //

            dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);

            if(InputBufferLength < dwSize)
            {
                return(FALSE);
            }

            ntStatus = LockFcb(FileObject);
            if(!NT_SUCCESS(ntStatus))
            {
                return(FALSE);
            }
            pPage = FindInterfaceOnHandle(
                    FileObject,
                    ((PFILTER_DRIVER_SET_FILTERS)InputBuffer)->pvDriverContext);

            if(!pPage)
            {
                UnLockFcb(FileObject);
                return(FALSE);
            }
            ntStatus = UnSetFiltersEx(
                                 (PPFFCB)FileObject->FsContext2,
                                 pPage,
                                 InputBufferLength,
                                 (PFILTER_DRIVER_SET_FILTERS)InputBuffer);
 
            UnLockFcb(FileObject);
            break;
        }

        case IOCTL_GET_SYN_COUNTS:
        {
            if(OutputBufferLength < sizeof(FILTER_DRIVER_GET_SYN_COUNT))
            {
                return(FALSE);
            }

            ntStatus = GetSynCountTotal(
                         (PFILTER_DRIVER_GET_SYN_COUNT)OutputBuffer);
            break;

        }

        case IOCTL_SET_INTERFACE_FILTERS_EX:
        {

            //
            // Make sure the caller is using symmetric buffers. If not
            // do it the slow way
            //
            if((InputBuffer != OutputBuffer)
                        ||
               (InputBufferLength != OutputBufferLength))
            {
                return(FALSE);
            }

            //
            // The minimum size is without any TOCs
            //

            dwSize = sizeof(FILTER_DRIVER_SET_FILTERS) - sizeof(RTR_TOC_ENTRY);

            if(InputBufferLength < dwSize)
            {
                return(FALSE);
            }

            ntStatus = LockFcb(FileObject);
            if(!NT_SUCCESS(ntStatus))
            {
                return(FALSE);
            }
            pPage = FindInterfaceOnHandle(
                    FileObject,
                    ((PFILTER_DRIVER_SET_FILTERS)InputBuffer)->pvDriverContext);

            if(!pPage)
            {
                UnLockFcb(FileObject);
                return(FALSE);
            }
            ntStatus = SetFiltersEx(
                                    (PPFFCB)FileObject->FsContext2,
                                    pPage,
                                    InputBufferLength,
                                    (PFILTER_DRIVER_SET_FILTERS)InputBuffer);
            UnLockFcb(FileObject);
            break;
        }
    }
    IoStatus->Status = ntStatus;
    IoStatus->Information = OutputBufferLength;
    return(TRUE);
}

NTSTATUS
LockFcb(
    IN struct _FILE_OBJECT *FileObject)
/*++
  Routine Description:
     Lock an FCB. Check if the FCB is on the master list and if
     it is still valid. On success, returns with the FCB resource locked
     and the FCB referenced.
--*/
{
    PPFFCB Fcb = (PPFFCB)FileObject->FsContext2;
    KIRQL kirql;
    PLIST_ENTRY List;
    PPFFCB Fcb1 = 0;

    KeAcquireSpinLock(&g_FcbSpin, &kirql);

    for(List = g_leFcbs.Flink;
        List != &g_leFcbs;
        List = List->Flink)
    {
        Fcb1 = CONTAINING_RECORD(List, PFFCB, leList);

        //
        // use it if it is not being closed
        //
        if(Fcb1 == Fcb)
        {
            if( !(Fcb->dwFlags & PF_FCB_CLOSED) )
            {
                InterlockedIncrement(&Fcb->UseCount);
            }
            else
            {
                Fcb1 = 0;
            }
            break;
        }
    }

    KeReleaseSpinLock(&g_FcbSpin, kirql);

    if(Fcb != Fcb1)
    {
        //
        // didn't find it.
        //

        return(STATUS_INVALID_PARAMETER);
    }

    //
    // found it. Lock it up. 
    //

    ExAcquireResourceExclusive( &Fcb->Resource, TRUE );

    //
    // must look one more time to see if it has been closed. This can
    // happen if the closer sneaked in. So we have to become the closer.
    //
    if(Fcb->dwFlags & PF_FCB_CLOSED)
    {
        //
        // it was. Unlock it and return an error
        //
        UnLockFcb(FileObject);
        return(STATUS_INVALID_PARAMETER);
    }
    return(STATUS_SUCCESS);
}

VOID
UnLockFcb(
    IN struct _FILE_OBJECT *FileObject)
/*++
  Routine Description:
    Unlock and derefence an FCB. If the reference count becomes zero,
    remove the FCB from the master list and close it.
--*/
{
    PPFFCB Fcb = (PPFFCB)FileObject->FsContext2;
    KIRQL kirql;

    KeAcquireSpinLock(&g_FcbSpin, &kirql);
    if(InterlockedDecrement(&Fcb->UseCount) <= 0)
    {
        ASSERT(Fcb->dwFlags & PF_FCB_CLOSED);
        RemoveEntryList(&Fcb->leList);
        KeReleaseSpinLock(&g_FcbSpin, kirql);
        CloseFcb(Fcb, FileObject);
    }
    else
    {
        KeReleaseSpinLock(&g_FcbSpin, kirql);
        ExReleaseResourceLite( &Fcb->Resource );
    }
}

VOID
PFReadRegistryParameters(PUNICODE_STRING RegistryPath)
/*++
  Routine Description:
    Called when the driver is loaded. Reads registry paramters
    for configuring the driver
--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE PFHandle;
    HANDLE PFParHandle;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ULONG Storage[8];
    PKEY_VALUE_PARTIAL_INFORMATION Value =
               (PKEY_VALUE_PARTIAL_INFORMATION)Storage;

    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,               // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey (&PFHandle, KEY_READ, &ObjectAttributes);

    RtlInitUnicodeString(&UnicodeString, L"Parameters");

    if(NT_SUCCESS(Status))
    {

        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            PFHandle,
            NULL
            );


        Status = ZwOpenKey (&PFParHandle, KEY_READ, &ObjectAttributes);

        ZwClose(PFHandle);

        if(NT_SUCCESS(Status))
        {
            ULONG BytesRead;

            RtlInitUnicodeString(&UnicodeString, L"AddressHashSize");

            Status = ZwQueryValueKey(
                            PFParHandle,
                            &UnicodeString,
                            KeyValuePartialInformation,
                            Value,
                            sizeof(Storage),
                            &BytesRead);

            if(NT_SUCCESS(Status)
                   &&
               (Value->Type == REG_DWORD) )
            {
                AddrModulus = *(PULONG)Value->Data;
            }

            RtlInitUnicodeString(&UnicodeString, L"FragmentThreshold");

            Status = ZwQueryValueKey(
                            PFParHandle,
                            &UnicodeString,
                            KeyValuePartialInformation,
                            Value,
                            sizeof(Storage),
                            &BytesRead);

            if(NT_SUCCESS(Status)
                   &&
               (Value->Type == REG_DWORD) )
            {
                g_FragThresholdSize = *(PULONG)Value->Data;
            }

            ZwClose(PFParHandle);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\ioctl.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ioctl.c

Abstract:


Author:



Revision History:

--*/

/*----------------------------------------------------------------------------
A note on the interlocking, as of 24-Feb-1997.

There are two important locks: the FilterListResourceLock which is
a resource and the  g_filter.ifListLock, which is a spin lock but acts
like a resource. The former is used to serialize API access to interface state
and filters. The latter is used to serialize DPC access.

----------------------------------------------------------------------------*/

#include "globals.h"


ERESOURCE FilterListResourceLock;
BOOL  fCheckDups = FALSE;

extern NPAGED_LOOKASIDE_LIST filter_slist;
extern PAGED_LOOKASIDE_LIST paged_slist;

NTSTATUS
UpdateMatchBindingInformation(
                         PFILTER_DRIVER_BINDING_INFO pBindInfo,
                         PVOID                       pvContext
                         );

NTSTATUS
CreateCommonInterface(PPAGED_FILTER_INTERFACE pPage,
                      DWORD dwBind,
                      DWORD dwName,
                      DWORD dwFlags);

VOID
FreePagedFilterList(PPFFCB Fcb,
                    PPAGED_FILTER pIn,
                    PPAGED_FILTER_INTERFACE pPage,
                    PDWORD pdwRemoved);

VOID
DeleteFilterList(PLIST_ENTRY pList);

BOOL
IsOnSpecialFilterList(PPAGED_FILTER pPageFilter,
                      PLIST_ENTRY   List,
                      PPAGED_FILTER * pPageHit);

PPAGED_FILTER
IsOnPagedInterface(PPAGED_FILTER pPageFilter,
                   PPAGED_FILTER_INTERFACE pPage);

PPAGED_FILTER
MakePagedFilter(
               IN  PPFFCB         Fcb,
               IN  PFILTER_INFOEX pInfo,
               IN  DWORD          dwEpoch,
               DWORD              dwFlags
               );

VOID
NotifyFastPath( PFILTER_INTERFACE pIf, DWORD dwIndex, DWORD dwCode);

VOID
NotifyFastPathIf( PFILTER_INTERFACE pIf);

NTSTATUS
DeleteByHandle(
           IN PPFFCB                      Fcb,
           IN PPAGED_FILTER_INTERFACE     pPage,
           IN PVOID *                     ppHandles,
           IN DWORD                       dwLength);

NTSTATUS
CheckFilterAddress(DWORD dwAdd, PFILTER_INTERFACE pIf);

VOID
AddFilterToInterface(
    PFILTER pMatch,
    PFILTER_INTERFACE pIf,
    BOOL   fInFilter,
    PFILTER * ppFilter);

VOID
RemoveFilterWorker(
    PPFFCB         Fcb,
    PFILTER_INFOEX pFilt,
    DWORD          dwCount,
    PPAGED_FILTER_INTERFACE pPage,
    PDWORD         pdwRemoved,
    BOOL           fInFilter);

NTSTATUS
AllocateAndAddFilterToMatchInterface(
                              PPFFCB         Fcb,
                              PFILTER_INFOEX pInfo,
                              BOOL     fInFilter,
                              PPAGED_FILTER_INTERFACE pPage,
                              PBOOL          pbAdded,
                              PPAGED_FILTER * ppFilter);

#pragma alloc_text(PAGED, SetFiltersEx)
#pragma alloc_text(PAGED, NewInterface)
#pragma alloc_text(PAGED, MakeNewFilters)
#pragma alloc_text(PAGED, GetPointerToTocEntry)
//#pragma alloc_text(PAGED, AddNewInterface)
#pragma alloc_text(PAGED, MakePagedFilter)
#pragma alloc_text(PAGED, AllocateAndAddFilterToMatchInterface)
#pragma alloc_text(PAGED, IsOnSpecialFilterList)
#pragma alloc_text(PAGED, IsOnPagedInterface)
#pragma alloc_text(PAGED, UnSetFiltersEx)
#pragma alloc_text(PAGED, DeleteByHandle)
#pragma alloc_text(PAGED, DeletePagedInterface)


#define HandleHash(x)  HashList[(x) + g_dwHashLists]

#define IsValidInterface(pIf)   (pIf != 0)

#define NOT_RESTRICTION   1
#define NOT_UNBIND        2

#if DOFRAGCHECKING
DWORD
GetFragIndex(DWORD dwProt)
{
    switch(dwProt)
    {
        case FILTER_PROTO_ICMP:
            return FRAG_ICMP;
        case FILTER_PROTO_UDP:
            return FRAG_UDP;
        case FILTER_PROTO_TCP:
            return FRAG_TCP;
    }
    return FRAG_OTHER;
}
#endif

BOOL CheckDescriptorSize(PFILTER_DESCRIPTOR2 pdsc, PBYTE pbEnd)
{
    PFILTER_INFOEX pFilt = &pdsc->fiFilter[0];


    //
    // Check that there is a full header structure and that
    // the claimed number of filters is present.
    //
    if(((PBYTE)pFilt > pbEnd)
              ||
       ((PBYTE)(&pFilt[pdsc->dwNumFilters]) > pbEnd) )
    {
        return(FALSE);
    }

    return(TRUE);
}


BOOL
WildFilter(PFILTER pf)
{
#if WILDHASH
    if(pf->dwFlags & FILTER_FLAGS_INFILTER)
    {
        if(pf->dwFlags & FILTER_FLAGS_DSTWILD)
        {
            return(TRUE);
        }
    }
    else
    {
        if(pf->dwFlags & FILTER_FLAGS_SRCWILD)
        {
            return(TRUE);
        }
    }
    return(FALSE);
#else
    return(ANYWILDFILTER(pf))
#endif
}

//
// N.B. If WILDHASH is on, then there is code in match.c that
// does a similar computation. Hence if this changes, then that
// must also.
//

#if WILDHASH
DWORD
ComputeMatchHashIndex(PFILTER pf, PBOOL pfWild)
{
    DWORD dwX;

    *pfWild = TRUE;

    if(!ANYWILDFILTER(pf))
    {
        *pfWild = FALSE;

        dwX =     (pf->SRC_ADDR                       +
                   pf->DEST_ADDR                      +
                   pf->DEST_ADDR                      +
                   PROTOCOLPART(pf->uliProtoSrcDstPort.LowPart)     +
                   pf->uliProtoSrcDstPort.HighPart);

    }
    else if(WildFilter(pf))
    {
        if(pf->dwFlags & FILTER_FLAGS_INFILTER)
        {
            dwX = g_dwHashLists;
        }
        else
        {
            dwX = g_dwHashLists + 1;
        }
        *pfWild = FALSE;
        return(dwX);
    }
    else if(pf->dwFlags & FILTER_FLAGS_INFILTER)
    {
        dwX = pf->DEST_ADDR                      +
              pf->DEST_ADDR                      +
              PROTOCOLPART(pf->uliProtoSrcDstPort.LowPart)     +
              HIWORD(pf->uliProtoSrcDstPort.HighPart);
    }
    else
    {
        dwX = pf->SRC_ADDR                       +
              PROTOCOLPART(pf->uliProtoSrcDstPort.LowPart)     +
              LOWORD(pf->uliProtoSrcDstPort.HighPart);
    }
    return(dwX % g_dwHashLists);
}

#else   // WILDHASH

__inline
DWORD
ComputeMatchHashIndex(PFILTER pf, PBOOL pfWild)
{
    DWORD dwX;

    if(WildFilter(pf))
    {
        if(pf->dwFlags & FILTER_FLAGS_SRCWILD)
        {
            dwX = g_dwHashLists;
        }
        else
        {
            dwX = g_dwHashLists + 1;
        }
        return(dwIndex);
    }
    dwX =     (pf->SRC_ADDR                       +
               pf->DEST_ADDR                      +
               pf->DEST_ADDR                      +
               PROTOCOLPART(pf->uliProtoSrcDstPort.LowPart)     +
               pf->uliProtoSrcDstPort.HighPart) % g_dwHashLists;
    return(dwX);
}
#endif     // WILDHASH

PFILTER_INTERFACE
FindMatchName(DWORD dwName, DWORD dwBind)
/*++
  Routine Description:
    Find an interface with the same name or with the
    same binding. The calller must have locked the
    resource
--*/
{
    PFILTER_INTERFACE pIf1;
    PLIST_ENTRY pList;

    for(pList = g_filters.leIfListHead.Flink;
        pList != &g_filters.leIfListHead;
        pList = pList->Flink)
    {

        pIf1 = CONTAINING_RECORD(pList, FILTER_INTERFACE, leIfLink);

        if((pIf1->dwName && (dwName == pIf1->dwName))
                        ||
           ((pIf1->dwIpIndex != UNKNOWN_IP_INDEX)
                          &&
            (pIf1->dwIpIndex == dwBind)) )
        {
            return(pIf1);
        }
    }
    return(NULL);
}

VOID
RemoveGlobalFilterFromInterface(PFILTER_INTERFACE pIf,
                                DWORD dwType)
{
    LOCK_STATE LockState;

    //
    // lock up the filters
    //
    
    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    switch(dwType)
    {
        case PFE_SYNORFRAG:
            pIf->CountSynOrFrag.lInUse--;
            if(pIf->CountSynOrFrag.lInUse == 0)
            {
                pIf->CountSynOrFrag.lCount = 0;
            }
            break;

        case PFE_SPOOF:
            pIf->CountSpoof.lInUse--;
            if(pIf->CountSpoof.lInUse == 0)
            {
                pIf->CountSpoof.lCount = 0;
            }
            break;

        case PFE_UNUSEDPORT:
            pIf->CountUnused.lInUse--;
            if(pIf->CountUnused.lInUse == 0)
            {
                pIf->CountUnused.lCount = 0;
            }
            break;

        case PFE_STRONGHOST:
            pIf->CountStrongHost.lInUse--;
            if(pIf->CountStrongHost.lInUse == 0)
            {
                pIf->CountStrongHost.lCount = 0;
            }
            break;

        case PFE_ALLOWCTL:
            pIf->CountCtl.lInUse--;
            if(pIf->CountCtl.lInUse == 0)
            {
                pIf->CountCtl.lCount = 0;
            }
            break;

        case PFE_FULLDENY:
           pIf->CountFullDeny.lInUse--;
           if(pIf->CountFullDeny.lInUse == 0)
           {
               pIf->CountFullDeny.lCount = 0;
           }
           break;

        case PFE_NOFRAG:
           pIf->CountNoFrag.lInUse--;
           if(pIf->CountNoFrag.lInUse == 0)
           {
               pIf->CountNoFrag.lCount = 0;
           }
           break;

        case PFE_FRAGCACHE:
           pIf->CountFragCache.lInUse--;
           if(pIf->CountFragCache.lInUse == 0)
           {
               pIf->CountFragCache.lCount = 0;
           }
           break;
    }
    ReleaseWriteLock(&g_filters.ifListLock,&LockState);
}

VOID
AddGlobalFilterToInterface(PPAGED_FILTER_INTERFACE pPage,
                           PFILTER_INFOEX  pfilt)
{
    PFILTER_INTERFACE pIf = pPage->pFilter;
    LOCK_STATE LockState;

    //
    // lock up the filters
    //
    
    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    switch(pfilt->type)
    {
        case PFE_SYNORFRAG:
            pIf->CountSynOrFrag.lInUse++;
            break;

        case PFE_SPOOF:
            pIf->CountSpoof.lInUse++;
            break;

        case PFE_UNUSEDPORT:

            pIf->CountUnused.lInUse++;
            break;

        case PFE_STRONGHOST:
            pIf->CountStrongHost.lInUse++;
            break;

        case PFE_ALLOWCTL:
            pIf->CountCtl.lInUse++;
            break;

        case PFE_FULLDENY:
            pIf->CountFullDeny.lInUse++;
            break;

        case PFE_NOFRAG:
            pIf->CountNoFrag.lInUse++;
            break;

        case PFE_FRAGCACHE:
            pIf->CountFragCache.lInUse++;
            break;
    }
    ReleaseWriteLock(&g_filters.ifListLock,&LockState);
}

/*++
Start of old STEELHEAD APIS routines.
--*/

#if STEELHEAD
NTSTATUS
AddInterface(
             IN  PVOID pvRtrMgrCtxt,
             IN  DWORD dwRtrMgrIndex,
             IN  DWORD dwAdapterId,
             IN  PPFFCB Fcb,
             OUT PVOID *ppvFltrDrvrCtxt
             )

/*++
  Routine Description
      Adds an interface to the filter driver and makes an association between context
      passed in and interface created

  Arguments
      pvRtrMgrCtxt   - Context passed in
      pvFltrDrvrCtxt - Handle to interface created

  Return Value
--*/
{
    PFILTER_INTERFACE   pIf;
    LOCK_STATE          LockState;
    NTSTATUS            Status;

    if(Fcb->dwFlags & PF_FCB_NEW)
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Fcb->dwFlags |= PF_FCB_OLD;

    pIf = NewInterface(pvRtrMgrCtxt,
                       dwRtrMgrIndex,
                       FORWARD,
                       FORWARD,
                       (PVOID)Fcb,
                       dwAdapterId,
                       0);

    if(pIf is NULL)
    {
        return STATUS_NO_MEMORY;
    }

    //
    // lock the resource that protects adding new interfaces. This
    // is needed to hold off others until everything is properly
    // verified. The spin lock is insufficient for this.
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&FilterListResourceLock, TRUE);

    //
    // Check for a name conflict
    //

    if(FindMatchName(0, dwAdapterId))
    {
        ExFreePool(pIf);
        Status = STATUS_DEVICE_BUSY;
    }
    else
    {
        pIf->dwGlobalEnables |= FI_ENABLE_OLD;

        *ppvFltrDrvrCtxt = (PVOID)pIf;

        AcquireWriteLock(&g_filters.ifListLock,&LockState);

        InsertTailList(&g_filters.leIfListHead,&pIf->leIfLink);

        ReleaseWriteLock(&g_filters.ifListLock,&LockState);
        Status = STATUS_SUCCESS;

    }
    ExReleaseResourceLite(&FilterListResourceLock);
    KeLeaveCriticalRegion();

    return(Status);
}

NTSTATUS
DeleteInterface(
                IN  PVOID pvIfContext
                )
/*++
  Routine Description
      Deletes an interface and all the filters associated with it
      Clears the cache

  Arguments
      pvRtrMgrCtxt   - Context passed in
      pvFltrDrvrCtxt - Handle to interface created

  Return Value
--*/
{
    PFILTER_INTERFACE   pIf;
    LOCK_STATE          LockState;

    pIf = (PFILTER_INTERFACE)pvIfContext;

    if(!IsValidInterface(pIf) || !(pIf->dwGlobalEnables & FI_ENABLE_OLD))
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&FilterListResourceLock, TRUE);

    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    DeleteFilters(pIf,
                  IN_FILTER_SET);

    DeleteFilters(pIf,
                  OUT_FILTER_SET);

    RemoveEntryList(&pIf->leIfLink);

    ClearCache();

    ReleaseWriteLock(&g_filters.ifListLock,&LockState);

    ExReleaseResourceLite(&FilterListResourceLock);
    KeLeaveCriticalRegion();

    return STATUS_SUCCESS;
}

NTSTATUS
SetFilters(
           IN  PFILTER_DRIVER_SET_FILTERS  pRtrMgrInfo
           )
/*++
  Routine Description
      Adds the set of in and out filters passed to the interface (identified by the
      context). Also sets the default actions.
      Clears the cache

  Arguments
      pInfo     Pointer to info passed by the router manager

  Return Value

--*/
{
    PFILTER_INTERFACE   pIf;
    LOCK_STATE          LockState;
    NTSTATUS            ntStatus;
    DWORD               dwNumInFilters,dwNumOutFilters;
    FORWARD_ACTION      faInAction,faOutAction;
    PFILTER_DESCRIPTOR  pFilterDesc;
    PRTR_TOC_ENTRY      pInToc,pOutToc;
    LIST_ENTRY          InList, OutList;

    //
    // Sensible defaults
    //

    dwNumInFilters  = dwNumOutFilters   = 0;
    faInAction      = faOutAction       = FORWARD;

    pIf = (PFILTER_INTERFACE)pRtrMgrInfo->pvDriverContext;

    if(!IsValidInterface(pIf) || !(pIf->dwGlobalEnables & FI_ENABLE_OLD))
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    pInToc  = GetPointerToTocEntry(IP_FILTER_DRIVER_IN_FILTER_INFO,
                                   &pRtrMgrInfo->ribhInfoBlock);

    pOutToc = GetPointerToTocEntry(IP_FILTER_DRIVER_OUT_FILTER_INFO,
                                   &pRtrMgrInfo->ribhInfoBlock);

    if(!pInToc && !pOutToc)
    {
        //
        // Nothing to change
        //

        TRACE(CONFIG,(
            "IPFLTDRV: Both filter set TOCs were null so nothing to change"
            ));

        return STATUS_SUCCESS;
    }

    if(pInToc)
    {
        //
        // If the infosize is 0, the filters will get deleted and default action
        // set to FORWARD. If infosize isnot 0 but the number of filters in the
        // descriptor is zero, the old filters will get deleted, no new filters
        // will be added, but the default action will be the one specified in the
        // descriptor. If Infosize is not 0 and number od filters is also not zero
        // then old filters will get deleted, new filters created and default
        // action set to what is specified in the
        //

        if(pInToc->InfoSize)
        {
            pFilterDesc  = GetInfoFromTocEntry(&pRtrMgrInfo->ribhInfoBlock,
                                               pInToc);

            if(pFilterDesc->dwVersion != 1)
            {
                return(STATUS_INVALID_PARAMETER);
            }
            if(!NT_SUCCESS( ntStatus = MakeNewFilters(pFilterDesc->dwNumFilters,
                                                      pFilterDesc->fiFilter,
                                                      TRUE,
                                                      &InList)))

            {
                ERROR(("IPFLTDRV: MakeNewFilters failed\n"));

                return ntStatus;
            }

            dwNumInFilters  = pFilterDesc->dwNumFilters;
            faInAction      = pFilterDesc->faDefaultAction;
        }
    }

    if(pOutToc)
    {

        if(pOutToc->InfoSize isnot 0)
        {
            pFilterDesc  = GetInfoFromTocEntry(&pRtrMgrInfo->ribhInfoBlock,
                                               pOutToc);

            if(pFilterDesc->dwVersion != 1)
            {
                ntStatus = STATUS_INVALID_PARAMETER;
                DeleteFilterList(&InList);
                return ntStatus;
            }

            if(!NT_SUCCESS( ntStatus = MakeNewFilters(pFilterDesc->dwNumFilters,
                                                      pFilterDesc->fiFilter,
                                                      FALSE,
                                                      &OutList)))
            {
                ERROR(("IPFLTDRV: MakeNewFilters failed - %x\n", ntStatus));
                DeleteFilterList(&InList);
                return ntStatus;
            }

            dwNumOutFilters  = pFilterDesc->dwNumFilters;
            faOutAction      = pFilterDesc->faDefaultAction;
        }
    }

    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    //
    // If new info was given, then blow away the old filters
    // If new filters were also given, then add them
    //

    if(pInToc)
    {

        DeleteFilters(pIf, IN_FILTER_SET);

        if(dwNumInFilters)
        {
            InList.Flink->Blink = &pIf->pleInFilterSet;
            InList.Blink->Flink = &pIf->pleInFilterSet;
            pIf->pleInFilterSet   = InList;
        }
        pIf->dwNumInFilters = dwNumInFilters;
        pIf->eaInAction     = faInAction;

    }

    if(pOutToc)
    {
        DeleteFilters(pIf, OUT_FILTER_SET);

        if(dwNumOutFilters)
        {
            OutList.Flink->Blink = &pIf->pleOutFilterSet;
            OutList.Blink->Flink = &pIf->pleOutFilterSet;
            pIf->pleOutFilterSet   = OutList;
        }
        pIf->dwNumOutFilters    = dwNumOutFilters;
        pIf->eaOutAction        = faOutAction;
    }

    ClearCache();

    ReleaseWriteLock(&g_filters.ifListLock,&LockState);

    return(STATUS_SUCCESS);
}

NTSTATUS
UpdateBindingInformation(
                         PFILTER_DRIVER_BINDING_INFO pBindInfo,
                         PVOID                       pvContext
                         )
/*++
  Routine Description
      Gets filters and statistics associated with an interface
      It is called with the Spin Lock held as reader

  Arguments
      pvIf    Pointer to FILTER_INTERFACE structure which was passed as a PVOID
              to router manager as a context for the interface
      pInfo   FILTER_IF structure filled in by driver

  Return Value

--*/
{
    PFILTER_INTERFACE   pIf;
    LOCK_STATE          LockState;
    PFILTER             pf;
    DWORD               i;
    PLIST_ENTRY         List;

    pIf = (PFILTER_INTERFACE)pvContext;

    if(!IsValidInterface(pIf) || !(pIf->dwGlobalEnables & FI_ENABLE_OLD))
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    AcquireWriteLock(&g_filters.ifListLock,&LockState);


    for(List = pIf->pleInFilterSet.Flink;
        List != &pIf->pleInFilterSet;
        List = List->Flink)
    {
        pf = CONTAINING_RECORD(List, FILTER, pleFilters);

        if(AreAllFieldsUnchanged(pf))
        {
            continue;
        }

        if(DoesSrcAddrUseLocalAddr(pf))
        {
            pf->SRC_ADDR  = pBindInfo->dwLocalAddr;
        }
        else if(DoesSrcAddrUseRemoteAddr(pf))
        {
            pf->SRC_ADDR  = pBindInfo->dwRemoteAddr;
        }

        if(DoesDstAddrUseLocalAddr(pf))
        {
            pf->DEST_ADDR  = pBindInfo->dwLocalAddr;
        }
        else if(DoesDstAddrUseRemoteAddr(pf))
        {
            pf->DEST_ADDR  = pBindInfo->dwRemoteAddr;
        }

        if(IsSrcMaskLateBound(pf))
        {
            pf->SRC_MASK = pBindInfo->dwMask;
        }

        if(IsDstMaskLateBound(pf))
        {
            pf->DEST_MASK = pBindInfo->dwMask;
        }
    }


    for(List = pIf->pleOutFilterSet.Flink;
        List != &pIf->pleOutFilterSet;
        List = List->Flink)
    {
        pf = CONTAINING_RECORD(List, FILTER, pleFilters);

        if(AreAllFieldsUnchanged(pf))
        {
            continue;
        }

        if(DoesSrcAddrUseLocalAddr(pf))
        {
            pf->SRC_ADDR  = pBindInfo->dwLocalAddr;
        }

        if(DoesSrcAddrUseRemoteAddr(pf))
        {
            pf->SRC_ADDR  = pBindInfo->dwRemoteAddr;
        }

        if(DoesDstAddrUseLocalAddr(pf))
        {
            pf->SRC_ADDR  = pBindInfo->dwLocalAddr;
        }

        if(DoesDstAddrUseRemoteAddr(pf))
        {
            pf->SRC_ADDR  = pBindInfo->dwRemoteAddr;
        }

        if(IsSrcMaskLateBound(pf))
        {
            pf->SRC_MASK = pBindInfo->dwMask;
        }

        if(IsDstMaskLateBound(pf))
        {
            pf->DEST_MASK = pBindInfo->dwMask;
        }
    }

    ClearCache();

    ReleaseWriteLock(&g_filters.ifListLock,&LockState);

    return STATUS_SUCCESS;
}


NTSTATUS
GetFilters(
           IN  PFILTER_INTERFACE  pIf,
           IN  BOOL               fClear,
           OUT PFILTER_IF         pInfo
           )
/*++
  Routine Description
      Gets filters and statistics associated with an interface
      It is called with the Spin Lock held as reader

  Arguments
      pvIf    Pointer to FILTER_INTERFACE structure which was passed as a PVOID
              to router manager as a context for the interface
      pInfo   FILTER_IF structure filled in by driver

  Return Value

--*/
{
    DWORD i,dwNumInFilters,dwNumOutFilters;
    PFILTER pf;
    PLIST_ENTRY List;

    if(!IsValidInterface(pIf) || !(pIf->dwGlobalEnables & FI_ENABLE_OLD))
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    dwNumInFilters = pIf->dwNumInFilters;
    dwNumOutFilters = pIf->dwNumOutFilters;

    i = 0;

    for(List = pIf->pleInFilterSet.Flink;
        List != &pIf->pleInFilterSet;
        i++, List = List->Flink)
    {
        pf = CONTAINING_RECORD(List, FILTER, pleFilters);

        pInfo->filters[i].dwNumPacketsFiltered = (DWORD)pf->Count.lCount;
        if(fClear)
        {
            pf->Count.lCount = 0;
        }

        pInfo->filters[i].info.dwSrcAddr  = pf->SRC_ADDR;
        pInfo->filters[i].info.dwSrcMask  = pf->SRC_MASK;
        pInfo->filters[i].info.dwDstAddr  = pf->DEST_ADDR;
        pInfo->filters[i].info.dwDstMask  = pf->DEST_MASK;
        pInfo->filters[i].info.dwProtocol = pf->PROTO;
        pInfo->filters[i].info.fLateBound = pf->fLateBound;

        if(pInfo->filters[i].info.dwProtocol is FILTER_PROTO_ICMP)
        {
            if(LOBYTE(LOWORD(pf->uliProtoSrcDstMask.HighPart)) isnot 0xff)
            {
                pInfo->filters[i].info.wSrcPort   = FILTER_ICMP_TYPE_ANY;
            }
            else
            {
                pInfo->filters[i].info.wSrcPort   =
                  MAKEWORD(LOBYTE(LOWORD(pf->uliProtoSrcDstPort.HighPart)),0x00);
            }

            if(HIBYTE(LOWORD(pf->uliProtoSrcDstMask.HighPart)) isnot 0xff)
            {
                pInfo->filters[i].info.wDstPort   = FILTER_ICMP_CODE_ANY;
            }
            else
            {
                pInfo->filters[i].info.wDstPort   =
                  MAKEWORD(HIBYTE(LOWORD(pf->uliProtoSrcDstPort.HighPart)),0x00);
            }
        }
        else
        {
            pInfo->filters[i].info.wSrcPort =
              LOWORD(pf->uliProtoSrcDstPort.HighPart);
            pInfo->filters[i].info.wDstPort =
              HIWORD(pf->uliProtoSrcDstPort.HighPart);

            if(pInfo->filters[i].info.dwProtocol is FILTER_PROTO_TCP)
            {
                if(HIBYTE(LOWORD(pf->PROTO)))
                {
                    pInfo->filters[i].info.dwProtocol = FILTER_PROTO_TCP_ESTAB;
                }
            }
        }
    }

    i = 0;

    for(List = pIf->pleOutFilterSet.Flink;
        List != &pIf->pleOutFilterSet;
        i++, List = List->Flink)
    {
        pf = CONTAINING_RECORD(List, FILTER, pleFilters);

        pInfo->filters[i+dwNumInFilters].dwNumPacketsFiltered =
                         (DWORD)pf->Count.lCount;

        if(fClear)
        {
            pf->Count.lCount = 0;
        }

        pInfo->filters[i+dwNumInFilters].info.dwSrcAddr  = pf->SRC_ADDR;
        pInfo->filters[i+dwNumInFilters].info.dwSrcMask  = pf->SRC_MASK;
        pInfo->filters[i+dwNumInFilters].info.dwDstAddr  = pf->DEST_ADDR;
        pInfo->filters[i+dwNumInFilters].info.dwDstMask  = pf->DEST_MASK;
        pInfo->filters[i+dwNumInFilters].info.dwProtocol = pf->PROTO;
        pInfo->filters[i+dwNumInFilters].info.fLateBound = pf->fLateBound;

        if(pInfo->filters[i+dwNumInFilters].info.dwProtocol is FILTER_PROTO_ICMP)
        {
            if(LOBYTE(LOWORD(pf->uliProtoSrcDstMask.HighPart)) isnot 0xff)
            {
                pInfo->filters[i+dwNumInFilters].info.wSrcPort   = FILTER_ICMP_TYPE_ANY;
            }
            else
            {
                pInfo->filters[i+dwNumInFilters].info.wSrcPort   =
                  MAKEWORD(LOBYTE(LOWORD(pf->uliProtoSrcDstPort.HighPart)),0x00);
            }

            if(HIBYTE(LOWORD(pf->uliProtoSrcDstMask.HighPart)) isnot 0xff)
            {
                pInfo->filters[i+dwNumInFilters].info.wDstPort   = FILTER_ICMP_CODE_ANY;
            }
            else
            {
                pInfo->filters[i+dwNumInFilters].info.wDstPort   =
                  MAKEWORD(HIBYTE(LOWORD(pf->uliProtoSrcDstPort.HighPart)),0x00);
            }
        }
        else
        {
            pInfo->filters[i+dwNumInFilters].info.wSrcPort =
              LOWORD(pf->uliProtoSrcDstPort.HighPart);
            pInfo->filters[i+dwNumInFilters].info.wDstPort =
              HIWORD(pf->uliProtoSrcDstPort.HighPart);

            if(pInfo->filters[i].info.dwProtocol is FILTER_PROTO_TCP)
            {
                if(HIBYTE(LOWORD(pf->PROTO)))
                {
                    pInfo->filters[i].info.dwProtocol = FILTER_PROTO_TCP_ESTAB;
                }
            }
        }
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
MakeNewFilters(
               IN  DWORD        dwNumFilters,
               IN  PFILTER_INFO pFilterInfo,
               IN  BOOL         fInFilter,
               OUT PLIST_ENTRY  pList
               )
/*++
  Routine Description


  Arguments


  Return Value
--*/
{
    DWORD i;
    PFILTER pCurrent;
    DWORD dwFlags = (fInFilter ? FILTER_FLAGS_INFILTER : 0) |
                     FILTER_FLAGS_OLDFILTER;


    PAGED_CODE();

    InitializeListHead(pList);

    //
    // Allocate memory for the filters
    //

    if(!dwNumFilters)
    {
        return STATUS_SUCCESS;
    }


    for(i = 0; i < dwNumFilters; i++)
    {
        pCurrent = ExAllocatePoolWithTag(
                                      NonPagedPool,
                                      dwNumFilters * sizeof(FILTER),
                                      '2liF');
        if(!pCurrent)
        {
            ERROR((
                "IPFLTDRV: MakeNewFilters: Couldnt allocate memory for in filter set\n"
                ));
            DeleteFilterList(pList);
            return STATUS_NO_MEMORY;
        }

        InsertTailList(pList, &pCurrent->pleFilters);

        pCurrent->SRC_ADDR     = pFilterInfo[i].dwSrcAddr;
        pCurrent->DEST_ADDR    = pFilterInfo[i].dwDstAddr;
        pCurrent->SRC_MASK     = pFilterInfo[i].dwSrcMask;
        pCurrent->DEST_MASK    = pFilterInfo[i].dwDstMask;
        pCurrent->fLateBound   = pFilterInfo[i].fLateBound;
        pCurrent->dwFlags      = dwFlags;

        //
        // Now the network ordering stuff - tricky part
        // LP0    LP1 LP2 LP3 HP0 HP1 HP2 HP3
        // Proto  00  00  00  SrcPort DstPort
        //
        // If we have proto == TCP_ESTAB, LP1 is the flags
        //
        // LP0    LP1       LP2 LP3 HP0 HP1 HP2 HP3
        // Proto  TCPFlags  00  00  SrcPort DstPort
        //

        //
        // For addresses, ANY_ADDR is given by 0.0.0.0 and the MASK must be 0.0.0.0
        // For proto and ports 0 means any and the mask is generated as follows
        // If the proto is O then LP0 for Mask is 0xff else its 0x00
        // If a port is 0, the corresponding XP0XP1 is 0x0000 else its 0xffff
        //

        //
        // ICMP:
        // LP0  LP1  LP2  LP3  HP0 HP1 HP2 HP3
        // 0x1  00   00   00   Typ Cod 00  00
        // ICMP is different since 0 is a valid code and type, so 0xff is used by the
        // user to signify that ANY code or type is to be matched. However to do this
        // we need to have the field set to zero and the the mask set to 00 (for any).
        // But if the filter is specifically for Type/Code = 0 then the field is zero
        // with the mask as 0xff
        //

        //
        // The protocol is in the low byte of the dwProtocol, so we take that out and
        // make a dword out of it
        //

        pCurrent->uliProtoSrcDstPort.LowPart =
          MAKELONG(MAKEWORD(LOBYTE(LOWORD(pFilterInfo[i].dwProtocol)),0x00),0x0000);

        pCurrent->uliProtoSrcDstMask.LowPart = MAKELONG(MAKEWORD(0xff,0x00),0x0000);

        switch(pFilterInfo[i].dwProtocol)
        {
            case FILTER_PROTO_ANY:
            {
                pCurrent->uliProtoSrcDstPort.HighPart = 0x00000000;
                pCurrent->uliProtoSrcDstMask.LowPart = 0x00000000;
                pCurrent->uliProtoSrcDstMask.HighPart = 0x00000000;

                break;
            }
            case FILTER_PROTO_ICMP:
            {
                WORD wTypeCode = 0x0000;
                WORD wTypeCodeMask = 0x0000;


                if((BYTE)(pFilterInfo[i].wSrcPort) isnot FILTER_ICMP_TYPE_ANY)
                {
                    wTypeCode |= MAKEWORD((BYTE)(pFilterInfo[i].wSrcPort),0x00);
                    wTypeCodeMask |= MAKEWORD(0xff,0x00);
                }

                if((BYTE)(pFilterInfo[i].wDstPort) isnot FILTER_ICMP_CODE_ANY)
                {
                    wTypeCode |= MAKEWORD(0x00,(BYTE)(pFilterInfo[i].wDstPort));
                    wTypeCodeMask |= MAKEWORD(0x00,0xff);
                }

                pCurrent->uliProtoSrcDstPort.HighPart =
                  MAKELONG(wTypeCode,0x0000);
                pCurrent->uliProtoSrcDstMask.HighPart =
                  MAKELONG(wTypeCodeMask,0x0000);

                break;
            }
            case FILTER_PROTO_TCP:
            case FILTER_PROTO_UDP:
            {
                DWORD dwSrcDstPort = 0x00000000;
                DWORD dwSrcDstMask = 0x00000000;

                if(pFilterInfo[i].wSrcPort isnot FILTER_TCPUDP_PORT_ANY)
                {
                    dwSrcDstPort |= MAKELONG(pFilterInfo[i].wSrcPort,0x0000);
                    dwSrcDstMask |= MAKELONG(0xffff,0x0000);
                }

                if(pFilterInfo[i].wDstPort isnot FILTER_TCPUDP_PORT_ANY)
                {
                    dwSrcDstPort |= MAKELONG(0x0000,pFilterInfo[i].wDstPort);
                    dwSrcDstMask |= MAKELONG(0x0000,0xffff);
                }

                pCurrent->uliProtoSrcDstPort.HighPart = dwSrcDstPort;
                pCurrent->uliProtoSrcDstMask.HighPart = dwSrcDstMask;

                break;
            }
            case FILTER_PROTO_TCP_ESTAB:
            {
                DWORD dwSrcDstPort = 0x00000000;
                DWORD dwSrcDstMask = 0x00000000;

                //
                // The actual protocol is FILTER_PROTO_TCP
                //

                pCurrent->uliProtoSrcDstPort.LowPart =
                    MAKELONG(MAKEWORD(FILTER_PROTO_TCP,ESTAB_FLAGS),0x0000);

                pCurrent->uliProtoSrcDstMask.LowPart =
                    MAKELONG(MAKEWORD(0xff,ESTAB_MASK),0x0000);

                if(pFilterInfo[i].wSrcPort isnot FILTER_TCPUDP_PORT_ANY)
                {
                    dwSrcDstPort |= MAKELONG(pFilterInfo[i].wSrcPort,0x0000);
                    dwSrcDstMask |= MAKELONG(0xffff,0x0000);
                }

                if(pFilterInfo[i].wDstPort isnot FILTER_TCPUDP_PORT_ANY)
                {
                    dwSrcDstPort |= MAKELONG(0x0000,pFilterInfo[i].wDstPort);
                    dwSrcDstMask |= MAKELONG(0x0000,0xffff);
                }

                pCurrent->uliProtoSrcDstPort.HighPart = dwSrcDstPort;
                pCurrent->uliProtoSrcDstMask.HighPart = dwSrcDstMask;

                break;
            }
            default:
            {
                //
                // All other protocols have no use for the port field
                //
                pCurrent->uliProtoSrcDstPort.HighPart = 0x00000000;
                pCurrent->uliProtoSrcDstMask.HighPart = 0x00000000;
            }
        }
    }


    return STATUS_SUCCESS;
}
#endif        // STEELHEAD

VOID
DeleteFilters(
              IN PFILTER_INTERFACE  pIf,
              DWORD                 dwInOrOut
              )
/*++
  Routine Description
      Deletes all filters associated with an interface
      Assumes that the write lock for this interface is held

  Arguments
      pIf  Pointer to interface

  Return Value
--*/
{
    if(dwInOrOut == IN_FILTER_SET)
    {
        pIf->dwNumInFilters = 0;

        DeleteFilterList(&pIf->pleInFilterSet);
    }
    else
    {
        pIf->dwNumOutFilters = 0;

        DeleteFilterList(&pIf->pleOutFilterSet);
    }
}

NTSTATUS
SetFiltersEx(
           IN PPFFCB                  Fcb,
           IN PPAGED_FILTER_INTERFACE pPage,
           IN DWORD                   dwLength,
           IN PFILTER_DRIVER_SET_FILTERS pInfo)
/*++
    Routine Description:
        Set filters use the new interface definitions.

--*/
{
    PRTR_TOC_ENTRY      pInToc,pOutToc;
    PFILTER_INTERFACE   pIf = pPage->pFilter;
    PFILTER_DESCRIPTOR2 pFilterDescIn, pFilterDescOut;
    DWORD               dwInCount, dwOutCount;
    DWORD                 i;
    PPAGED_FILTER       pPFilter;
    NTSTATUS            Status = STATUS_SUCCESS;
    PBYTE               pbEnd = (PBYTE)pInfo + dwLength;
    DWORD               dwFiltersAdded = 0;

    PAGED_CODE();


    if(pIf->dwGlobalEnables & FI_ENABLE_OLD)
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }
    pInToc  = GetPointerToTocEntry(IP_FILTER_DRIVER_IN_FILTER_INFO,
                                   &pInfo->ribhInfoBlock);

    pOutToc = GetPointerToTocEntry(IP_FILTER_DRIVER_OUT_FILTER_INFO,
                                   &pInfo->ribhInfoBlock);

    if(pInToc && pInToc->InfoSize)
    {
        //
        // filters are defined.
        //

        pFilterDescIn  = GetInfoFromTocEntry(&pInfo->ribhInfoBlock,
                                             pInToc);
        if((pFilterDescIn != NULL) && (pFilterDescIn->dwVersion != 2))
        {
            ERROR(("IPFLTDRV: SetFiltersEx: Invalid version for FiltersEx\n"));
            return(STATUS_INVALID_PARAMETER);
        }
    }
    else
    {
        pFilterDescIn = NULL;
    }

    if(pOutToc && pOutToc->InfoSize)
    {
        //
        // filters are defined.
        //

        pFilterDescOut  = GetInfoFromTocEntry(&pInfo->ribhInfoBlock,
                                              pOutToc);
        if((pFilterDescOut != NULL) && (pFilterDescOut->dwVersion != 2))
        {
            ERROR(("IPFLTDRV: SetFiltersEx: Invalid version for FiltersEx\n"));
            return(STATUS_INVALID_PARAMETER);
        }
    }
    else
    {
        pFilterDescOut = NULL;
    }

    //
    // For each set of filters, add the filters to the paged, FCB
    // interface and therefore to the match interface.
    //

    if((pFilterDescIn && !CheckDescriptorSize(pFilterDescIn, pbEnd))
                            ||
       (pFilterDescOut && !CheckDescriptorSize(pFilterDescOut, pbEnd)) )
    {
        return(STATUS_BUFFER_TOO_SMALL);
    }

    if(pFilterDescIn)
    {
        // Adding in filters. For each filter, process as
        // needed. Input filters include the global checks
        /// such as spoofing.
        //

        for(dwInCount = 0;
            (dwInCount < pFilterDescIn->dwNumFilters);
            dwInCount++)
        {
            PFILTER_INFOEX pFilt = &pFilterDescIn->fiFilter[dwInCount];
            BOOL bAdded;

            //
            // If a regular filter, add it. If a special, global
            // filter, handle it specially.
            //

            if(pFilt->type == PFE_FILTER)
            {
                Status = AllocateAndAddFilterToMatchInterface(
                              Fcb,
                              pFilt,
                              TRUE,
                              pPage,
                              &bAdded,
                              &pPFilter);
                if(!NT_SUCCESS(Status))
                {
                    if((Status == STATUS_OBJECT_NAME_COLLISION)
                               &&
                       pPFilter)
                    {
                        if(!fCheckDups
                              ||
                           (pPFilter->dwFlags & FLAGS_INFOEX_ALLOWDUPS))
                        {
                            pPFilter->dwInUse++;
                            Status = STATUS_SUCCESS;
                        }
                        else
                        {
                            ERROR((
                                "IPFLTDRV: Adding in filter failed %x\n", 
                                 Status
                                ));
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                else if(bAdded && (pIf->eaInAction == FORWARD))
                {
                    dwFiltersAdded++;
                }
            }
            else
            {
                //
                // a special filter of some sort.
                //

                pPFilter = MakePagedFilter(Fcb, pFilt, pPage->dwUpdateEpoch, 0);
                if(!pPFilter)
                {
                    Status = STATUS_NO_MEMORY;
                }
                else
                {
                    PPAGED_FILTER pWhoCares;

                    if(IsOnSpecialFilterList(pPFilter,
                                      &pPage->leSpecialFilterList,
                                      &pWhoCares))
                    {

                        pWhoCares->dwInUse++;
                        ExFreePool(pPFilter);
                        pPFilter = 0;
                    }
                    else
                    {
                        switch(pFilt->type)
                        {
                            case PFE_SYNORFRAG:
                            case PFE_SPOOF:
                            case PFE_UNUSEDPORT:
                            case PFE_ALLOWCTL:
                            case PFE_STRONGHOST:
                            case PFE_FULLDENY:
                            case PFE_NOFRAG:
                            case PFE_FRAGCACHE:
                                AddGlobalFilterToInterface(pPage, pFilt);
                                break;
                            default:
                                ERROR(("IPFLTDRV: Unknown filter type\n"));
                                ExFreePool(pPFilter);
                                pPFilter = 0;
                                Status = STATUS_INVALID_PARAMETER;
                                break;
                        }
                    }
                    if(pPFilter)
                    {
                        InsertTailList(&pPage->leSpecialFilterList,
                                       &pPFilter->leSpecialList);
                    }
                    else if(!NT_SUCCESS(Status))
                    {
                        break;
                    }
                }
            }
        }
    }
    else
    {
        dwInCount = 0;
    }

    if(!NT_SUCCESS(Status))
    {
        RemoveFilterWorker(
                Fcb,
                &pFilterDescIn->fiFilter[0],
                dwInCount,
                pPage,
                &dwFiltersAdded,
                TRUE);
        return(Status);
    }


    //
    // now the output filters. This is a bit simpler since there
    // are no global settings.
    //

    if(pFilterDescOut)
    {
        //
        // Adding in filters. For each filter, process as
        // needed. Input filters include the global checks
        /// such as spoofing.
        //

        for(dwOutCount = 0;
            dwOutCount < pFilterDescOut->dwNumFilters;
            dwOutCount++)
        {
            PFILTER_INFOEX pFilt = &pFilterDescOut->fiFilter[dwOutCount];
            BOOL bAdded;

            //
            // If a regular filter, add it. If a special, global
            // filter, handle it specially.
            //

            if(pFilt->type == PFE_FILTER)
            {
                Status = AllocateAndAddFilterToMatchInterface(
                              Fcb,
                              pFilt,
                              FALSE,
                              pPage,
                              &bAdded,
                              &pPFilter);
                if(!NT_SUCCESS(Status))
                {
                    if((Status == STATUS_OBJECT_NAME_COLLISION)
                               &&
                       pPFilter)
                    {
                        if(!fCheckDups
                              ||
                           (pPFilter->dwFlags & FLAGS_INFOEX_ALLOWDUPS))
                        {
                            pPFilter->dwInUse++;
                            Status = STATUS_SUCCESS;
                        }
                        else
                        {
                            ERROR((
                                "IPFLTDRV: Adding out filter failed %x\n", 
                                Status
                                ));

                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                else if(bAdded && (pIf->eaOutAction == FORWARD))
                {
                    dwFiltersAdded++;
                }
            }
            else
            {
                ERROR(("IPFLTDRV: Ignoring global out filter\n"));
            }
        }
    }


    if(!NT_SUCCESS(Status))
    {
        RemoveFilterWorker(
                           Fcb,
                           &pFilterDescIn->fiFilter[0],
                           dwInCount,
                           pPage,
                           &dwFiltersAdded,
                           TRUE);
        RemoveFilterWorker(
                           Fcb,
                           &pFilterDescOut->fiFilter[0],
                           dwOutCount,
                           pPage,
                           &dwFiltersAdded,
                           FALSE);

    }
    else if(dwFiltersAdded)
    {
        NotifyFastPath(pIf, pIf->dwIpIndex, NOT_RESTRICTION);
    }
    return(Status);
}


NTSTATUS
UpdateBindingInformationEx(
                         PFILTER_DRIVER_BINDING_INFO pBindInfo,
                         PPAGED_FILTER_INTERFACE pPage)
/*++
  Routine Description:
    Just like the routine below. But this fixes up the
    paged filters only
--*/

{
    PPAGED_FILTER       pf;
    DWORD               i;

    if((pPage->pFilter->dwGlobalEnables & FI_ENABLE_OLD))
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    pPage->dwUpdateEpoch++;

    //
    // update all filters on this paged interface
    //

    for(i = 0; i < g_dwHashLists; i++)
    {
        PLIST_ENTRY List = &pPage->HashList[i];
        PLIST_ENTRY pList, NextListItem;

        for(pList = List->Flink;
            pList != List;
            pList = NextListItem)
        {
            NextListItem = pList->Flink;

            pf = CONTAINING_RECORD(pList, PAGED_FILTER, leHash);

            if(pf->dwEpoch == pPage->dwUpdateEpoch)
            {
                break;
            }

            if(AreAllFieldsUnchanged(pf))
            {
                continue;
            }

            //
            // it's to be changed. Take it off of its hash list
            // so it can be rehashed when we are done
            //

            RemoveEntryList(&pf->leHash);

            if(DoesSrcAddrUseLocalAddr(pf))
            {
                pf->SRC_ADDR  = pBindInfo->dwLocalAddr;
            }
            else if(DoesSrcAddrUseRemoteAddr(pf))
            {
                pf->SRC_ADDR  = pBindInfo->dwRemoteAddr;
            }

            if(DoesDstAddrUseLocalAddr(pf))
            {
                pf->DEST_ADDR  = pBindInfo->dwLocalAddr;
            }
            else if(DoesDstAddrUseRemoteAddr(pf))
            {
                pf->DEST_ADDR  = pBindInfo->dwRemoteAddr;
            }

            if(IsSrcMaskLateBound(pf))
            {
                pf->SRC_MASK = pBindInfo->dwMask;
            }

            if(IsDstMaskLateBound(pf))
            {
                pf->DEST_MASK = pBindInfo->dwMask;
            }

            pf->dwEpoch = pPage->dwUpdateEpoch;

            //
            // compute new hash index
            //

            pf->dwHashIndex = (
               pf->SRC_ADDR    +
               pf->DEST_ADDR  +
               pf->DEST_ADDR  +
               PROTOCOLPART(pf->uliProtoSrcDstPort.LowPart) +
               pf->uliProtoSrcDstPort.HighPart) % g_dwHashLists;


            InsertTailList(&pPage->HashList[pf->dwHashIndex],
                           &pf->leHash);
        }

    }

    return(UpdateMatchBindingInformation(pBindInfo, (PVOID)pPage->pFilter));
}

VOID
UpdateLateBoundFilter(PFILTER pf,
                      DWORD  dwLocalAddr,
                      DWORD  dwRemoteAddr,
                      DWORD  dwMask)
{

    if(DoesSrcAddrUseLocalAddr(pf))
    {
        pf->SRC_ADDR  = dwLocalAddr;
    }
    else if(DoesSrcAddrUseRemoteAddr(pf))
    {
        pf->SRC_ADDR  = dwRemoteAddr;
    }

    if(DoesDstAddrUseLocalAddr(pf))
    {
        pf->DEST_ADDR  = dwLocalAddr;
    }
    else if(DoesDstAddrUseRemoteAddr(pf))
    {
        pf->DEST_ADDR  = dwRemoteAddr;
    }

    if(IsSrcMaskLateBound(pf))
    {
        pf->SRC_MASK = dwMask;
    }

    if(IsDstMaskLateBound(pf))
    {
        pf->DEST_MASK = dwMask;
    }
}

NTSTATUS
UpdateMatchBindingInformation(
                         PFILTER_DRIVER_BINDING_INFO pBindInfo,
                         PVOID                       pvContext
                         )
/*++
  Routine Description
     Update the bindings for a new style interface

  Arguments
      pvIf    Pointer to FILTER_INTERFACE structure which was passed as a PVOID
              to router manager as a context for the interface
      pInfo   FILTER_IF structure filled in by driver

  Return Value

--*/
{
    PFILTER_INTERFACE   pIf;
    LOCK_STATE          LockState;
    PFILTER             pf;
    DWORD               i;
    DWORD               dwX;
    PLIST_ENTRY         List, NextList;

    pIf = (PFILTER_INTERFACE)pvContext;

    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    pIf->dwUpdateEpoch++;

    for(i = 0; i < g_dwHashLists; i++)
    {

        for(List = pIf->HashList[i].Flink;
            List != &pIf->HashList[i];
            List = NextList)
        {
            pf = CONTAINING_RECORD(List, FILTER, pleHashList);

            NextList = List->Flink;

            if(pf->dwEpoch == pIf->dwUpdateEpoch)
            {
                break;
            }

            pf->dwEpoch = pIf->dwUpdateEpoch;

            if(!AreAllFieldsUnchanged(pf))
            {
                BOOL fWild;

                UpdateLateBoundFilter(pf,
                                      pBindInfo->dwLocalAddr,
                                      pBindInfo->dwRemoteAddr,
                                      pBindInfo->dwMask);


                dwX = ComputeMatchHashIndex(pf, &fWild);
                RemoveEntryList(&pf->pleHashList);
                InsertTailList(&pIf->HashList[dwX], &pf->pleHashList);
            }
        }
    }

    //
    // finally the wild card filters
    //
    for(i = g_dwHashLists; i <= g_dwHashLists + 1; i++)
    {
        for(List = pIf->HashList[i].Flink;
            List != &pIf->HashList[i];
            List = List->Flink)
        {
            pf = CONTAINING_RECORD(List, FILTER, pleHashList);

            if(pf->dwEpoch == pIf->dwUpdateEpoch)
            {
                break;
            }

            pf->dwEpoch = pIf->dwUpdateEpoch;
            if(!AreAllFieldsUnchanged(pf))
            {
                UpdateLateBoundFilter(pf,
                                      pBindInfo->dwLocalAddr,
                                      pBindInfo->dwRemoteAddr,
                                      pBindInfo->dwMask);
            }

        }
    }
    ClearCache();
    ReleaseWriteLock(&g_filters.ifListLock,&LockState);
    NotifyFastPathIf(pIf);

    return STATUS_SUCCESS;
}


PFILTER_INTERFACE
NewInterface(
             IN  PVOID   pvContext,
             IN  DWORD   dwIndex,
             IN  FORWARD_ACTION inAction,
             IN  FORWARD_ACTION outAction,
             IN  PVOID   pvOldInterfaceContext,
             IN  DWORD   dwIpIndex,
             IN  DWORD   dwName
             )
/*++
  Routine Description
      Interface constructor

  Arguments
      pIf  Pointer to interface

  Return Value
--*/
{
    PFILTER_INTERFACE pIf;

    PAGED_CODE();

    pIf = (PFILTER_INTERFACE)ExAllocatePoolWithTag(NonPagedPool,
                                                   FILTER_INTERFACE_SIZE,
                                                   '1liF');

    if(pIf != NULL)
    {
        DWORD i;

        RtlZeroMemory(pIf, sizeof(*pIf));
        pIf->dwNumOutFilters = pIf->dwNumInFilters = 0;
        pIf->pvRtrMgrContext = pvContext;
        pIf->dwRtrMgrIndex   = dwIndex;
        pIf->eaInAction      =  inAction;
        pIf->eaOutAction    = outAction;
        pIf->dwIpIndex      = dwIpIndex;
        pIf->dwLinkIpAddress = 0;
        pIf->lInUse = 1;
        pIf->lTotalInDrops = pIf->lTotalOutDrops = 0;
        pIf->dwName        = dwName;
        pIf->dwUpdateEpoch = 0;
        pIf->pvHandleContext = pvOldInterfaceContext;
        InitializeListHead(&pIf->pleInFilterSet);
        InitializeListHead(&pIf->pleOutFilterSet);
        for(i = 0; i < FRAG_NUMBEROFENTRIES; i++)
        {
            InitializeListHead(&pIf->FragLists[i]);
        }
        for(i = 0; i <= (g_dwHashLists + 1); i++)
        {
            InitializeListHead(&pIf->HashList[i]);
        }
    }

    return pIf;
}


VOID
DeleteFilterList(PLIST_ENTRY pList)
/*++
  Routine Description
    Free the list of filters given
--*/
{
    while(!IsListEmpty(pList))
    {
        PLIST_ENTRY pEntry = RemoveHeadList(pList);

        ExFreePool(pEntry);
    }
}

VOID
ClearFragCache()

/*++
  Routine Description
      Clears the fragments cache
     
          
  Arguments
      None
         
  Return Value
         None
--*/
{
    DWORD i;
    KIRQL   kiCurrIrql;
   
    if (g_pleFragTable)
    {
        KeAcquireSpinLock(&g_kslFragLock, &kiCurrIrql);

        for(i = 0; i < g_dwFragTableSize; i++)
        {
     
            PLIST_ENTRY pleNode;
            pleNode = g_pleFragTable[i].Flink;

            while(pleNode != &(g_pleFragTable[i]))
            {
                PFRAG_INFO  pfiFragInfo;

                pfiFragInfo = CONTAINING_RECORD(pleNode, FRAG_INFO, leCacheLink);
                pleNode = pleNode->Flink;
                RemoveEntryList(&(pfiFragInfo->leCacheLink));

                ExFreeToNPagedLookasideList(
                               &g_llFragCacheBlocks,
                               pfiFragInfo);
            }
        }

        KeReleaseSpinLock(&g_kslFragLock,
                           kiCurrIrql);
    } 
    TRACE(FRAG,("IPFLTDRV: Frag cache cleanup Done\n"));
    

}

VOID
ClearCache()
/*++
  Routine Description
      Clears the input and output caches
      Assumes that the write lock has been acquired (for the system)

  Arguments
      None

  Return Value
         None
--*/
{
    DWORD i;
    PLIST_ENTRY pleNode;

    //
    // This code assumes that the g_filter.pIn/OutCache is valid and that each of the
    // pointers in the array are valid. If they are not, there is something seriously
    // wrong and you would end up blue screening in someother part of the code anyways
    //

    TRACE(CACHE,("IPFLTDRV: Clearing in and out cache..."));

    for(i = 0; i < g_dwCacheSize; i ++)
    {
        ClearInCacheEntry(g_filters.ppInCache[i]);
        ClearOutCacheEntry(g_filters.ppOutCache[i]);
    }

    TRACE(CACHE,("IPFLTDRV: Done Clearing in and out cache\n"));
    
    pleNode = g_freeInFilters.Flink;

    TRACE(CACHE,("IPFLTDRV: Clearing in free list...\n"));

    while(pleNode isnot &g_freeInFilters)
    {
        PFILTER_INCACHE pInCache;

        pInCache = CONTAINING_RECORD(pleNode,FILTER_INCACHE,leFreeLink);

        ClearInFreeEntry(pInCache);

        pleNode = pleNode->Flink;
    }

    TRACE(CACHE,("IPFLTDRV: Done Clearing in free list\n"));

    pleNode = g_freeOutFilters.Flink;

    TRACE(CACHE,("IPFLTDRV: Clearing out free list...\n"));

    while(pleNode isnot &g_freeOutFilters)
    {
        PFILTER_OUTCACHE pOutCache;

        pOutCache = CONTAINING_RECORD(pleNode,FILTER_OUTCACHE,leFreeLink);

        ClearOutFreeEntry(pOutCache);

        pleNode = pleNode->Flink;
    }

    TRACE(CACHE,("IPFLTDRV: Done Clearing out free list\n"));
    
    ClearFragCache();

    CALLTRACE(("IPFLTDRV: ClearCache Done\n"));

    return;
}


PRTR_TOC_ENTRY
GetPointerToTocEntry(
                     DWORD                     dwType,
                     PRTR_INFO_BLOCK_HEADER    pInfoHdr
                     )
{
    DWORD   i;

    PAGED_CODE();

    if(!pInfoHdr)
    {
        return NULL;
    }

    for(i = 0; i < pInfoHdr->TocEntriesCount; i++)
    {
        if(pInfoHdr->TocEntry[i].InfoType is dwType)
        {
            return &(pInfoHdr->TocEntry[i]);
        }
    }

    return NULL;
}

NTSTATUS
AddNewInterface(PPFINTERFACEPARAMETERS pInfo,
                PPFFCB                 Fcb)
/*++
Routine Description:
    Create a new interface for this handle. Also create or
    merge with a common underlying interface.
--*/
{
    PPAGED_FILTER_INTERFACE pgIf;
    PPAGED_FILTER_INTERFACE pPaged;
    DWORD dwBind = pInfo->dwBindingData;
    NTSTATUS Status;
    KPROCESSOR_MODE Mode;
    DWORD i, dwName = 0;

    PAGED_CODE();

    if(Fcb->dwFlags & PF_FCB_OLD)
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Fcb->dwFlags |= PF_FCB_NEW;

    Mode = ExGetPreviousMode();

    //
    // verify that this interface is unique on this handle.
    //

    switch(pInfo->pfbType)
    {
        default:
            Status = STATUS_NO_SUCH_DEVICE;
            break;

        case PF_BIND_NONE:

            dwBind = UNKNOWN_IP_INDEX;
            Status = STATUS_SUCCESS;
            break;

        case PF_BIND_NAME:

            dwName = dwBind;
            dwBind = UNKNOWN_IP_INDEX;
            Status = STATUS_SUCCESS;
            break;
    }

    if(NT_SUCCESS(Status))
    {
        //
        // it's not in use on this handle. So create an PAGED
        // FCB to remember this and to link into a non-paged interface.
        //

        pPaged = ExAllocatePoolWithTag(PagedPool,
                                       PAGED_INTERFACE_SIZE,
                                       'pfpI');
        if(!pPaged)
        {
            return(STATUS_NO_MEMORY);
        }

        //
        // fill in the paged filter definition and allocate
        // a non-paged filter. The non-paged filter could already
        // exist, in which case simply link this to the existing
        // one.

        if(pInfo->pfLogId)
        {
            //
            // If a Log ID is given, reference the log to
            // prevent it from going away
            //

            Status = ReferenceLogByHandleId(pInfo->pfLogId,
                                            Fcb,
                                            &pPaged->pLog);
            if(!NT_SUCCESS(Status))
            {
                ExFreePool(pPaged);
                return(Status);
            }
        }
        else
        {
            pPaged->pLog = NULL;
        }

        pPaged->dwNumInFilters = pPaged->dwNumOutFilters = 0;
        pPaged->eaInAction = pInfo->eaIn;
        pPaged->eaOutAction = pInfo->eaOut;
        pPaged->dwGlobalEnables = 0;
        pPaged->pvRtrMgrContext = pInfo->fdInterface.pvRtrMgrContext;
        pPaged->dwRtrMgrIndex = pInfo->fdInterface.dwIfIndex;
        pPaged->dwUpdateEpoch = 0;


        Status = CreateCommonInterface(pPaged,
                                       dwBind,
                                       dwName,
                                       pInfo->dwInterfaceFlags);

        if(!NT_SUCCESS(Status))
        {
            if(pPaged->pLog)
            {
                ERROR(("IPFLTDRV: CreateCommonInterface failed: DereferenceLog being called\n"));
                DereferenceLog(pPaged->pLog);
            }
            ExFreePool(pPaged);
            return(Status);
        }

        pPaged->pvDriverContext =
            pInfo->fdInterface.pvDriverContext = (PVOID)pPaged;

        InitializeListHead(&pPaged->leSpecialFilterList);

        for(i = 0; i < 2 * g_dwHashLists; i++)
        {
            PLIST_ENTRY List = &pPaged->HashList[i];

            InitializeListHead(List);
        }

        InsertTailList(&Fcb->leInterfaces, &pPaged->leIfLink);
    }
    return(Status);
}

BOOL
DereferenceFilterInterface(PFILTER_INTERFACE pIf, PPFLOGINTERFACE pLog)
/*++
    Routine Description:
      Nonpaged routine to dereference a match interface. If the
      reference count goes to zero, free the interface
--*/
{
    LOCK_STATE LockState, LockState2;
    BOOL fRel = FALSE;

    //
    // lock the resource that protects adding new interfaces. This
    // is needed to hold off others until everything is properly
    // verified. The spin lock is insufficient for this.
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&FilterListResourceLock, TRUE);
    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    if(--pIf->lInUse == 0)
    {
        RemoveEntryList(&pIf->leIfLink);
        if(pIf->dwIpIndex != UNKNOWN_IP_INDEX)
        {
            InterlockedCleanCache(g_filters.pInterfaceCache, pIf->dwIpIndex, pIf->dwLinkIpAddress);
            InterlockedDecrement(&g_ulBoundInterfaceCount);

            TRACE(CONFIG,(
                "IPFLTDRV: UnBound Interface Index=%d, Link=%d, TotalCnt=%d\n", 
                 pIf->dwIpIndex, 
                 pIf->dwLinkIpAddress, 
                 g_ulBoundInterfaceCount
                 ));
        }
        fRel = TRUE;
    }

    ReleaseWriteLock(&g_filters.ifListLock,&LockState);

    if(fRel)
    {
        //
        // Getting rid of it
        //

        if(pIf->dwIpIndex != UNKNOWN_IP_INDEX)
        {
            DWORD dwIndex = pIf->dwIpIndex;

            pIf->dwIpIndex =  UNKNOWN_IP_INDEX;
            NotifyFastPath(pIf, dwIndex, NOT_UNBIND);
        }

        AcquireWriteLock(&g_filters.ifListLock,&LockState2);
        ClearCache();
        ReleaseWriteLock(&g_filters.ifListLock,&LockState2);

        if(pIf->pLog)
        {
            DereferenceLog(pIf->pLog);
        }
        ExFreePool(pIf);
    }
    else if(pLog)
    {
        //
        // this deref owns the log. So take the log off of the
        // the interface. Note it may be true that the match interface
        // has a different log than the paged interface. This will
        // happen if the log is closed while it exists on the interface.
        // In such a case, the log is removed from the match interface
        // but not the paged interface. And when the paged interface
        // is closed, as is happening now, the log it has is incorrect.
        // So this check is required.
        // The FilterListResourceLock serializes all of this ...
        //

        if(pLog == pIf->pLog)
        {
            AcquireWriteLock(&g_filters.ifListLock,&LockState2);
            pIf->pLog = 0;
            ReleaseWriteLock(&g_filters.ifListLock,&LockState2);
            DereferenceLog(pLog);
        }
    }

    ExReleaseResourceLite(&FilterListResourceLock);
    KeLeaveCriticalRegion();
    return(fRel);
}


NTSTATUS
CreateCommonInterface(PPAGED_FILTER_INTERFACE pPage,
                      DWORD dwBind,
                      DWORD dwName,
                      DWORD dwFlags)
/*++
Routine Description:
   Non-paged routine called by AddNewInterface to bind the
   paged interface to an underlying interface, and to bind
   that to a stack interface. The caller should have
   verified that dwBind is a valid stack interface.
--*/
{
    PFILTER_INTERFACE   pIf, pIf1;
    LOCK_STATE          LockState;
    NTSTATUS            Status = STATUS_SUCCESS;
    PPFLOGINTERFACE     pLog = pPage->pLog;

    pIf = NewInterface(pPage->pvRtrMgrContext,
                       pPage->dwRtrMgrIndex,
                       pPage->eaInAction,
                       pPage->eaOutAction,
                       0,
                       dwBind,
                       dwName);

    if(pIf == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    if(dwFlags & PFSET_FLAGS_UNIQUE)
    {
        pIf->dwGlobalEnables |= FI_ENABLE_UNIQUE;
    }

    //
    // lock the resource that protects adding new interfaces. This
    // is needed to hold off others until everything is properly
    // verified. The spin lock is insufficient for this.
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&FilterListResourceLock, TRUE);


    //
    // Now reconcile the binding. Note that we had to make the interface
    // first in order to prevent a race with another process trying
    // to bind to the same stack interface.
    //

    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    if((dwBind != UNKNOWN_IP_INDEX)
               ||
       dwName)
    {

        pIf1 = FindMatchName(dwName, dwBind);

        if(pIf1)
        {
            // found it. Make sure it agrees. If so,
            // refcount it and use it
            //

            if(!(pIf->dwGlobalEnables & FI_ENABLE_OLD)
                       &&
               (pIf->eaInAction == pIf1->eaInAction)
                       &&
               (pIf->eaOutAction == pIf1->eaOutAction)
                       &&
               !(pIf->dwGlobalEnables & FI_ENABLE_UNIQUE)
                       &&
               !(pIf1->dwGlobalEnables & FI_ENABLE_UNIQUE)
              )
            {

                pIf1->lInUse++;
            }
            else
            {
                //
                // mismatch. Can't do it
                //

                Status = STATUS_INVALID_PARAMETER;
            }
        }
    }
    else
    {
       pIf1 = 0;
    }

    if(!pIf1)
    {
        InsertTailList(&g_filters.leIfListHead,&pIf->leIfLink);
    }

    ReleaseWriteLock(&g_filters.ifListLock,&LockState);

    if(pIf1)
    {
        //
        // If log is specifed but log alreadye exists, error.
        //
        ExFreePool(pIf);
        if(NT_SUCCESS(Status))
        {
            pPage->pFilter = pIf1;
            if(pIf1->pLog)
            {
                if(pPage->pLog)
                {
                    //
                    // the interface already has a log. In prinicple
                    // this should call DereferenceFilterInterface but
                    // this will do and it's faster.
                    //
                    Status = STATUS_DEVICE_BUSY;
                    pIf1->lInUse--;
                }
            }
            else if(pPage->pLog)
            {
                //
                // see comment below about log referencing
                //

                AddRefToLog(pIf1->pLog = pPage->pLog);
            }
        }
        ExReleaseResourceLite(&FilterListResourceLock);
        KeLeaveCriticalRegion();
        return(Status);
    }

    NotifyFastPathIf(pIf);
    pPage->pFilter = pIf;
    if(pPage->pLog)
    {
        //
        // Reference the log. Need this since the
        // paged interface can be deleted before the
        // match interface, so each must apply a reference.
        // Actually, only the match needs to do it, but
        // the way the log works, the paged interface already
        // got a reference, so just do it this way.
        // N.B. The single = is intentional
        //

        AddRefToLog(pIf->pLog = pPage->pLog);
    }

    ExReleaseResourceLite(&FilterListResourceLock);
    KeLeaveCriticalRegion();

    return(Status);
}

VOID
MakeFilterInfo(IN  PPAGED_FILTER pPage,
               IN  PFILTER_INFOEX pInfo,
               IN  DWORD          dwFlags)
{
    PFILTER_INFO2 pFilterInfo = &pInfo->info;

    if(pInfo->type != PFE_FILTER)
    {
        //
        // a special filter.
        //

        memset(pPage, 0, sizeof(*pPage));
        pPage->type = pInfo->type;
        pPage->fLateBound = pInfo->dwFlags;
        pPage->dwInUse    = 1;
        return;
    }

    pPage->type         = pInfo->type;
    pPage->SRC_ADDR     = pFilterInfo->dwaSrcAddr[0];
    pPage->DEST_ADDR    = pFilterInfo->dwaDstAddr[0];
    pPage->SRC_MASK     = pFilterInfo->dwaSrcMask[0];
    pPage->DEST_MASK    = pFilterInfo->dwaDstMask[0];
    pPage->fLateBound   = pFilterInfo->fLateBound;
    pPage->wSrcPortHigh = pPage->wDstPortHigh = 0;
    pPage->dwFlags      = dwFlags;
    pPage->dwInUse      = 1;


    if(pPage->SRC_MASK != INADDR_SPECIFIC)
    {
        pPage->dwFlags |= FILTER_FLAGS_SRCWILD;
    }
    if(pPage->DEST_MASK != INADDR_SPECIFIC)
    {
        pPage->dwFlags |= FILTER_FLAGS_DSTWILD;
    }


    //
    // Now the network ordering stuff - tricky part
    // LP0    LP1 LP2 LP3 HP0 HP1 HP2 HP3
    // Proto  00  00  00  SrcPort DstPort
    //

    //
    // For addresses, ANY_ADDR is given by 0.0.0.0 and the MASK must be 0.0.0.0
    // For proto and ports 0 means any and the mask is generated as follows
    // If the proto is O then LP0 for Mask is 0xff else its 0x00
    // If a port is 0, the corresponding XP0XP1 is 0x0000 else its 0xffff
    //

    //
    // ICMP:
    // LP0  LP1  LP2  LP3  HP0 HP1 HP2 HP3
    // 0x1  00   00   00   Typ Cod 00  00
    // ICMP is different since 0 is a valid code and type, so 0xff is used by the
    // user to signify that ANY code or type is to be matched. However to do this
    // we need to have the field set to zero and the the mask set to 00 (for any).
    // But if the filter is specifically for Type/Code = 0 then the field is zero
    // with the mask as 0xff
    //

    //
    // The protocol is in the low byte of the dwProtocol, so we take that out and
    // make a dword out of it
    //

    pPage->uliProtoSrcDstPort.LowPart =
      MAKELONG(MAKEWORD(LOBYTE(LOWORD(pFilterInfo->dwProtocol)),0x00),0x0000);

    pPage->uliProtoSrcDstMask.LowPart = MAKELONG(MAKEWORD(0xff,0x00),0x0000);

    switch(pFilterInfo->dwProtocol)
    {
        case FILTER_PROTO_ANY:
        {
            pPage->uliProtoSrcDstPort.HighPart = 0x00000000;
            pPage->uliProtoSrcDstMask.LowPart = 0x00000000;
            pPage->uliProtoSrcDstMask.HighPart = 0x00000000;
            pPage->dwFlags |= FILTER_FLAGS_SRCWILD | FILTER_FLAGS_DSTWILD;

            break;
            }
        case FILTER_PROTO_ICMP:
         {
            WORD wTypeCode = 0x0000;
            WORD wTypeCodeMask = 0x0000;


            //
            // For ICMP, the "ports" occupy the same place as the
            // source port for TCP/UDP. So a wild card in here
            // can never produce a FILTER_FLAGS_DSTWILD but we assume
            // it does. This will put all wild ICMP filters into
            // the default bucket. This seems OK since the performance
            // for matching these is not critical.
            //
            if((BYTE)(pFilterInfo->wSrcPort) != FILTER_ICMP_TYPE_ANY)
            {
                wTypeCode |= MAKEWORD((BYTE)(pFilterInfo->wSrcPort),0x00);
                wTypeCodeMask |= MAKEWORD(0xff,0x00);
            }
            else
            {
                pPage->dwFlags |= FILTER_FLAGS_SRCWILD | FILTER_FLAGS_DSTWILD;
            }

            if((BYTE)(pFilterInfo->wDstPort) != FILTER_ICMP_CODE_ANY)
            {
                wTypeCode |= MAKEWORD(0x00,(BYTE)(pFilterInfo->wDstPort));
                wTypeCodeMask |= MAKEWORD(0x00,0xff);
            }
            else
            {
                pPage->dwFlags |= FILTER_FLAGS_SRCWILD | FILTER_FLAGS_DSTWILD;
            }

            pPage->uliProtoSrcDstPort.HighPart =
              MAKELONG(wTypeCode,0x0000);
            pPage->uliProtoSrcDstMask.HighPart =
              MAKELONG(wTypeCodeMask,0x0000);

            break;
        }
        case FILTER_PROTO_TCP:

            //
            // if no connections allowed, set the ESTAB_MASK
            // value in the comparison mask
            //
            if(pInfo->dwFlags & FLAGS_INFOEX_NOSYN)
            {
               pPage->uliProtoSrcDstMask.LowPart |=
                   MAKELONG(MAKEWORD(0,ESTAB_MASK),0x0000);
               pPage->uliProtoSrcDstPort.LowPart |=
                   MAKELONG(MAKEWORD(0,ESTAB_MASK),0x0000);
            }

            //
            // fall through
            //

        case FILTER_PROTO_UDP:
        {
            DWORD dwSrcDstPort = 0x00000000;
            DWORD dwSrcDstMask = 0x00000000;

            if(pFilterInfo->wSrcPort != FILTER_TCPUDP_PORT_ANY)
            {
                dwSrcDstPort |= MAKELONG(pFilterInfo->wSrcPort,0x0000);
                if(pFilterInfo->wSrcPortHigh)
                {
                   pPage->wSrcPortHigh = pFilterInfo->wSrcPortHigh;
                   pPage->dwFlags |=
                       (FILTER_FLAGS_PORTWILD | FILTER_FLAGS_SRCWILD);
                }
                else
                {
                    dwSrcDstMask |= MAKELONG(0xffff,0x0000);
                }

            }
            else
            {
                pPage->dwFlags |= FILTER_FLAGS_SRCWILD;
            }


            if(pFilterInfo->wDstPort != FILTER_TCPUDP_PORT_ANY)
            {
                dwSrcDstPort |= MAKELONG(0x0000,pFilterInfo->wDstPort);
                if(pFilterInfo->wDstPortHigh)
                {
                   pPage->wDstPortHigh = pFilterInfo->wDstPortHigh;
                   pPage->dwFlags |=
                       (FILTER_FLAGS_PORTWILD | FILTER_FLAGS_DSTWILD);
                }
                else
                {
                    dwSrcDstMask |= MAKELONG(0x0000,0xffff);
                }
            }
            else
            {
                pPage->dwFlags |= FILTER_FLAGS_DSTWILD;
            }

            pPage->uliProtoSrcDstPort.HighPart = dwSrcDstPort;
            pPage->uliProtoSrcDstMask.HighPart = dwSrcDstMask;

            break;
        }
        default:
        {
            //
            // All other protocols have no use for the port field
            //
            pPage->uliProtoSrcDstPort.HighPart = 0x00000000;
            pPage->uliProtoSrcDstMask.HighPart = 0x00000000;
        }
    }

    //
    // compute the hash index
    //

    pPage->dwHashIndex = (
               pPage->SRC_ADDR    +
               pPage->DEST_ADDR  +
               pPage->DEST_ADDR  +
               PROTOCOLPART(pPage->uliProtoSrcDstPort.LowPart) +
               pPage->uliProtoSrcDstPort.HighPart) % g_dwHashLists;
}

PPAGED_FILTER
MakePagedFilter(
               IN  PPFFCB         Fcb,
               IN  PFILTER_INFOEX pInfo,
               IN  DWORD          dwEpoch,
               IN  DWORD          dwFlags
               )
/*++
  Routine Description


  Arguments


  Return Value
--*/
{
    PPAGED_FILTER pPage;
    PFILTER_INFO2 pFilterInfo = &pInfo->info;

    PAGED_CODE();

    //
    // Allocate memory for the filters
    //


    pPage = (PPAGED_FILTER)ExAllocateFromPagedLookasideList(&paged_slist);

    if(!pPage)
    {
        ERROR(("IPFLTDRV: Couldnt allocate memory for paged filter set\n"));
        return NULL;
    }

    pPage->pFilters = NULL;

    MakeFilterInfo(pPage, pInfo, dwFlags);

    pPage->dwEpoch = dwEpoch;

    return pPage;
}

NTSTATUS
AllocateAndAddFilterToMatchInterface(
                              PPFFCB         Fcb,
                              PFILTER_INFOEX pInfo,
                              BOOL     fInFilter,
                              PPAGED_FILTER_INTERFACE pPage,
                              PBOOL          pbAdded,
                              PPAGED_FILTER * ppFilter)
/*++
    Routine Description:
        Check if this filter is already on the handle. If not
        allocate a handle fitler and add it to the match
        interface. Note the handle filter is not added to
        the handle. This is so the caller can easily back out
        if something fails.
     Returns: STATUS_SUCCESS if all is well. ppFilter is either NULL
              or contains the new filter.
--*/
{
    PPAGED_FILTER pPageFilter, pPage1;
    PFILTER pMatch, pMatch1;
    DWORD dwFlags = (fInFilter ? FILTER_FLAGS_INFILTER : 0);
    DWORD dwAdd;

    PAGED_CODE();

    //
    // Make a paged filter so we can figure out whether
    // it exists yet.
    //

    pPageFilter = MakePagedFilter(
                          Fcb,
                          pInfo,
                          pPage->dwUpdateEpoch,
                          dwFlags);
    if(!pPageFilter)
    {
        return STATUS_NO_MEMORY;
    }

    if(pPage1 = IsOnPagedInterface(pPageFilter, pPage))
    {
        {
            //
            // it already exists. So return the existing one
            // and also the handle
            //
            ExFreeToPagedLookasideList(&paged_slist,
                                       (PVOID)pPageFilter);
            *ppFilter = pPage1;
            pInfo->pvFilterHandle = (PVOID)pPage1;
            return(STATUS_OBJECT_NAME_COLLISION);
        }
    }

    //
    // See if we should check out the address.
    //


    if(!(pInfo->dwFlags & FLAGS_INFOEX_ALLOWANYREMOTEADDRESS))
    {
        if(pPageFilter->dwFlags & FILTER_FLAGS_INFILTER)
        {
            if(pPageFilter->SRC_MASK != INADDR_SPECIFIC)
            {
                dwAdd = 0;
            }
            else
            {
                dwAdd = pPageFilter->SRC_ADDR;
            }
        }
        else if(pPageFilter->DEST_MASK != INADDR_SPECIFIC)
        {
            dwAdd = 0;
        }
        else
        {
           dwAdd = pPageFilter->DEST_ADDR;
        }

        //
        // see if address checking should be done. It is done if an
        // address is specified and the filter does not indicate the
        // address is late bound. If it is late bound, just allow it
        // since it may change
        //
        if(dwAdd)
        {
            NTSTATUS Status;

            if(!BMAddress(dwAdd))
            {
                Status = CheckFilterAddress(dwAdd, pPage->pFilter);
                if(!NT_SUCCESS(Status))
                {

                    ExFreeToPagedLookasideList(&paged_slist,
                                               (PVOID)pPageFilter);
                    return(Status);
                }
           }
        }
    }
    else
    {
        TRACE(CONFIG,("IPFLTDRV: Allow any address is filter\n"));
    }

    if(!(pInfo->dwFlags & FLAGS_INFOEX_ALLOWANYLOCALADDRESS))
    {
        if(pPageFilter->dwFlags & FILTER_FLAGS_INFILTER)
        {
            if(pPageFilter->DEST_MASK != INADDR_SPECIFIC)
            {
                dwAdd = 0;
            }
            else
            {
                dwAdd = pPageFilter->DEST_ADDR;
            }
        }
        else if(pPageFilter->SRC_MASK != INADDR_SPECIFIC)
        {
            dwAdd = 0;
        }
        else
        {
           dwAdd = pPageFilter->SRC_ADDR;
        }

        if(dwAdd)
        {
            if(pPage->pFilter->dwIpIndex != UNKNOWN_IP_INDEX)
            {
                if(!BMAddress(dwAdd) &&
                   (GetIpStackIndex(dwAdd, FALSE) != pPage->pFilter->dwIpIndex))
                {
                    ExFreeToPagedLookasideList(&paged_slist,
                                               (PVOID)pPageFilter);
                    return(STATUS_INVALID_ADDRESS);
                }
            }
        }
    }


    //
    // Not on the handle. Assume we need to add a new filter
    // to the match interface. Allocate memory for this filter if
    // necessary
    //

    pMatch = (PFILTER)ExAllocateFromNPagedLookasideList(
                              &filter_slist);
    if(!pMatch)
    {
        ExFreePool(pPageFilter);
        return(STATUS_NO_MEMORY);
    }

    pInfo->pvFilterHandle = (PVOID)pPageFilter;

    //
    // We will keep this filter so add it to the hash list
    //

    InsertTailList(&(pPage->HashList[pPageFilter->dwHashIndex]),
                   &pPageFilter->leHash);

    //
    // Now add it to the handle hash list
    //

    InsertTailList(&(pPage->HandleHash((UINT_PTR)pPageFilter & HANDLE_HASH_SIZE)),
                   &pPageFilter->leHandleHash);


    //
    // fix up the match interface
    //

    pMatch->uliSrcDstAddr = pPageFilter->uliSrcDstAddr;
    pMatch->uliSrcDstMask = pPageFilter->uliSrcDstMask;
    pMatch->uliProtoSrcDstPort = pPageFilter->uliProtoSrcDstPort;
    pMatch->uliProtoSrcDstMask = pPageFilter->uliProtoSrcDstMask;
    pMatch->fLateBound = pPageFilter->fLateBound;
    pMatch->wSrcPortHigh = pPageFilter->wSrcPortHigh;
    pMatch->wDstPortHigh = pPageFilter->wDstPortHigh;

    pMatch->Count.lCount = 0;
    pMatch->dwFlags =  pPageFilter->dwFlags;
    pMatch->dwFlags |= (pInfo->dwFlags & FLAGS_INFOEX_ALLFLAGS);
    pMatch->dwFilterRule = pInfo->dwFilterRule;
    pMatch->Count.lInUse = 0;


    AddFilterToInterface(
                         pMatch,
                         pPage->pFilter,
                         fInFilter,
                         &pMatch1);

    if(pMatch1)
    {
        //
        // the filter already exists. Don't need the one we built
        //

        ExFreePool(pMatch);
        pMatch = pMatch1;
        *pbAdded = FALSE;
    }
    else
    {
        *pbAdded = TRUE;
    }
    pPageFilter->pMatchFilter = pMatch;
    *ppFilter = pPageFilter;
    return(STATUS_SUCCESS);
}

VOID
AddFilterToInterface(
    PFILTER pFilter,
    PFILTER_INTERFACE pIf,
    BOOL   fInFilter,
    PFILTER * ppFilter)
/*++
    Routine Description:
        Add pFilter to the interface. If it already exists,
        just refcount it and return the address of the
        existing filter.
--*/
{
    PFILTER pTemp;
    LOCK_STATE  LockState;
    PLIST_ENTRY   List, pList;
    PDWORD pdwCount;
    DWORD dwIndex;
    DWORD dwType = pFilter->dwFlags & FILTER_FLAGS_INFILTER;
    BOOL fWild;


    *ppFilter = NULL;

    dwIndex = ComputeMatchHashIndex(pFilter, &fWild);

    if(fInFilter)
    {
        pList = &pIf->pleInFilterSet;
        pdwCount = &pIf->dwNumInFilters;
    }
    else
    {
        pList = &pIf->pleOutFilterSet;
        pdwCount = &pIf->dwNumOutFilters;
    }

    //
    // lock up the filters
    //
    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    for(List = pIf->HashList[dwIndex].Flink;
        List != &pIf->HashList[dwIndex];
        List = List->Flink)
    {
        pTemp = CONTAINING_RECORD(List, FILTER, pleHashList);

        if((dwType == (pTemp->dwFlags & FILTER_FLAGS_INFILTER))
                                &&
           (pTemp->uliSrcDstAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart)
                                &&
           (pTemp->uliSrcDstMask.QuadPart == pFilter->uliSrcDstMask.QuadPart)
                                &&
           (pTemp->uliProtoSrcDstPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)
                                &&
           (pTemp->uliProtoSrcDstMask.QuadPart == pFilter->uliProtoSrcDstMask.QuadPart)
                                &&
           (pTemp->wSrcPortHigh == pFilter->wSrcPortHigh)
                                &&
           (pTemp->wDstPortHigh == pFilter->wDstPortHigh)
          )
        {
            pFilter = *ppFilter = pTemp;
            break;
        }
    }

    if(!*ppFilter)
    {

        //
        // a new filter. Add it to the interface. First flush incorrect cache
        // entries.
        //

        if(ANYWILDFILTER(pFilter))
        {
            //
            // wild card filters can cause cache entries almost anywhere
            // in the table. Very nasty. So take the draconian step of
            // deleting the entire cache.
            //
            ClearCache();
        }
        else
        {
            ClearCacheEntry(pFilter, pIf);
        }
        pFilter->dwEpoch = pIf->dwUpdateEpoch;
        InsertTailList(pList, &pFilter->pleFilters);

        //
        // and add it to the proper fragment list
        //

#if DOFRAGCHECKING
        InsertTailList(
             &pIf->FragLists[GetFragIndex(PROTOCOLPART(pFilter->PROTO))],
             &pFilter->leFragList);
#endif

        *pdwCount+= 1;
#if WILDHASH
        if(fWild)
        {
            //
            // if a wild filter of some sort, insert at the tail
            // keeping specific filters ahead of wild filters
            //
            InsertTailList((&pIf->HashList[dwIndex]), &pFilter->pleHashList);
            pIf->dwWilds++;
        }
        else
#endif
        {
            //
            // insert at the head on the assumption this filter will
            // be used soon and existing filters already have been
            // used to produce a valid packet cache entry
            //
            InsertHeadList((&pIf->HashList[dwIndex]), &pFilter->pleHashList);
        }

    }

    pFilter->Count.lInUse++;

    ReleaseWriteLock(&g_filters.ifListLock,&LockState);
}

BOOL
DereferenceFilter(PFILTER pFilt, PFILTER_INTERFACE pIf)
/*++
    Routine Description:

    Dereference a filter and if it has no more referents, free it.
    Returns TRUE if the filter was freed, FALSE otherwise.
--*/
{
    LOCK_STATE LockState;
    BOOL fFreed = FALSE;

    //
    // lock up the filters
    //
    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    //
    // Decrement reference count. If new count is 0, remove
    // the entry but defer freeing the memory until the
    // spin lock is released
    //
    if(--pFilt->Count.lInUse == 0)
    {

        TRACE(FLDES, ("IPFLTDRV: Deleting a filter: "));
        TRACE_FILTER_DESCRIPTION(pFilt);

        RemoveEntryList(&pFilt->pleFilters);
        RemoveEntryList(&pFilt->pleHashList);
#if DOFRAGCHECKING
        RemoveEntryList(&pFilt->leFragList);
#endif

        if(pFilt->dwFlags & FILTER_FLAGS_INFILTER)
        {
            pIf->dwNumInFilters--;

        }
        else
        {
            pIf->dwNumOutFilters--;
            pIf->lEpoch++;
        }

        if(ANYWILDFILTER(pFilt))
        {
            //
            // wild card filters can cause cache entries almost anywhere
            // in the table. Very nasty.
            //
#if WILDHASH

            if(!WildFilter(pFilt))
            {
                pIf->dwWilds--;
            }
#endif
            ClearAnyCacheEntry(pFilt, pIf);
        }
        else
        {
            ClearCacheEntry(pFilt, pIf);
        }
        fFreed = TRUE;
    }
    ReleaseWriteLock(&g_filters.ifListLock,&LockState);
    if(fFreed)
    {
        ExFreeToNPagedLookasideList(
                      &filter_slist,
                      (PVOID)pFilt);
    }
    return(fFreed);
}

PPAGED_FILTER
IsOnPagedInterface(PPAGED_FILTER pPageFilter,
                   PPAGED_FILTER_INTERFACE pPage)
{
    PPAGED_FILTER pPage1;
    PLIST_ENTRY List = &pPage->HashList[pPageFilter->dwHashIndex];
    PLIST_ENTRY pEntry;
    DWORD dwFlags = pPageFilter->dwFlags & FILTER_FLAGS_INFILTER;

    PAGED_CODE();

    for(pEntry =  List->Flink;
        pEntry != List;
        pEntry =  pEntry->Flink)
    {
        pPage1 = CONTAINING_RECORD(pEntry, PAGED_FILTER, leHash);

        if((dwFlags == (pPage1->dwFlags & FILTER_FLAGS_INFILTER))
                      &&
           (pPage1->uliSrcDstAddr.QuadPart == pPageFilter->uliSrcDstAddr.QuadPart)
                                &&
           (pPage1->uliSrcDstMask.QuadPart == pPageFilter->uliSrcDstMask.QuadPart)
                                &&
           (pPage1->uliProtoSrcDstPort.QuadPart == pPageFilter->uliProtoSrcDstPort.QuadPart)
                                &&
           (pPage1->uliProtoSrcDstMask.QuadPart == pPageFilter->uliProtoSrcDstMask.QuadPart)
                                &&
           (pPage1->wSrcPortHigh == pPageFilter->wSrcPortHigh)
                                &&
           (pPage1->wDstPortHigh == pPageFilter->wDstPortHigh)
           )
        {
            return(pPage1);
        }
    }
    return(NULL);
}

BOOL
IsOnSpecialFilterList(PPAGED_FILTER pPageFilter,
                      PLIST_ENTRY   List,
                      PPAGED_FILTER * pPageHit)
{
    PPAGED_FILTER pPage1;
    PLIST_ENTRY pList;

    PAGED_CODE();


    for(pList = List->Flink;
        pList != List;
        pList = pList->Flink)
    {
        pPage1 = CONTAINING_RECORD(pList, PAGED_FILTER, leSpecialList);

        //
        // See if this filter matches the new one. If so,
        // we've already got it, so just free the new filter
        // and return success

        if(pPageFilter->type == pPage1->type)
        {
            *pPageHit = pPage1;
            return(TRUE);
        }
    }
    return(FALSE);
}

VOID
FreePagedFilterList(PPFFCB Fcb,
                    PPAGED_FILTER pList,
                    PPAGED_FILTER_INTERFACE pPage,
                    PDWORD  pdwRemoved)
/*++
    Routine Description:
        Release all of the filters in the list. Each such filter
        has to cause a derefernce of the underlying match
        filter. If the paged filter is a global filter, handle
        it specially
--*/
{
    PPAGED_FILTER pFilt;

    while(pList)
    {
        if(pList->type == PFE_FILTER)
        {

            if(DereferenceFilter(pList->pMatchFilter, pPage->pFilter))
            {
                //
                // removed a filter. If this added a restriction,
                // note it. A restriction is added only if the
                // default action is DROP
                //
                if(pList->dwFlags & FILTER_FLAGS_INFILTER)
                {
                    if(pPage->eaInAction == DROP)
                    {
                        *pdwRemoved += 1;
                    }
                } else if(pPage->eaOutAction == DROP)
                {
                    *pdwRemoved += 1;
                }
            }
            RemoveEntryList(&pList->leHash);
            RemoveEntryList(&pList->leHandleHash);

        }
        else
        {
            RemoveGlobalFilterFromInterface(pPage->pFilter,
                                            pList->type);
            RemoveEntryList(&pList->leSpecialList);
        }
        pFilt = pList->pFilters;
        ExFreeToPagedLookasideList(&paged_slist,
                                   (PVOID)pList);
        pList = pFilt;
    }
}

NTSTATUS
FindAndRemovePagedFilter(
                          PPFFCB          Fcb,
                          PFILTER_INFOEX pInfo,
                          BOOL fInFilter,
                          PDWORD    pdwRemoved,
                          PPAGED_FILTER_INTERFACE pPage)
/*++
    Routine Description:
       Find if the described filter in on the paged interface,
       and if so, remove it, and derefernce the underlying match
       filter.
--*/
{
    PAGED_FILTER Page;
    PPAGED_FILTER pPageHit;
    DWORD dwFlags = fInFilter ? FILTER_FLAGS_INFILTER : 0;

    MakeFilterInfo(&Page, pInfo, dwFlags);

    //
    // search the interface to see if we have this already.
    //

    if(Page.type != PFE_FILTER)
    {
        //
        // it's a special filte. Search the list
        //
        if(!IsOnSpecialFilterList(&Page,
                          &pPage->leSpecialFilterList,
                          &pPageHit)
                           )
        {
            return(STATUS_INVALID_PARAMETER);
        }
    }
    else
    {
        //
        // a regular filter
        //
        pPageHit = IsOnPagedInterface(&Page, pPage);
        if(!pPageHit)
        {
            return(STATUS_INVALID_PARAMETER);
        }
    }

    if(!--pPageHit->dwInUse)
    {
        pPageHit->pFilters = NULL;
        FreePagedFilterList(Fcb, pPageHit, pPage, pdwRemoved);
    }

    return(STATUS_SUCCESS);
}

PPAGED_FILTER
FindFilterByHandle(
           IN PPFFCB                      Fcb,
           IN PPAGED_FILTER_INTERFACE     pPage,
           IN PVOID                       pvHandle)
/*++
  Routine Description:
    Find a filter given its filter handle
--*/
{
    PPAGED_FILTER pPaged = 0;
    DWORD dwHash = (DWORD)(((UINT_PTR)pvHandle % HANDLE_HASH_SIZE));
    PLIST_ENTRY pList;

    for(pList = pPage->HandleHash(dwHash).Flink;
        pList != &pPage->HandleHash(dwHash);
        pList = pList->Flink)
    {
        PPAGED_FILTER ppf = CONTAINING_RECORD(pList,
                                              PAGED_FILTER,
                                              leHandleHash);

        if(ppf == (PPAGED_FILTER)pvHandle)
        {
            pPaged = ppf;
            break;
        }
    }
    return(pPaged);
}


NTSTATUS
DeleteByHandle(
           IN PPFFCB                      Fcb,
           IN PPAGED_FILTER_INTERFACE     pPage,
           IN PVOID *                     ppHandles,
           IN DWORD                       dwLength)
/*++
  Routine Description:
    Delete filters using the assigned filter handles
    Note the FCB is locked, so it won't change
--*/
{
    PFILTER_INTERFACE   pIf = pPage->pFilter;
    DWORD               dwFilters;
    PPAGED_FILTER       pPFilter;
    NTSTATUS            Status = STATUS_SUCCESS;
    DWORD               dwFiltersRemoved = 0;

    PAGED_CODE();

    if(pPage->pFilter->dwGlobalEnables & FI_ENABLE_OLD)
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // compute number of filters
    //

    dwFilters = dwLength / sizeof(PVOID);


    for(; dwFilters; dwFilters--, ppHandles++)
    {
        //
        // for each handle, locate the filter
        //

        pPFilter = FindFilterByHandle(Fcb, pPage, *ppHandles);
        if(!pPFilter)
        {
            TRACE(CONFIG,("IPFLTDRV: Could not translate handle to filter\n"));
        }
        else
        {
            if(!--pPFilter->dwInUse)
            {
                pPFilter->pFilters = NULL;
                FreePagedFilterList(Fcb, pPFilter, pPage, &dwFiltersRemoved);
            }
        }
    }
    if(dwFiltersRemoved)
    {
        NotifyFastPath(pIf, pIf->dwIpIndex, NOT_RESTRICTION);
    }
    return(STATUS_SUCCESS);
}



NTSTATUS
UnSetFiltersEx(
           IN PPFFCB                  Fcb,
           IN PPAGED_FILTER_INTERFACE pPage,
           IN DWORD                   dwLength,
           IN PFILTER_DRIVER_SET_FILTERS pInfo)
/*++
    Routine Description:
        Unset a list of filters from an interface. This is the
        inverse operation of SetFilterEx

--*/
{
    PRTR_TOC_ENTRY      pInToc,pOutToc;
    PFILTER_INTERFACE   pIf = pPage->pFilter;
    PFILTER_DESCRIPTOR2 pFilterDescIn, pFilterDescOut;
    PPAGED_FILTER             pIn = NULL, pOut = NULL;
    DWORD                 i;
    PPAGED_FILTER       pPFilter;
    NTSTATUS            Status = STATUS_SUCCESS;
    PBYTE               pbEnd = (PBYTE)pInfo + dwLength;
    DWORD               dwFiltersRemoved = 0;

    PAGED_CODE();

    if(pPage->pFilter->dwGlobalEnables & FI_ENABLE_OLD)
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    pInToc  = GetPointerToTocEntry(IP_FILTER_DRIVER_IN_FILTER_INFO,
                                   &pInfo->ribhInfoBlock);

    pOutToc = GetPointerToTocEntry(IP_FILTER_DRIVER_OUT_FILTER_INFO,
                                   &pInfo->ribhInfoBlock);

    if(pInToc && pInToc->InfoSize)
    {
        //
        // filters are defined.
        //

        pFilterDescIn  = GetInfoFromTocEntry(&pInfo->ribhInfoBlock,
                                             pInToc);
        if((pFilterDescIn != NULL) && (pFilterDescIn->dwVersion != 2))
        {
            TRACE(CONFIG,("IPFLTDRV: Invalid version for FiltersEx\n"));
            return(STATUS_INVALID_PARAMETER);
        }
    }
    else
    {
        pFilterDescIn = NULL;
    }

    if(pOutToc && pOutToc->InfoSize)
    {
        //
        // filters are defined.
        //

        pFilterDescOut  = GetInfoFromTocEntry(&pInfo->ribhInfoBlock,
                                              pOutToc);
        if((pFilterDescOut != NULL) && (pFilterDescOut->dwVersion != 2))
        {
            TRACE(CONFIG,("IPFLTDRV: Invalid version for FiltersEx\n"));
            return(STATUS_INVALID_PARAMETER);
        }
    }
    else
    {
        pFilterDescOut = NULL;
    }

    if((pFilterDescIn && !CheckDescriptorSize(pFilterDescIn, pbEnd))
                            ||
       (pFilterDescOut && !CheckDescriptorSize(pFilterDescOut, pbEnd)) )
    {
        return(STATUS_BUFFER_TOO_SMALL);
    }
    //
    // For each set of filters, remove the filters from the
    // paged interface and thence from the match interface

    if(pFilterDescIn)
    {

        //
        // Removing in filters. For each filter, process as
        // needed. Input filters include the global checks
        /// such as spoofing.
        //

        RemoveFilterWorker(Fcb,
                           &pFilterDescIn->fiFilter[0],
                           pFilterDescIn->dwNumFilters,
                           pPage,
                           &dwFiltersRemoved,
                           TRUE);
    }

    //
    // now the output filters. This is a bit simpler since there
    // are no global settings.
    //

    if(pFilterDescOut)
    {

        //
        // Adding in filters. For each filter, process as
        // needed. Input filters include the global checks
        /// such as spoofing.
        //

        RemoveFilterWorker(Fcb,
                           &pFilterDescOut->fiFilter[0],
                           pFilterDescOut->dwNumFilters,
                           pPage,
                           &dwFiltersRemoved,
                           FALSE);
    }
    if(dwFiltersRemoved)
    {
        NotifyFastPath(pIf, pIf->dwIpIndex, NOT_RESTRICTION);
    }
    return(STATUS_SUCCESS);
}


VOID
RemoveFilterWorker(
    PPFFCB         Fcb,
    PFILTER_INFOEX pFilt,
    DWORD          dwCount,
    PPAGED_FILTER_INTERFACE pPage,
    PDWORD         pdwRemoved,
    BOOL           fInFilter)
{
    NTSTATUS Status;

    //
    // If a regular filter, add it. If a special, global
    // filter, handle it specially.
    //

    while(dwCount)
    {
        if(fInFilter || (pFilt->type == PFE_FILTER))
        {
            Status = FindAndRemovePagedFilter(
                          Fcb,
                          pFilt,
                          fInFilter,
                          pdwRemoved,
                          pPage);
            if(!NT_SUCCESS(Status))
            {
                ERROR(("IPFLTDRV: Removing filter failed %x\n", Status));
            }
        }
        else
        {
            ERROR(("IPFLTDRV: Ignoring global out filter\n"));
        }
        dwCount--;
        pFilt++;
    }
}

NTSTATUS 
SetInterfaceBinding(PINTERFACEBINDING pBind,
                    PPAGED_FILTER_INTERFACE pPage)
{

    INTERFACEBINDING2 Bind2;
    NTSTATUS status;

    //
    // Rather than duplicating the code for the new & the old routine
    // call the new routine by transforming old structure to the new
    // structure.
    //

    Bind2.pvDriverContext = pBind->pvDriverContext;
    Bind2.pfType = pBind->pfType;
    Bind2.dwAdd = pBind->dwAdd;
    Bind2.dwEpoch = pBind->dwEpoch;
    Bind2.dwLinkAdd = 0;

    status = SetInterfaceBinding2(&Bind2, pPage);
    pBind->dwEpoch = Bind2.dwEpoch;

    return(status);
}

NTSTATUS
SetInterfaceBinding2(PINTERFACEBINDING2 pBind,
                     PPAGED_FILTER_INTERFACE pPage)
{
    PFILTER_INTERFACE pIf1, pIf = pPage->pFilter;
    NTSTATUS Status;
    LOCK_STATE LockState;
    DWORD dwBind, dwOldBind;

    if(pPage->pFilter->dwGlobalEnables & FI_ENABLE_OLD)
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    KeEnterCriticalRegion(); 
    ExAcquireResourceExclusiveLite(&FilterListResourceLock, TRUE);

    //
    // verify binding type
    //

    switch(pBind->pfType)
    {
        default:
            dwBind = UNKNOWN_IP_INDEX;
            break;

        case PF_BIND_INTERFACEINDEX:
            (VOID)GetIpStackIndex(0, TRUE);   // make sure have this list
            dwBind = pBind->dwAdd;
            break;

        case PF_BIND_IPV4ADDRESS:

            dwBind = GetIpStackIndex((IPAddr)pBind->dwAdd, TRUE);
            break;
    }

    //
    // Make sure  it is not bound or if it is that it is
    // bound to this interface
    //

    if(((pIf->dwIpIndex != UNKNOWN_IP_INDEX) && 
        (pIf->dwIpIndex != dwBind)  &&
        (pIf->dwLinkIpAddress != pBind->dwLinkAdd) )
                ||
       (dwBind == UNKNOWN_IP_INDEX)
      )
    {
         Status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        BOOL fFound = FALSE;
        PLIST_ENTRY pList;

        //
        // verify that this is not already in use by some other
        // interface
        //
        dwOldBind = pIf->dwIpIndex;

        AcquireWriteLock(&g_filters.ifListLock,&LockState);

        for(pList = g_filters.leIfListHead.Flink;
            pList != &g_filters.leIfListHead;
            pList = pList->Flink)
        {
            pIf1 = CONTAINING_RECORD(pList, FILTER_INTERFACE, leIfLink);

            if((pIf1->dwIpIndex == dwBind) && (pIf1->dwLinkIpAddress == pBind->dwLinkAdd))
            {
                //
                // found it.
                //
                fFound = TRUE;
                break;
            }
        }

        if(!fFound)
        {
            pIf->dwIpIndex = dwBind;
            pIf->dwLinkIpAddress = pBind->dwLinkAdd;
            InterlockedIncrement(&g_ulBoundInterfaceCount);

            TRACE(CONFIG,(
                "IPFLTDRV: Bound Interface Index=%d, Link=%d, TotalCnt=%d\n", 
                 dwBind, 
                 pBind->dwLinkAdd, 
                 g_ulBoundInterfaceCount
                 ));
        }

        ReleaseWriteLock(&g_filters.ifListLock,&LockState);

        if(fFound)
        {
            if(pIf1 == pIf)
            {
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {

            NotifyFastPathIf(pIf);
            if(!++pIf->dwBindEpoch)
            {
                pIf->dwBindEpoch++;
            }
            Status = STATUS_SUCCESS;
        }
    }

    pBind->dwEpoch = pIf->dwBindEpoch;
    ExReleaseResourceLite(&FilterListResourceLock);
    KeLeaveCriticalRegion();
    return(Status);
}

NTSTATUS
ClearInterfaceBinding(PPAGED_FILTER_INTERFACE pPage,
                      PINTERFACEBINDING pBind)
{
    PFILTER_INTERFACE pIf = pPage->pFilter;
    NTSTATUS Status;

    if(pIf->dwGlobalEnables & FI_ENABLE_OLD)
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&FilterListResourceLock, TRUE);

    //
    // Make sure it is bound
    //

    if((pIf->dwIpIndex == UNKNOWN_IP_INDEX)
                     ||
        ( pBind->dwEpoch
                     &&
          (pIf->dwBindEpoch != pBind->dwEpoch)))
    {
         Status = STATUS_SUCCESS;
    }
    else
    {
        
        
        LOCK_STATE LockState;
        DWORD dwIndex;

        AcquireWriteLock(&g_filters.ifListLock,&LockState);
        InterlockedCleanCache(g_filters.pInterfaceCache, pIf->dwIpIndex, pIf->dwLinkIpAddress);
        InterlockedDecrement(&g_ulBoundInterfaceCount);
        
        TRACE(CONFIG,(
            "IPFLTDRV: UnBound Interface Index=%d, Link=%d, TotalCnt=%d\n", 
             pIf->dwIpIndex, 
             pIf->dwLinkIpAddress, 
             g_ulBoundInterfaceCount
             ));

        ClearCache();
        ReleaseWriteLock(&g_filters.ifListLock, &LockState);

        dwIndex = pIf->dwIpIndex;
        pIf->dwIpIndex = UNKNOWN_IP_INDEX;
        NotifyFastPath(pIf, dwIndex, NOT_UNBIND);
        Status = STATUS_SUCCESS;
        
    }
    ExReleaseResourceLite(&FilterListResourceLock);
    KeLeaveCriticalRegion();
    return(Status);
}


NTSTATUS
DeletePagedInterface(PPFFCB Fcb, PPAGED_FILTER_INTERFACE pPage)
/*++
    Routine Description:
       Delete the filters and this interface
--*/
{
    PLIST_ENTRY pList;
    PPAGED_FILTER pf;
    PPAGED_FILTER pfp = NULL;
    DWORD i;
    DWORD dwDummy;


    PAGED_CODE();

    if(pPage->pFilter->dwGlobalEnables & FI_ENABLE_OLD)
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    for(pList = pPage->leSpecialFilterList.Flink;
        pList != &pPage->leSpecialFilterList;
        pList = pList->Flink)
    {
        pf = CONTAINING_RECORD(pList, PAGED_FILTER, leSpecialList);
        pf->pFilters = pfp;
        pfp = pf;
    }
    for(i = 0; i < g_dwHashLists; i++)
    {
        for(pList = pPage->HashList[i].Flink;
            pList != &pPage->HashList[i];
            pList = pList->Flink)
        {
            pf = CONTAINING_RECORD(pList, PAGED_FILTER, leHash);
            pf->pFilters = pfp;
            pfp = pf;
        }
    }
    FreePagedFilterList(Fcb, pfp, pPage, &dwDummy);
    DereferenceFilterInterface(pPage->pFilter, pPage->pLog);
    if(pPage->pLog)
    {
        DereferenceLog(pPage->pLog);
    }

    ExFreePool(pPage);
    return(STATUS_SUCCESS);
}
NTSTATUS
GetFiltersEx(
           IN  PFILTER_INTERFACE  pIf,
           IN  BOOL               fClear,
           OUT PFILTER_STATS_EX   pInfo
           )
/*++
  Routine Description
      Gets filters and statistics associated with an interface
      It is called with the Spin Lock held as reader

  Arguments
      pvIf    Pointer to FILTER_INTERFACE structure which was passed as a PVOID
              to router manager as a context for the interface
      pInfo   FILTER_IF structure filled in by driver

  Return Value

--*/
{
    DWORD i,dwNumInFilters,dwNumOutFilters;
    PFILTER pf;
    PLIST_ENTRY List;

    dwNumInFilters = pIf->dwNumInFilters;
    dwNumOutFilters = pIf->dwNumOutFilters;

    for(i = 0, List = pIf->pleInFilterSet.Flink;
        List != &pIf->pleInFilterSet;
        i++, List = List->Flink)
    {
        PFILTER_INFOEX pEx = &pInfo->info;
        PFILTER_INFO2 pFilt = &pEx->info;

        pf = CONTAINING_RECORD(List, FILTER, pleFilters);
        pInfo->dwNumPacketsFiltered = (DWORD)pf->Count.lCount;;
        if(fClear)
        {
            pf->Count.lCount = 0;
        }

        pEx->dwFilterRule = pf->dwFilterRule;
        pEx->type = PFE_FILTER;
        pEx->dwFlags = pf->dwFlags & FLAGS_INFOEX_ALLFLAGS;
        pFilt->addrType      = IPV4;
        pFilt->dwaSrcAddr[0]  = pf->SRC_ADDR;
        pFilt->dwaSrcMask[0]  = pf->SRC_MASK;
        pFilt->dwaDstAddr[0]  = pf->DEST_ADDR;
        pFilt->dwaDstMask[0]  = pf->DEST_MASK;
        pFilt->dwProtocol = pf->PROTO;
        pFilt->fLateBound = pf->fLateBound;
        pFilt->wSrcPortHigh = pf->wSrcPortHigh;
        pFilt->wDstPortHigh = pf->wDstPortHigh;

        if(pFilt->dwProtocol == FILTER_PROTO_ICMP)
        {
            if(LOBYTE(LOWORD(pf->uliProtoSrcDstMask.HighPart)) isnot 0xff)
            {
                pFilt->wSrcPort   = FILTER_ICMP_TYPE_ANY;
            }
            else
            {
                pFilt->wSrcPort   =
                  MAKEWORD(LOBYTE(LOWORD(pf->uliProtoSrcDstPort.HighPart)),0x00);
            }

            if(HIBYTE(LOWORD(pf->uliProtoSrcDstMask.HighPart)) isnot 0xff)
            {
                pFilt->wDstPort   = FILTER_ICMP_CODE_ANY;
            }
            else
            {
               pFilt->wDstPort   =
                  MAKEWORD(HIBYTE(LOWORD(pf->uliProtoSrcDstPort.HighPart)),0x00);
            }
        }
        else
        {
            pFilt->wSrcPort =
              LOWORD(pf->uliProtoSrcDstPort.HighPart);
            pFilt->wDstPort =
              HIWORD(pf->uliProtoSrcDstPort.HighPart);
        }
        pInfo++;
    }

    for(i = 0, List = pIf->pleOutFilterSet.Flink;
        List != &pIf->pleOutFilterSet;
        i++, List = List->Flink)
    {
        PFILTER_INFOEX pEx = &pInfo->info;
        PFILTER_INFO2 pFilt = &pEx->info;

        pf = CONTAINING_RECORD(List, FILTER, pleFilters);

        pInfo->dwNumPacketsFiltered =
                         (DWORD)pf->Count.lCount;

        if(fClear)
        {
            pf->Count.lCount = 0;
        }

        pEx->dwFilterRule = pf->dwFilterRule;
        pEx->type = PFE_FILTER;
        pEx->dwFlags = pf->dwFlags & FLAGS_INFOEX_ALLFLAGS;
        pFilt->addrType      = IPV4;
        pFilt->dwaSrcAddr[0]  = pf->SRC_ADDR;
        pFilt->dwaSrcMask[0]  = pf->SRC_MASK;
        pFilt->dwaDstAddr[0]  = pf->DEST_ADDR;
        pFilt->dwaDstMask[0]  = pf->DEST_MASK;
        pFilt->dwProtocol = pf->PROTO;
        pFilt->fLateBound = pf->fLateBound;

        if(pFilt->dwProtocol == FILTER_PROTO_ICMP)
        {
            if(LOBYTE(LOWORD(pf->uliProtoSrcDstMask.HighPart)) isnot 0xff)
            {
                pFilt->wSrcPort   = FILTER_ICMP_TYPE_ANY;
            }
            else
            {
                pFilt->wSrcPort   =
                  MAKEWORD(LOBYTE(LOWORD(pf->uliProtoSrcDstPort.HighPart)),0x00);
            }

            if(HIBYTE(LOWORD(pf->uliProtoSrcDstMask.HighPart)) isnot 0xff)
            {
                pFilt->wDstPort   = FILTER_ICMP_CODE_ANY;
            }
            else
            {
                pFilt->wDstPort   =
                  MAKEWORD(HIBYTE(LOWORD(pf->uliProtoSrcDstPort.HighPart)),0x00);
            }
        }
        else
        {
            pFilt->wSrcPort =
              LOWORD(pf->uliProtoSrcDstPort.HighPart);
            pFilt->wDstPort =
              HIWORD(pf->uliProtoSrcDstPort.HighPart);
        }
        pInfo++;
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
GetInterfaceParameters(PPAGED_FILTER_INTERFACE pPage,
                       PPFGETINTERFACEPARAMETERS pp,
                       PDWORD                   pdwSize)
/*++
  Routine Description:
     Read the information about an interface

  pPage -- the paged filter interface
  pp    -- the user's args to this
  pdwSize -- the size of the buffer on IN and the bytes used on OUT
--*/
{
    PFILTER_INTERFACE pIf;
    DWORD             dwFilterSize;
    BOOL fClear = (pp->dwFlags & GET_FLAGS_RESET) != 0;
    LOCK_STATE LockState;


    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&FilterListResourceLock, TRUE);

    if(!pPage)
    {
        pIf = FindMatchName(0, (DWORD)((DWORD_PTR)pp->pvDriverContext));
        if(!pIf)
        {
            ExReleaseResourceLite(&FilterListResourceLock);
            KeLeaveCriticalRegion();
            return(STATUS_INVALID_PARAMETER);
       }
    }
    else
    {
        pIf = pPage->pFilter;
    }

    if(pIf->dwGlobalEnables & FI_ENABLE_OLD)
    {
        ExReleaseResourceLite(&FilterListResourceLock);
        KeLeaveCriticalRegion();
        return(STATUS_INVALID_DEVICE_REQUEST);
    }



    //
    // fill in what we can fill in. Need to double lock -- the
    // outer to prevent the interface from going away and filters
    // being changed, the inner to protect the counts.
    //

    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    pp->dwInDrops = (DWORD)pIf->lTotalInDrops;
    pp->dwOutDrops = (DWORD)pIf->lTotalOutDrops;

    pp->dwSynOrFrag = (DWORD)pIf->CountSynOrFrag.lCount +
                       (DWORD)pIf->CountNoFrag.lCount;
    pp->dwSpoof = (DWORD)pIf->CountSpoof.lCount +
                  (DWORD)pIf->CountStrongHost.lCount;
    pp->dwUnused = (DWORD)pIf->CountUnused.lCount;
    pp->dwTcpCtl = (DWORD)pIf->CountCtl.lCount;
    pp->liSYN.QuadPart    = pIf->liSYNCount.QuadPart;
    pp->liTotalLogged.QuadPart = pIf->liLoggedFrames.QuadPart;
    pp->dwLostLogEntries = pIf->dwLostFrames;

    pp->eaInAction = pIf->eaInAction;
    pp->eaOutAction = pIf->eaOutAction;

    pp->dwNumInFilters = pIf->dwNumInFilters;
    pp->dwNumOutFilters = pIf->dwNumOutFilters;

    dwFilterSize = (pIf->dwNumInFilters + pIf->dwNumOutFilters) *
                        sizeof(FILTER_STATS_EX);

    if((pp->dwFlags & GET_FLAGS_FILTERS) != 0)
    {
        //
        // Make sure all of the filters fit
        //

        if((*pdwSize -
             (sizeof(PFGETINTERFACEPARAMETERS) - sizeof(FILTER_STATS_EX))) <
           dwFilterSize)
        {
            //
            // doesn't fit. Return the required size
            //

            pp->dwReserved = 
                       dwFilterSize + (sizeof(PFGETINTERFACEPARAMETERS) -
                                       sizeof(FILTER_STATS_EX));
            ReleaseWriteLock(&g_filters.ifListLock, &LockState);
            ExReleaseResourceLite(&FilterListResourceLock);
            KeLeaveCriticalRegion();
            return(STATUS_SUCCESS);
        }

        (VOID)GetFiltersEx(pIf,
                          fClear,
                          &pp->FilterInfo[0]);
    }

    //
    // if clear requested, do it now
    //
    if(fClear)
    {
        pIf->lTotalInDrops = 0;
        pIf->lTotalOutDrops = 0;
        pIf->CountSynOrFrag.lCount = 0;
        pIf->CountNoFrag.lCount = 0;
        pIf->CountFragCache.lCount = 0;
        pIf->CountSpoof.lCount = 0;
        pIf->CountUnused.lCount = 0;
        pIf->CountCtl.lCount = 0;
        pIf->CountStrongHost.lCount = 0;
        pIf->liSYNCount.QuadPart = 0;
        pIf->liLoggedFrames.QuadPart = 0;
        pIf->dwLostFrames = 0;
    }
    ReleaseWriteLock(&g_filters.ifListLock, &LockState);

    ExReleaseResourceLite(&FilterListResourceLock);
    KeLeaveCriticalRegion();
    return(STATUS_SUCCESS);
}

NTSTATUS
GetSynCountTotal(PFILTER_DRIVER_GET_SYN_COUNT pscCount)
/*++
  Routine Description:
    Get sum of SYNs on filter interfaces
--*/
{
    PFILTER_INTERFACE pIf;
    PLIST_ENTRY pList;
    LOCK_STATE LockState;
    LONGLONG llCount = 0;

    AcquireWriteLock(&g_filters.ifListLock,&LockState);

    for(pList = g_filters.leIfListHead.Flink;
        pList != &g_filters.leIfListHead;
        pList = pList->Flink)
    {

        pIf = CONTAINING_RECORD(pList, FILTER_INTERFACE, leIfLink);

        if(!(pIf->dwGlobalEnables & FI_ENABLE_OLD))
        {
            //
            // accumulate it here to avoid page faults.
            //
            llCount += pIf->liSYNCount.QuadPart;
        }
    }
    ReleaseWriteLock(&g_filters.ifListLock,&LockState);

    //
    // Now that no lock is held, store into the pageable
    // value
    //
    pscCount->liCount.QuadPart = llCount;
    return(STATUS_SUCCESS);
}

VOID
NotifyFastPath(PFILTER_INTERFACE pIf, DWORD dwIndex, DWORD dwCode)
/*++
Routine Description:
   Called whenever the filter of an interface change so that
   we can tell the fast path code to clear its cache. This
   must be called at base level as it might sleep or yield.
--*/
{
    DWORD dwFilterCount = 1;

    if(dwIndex != UNKNOWN_IP_INDEX)
    {
        InterlockedIncrement(&pIf->lNotify);
        if(dwCode == NOT_UNBIND)
        {
            LARGE_INTEGER liInterval;
            //
            // it's an unbind. Wait for all existing callouts to
            // complete.
            //

            liInterval.QuadPart = -1000;        // short delay. Start with
                                               //  100 us;
            while(pIf->lNotify > 1)
            {
                //
                // small delay to allow this to settle
                //

                KeDelayExecutionThread(KernelMode, FALSE, &liInterval);
                liInterval.QuadPart *= 2;
            }
            dwFilterCount = 0;
        }
        //
        // tell the fast path of this
        //
        InterlockedDecrement(&pIf->lNotify);
    }
}

VOID
NotifyFastPathIf(PFILTER_INTERFACE pIf)
/*++
Routine Description:
  Same as above, but this is called when an interface is first
  bound. Notify only if it has filters or is a DROP interface
--*/
{
    if(
       (pIf->eaInAction == DROP)
             ||
       (pIf->eaOutAction == DROP)
             ||
       pIf->dwNumInFilters
             ||
       pIf->dwNumOutFilters)
    {
        NotifyFastPath(pIf, pIf->dwIpIndex, NOT_RESTRICTION);
    }
}

NTSTATUS
SetExtensionPointer(
                  PPF_SET_EXTENSION_HOOK_INFO Info,
                  PFILE_OBJECT FileObject
                  )
{
    LOCK_STATE LockState;
    PFILTER_INTERFACE pIf;
    PLIST_ENTRY pList;

    AcquireWriteLock(&g_Extension.ExtLock, &LockState);
    if (Info->ExtensionPointer == NULL) 
    {
        //
        // Extension hook is already set to NULL, be strict about it.
        //

        if (g_Extension.ExtPointer == NULL) 
        {
            ReleaseWriteLock(&g_Extension.ExtLock, &LockState);
            return(STATUS_INVALID_PARAMETER);
        }

        //
        // File object of the entity hooking and unhooking should match.
        //
        
        if (g_Extension.ExtFileObject != FileObject) 
        {
            ReleaseWriteLock(&g_Extension.ExtLock, &LockState);
            return(STATUS_INVALID_PARAMETER);
        }


        g_Extension.ExtPointer = NULL;
        g_Extension.ExtFileObject = NULL;
        
    }
    else 
    {
        //
        // We are setting the extension pointer to a non NULL value. The extension pointer must
        // be already set to NULL to begin with, otherwise someone else registered it already.
        // 
 
        if (g_Extension.ExtPointer != NULL) 
        {
            ReleaseWriteLock(&g_Extension.ExtLock,&LockState);
            return(STATUS_INVALID_PARAMETER);
        }

        // 
        // Record the file object here, every other call should be validated against this 
        // file object.
        //
 
        g_Extension.ExtFileObject = FileObject;
        g_Extension.ExtPointer = Info->ExtensionPointer ;
       
    }

    CALLTRACE(("IPFLTDRV: SetExtensionPointer SUCCESSFUL\n"));
    ReleaseWriteLock(&g_Extension.ExtLock,&LockState);
    
    return(STATUS_SUCCESS);

}


PFILTER_INTERFACE
FilterDriverLookupInterface(
    IN ULONG Index,
    IN IPAddr LinkNextHop
    )

/*++
Routine Description:

    This routine is invoked to search for an interface with the given index
    in our list of interfaces.
--*/

{
    PFILTER_INTERFACE pIf;
    PLIST_ENTRY pList;

    for (pList = g_filters.leIfListHead.Flink;
         pList != &g_filters.leIfListHead;
         pList = pList->Flink) 
    {

        pIf = CONTAINING_RECORD(pList, FILTER_INTERFACE, leIfLink);
        if ((pIf->dwIpIndex == Index) && (pIf->dwLinkIpAddress == LinkNextHop))
        {
            TRACE(CONFIG,(
                 "IPFLTDRV: LookupIF: Found Entry %8x for Index=%d, NextHop=%d\n", 
                 pIf, 
                 Index, 
                 LinkNextHop
                 ));

            return pIf; 
        } 
    }

    return NULL;

} // FilterDriverLookupInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\logger.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    logger.c

Abstract:

    Most of the code to manage logs. The interlocking is fairly simple,
    but worth a note. Each log structure has a kernel resource. This
    is used to protect the volatile structures. In addition, some
    of the things in a log structure are examined by the
    DPC match code. Any such values should be modified only
    with the log lock held. Note that the DPC code only
    modifies the UseCount of a log structure, but it relies
    on some of the flags and the log size values to know whether
    the log is valid and whether there is room for more data.

    There is also a paged counterpart for each log, but it
    is very simple and exists only to reference the real log
    structure.

Author:



Revision History:

--*/
/*----------------------------------------------------------------------------
A note on the interlocking, as of 24-Feb-1997.

There are three important locks: the FilterListResourceLock which is
a resource, the  g_filter.ifListLock, which is a spin lock but acts
like a resource, and the log lock of each log each of which is a spin
lock. As noted in ioctl.c, the first two locks are used to serialize
operations among APIs and DPCs respectively.  The log lock is also used
to serialize DPC operations and is used as a finer-grained interlocked. Aside
from granularity it is required to serialize on an MP since there can a DPC
callout on each processor!

The correct order is always to lock the FilterListResourceLock first, then
the g_filter.ifListLock and finally the appropriate log lock. It is never
correct to lock more than one log lock since no ordering among logs exists (if
you need this you will have to invent it). The log lock is always an exclusive
lock -- that is it does not act like a resource.

The log also has a RESOURCE. This is used to protect the mapping. Note that
if Apc is enabled, this does not prevent a conflict between the Apc routine
and the base thread code. There is a unique test in the Apc routine to detect
and recover from this.

----------------------------------------------------------------------------*/


#include "globals.h"
#include <align.h>

LIST_ENTRY g_pLogs;

DWORD g_dwLogClump;
extern POBJECT_TYPE *ExEventObjectType;


VOID
PfLogApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
RemoveLogFromInterfaces(PPFLOGINTERFACE pLog);

NTSTATUS
DoAMapping(
       PBYTE  pbVA,
       DWORD  dwSize,
       PMDL * pMdl,
       PBYTE * pbKernelVA);

VOID
PfCancelIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PPFPAGEDLOG
FindLogById(PPFFCB Fcb, PFLOGGER LogId);


#pragma alloc_text(PAGED, FindLogById)
#pragma alloc_text(PAGED, ReferenceLogByHandleId)


VOID
SetCancelOnIrp(PIRP Irp,
               PPFLOGINTERFACE pLog)
{
    IoAcquireCancelSpinLock(&Irp->CancelIrql);
    
    #if DOLOGAPC //according to arnold miller it is broken
    Irp->IoStatus.Status = pLog;
    #endif
    
    IoSetCancelRoutine(Irp, PfCancelIrp);
    IoReleaseCancelSpinLock(Irp->CancelIrql);
}

VOID
InitLogs()
{
    InitializeListHead(&g_pLogs);

    //
    // It's possible to get this from the registry
    //
    g_dwLogClump = MAX_NOMINAL_LOG_MAP;
}

VOID
AddRefToLog(PPFLOGINTERFACE pLog)
{
    InterlockedIncrement(&pLog->UseCount);
}

PPFPAGEDLOG
FindLogById(PPFFCB Fcb, PFLOGGER LogId)
{
    PPFPAGEDLOG pPage;

    PAGED_CODE();

    for(pPage = (PPFPAGEDLOG)Fcb->leLogs.Flink;
        (PLIST_ENTRY)pPage != &Fcb->leLogs;
        pPage = (PPFPAGEDLOG)pPage->Next.Flink)
    {
        if((PFLOGGER)pPage == LogId)
        {
            return(pPage);
        }
    }
    return(NULL);
}

NTSTATUS
ReferenceLogByHandleId(PFLOGGER LogId,
                       PPFFCB  Fcb,
                       PPFLOGINTERFACE * ppLog)
/*++
    Routine Description:

    Given a log ID, find the log entry, reference it, and return
    a pointer to the underlying log structure.
--*/
{
    PPFPAGEDLOG pPage;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();


    pPage = FindLogById(Fcb, LogId);
    if(pPage)
    {
        *ppLog = pPage->pLog;

        //
        // don't need the write lock since the reference
        // from the FCB is good enough
        //
        InterlockedIncrement(&pPage->pLog->UseCount);
        Status = STATUS_SUCCESS;
    }
    return(Status);
}

NTSTATUS
PfDeleteLog(PPFDELETELOG pfDel,
            PPFFCB Fcb)
/*++
  Routine Description:
      Called when the log is deleted by the process either
      explicity or by closing the handle. The paged log
      structure is taken care of by the caller.
--*/
{
    KIRQL kIrql;
    PPFPAGEDLOG pPage;
    PPFLOGINTERFACE pLog;

    pPage = FindLogById(Fcb, pfDel->pfLogId);
    if(!pPage)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    pLog = pPage->pLog;

    //
    // grab the interlocks
    // 
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&pLog->Resource, TRUE);

    kIrql = LockLog(pLog);

    pLog->dwFlags |= LOG_BADMEM;       // shut off logging

    UnLockLog(pLog, kIrql);

#if DOLOGAPC
    if(pLog->Irp)
    {
        pLog->Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(pLog->Irp, IO_NO_INCREMENT);
        DereferenceLog(pLog);
        pLog->Irp = NULL;
    }
#endif

    //
    // if a current mapping, unmap it
    //

    if(pLog->Mdl)
    {
        MmUnlockPages(pLog->Mdl);
        IoFreeMdl(pLog->Mdl);
        pLog->Mdl = 0;
    }

    //
    // Need to remove it from the interfaces. Do this with
    // the resource unlocked. Since the FCB still has the log referenced,
    // and the FCB is locked, the log should not go away. The only
    // compelling reason for the resource is to interlock against APCs and
    // setting BADMEM should have taken care of that.
    //

    ExReleaseResourceLite(&pLog->Resource);
    KeLeaveCriticalRegion();

    RemoveLogFromInterfaces(pLog);

    //
    // free the paged log structure
    //
    RemoveEntryList(&pPage->Next);
    ExFreePool(pPage);

    //
    // Dereference the log structure. It might or might not
    // go away.
    //
    DereferenceLog(pLog);
    return(STATUS_SUCCESS);
}

VOID
DereferenceLog(PPFLOGINTERFACE pLog)
/*++
    Routine Description:

    Derefence the log and if the reference count goes to zero,
    free the log.
--*/

{
    BOOL fFreed;
    LOCK_STATE LockState;

    //
    // grab the resource to prevent confusion with cancelled
    // Irps.
    //

    
    fFreed = InterlockedDecrement(&pLog->UseCount) == 0;

    if(fFreed)
    {
        AcquireWriteLock(&g_filters.ifListLock,&LockState);
        RemoveEntryList(&pLog->NextLog);
        ReleaseWriteLock(&g_filters.ifListLock,&LockState);

#if DOLOGAPC
        ASSERT(!pLog->Irp && !pLog->Mdl);
#endif

        if(pLog->Event)
        {
            ObDereferenceObject(pLog->Event);
        }

        ExDeleteResourceLite( &pLog->Resource);
        ExFreePool(pLog);
    }
}

NTSTATUS
PfLogCreateLog(PPFLOG pLog,
               PPFFCB Fcb,
               PIRP Irp)
/*++
  Routine Description:
     Create a new log entry.
--*/
{
    PPFLOGINTERFACE pfLog;
    KPROCESSOR_MODE Mode;
    NTSTATUS Status;
    LOCK_STATE LockState;
    DWORD dwBytesMapped;
    PBYTE pbKernelAddress;
    PPFPAGEDLOG pPage;

    PAGED_CODE();

    pPage = (PPFPAGEDLOG)ExAllocatePoolWithTag(
                    PagedPool,
                    sizeof(*pPage),
                    'pflg');
    if(!pPage)
    {
        return(STATUS_NO_MEMORY);
    }

    pfLog = (PPFLOGINTERFACE)ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(*pfLog),
                    'pflg');

    if(!pfLog)
    {
        ExFreePool(pPage);
        return(STATUS_NO_MEMORY);
    }

    RtlZeroMemory(pfLog, sizeof(*pfLog));

    ExInitializeResourceLite(&pfLog->Resource);

    if(pLog->hEvent)
    {
        Mode = ExGetPreviousMode();
        Status = ObReferenceObjectByHandle(
                       pLog->hEvent,
                       EVENT_MODIFY_STATE,
                       *ExEventObjectType,  
                       Mode,
                       (PVOID *)&pfLog->Event,
                       NULL);
        if(!NT_SUCCESS(Status))
        {
            goto Bad;
        }
    }

    pLog->pfLogId = pfLog->pfLogId = (PFLOGGER)pPage;

    //
    // Copy the user addresses. Note we don't probe it because this is
    // too expensive. The probing is done when we remap the buffer,
    // either now or in the APC.
    //

    pfLog->pUserAddress = 0;
    pfLog->dwTotalSize = 0;
    pfLog->dwPastMapped = 0;
    pfLog->dwMapOffset = 0;
    pfLog->dwMapCount = 0;


    if(pLog->dwFlags & LOG_LOG_ABSORB)
    {
        pfLog->dwMapWindowSize = MAX_ABSORB_LOG_MAP;
    }
    else
    {
        pfLog->dwMapWindowSize = g_dwLogClump;
    }

    pfLog->dwMapWindowSize2 = pfLog->dwMapWindowSize * 2;
    pfLog->dwMapWindowSizeFloor = pfLog->dwMapWindowSize / 2;

    pfLog->dwMapCount = 0;

    //
    // Mapped. Note we don't save room for the header since
    // that will be returned when the caller calls to release
    // the buffer.
    //
    pfLog->UseCount = 1;

    //
    // Add it to the list of Logs.
    //

    KeInitializeSpinLock(&pfLog->LogLock);
    
    AcquireWriteLock(&g_filters.ifListLock,&LockState);
    InsertTailList(&g_pLogs, &pfLog->NextLog);
    ReleaseWriteLock(&g_filters.ifListLock,&LockState);

    pPage->pLog = pfLog;

    InsertTailList(&Fcb->leLogs, &pPage->Next);

    return(STATUS_SUCCESS);

    //
    // if here, something went awry. Clean up and return the status
    //
Bad:

    ExDeleteResourceLite(&pfLog->Resource);

    if(pfLog->Event)
    {
        ObDereferenceObject(pfLog->Event);
    }
    ExFreePool(pPage);
    ExFreePool(pfLog);
    return(Status);
}

NTSTATUS
PfLogSetBuffer( PPFSETBUFFER pSet, PPFFCB Fcb, PIRP Irp )
/*++
  Routine Description:
     Set a new buffer for the log. Return use count of the old buffer
     as well.
--*/
{
    PMDL Mdl;
    PBYTE pbKernelAddress;
    DWORD dwBytesMapped, dwOldUsed, dwOldLost;
    NTSTATUS Status;
    PBYTE pbVA = pSet->pbBaseOfLog;
    DWORD dwSize = pSet->dwSize;
    DWORD dwSize1 = pSet->dwEntriesThreshold;
    DWORD dwThreshold = pSet->dwSizeThreshold;
    DWORD dwLoggedEntries;
    KIRQL kIrql;
    PPFLOGINTERFACE pLog;
    PPFPAGEDLOG pPage;
    PPFSETBUFFER pLogOut = Irp->UserBuffer;
    PBYTE pbUserAdd;

    if(!COUNT_IS_ALIGNED(dwSize, ALIGN_WORST))
    {
        //
        // not quadword aligned. tsk tsk. 
        //

        return(STATUS_MAPPED_ALIGNMENT);
    }
   
    if(!(pPage = FindLogById(Fcb, pSet->pfLogId)))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    pLog = pPage->pLog;

    //
    // Acquire the resource that protects the mapping.
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&pLog->Resource, TRUE);
    //
    // Now map the first segment.  
    //
#if DOLOGAPC

    if(dwSize < pLog->dwMapWindowSize2)
    {
        dwBytesMapped = dwSize;
    }
    else
    {
        dwBytesMapped = pLog->dwMapWindowSize;
    }
#else
    dwBytesMapped = dwSize;
#endif

    if(dwBytesMapped)
    {
        Status = DoAMapping(
                    pbVA,
                    dwBytesMapped,
                    &Mdl,
                    &pbKernelAddress);
    }
    else
    {
        Status = STATUS_SUCCESS;
        pbKernelAddress = 0;
        pbVA = NULL;
        Mdl = NULL;
    }

    if(NT_SUCCESS(Status))
    {
        PMDL OldMdl;

        //
        // Made the mapping. Now swap it in.
        //

#if DOLOGAPC
        //
        // init the APC routine.
        //

        KeInitializeApc(
                    &pLog->Apc,
                    &(PsGetCurrentThread()->Tcb),
                    CurrentApcEnvironment,
                    PfLogApc,
                    NULL,
                    NULL,
                    0,
                    NULL);           
        pLog->ApcInited = 1;


        if(pLog->Irp)
        {
            pLog->Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(pLog->Irp, IO_NO_INCREMENT);
            DereferenceLog(pLog);
        }

        if(dwBytesMapped)
        {
            //
            // This appears to be a bug as we have the log
            // resource and will now get the Irp cancel lock. Our
            // cancel routine does this in the other order, giving the
            // appearance of a race to a deadlock, but the cancel routine
            // won't get called until we own all of the locks so
            // we will not be blocked.
            //
            AddRefToLog(pLog);
            SetCancelOnIrp(Irp, pLog);
            pLog->Irp = Irp;
        }
        else
        {
            pLog->Irp = 0;
        }
#endif
        pbUserAdd = pLog->pUserAddress;
        
        //
        // interlock against the stack's DPC callout
        // and "swap" the logs
        //
        kIrql = LockLog(pLog);


        dwOldUsed = pLog->dwPastMapped + pLog->dwMapOffset;
        dwOldLost = pLog->dwLostEntries;
        dwLoggedEntries = pLog->dwLoggedEntries;
        pLog->dwLoggedEntries = 0;
        pLog->dwLostEntries = 0;
        pLog->dwMapCount = dwBytesMapped;
        pLog->dwPastMapped = 0;
        pLog->dwFlags &= ~(LOG_BADMEM | LOG_OUTMEM | LOG_CANTMAP);
        pLog->pUserAddress = pbVA;
        pLog->dwTotalSize =  dwSize;
        OldMdl = pLog->Mdl;
        pLog->pCurrentMapPointer = pbKernelAddress;
        pLog->dwMapOffset = 0;
        pLog->Mdl = Mdl;
        pLog->dwSignalThreshold = dwThreshold;
        pLog->dwEntriesThreshold = dwSize1;
        UnLockLog(pLog, kIrql);

        if(OldMdl)
        {
            MmUnlockPages(OldMdl);
            IoFreeMdl(OldMdl);
        }
        pSet->dwSize = pLogOut->dwSize = dwOldUsed;
        pSet->pbPreviousAddress = pLogOut->pbPreviousAddress = pbUserAdd;
        pSet->dwLostEntries = pLogOut->dwLostEntries = dwOldLost;
        pSet->dwLoggedEntries = pLogOut ->dwLoggedEntries  = dwLoggedEntries;
    }
    ExReleaseResourceLite(&pLog->Resource);
    KeLeaveCriticalRegion();
    if(dwBytesMapped && NT_SUCCESS(Status))
    {
#if LOGAPC
       
        Status = STATUS_PENDING;
#endif
    }
    return(Status);
}

NTSTATUS
DoAMapping(
       PBYTE  pbVA,
       DWORD  dwSize,
       PMDL * ppMdl,
       PBYTE * pbKernelVA)
/*++
  Routine Description:
     Map a user buffer into kernel space and lock it.
     This is called when a log is created as well as
     when the mapped portion of a log needs to be moved.
     The log has a sliding mapped windows so that the
     actual buffer can be large but the system resoures
     committed to it modest. The added cost is in sliding
     the windows as needed.

     The log structure, not known to this routine, should be
     appropriately protected.

  Returns: various status conditions
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    *ppMdl = 0;

    try
    {
        *ppMdl = IoAllocateMdl(
                      (PVOID)pbVA,
                      dwSize,
                      FALSE,
                      TRUE,
                      NULL);
        if(*ppMdl)
        {
            //
            // Got a Mdl. Now lock the pages. If this fails, the exception
            // takes us out of this block.
            //

            MmProbeAndLockPages(*ppMdl,
                                UserMode,
                                IoWriteAccess);

           //
           // all locked. Now map the locked pages to a kernel
           // address. If it fails, unlock the pages.
           //
           *pbKernelVA = MmGetSystemAddressForMdlSafe(*ppMdl, HighPagePriority);
           if (*pbKernelVA == NULL) {
               Status = STATUS_NO_MEMORY;
               MmUnlockPages(*ppMdl);
           }
        }

    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // This covers IoAllocateMdl and MmProbeAndLockPages
        // failing.
        //
        Status = GetExceptionCode();
    }

    if(!NT_SUCCESS(Status))
    {
        if(*ppMdl)
        {
            IoFreeMdl(*ppMdl);
        }
        return(Status);
    }

    if(!*ppMdl)
    {
        return(STATUS_NO_MEMORY);
    }
    

    return(STATUS_SUCCESS);
}


VOID
PfLogApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )
/*++
  Routine Description:
    This is the special APC routine that runs to map or remap a log
    It returns its status via SystemArgument1 which is a pointer
    to the log structure. Note that the log structure was referenced
    when the Apc was enqueued, so the pointer is guaranteed to be
    valid. However, the log itself may not be valid, so the first
    order of business is to lock the log and verify it.
--*/
{
#if DOLOGAPC
    PPFLOGINTERFACE pLog = (PPFLOGINTERFACE)*SystemArgument1;
    PMDL Mdl;
    PBYTE pbVA;
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL kIrql;

    //
    // Need to extend the mapping of this Log. Lock the log. 
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&pLog->Resource, TRUE);

    //
    // slide the mapping as long as the resource has not nested and
    // the log is valid. Note the nesting test is made to prevent
    // the APC routine from interfering with the base thread code
    // that might also be trying to do a log operation.
    //
    if((pLog->Resource.OwnerThreads[0].OwnerCount == 1)
                      &&
        pLog->Irp
                      &&
        !(pLog->dwFlags & LOG_BADMEM))
    {
        DWORD dwSpaceRemaining, dwSpaceToMap, dwOffset;
        //
        // the log is still valid. Slide the mapping down. Because
        // logging may still be going on, the new mapping needs to
        // overlap slightly. Once the new mapping exists, we can
        // fix up the pointers under the spin lock.
        //

        dwSpaceRemaining = pLog->dwTotalSize -
                           (pLog->dwPastMapped + pLog->dwMapCount);
        if(pLog->Event
                &&
           (dwSpaceRemaining < pLog->dwSignalThreshold))
        {
            KeSetEvent(pLog->Event, LOG_PRIO_BOOST, FALSE);
        }

        if(!dwSpaceRemaining)
        {
            //
            // Nothing left to map. Just go away
            //
            pLog->dwFlags |= LOG_CANTMAP;
        }
        else
        {
            //
            // Still space. Grab it. Don't leave anything dangling
            // though. That is, there should always be at least
            // MAX_NOMINAL_LOG_MAP bytes left for the next time.
            //

            if(dwSpaceRemaining < pLog->dwMapWindowSize2 )
            {
                dwSpaceToMap = dwSpaceRemaining;
            }
            else
            {
                dwSpaceToMap = pLog->dwMapWindowSize;
            }


            //
            // Now compute the extra space to map. No need for
            // the lock since the resource prevents remapping
            //

            dwOffset = (volatile DWORD)pLog->dwMapOffset;

            dwSpaceToMap += pLog->dwMapCount - dwOffset;

            //
            // Now the address of the new mapping.
            //

            pbVA = pLog->pUserAddress + dwOffset + pLog->dwPastMapped;

            Status = DoAMapping(
                         pbVA,
                         dwSpaceToMap,
                         &Mdl,
                         &pbVA);

            if(NT_SUCCESS(Status))
            {
                PMDL OldMdl;
                //
                // get the spin lock and slide things down. Also
                // capture the old Mdl so it can be freed.
                //

                kIrql = LockLog(pLog);


                OldMdl = pLog->Mdl;
                pLog->Mdl = Mdl;
                pLog->pCurrentMapPointer = pbVA;
                pLog->dwMapCount = dwSpaceToMap;
                pLog->dwMapOffset -= dwOffset;
                pLog->dwPastMapped += dwOffset;
                UnLockLog(pLog, kIrql);

                if(OldMdl)
                {
                    MmUnlockPages(OldMdl);
                    IoFreeMdl(OldMdl);
                }
            }
            else
            {
                //
                // In principle, this should take the filter spin lock,
                // but whatever race it creates with the match code
                // is harmless, so don't bother.
                //
                pLog->dwFlags |= LOG_OUTMEM;
                pLog->MapStatus = Status;
            }
        }
    }

    //
    // small race here in that the APC is still in progress. However,
    // it is most likely that we advanced the log and therefore
    // an APC won't be needed any time soon. If it is, then it may
    // run needlessly.

    pLog->lApcInProgress = 0;
    ExReleaseResourceLite(&pLog->Resource);           
    KeLeaveCriticalRegion();
    DereferenceLog(pLog);
#endif
}
   

VOID
PfCancelIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
  Routine Description:

     Called when an IRP is cancelled. This is used to catch
     when the thread owning the log terminates.
--*/
{
#if DOLOGAPC
    PPFLOGINTERFACE pLog = (PPFLOGINTERFACE) Irp->IoStatus.Status;

    //
    // Invalidate the log. Unmap the memory. The cancel spin
    // lock prevents the log from going away.
    //

    if(pLog->Irp == Irp)
    {
        KIRQL kIrql;
        PMDL Mdl;

        //
        // Same Irp.
        //

        kIrql = LockLog(pLog);

        //
        // reference it so it won't go away
        //
        AddRefToLog(pLog);
        //
        // if this is still the correct IRP, mark the log invalid. This
        // closes a race with AdvanceLog since LOG_BADMEM will prevent
        // an APC insertion.
        //
        if(pLog->Irp == Irp)
        {
            pLog->dwFlags |= LOG_BADMEM;
            pLog->ApcInited = FALSE;
        }
        UnLockLog(pLog, kIrql);

        IoReleaseCancelSpinLock(Irp->CancelIrql);

        //
        // Now get the resource to prevent others from
        // tampering. Assume this will never nest.
        //
        KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite(&pLog->Resource, TRUE);

        //
        // Make sure it's the same IRP. This could have changed
        // while we were not interlocked. If the Irp changed, keep
        // hands off.
        //

        if(pLog->Irp == Irp)
        {
            //
            // if a current mapping, unmap it
            //

            if(pLog->Mdl)
            {
                MmUnlockPages(pLog->Mdl);
                IoFreeMdl(pLog->Mdl);
                pLog->Mdl = 0;
            }
            pLog->Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(pLog->Irp, IO_NO_INCREMENT);
            DereferenceLog(pLog);
            pLog->Irp = 0;
         
        }
        ExReleaseResourceLite(&pLog->Resource);
        KeLeaveCriticalRegion();

        DereferenceLog(pLog);
    }
    else
    {
        IoReleaseCancelSpinLock(Irp->CancelIrql);
    }
#endif    // DOLOGAPC
}

VOID
AdvanceLog(PPFLOGINTERFACE pLog)
/*++
  Routine Description:
     Called to schedule the APC to move the log mapping.
     If the APC can't be inserted, just forget it.
--*/
{

#if DOLOGAPC
    //
    // can't use the routines in logger.c 'cause the spin
    // lock is in force
    //
    if(pLog->ApcInited
                  &&
       pLog->Irp
                  &&
       !(pLog->dwFlags & (LOG_BADMEM | LOG_OUTMEM | LOG_CANTMAP))
                  &&
       InterlockedExchange(&pLog->lApcInProgress, 1) == 0)
    {
        InterlockedIncrement(&pLog->UseCount);

        if(!KeInsertQueueApc(
                   &pLog->Apc,
                   (PVOID)pLog,
                   NULL,
                   LOG_PRIO_BOOST))
        {
            //
            // failed to insert
            //

            InterlockedDecrement(&pLog->UseCount);
            pLog->lApcInProgress = 0;
        }
    }
#endif
}

KIRQL
LockLog(PPFLOGINTERFACE pLog)
/*++
  Routine Description:
    Acquire the log spin lock. This is called by the match code
    at DPC only
--*/
{
    KIRQL kIrql;

    KeAcquireSpinLock(&pLog->LogLock, &kIrql);

    return(kIrql);
}

VOID
RemoveLogFromInterfaces(PPFLOGINTERFACE pLog)
{
    PLIST_ENTRY pList;
    PFILTER_INTERFACE pf;

    //
    // protect the interface list. The assumption is that no
    // resources, aside from an FCB lock are held.
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&FilterListResourceLock, TRUE);


    for(pList = g_filters.leIfListHead.Flink;
        pList != &g_filters.leIfListHead;
        pList = pList->Flink)
    {
        pf = CONTAINING_RECORD(pList, FILTER_INTERFACE, leIfLink);

        if(pLog == pf->pLog)
        {
            LOCK_STATE LockState;

            AcquireWriteLock(&g_filters.ifListLock,&LockState);
            pf->pLog = NULL;
            ReleaseWriteLock(&g_filters.ifListLock,&LockState);
            DereferenceLog(pLog);
        }
    }
    ExReleaseResourceLite(&FilterListResourceLock);
    KeLeaveCriticalRegion();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\match.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\fltrdrvr\driver.c

Abstract:


Revision History:



--*/

#include "globals.h"
#include <align.h>
#include <ipinfo.h>


#ifdef DRIVER_PERF

#define RecordTimeIn() {                          \
        InterlockedIncrement(&g_dwNumPackets);    \
        KeQuerySystemTime(&liTimeIn);             \
   }

#define RecordTimeOut(){                                                         \
        KeQuerySystemTime(&liTimeOut);                                           \
        ExInterlockedAddLargeInteger(&g_liTotalTime,                             \
                                     liTimeOut.QuadPart - liTimeIn.QuadPart),    \
                                     &g_slPerfLock);                             \
   }
#define IncrementFragments() InterlockedIncrement(&g_dwFragments)
#define IncrementCache1() InterlockedIncrement(&g_dwCache1)
#define IncrementCache2() InterlockedIncrement(&g_dwCache2)
#define IncrementWalk1() InterlockedIncrement(&g_dwWalk1)
#define IncrementWalk2() InterlockedIncrement(&g_dwWalk2)
#define IncrementForward() InterlockedIncrement(&g_dwForw)
#define IncrementWalkCache() InterlockedIncrement(&g_dwWalkCache)
#else
#define RecordTimeIn()
#define RecordTimeOut()
#define IncrementFragments()
#define IncrementCache1()
#define IncrementCache2()
#define IncrementWalk1()
#define IncrementWalk2()
#define IncrementForward()
#define IncrementWalkCache()
#endif // DRIVER_PERF

#define PROT_IPSECESP 50
#define PROT_IPSECAH 51

//
// The IPSEC AH payload
//
typedef struct  _AH {
    UCHAR   ah_next;
    UCHAR   ah_len;
    USHORT  ah_reserved;
    ULONG   ah_spi;
    ULONG   ah_replay;
} AH, *PAH;

#define SIZE_OF_IPSECAH sizeof(AH)


#if LOOKUPROUTE
void
LookupRoute (IPRouteLookupData *pRLData,  IPRouteEntry *pIPRTE);
#endif

#if DOFRAGCHECKING
DWORD
GetFragIndex(DWORD dwProt);
#endif

VOID __fastcall
FragCacheUpdate(
    ULARGE_INTEGER  uliSrcDstAddr,
    PVOID           pInContext,
    PVOID           pOutContext,
    DWORD           dwId,
    FORWARD_ACTION  faAction
    );

BOOL
CheckAddress(IPAddr ipAddr, DWORD dwInterfaceId);

VOID
SendTCPReset(UNALIGNED IPHeader *  pIpHeader,
             BYTE *                pbRestOfPacket,
             ULONG                 uiPacketLength);
VOID
SendUDPUnreachable(UNALIGNED IPHeader *  pIpHeader,
                   BYTE *                pbRestOfPacket,
                   ULONG                 uiPacketLength);
BOOL
CheckRedirectAddress(UNALIGNED IPHeader *IPHead, DWORD dwInterface);

VOID
LogFiltHit(
        FORWARD_ACTION Action,
        BOOL fIn,
        DWORD    dwFilterRule,
        PFILTER_INTERFACE pIf,
        UNALIGNED IPHeader *pIpHeader,
        BYTE *pbRestOfPacket,
        UINT  uiPacketLength);

VOID
FiltHit(PFILTER pf,
        PFILTER_INTERFACE pIf,
        FORWARD_ACTION Action,
        UNALIGNED IPHeader *pIpHeader,
        BYTE *pbRestOfPacket,
        UINT  uiPacketLength,
        BOOL fIn);

VOID
RegisterFragAttack(
            PFILTER_INTERFACE pIf,
            UNALIGNED IPHeader *pIpHeader,
            BYTE *pbRestOfPacket,
            UINT              uiSize);

VOID
RegisterFullDeny(
            PFILTER_INTERFACE pIf,
            UNALIGNED IPHeader *pIpHeader,
            BYTE *pbRestOfPacket,
            UINT              uiSize);


VOID
RegisterUnusedICMP(PFILTER_INTERFACE pIf,
                   UNALIGNED IPHeader *pIpHeader,
                   BYTE *pbRestOfPacket,
                   UINT              uiSize);

VOID
RegisterSpoof(     PFILTER_INTERFACE pIf,
                   UNALIGNED IPHeader *pIpHeader,
                   BYTE *pbRestOfPacket,
                   UINT              uiSize);

VOID
LogData(
    PFETYPE  pfeType,
    PFILTER_INTERFACE pIf,
    DWORD   dwFilterRule,
    UNALIGNED IPHeader *pIpHeader,
    BYTE *pbRestOfPacket,
    UINT  uiPacketLength);

VOID
AdvanceLog(PPFLOGINTERFACE pLog);

PFILTER
LookForFilter(PFILTER_INTERFACE pIf,
              ULARGE_INTEGER UNALIGNED * puliSrcDstAddr,
              PULARGE_INTEGER puliProtoSrcDstPort,
              DWORD dwSum,
              DWORD dwFlags);

PFILTER
CheckFragAllowed(
              PFILTER_INTERFACE pIf,
              UNALIGNED IPHeader *pIp);

BOOL
CheckForTcpCtl(
              PFILTER_INTERFACE pIf,
              DWORD Prot,
              UNALIGNED IPHeader *pIp,
              PBYTE     pbRest,
              DWORD     dwSize);

//
// definitions
//

#define GLOBS_UNREACH    0x1
#define GLOBS_SPOOF      0x2
#define GLOBS_SYN        0x4
#define GLOBS_REDIRECT   0x8
#define GLOBS_SYNDrop    0x10
#define GLOBS_TCPGood    0x20

#define OutCacheMatch(uliAddr,uliPort,outCtxt,pOutCache)                    \
                       ((uliAddr).QuadPart is pOutCache->uliSrcDstAddr.QuadPart) and      \
                       ((uliPort).QuadPart is pOutCache->uliProtoSrcDstPort.QuadPart) and \
                       (pOutCache->pOutContext is (outCtxt))

#define InCacheMatch(uliAddr,uliPort,inCtxt,pInCache)                       \
        ((uliAddr).QuadPart is pInCache->uliSrcDstAddr.QuadPart) and       \
        ((uliPort).QuadPart is pInCache->uliProtoSrcDstPort.QuadPart) and  \
        (pInCache->pInContext is (inCtxt))

#define GenericFilterMatch(uliAddr,uliPort, pFilter)                          \
        ((uliAddr).QuadPart is pFilter->uliSrcDstAddr.QuadPart) and   \
        ((uliPort).QuadPart is pFilter->uliProtoSrcDstPort.QuadPart)

#define InFilterMatch(uliAddr,uliPort, pInFilter)                          \
        ((uliAddr).QuadPart is pInFilter->uliSrcDstAddr.QuadPart) and   \
        ((uliPort).QuadPart is pInFilter->uliProtoSrcDstPort.QuadPart)

#define OutFilterMatch(uliAddr,uliPort,pOutFilter)                          \
        ((uliAddr).QuadPart is pOutFilter->uliSrcDstAddr.QuadPart) and  \
        ((uliPort).QuadPart is pOutFilter->uliProtoSrcDstPort.QuadPart)

//
// There is a race condition in that when the cache match is done, the code first
// copies out the value of the pointer to the entry and then InterlockedIncrements
// the dwCount variable. The race condition can occur because between the time the
// matching code keeps a ref. to the entry and increments the variable some other
// thread could remove the entry from that cache (i.e update that entry) and put
// it at the tail of the free list. Then if the entry ALSO comes to the head
// of the list BEFORE the other thread has the chance to increment the var, then
// the following Update macros will see a dwCount of 0 and begin to use this block
// But the other thread will assume valid values in the cache entry
// and use those values.  The chances of this hapenning are so so so low that I am
// going ahead with this model
//

#define OutCacheUpdate(uliAddr,uliPort,outCtxt,eaAct,dwId,pdwHit)  {     \
    PFILTER_OUTCACHE __pTemp;                                            \
    PLIST_ENTRY __pNode;                                                 \
    TRACE(CACHE,("IPFLTDRV: Attempting out cache update\n"));            \
    __pNode = ExInterlockedRemoveHeadList(&g_freeOutFilters,&g_lOutFilterLock); \
    __pTemp = CONTAINING_RECORD(__pNode,FILTER_OUTCACHE,leFreeLink);     \
    if(__pTemp isnot NULL)                                               \
    {                                                                    \
        if(__pTemp->lCount <= 0)                                         \
        {                                                                \
            __pTemp->uliSrcDstAddr = (uliAddr);                          \
            __pTemp->uliProtoSrcDstPort = (uliPort);                     \
            __pTemp->pOutContext = (outCtxt);                            \
            __pTemp->eaOutAction = (eaAct);                              \
            __pTemp->pOutFilter = (pdwHit);                              \
            __pTemp = (PFILTER_OUTCACHE)InterlockedExchangePointer(&g_filters.ppOutCache[(dwId)], \
                                                            __pTemp);    \
            ExInterlockedInsertTailList(&g_freeOutFilters,               \
                                        &(__pTemp->leFreeLink),&g_lOutFilterLock);       \
            TRACE(CACHE,("IPFLTDRV: Managed out cache update - ignore next msg\n"));     \
        }                                                                \
        else                                                             \
        {                                                                \
            ExInterlockedInsertTailList(&g_freeOutFilters,               \
                                        &(__pTemp->leFreeLink),          \
                                        &g_lOutFilterLock);              \
        }                                                                \
    }                                                                    \
    TRACE(CACHE,("IPFLTDRV: Couldnt get into out cache for update\n"));  \
}

#define InCacheUpdate(uliAddr,uliPort,inCtxt,eaAct,dwId,pfHit)  {        \
    PFILTER_INCACHE __pTemp;                                             \
    PLIST_ENTRY __pNode;                                                 \
    TRACE(CACHE,("IPFLTDRV: Attempting in cache update\n"));            \
    __pNode = ExInterlockedRemoveHeadList(&g_freeInFilters,&g_lInFilterLock);  \
    __pTemp = CONTAINING_RECORD(__pNode,FILTER_INCACHE,leFreeLink);      \
    if(__pTemp isnot NULL)                                               \
    {                                                                    \
        if(__pTemp->lCount <= 0)                                         \
        {                                                                \
            __pTemp->uliSrcDstAddr = (uliAddr);                          \
            __pTemp->uliProtoSrcDstPort = (uliPort);                     \
            __pTemp->pInContext = (inCtxt);                              \
            __pTemp->eaInAction = (eaAct);                               \
            __pTemp->pOutContext = NULL;                                 \
            __pTemp->pInFilter = (pfHit);                                \
            __pTemp->pOutFilter = NULL;                                  \
          __pTemp = (PFILTER_INCACHE)InterlockedExchangePointer(&g_filters.ppInCache[(dwId)], \
                                                           __pTemp); \
            ExInterlockedInsertTailList(&g_freeInFilters,                \
                                        &(__pTemp->leFreeLink),&g_lInFilterLock);        \
            TRACE(CACHE,("IPFLTDRV: Managed out cache update - ignore next msg\n"));    \
        }                                                                \
        else                                                             \
        {                                                                \
            ExInterlockedInsertTailList(&g_freeInFilters,                \
                                        &(__pTemp->leFreeLink),          \
                                        &g_lInFilterLock);               \
        }                                                                \
    }                                                                    \
    TRACE(CACHE,("IPFLTDRV: Couldnt get into in cache for update\n"));  \
}

#define InCacheFullUpdate(uliAddr,uliPort,inCtxt,eaInAct,outCtxt,eaOutAct,dwId,pdwHit1,pdwHit2){ \
    PFILTER_INCACHE __pTemp;                                              \
    PLIST_ENTRY __pNode;                                                  \
    TRACE(CACHE,("IPFLTDRV: Attempting in cache full update\n"));        \
    __pNode = ExInterlockedRemoveHeadList(&g_freeInFilters,&g_lInFilterLock); \
    __pTemp = CONTAINING_RECORD(__pNode,FILTER_INCACHE,leFreeLink);       \
    if(__pTemp isnot NULL)                                                \
    {                                                                     \
        if(__pTemp->lCount <= 0)                                          \
        {                                                                 \
            __pTemp->uliSrcDstAddr = (uliAddr);                           \
            __pTemp->uliProtoSrcDstPort = (uliPort);                      \
            __pTemp->pInContext = (inCtxt);                               \
            __pTemp->eaInAction = (eaInAct);                              \
            __pTemp->pOutContext = (outCtxt);                             \
            __pTemp->eaOutAction = (eaOutAct);                            \
            __pTemp->pInFilter = (pdwHit1);                               \
            __pTemp->pOutFilter = (pdwHit2);                              \
            __pTemp->lOutEpoch = outCtxt->lEpoch;                         \
            __pTemp = (PFILTER_INCACHE)InterlockedExchangePointer(&g_filters.ppInCache[(dwId)], \
                                                           __pTemp); \
            ExInterlockedInsertTailList(&g_freeInFilters,                 \
                                        &(__pTemp->leFreeLink),&g_lInFilterLock);        \
            TRACE(CACHE,("IPFLTDRV: Managed in cache full update - ignore next msg\n")); \
        }                                                                 \
        else                                                              \
        {                                                                 \
            ExInterlockedInsertTailList(&g_freeInFilters,                 \
                                        &(__pTemp->leFreeLink),           \
                                        &g_lInFilterLock);                \
        }                                                                 \
    }                                                                     \
    TRACE(CACHE,("IPFLTDRV: Couldnt get into in cache for full update\n")); \
}

#define InCacheOutUpdate(outCtxt,eaAct,dwId,pInCache,pdwHit) {                           \
    PFILTER_INCACHE __pTemp;                                                             \
    (pInCache)->pOutContext = outCtxt;                                                   \
    (pInCache)->pOutFilter = (pdwHit);                                                    \
    (pInCache)->eaOutAction = (eaAct);                                                    \
    (pInCache)->lOutEpoch = outCtxt->lEpoch;                                                 \
    __pTemp = (PFILTER_INCACHE)InterlockedExchangePointer(&g_filters.ppInCache[(dwId)], \
                                                   (pInCache));                   \
    if(__pTemp isnot (pInCache))                                                         \
    {                                                                                    \
        ExInterlockedInsertTailList(&g_freeInFilters,                                    \
                                    &(__pTemp->leFreeLink),&g_lInFilterLock);            \
    }                                                                                    \
}                                                                                        \

#define LockCache(pCache){                       \
    InterlockedIncrement(&((pCache)->lCount));   \
}

#define ReleaseCache(pCache){                    \
    InterlockedDecrement(&((pCache)->lCount));   \
}

#define REGISTER register

#define PRINT_IPADDR(x) \
    ((x)&0x000000FF),(((x)&0x0000FF00)>>8),(((x)&0x00FF0000)>>16),(((x)&0xFF000000)>>24)
    


#define \
FilterDriverLookupCachedInterface( \
    _Index, \
    _Link, \
    _pIf \
    ) \
    ( (((_pIf) = InterlockedProbeCache(g_filters.pInterfaceCache, (_Index), (_Link))) && \
       (_pIf)->dwIpIndex == (_Index) && (_pIf)->dwLinkIpAddress == (_Link)) \
        ? (_pIf) \
        : (((_pIf) = FilterDriverLookupInterface((_Index), (_Link))) \
            ? (InterlockedUpdateCache(g_filters.pInterfaceCache, (_Index),(_Link),(_pIf)), \
                (_pIf)) \
            : NULL) )



//FORWARD_ACTION __fastcall
FORWARD_ACTION
MatchFilter(
            UNALIGNED IPHeader *pIpHeader,
            BYTE               *pbRestOfPacket,
            UINT               uiPacketLength,
            UINT               RecvInterfaceIndex,
            UINT               SendInterfaceIndex,
            IPAddr             RecvLinkNextHop,
            IPAddr             SendLinkNextHop
            )
/*++


--*/
{
    FORWARD_ACTION  faAction;
    
    
    faAction = MatchFilterp(pIpHeader,
                            pbRestOfPacket,
                            uiPacketLength,
                            RecvInterfaceIndex,
                            SendInterfaceIndex,
                            RecvLinkNextHop,
                            SendLinkNextHop,
                            NULL,
                            NULL,
                            FALSE,
                            FALSE);

    if (IP_ADDR_EQUAL(RecvLinkNextHop, MAXULONG))
    	return faAction;
    	
    TRACE(ACTION,(
             "FILTER: %d.%d.%d.%d->%d.%d.%d.%d %d (%x) %x -> %x: action %s\n",
             PRINT_IPADDR(pIpHeader->iph_src),
             PRINT_IPADDR(pIpHeader->iph_dest),
             pIpHeader->iph_protocol,
             *((DWORD UNALIGNED *) pbRestOfPacket),
             RecvInterfaceIndex,
             SendInterfaceIndex,
             (faAction == FORWARD)?"FORWARD":"DROP"
             ));

    return faAction;
}



FORWARD_ACTION
MatchFilterp(
            UNALIGNED IPHeader *pIpHeader,
            BYTE               *pbRestOfPacket,
            UINT               uiPacketLength,
            UINT               RecvInterfaceIndex,
            UINT               SendInterfaceIndex,
            IPAddr             RecvLinkNextHop,
            IPAddr             SendLinkNextHop,
            INTERFACE_CONTEXT  RecvInterfaceContext,
            INTERFACE_CONTEXT  SendInterfaceContext,
            BOOL               fInnerCall,
            BOOL               fIoctlCall
            )
{
    REGISTER PFILTER_INTERFACE          pInInterface, pOutInterface;
    ULARGE_INTEGER UNALIGNED *          puliSrcDstAddr;
    ULARGE_INTEGER                      uliProtoSrcDstPort;
    REGISTER FORWARD_ACTION             eaAction;
    REGISTER ULARGE_INTEGER             uliAddr;
    REGISTER ULARGE_INTEGER             uliPort;
    LOCK_STATE                          LockState, LockStateExt;
    DWORD                               dwIndex, dwSum;
    REGISTER DWORD                      i;
    UNALIGNED WORD                      *pwPort;
    REGISTER PFILTER_INCACHE            pInCache;
    REGISTER PFILTER_OUTCACHE           pOutCache;
    PFILTER                             pf, pf1;
    DWORD                               dwGlobals = 0;
    UNALIGNED IPHeader                  *RedirectHeader;
    PBYTE                               pbRest;
    UINT                                uiLength;
    BOOLEAN                             bFirstFrag = FALSE;
    DWORD                               dwId, dwFragIndex;
    KIRQL                               kiCurrIrql;
    PLIST_ENTRY                         pleNode;
    PF_FORWARD_ACTION                   pfAction = PF_PASS;



#ifdef DRIVER_PERF
    LARGE_INTEGER liTimeIn, liTimeOut;
#endif

    //
    // If the packet is part of a fragment, accept it
    //   3     13 bits
    // |---|-------------|     ---> Network Byte Order
    //   Fl  Frag Offset
    // Need to and with 0x1fff (in nbo) which would be 0xff1f in little endian
    //

    
#ifdef BASE_PERF
    return FORWARD;
#else // BASE_PERF


    RecordTimeIn();

    if (!fIoctlCall) 
    {
        //
        // Call the extension driver if there is any. Also, pass the 
        // extension driver's interface contexts and the interface indexes.
        //

        AcquireReadLock(&g_Extension.ExtLock, &LockStateExt);
        if (g_Extension.ExtPointer) 
        {
            //
            // We will be accessing the interface so obtain a read lock on them.
            //
 
            pfAction =  g_Extension.ExtPointer(
                                    (unsigned char *)pIpHeader,
                                    pbRestOfPacket,
                                    uiPacketLength,
                                    RecvInterfaceIndex,
                                    SendInterfaceIndex,
                                    RecvLinkNextHop,
                                    SendLinkNextHop
                                    );

            //
            // If the action returned is FORWARD or DROP, then forward the action as it is.
            // Any other action must be taken by the filter driver only.
            //

            if (pfAction == PF_FORWARD) 
            {
                ReleaseReadLock(&g_Extension.ExtLock, &LockStateExt);
                return(FORWARD);
            }
            else if (pfAction == PF_DROP) 
            {
                ReleaseReadLock(&g_Extension.ExtLock, &LockStateExt);
                return(DROP);
            }

        }
        ReleaseReadLock(&g_Extension.ExtLock, &LockStateExt);

        //
        // Quick check to see if there are bound interfaces.
        // We make this check only for callouts coming directly from IP.
        //

        if (!g_ulBoundInterfaceCount) 
        {
            return(FORWARD);
        }

        //
        // Lookup the the filter driver interfaces.
        //

        AcquireReadLock(&g_filters.ifListLock, &LockState);
        if (RecvInterfaceIndex != INVALID_IF_INDEX) 
        {
            FilterDriverLookupCachedInterface(
                                         RecvInterfaceIndex,
                                         RecvLinkNextHop,
                                         pInInterface
                                         );
        }
        else 
        {
            pInInterface = NULL;
        }

        if (SendInterfaceIndex != INVALID_IF_INDEX) 
        {
            FilterDriverLookupCachedInterface(
                                         SendInterfaceIndex,
                                         SendLinkNextHop,
                                         pOutInterface
                                         );
        }
        else 
        {
            pOutInterface = NULL;
        }
    }
    else 
    {
        AcquireReadLock(&g_filters.ifListLock, &LockState);
        pInInterface  = (PFILTER_INTERFACE)RecvInterfaceContext;
        pOutInterface = (PFILTER_INTERFACE)SendInterfaceContext;
    }
    
    if (IP_ADDR_EQUAL(RecvLinkNextHop, MAXULONG))
    {
        //The packet is invalid. Make sure it is valid enough to make
        //right filtering decisions. Length of IP header >= 20

        if ( 20 > ((DWORD)(pIpHeader->iph_verlen & IPHDRLEN) << IPHDRSFT))
        {
            ReleaseReadLock(&g_filters.ifListLock,&LockState);
            return(DROP);
        }
    }
    
    //
    // Normal filter driver processing continues at this point.
    //
    
    if(!pInInterface && !pOutInterface)
    {
        //
        // Quick check for this case, there are filter driver 
        // interfaces just that nothing of our interest.
        //

        ReleaseReadLock(&g_filters.ifListLock,&LockState);
        return (FORWARD);
    }

    if((pIpHeader->iph_offset & 0xff1f) is 0)
    {
        if (pIpHeader->iph_offset & 0x0020) 
        {
            //
            // If it is the first IPSEC fragment forward it, or drop it
            // based on the state of fragment filter. 
            //
 
            if((pIpHeader->iph_protocol is PROT_IPSECAH)  ||
               (pIpHeader->iph_protocol is PROT_IPSECESP))
            {
                if (pInInterface && pInInterface->CountNoFrag.lInUse)
                {
                    RegisterFragAttack(
                        pInInterface,
                        pIpHeader,
                        pbRestOfPacket,
                        uiPacketLength);

                    ReleaseReadLock(&g_filters.ifListLock,&LockState);
                    return(DROP);           
                }
                else 
                {
                    ReleaseReadLock(&g_filters.ifListLock,&LockState);
                    return(FORWARD);
                }
            }

            if (pInInterface && pInInterface->CountFragCache.lInUse)
            {
                TRACE(FRAG,("IPFLTDRV: Packet is the first fragment\n"));
                bFirstFrag = TRUE;
            }
        }
    }
    else 
    {

        WORD wFrag;

        TRACE(FRAG,("IPFLTDRV: Packet is a fragment\n"));
        RecordTimeOut();
        IncrementFragments();

        eaAction = FORWARD;

        do
        {
            if(pInInterface is NULL)
            {
                TRACE(FRAG,("IPFLTDRV: InInterface is NULL on FRAG - forward\n"));
                break;
            }
        
            if (!pInInterface->CountFragCache.lInUse &&
                !pInInterface->CountSynOrFrag.lInUse &&
                !pInInterface->CountNoFrag.lInUse
               )
            {
               //
               // None of the fragment filters are being used.
               // FORWARD
               //

               TRACE(FRAG,("IPFLTDRV: No FRAG filters being used - forward\n"));
               break;
            }

            if (pInInterface->CountSynOrFrag.lInUse &&
                ((pIpHeader->iph_protocol == 6)  ||
                 (pIpHeader->iph_protocol == 17) ||
                 (pIpHeader->iph_protocol == 1)) )
            {
                //
                // allowing only valid-looking frags.
                //
                wFrag = net_short(pIpHeader->iph_offset) & 0x1fff;
            }
            else
            {
                //
                // allowing all of these frags.
                //

                wFrag = (WORD)g_FragThresholdSize;
            }

            //
            // compute extent of this fragment. If it is bigger than
            // 64K, log it and drop it.
            //

            if( (wFrag < (WORD)g_FragThresholdSize)
                        ||
                (((wFrag << 3) + 
                 (((UINT)net_short(pIpHeader->iph_length)) - (((pIpHeader->iph_verlen)&0x0f)<<2)))  
                  > 0xFFFF) )
            {

                eaAction = DROP;
                TRACE(FRAG,("IPFLTDRV: SynOrFrag attck - DROP\n"));
                break;
            }
            
            //
            // The Fragment-Cache filter takes precedence over other
            // fragment filter.
            //

            if ((pInInterface->CountFragCache.lInUse)      &&
                (pIpHeader->iph_protocol != PROT_IPSECAH)  &&
                (pIpHeader->iph_protocol != PROT_IPSECESP))
            {
                //
                // If it is a IPSEC fragment forward it, don't touch it 
                // as IPSec fragment are not kept in the cache.
                //

             
                BOOL bFound = FALSE;
                TRACE(FRAG,("IPFLTDRV: FRAG Offset is 0x%04x\n", pIpHeader->iph_offset));
                
                uliProtoSrcDstPort.LowPart = 
                    MAKELONG(MAKEWORD(pIpHeader->iph_protocol,0x00),0x0000);
             
                dwId = 
                    MAKELONG(
                       LOWORD(uliProtoSrcDstPort.LowPart), pIpHeader->iph_id);
                
                puliSrcDstAddr = 
                    (PULARGE_INTEGER)(&(pIpHeader->iph_src));

                
                //
                // Look up id in frag table and check for a match
                //

                dwFragIndex = dwId % g_dwFragTableSize;

                TRACE(FRAG,(
                    "IPFLTDRV: Checking fragment cache for index %d\n", 
                    dwFragIndex
                    ));

                KeAcquireSpinLock(&g_kslFragLock, &kiCurrIrql);
         
                for(pleNode = g_pleFragTable[dwFragIndex].Flink;
                    pleNode isnot &(g_pleFragTable[dwFragIndex]);
                    pleNode = pleNode->Flink)
                {
                    PFRAG_INFO  pfiFragInfo;
                    pfiFragInfo = 
                        CONTAINING_RECORD(pleNode, FRAG_INFO, leCacheLink);

                    if((pfiFragInfo->uliSrcDstAddr.QuadPart == 
                            puliSrcDstAddr->QuadPart)                 &&
                       (pfiFragInfo->pvInContext == pInInterface)     &&
                       (pfiFragInfo->pvOutContext == pOutInterface)   &&
                       (pfiFragInfo->dwId == dwId))
                    {
                        TRACE(FRAG,("IPFLTDRV: FRAG: Found entry %x\n", pfiFragInfo));
                        
                        eaAction = pfiFragInfo->faAction;
                        KeQueryTickCount((PLARGE_INTEGER)&(pfiFragInfo->llLastAccess));
                        bFound = TRUE;
                        break;
                    }
                }
                 
                KeReleaseSpinLock(&g_kslFragLock, kiCurrIrql);
                
                //
                // This fragment was found in the fragment cache.
                //

                if (bFound) 
                {
                   break;
                }
            }

            if (pInInterface->CountNoFrag.lInUse)
            {
               //
               // Fragment filter is in use
               //

               eaAction = DROP;
               break;
            }

#if DOFRAGCHECKING
            if(eaAction == FORWARD)
            {    
                pf = CheckFragAllowed(pInInterface,
                                      pIpHeader);
               
                eaAction = pInInterface->eaInAction;
                if(pf)
                {
                    eaAction ^= 1;
                }

                FiltHit(pf,
                        pInInterface,
                        eaAction,
                        pIpHeader,
                        pbRestOfPacket,
                        uiPacketLength,
                        TRUE);
            }
#endif           // if DOFRAGCHECKING
        } while(FALSE);

        if (eaAction == DROP) 
        {    
            //
            // bogus.
            //
            RegisterFragAttack(
                pInInterface,
                pIpHeader,
                pbRestOfPacket,
                uiPacketLength);
        }

        ReleaseReadLock(&g_filters.ifListLock,&LockState);

        TRACE(FRAG,(
            "IPFLTDRV: FRAG: Returning %s for frag\n", 
            (eaAction is DROP)?"DROP":"FORWARD"
            ));

        return eaAction;
    }

#if 0
    //
    // Extract all the information out of the header
    //

    if((pIpHeader->iph_protocol == PROT_IPSECAH)
                   &&
       !fInnerCall
                   &&
       (uiPacketLength > SIZE_OF_IPSECAH))
    {
        //
        // if this is the call from the stack, call again
        // to check on the IPSEC header. If that succeeds, then
        // check on the upper layer protocol fields.
        //
        if(MatchFilterp(
            pIpHeader,
            pbRestOfPacket,
            uiPacketLength,
            RecvIntefaceContext,
            SendInterfaceContext,
            TRUE) == DROP)
        {
             return(DROP);
        }
        pbRest = pbRestOfPacket + SIZE_OF_IPSECAH;
        uiLength = uiPacketLength - SIZE_OF_IPSECAH;
        //
        // get the next protocol from the IPSEC header
        //
         uliProtoSrcDstPort.LowPart =
          MAKELONG(MAKEWORD(((UNALIGNED PAH)pbRest)->ah_next,0x00),0x0000);
    }
    else
    {
        pbRest = pbRestOfPacket;
        uiLength = uiPacketLength;
        uliProtoSrcDstPort.LowPart =
          MAKELONG(MAKEWORD(pIpHeader->iph_protocol,0x00),0x0000);
    }
#endif

    pbRest = pbRestOfPacket;
    uiLength = uiPacketLength;
    uliProtoSrcDstPort.LowPart =
      MAKELONG(MAKEWORD(pIpHeader->iph_protocol,0x00),0x0000);

    pwPort = (UNALIGNED WORD *)pbRest;
    puliSrcDstAddr = (PULARGE_INTEGER)(&(pIpHeader->iph_src));

    dwId = 
         MAKELONG(LOWORD(uliProtoSrcDstPort.LowPart), pIpHeader->iph_id);
    //
    // Ports make sense only for TCP and UDP
    //

    //
    // TCP/UDP header
    // 0                 15 16               31
    // |----|----|----|----|----|----|----|----|
    // |    Source Port    |    Dst Port       |
    //

    switch(uliProtoSrcDstPort.LowPart)
    {
        case 1: //ICMP
        {
            BYTE bType, bCode;
            //
            // The type and code go into high part. Make sure there is enough
            // data.
            //
            if(uiLength >= 2)
            {
                uliProtoSrcDstPort.HighPart = MAKELONG(pwPort[0],0x0000);

                //
                // two checks: unassigned port check and incoming
                // redirect address check may be requested. The first
                // is done only if this is a frame sent from this
                // machine. the second is done only if this is
                // a frame sent by this machine.
                // Note, spoof checking, if needed, is done in the
                // common path.


                switch(pwPort[0] & 0xff)
                {
                    UNALIGNED IPHeader * IpHead;
                    PICMPHeader pIcmp;

                    case ICMP_DEST_UNREACH:
                        dwGlobals |= GLOBS_UNREACH;
                        break;

                    case ICMP_REDIRECT:
                        if(uiLength >= (sizeof(ICMPHeader) + 
                                               sizeof(IPHeader) ) )
                        {
                            dwGlobals |= GLOBS_REDIRECT;
                            pIcmp = (PICMPHeader)pbRest;
                            RedirectHeader = (UNALIGNED IPHeader *)(pIcmp + 1);
                        }
                        break;
                }
            }
            else
            {
                //
                // if mal-formed, use invalid codes
                //
                uliProtoSrcDstPort.HighPart = MAKELONG(0xffff, 0x0000);
            }

            break;
        }
        case 6:  //TCP
        {
            DWORD  dwFlags1;
            UNALIGNED TCPHeader  *pTcpHdr =
                           (UNALIGNED TCPHeader *)pbRest;
            
            //
            // if a valid TCP packet, compute whether it is a SYN or
            // an established connection. If the frame is invalid, assume
            // it is a SYN.
            //
            if(uiLength >= sizeof(TCPHeader))
            {
                dwGlobals |= GLOBS_TCPGood;

                //
                // Now all the funky stuff with the flags.
                //

                if(pTcpHdr->tcp_flags & ( TCP_FLAG_ACK | TCP_FLAG_RST ) )
                {
                    dwFlags1 = ESTAB_FLAGS;
                }
                else
                {
                    dwFlags1 = 0;
                }

                //
                // Set the LP1 byte of theProtoSrcDstPort
                //

                uliProtoSrcDstPort.LowPart |=
                    MAKELONG(MAKEWORD(0x00,LOWORD(LOBYTE(dwFlags1))),0x0000);
            }
        }

            //
            // and fall through to the common TCP/UDP code.
            //
        case 17: //UDP
        {
            if(uiLength >= 4)
            {
                uliProtoSrcDstPort.HighPart =  MAKELONG(pwPort[0],pwPort[1]);
            }
            else
            {
                //
                // malformed. Use invalid port numbers
                //
                uliProtoSrcDstPort.HighPart = 0;

            }
            break;
        }
        default:
        {
            uliProtoSrcDstPort.HighPart = 0x00000000;
            break;
        }
    }


    TRACE(CACHE,(
        "IPFLTDRV: Addr Large Int: High= %0#8x Low= %0#8x\n",
        puliSrcDstAddr->HighPart,
        puliSrcDstAddr->LowPart
        ));

    TRACE(CACHE,(
        "IPFLTDRV: Packet value is Src: %0#8x Dst: %0#8x\n",
        pIpHeader->iph_src,
        pIpHeader->iph_dest
        ));

    TRACE(CACHE,(
        "IPFLTDRV: Proto/Port:High= %0#8x Low= %0#8x\n",
        uliProtoSrcDstPort.HighPart,
        uliProtoSrcDstPort.LowPart
        ));

    TRACE(CACHE,("IPFLTDRV: Iph is %x\n",pIpHeader));
    TRACE(CACHE,("IPFLTDRV: Addr of src is %x\n",&(pIpHeader->iph_src)));
    TRACE(CACHE,("IPFLTDRV: Ptr to LI is %x\n",puliSrcDstAddr));
    TRACE(CACHE,(
        "IPFLTDRV: Interfaces - IN: %x OUT: %x\n",
        pInInterface,
        pOutInterface
        ));


    //
    // Sum up the fields and get the cache index. We make sure the sum
    // is assymetric, i.e. a packet from A->B goes to different bucket
    // than one from B->A
    //

    dwSum   =    pIpHeader->iph_src             +
                 pIpHeader->iph_dest            +
                 pIpHeader->iph_dest            +
                 PROTOCOLPART(uliProtoSrcDstPort.LowPart)     +
                 uliProtoSrcDstPort.HighPart;


    TRACE(CACHE,("IPFLTDRV: Sum of field is %0#8x ",dwSum));

    dwIndex = dwSum % g_dwCacheSize;

    TRACE(CACHE,("IPFLTDRV: Cache Index is %d \n",dwIndex));

    //
    // If the inInterface is NULL means we originated the Packet so we only apply the
    // out filter set to it
    //

    if(pInInterface is NULL)
    {
        //
        // Just an out interface to consider
        //

        if(pOutInterface->CountFullDeny.lInUse)
        {
            //
            // full deny is in force. Just drop it
            //

            RegisterFullDeny(
                pOutInterface,
                pIpHeader,
                pbRestOfPacket,
                uiPacketLength);

            ReleaseReadLock(&g_filters.ifListLock,&LockState);
            return DROP;
        }

        //
        // sending from this machine. Check for reporting an UNREACH
        // condition
        //
#if 0                    // don't do this
        if(dwGlobals & GLOBS_UNREACH)
        {
            //
            // it is an ICMP unreachable. See if this interface
            // is interested in these.
            //
            if(pOutInterface->CountUnused.lInUse)
            {
                RegisterUnusedICMP(pOutInterface,
                                   pIpHeader,
                                   pbRestOfPacket,
                                   uiPacketLength);
            }
        }
#endif

        pOutCache = g_filters.ppOutCache[dwIndex];

        TRACE(CACHE,("IPFLTDRV: In Interface is NULL\n"));

        //
        // Try for a quick cache probe
        //

        LockCache(pOutCache);

        if(OutCacheMatch(*puliSrcDstAddr,uliProtoSrcDstPort,pOutInterface,pOutCache))
        {
            TRACE(CACHE,("IPFLTDRV: OutCache Match\n"));
            eaAction = pOutCache->eaOutAction;
            ReleaseCache(pOutCache);

            FiltHit(pOutCache->pOutFilter,
                    pOutCache->pOutContext,
                    eaAction,
                    pIpHeader,
                    pbRestOfPacket,
                    uiPacketLength,
                    FALSE);
//            InterlockedIncrement(pOutCache->pdwOutHitCounter);

            ReleaseReadLock(&g_filters.ifListLock,&LockState);
            TRACE(ACTION,(
                "IPFLTDRV: Packet is being %s\n",
                (eaAction is DROP)?"DROPPED":"FORWARDED"
                ));
            RecordTimeOut();
            IncrementCache1();
            return eaAction;
        }

        ReleaseCache(pOutCache);

        TRACE(CACHE,("IPFLTDRV: Didnt match cache entry\n"));

        TRACE(CACHE,("IPFLTDRV: Walking out filter list\n"));

        pf = LookForFilter(pOutInterface,
                           puliSrcDstAddr,
                           &uliProtoSrcDstPort,
                           dwSum,
                           0);
        if(pf)
        {
            //
            // Update the out cache
            //


            eaAction = pOutInterface->eaOutAction ^ 0x00000001;

            if((eaAction == DROP)
                     &&
               pOutInterface->CountCtl.lInUse)
            {
                //
                // it's a drop and this interface is allowing all
                // TCP control frames. See if this is a TCP control
                // frame.

                if(CheckForTcpCtl(
                                  pOutInterface,
                                  PROTOCOLPART(uliProtoSrcDstPort.LowPart),
                                  pIpHeader,
                                  pbRestOfPacket,
                                  uiPacketLength))
                {
                    pf = 0;
                    eaAction = FORWARD;
                }
            }


            if(pf)
            {
                OutCacheUpdate(*puliSrcDstAddr,
                               uliProtoSrcDstPort,
                               pOutInterface,
                               eaAction,
                               dwIndex,
                               pf);

                FiltHit(pf,
                        pOutInterface,
                        eaAction,
                        pIpHeader,
                        pbRestOfPacket,
                        uiPacketLength,
                        FALSE);
            }

            ReleaseReadLock(&g_filters.ifListLock,&LockState);
            TRACE(ACTION,(
                "IPFLTDRV: Packet is being %s\n",
                (eaAction is DROP)?"DROPPED":"FORWARDED"
                ));
            RecordTimeOut();
            IncrementWalk1();
            return eaAction;
        }

        TRACE(CACHE,("IPFLTDRV: Didnt match any out filters\n"));

        eaAction = pOutInterface->eaOutAction;

        if((eaAction == DROP)
                 &&
           pOutInterface->CountCtl.lInUse)
        {
            if(CheckForTcpCtl(pOutInterface,
                              PROTOCOLPART(uliProtoSrcDstPort.LowPart),
                              pIpHeader,
                              pbRestOfPacket,
                              uiPacketLength))
            {
                eaAction = FORWARD;
                ReleaseReadLock(&g_filters.ifListLock,&LockState);
                TRACE(ACTION,("IPFLTDRV: Packet is being FORWARDED\n"));
                RecordTimeOut();
                IncrementWalk1();
                return eaAction;
            }
        }

        OutCacheUpdate(*puliSrcDstAddr,
                       uliProtoSrcDstPort,
                       pOutInterface,
                       eaAction,
                       dwIndex,
                       NULL);

        ReleaseReadLock(&g_filters.ifListLock,&LockState);
        TRACE(ACTION,(
            "IPFLTDRV: Packet is being %s\n",
            (eaAction is DROP)?"DROPPED":"FORWARDED"
            ));
        RecordTimeOut();
        IncrementWalk1();
//        InterlockedIncrement(&g_dwNumHitsDefaultOut);

        return eaAction;

    }
    else
    {
        PFILTER pfHit;

        if(pInInterface->CountFullDeny.lInUse)
        {
            RegisterFullDeny(
                pInInterface,
                pIpHeader,
                pbRestOfPacket,
                uiPacketLength);
            ReleaseReadLock(&g_filters.ifListLock,&LockState);
            eaAction = DROP;
            if (bFirstFrag)
            {
                FragCacheUpdate(*puliSrcDstAddr,
                                pInInterface,
                                pOutInterface,
                                dwId,
                                eaAction);
            }
            
            return(eaAction);
        }

        pInCache = g_filters.ppInCache[dwIndex];

        //
        // In Interface isnot NULL.
        //
        LockCache(pInCache);

        if(InCacheMatch(*puliSrcDstAddr,uliProtoSrcDstPort,pInInterface,pInCache))
        {

            //
            // We have a cache hit
            //

            eaAction = pInCache->eaInAction;

            //
            // if dropping a frame meant for this machine,
            // see if the TCP CTL override applies
            //
            if((eaAction == DROP)
                     &&
               !pOutInterface
                     &&
               pInInterface->CountCtl.lInUse)
            {
                if(CheckForTcpCtl(pInInterface,
                                  PROTOCOLPART(uliProtoSrcDstPort.LowPart),
                                  pIpHeader,
                                  pbRestOfPacket,
                                  uiPacketLength))
                {
                    eaAction = FORWARD;
                }
            }

            //
            // if not DROP check for spoofing.
            //

            if(eaAction == FORWARD)
            {
                if(pInInterface->dwIpIndex != UNKNOWN_IP_INDEX)
                {
                    if(pInInterface->CountSpoof.lInUse)
                    {
                         IPAddr SrcAddr = puliSrcDstAddr->LowPart;

                         //
                         // we need to check these addresses
                         //
     
                         if(!CheckAddress(SrcAddr, pInInterface->dwIpIndex))
                         {
                             eaAction = DROP;
                         }
                    }

                    if(pInInterface->CountStrongHost.lInUse)
                    {
                         IPAddr DstAddr = puliSrcDstAddr->HighPart;

                         if(!MatchLocalLook(DstAddr, pInInterface->dwIpIndex))
                         {
                             eaAction = DROP;
                         }
                    }
                }

                if(eaAction == DROP)
                {
                    //
                    // Spoofed address. Log it and drop this
                    // 
                    //

                    RegisterSpoof(pInInterface,
                                  pIpHeader,
                                  pbRestOfPacket,
                                  uiPacketLength);

                    ReleaseCache(pInCache);
                    ReleaseReadLock(&g_filters.ifListLock,&LockState);
                    eaAction = DROP;
                    if (bFirstFrag)
                    {
                        FragCacheUpdate(*puliSrcDstAddr,
                                        pInInterface,
                                        pOutInterface,
                                        dwId,
                                        eaAction);
                    }
                    
                    return(eaAction);
                }

                if( (PROTOCOLPART(uliProtoSrcDstPort.LowPart) == 6)
                         &&
                    (dwGlobals & GLOBS_TCPGood)
                         &&
                   ((((PTCPHeader)pbRest)->tcp_flags  &
                      (TCP_FLAG_SYN | TCP_FLAG_ACK)) == TCP_FLAG_SYN) )
                {
                    pInInterface->liSYNCount.QuadPart++;
                }


            }

            TRACE(CACHE,("IPFLTDRV: Matched InCache entry\n"));
            FiltHit(pInCache->pInFilter,
                    pInCache->pInContext,
                    eaAction,
                    pIpHeader,
                    pbRestOfPacket,
                    uiPacketLength,
                    TRUE);
//            InterlockedIncrement(pInCache->pdwInHitCounter);

            if((eaAction == DROP) || (pOutInterface == NULL))
            {
                //
                // In case the packet is destined for this machine or if the action is
                // to drop the packet, we dont need to look at the out interface at all
                //

                TRACE(ACTION,(
                    "IPFLTDRV: Action is %s and context is %x so finished\n",
                    (pInCache->eaInAction is DROP)?"DROP":"FORWARD",
                    pOutInterface
                    ));

                ReleaseCache(pInCache);
                ReleaseReadLock(&g_filters.ifListLock,&LockState);
                if (bFirstFrag)
                {
                    FragCacheUpdate(*puliSrcDstAddr,
                                    pInInterface,
                                    pOutInterface,
                                    dwId,
                                    eaAction);
                }
                TRACE(ACTION,(
                    "IPFLTDRV: Packet is being %s\n",
                    (eaAction is DROP)?"DROPPED":"FORWARDED"
                    ));
                RecordTimeOut();
                IncrementCache1();

                return eaAction;
            }

            //
            // This is the case where we have to apply out filters
            //

            if(pOutInterface->CountFullDeny.lInUse)
            {
                //
                // full deny is in force. Just drop it
                //

                RegisterFullDeny(
                    pOutInterface,
                    pIpHeader,
                    pbRestOfPacket,
                    uiPacketLength);

                ReleaseCache(pInCache);
                ReleaseReadLock(&g_filters.ifListLock,&LockState);
                eaAction = DROP;
                if (bFirstFrag)
                {
                    FragCacheUpdate(*puliSrcDstAddr,
                                    pInInterface,
                                    pOutInterface,
                                    dwId,
                                    eaAction);
                }
                return eaAction;
            }

            TRACE(CACHE,(
                "IPFLTDRV: Have to apply out filters out context is %x\n",
                pOutInterface
                ));

            if((pInCache->pOutContext is pOutInterface)
                            &&
               (pInCache->lOutEpoch == pOutInterface->lEpoch))
            {
                //
                // So we matched the out context. if there is an
                // out filter, check if SYN is restricted.
                //

                eaAction = pInCache->eaOutAction;

                TRACE(CACHE,("IPFLTDRV: Paydirt - out context match in InCache entry\n"));

                ReleaseCache(pInCache);
                FiltHit(pInCache->pOutFilter,
                        pInCache->pOutContext,
                        eaAction,
                        pIpHeader,
                        pbRestOfPacket,
                        uiPacketLength,
                        FALSE);
//                InterlockedIncrement(pInCache->pdwOutHitCounter);

                if (bFirstFrag)
                {
                    FragCacheUpdate(*puliSrcDstAddr,
                                    pInInterface,
                                    pOutInterface,
                                    dwId,
                                    eaAction);
                }

                ReleaseReadLock(&g_filters.ifListLock,&LockState);
                TRACE(ACTION,(
                    "IPFLTDRV: Packet is being %s\n",
                    (eaAction is DROP)?"DROPPED":"FORWARDED"
                    ));
                RecordTimeOut();
                IncrementForward();
                return eaAction;
            }

            //
            // We need to walk the out interface filters. We dont let go of the in cache though.
            // This doesnt block any reader, only stops the cache entry from being reused
            //

            pOutCache = g_filters.ppOutCache[dwIndex];

            LockCache(pOutCache);

            if(OutCacheMatch(*puliSrcDstAddr,uliProtoSrcDstPort,pOutInterface,pOutCache))
            {

                TRACE(CACHE,("IPFLTDRV: Matched OutCache entry\n"));

                eaAction = pOutCache->eaOutAction;


                FiltHit(pOutCache->pOutFilter,
                        pOutCache->pOutContext,
                        eaAction,
                        pIpHeader,
                        pbRestOfPacket,
                        uiPacketLength,
                        FALSE);
//                InterlockedIncrement(pOutCache->pdwOutHitCounter);


                if(!(dwGlobals & GLOBS_SYNDrop))
                {
                    InCacheOutUpdate(pOutInterface,
                                     eaAction,
                                     dwIndex,
                                     pInCache,
                                     pOutCache->pOutFilter);
                }

                ReleaseCache(pInCache);
                ReleaseCache(pOutCache);
                ReleaseReadLock(&g_filters.ifListLock,&LockState);
                if (bFirstFrag)
                {
                    FragCacheUpdate(*puliSrcDstAddr,
                                    pInInterface,
                                    pOutInterface,
                                    dwId,
                                    eaAction);
                }
                TRACE(ACTION,(
                    "IPFLTDRV: Packet is being %s\n",
                    (eaAction is DROP)?"DROPPED":"FORWARDED"
                    ));
                RecordTimeOut();
                IncrementCache2();

                return eaAction;
            }

            ReleaseCache(pOutCache);

            //
            // Didnt match out cache entry, still holding incache, walk out filters
            //
            
            TRACE(CACHE,("IPFLTDRV: Didnt match OutCache entry\n"));

            TRACE(CACHE,("IPFLTDRV: Walking out filters\n"));

            pf = LookForFilter(pOutInterface,
                               puliSrcDstAddr,
                               &uliProtoSrcDstPort,
                               dwSum,
                               0);
            if(pf)
            {
                //
                // Update the out cache
                //


                eaAction = pOutInterface->eaOutAction ^ 0x00000001;


                FiltHit(pf,
                        pOutInterface,
                        eaAction,
                        pIpHeader,
                        pbRestOfPacket,
                        uiPacketLength,
                        FALSE);
//                    InterlockedIncrement(&(pf->dwNumHits));

                if(!(dwGlobals & GLOBS_SYNDrop))
                {
                    InCacheOutUpdate(pOutInterface,
                                     eaAction,
                                     dwIndex,
                                     pInCache,
                                     pf);

                    OutCacheUpdate(*puliSrcDstAddr,
                                   uliProtoSrcDstPort,
                                   pOutInterface,
                                   eaAction,
                                   dwIndex,
                                   pf);
                }

                ReleaseCache(pInCache);
                ReleaseReadLock(&g_filters.ifListLock,&LockState);
                if (bFirstFrag)
                {
                    FragCacheUpdate(*puliSrcDstAddr,
                                    pInInterface,
                                    pOutInterface,
                                    dwId,
                                    eaAction);
                }
                TRACE(ACTION,(
                    "IPFLTDRV: Packet is being %s\n",
                    (eaAction is DROP)?"DROPPED":"FORWARDED"
                    ));
                RecordTimeOut();
                IncrementWalkCache();

                return eaAction;
            }

            TRACE(CACHE,("IPFLTDRV: Didnt match any filters\n"));
//            InterlockedIncrement(&g_dwNumHitsDefaultOut);

            InCacheOutUpdate(pOutInterface,
                             pOutInterface->eaOutAction,
                             dwIndex,
                             pInCache,
                             NULL);

            OutCacheUpdate(*puliSrcDstAddr,
                           uliProtoSrcDstPort,
                           pOutInterface,
                           pOutInterface->eaOutAction,
                           dwIndex,
                           NULL);

            eaAction = pOutInterface->eaOutAction;

            ReleaseCache(pInCache);
            ReleaseReadLock(&g_filters.ifListLock,&LockState);
            if (bFirstFrag)
            {
                FragCacheUpdate(*puliSrcDstAddr,
                                pInInterface,
                                pOutInterface,
                                dwId,
                                eaAction);
            }
            TRACE(ACTION,(
                "IPFLTDRV: Packet is being %s\n",
                (eaAction is DROP)?"DROPPED":"FORWARDED"
                ));
            RecordTimeOut();
            IncrementWalkCache();

            return eaAction;
        }


        //
        // We couldnt get into the in cache, so we walk in filters, try outcache
        // probe, walk out filters, update out cache, update in cache, return
        // This is the worst case scenario
        //

        ReleaseCache(pInCache);

        TRACE(CACHE,("IPFLTDRV: Didnt match cache entry\n"));

        pfHit = NULL;

        //
        // eaAction is the default action. If we match a filter, we flip the action
        // so that at the end of the loop, eaAction describes the action to be taken on the
        // packet
        //

        eaAction = pInInterface->eaInAction;

        TRACE(CACHE,("IPFLTDRV: Walking in filters\n"));

        pf = LookForFilter(pInInterface,
                           puliSrcDstAddr,
                           &uliProtoSrcDstPort,
                           dwSum,
                           FILTER_FLAGS_INFILTER);
        if(pf)
        {
            eaAction = pInInterface->eaInAction ^ 0x00000001;
            pfHit = pf;

        }

        if(eaAction == DROP)
        {
            if(pInInterface->CountCtl.lInUse)
            {

                //
                // it's a drop and this interface is allowing all
                // TCP control frames. See if this is a TCP control
                // frame.

                if(CheckForTcpCtl(pInInterface,
                                  PROTOCOLPART(uliProtoSrcDstPort.LowPart),
                                  pIpHeader,
                                  pbRestOfPacket,
                                  uiPacketLength))
                {
                    pf = 0;
                    eaAction = FORWARD;
                    dwGlobals |= GLOBS_SYNDrop;
                }
            }
        }

        //
        // if not DROP check for spoofing.
        //

        if(eaAction == FORWARD)
        {
            if(pInInterface->dwIpIndex != UNKNOWN_IP_INDEX)
            {
                if(pInInterface->CountSpoof.lInUse)
                {
                     IPAddr SrcAddr = puliSrcDstAddr->LowPart;

                     //
                     // we need to check these addresses
                     //
     
                     if(!CheckAddress(SrcAddr, pInInterface->dwIpIndex))
                     {
                         eaAction = DROP;
                     }
                }

                if(pInInterface->CountStrongHost.lInUse)
                {
                     IPAddr DstAddr = puliSrcDstAddr->HighPart;

                     if(!MatchLocalLook(DstAddr, pInInterface->dwIpIndex))
                     {
                         eaAction = DROP;
                     }
                }
            }

            if(eaAction == DROP)
            {
                //
                // Spoofed address. Log it and drop this
                // 
                //

                RegisterSpoof(pInInterface,
                              pIpHeader,
                              pbRestOfPacket,
                              uiPacketLength);

                ReleaseReadLock(&g_filters.ifListLock,&LockState);
                eaAction = DROP;
                if (bFirstFrag)
                {
                    FragCacheUpdate(*puliSrcDstAddr,
                                    pInInterface,
                                    pOutInterface,
                                    dwId,
                                    eaAction);
                }
                return(eaAction);
            }

            //
            // finally, if not DROP, check for SYN and count it
            //

           if((PROTOCOLPART(uliProtoSrcDstPort.LowPart) == 6)
                         &&
               (dwGlobals & GLOBS_TCPGood)
                         &&
               ((((PTCPHeader)pbRest)->tcp_flags  &
                  (TCP_FLAG_SYN | TCP_FLAG_ACK)) == TCP_FLAG_SYN) )
            {
                pInInterface->liSYNCount.QuadPart++;
            }
        }

        FiltHit(pfHit,
                pInInterface,
                eaAction,
                pIpHeader,
                pbRestOfPacket,
                uiPacketLength,
                TRUE);
//        InterlockedIncrement(pdwHit);


        if((eaAction is DROP) or
           (pOutInterface is NULL))
        {
            //
            // We dont need to go any further if:
            // (i)   If the action says we drop
            // (ii)  If the out interface is NULL - because then this is the final action
            //

            if(!(dwGlobals & GLOBS_SYNDrop))
            {
                //
                // if this was dropped because of a SYN rejection
                // don't cache the entry. This means other SYNs
                // from this guy will cause a walk, but it also
                // means legitimate traffic from him will be
                // allowed. This also applies if it was forwarded
                // because of an "allow control messages" filter.
                //
                InCacheUpdate(*puliSrcDstAddr,
                              uliProtoSrcDstPort,
                              pInInterface,
                              eaAction, // Dont need full update? BUG?
                              dwIndex,
                              pfHit);
            }

            ReleaseReadLock(&g_filters.ifListLock,&LockState);
            if (bFirstFrag)
            {
                FragCacheUpdate(*puliSrcDstAddr,
                                pInInterface,
                                pOutInterface,
                                dwId,
                                eaAction);
            }
            TRACE(ACTION,(
                "IPFLTDRV: Packet is being %s\n",
                (eaAction is DROP)?"DROPPED":"FORWARDED"
                ));
            RecordTimeOut();
            IncrementWalk1();

            return eaAction;
        }

        //
        // If we have come till here, means we passed the in filter stage
        //

        TRACE(CACHE,("IPFLTDRV: Passed the in filter stage\n"));

        pOutCache = g_filters.ppOutCache[dwIndex];

        LockCache(pOutCache);

        if(OutCacheMatch(*puliSrcDstAddr,uliProtoSrcDstPort,pOutInterface,pOutCache))
        {

            TRACE(CACHE,("IPFLTDRV: nMatched OutCache entry\n"));

            eaAction = pOutCache->eaOutAction;

            FiltHit(pOutCache->pOutFilter,
                    pOutCache->pOutContext,
                    eaAction,
                    pIpHeader,
                    pbRestOfPacket,
                    uiPacketLength,
                    FALSE);
//            InterlockedIncrement(pOutCache->pdwOutHitCounter);


            if(!(dwGlobals & GLOBS_SYNDrop))
            {
                InCacheFullUpdate(*puliSrcDstAddr,
                                  uliProtoSrcDstPort,
                                  pInInterface,
                                  FORWARD, // If we are here, then the in action was forward
                                  pOutInterface,
                                  eaAction,
                                  dwIndex,
                                  pf,
                                  pOutCache->pOutFilter);
            }

            ReleaseCache(pOutCache);
            ReleaseReadLock(&g_filters.ifListLock,&LockState);
            if (bFirstFrag)
            {
                FragCacheUpdate(*puliSrcDstAddr,
                                pInInterface,
                                pOutInterface,
                                dwId,
                                eaAction);
            }
            TRACE(ACTION,(
                "IPFLTDRV: Packet is being %s\n",
                (eaAction is DROP)?"DROPPED":"FORWARDED"
                ));
            RecordTimeOut();
            IncrementWalkCache();

            return eaAction;
        }

        ReleaseCache(pOutCache);

        TRACE(CACHE,("IPFLTDRV: Didnt match OutCache entry\n"));

        TRACE(CACHE,("IPFLTDRV: Walking out filters\n"));

        pf1 = LookForFilter(pOutInterface,
                           puliSrcDstAddr,
                           &uliProtoSrcDstPort,
                           dwSum,
                           0);
        if(pf1)
        {
            //
            // Update the out cache
            //


            eaAction = pOutInterface->eaOutAction ^ 0x00000001;

            FiltHit(pf1,
                    pOutInterface,
                    eaAction,
                    pIpHeader,
                    pbRestOfPacket,
                    uiPacketLength,
                    FALSE);
//                InterlockedIncrement(&(pf->dwNumHits));

            if(!(dwGlobals & GLOBS_SYNDrop))
            {
                InCacheFullUpdate(*puliSrcDstAddr,
                                  uliProtoSrcDstPort,
                                  pInInterface,
                                  FORWARD,
                                  pOutInterface,
                                  eaAction,
                                  dwIndex,
                                  pf,
                                  pf1);


                OutCacheUpdate(*puliSrcDstAddr,
                               uliProtoSrcDstPort,
                               pOutInterface,
                               eaAction,
                               dwIndex,
                               pf1);

            }
            ReleaseReadLock(&g_filters.ifListLock,&LockState);
            if (bFirstFrag)
            {
                FragCacheUpdate(*puliSrcDstAddr,
                                pInInterface,
                                pOutInterface,
                                dwId,
                                eaAction);
            }
            TRACE(ACTION,(
                "IPFLTDRV: Packet is being %s\n",
                (eaAction is DROP)?"DROPPED":"FORWARDED"
                ));
            RecordTimeOut();
            IncrementWalk2();

            return eaAction;
        }

        TRACE(CACHE,("IPFLTDRV: Didnt match any filters\n"));

//        InterlockedIncrement(&g_dwNumHitsDefaultOut);

        InCacheFullUpdate(*puliSrcDstAddr,
                          uliProtoSrcDstPort,
                          pInInterface,
                          FORWARD,
                          pOutInterface,
                          pOutInterface->eaOutAction,
                          dwIndex,
                          pf,
                          NULL);

        OutCacheUpdate(*puliSrcDstAddr,
                       uliProtoSrcDstPort,
                       pOutInterface,
                       pOutInterface->eaOutAction,
                       dwIndex,
                       NULL);

        eaAction = pOutInterface->eaOutAction;
        ReleaseReadLock(&g_filters.ifListLock,&LockState);
        if (bFirstFrag)
        {
            FragCacheUpdate(*puliSrcDstAddr,
                            pInInterface,
                            pOutInterface,
                            dwId,
                            eaAction);
        }
        TRACE(ACTION,(
            "Packet is being %s\n",
            (eaAction is DROP)?"DROPPED":"FORWARDED"
            ));
        RecordTimeOut();
        IncrementWalk2();

        return eaAction;
    }

#endif // BASE_PERF
}

//__inline
VOID
FiltHit(PFILTER pf,
        PFILTER_INTERFACE pIf,
        FORWARD_ACTION Action,
        UNALIGNED IPHeader *pIpHeader,
        BYTE *pbRestOfPacket,
        UINT  uiPacketLength,
        BOOL fIn)
/*++
  Routine Description:
     Called whenever a filter action happens. If pf is NULL, then the
     action is the default interface action. If pf is non-NULL, then
     the action is the reverse of the interface action.

     pf the filter or NULL
     pIf the filter interface
     Action The computed action
     fIn TRUE if this is an in action, FALSE if an out action
--*/
{
    DWORD dwFilterRule;
    BOOL fLogAll;

    if(pf)
    {
        InterlockedIncrement(&pf->Count.lCount);
        dwFilterRule = pf->dwFilterRule;
        fLogAll = (pf->dwFlags & FILTER_FLAGS_LOGALL) != 0;
    }
    else
    {
        dwFilterRule = 0;
        fLogAll = FALSE;
    }

    if(fLogAll || (Action == DROP))
    {
        LogFiltHit(Action,
                   fIn,
                   dwFilterRule,
                   pIf,
                   pIpHeader,
                   pbRestOfPacket,
                   uiPacketLength);
    }
    return;
}

VOID
LogFiltHit(
        FORWARD_ACTION Action,
        BOOL fIn,
        DWORD    dwFilterRule,
        PFILTER_INTERFACE pIf,
        UNALIGNED IPHeader *pIpHeader,
        BYTE *pbRestOfPacket,
        UINT  uiPacketLength)
/*++
  Routine Description:
     Worker to do the logging on a filter hit. This is a separate
     routine so that FiltHit and be an inline for performance reasons.
--*/
{
    BOOL fHit = FALSE;

    if(fIn)
    {
        InterlockedIncrement(&pIf->lTotalInDrops);
    }
    else
    {
        InterlockedIncrement(&pIf->lTotalOutDrops);
    }

    if((pIf->lTotalInDrops + pIf->lTotalOutDrops) ==
       (LONG)pIf->dwDropThreshold)
    {
        fHit = TRUE;
    }

    //
    // If a log exists, do logging and event handling
    //

    if(pIf->pLog
         &&
       pIf->pLog->pUserAddress)
    {
        //
        // Try to log this data
        //

        LogData(
                PFE_FILTER,
                pIf,
                dwFilterRule,
                pIpHeader,
                pbRestOfPacket,
                uiPacketLength);

        if(fHit)
        {
            SignalLogThreshold(pIf->pLog);
        }
    }

    if(Action == DROP)
    {
        //
        // it's a dropped frame. See if we need to produce
        // a response. If this is an IPSEC frame we
        // don't do the right thing since we really need
        // to be looking at the upper layer protocol.
        //

        switch(pIpHeader->iph_protocol)
        {
            case 6:           // TCP
                SendTCPReset(pIpHeader, pbRestOfPacket, uiPacketLength);
                break;

            case PROT_IPSECAH:
            case PROT_IPSECESP:
            case 17:         // UDP
                SendUDPUnreachable(pIpHeader, pbRestOfPacket, uiPacketLength);
                break;
        }
    }
}

VOID
RegisterFragAttack(
            PFILTER_INTERFACE pIf,
            UNALIGNED IPHeader *pIpHeader,
            BYTE *pbRestOfPacket,
            UINT              uiSize)
{
    if(pIf->CountNoFrag.lInUse == 0)
    {
        InterlockedIncrement(&pIf->CountSynOrFrag.lCount);
    }
    else
    {
        InterlockedIncrement(&pIf->CountNoFrag.lCount);
    }

    if(pIf->pLog
         &&
       pIf->pLog->pUserAddress)
    {
        //
        // logging is enabled.
        //

        LogData(
                PFE_SYNORFRAG,
                pIf,
                0,
                pIpHeader,
                pbRestOfPacket,
                uiSize);

    }
}

VOID
RegisterFullDeny(
            PFILTER_INTERFACE pIf,
            UNALIGNED IPHeader *pIpHeader,
            BYTE *pbRestOfPacket,
            UINT              uiSize)
{
    InterlockedIncrement(&pIf->CountFullDeny.lCount);

    if(pIf->pLog
         &&
       pIf->pLog->pUserAddress)
    {
        //
        // logging is enabled.
        //

        LogData(
                PFE_FULLDENY,
                pIf,
                0,
                pIpHeader,
                pbRestOfPacket,
                uiSize);

    }
}

VOID
RegisterSpoof(     PFILTER_INTERFACE pIf,
                   UNALIGNED IPHeader *pIpHeader,
                   BYTE *pbRestOfPacket,
                   UINT              uiSize)
/*++
  Routine Description:
     Called when a spoofed address is encountered.
--*/
{


    InterlockedIncrement(&pIf->CountSpoof.lCount);

    //
    // See if logging is enabled. If so, log some of this frame.
    //
    //

    if(pIf->pLog
         &&
       pIf->pLog->pUserAddress)
    {
        //
        // logging is enabled.
        //

        LogData(
                PFE_SPOOF,
                pIf,
                0,
                pIpHeader,
                pbRestOfPacket,
                uiSize);

    }
}
VOID
RegisterUnusedICMP(PFILTER_INTERFACE pIf,
                   UNALIGNED IPHeader *pIpHeader,
                   BYTE *pbRestOfPacket,
                   UINT              uiSize)
/*++
  Routine Description:
     Called whenever an ICMP "unreachable" is sent from this machine
     on an interface listening for such things. It increments use
     counts and if any threshold is exceeded, signals the log event
--*/
{


    InterlockedIncrement(&pIf->CountUnused.lCount);

    //
    // See if logging is enabled. If so, log some of this frame.
    //
    //

    if(pIf->pLog
          &&
       pIf->pLog->pUserAddress)
    {
        //
        // logging is enabled.
        //

        LogData(
                PFE_UNUSEDPORT,
                pIf,
                0,
                pIpHeader,
                pbRestOfPacket,
                uiSize);

    }
}

VOID
LogData(
    PFETYPE  pfeType,
    PFILTER_INTERFACE pIf,
    DWORD   dwFilterRule,
    UNALIGNED IPHeader *pIpHeader,
    BYTE *pbRestOfPacket,
    UINT  uiPacketLength)
/*++
  Routine Description:
     Log the error. Copy the header and as much of the other data
     into the log as makes sense. If the log threshold is exceeded,
     or if the available space is running low, hit the event.
     The caller should not call this is no log is in force for the
     interface. The filter write lock is held.
--*/
{
    DWORD dwSpaceLeft, dwSpaceToUse, dwExtra;
    PPFLOGINTERFACE pLog = pIf->pLog;
    PPFLOGGEDFRAME pFrame;
    KIRQL kIrql;
    LONG lIpLen = (LONG)((DWORD)(pIpHeader->iph_verlen & IPHDRLEN) << IPHDRSFT);

    ASSERT(pLog);

    //
    // compute options length
    //
    lIpLen -= (LONG)sizeof(IPHeader);
    if(lIpLen < 0)
    {
         lIpLen = 0;
    }

    //
    // if can't do any logging, no need to proceed with
    // the computation
    //

    kIrql = LockLog(pLog);

    pIf->liLoggedFrames.QuadPart++;

    if(pLog->dwFlags & (LOG_OUTMEM | LOG_BADMEM))
    {
        pLog->dwLostEntries++;
        pIf->dwLostFrames++;
        UnLockLogDpc(pLog);
        return;
    }
    dwSpaceToUse = sizeof(PFLOGGEDFRAME) - 1;

    dwSpaceToUse += (DWORD)lIpLen;

    switch(pfeType)
    {
        default:
        case PFE_FILTER:
            dwExtra = (uiPacketLength < LOG_DATA_SIZE ?
                                  uiPacketLength : LOG_DATA_SIZE);
            break;

        case PFE_UNUSEDPORT:
            dwExtra = uiPacketLength;
            break;

    }

    dwSpaceToUse += dwExtra;

    //
    // align on a quadword boundary
    //
    dwSpaceToUse = ROUND_UP_COUNT(dwSpaceToUse, ALIGN_WORST);

    dwSpaceLeft = pLog->dwMapCount - pLog->dwMapOffset;

    if(dwSpaceLeft < dwSpaceToUse)
    {
        pLog->dwLostEntries++;
        AdvanceLog(pLog);
        UnLockLogDpc(pLog);
        if(!(pLog->dwFlags & (LOG_OUTMEM | LOG_BADMEM | LOG_CANTMAP)))
        {
            TRACE(LOGGER,("IPFLTDRV: Could not log data\n"));
        }
        return;
    }

    //
    // there's room. So log it.
    //

    pLog->dwLoggedEntries++;
    if(pLog->dwLoggedEntries == pLog->dwEntriesThreshold)
    {
        SignalLogThreshold(pLog);
    }
    pFrame = (PPFLOGGEDFRAME)pLog->pCurrentMapPointer;

    KeQuerySystemTime(&pFrame->Timestamp);
    pFrame->pfeTypeOfFrame = pfeType;
    pFrame->wSizeOfAdditionalData = (WORD)dwExtra;
    pFrame->wSizeOfIpHeader = (WORD)(sizeof(IPHeader) + lIpLen);
    pFrame->dwRtrMgrIndex = pIf->dwRtrMgrIndex;
    pFrame->dwFilterRule = dwFilterRule;
    pFrame->dwIPIndex = pIf->dwIpIndex;
    RtlCopyMemory(&pFrame->IpHeader, pIpHeader, sizeof(IPHeader) + lIpLen);
    RtlCopyMemory(&pFrame->bData + lIpLen,
                  pbRestOfPacket,
                  dwExtra);


    pFrame->dwTotalSizeUsed = dwSpaceToUse;

    pLog->pCurrentMapPointer += dwSpaceToUse;

    pLog->dwMapOffset += dwSpaceToUse;

    dwSpaceLeft -= dwSpaceToUse;

    if(dwSpaceLeft < pLog->dwMapWindowSizeFloor)
    {
        //
        // running low
        //

        AdvanceLog(pLog);
    }

    if(dwSpaceLeft < pLog->dwSignalThreshold)
    {
        SignalLogThreshold(pLog);
    }

    UnLockLogDpc(pLog);
}

VOID
ClearCacheEntry(PFILTER pFilt, PFILTER_INTERFACE pIf)
/*++
  Routine Description:
     Called when a filter is deleted. Compute where the matching
     packet would go and clear that cache entry.
--*/
{
    DWORD dwIndex;

    dwIndex = pFilt->SRC_ADDR                          +
                 pFilt->DEST_ADDR                      +
                 pFilt->DEST_ADDR                      +
                 PROTOCOLPART(pFilt->uliProtoSrcDstPort.LowPart)     +
                 pFilt->uliProtoSrcDstPort.HighPart;

    dwIndex %= g_dwCacheSize;

    ClearInCacheEntry(g_filters.ppInCache[dwIndex]);
    ClearOutCacheEntry(g_filters.ppOutCache[dwIndex]);
}

VOID
ClearAnyCacheEntry(PFILTER pFilt, PFILTER_INTERFACE pIf)
/*++
  Routine Description:
    Called when a wild card filter is deleted. It scans the caches looking
    for any cache entries pointing to this filter. The Write lock should be
    held
--*/
{
    DWORD   dwX;

    //
    // if an input filter, scan the infilter cache only
    //

    if((pFilt->dwFlags & FILTER_FLAGS_INFILTER))
    {
        for(dwX = 0; dwX < g_dwCacheSize; dwX++)
        {
            if(g_filters.ppInCache[dwX]->pInFilter == pFilt)
            {
                ClearInCacheEntry(g_filters.ppInCache[dwX]);
            }
        }
    }
    else
    {

        //
        //  output filters need scan both cachees.
        //

        for(dwX = 0; dwX < g_dwCacheSize; dwX++)
        {
            if(g_filters.ppOutCache[dwX]->pOutFilter == pFilt)
            {
                //
                // found one.
                //

                ClearOutCacheEntry(g_filters.ppOutCache[dwX]);
            }

            //
            // and checkout the cached output filter in the
            // corresponding InCache
            //
            if(g_filters.ppInCache[dwX]->pOutFilter == pFilt)
            {
                ClearInCacheEntry(g_filters.ppInCache[dwX]);
            }
        }
    }
}


BOOL
CheckRedirectAddress(UNALIGNED IPHeader *IPHead, DWORD dwInterface)
/*++
Routine Description:
   Called to validate a redirect message.
   Arguments:
     IpHead -- the redirect IP header
     dwInterface -- the interface index this came arrived on

     This routine is disabled for now because we don't know
     how to validate redirect messages.
--*/
{
#if 0
    IPRouteEntry iproute;
    IPRouteLookupData lup;
    PFILTER_INTERFACE pIf;
    PLIST_ENTRY pl;

    lup.DestAdd = ipAddr;
    lup.SrcAdd = 0;
    lup.Version = 0;
    LookupRoute(&lup, &iproute);
    if(iproute.ire_index == dwInterface)
    {
        return(TRUE);
    }
    
    //
    // not this interface. Look through all of the filtered interfaces
    // for a match. That is, allow the redirect to any other
    // filtered interface but no others.
    //

    for(pl = g_filters.leIfListHead.Flink;
        pl != &g_filters.leIfListHead;
        pl = pl->Flink)
    {
        pIf = CONTAINING_RECORD(pl, FILTER_INTERFACE, leIfLink);

        if(iproute.ire_index == pIf->dwIpIndex)
        {
            return(TRUE);
        }
    }
    return(FALSE);
#else
    return(TRUE);
#endif
}


BOOL
CheckAddress(IPAddr ipAddr, DWORD dwInterfaceId)
/*++
  Routine Description:
     Called to check that the given address belongs to the given interface
--*/
{
#if LOOKUPROUTE
    IPRouteEntry iproute;
    IPRouteLookupData lup;


    lup.DestAdd = ipAddr;
    lup.SrcAdd = 0;
    lup.Version = 0;
    LookupRoute(&lup, &iproute);
    if(iproute.ire_index == dwInterfaceId)
    {
        return(TRUE);
    }
    return(FALSE);
#else
    return(TRUE);
#endif
}

NTSTATUS
CheckFilterAddress(DWORD dwAdd, PFILTER_INTERFACE pIf)
{
    NTSTATUS Status;
    LOCK_STATE LockState;

    AcquireReadLock(&g_filters.ifListLock, &LockState);

    if(dwAdd && (pIf->dwIpIndex != UNKNOWN_IP_INDEX))
    {
        if(!CheckAddress(dwAdd, pIf->dwIpIndex))
        {
            Status = STATUS_INVALID_ADDRESS;
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    ReleaseReadLock(&g_filters.ifListLock, &LockState);
    return(Status);
}
    
       

#if DOFRAGCHECKING

PFILTER
CheckFragAllowed(
              PFILTER_INTERFACE pIf,
              UNALIGNED IPHeader *pIp)
/*++
  Routine Description:
    Called when a fragment is received. Checks whether the
    filters might allow it. Returns a filter that applies
--*/
{
    PFILTER                    pTemp;
    UNALIGNED PULARGE_INTEGER puliSrcDstAddr;
    ULARGE_INTEGER uliProtoSrcDstPort;
    ULARGE_INTEGER             uliAddr;
    ULARGE_INTEGER             uliPort;
    ULARGE_INTEGER             uliAuxMask;
    PLIST_ENTRY                List;
    PLIST_ENTRY                pList;
    

    if(pIf)
    {
        pList =  &pIf->FragLists[GetFragIndex((DWORD)pIp->iph_protocol)];

        if(!IsListEmpty(pList))
        {   
            puliSrcDstAddr = (UNALIGNED PULARGE_INTEGER)(&(pIp->iph_src));
            uliProtoSrcDstPort.LowPart =
              MAKELONG(MAKEWORD(pIp->iph_protocol,0x00),0x0000);

            //
            // always compare the protocol. Don't compare the must-be-connected.
            //
            uliAuxMask.LowPart = MAKELONG(MAKEWORD(0xff, 0), 0x0000);

            if(pIf->eaInAction == FORWARD)
            {
                uliAuxMask.HighPart = 0xffffffff;
            }
            else
            {
                uliAuxMask.HighPart = 0;
            }


            //
            // scan each input filter looking for a "match". Note that a match
            // in this case might be approximate. What we are looking for
            // is a match on the addresses and the protocol alone. Can't do
            // the ports 'cause we don't have them.
            //

            for(List = pList->Flink;
                List != pList;
                List = List->Flink)
            {
                pTemp = CONTAINING_RECORD(List, FILTER, leFragList);

                //
                // only look at input filters
                //
                if(pTemp->dwFlags & FILTER_FLAGS_INFILTER)
                {
                    uliAddr.QuadPart = (*puliSrcDstAddr).QuadPart & pTemp->uliSrcDstMask.QuadPart;

                    uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pTemp->uliProtoSrcDstMask.QuadPart;

                    if(uliAddr.QuadPart == pTemp->uliSrcDstAddr.QuadPart)
                    {
                        ULARGE_INTEGER uliAux;

                        //
                        // the addresses match. Now for the tricky part. What
                        // we do is mask off the parts of the filter description
                        // that don't apply. If this is a DROP filter, then
                        // mask nothing since only a filter that allows any
                        // port can match. If it is a FORWARD filter, then
                        // mask off the ports. 
                        //

                        uliAux.QuadPart = pTemp->uliProtoSrcDstPort.QuadPart & uliAuxMask.QuadPart;

                        if(uliAux.QuadPart == uliPort.QuadPart)
                        {
                            return(pTemp);
                        }
                    }
                }
            }
        }
    }
    return(NULL);
}

#endif    // DOFRAGCHECKING

PFILTER
LookForFilter(PFILTER_INTERFACE pIf,
              ULARGE_INTEGER UNALIGNED * puliSrcDstAddr,
              PULARGE_INTEGER puliProtoSrcDstPort,
              DWORD dwSum,
              DWORD dwFlags)
/*++
  Routine Description
    Look for a filter on an interface. The type is encoded in the flags
--*/
{
    PFILTER                    pTemp;
    ULARGE_INTEGER             uliAddr;
    ULARGE_INTEGER             uliPort;
    PLIST_ENTRY                List, pList;

    if(pIf->dwGlobalEnables & FI_ENABLE_OLD)
    {
        //
        // an old interface. Do it the hard way.
        //


        if(dwFlags & FILTER_FLAGS_INFILTER)
        {
            pList = &pIf->pleInFilterSet;
        }
        else
        {
            pList = &pIf->pleOutFilterSet;
        }

        for(List = pList->Flink;
            List != pList;
            List = List->Flink)
        {
            pTemp = CONTAINING_RECORD(List, FILTER, pleFilters);

            uliAddr.QuadPart = (*puliSrcDstAddr).QuadPart & pTemp->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = (*puliProtoSrcDstPort).QuadPart & pTemp->uliProtoSrcDstMask.QuadPart;

            if(GenericFilterMatch(uliAddr,uliPort,pTemp))
            {

                return(pTemp);
            }
        }
        return(NULL);
    }


    //
    // a new style interface. First look for a specific filter
    // match.
    //
    {
        dwSum %= g_dwHashLists;

        for(List = pIf->HashList[dwSum].Flink;
            List != &pIf->HashList[dwSum];
            List = List->Flink)
        {
            pTemp = CONTAINING_RECORD(List, FILTER, pleHashList);

            if(dwFlags == (pTemp->dwFlags & FILTER_FLAGS_INFILTER))
            {
                //
                // if any fields are wild, don't bother on this pass.
                //
                if(ANYWILDFILTER(pTemp))
                {
                   break;
                }
                uliPort.QuadPart = (*puliProtoSrcDstPort).QuadPart & pTemp->uliProtoSrcDstMask.QuadPart;

                if(OutFilterMatch(*puliSrcDstAddr, uliPort, pTemp))
                {
                    return(pTemp);
                }
            }
        }
    }

    //
    // not a specific filter match. Try a wild card with full-specified
    // local information. Such filters are also hashed.
    //

    if(pIf->dwWilds)
    {
        //
        // got some.
        //

        if(dwFlags & FILTER_FLAGS_INFILTER)
        {
            //
            // an input frame. Compute hash on the dest
            // params

            dwSum = puliSrcDstAddr->HighPart        +
                    puliSrcDstAddr->HighPart        +
                    PROTOCOLPART(puliProtoSrcDstPort->LowPart)  +
                    HIWORD(puliProtoSrcDstPort->HighPart);
        }
        else
        {
            //
            // an output frame. Compute the hash on the source
            // parameters
            //

            dwSum = puliSrcDstAddr->LowPart         +
                    PROTOCOLPART(puliProtoSrcDstPort->LowPart)   +
                    LOWORD(puliProtoSrcDstPort->HighPart);
        }

        dwSum %= g_dwHashLists;

        for(List = pIf->HashList[dwSum].Flink;
            List != &pIf->HashList[dwSum];
            List = List->Flink)
        {
            pTemp = CONTAINING_RECORD(List, FILTER, pleHashList);

            if(dwFlags == (pTemp->dwFlags & FILTER_FLAGS_INFILTER))
            {
                uliAddr.QuadPart = (*puliSrcDstAddr).QuadPart & pTemp->uliSrcDstMask.QuadPart;
                uliPort.QuadPart = (*puliProtoSrcDstPort).QuadPart & pTemp->uliProtoSrcDstMask.QuadPart;

                if(GenericFilterMatch(uliAddr,uliPort,pTemp))
                {

                    return(pTemp);
                }
            }
        }
    }

    //
    // didn't find it on the hash list. Search the default list for
    // really bizarre filters
    //

    if(dwFlags & FILTER_FLAGS_INFILTER)
    {
        dwSum = g_dwHashLists;
    }
    else
    {
        dwSum = g_dwHashLists + 1;
    }


    for(List = pIf->HashList[dwSum].Flink;
        List != &pIf->HashList[dwSum];
        List = List->Flink)
    {
        pTemp = CONTAINING_RECORD(List, FILTER, pleHashList);

//        if(dwFlags == (pTemp->dwFlags & FILTER_FLAGS_INFILTER))
        {
            uliAddr.QuadPart = (*puliSrcDstAddr).QuadPart & pTemp->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = (*puliProtoSrcDstPort).QuadPart & pTemp->uliProtoSrcDstMask.QuadPart;

            if(uliAddr.QuadPart == pTemp->uliSrcDstAddr.QuadPart)
            {
                //
                // addresses match. For the ports it depends
                // on whether this is a port range.
                //
                if(pTemp->dwFlags & FILTER_FLAGS_PORTWILD)
                {
                    ULARGE_INTEGER uliPort1;

                    //
                    // a port range. Have to do some more complicated
                    // matching. First mask the filter value.
                    //

                    uliPort1.QuadPart = pTemp->uliProtoSrcDstPort.QuadPart & pTemp->uliProtoSrcDstMask.QuadPart;

                    if(uliPort.QuadPart == uliPort1.QuadPart)
                    {
                        //
                        // it passes muster so far. So look at the
                        // range.
                        do
                        {

                            if(pTemp->wSrcPortHigh)
                            {
                                DWORD dwPort =
                                     LOWORD(puliProtoSrcDstPort->HighPart);

                                dwPort = net_short((USHORT)dwPort);

                                if((LOWORD(pTemp->uliProtoSrcDstPort.HighPart) >
                                    dwPort)
                                               ||
                                   (pTemp->wSrcPortHigh <
                                    dwPort))
                                {
                                    break;
                                }
                            }

                            if(pTemp->wDstPortHigh)
                            {
                                DWORD dwPort =
                                     HIWORD(puliProtoSrcDstPort->HighPart);

                                dwPort = net_short((USHORT)dwPort);

                                if((HIWORD(pTemp->uliProtoSrcDstPort.HighPart) >
                                    dwPort)
                                               ||
                                   (pTemp->wDstPortHigh <
                                    dwPort))
                                {
                                    break;
                                }
                            }
                            return(pTemp);
                        } while(TRUE);
                    }

                }
                else
                {
                    //
                    // not a range. So just do the simple test
                    //
                    if(uliPort.QuadPart == pTemp->uliProtoSrcDstPort.QuadPart)
                    {
                        return(pTemp);
                    }
                }
            }
        }
    }
    return(NULL);
}

#define TCP_OFFSET_MASK 0xf0
#define TCP_HDR_SIZE(t) (DWORD)(((*(uchar *)&(t)->tcp_flags) & TCP_OFFSET_MASK)>> 2)

BOOL
CheckForTcpCtl(
              PFILTER_INTERFACE pIf,
              DWORD Prot,
              UNALIGNED IPHeader *pIp,
              PBYTE     pbRest,
              DWORD     dwSize)
/*++
  Routine Description:
    Check for a TCP control packet. This is quite selective allowing
    only ACK, FIN, and RST packets with either no payload or a four-byte
    payload.
--*/
{
    if(Prot == MAKELONG(MAKEWORD(6, 0x00), 0x0000))
    {
        PTCPHeader pTcp = (PTCPHeader)pbRest;

        if((dwSize >= sizeof(TCPHeader))
                &&
          (dwSize <= (TCP_HDR_SIZE(pTcp) + 4)))
        {
            if(pTcp->tcp_flags & (TCP_FLAG_FIN | TCP_FLAG_ACK | TCP_FLAG_RST))
            {
                pIf->CountCtl.lCount++;
                return(TRUE);
            }
        }
    }
    return(FALSE);
}

VOID
SendTCPReset(UNALIGNED IPHeader * pIpHeader,
             BYTE *               pbRestOfPacket,
             ULONG                uiPacketLength)
/*++
Routine Description:
  Called when a TCP frame is dropped. Creates and sends a
  TCP reset frame.
--*/
{
    return;
}

VOID
SendUDPUnreachable(UNALIGNED IPHeader * pIpHeader,
                   BYTE *               pbRestOfPacket,
                   ULONG                uiPacketLength)
/*++
Routine Description:
  Called when a UDP frame is dropped. Creates and sends a
  UDP unreachable frame
--*/
{
    return;
}

VOID __fastcall
FragCacheUpdate(
    ULARGE_INTEGER  uliSrcDstAddr,
    PVOID           pInContext,
    PVOID           pOutContext,
    DWORD           dwId,
    FORWARD_ACTION  faAction
    )

/*++
Routine Description
    Called whenvert the first fragment of a fragmented packet arrives. The action
    taken on the fragment is cached and is applied to other fragments in fastpath.
--*/

{
    DWORD       dwFragIndex;
    KIRQL       kiCurrIrql;
    PLIST_ENTRY pleNode;
    PFRAG_INFO  pfiFragInfo;
        
    //
    // Look up id in frag table and check for a match
    //
    
    dwFragIndex = dwId % g_dwFragTableSize;

    TRACE(FRAG,(
        "IPFLTDRV: Updating frag cache with %x.%x %x\n",
        uliSrcDstAddr.HighPart, 
        uliSrcDstAddr.LowPart,
        dwId
        ));

    TRACE(FRAG,(
       "IPFLTDRV: In %x Out %x Id %x action %s\n",
       pInContext,
       pOutContext,
       dwId,
       (faAction is DROP)?"DROP":"FORWARD"
        ));

    KeAcquireSpinLock(&g_kslFragLock,
                      &kiCurrIrql);

#if DBG
    
    for(pleNode = g_pleFragTable[dwFragIndex].Flink;
        pleNode isnot &(g_pleFragTable[dwFragIndex]);
        pleNode = pleNode->Flink)
    {
        pfiFragInfo = CONTAINING_RECORD(pleNode,
                                        FRAG_INFO,
                                        leCacheLink);
        
        if((pfiFragInfo->uliSrcDstAddr.QuadPart is uliSrcDstAddr.QuadPart) and
           (pfiFragInfo->pvInContext is pInContext) and
           (pfiFragInfo->pvOutContext is pOutContext) and
           (pfiFragInfo->dwId is dwId))
        {
            //
            // Very weird, should never happen
            //

            TRACE(FRAG,("IPFLTDRV: FRAG Duplicate Insert\n"));
            DbgBreakPoint();
            
            KeQueryTickCount((PLARGE_INTEGER)&(pfiFragInfo->llLastAccess));

            KeReleaseSpinLock(&g_kslFragLock, kiCurrIrql);

            return;
        }
    }
    
#endif

    if(InterlockedIncrement(&g_dwNumFragsAllocs) > MAX_FRAG_ALLOCS)
    {
        TRACE(FRAG,(
            "IPFLTDRV: Fragcounter at %d\n",
            g_dwNumFragsAllocs
            ));

        InterlockedDecrement(&g_dwNumFragsAllocs);

        KeReleaseSpinLock(&g_kslFragLock, kiCurrIrql);

        return;
    }

    pfiFragInfo = ExAllocateFromNPagedLookasideList(&g_llFragCacheBlocks);

    if(pfiFragInfo is NULL)
    {
        ERROR(("IPFLTDRV: No memory for frags\n"));

        InterlockedDecrement(&g_dwNumFragsAllocs);

        KeReleaseSpinLock(&g_kslFragLock, kiCurrIrql);

        return;
    }

    // InterlockedIncrement(&g_dwNumFragsAllocs);

    pfiFragInfo->dwId                   = dwId;
    pfiFragInfo->uliSrcDstAddr.QuadPart = uliSrcDstAddr.QuadPart;
    pfiFragInfo->pvInContext            = pInContext;
    pfiFragInfo->pvOutContext           = pOutContext;
    pfiFragInfo->faAction               = faAction;

    KeQueryTickCount((PLARGE_INTEGER)&(pfiFragInfo->llLastAccess));
   
    TRACE(FRAG,(
        "IPFLTDRV: Inserted %x into index %d\n",
        pfiFragInfo,
        dwFragIndex
        ));
 
    InsertHeadList(&(g_pleFragTable[dwFragIndex]),
                   &(pfiFragInfo->leCacheLink));

    KeReleaseSpinLock(&g_kslFragLock, kiCurrIrql);

    return;
}

VOID
FragCacheTimerRoutine(
    PKDPC   Dpc,
    PVOID   DeferredContext,
    PVOID   SystemArgument1,
    PVOID   SystemArgument2
    )

/*++

Routine Description
    A DPC timer routine which fires up at a fixed interval to cleanup the fragment cache.
    Specifically the enetries unused for a predfined timer interval are freed.
--*/

{
    ULONG       i;
    LONGLONG    llCurrentTime;
    ULONGLONG   ullTime;
 
    KeQueryTickCount((PLARGE_INTEGER)&llCurrentTime);
        
    KeAcquireSpinLockAtDpcLevel(&g_kslFragLock);
    
    TRACE(FRAG,("IPFLTDRV: Timer called...\n"));
    for(i = 0; i < g_dwFragTableSize; i++)
    {
        PLIST_ENTRY pleNode;

        pleNode = g_pleFragTable[i].Flink;
    
        while(pleNode isnot &(g_pleFragTable[i]))
        {
            PFRAG_INFO  pfiFragInfo;

            pfiFragInfo = CONTAINING_RECORD(pleNode,
                                            FRAG_INFO,
                                            leCacheLink);


            pleNode = pleNode->Flink;

            ullTime = (ULONGLONG)(llCurrentTime - pfiFragInfo->llLastAccess);

            if(ullTime < (ULONGLONG)g_llInactivityTime)
            {
                continue;
            }
       
            TRACE(FRAG,(
                "IPFLTDRV: FragTimer removing %x from %d\n",
                pfiFragInfo, 
                i
                ));
    
            RemoveEntryList(&(pfiFragInfo->leCacheLink));

            ExFreeToNPagedLookasideList(&g_llFragCacheBlocks,
                                        pfiFragInfo);

            InterlockedDecrement(&g_dwNumFragsAllocs);

        }
    }

    KeReleaseSpinLockFromDpcLevel(&g_kslFragLock);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\globals.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    globals.h

Abstract:


Author:



Revision History:

--*/

#ifndef __GLOBALS__
#define __GLOBALS__

#include <ntosp.h>
#include <windef.h>

#include <ndis.h>
#include <tdikrnl.h>
#include <zwapi.h>

#include "defs.h"
#include "cache.h"
#include <ipexport.h>
#include <cxport.h>
#include <ip.h>
#include <ipfilter.h>
#include <ntddip.h>
#include <ipfltdrv.h>
#include "logger.h"
#include "filter.h"
#include "proto.h"

extern FILTER_DRIVER g_filters;
extern EXTENSION_DRIVER g_Extension;
extern DWORD g_dwCacheSize;
extern DWORD g_dwHashLists;
extern KSPIN_LOCK g_lOutFilterLock;
extern KSPIN_LOCK g_lInFilterLock;
extern LIST_ENTRY g_freeOutFilters;
extern LIST_ENTRY g_freeInFilters;
extern DWORD      g_dwNumHitsDefaultIn;
extern DWORD      g_dwNumHitsDefaultOut;
extern DWORD      g_FragThresholdSize;
extern ERESOURCE  FilterListResourceLock;
extern ULONG      g_ulBoundInterfaceCount;

extern NPAGED_LOOKASIDE_LIST   g_llFragCacheBlocks;
extern LONGLONG                g_llInactivityTime;
extern KSPIN_LOCK              g_kslFragLock;
extern DWORD                   g_dwFragTableSize;
extern PLIST_ENTRY             g_pleFragTable;
extern DWORD                   g_dwNumFragsAllocs;

extern ULONG                   TraceClassesEnabled;

#define FILTER_INTERFACE_SIZE (sizeof(FILTER_INTERFACE) - sizeof(LIST_ENTRY) \
               + ((g_dwHashLists + 2) * sizeof(LIST_ENTRY)))

#define PAGED_INTERFACE_SIZE (sizeof(PAGED_FILTER_INTERFACE) - \
       sizeof(LIST_ENTRY) + (2 * (g_dwHashLists * sizeof(LIST_ENTRY))))

#ifdef DRIVER_PERF
extern DWORD          g_dwFragments,g_dwNumPackets, g_dwCache1,g_dwCache2;
extern DWORD          g_dwWalk1,g_dwWalk2,g_dwForw,g_dwWalkCache;
extern KSPIN_LOCK     g_slPerfLock;
extern LARGE_INTEGER  g_liTotalTime;
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\proto.h ===
#ifndef __PROTO__
#define __PROTO__

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT  DriverObject,
            IN PUNICODE_STRING RegistryPath
            );

NTSTATUS
FilterDriverDispatch(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     );
VOID
FilterDriverUnload(
                   IN PDRIVER_OBJECT DriverObject
                   );
VOID
SetupExternalNaming(
                    IN PUNICODE_STRING ntname
                    );
                     
VOID
TearDownExternalNaming();

BOOL
InitFilterDriver();

BOOL
CloseFilterDriver();

BOOL
MatchLocalLook(DWORD Addr, DWORD dwIndex);

NTSTATUS
SetForwarderEntryPoint(
                       IPPacketFilterPtr pfnMatch
                       );

BOOL 
AllocateCacheStructures();

VOID
FreeExistingCache();

//FORWARD_ACTION __fastcall
FORWARD_ACTION 
MatchFilter(
            IPHeader UNALIGNED *pIpHeader,
            PBYTE              pbRestOfPacketPacket,
            UINT               uiPacketLength,
            UINT               RecvInterfaceIndex,
            UINT               SendInterfaceIndex,
            IPAddr             RecvLinkNextHop,
            IPAddr             SendLinkNextHop
            );

FORWARD_ACTION
MatchFilterp(
            UNALIGNED IPHeader *pIpHeader,
            BYTE               *pbRestOfPacket,
            UINT               uiPacketLength,
            UINT               RecvInterfaceIndex,
            UINT               SendInterfaceIndex,
            IPAddr             RecvLinkNextHop,
            IPAddr             SendLinkNextHop,
            INTERFACE_CONTEXT  RecvInterfaceContext,
            INTERFACE_CONTEXT  SendInterfaceContext,
            BOOL               fInnerCall,
            BOOL               fIoctlCall
            );

NTSTATUS
AddInterface(
             IN  PVOID pvRtrMgrCtxt,
             IN  DWORD dwRtrMgrIndex,
             IN  DWORD dwAdapterId,
             IN  PPFFCB Fcb,
             OUT PVOID *ppvFltrDrvrCtxt
             );

NTSTATUS
DeleteInterface(
                IN  PVOID pvIfContext
                );

NTSTATUS
UnSetFiltersEx(
           IN PPFFCB                      Fcb,
           IN PPAGED_FILTER_INTERFACE     pPage,
           DWORD                          dwLength,
           IN PFILTER_DRIVER_SET_FILTERS  pRtrMgrInfo
           );

NTSTATUS
SetFiltersEx(
           IN PPFFCB                      Fcb,
           IN PPAGED_FILTER_INTERFACE     pPage,
           DWORD                          dwLength,
           IN PFILTER_DRIVER_SET_FILTERS  pRtrMgrInfo
           );

NTSTATUS
SetFilters(
           IN PFILTER_DRIVER_SET_FILTERS  pRtrMgrInfo
           );

NTSTATUS
UpdateBindingInformation(
                         PFILTER_DRIVER_BINDING_INFO pBindInfo,
                         PVOID                       pvContext
                         );

NTSTATUS
GetFilters(
           IN  PVOID          pvIfContext,
           IN  BOOL           fClear,
           OUT PFILTER_IF     pInfo
           );

PFILTER_INTERFACE
NewInterface(
             IN  PVOID   pvContext,
             IN  DWORD   dwIndex,
             IN  FORWARD_ACTION inAction,
             IN  FORWARD_ACTION outAction,
             IN  PVOID   pvOldContext,
             IN  DWORD   dwIpIndex,
             IN  DWORD   dwName
             );

VOID
DeleteFilters(
              IN PFILTER_INTERFACE pIf,
              IN DWORD             dwInOrOut
              );

VOID
ClearCache();

NTSTATUS
MakeNewFilters(
               IN  DWORD        dwNumFilters,
               IN  PFILTER_INFO pFilterInfo,
               IN  BOOL         fInFilter,
               OUT PLIST_ENTRY  pList
               );

PRTR_TOC_ENTRY
GetPointerToTocEntry(
                     DWORD                     dwType,
                     PRTR_INFO_BLOCK_HEADER    pInfoHdr
                     );

NTSTATUS
DoIpIoctl(
          IN  PWCHAR        DriverName,
          IN  DWORD         Ioctl,
          IN  PVOID         pvInArg,
          IN  DWORD         dwInSize,
          IN  PVOID         pvOutArg,
          IN  DWORD         dwOutSize,
          OUT PDWORD        pdwFinalSize OPTIONAL);

NTSTATUS
AddNewInterface(PPFINTERFACEPARAMETERS pInfo,
                PPFFCB     Fcb);

VOID
DereferenceLog(PPFLOGINTERFACE pLog);

VOID
AddRefToLog(PPFLOGINTERFACE pLog);

NTSTATUS
ReferenceLogByHandleId(PFLOGGER LogId,
                       PPFFCB Fcb,
                       PPFLOGINTERFACE * ppLog);

BOOL
DereferenceFilter(PFILTER pFilt, PFILTER_INTERFACE pIf);

NTSTATUS
DeletePagedInterface(PPFFCB Fcb, PPAGED_FILTER_INTERFACE pPage);

VOID
InitLogs();

NTSTATUS
PfLogCreateLog(PPFLOG pLog,
               PPFFCB Fcb,
               PIRP Irp);

NTSTATUS
PfDeleteLog(PPFDELETELOG pfDel,
            PPFFCB Fcb);

NTSTATUS
PfLogSetBuffer( PPFSETBUFFER pSet, PPFFCB Fcb, PIRP Irp );

NTSTATUS
GetInterfaceParameters(PPAGED_FILTER_INTERFACE pPage,
                       PPFGETINTERFACEPARAMETERS pp,
                       PDWORD                   pdwSize);

VOID
AdvanceLog(PPFLOGINTERFACE pLog);

DWORD
GetIpStackIndex(IPAddr Addr, BOOL fNew);

KIRQL
LockLog(PPFLOGINTERFACE pLog);

NTSTATUS
SetInterfaceBinding(PINTERFACEBINDING pBind,
                    PPAGED_FILTER_INTERFACE pPage);

NTSTATUS
SetInterfaceBinding2(PINTERFACEBINDING2 pBind,
                    PPAGED_FILTER_INTERFACE pPage);

NTSTATUS
ClearInterfaceBinding(PPAGED_FILTER_INTERFACE pPage, PINTERFACEBINDING pBind);

VOID
ClearCacheEntry(PFILTER pFilt, PFILTER_INTERFACE pIf);

VOID
ClearAnyCacheEntry(PFILTER pFilt, PFILTER_INTERFACE pIf);

NTSTATUS
UpdateBindingInformationEx(
                         PFILTER_DRIVER_BINDING_INFO pBindInfo,
                         PPAGED_FILTER_INTERFACE pPage
                         );

NTSTATUS
SetExtensionPointer(
                  PPF_SET_EXTENSION_HOOK_INFO Info,
                  PFILE_OBJECT FileObject
                  );


PFILTER_INTERFACE
FilterDriverLookupInterface(
    IN ULONG Index,
    IN IPAddr LinkNextHop
    );


BOOL
WildFilter(PFILTER pf);

__inline
BMAddress(DWORD dwAddr)
/*++
  Routine Description:
    Check if the given address is the broadcast address or
    a multicast address.
--*/
{
    UCHAR cPtr = (UCHAR)dwAddr;

    if((dwAddr == BCASTADDR)
             ||
       ((cPtr >= MCASTSTART) && (cPtr <= MCASTEND) )
      )
    {
        return(TRUE);
    }
    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\api.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: Api.h
//
// Abstract:
//      This module contains declarations for api.c
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//=============================================================================

#ifndef _API_H_
#define _API_H_


//
// PROTOTYPES OF FUNCTIONS USED ONLY IN THIS FILE
//

BOOL DllStartup();
BOOL DllCleanup();
VOID ProtocolCleanup();
BOOL ValidateGlobalConfig(
        PIGMP_MIB_GLOBAL_CONFIG pGlobalConfig);


//
// API's
//

DWORD WINAPI 
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );

DWORD WINAPI
StartProtocol(
    IN HANDLE               hMgrNotifyEvent,
    IN PSUPPORT_FUNCTIONS   pSupportFunctions,
    IN PVOID                pGlobalConfig,
    IN ULONG                ulStructureVersion,
    IN ULONG                ulStructureSize,
    IN ULONG                ulStructureCount
    );

DWORD WINAPI
StartComplete(
    VOID
    );
    
DWORD WINAPI
StopProtocol(
    VOID
    );

DWORD WINAPI
GetGlobalInfo(
    IN OUT PVOID    pConfig,
    IN OUT PDWORD   pdwSize,
    IN OUT PULONG   pulStructureVersion,
    IN OUT PULONG   pulStructureSize,
    IN OUT PULONG   pulStructureCount    
    );

DWORD WINAPI
SetGlobalInfo(
    IN PVOID pConfig,
    IN ULONG ulStructureVersion,
    IN ULONG ulStructureSize,
    IN ULONG ulStructureCount
    );

DWORD WINAPI
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT MESSAGE *pResult
    );

DWORD WINAPI
GetNeighbors(
    IN DWORD    InterfaceIndex,
    IN PDWORD   NeighborList,
    IN OUT PDWORD NeighborListSize,
    OUT PBYTE   InterfaceFlags
    );

DWORD WINAPI
GetMfeStatus(
    IN DWORD    InterfaceIndex,
    IN DWORD    GroupAddress,
    IN DWORD    SourceAddress,
    OUT PBYTE   StatusCode
    );
    
DWORD WINAPI
InterfaceStatus(
    ULONG IfIndex,
    BOOL  bIfActive,
    DWORD dwStatusType,
    PVOID pvStatusInfo
    );

#endif     //_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\global.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: global.h
//
// Abstract:
//      This file contains declarations for the global variables
//      and some global #defines.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
//=============================================================================

#ifndef _IGMP_H_
#define _IGMP_H_


//------------------------------------------------------------------------------
// SOME GLOBAL #DEFINES
//------------------------------------------------------------------------------


// log warning every 60 min if ver-1 router present when my router is ver-2
#define OTHER_VER_ROUTER_WARN_INTERVAL  60


//
// the router remains in ver-1 for 400secs after hearing from a ver-1 router
//
#define IGMP_VER1_RTR_PRESENT_TIMEOUT   40000L 



//
// the default size set for local mib enumeration.
//
#define MIB_DEFAULT_BUFFER_SIZE         500


//
// for the first 5 sockets, I bind them to different event objects
//
#define NUM_SINGLE_SOCKET_EVENTS        5


//
// at most 30 sockets will be bound to the same event.
//
#define MAX_SOCKETS_PER_EVENT           30



//
// various codes describing states of igmp
//
typedef enum _IGMP_STATUS_CODE {
    IGMP_STATUS_STARTING   = 100,
    IGMP_STATUS_RUNNING    = 101,
    IGMP_STATUS_STOPPING   = 102,
    IGMP_STATUS_STOPPED    = 103
} IGMP_STATUS_CODE, *PIGMP_STATUS_CODE;



//------------------------------------------------------------------------------
//
// struct:    IGMP_GLOBAL
//
// The critical section IGMP_GLOBAL::CS protects the fields Status,
// ActivityCount and ActivitySemaphore.
// Changes: if any new fields are added, make sure that StartProtocol() takes 
//    appropriate action of its value being reset if StartProtocol() is called 
//    immediately after StopProtocol().
// Locks for ProxyIfEntry: take the lock on the interface, and then check
//    again if the g_pProxyIfEntry value has been changed.
//
// Note: if any new field is added,  you might have to reset it in StartProtocol
//------------------------------------------------------------------------------



// used during cleanup to see what all structures need to be deleted

extern DWORD                   g_Initialized;



//
// Interface table: IF_HASHTABLE_SZ set in table.h to 256
// Contains the hash table, lists, etc.
//

extern PIGMP_IF_TABLE               g_pIfTable;



// group table: GROUP_HASH_TABLE_SZ set in table.h to 256

extern PGROUP_TABLE            g_pGroupTable;



// defined in table.h. contains LoggingLevel and RasClientStats

extern GLOBAL_CONFIG           g_Config;



// defined in table.h. contains Current-Added GroupMemberships

extern IGMP_GLOBAL_STATS       g_Info;



//
// list of sockets (1st 4 interfaces will be bound to different sockets).
// After that, a socket will be created for every 30 interfaces
// Most of the operations take read lock (input packet).
//

extern LIST_ENTRY              g_ListOfSocketEvents;
extern READ_WRITE_LOCK         g_SocketsRWLock;

// enum lock
extern READ_WRITE_LOCK         g_EnumRWLock;
    


// Igmp global timer. defined in igmptimer.h

extern IGMP_TIMER_GLOBAL       g_TimerStruct; 


//
// MGMhandle for igmp router and proxy.
//

extern HANDLE                  g_MgmIgmprtrHandle;
extern HANDLE                  g_MgmProxyHandle;
extern CRITICAL_SECTION        g_ProxyAlertCS;
extern LIST_ENTRY              g_ProxyAlertsList;



//------------------------------------------------------------------------------
// proxy interface.
//
// For accessing proxy Interface, 
//  1. tmpVar = g_ProxyIfIndex.
//  2. Read/WriteLockInterface(tmpVar).
//  3. check(tmpVar==g_ProxyIfIndex). If FALSE, UnlockInterface using tmpVar
//      as index, and goto 1 and try again.
//  4. if TRUE, g_ProxyIfEntry is valid for use. Release IF lock when done.
//
// While deleting, the interface is write locked and g_ProxyIfIndex is
// changed using interlocked operation
//
// most of the operations for the proxy interface involve creating/deleting
// group entries and (un)binding the Mcast group from the socket. The
// processing being less, I dont create dynamic lock for each bucket,
// also no point creating a ProxyHT_CS. I just take a write lock for the 
// interface. Change this if required. However dynamic locking would require
// additional 3 lockings in addition to interface locking.
//------------------------------------------------------------------------------

extern DWORD                   g_ProxyIfIndex;
extern PIF_TABLE_ENTRY         g_pProxyIfEntry;

#define PROXY_HASH_TABLE_SZ 128



//
// ras interface
//
extern DWORD                   g_RasIfIndex;
extern PIF_TABLE_ENTRY         g_pRasIfEntry;



//
// global lock:
// protects g_ActivitySemaphore, g_ActivityCount, g_RunningStatus
//

extern CRITICAL_SECTION        g_CS;



// 
// contains list of free dynamic CS locks and the MainLock
//

extern DYNAMIC_LOCKS_STORE     g_DynamicCSStore;
extern DYNAMIC_LOCKS_STORE     g_DynamicRWLStore;



//
// used to know how many active threads are running
// protected by g_CS
//

extern HANDLE                  g_ActivitySemaphore;
extern LONG                    g_ActivityCount;
extern DWORD                   g_RunningStatus;
extern HINSTANCE               g_DllHandle;


// rtm event and queue

extern HANDLE                  g_RtmNotifyEvent;
extern LOCKED_LIST             g_RtmQueue;



extern HANDLE                  g_Heap;
extern DWORD                   g_TraceId;
extern HANDLE                  g_LogHandle;



// global variable used to assign unique ids for mib enumeration

extern USHORT                  g_GlobalIfGroupEnumSignature;


#ifdef MIB_DEBUG    
extern DWORD                   g_MibTraceId;
extern IGMP_TIMER_ENTRY        g_MibTimer;
#endif



// IGMP_GLOBAL





//------------------------------------------------------------------------------
// type definitions for event message queue
//------------------------------------------------------------------------------

typedef struct _EVENT_QUEUE_ENTRY {

    ROUTING_PROTOCOL_EVENTS EventType;
    MESSAGE                 Msg;

    LIST_ENTRY              Link;

} EVENT_QUEUE_ENTRY, *PEVENT_QUEUE_ENTRY;


DWORD
EnqueueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS EventType,
    MESSAGE Msg
    );

DWORD
DequeueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS *pEventType,
    PMESSAGE pResult
    );


#endif // #ifndef _IGMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\api.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// Module Name: Api.c
// Abstract:
//      This module implements some of the Igmp APIs
//      RegisterProtocol, StartProtocol, StopProtocol,
//      GetGlobalInfo, SetGlobalInfo, and GetEventMessage
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//=============================================================================


#include "pchigmp.h"
#pragma hdrstop


//------------------------------------------------------------------------------
// Global variables (see global.h for description)
//------------------------------------------------------------------------------

DWORD                   g_Initialized;


// interface table, group table, global config, global stats

PIGMP_IF_TABLE          g_pIfTable;
PGROUP_TABLE            g_pGroupTable;
GLOBAL_CONFIG           g_Config;
IGMP_GLOBAL_STATS       g_Info;

// socket wait-event bindings

LIST_ENTRY              g_ListOfSocketEvents;
READ_WRITE_LOCK         g_SocketsRWLock;

// igmp global timer struct

IGMP_TIMER_GLOBAL       g_TimerStruct;

// protocol handles returned by mgm

HANDLE                  g_MgmIgmprtrHandle;
HANDLE                  g_MgmProxyHandle;

// proxy table

DWORD                   g_ProxyIfIndex;
PIF_TABLE_ENTRY         g_pProxyIfEntry;
CRITICAL_SECTION        g_ProxyAlertCS;
LIST_ENTRY              g_ProxyAlertsList;


// ras table

DWORD                   g_RasIfIndex;
PIF_TABLE_ENTRY         g_pRasIfEntry;

// global lock, and dynamic locks

CRITICAL_SECTION        g_CS;
DYNAMIC_LOCKS_STORE     g_DynamicCSStore;
DYNAMIC_LOCKS_STORE     g_DynamicRWLStore;

// enum lock
READ_WRITE_LOCK         g_EnumRWLock;

// others

HANDLE                  g_ActivitySemaphore;
LONG                    g_ActivityCount;
DWORD                   g_RunningStatus;
HINSTANCE               g_DllHandle;

HANDLE                  g_RtmNotifyEvent;
LOCKED_LIST             g_RtmQueue;

HANDLE                  g_Heap;
DWORD                   g_TraceId=INVALID_TRACEID;
HANDLE                  g_LogHandle;

// signature for each enumeration

USHORT                  g_GlobalIfGroupEnumSignature;

#ifdef MIB_DEBUG
DWORD                   g_MibTraceId;
IGMP_TIMER_ENTRY        g_MibTimer;
#endif

#if DEBUG_FLAGS_MEM_ALLOC
extern CRITICAL_SECTION g_MemCS;
#endif




//------------------------------------------------------------------------------
// #defines for g_Initialized
//------------------------------------------------------------------------------

//
// the below flags are used to mark if the data has been initialized.
// If a flag is not set, the corresponding structure wont be deinitialized
//

#define TIMER_GLOBAL_INIT           0x00000002
#define WINSOCK_INIT                0x00000010
#define DYNAMIC_CS_LOCKS_INIT       0x00000020
#define DYNAMIC_RW_LOCKS_INIT       0x00000040
#define GROUP_TABLE_INIT            0x00000080
#define IF_TABLE_INIT               0x00000100



//
// flags associated with dll and calls made before start protocol.
// these flags should not be reset by start protocol
//
#define DLL_STARTUP_FLAGS           0xFF000000


//
// Is StartProtocol being called immediately after DLL startup.
// Used to see if heap has to be destroyed and recreated.
// Set in DllStartup() and cleared in ProcolCleanup() as part of StopProtocol()
//
#define CLEAN_DLL_STARTUP           0x01000000

// flag set to prevent register_protocol from being called multiple times.
#define REGISTER_PROTOCOL           0x02000000





//------------------------------------------------------------------------------
//      _DLLMAIN
//
// Called immediately after igmpv2.dll is loaded for the first time by the
// process, and when the igmpv2.dll is unloaded by the process.
// It does some initialization/final cleanup.
//
// Calls: _DllStartup() or _DllCleanup()
//------------------------------------------------------------------------------
BOOL
WINAPI
DLLMAIN (
    HINSTANCE   hModule,
    DWORD       dwReason,
    LPVOID      lpvReserved
    )
{

    BOOL     bNoErr;
    DWORD    Error=NO_ERROR;


    switch (dwReason) {

        //
        // Startup Initialization of Dll
        //
        case DLL_PROCESS_ATTACH:
        {
            // disable per-thread initialization
            DisableThreadLibraryCalls(hModule);


            // create and initialize global data
            bNoErr = DllStartup();

            break;
        }


        //
        // Cleanup of Dll
        //
        case DLL_PROCESS_DETACH:
        {
            // free global data
            bNoErr = DllCleanup();

            break;
        }


        default:
            bNoErr = TRUE;
            break;

    }
    return bNoErr;

} //end _DLLMAIN



//------------------------------------------------------------------------------
//            _DllStartup
//
// Sets the initial igmp status to IGMP_STATUS_STOPPED, creates a private heap,
// Does the initialization of the rtm queue and tracing/logging,
// and creates the global critical section.
//
// Note: no structures must be allocated from heap here, as StartProtocol()
//    if called after StopProtocol() destroys the heap.
// Return Values: TRUE (if no error), else FALSE.
//------------------------------------------------------------------------------
BOOL
DllStartup(
    )
{
    BOOL     bNoErr;
    DWORD    Error=NO_ERROR;


    //not required to ZeroMemory igmp global struct as it is a global variable


    //
    // set the initial igmp status to stopped.
    // The status is set to running, after the protocol specific initialization
    // is completed as part of Start Protocol
    //
    g_RunningStatus = IGMP_STATUS_STOPPED;


    bNoErr = FALSE;


    BEGIN_BREAKOUT_BLOCK1 {


        // set the default logging level. It will be reset during
        // StartProtocol(), when logging level is set as part of global config

        g_Config.LoggingLevel = IGMP_LOGGING_WARN;



        //
        // create a private heap for Igmp
        //
        g_Heap = HeapCreate(0, 0, 0);

        if (g_Heap == NULL) {
            Error = GetLastError();
            GOTO_END_BLOCK1;
        }



        try {
            // initialize the Router Manager event queue

            CREATE_LOCKED_LIST(&g_RtmQueue);


            // create global critical section

            InitializeCriticalSection(&g_CS);
        }

        except (EXCEPTION_EXECUTE_HANDLER) {

            Error = GetExceptionCode();
            GOTO_END_BLOCK1;
        }



        // igmp has a clean initialization from DLL startup. If StartProtocol
        // is now called, it does not have to cleanup the heap.

        g_Initialized |= CLEAN_DLL_STARTUP;


        bNoErr = TRUE;

    } END_BREAKOUT_BLOCK1;

    return bNoErr;

} //end _DllStartup



//------------------------------------------------------------------------------
//            _DllCleanup
//
// Called when the igmpv2 dll is being unloaded. StopProtocol() would have
// been called before, and that would have cleaned all the igmpv2 structures.
// This call frees the rtm queue, the global CS, destroys the local heap,
// and deregisters tracing/logging.
//
// Return Value:  TRUE
//------------------------------------------------------------------------------
BOOL
DllCleanup(
    )
{

    // destroy the router manager event queue

    if (LOCKED_LIST_CREATED(&g_RtmQueue)) {

         DELETE_LOCKED_LIST(&g_RtmQueue, EVENT_QUEUE_ENTRY, Link);
    }


    //DebugCheck
    //DebugScanMemory();

    // delete global critical section

    DeleteCriticalSection(&g_CS);

    #if DEBUG_FLAGS_MEM_ALLOC
    DeleteCriticalSection(&g_MemCS);
    #endif

    // destroy private heap

    if (g_Heap != NULL) {
        HeapDestroy(g_Heap);
    }


    //  deregister tracing/error logging

    if (g_LogHandle)
        RouterLogDeregister(g_LogHandle);
    if (g_TraceId!=INVALID_TRACEID)
        TraceDeregister(g_TraceId);
    
    return TRUE;
}

VOID
InitTracingAndLogging(
    )
{
    BEGIN_BREAKOUT_BLOCK1 {
    
        #define REGKEY_TRACING TEXT("Software\\Microsoft\\Tracing\\IGMPv2")
        #define REGVAL_CONSOLETRACINGMASK   TEXT("ConsoleTracingMask")
        TCHAR szTracing[MAX_PATH];
        HKEY pTracingKey;
        DWORD Value, Error;
        lstrcpy(szTracing, REGKEY_TRACING);

        
        Error = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, szTracing, 0, KEY_SET_VALUE, &pTracingKey
                    );
        if (Error != ERROR_SUCCESS)
            GOTO_END_BLOCK1;
            
                
        Value = 0x00ff0000;
        RegSetValueEx(
                    pTracingKey, REGVAL_CONSOLETRACINGMASK, 0,
                    REG_DWORD, (LPBYTE)&Value, sizeof(DWORD)
                    );

        RegCloseKey(pTracingKey);

    } END_BREAKOUT_BLOCK1;



    // initialize tracing and error logging

    if (g_TraceId==INVALID_TRACEID) {
        g_TraceId = TraceRegister("IGMPv2");
    }
    

    if (!g_LogHandle) {
        g_LogHandle = RouterLogRegister("IGMPv2");
    }
}



//------------------------------------------------------------------------------
//            _RegisterProtocol
//
// This is the first function called by the IP Router Manager.
//    The Router Manager tells the routing protocol its version and capabilities
//    It also tells the DLL, the ID of the protocol it expects us to
//    register.  This allows one DLL to support multiple routing protocols.
//    We return the functionality we support and a pointer to our functions.
// Return Value:
//    Error: The error code returned by MGM if registering with it failed
//    else NO_ERROR
//------------------------------------------------------------------------------
DWORD
WINAPI
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    )
{
    DWORD   Error = NO_ERROR;

    // Note: There should not be any trace/logs before here

    InitTracingAndLogging() ;

    Trace0(ENTER, "RegisterProtocol()");



    // cannot call RegisterProtocol multiple times

    if (g_Initialized&REGISTER_PROTOCOL) {
        Trace0(ERR, "Error: _RegisterProtocol() called multiple times for igmp");
        IgmpAssertOnError(FALSE);
        return ERROR_CAN_NOT_COMPLETE;
    }
    else {
        g_Initialized |= REGISTER_PROTOCOL;
    }



    //
    // The Router Manager should be calling us to register our protocol.
    // The Router Manager must be atleast the version we are compiled with
    // The Router Manager must support routing and multicast.
    //

    if(pRoutingChar->dwProtocolId != MS_IP_IGMP)
        return ERROR_NOT_SUPPORTED;

    if(pRoutingChar->dwVersion < MS_ROUTER_VERSION)
        return ERROR_NOT_SUPPORTED;

    if(!(pRoutingChar->fSupportedFunctionality & RF_ROUTING)
        || !(pRoutingChar->fSupportedFunctionality & RF_MULTICAST) )
        return ERROR_NOT_SUPPORTED;



    //
    // We setup our characteristics and function pointers
    // All pointers should be set to NULL by the caller.
    //

    pServiceChar->fSupportedFunctionality = 0;

    pRoutingChar->fSupportedFunctionality = RF_MULTICAST | RF_ROUTING;

    pRoutingChar->pfnStartProtocol    = StartProtocol;
    pRoutingChar->pfnStartComplete    = StartComplete;
    pRoutingChar->pfnStopProtocol     = StopProtocol;
    pRoutingChar->pfnAddInterface     = AddInterface;
    pRoutingChar->pfnDeleteInterface  = DeleteInterface;
    pRoutingChar->pfnInterfaceStatus  = InterfaceStatus;
    pRoutingChar->pfnGetEventMessage  = GetEventMessage;
    pRoutingChar->pfnGetInterfaceInfo = GetInterfaceConfigInfo;
    pRoutingChar->pfnSetInterfaceInfo = SetInterfaceConfigInfo;
    pRoutingChar->pfnGetGlobalInfo    = GetGlobalInfo;
    pRoutingChar->pfnSetGlobalInfo    = SetGlobalInfo;
    pRoutingChar->pfnMibCreateEntry   = MibCreate;
    pRoutingChar->pfnMibDeleteEntry   = MibDelete;
    pRoutingChar->pfnMibGetEntry      = MibGet;
    pRoutingChar->pfnMibSetEntry      = MibSet;
    pRoutingChar->pfnMibGetFirstEntry = MibGetFirst;
    pRoutingChar->pfnMibGetNextEntry  = MibGetNext;
    pRoutingChar->pfnUpdateRoutes     = NULL;
    pRoutingChar->pfnConnectClient    = ConnectRasClient;
    pRoutingChar->pfnDisconnectClient = DisconnectRasClient;
    pRoutingChar->pfnGetNeighbors     = GetNeighbors;
    pRoutingChar->pfnGetMfeStatus     = GetMfeStatus;
    pRoutingChar->pfnQueryPower       = NULL;
    pRoutingChar->pfnSetPower         = NULL;

    Trace0(LEAVE, "Leaving RegisterProtocol():\n");
    return NO_ERROR;

} //end _RegisterProtocol



//------------------------------------------------------------------------------
//        _StartProtocol
//
// Called after the _RegisterProtocol() API.
//    Initializes the data structures used by the protocol. However, the
//    protocol actually starts to run when it gets interface ownerships.
// Locks:
//    runs completely in g_CS.
// Return Value:
//    Error: if there is an error else NO_ERROR
//------------------------------------------------------------------------------

DWORD
WINAPI
StartProtocol(
    IN HANDLE               hRtmNotifyEvent,   //notify Rtm when protocol stopped
    IN PSUPPORT_FUNCTIONS   pSupportFunctions, //NULL
    IN PVOID                pGlobalConfig,
    IN ULONG                ulStructureVersion,
    IN ULONG                ulStructureSize,
    IN ULONG                ulStructureCount
    )
{
    WSADATA WsaData;
    DWORD   Error = NO_ERROR;
    BOOL    bErr;


    Trace0(ENTER, "Entering StartProtocol()");

    // make sure it is not an unsupported igmp version structure
    if (ulStructureVersion>=IGMP_CONFIG_VERSION_600) {
        Trace1(ERR, "Unsupported IGMP version structure: %0x",
            ulStructureVersion);
        IgmpAssertOnError(FALSE);
        return ERROR_CAN_NOT_COMPLETE;
    }
    
        
    // lock retained for entire initialization. so api_entry not required

    ACQUIRE_GLOBAL_LOCK("_StartProtocol");


    //
    // make certain igmp is not already running
    //
    if (g_RunningStatus != IGMP_STATUS_STOPPED) {

        Trace0(START,
            "Error: _StartProtocol called when Igmp is already running");
        Logwarn0(IGMP_ALREADY_STARTED, NO_ERROR);

        RELEASE_GLOBAL_LOCK("_StartProtocol");

        return ERROR_CAN_NOT_COMPLETE;
    }



    bErr = TRUE;

    BEGIN_BREAKOUT_BLOCK1 {

        // clear initialization flags set during and after _startProtocol

        g_Initialized &= DLL_STARTUP_FLAGS;


        // g_RunningStatus, g_CS, g_TraceId, g_LogHandle, g_RtmQueue,
        // g_Initialized & 0xFF000000 initialized in DllStartup/RegisterProtocol


        //
        // If start protocol has been called after a stop protocol.
        //

        if (!(g_Initialized & CLEAN_DLL_STARTUP)) {


            // destroy private heap, so that there is no memory leak.

            if (g_Heap != NULL) {
               HeapDestroy(g_Heap);
            }


            //
            // Reset the igmp global structure.
            // bugchk:make sure that all appropriate fields are being reset.
            //

            g_pIfTable = NULL;
            g_pGroupTable = NULL;
            ZeroMemory(&g_Config, sizeof(GLOBAL_CONFIG));
            g_Config.LoggingLevel = IGMP_LOGGING_WARN;
            ZeroMemory(&g_Info, sizeof(IGMP_GLOBAL_STATS));
            InitializeListHead(&g_ListOfSocketEvents);
            ZeroMemory(&g_SocketsRWLock, sizeof(READ_WRITE_LOCK));
            ZeroMemory(&g_EnumRWLock, sizeof(READ_WRITE_LOCK));
            ZeroMemory(&g_TimerStruct, sizeof(IGMP_TIMER_GLOBAL));
            g_MgmIgmprtrHandle = g_MgmProxyHandle = NULL;
            g_ProxyIfIndex = 0;
            g_pProxyIfEntry = NULL;
            ZeroMemory(&g_ProxyAlertCS, sizeof(CRITICAL_SECTION));
            InitializeListHead(&g_ProxyAlertsList);
            g_RasIfIndex = 0;
            g_pRasIfEntry = NULL;
            ZeroMemory(&g_DynamicCSStore, sizeof(DYNAMIC_LOCKS_STORE));
            ZeroMemory(&g_DynamicRWLStore, sizeof(DYNAMIC_LOCKS_STORE));
            g_ActivitySemaphore = NULL;
            g_ActivityCount = 0;
            g_RtmNotifyEvent = NULL;
            g_Heap = NULL;

            #ifdef MIB_DEBUG
            g_MibTraceId = 0;
            ZeroMemory(&g_MibTimer, sizeof(IGMP_TIMER_ENTRY));
            #endif


            // create private heap again.

            g_Heap = HeapCreate(0, 0, 0);

            if (g_Heap == NULL) {
                Error = GetLastError();
                Trace1(ANY, "error %d creating Igmp private heap", Error);
                GOTO_END_BLOCK1;
            }
        }


        // save the Router Manager notification event

        g_RtmNotifyEvent = hRtmNotifyEvent;



        //
        // set the Global Config (after making validation changes)
        //

        if(pGlobalConfig == NULL) {

            Trace0(ERR, "_StartProtocol: Called with NULL global config");
            IgmpAssertOnError(FALSE);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }
        {
            PIGMP_MIB_GLOBAL_CONFIG pGlobalConfigTmp;

            pGlobalConfigTmp = (PIGMP_MIB_GLOBAL_CONFIG) pGlobalConfig;


            // Check the global config, and correct if values are not correct.
            // Not a fatal error.

            if (! ValidateGlobalConfig(pGlobalConfigTmp)) {
                Error = ERROR_INVALID_PARAMETER;
                GOTO_END_BLOCK1;
            }

            g_Config.Version = pGlobalConfigTmp->Version;
            g_Config.LoggingLevel = pGlobalConfigTmp->LoggingLevel;
            g_Config.RasClientStats = 1;
        }



        //
        // The Global Stats are set to all 0 as it is a global variable.
        //



        //
        // Initialize Winsock version 2.0
        //
        Error = (DWORD)WSAStartup(MAKEWORD(2,0), &WsaData);

        if ( (Error!=0) || (LOBYTE(WsaData.wVersion)<2) ) {

            Trace1(ERR,
                 "StartProtocol: Error %d :could not initialize winsock v-2.0",
                 Error);
            IgmpAssertOnError(FALSE);
            Logerr0(WSASTARTUP_FAILED, Error);

            if (LOBYTE(WsaData.wVersion)<2)
                WSACleanup();

            GOTO_END_BLOCK1;
        }

        g_Initialized |= WINSOCK_INIT;


        //
        // initialize list of SocketEvents
        //
        InitializeListHead(&g_ListOfSocketEvents);

        Error = CreateReadWriteLock(&g_SocketsRWLock);
        if (Error!=NO_ERROR)
            GOTO_END_BLOCK1;

        Error = CreateReadWriteLock(&g_EnumRWLock);
        if (Error!=NO_ERROR)
            GOTO_END_BLOCK1;



        //
        // initialize the timer queues and other timer structures
        //
        Error = InitializeTimerGlobal();
        if (Error!=NO_ERROR)
            GOTO_END_BLOCK1;

        g_Initialized |= TIMER_GLOBAL_INIT;




        // Create Interface Table

        InitializeIfTable();

        g_Initialized |= IF_TABLE_INIT;



        // Create Group Table

        InitializeGroupTable();

        g_Initialized |= GROUP_TABLE_INIT;



        // proxy, ras interface already set to 0/NULL in global structure.
        InitializeListHead(&g_ProxyAlertsList);


        //
        // Initialise the Dynamic CS and ReadWrite locks main struct
        //

        Error = InitializeDynamicLocksStore(&g_DynamicCSStore);
        if (Error!=NO_ERROR)
            GOTO_END_BLOCK1;
        g_Initialized |= DYNAMIC_CS_LOCKS_INIT;

        Error = InitializeDynamicLocksStore(&g_DynamicRWLStore);
        if (Error!=NO_ERROR)
            GOTO_END_BLOCK1;
        g_Initialized |= DYNAMIC_RW_LOCKS_INIT;



        //
        // create the semaphore released by each thread when it is done
        // g_ActivityCount already set to 0.
        //

        g_ActivityCount = 0;

        g_ActivitySemaphore = CreateSemaphore(NULL, 0, 0xfffffff, NULL);

        if (g_ActivitySemaphore == NULL) {
            Error = GetLastError();
            Trace1(ERR, "error %d creating semaphore for Igmp threads", Error);
            IgmpAssertOnError(FALSE);
            Logerr0(CREATE_SEMAPHORE_FAILED, Error);
            GOTO_END_BLOCK1;
        }



        //
        // set the starting time for igmp. Should be done after global
        // timer and global Info struct are initialized
        //
        g_Info.TimeWhenRtrStarted.QuadPart = GetCurrentIgmpTime();



        // set igmp status to running

        g_RunningStatus = IGMP_STATUS_RUNNING;


        #ifdef MIB_DEBUG
        //
        // set delayed timer to display igmp's MIB tables periodically
        //

        g_MibTraceId = TraceRegisterEx("IGMPMIB", TRACE_USE_CONSOLE);

        if (g_MibTraceId != INVALID_TRACEID) {

            g_MibTimer.Context = NULL;
            g_MibTimer.Status = TIMER_STATUS_CREATED;
            g_MibTimer.Function = WT_MibDisplay;

            #if DEBUG_TIMER_TIMERID
                SET_TIMER_ID(&g_MibTimer, 910, 0, 0, 0);
            #endif

            ACQUIRE_TIMER_LOCK("_StartProtocol");
            InsertTimer(&g_MibTimer, 5000, TRUE, DBG_Y);
            RELEASE_TIMER_LOCK("_StartProtocol");
        }
        #endif //MIB_DEBUG



        //
        // register Igmp router with MGM. Proxy will be registered if there
        // is an active proxy interface.
        //
        Error = RegisterProtocolWithMgm(PROTO_IP_IGMP);


        // no error if I have reached here

        bErr = FALSE;

    } END_BREAKOUT_BLOCK1;


    if (bErr) {
        Trace1(START, "Igmp could not be started: %d", Error);
        ProtocolCleanup();
    }
    else {
        Trace0(START, "Igmp started successfully");
        Loginfo0(IGMP_STARTED, NO_ERROR);
    }

    g_DllHandle = LoadLibrary(TEXT("igmpv2.dll"));


    RELEASE_GLOBAL_LOCK("_StartProtocol()");


    Trace1(LEAVE, "Leaving StartProtocol():%d\n", Error);
    return (Error);

} //end StartProtocol



//------------------------------------------------------------------------------
//            _StartComplete
//
//------------------------------------------------------------------------------

DWORD
APIENTRY
StartComplete(
    VOID
    )
{
    return NO_ERROR;
}

//------------------------------------------------------------------------------
//            _StopProtocol
//
// sets the igmp status to stopping, marks the current number of active igmp
//    work items, and queues a worker that will wait till all those work items
//    have completed and then clean up igmp structures. This function returns
//    a pending status to the caller, while the queued work item will notify
//    the rtm after the cleanup has been done.
// Locking:
//    Runs completely in g_CS.
// Return Values:
//    ERROR_CAN_NOT_COMPLETE, PENDING.
// Queues:
//    _WF_FinishStopProtocol()
//------------------------------------------------------------------------------

DWORD
APIENTRY
StopProtocol(
    VOID
    )
{
    DWORD   dwThreadCount, Error=NO_ERROR;


    Trace0(ENTER, "entering _StopProtocol()");

    //debugCheck

    #if DEBUG_FLAGS_MEM_ALLOC
    // make sure that no interface timers exist
    #ifdef MIB_DEBUG
    if (g_TimerStruct.NumTimers>1)
    #else
    if (g_TimerStruct.NumTimers>0)
    #endif
    {
        IgmpAssert(FALSE);
        DbgPrint("Cleanup: some igmp timers still exist\n");
        DebugPrintTimerQueue();
    }
    // make sure that no groups exist
    DebugForcePrintGroupsList(ENSURE_EMPTY);
    #endif
    
    
    ACQUIRE_GLOBAL_LOCK("_StopProtocol");


    //
    // cannot stop if already stopped
    //
    if (g_RunningStatus != IGMP_STATUS_RUNNING) {

        Trace0(ERR, "Trying to stop Igmp when it is already being stopped");
        IgmpAssertOnError(FALSE);
        Logerr0(PROTO_ALREADY_STOPPING, NO_ERROR);
        Trace0(LEAVE, "Leaving _StopProtocol()\n");

        RELEASE_GLOBAL_LOCK("_StopProtocol");
        return ERROR_CAN_NOT_COMPLETE;
    }


    //
    // set Igmp's status to STOPPING;
    // this prevents any more work-items from being queued,
    // and it prevents the one's already queued from executing
    //

    InterlockedExchange(&g_RunningStatus, IGMP_STATUS_STOPPING);



    //
    // find out how many threads are active in Igmp;
    // we will have to wait for this many threads to exit
    // before we clean up Igmp's resources
    //

    dwThreadCount = g_ActivityCount;


    RELEASE_GLOBAL_LOCK("_StopProtocol");

    Trace0(LEAVE, "leaving _StopProtocol");


    //
    // QueueUserWorkItem that waits for all active Igmp threads and then
    // releases resources taken by this DLL.
    // Note: I dont use QueueIgmpWorker as that would increment the
    // ActivityCount.
    //

    QueueUserWorkItem(WF_FinishStopProtocol, (PVOID)(DWORD_PTR)dwThreadCount, 0);



    // Note: to be safe, there should be no code after QueueUserWorkItem


    return ERROR_PROTOCOL_STOP_PENDING;

} //end StopProtocol



DWORD
FreeLibraryThread(
    PVOID pvContext
    )
{
    FreeLibraryAndExitThread(g_DllHandle, 0);
    return 0;
}

//------------------------------------------------------------------------------
//        WF_FinishStopProtocol
//------------------------------------------------------------------------------
DWORD
WF_FinishStopProtocol(
    PVOID pContext    //dwThreadCount
    )
/*++
Routing Description:
    Waits for all the current active igmp work items to complete. Follows that
    by a call to ProtocolCleanup() to deregister and cleanup all igmp structures.
    In the end, notifies RtrManager that the protocol has stopped.
Queued by: _StopProtocol()
Calls: _ProtocolCleanup()
Locks: no locks required as all igmp threads have stopped.
--*/
{
    MESSAGE msg = {0, 0, 0};
    DWORD   dwThreadCount;
    DWORD   Error = NO_ERROR;

    Trace0(ENTER1, "entering _WF_FinishStopProtocol()");


    //
    // NOTE: since this is called while the router is stopping,
    // do not use EnterIgmpWorker()/LeaveIgmpWorker()
    //

    dwThreadCount = PtrToUlong(pContext);



    //
    // waits for API callers and worker functions to finish
    //
    while (dwThreadCount-- > 0) {

        Trace1(STOP, "%d threads active in Igmp", dwThreadCount+1);

        WaitForSingleObject(g_ActivitySemaphore, INFINITE);
    }



    // enter the critical section and leave, just to be sure that
    // all threads have quit their calls to LeaveIgmpWorker()

    ACQUIRE_GLOBAL_LOCK("_WF_FinishStopProtocol");
    RELEASE_GLOBAL_LOCK("_WF_FinishStopProtocol");



    Trace0(STOP, "all threads stopped. Cleaning up resources");



    //
    // This call deregisters with Wait-Server/MGM, and cleans up
    // all structures
    //
    ProtocolCleanup();



    Loginfo0(IGMP_STOPPED, NO_ERROR);


    //
    // notify Router Manager that protocol has been stopped
    //

    ACQUIRE_LIST_LOCK(&g_RtmQueue, "g_RtmQueue", "_WF_FinishStopProtocol");
    EnqueueEvent(&g_RtmQueue, ROUTER_STOPPED, msg);
    SetEvent(g_RtmNotifyEvent);
    RELEASE_LIST_LOCK(&g_RtmQueue, "g_RtmQueue", "_WF_FinishStopProtocol");


    Trace0(LEAVE1, "Leaving _WF_FinishStopProtocol()");
    
    if (g_DllHandle) {
        HANDLE h_Thread;
        h_Thread = CreateThread(0,0,FreeLibraryThread, NULL, 0, NULL);
        if (h_Thread != NULL)
            CloseHandle(h_Thread);
    }

    return 0;

} //end _WF_FinishStopProtocol


//------------------------------------------------------------------------------
//            _ProtocolCleanup
//
// All active igmp work items have completed before this procedure is called.
// So it is safe to deregister with Wait-Server, and deregister all interfaces/
// RAS clients and Igmp router/proxy protocol with MGM. Then, all the structures
// are cleaned up.
//
// Called by:
//    _WF_FinishStopProtocol() and _StartProtocol()
// Locks:
//    No locks required as no api can enter when g_RunningStatus set to stopping.
//------------------------------------------------------------------------------

VOID
ProtocolCleanup(
    )
{
    DWORD   Error = NO_ERROR;

    Trace0(ENTER1, "entering _ProtocolCleanup()");


    //
    // Deregister Igmp Router from MGM. Proxy is deregistered if required in
    // _DeinitializeIfTable
    //
    if (g_MgmIgmprtrHandle!=NULL) {

        Error = MgmDeRegisterMProtocol(g_MgmIgmprtrHandle);
        Trace1(MGM, "_MgmDeRegisterMProtocol(Igmp): returned %d", Error);
    }



    // deregister Mib display

    #ifdef MIB_DEBUG
    if (g_MibTraceId != INVALID_TRACEID)
        TraceDeregister(g_MibTraceId);
    #endif



    // close activity semaphore

    if (g_ActivitySemaphore != NULL) {

       CloseHandle(g_ActivitySemaphore);
       g_ActivitySemaphore = NULL;
    }



    // DeInitialise the Dynamic CS and ReadWrite locks main struct

    if (g_Initialized&DYNAMIC_RW_LOCKS_INIT)
        DeInitializeDynamicLocksStore(&g_DynamicRWLStore, LOCK_TYPE_RW);

    if (g_Initialized&DYNAMIC_CS_LOCKS_INIT)
        DeInitializeDynamicLocksStore(&g_DynamicCSStore, LOCK_TYPE_CS);



    // DeInitialize the group table. Delete the group bucket locks.

    if (g_Initialized & GROUP_TABLE_INIT)
        DeInitializeGroupTable();



    // DeInitialize InterfaceTable. This call also deregister all interfaces &
    // ras clients from MGM

    if (g_Initialized & IF_TABLE_INIT)
        DeInitializeIfTable();



    // DeInitialize the global timer. Deletes the timer critical-section.

    if (g_Initialized&TIMER_GLOBAL_INIT)
        DeInitializeTimerGlobal();



    //
    // delete sockets events and deregister them from wait thread.
    // delete sockets read-write lock
    //
    {
        PLIST_ENTRY         pHead, ple;
        PSOCKET_EVENT_ENTRY psee;
        HANDLE              WaitHandle;

        pHead = &g_ListOfSocketEvents;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            psee = CONTAINING_RECORD(ple,SOCKET_EVENT_ENTRY,LinkBySocketEvents);
            if (psee->InputWaitEvent) {
                WaitHandle = InterlockedExchangePointer(&psee->InputWaitEvent, NULL);

                if (WaitHandle)
                    UnregisterWaitEx( WaitHandle, NULL ) ;

            }
            CloseHandle(psee->InputEvent);
        }

        DeleteReadWriteLock(&g_SocketsRWLock);
        DeleteCriticalSection(&g_ProxyAlertCS);
        DeleteReadWriteLock(&g_EnumRWLock);
    }



    // deinitialize winsock

    if (g_Initialized & WINSOCK_INIT) {
        WSACleanup();
    }



    // Mark that _StopProtocol has been called once.
    // If _StartProtocol is called again, igmp will have to Destroy/Create
    // private heap and ZeroMemory parts of igmp global struct.

    g_Initialized &= ~CLEAN_DLL_STARTUP;
    
    Trace0(LEAVE1, "leaving _ProtocolCleanup()");
    return;

} //end _ProtocolCleanup



//------------------------------------------------------------------------------
//          DebugPrintGlobalConfig
//------------------------------------------------------------------------------
VOID
DebugPrintGlobalConfig (
    PIGMP_MIB_GLOBAL_CONFIG pConfigExt
    )
{    
    Trace0(CONFIG, "Printing Global Config");
    Trace1(CONFIG, "Version:                    0x%x", pConfigExt->Version);
    Trace1(CONFIG, "LoggingLevel:               %x\n", pConfigExt->LoggingLevel);
}

//------------------------------------------------------------------------------
//        GetGlobalInfo
//
// Return Values: ERROR_CAN_NOT_COMPLETE, ERROR_INVALID_DATA, NO_ERROR
//------------------------------------------------------------------------------

DWORD
WINAPI
GetGlobalInfo(
    IN OUT PVOID    pvConfig,
    IN OUT PDWORD   pdwSize,
    IN OUT PULONG   pulStructureVersion,
    IN OUT PULONG   pulStructureSize,
    IN OUT PULONG   pulStructureCount
    )
{

    DWORD                       Error=NO_ERROR, dwSize;
    PIGMP_MIB_GLOBAL_CONFIG     pGlobalConfig;


    Trace2(ENTER1, "entering GetGlobalInfo(): pvConfig(%08x) pdwSize(%08x)",
                pvConfig, pdwSize);
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }



    BEGIN_BREAKOUT_BLOCK1 {

        //
        // check the buffer size and set to global config
        //

        if (pdwSize == NULL) {
             Error = ERROR_INVALID_PARAMETER;
             GOTO_END_BLOCK1;
        }

        if ( (*pdwSize < sizeof(IGMP_MIB_GLOBAL_CONFIG)) || (pvConfig==NULL) ) {
             Error = ERROR_INSUFFICIENT_BUFFER;
        }
        else {

            pGlobalConfig = (PIGMP_MIB_GLOBAL_CONFIG) pvConfig;

            pGlobalConfig->Version = g_Config.Version;
            
            pGlobalConfig->LoggingLevel = g_Config.LoggingLevel;

            pGlobalConfig->RasClientStats = g_Config.RasClientStats;
        }

        *pdwSize = sizeof(IGMP_MIB_GLOBAL_CONFIG);


    } END_BREAKOUT_BLOCK1;


    if (pulStructureCount)
        *pulStructureCount = 1;
    if (pulStructureSize && pdwSize)
        *pulStructureSize = *pdwSize;
    if (pulStructureVersion)
        *pulStructureVersion = IGMP_CONFIG_VERSION_500;
    
    Trace1(LEAVE1, "Leaving GetGlobalInfo(): %d\n", Error);
    LeaveIgmpApi();
    return Error;
}


//------------------------------------------------------------------------------
//            SetGlobalInfo
// Return Values: ERROR_CAN_NOT_COMPLETE, ERROR_INVALID_PARAMETER,
//                ERROR_INVALID_DATA, NO_ERROR
//------------------------------------------------------------------------------

DWORD
WINAPI
SetGlobalInfo(
    IN PVOID pvConfig,
    IN ULONG ulStructureVersion,
    IN ULONG ulStructureSize,
    IN ULONG ulStructureCount
    )
{
    DWORD                   Error=NO_ERROR, dwSize;
    PIGMP_MIB_GLOBAL_CONFIG pConfigSrc;
    BOOL                    bValid;
    

    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }


    // make sure it is not an unsupported igmp version structure
    if (ulStructureVersion>=IGMP_CONFIG_VERSION_600) {
        Trace1(ERR, "Unsupported IGMP version structure: %0x",
            ulStructureVersion);
        IgmpAssertOnError(FALSE);
        LeaveIgmpApi();
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    Trace1(ENTER, "entering SetGlobalInfo: pvConfig(%08x)", pvConfig);

    ASSERT(ulStructureSize == sizeof(IGMP_MIB_GLOBAL_CONFIG));
        
    BEGIN_BREAKOUT_BLOCK1 {

        if (pvConfig == NULL) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        pConfigSrc = (PIGMP_MIB_GLOBAL_CONFIG) pvConfig;


        // validate global config.

        bValid = ValidateGlobalConfig(pConfigSrc);
        if (!bValid) {
            Error = ERROR_INVALID_DATA;
            GOTO_END_BLOCK1;
        }



        // copy from the buffer

        InterlockedExchange(&g_Config.RasClientStats,
                                pConfigSrc->RasClientStats);
        InterlockedExchange(&g_Config.LoggingLevel,
                                pConfigSrc->LoggingLevel);

    } END_BREAKOUT_BLOCK1;


    Trace1(LEAVE, "leaving SetGlobalInfo(): %d\n", Error);
    LeaveIgmpApi();
    return Error;
}


//------------------------------------------------------------------------------
//          ValidateGlobalConfig
//
// validates the global config info. If values are not valid, then sets them to
// some default values.
//
// Return Values:
//    TRUE: if the global config values are valid.
//    FALSE: if the global config values are not valid. sets default values.
//------------------------------------------------------------------------------

BOOL
ValidateGlobalConfig(
    PIGMP_MIB_GLOBAL_CONFIG pGlobalConfig
    )
{
    DebugPrintGlobalConfig(pGlobalConfig);

    
    // check version

    if (pGlobalConfig->Version>=IGMP_VERSION_3_5) {

        Trace1(ERR, "Invalid version in global config.\n"
            "Create the Igmp configuration again", pGlobalConfig->Version);
        IgmpAssertOnError(FALSE);
        Logerr0(INVALID_VERSION, ERROR_INVALID_DATA);
        return FALSE;
    }

    
    // check loggingLevel

    switch (pGlobalConfig->LoggingLevel) {
        case IGMP_LOGGING_NONE :
        case IGMP_LOGGING_ERROR :
        case IGMP_LOGGING_WARN :
        case IGMP_LOGGING_INFO :
            break;

        default :
            pGlobalConfig->LoggingLevel = IGMP_LOGGING_WARN;
            return FALSE;
    }


    // check RasClientStats value

    if ((pGlobalConfig->RasClientStats!=0)&&(pGlobalConfig->RasClientStats!=1)){
        pGlobalConfig->RasClientStats = 0;
        return FALSE;
    }


    return TRUE;
}



//----------------------------------------------------------------------------
//        GetEventMessage
//
// This is called by the IP Router Manager if we indicate that we have
//      a message in our queue to be delivered to it (by setting the
//      g_RtmNotifyEvent)
//  Return Value
//      NO_ERROR
//----------------------------------------------------------------------------

DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT PMESSAGE                pResult
    )
{
    DWORD Error;

    //
    // Note: _GetEventMessage() does not use the
    // EnterIgmpApi()/LeaveIgmpApi() mechanism,
    // since it may be called after Igmp has stopped, when the
    // Router Manager is retrieving the ROUTER_STOPPED message
    //

    Trace2(ENTER, "entering _GetEventMessage: pEvent(%08x) pResult(%08x)",
                pEvent, pResult);



    ACQUIRE_LIST_LOCK(&g_RtmQueue, "RtmQueue", "_GetEventMessage");

    Error = DequeueEvent(&g_RtmQueue, pEvent, pResult);

    RELEASE_LIST_LOCK(&g_RtmQueue, "RtmQueue", "_GetEventMessage");



    Trace1(LEAVE, "leaving _GetEventMessage: %d\n", Error);

    return Error;
}


//----------------------------------------------------------------------------
// Function:    EnqueueEvent
//
// This function adds an entry to the end of the queue of
// Router Manager events. It assumes the queue is locked.
//----------------------------------------------------------------------------
DWORD
EnqueueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS EventType,
    MESSAGE Msg
    ) {


    DWORD       Error;
    PLIST_ENTRY phead;
    PEVENT_QUEUE_ENTRY peqe;


    phead = &pQueue->Link;

    peqe = IGMP_ALLOC(sizeof(EVENT_QUEUE_ENTRY), 0x1, 0);
    PROCESS_ALLOC_FAILURE2(peqe,
            "error %d allocating %d bytes for event queue entry",
            Error, sizeof(EVENT_QUEUE_ENTRY),
            return Error);

    peqe->EventType = EventType;
    peqe->Msg = Msg;

    InsertTailList(phead, &peqe->Link);

    return NO_ERROR;
}


//------------------------------------------------------------------------------
// Function:    DequeueEvent
//
// This function removes an entry from the head of the queue
// of Router Manager events. It assumes the queue is locked
//------------------------------------------------------------------------------
DWORD
DequeueEvent(
    PLOCKED_LIST pQueue,
    ROUTING_PROTOCOL_EVENTS *pEventType,
    PMESSAGE pMsg
    ) {

    PLIST_ENTRY phead, ple;
    PEVENT_QUEUE_ENTRY peqe;

    phead = &pQueue->Link;
    if (IsListEmpty(phead)) {
        return ERROR_NO_MORE_ITEMS;
    }

    ple = RemoveHeadList(phead);
    peqe = CONTAINING_RECORD(ple, EVENT_QUEUE_ENTRY, Link);

    *pEventType = peqe->EventType;
    *pMsg = peqe->Msg;

    IGMP_FREE(peqe);

    return NO_ERROR;
}

//------------------------------------------------------------------------------
//        GetNeighbors
// Return Values: ERROR_INSUFFICIENT_BUFFER, NO_ERROR
//------------------------------------------------------------------------------
DWORD
APIENTRY
GetNeighbors(
    IN     DWORD  dwInterfaceIndex,
    IN     PDWORD pdwNeighborList,
    IN OUT PDWORD pdwNeighborListSize,
       OUT PBYTE  pbInterfaceFlags
    )
{
   PIF_TABLE_ENTRY pite = GetIfByIndex(dwInterfaceIndex);

   if (IS_QUERIER(pite)) {
      *pbInterfaceFlags |= MRINFO_QUERIER_FLAG;
      *pdwNeighborListSize = 0;
   }

   else {
      if (*pdwNeighborListSize < 4)
         return ERROR_INSUFFICIENT_BUFFER;

      *pdwNeighborListSize = 4;
      *pdwNeighborList = pite->Info.QuerierIpAddr;
   }

   return NO_ERROR; // no neighbors
}


//-------------------------------------------------------------------------
//        GetMfeStatus
//
// set statusCode to MFE_OIF_PRUNED if the GroupAddr Mcast group is not
// joined on the interface, else set it to MFE_NO_ERROR
//-------------------------------------------------------------------------

DWORD
APIENTRY
GetMfeStatus(
    IN     DWORD  IfIndex,
    IN     DWORD  GroupAddr,
    IN     DWORD  SourceAddr,
    OUT    PBYTE  StatusCode
    )
{
    PIF_TABLE_ENTRY     pite;
    PGROUP_TABLE_ENTRY  pge;
    PGI_ENTRY           pgie;


    // by default, set code to group not found on the interface.
    // if found, set it to MFE_NO_ERROR later on.

    *StatusCode = MFE_OIF_PRUNED;


    ACQUIRE_IF_LOCK_SHARED(IfIndex, "_GetMfeStatus");

    pite = GetIfByIndex(IfIndex);
    if (pite!=NULL) {

        ACQUIRE_GROUP_LOCK(GroupAddr, "_GetMfeStatus");
        pge = GetGroupFromGroupTable(GroupAddr, NULL, 0);
        if (pge!=NULL) {
            pgie = GetGIFromGIList(pge, pite, 0, ANY_GROUP_TYPE, NULL, 0);
            if (pgie!=NULL)
                *StatusCode = MFE_NO_ERROR;
        }
        RELEASE_GROUP_LOCK(GroupAddr, "_GetMfeStatus");
    }

    RELEASE_IF_LOCK_SHARED(IfIndex, "_GetMfeStatus");

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\if.h ===
#ifndef _IGMP_IF_H_
#define _IGMP_IF_H_

//=============================================================================
//
// Copyright (c) 1997 Microsoft Corporation
//
// File Name: If.h
//
// Abstract:
//      This file contains declarations for if.c
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//
//=============================================================================

//
// API PROTOTYPES
//
DWORD
WINAPI
AddInterface(
    IN PWCHAR               pwszInterfaceName,//not used
    IN ULONG                IfIndex,
    IN NET_INTERFACE_TYPE   dwIfType,
    IN DWORD                dwMediaType,
    IN WORD                 wAccessType,
    IN WORD                 wConnectionType,
    IN PVOID                pvConfig,
    IN ULONG                ulStructureVersion,
    IN ULONG                ulStructureSize,
    IN ULONG                ulStructureCount
    );

DWORD
WINAPI
DeleteInterface(
    IN DWORD IfIndex
    );  

DWORD
WINAPI
ConnectRasClient (
    DWORD       IfIndex,
    PVOID       pvNHAddr 
    );
    
DWORD
WINAPI
DisconnectRasClient (
    DWORD       IfIndex,
    PVOID       pvNHAddr
    );

DWORD
WINAPI
SetInterfaceConfigInfo(
    IN DWORD IfIndex,
    IN PVOID pvConfig,
    IN ULONG ulStructureVersion,
    IN ULONG ulStructureSize,
    IN ULONG ulStructureCount
    );


DWORD
WINAPI
GetInterfaceConfigInfo(
    IN     DWORD  IfIndex,
    IN OUT PVOID  pvConfig,
    IN OUT PDWORD pdwSize,
    IN OUT PULONG pulStructureVersion,
    IN OUT PULONG pulStructureSize,
    IN OUT PULONG pulStructureCount
    );
    
DWORD
WINAPI
InterfaceStatus(
    ULONG IfIndex,
    BOOL  bIfActive,
    DWORD dwStatusType,
    PVOID pvStatusInfo
    );

DWORD
WINAPI
IgmpMibIfConfigSize(
    PIGMP_MIB_IF_CONFIG pConfig
    );

//
// EXPORTED PROTOTYPES
//

VOID
CompleteIfDeletion (
    PIF_TABLE_ENTRY     pite
    );

DWORD
ActivateInterface (
    PIF_TABLE_ENTRY     pite
    );
    
VOID
DeActivateInterfaceComplete (
    PIF_TABLE_ENTRY     pite
    );

DWORD
CreateRasClient (
    PIF_TABLE_ENTRY     pite,      
    PRAS_TABLE_ENTRY   *prteNew,
    DWORD               NHAddr
    );

//
// INTERNAL PROTOTYPES
//

DWORD
BindInterface(
    IN DWORD IfIndex,
    IN PVOID pBinding
    );

DWORD
UnBindInterface(
    IN DWORD IfIndex
    );

DWORD
EnableInterface(
    IN DWORD IfIndex
    );

DWORD
DisableInterface(
    IN DWORD IfIndex
    );
    
DWORD
AddIfEntry(
    DWORD IfIndex,
    NET_INTERFACE_TYPE dwIfType,
    PIGMP_MIB_IF_CONFIG pConfig,
    ULONG ulStructureVersion,
    ULONG ulStructureSize    
    );
    
DWORD
DeleteIfEntry (
    PIF_TABLE_ENTRY pite
    );
    
DWORD
BindIfEntry(
    DWORD IfIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    );

DWORD
UnBindIfEntry(
    DWORD IfIndex
    );

DWORD
EnableIfEntry(
    DWORD IfIndex,
    BOOL  bChangedByRtrmgr // changed by rtrmgr or by SetInterfaceConfigInfo
    );

DWORD
DisableIfEntry(
    DWORD IfIndex,
    BOOL  bChangedByRtrmgr // changed by rtrmgr or by SetInterfaceConfigInfo
    );

DWORD
ProcessIfProtocolChange(
    DWORD               IfIndex,
    PIGMP_MIB_IF_CONFIG pConfigSrc
    );

DWORD
DeActivationDeregisterFromMgm(
    PIF_TABLE_ENTRY pite
    );

#endif // _IGMP_IF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\sources.inc ===
SOURCES_USED=..\sources.inc
TARGETPATH=obj
TARGETTYPE=DRIVER

FWPF=-DFWPF=1 -DSYNCHECK_ENABLED=0 -DLOOKUPROUTE=1 -DWILDHASH=1

C_DEFINES=$(C_DEFINES) -D_NTDRIVER_ -DNT -DFWPF=1 -DSTEELHEAD=0 $(FWPF)
USE_MSVCRT=1

TARGETLIBS=\
           $(DDK_LIB_PATH)\tcpip.lib \
           $(DDK_LIB_PATH)\ndis.lib \

INCLUDES=..\..\..\inc;$(BASE_INC_PATH)

SOURCES=\
    ..\driver.c \
    ..\ioctl.c \
    ..\ipfltdrv.rc \
    ..\logger.c \
    ..\match.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\if.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// Module Name: If.c
//
// Abstract:
//      This module implements some of the Igmp API's related with interfaces.
//      _AddInterface, _DeleteInterface, _EnableInterface, _DisableInterface,
//      _BindInterface, _UnbindInterface, _ConnectRasClient, _DisconectRasClient,
//      _SetInterfaceConfigInfo, _GetInterfaceConfigInfo.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//=============================================================================


#include "pchigmp.h"
#pragma hdrstop



//------------------------------------------------------------------------------
//          _AddInterface
//
// This api is called to add an interface to Igmp. The interface can be a Proxy
// or an Igmp router(v1/v2). Further, the interface can be a RAS or DemandDial
// or a Permanent interface. This routine creates the interface entry and 
// associated structures including timers.
//
// Locks: Runs completely in ListLock and ExclusiveIfLock.
// Calls: _AddIfEntry()
// Return Values: ERROR_CAN_NOT_COMPLETE, Error, NO_ERROR.
//------------------------------------------------------------------------------
DWORD
WINAPI
AddInterface(
    IN PWCHAR               pwszInterfaceName,//not used
    IN ULONG                IfIndex,
    IN NET_INTERFACE_TYPE   dwIfType,
    IN DWORD                dwMediaType,
    IN WORD                 wAccessType,
    IN WORD                 wConnectionType,
    IN PVOID                pvConfig,
    IN ULONG                ulStructureVersion,
    IN ULONG                ulStructureSize,
    IN ULONG                ulStructureCount
    )
{
    DWORD   Error=NO_ERROR;
    CHAR    str[60];

    
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    // make sure it is not an unsupported igmp version structure
    if (ulStructureVersion>=IGMP_CONFIG_VERSION_600) {
        Trace1(ERR, "Unsupported IGMP version structure: %0x",
            ulStructureVersion);
        IgmpAssertOnError(FALSE);
        LeaveIgmpApi();
        return ERROR_CAN_NOT_COMPLETE;
    }

    switch (dwIfType) {
        case PERMANENT: //lan
            lstrcpy(str, "PERMANENT(IGMP_IF_NOT_RAS)"); break;
        case DEMAND_DIAL: 
            lstrcpy(str, "DEMAND_DIAL(IGMP_IF_RAS_ROUTER)");break;
        case LOCAL_WORKSTATION_DIAL: 
            lstrcpy(str, "LOCAL_WORKSTATION_DIAL(IGMP_IF_RAS_SERVER)"); break;
    }
    
    Trace2(ENTER, "entering AddInterface(): IfIndex:%0x IfType:%s", 
            IfIndex, str);



    // entire procedure runs in IfListLock and exclusive IfLock.

    ACQUIRE_IF_LIST_LOCK("_AddInterface");
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_AddInterface");

    
    //
    // create the interface entry
    //
    Error = AddIfEntry(IfIndex, dwIfType, (PIGMP_MIB_IF_CONFIG)pvConfig,
                ulStructureVersion, ulStructureSize
                );



    RELEASE_IF_LIST_LOCK("_AddInterface");
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_AddInterface");

    Trace2(LEAVE1, "leaving AddInterface(%0x): %d\n", IfIndex, Error);
    if (Error!=NO_ERROR) {
        Trace1(ERR, "Error adding interface:%0x to IGMP\n", IfIndex);
        IgmpAssertOnError(FALSE);
    }        
    LeaveIgmpApi();
    return Error;
}



//------------------------------------------------------------------------------
//          _AddIfEntry
//
// Creates and initializes a new interface entry and associated data structures.
//
// Called by: _AddInterface().
// Locks: Assumes IfListLock and exclusive IfLock throughout.
//------------------------------------------------------------------------------
DWORD
AddIfEntry(
    DWORD               IfIndex,
    NET_INTERFACE_TYPE  dwExternalIfType,
    PIGMP_MIB_IF_CONFIG pConfigExt,
    ULONG               ulStructureVersion,
    ULONG               ulStructureSize
    )
{
    DWORD               Error = NO_ERROR, IfType;
    PIF_TABLE_ENTRY     pite = NULL;
    PLIST_ENTRY         ple, phead;
    PIGMP_IF_TABLE      pIfTable = g_pIfTable;
    BOOL                bProxy;
    
    

    BEGIN_BREAKOUT_BLOCK1 {
    
        //
        // fail if the interface exists.
        //
        pite = GetIfByIndex(IfIndex);

        if (pite != NULL) {
            Trace1(ERR, "interface %0x already exists", IfIndex);
            IgmpAssertOnError(FALSE);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }

        // convert iftype to igmp iftype
        
        switch (dwExternalIfType) {
        
            case PERMANENT : 
                IfType = IGMP_IF_NOT_RAS;
                break;
            
            case DEMAND_DIAL:
                IfType = IGMP_IF_RAS_ROUTER;
                break;
                
            case LOCAL_WORKSTATION_DIAL:
            {
                IfType = IGMP_IF_RAS_SERVER;


                // currently there can be at most one ras table entry
                
                if (g_RasIfIndex!=0) {
                    Trace2(ERR, 
                        "Error. Cannot have more than one ras server IF(%0x:%0x)",
                        g_RasIfIndex, IfIndex
                        );
                    IgmpAssertOnError(FALSE);
                    Error = ERROR_CAN_NOT_COMPLETE;
                    Logerr0(RAS_IF_EXISTS, Error);
                    GOTO_END_BLOCK1;
                }
                
                break;
            }
            
            case REMOTE_WORKSTATION_DIAL :
                Error = ERROR_INVALID_PARAMETER;
                break;

            default :
                Error = ERROR_INVALID_PARAMETER;
                break;

        } //end switch (IfType)

        
        // Validate the interface config

        Error = ValidateIfConfig(pConfigExt, IfIndex, IfType, 
                    ulStructureVersion, ulStructureSize
                    );
        if (Error!=NO_ERROR)
            GOTO_END_BLOCK1;


        //
        // allocate memory for the new interface and Zero it.
        // Fields that are to be initialized to 0 or NULL are commented out.
        //
        pite = IGMP_ALLOC(sizeof(IF_TABLE_ENTRY), 0x2, IfIndex);
        PROCESS_ALLOC_FAILURE3(pite, 
                "error %d allocating %d bytes for interface %0x", Error, 
                sizeof(IF_TABLE_ENTRY), IfIndex, 
                GOTO_END_BLOCK1);
        Trace2(CONFIG, "IfEntry %0x for IfIndex:%0x", (ULONG_PTR)pite, IfIndex);

        ZeroMemory(pite, sizeof(IF_TABLE_ENTRY));

        
        //
        // set the interface type
        //
        pite->IfType = (UCHAR)IfType;


        //
        // if proxy, make sure that a proxy interface does not already exist
        //
        if ( IS_CONFIG_IGMPPROXY(pConfigExt) ){

            bProxy = TRUE;


            //
            // multiple proxy interfaces cannot exist
            //
            if (g_ProxyIfIndex!=0) {
                
                Error =  ERROR_CAN_NOT_COMPLETE;
                Trace1(IF, "Cannot create multiple proxy interfaces. "
                        "If %d is Proxy",  g_ProxyIfIndex);
                Logerr0(PROXY_IF_EXISTS, Error);
                
                GOTO_END_BLOCK1;
            }
        } 
        
        else  {
            bProxy = FALSE;
        }

    } END_BREAKOUT_BLOCK1;
            
    
    if (Error != NO_ERROR) {
        IGMP_FREE_NOT_NULL(pite);
        
        return Error;
    }


    //
    // initialize fields for the interface
    //
    InitializeListHead(&pite->LinkByAddr);
    InitializeListHead(&pite->LinkByIndex);
    InitializeListHead(&pite->HTLinkByIndex);
    InitializeListHead(&pite->ListOfSameIfGroups);
    InitializeListHead(&pite->ListOfSameIfGroupsNew);
    InitializeListHead(&pite->Config.ListOfStaticGroups);
    //pite->NumGIEntriesInNewList = 0;


    // IfType already set before
    
    pite->IfIndex = IfIndex;


    // Ip addr set when interface is bound
    //pite->IpAddr = 0; 


    // set interface status (neither bound, enabled or activated)
    pite->Status = IF_CREATED_FLAG;



    // copy the interface config

    CopyinIfConfig(&pite->Config, pConfigExt, IfIndex);



    // initialize the Info struct, and If bindings to 0/NULL
    //pite->pBinding = NULL;
    //ZeroMemory(&pite->Info, sizeof(IF_INFO));
    


    //
    // Create RAS table if it is a RAS server interface
    //
    if ( IS_RAS_SERVER_IF(pite->IfType)) {
        InitializeRasTable(IfIndex, pite);
    }
    else {
        //pite->pRasTable = NULL;
    }



    //
    // initialize the sockets to invalid_socket
    //
    pite->SocketEntry.Socket = INVALID_SOCKET;
    pite->SocketEntry.pSocketEventsEntry = NULL;
    InitializeListHead(&pite->SocketEntry.LinkByInterfaces);
    
    
    
    // set (non)query timer to not created. 
    //Other fields set in activate interface.
    //pite->QueryTimer.Status = 0;
    //pite->NonQueryTimer.Status = 0;

    
    //pite->pPrevIfGroupEnumPtr = NULL;
    //pite->PrevIfGroupEnumSignature = 0;
    pite->StaticGroupSocket = INVALID_SOCKET;
    


    //  insert the interface in the hash table at the end.

    InsertTailList(&pIfTable->HashTableByIndex[IF_HASH_VALUE(IfIndex)],
                    &pite->HTLinkByIndex);


    //
    // insert the interface into the list ordered by index
    //
    {
        PIF_TABLE_ENTRY piteTmp;
        
        phead = &pIfTable->ListByIndex;
        for (ple=phead->Flink;  ple!=phead;  ple=ple->Flink) {

            piteTmp = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, LinkByIndex);
            if (pite->IfIndex < piteTmp->IfIndex) 
                break;
        }
    }
    
    InsertTailList(ple, &pite->LinkByIndex);



    // changes to the interface table fields.

    pIfTable->NumInterfaces++;



    // the interface will be inserted into list ordered by IpAddr
    // when it is activated.



    //
    // create proxy HT, and set proxy info in global structure.
    //
    if (bProxy) {
    
        DWORD   dwSize = PROXY_HASH_TABLE_SZ * sizeof(LIST_ENTRY);
        DWORD   i;
        PLIST_ENTRY pProxyHashTable;
        

        BEGIN_BREAKOUT_BLOCK2 {
        
            pProxyHashTable = pite->pProxyHashTable = IGMP_ALLOC(dwSize, 0x4, 
                                                                IfIndex);

            PROCESS_ALLOC_FAILURE2(pProxyHashTable, 
                    "error %d allocating %d bytes for interface table",
                    Error, dwSize, GOTO_END_BLOCK2);

            for (i=0;  i<PROXY_HASH_TABLE_SZ;  i++) {
                InitializeListHead(pProxyHashTable+i);
            }


            InterlockedExchangePointer(&g_pProxyIfEntry, pite);
            InterlockedExchange(&g_ProxyIfIndex, IfIndex);

            pite->CreationFlags |= CREATED_PROXY_HASH_TABLE;

        } END_BREAKOUT_BLOCK2;
    }


    //
    // set ras info in global structure. Ras table already created before.
    //
    if (IS_RAS_SERVER_IF(pite->IfType)) {
        InterlockedExchangePointer(&g_pRasIfEntry, pite);
        InterlockedExchange(&g_RasIfIndex, IfIndex);
    }


    if ( (Error!=NO_ERROR)&&(pite!=NULL) )
        DeleteIfEntry(pite);

        
    return Error;
    
} //end _AddIfEntry




//------------------------------------------------------------------------------
//          _DeleteInterface
//
// Deletes the interface, deactivating if it is activated.
//
// Calls: _DeleteIfEntry()
// Locks: Exclusive SocketsLock, IfListLock, Exclusive IfLock
//------------------------------------------------------------------------------
DWORD
DeleteInterface(
    IN DWORD IfIndex
    )
{
    DWORD            Error = NO_ERROR;
    PIF_TABLE_ENTRY  pite = NULL;


    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    Trace1(ENTER, "entering DeleteInterface: %0x", IfIndex);


    //
    // acquire exclusive SocketsLock, IfListLock, Exclusive IfLock
    //
    ACQUIRE_SOCKETS_LOCK_EXCLUSIVE("_DeleteInterface");
    ACQUIRE_IF_LIST_LOCK("_DeleteInterface");
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_DeleteInterface");


    
    // retrieve the interface specified

    pite = GetIfByIndex(IfIndex);

    if (pite == NULL) {
        Trace1(ERR,
            "_DeleteInterface() called for non existing interface(%0x)", IfIndex);
        IgmpAssertOnError(FALSE);
        Error = ERROR_INVALID_PARAMETER;
    }

    // delete the interface if found.
    else {
    
        Error = DeleteIfEntry(pite);

        //DebugCheck deldel remove #if dbg
        #if DBG
            DebugScanMemoryInterface(IfIndex);
        #endif
    }
    

    RELEASE_SOCKETS_LOCK_EXCLUSIVE("_DeleteInterface");
    RELEASE_IF_LIST_LOCK("_DeleteInterface");
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_DeleteInterface");

    Trace2(LEAVE, "Leaving DeleteInterface(%0x): %d\n", IfIndex, Error);

    LeaveIgmpApi();

    return NO_ERROR;
}



//------------------------------------------------------------------------------
//          _DeleteIfEntry
//
// Assumes exclusive IF lock. Marks the interface as deleted, and removes it
// from all global lists. Then queues a work item to do a lazy delete of 
// the Interface structures without having to take the exclusive IF lock.
// If Ras interface, the work item will delete the Ras clients also.
//
// Called by: _DeleteInterface() or _AddIfEntry()
// Calls: 
//    _WF_CompleteIfDeactivateDelete (this calls _DeActivateInterfaceComplete())
// Lock:
//    runs in exclusive SocketLock, IfListLock, exclusive IfLock
//------------------------------------------------------------------------------

DWORD
DeleteIfEntry (
    PIF_TABLE_ENTRY pite
    )
{
    DWORD   dwRetval, Error = NO_ERROR;
    BOOL    bProxy = IS_PROTOCOL_TYPE_PROXY(pite);


    //
    // Set deleted flag for the interface
    //
    pite->Status |= DELETED_FLAG;


    //
    // remove the interface from the InterfaceHashTable and IfIndex lists.
    //
    RemoveEntryList(&pite->LinkByIndex);
    RemoveEntryList(&pite->HTLinkByIndex);


    //
    // if activated, remove the interface from the list of activated interfaces
    // and if proxy or ras server, remove from global table.
    //

    // do not replace the below with IS_IF_ACTIVATED, as deleted flag is set
    if (pite->Status&IF_ACTIVATED_FLAG)
        RemoveEntryList(&pite->LinkByAddr);
    
    if (bProxy) {
        InterlockedExchangePointer(&g_pProxyIfEntry, NULL);
        InterlockedExchange(&g_ProxyIfIndex, 0);        
    }
    
    if (g_pRasIfEntry == pite) {
        InterlockedExchangePointer(&g_pRasIfEntry, NULL);
        InterlockedExchange(&g_RasIfIndex, 0);
    }

    
    //
    // From now on, the interface cannot be accessed from any global list
    // and  is as good as deleted. The only way it can be accessed is 
    // through group list enumeration and timers getting fired, or input on
    // socket.
    //

       
    //
    // if Interface activated, deactivate it
    // Note: deleted flag is already set. 
    //
    
    if (pite->Status&IF_ACTIVATED_FLAG) {

        //
        // I have already removed the interface from the list of activated 
        // interfaces
        //


        //
        // Call MGM to release the interface ownership. If proxy then
        // deregister proxy protocol from Mgm. If RAS, deregister all clients
        //
        
        DeActivationDeregisterFromMgm(pite);
        
        
        //
        // queue work item to deactivate and delete the interface. 
        //
        // _WF_CompleteIfDeactivateDelete will delete the Ras clients,
        // GI entries, and deinitialize pite structure. It will call
        // _CompleteIfDeletion() in the end.
        //
        
        CompleteIfDeactivateDelete(pite);
    }

    //
    // if it is not activated, then go ahead and delete it completely.
    //
    else {

        CompleteIfDeletion(pite);
    }


    // decrement the total number of interfaces
    
    g_pIfTable->NumInterfaces--;


    return NO_ERROR;

} //end _DeleteIfEntry



//------------------------------------------------------------------------------
//          _CompleteIfDeletion
//
// Frees memory with the static groups, frees
// rasTable, proxyHashTable, binding and pite. 
//
// Called by:
//    _DeleteIfEntry() if interface is not activated.
//    _DeActivateInterfaceComplete() if the pite deleted flag is set.
//------------------------------------------------------------------------------
VOID
CompleteIfDeletion (
    PIF_TABLE_ENTRY     pite
    )
{
    if (pite==NULL)
        return;

        
    //
    // delete all static groups.
    //
    {
        PIF_STATIC_GROUP    pStaticGroup;
        PLIST_ENTRY         pHead, ple;
        
        pHead = &pite->Config.ListOfStaticGroups;
        for (ple=pHead->Flink;  ple!=pHead;  ) {
            pStaticGroup = CONTAINING_RECORD(ple, IF_STATIC_GROUP, Link);
            ple = ple->Flink;
            IGMP_FREE(pStaticGroup);
        }
    }
    

    // if ras server, then delete ras table.
    
    if ( IS_RAS_SERVER_IF(pite->IfType) ) {

        IGMP_FREE(pite->pRasTable);
    }


    //
    // if proxy interface, then delete the proxy Hash Table
    //
    if (IS_PROTOCOL_TYPE_PROXY(pite)) {
        if ( (pite->CreationFlags&CREATED_PROXY_HASH_TABLE)
            && pite->pProxyHashTable
            ) {

            // clean the hash table entries
            {
                DWORD               i;
                PPROXY_GROUP_ENTRY  ppge;
                PLIST_ENTRY         pHead, ple, 
                                    pProxyHashTable = pite->pProxyHashTable;
                

                for (i=0;  i<PROXY_HASH_TABLE_SZ;  i++) {
                    pHead = &pProxyHashTable[i];

                    for (ple=pHead->Flink;  ple!=pHead;  ) {

                        ppge = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, HT_Link);
                        ple=ple->Flink;

                        // delete all sources
                        {
                            PLIST_ENTRY pHeadSrc, pleSrc;
                            PPROXY_SOURCE_ENTRY pSourceEntry;
                            
                            pHeadSrc = &ppge->ListSources;
                            for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; ) {

                                pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                                    PROXY_SOURCE_ENTRY, LinkSources);
                                pleSrc = pleSrc->Flink;

                                IGMP_FREE(pSourceEntry);
                            }
                        }
                        
                        IGMP_FREE(ppge);
                    }

                    InitializeListHead(pHead);
                }
            }

            IGMP_FREE_NOT_NULL(pite->pProxyHashTable);
        }
    }

    // delete the bindings

    IGMP_FREE_NOT_NULL(pite->pBinding);

    
    // delete the interface table entry

    IGMP_FREE(pite);

    return;
}



//------------------------------------------------------------------------------
//             _ActivateInterface
//
// an interface is activated: when it is bound, enabled by routerMgr & in config
// When activated, 
// (1) call is made to MGM to take interface ownership, 
// (2) static groups are appropriately joined, and socket for it created if req.
// (3) Igmprtr: query timer and input socket is activated.
// Note: it is already put in the list of activated IFs(ordered by IpAddr)
//
// Locks: assumes socketLock, IfListLock, exclusive IfLock
// Called by: _BindIfEntry, _EnableIfEntry, 
//------------------------------------------------------------------------------
DWORD
ActivateInterface (
    PIF_TABLE_ENTRY    pite
    )
{
    DWORD                   IfIndex = pite->IfIndex;
    PIGMP_IF_CONFIG         pConfig = &pite->Config;
    PIF_INFO                pInfo = &pite->Info;
    PIGMP_TIMER_ENTRY       pQueryTimer = &pite->QueryTimer,
                            pNonQueryTimer = &pite->NonQueryTimer;
    LONGLONG                llCurTime = GetCurrentIgmpTime();
    BOOL                    bProxy = IS_PROTOCOL_TYPE_PROXY(pite);
    DWORD                   Error = NO_ERROR;
    PLIST_ENTRY             pHead, ple;
    PIF_STATIC_GROUP        pStaticGroup;
    
    
    Trace2(ENTER, "entering ActivateInterface(%0x:%d.%d.%d.%d)", 
                IfIndex, PRINT_IPADDR(pite->IpAddr));


    BEGIN_BREAKOUT_BLOCK1 {

        //
        // set time when it is activated
        //
        pite->Info.TimeWhenActivated = llCurTime;


        
        //
        // create sockets for interface
        //
        Error = CreateIfSockets(pite);

        if (Error != NO_ERROR) {

            Trace2(IF, "error %d initializing sockets for interface %0x", Error,
                        pite->IfIndex);
            GOTO_END_BLOCK1;
        }
        pite->CreationFlags |= SOCKETS_CREATED;


        

            
        //------------------------------------------
        // PROXY INTERFACE PROCESSING (break at end)
        //------------------------------------------
        if (bProxy) {


            //
            // set status to activated here so that the MGM (*,*) join callbacks will 
            // be successful.
            //
            pite->Status |= IF_ACTIVATED_FLAG;

            

            //
            // register the protocol with mgm
            //
            Error = RegisterProtocolWithMgm(PROTO_IP_IGMP_PROXY);
            if (Error!=NO_ERROR)
                GOTO_END_BLOCK1;
            pite->CreationFlags |= REGISTERED_PROTOCOL_WITH_MGM;



            //
            // enumerate all existing groups from MGM
            //
            {
                DWORD               dwBufferSize, dwNumEntries, dwRetval, i;
                MGM_ENUM_TYPES      MgmEnumType = 0;
                SOURCE_GROUP_ENTRY  BufferSGEntries[20];
                HANDLE              hMgmEnum;
                

                // start enumeration

                dwBufferSize = sizeof(SOURCE_GROUP_ENTRY)*20;
                
                Error = MgmGroupEnumerationStart(g_MgmProxyHandle, MgmEnumType, 
                                                &hMgmEnum);
                if (Error!=NO_ERROR) {
                    Trace1(ERR, "MgmGroupEnumerationStart() returned error:%d", 
                            Error);
                    IgmpAssertOnError(FALSE);
                    GOTO_END_BLOCK1;
                }



                // get group entries from mgm
                // and insert group into Proxy's group list / increment refcount
                
                do {

                    
                    dwRetval = MgmGroupEnumerationGetNext(hMgmEnum, &dwBufferSize,
                                                        (PBYTE)BufferSGEntries, 
                                                        &dwNumEntries);

                
                    for (i=0;  i<dwNumEntries;  i++) {

                        ProcessProxyGroupChange(BufferSGEntries[i].dwSourceAddr, 
                                                BufferSGEntries[i].dwGroupAddr, 
                                                ADD_FLAG, NOT_STATIC_GROUP);
                    }
                    
                } while (dwRetval==ERROR_MORE_DATA);



                // end enumeration
                
                dwRetval = MgmGroupEnumerationEnd(hMgmEnum);
                if (dwRetval!=NO_ERROR) {
                    Trace1(ERR, "MgmGroupEnumerationEnd() returned error:%d", 
                            dwRetval);
                    IgmpAssertOnError(FALSE);
                }
            } //end block:enumerate existing groups



            //
            // take interface ownership
            //
            Error = MgmTakeInterfaceOwnership(g_MgmProxyHandle, IfIndex, 0);

            if (Error!=NO_ERROR) {
                Trace1(MGM, "MgmTakeInterfaceOwnership rejected for interface %0x", 
                        IfIndex);
                Logerr0(MGM_TAKE_IF_OWNERSHIP_FAILED, Error);
                GOTO_END_BLOCK1;
            }
            else {
                Trace1(MGM, "MgmTakeInterfaceOwnership successful for interface %0x", 
                        IfIndex);
            }
            
            pite->CreationFlags |= TAKEN_INTERFACE_OWNERSHIP_WITH_MGM;



            //
            // proxy does a (*,*) join
            //
            Error = MgmAddGroupMembershipEntry(g_MgmProxyHandle, 0, 0, 0, 0,
                                                IfIndex, 0, MGM_JOIN_STATE_FLAG);
            if (Error!=NO_ERROR) {
                Trace1(ERR, 
                    "Proxy failed to add *,* entry to MGM on interface %0x",
                    IfIndex);
                IgmpAssertOnError(FALSE);
                GOTO_END_BLOCK1;
            }
            
            Trace0(MGM, "proxy added *,* entry to MGM");
            pite->CreationFlags|= DONE_STAR_STAR_JOIN;


            //
            // do static joins
            //
            pHead = &pite->Config.ListOfStaticGroups;
            for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                DWORD i;
                
                pStaticGroup = CONTAINING_RECORD(ple, IF_STATIC_GROUP, Link);
                for (i=0;  i<pStaticGroup->NumSources;  i++) {
                    ProcessProxyGroupChange(pStaticGroup->Sources[i], pStaticGroup->GroupAddr, 
                                            ADD_FLAG, STATIC_GROUP);
                }

                if (pStaticGroup->NumSources==0)
                    ProcessProxyGroupChange(0, pStaticGroup->GroupAddr, 
                                            ADD_FLAG, STATIC_GROUP);
            }

            
            GOTO_END_BLOCK1;
            
        } // done processing for a proxy interface



        //-----------------------------------------
        //    IGMP ROUTER INTERFACE
        //-----------------------------------------


        //
        // take interface ownership
        //
        Error = MgmTakeInterfaceOwnership(g_MgmIgmprtrHandle, IfIndex, 0);

        if (Error!=NO_ERROR) {
            Trace1(MGM, "TakeInterfaceOwnership rejected for interface %0x", 
                    IfIndex);
            Logerr0(MGM_TAKE_IF_OWNERSHIP_FAILED, Error);
            GOTO_END_BLOCK1;
        }
        pite->CreationFlags |= TAKEN_INTERFACE_OWNERSHIP_WITH_MGM;
        

        //
        // see if any other MCast protocol is owning that interface
        // this affects whether a non-querier registers group with Mgm or not
        //
        {
            DWORD   dwProtoId, dwComponentId;
            
            MgmGetProtocolOnInterface(IfIndex, 0, &dwProtoId, &dwComponentId);
            if (dwProtoId==PROTO_IP_IGMP) {
                SET_MPROTOCOL_ABSENT_ON_IGMPRTR(pite);
            }
            else {
                SET_MPROTOCOL_PRESENT_ON_IGMPRTR(pite);
            }
        }

        //
        // when interface is activated, it is by default enabled by mgm.
        //
        MGM_ENABLE_IGMPRTR(pite);
        
        
        //
        // if ras server interface, then register all the ras clients as they 
        // would not have been registered
        //
        if (IS_RAS_SERVER_IF(pite->IfType)) {
        
            PRAS_TABLE_ENTRY    prte;
            
            // join all ras clients
            pHead = &pite->pRasTable->ListByAddr;
            for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                prte = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, LinkByAddr);
                
                Error = MgmTakeInterfaceOwnership(g_MgmIgmprtrHandle,  IfIndex, 
                                            prte->NHAddr);
                
                if (Error!=NO_ERROR) {
                    Trace2(MGM, 
                        "TakeInterfaceOwnership rejected for interface %0x "
                        "NHAddr(%d.%d.%d.%d)",
                        IfIndex, PRINT_IPADDR(prte->NHAddr));
                    Logerr0(MGM_TAKE_IF_OWNERSHIP_FAILED, Error);
                }
                else {
                    prte->CreationFlags |= TAKEN_INTERFACE_OWNERSHIP_WITH_MGM;
                }
            }
        }



        //
        // INITIALIZE THE INFO STRUCTURE AND SET THE TIMERS
        //

        //
        // start as querier with version specified in the config
        //
        pInfo->QuerierState = RTR_QUERIER;

        pInfo->QuerierIpAddr = pite->IpAddr;

        pInfo->LastQuerierChangeTime = llCurTime;

        
        //
        // how many startup queries left to be sent 
        //
        pInfo->StartupQueryCountCurrent = pConfig->StartupQueryCount;
        {
            MIB_IFROW   TmpIfEntry;

            TmpIfEntry.dwIndex = IfIndex;
            if (GetIfEntry(&TmpIfEntry ) == NO_ERROR)
                pInfo->PacketSize = TmpIfEntry.dwMtu;
            else
                pInfo->PacketSize = INPUT_PACKET_SZ;
        }

                        
        //
        // initialize the query timer
        //
        pQueryTimer->Function = T_QueryTimer;
        pQueryTimer->Context = &pQueryTimer->Context;
        pQueryTimer->Timeout = pConfig->StartupQueryInterval;
        pQueryTimer->Status = TIMER_STATUS_CREATED;

        //
        // initialize non query timer
        //
        pNonQueryTimer->Function = T_NonQueryTimer;
        pNonQueryTimer->Context = &pNonQueryTimer->Context;
        pNonQueryTimer->Timeout = pConfig->OtherQuerierPresentInterval;
        pNonQueryTimer->Status = TIMER_STATUS_CREATED;

        
        //
        // take timer lock and insert timers into the list
        //
        ACQUIRE_TIMER_LOCK("_ActivateInterface");

        //
        // insert querier timer in the list
        //
        #if DEBUG_TIMER_TIMERID
            SET_TIMER_ID(pQueryTimer, 110, IfIndex, 0, 0);
        #endif;
        
        InsertTimer(pQueryTimer, pQueryTimer->Timeout, TRUE, DBG_Y);
        
        RELEASE_TIMER_LOCK("_ActivateInterface");


        
        //
        // activate Input socket
        //
        Error = WSAEventSelect(pite->SocketEntry.Socket, 
                            pite->SocketEntry.pSocketEventsEntry->InputEvent, 
                            FD_READ
                            );

        if (Error != NO_ERROR) {
            Trace3(IF, "WSAEventSelect returned %d for interface %0x (%d.%d.%d.%d)",
                    Error, IfIndex, PRINT_IPADDR(pite->IpAddr));
            Logerr1(EVENTSELECT_FAILED, "%I", pite->IpAddr, 0);
            GOTO_END_BLOCK1;
        }


        //
        // set the activated flag here so that the joins will work
        //
        pite->Status |= IF_ACTIVATED_FLAG;

        
        if (pInfo->StartupQueryCountCurrent) {

            //
            // send the initial general query
            //
            SEND_GEN_QUERY(pite);


            // decrement the number of startupQueryCount left to be sent
            pInfo->StartupQueryCountCurrent--;
        }


        //
        // do static joins (no static joins for ras server interface)
        //
        if (!IS_RAS_SERVER_IF(pite->IfType))
        {
            PGROUP_TABLE_ENTRY  pge;
            PGI_ENTRY           pgie;
            DWORD               GroupAddr;
            SOCKADDR_IN         saLocalIf;

            //
            // socket for static groups already created in _CreateIfSockets
            // irrespective of whether there are any static groups
            //
           
            
            pHead = &pite->Config.ListOfStaticGroups;
            for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                pStaticGroup = CONTAINING_RECORD(ple, IF_STATIC_GROUP, Link);


                // IGMP_HOST_JOIN
                
                if (pStaticGroup->Mode==IGMP_HOST_JOIN) {

                    DWORD i;

                    if (pStaticGroup->NumSources==0
                        || pStaticGroup->FilterType==EXCLUSION)
                    {
                        JoinMulticastGroup(pite->StaticGroupSocket,
                                        pStaticGroup->GroupAddr,
                                        pite->IfIndex,
                                        pite->IpAddr,
                                        0
                                       );
                    }
                    
                    for (i=0;  i<pStaticGroup->NumSources;  i++) {
                        if (pStaticGroup->FilterType==INCLUSION) {
                            JoinMulticastGroup(pite->StaticGroupSocket,
                                    pStaticGroup->GroupAddr,
                                    pite->IfIndex,
                                    pite->IpAddr,
                                    pStaticGroup->Sources[i]
                                   );
                        }
                        else {
                            BlockSource(pite->StaticGroupSocket,
                                    pStaticGroup->GroupAddr,
                                    pite->IfIndex,
                                    pite->IpAddr,
                                    pStaticGroup->Sources[i]
                                   );
                        }
                    }
                }

                // IGMPRTR_MGM_ONLY
                
                else {
                    BOOL bCreate = TRUE;
                    DWORD i;
                    
                    GroupAddr = pStaticGroup->GroupAddr;
                    
                    ACQUIRE_GROUP_LOCK(GroupAddr, "_ActivateInterface");

                    pge = GetGroupFromGroupTable(GroupAddr, &bCreate, 0);
                    pgie = GetGIFromGIList(pge, pite, 0,
                                pStaticGroup->NumSources==0?STATIC_GROUP:NOT_STATIC_GROUP,
                                &bCreate, 0);
                    for (i=0;  i<pStaticGroup->NumSources;  i++) {
                        GetSourceEntry(pgie, pStaticGroup->Sources[i],
                            pStaticGroup->FilterType,
                            &bCreate, STATIC, MGM_YES);
                    }
                    RELEASE_GROUP_LOCK(GroupAddr, "_ActivateInterface");

                }
            }
        }

        

    } END_BREAKOUT_BLOCK1;


    if (Error!=NO_ERROR) {

        DeActivationDeregisterFromMgm(pite);
        
        DeActivateInterfaceComplete(pite);

        pite->Status &= ~IF_ACTIVATED_FLAG;

        if (bProxy) {
            Logerr1(ACTIVATION_FAILURE_PROXY, "%d",IfIndex, Error);
        }
        else {
            Logerr2(ACTIVATION_FAILURE_RTR, "%d%d",
                GET_IF_VERSION(pite), IfIndex, Error);
        }
    }

    else {
        if (bProxy) {
            Loginfo1(INTERFACE_PROXY_ACTIVATED, "%d",
                IfIndex, NO_ERROR);
        }
        else {
            Loginfo2(INTERFACE_RTR_ACTIVATED, "%d%d",
                GET_IF_VERSION(pite), IfIndex, NO_ERROR);
        }
        Trace1(START, "IGMP activated on interface:%0x", IfIndex);
    }

            
    Trace1(LEAVE, "leaving ActivateInterface():%d\n", Error);

    return Error;
    
} //end _ActivateInterface


//------------------------------------------------------------------------------
//          _DeActivateDeregisterFromMgm
//------------------------------------------------------------------------------

DWORD
DeActivationDeregisterFromMgm(
    PIF_TABLE_ENTRY pite
    )
{
    HANDLE hMgmHandle = IS_PROTOCOL_TYPE_PROXY(pite)
                        ? g_MgmProxyHandle: g_MgmIgmprtrHandle;
    DWORD               Error=NO_ERROR, IfIndex=pite->IfIndex;
    PLIST_ENTRY         pHead, ple;
    
    //
    // Call MGM to release the interface ownership
    //
    if (pite->CreationFlags&TAKEN_INTERFACE_OWNERSHIP_WITH_MGM) {
        
        Error = MgmReleaseInterfaceOwnership(hMgmHandle, IfIndex,0);
        if (Error!=NO_ERROR) {
            Trace2(ERR, "MgmReleaseInterfaceOwnership returned error(%d) for If(%0x)",
                Error, IfIndex);
            IgmpAssertOnError(FALSE);
        }
        else
            pite->CreationFlags &= ~TAKEN_INTERFACE_OWNERSHIP_WITH_MGM;
    }
    

    //
    // if releasing proxy interface, then deregister proxy from mgm
    //

    if (IS_PROTOCOL_TYPE_PROXY(pite) 
        && (pite->CreationFlags&REGISTERED_PROTOCOL_WITH_MGM)) 
    {
        Error = MgmDeRegisterMProtocol(g_MgmProxyHandle);

        if (Error!=NO_ERROR) {
            Trace1(ERR, "MgmDeRegisterMProtocol(proxy) returned error(%d)", 
                Error);
            IgmpAssertOnError(FALSE);
                
        }
        else
            pite->CreationFlags &= ~REGISTERED_PROTOCOL_WITH_MGM;
    }

    //
    // delete all proxy alert entries        
    //
    if (IS_PROTOCOL_TYPE_PROXY(pite)) {

        ACQUIRE_PROXY_ALERT_LOCK("_DeActivationDeregisterMgm");
        
        {
            for (ple=g_ProxyAlertsList.Flink;  ple!=&g_ProxyAlertsList;  ) {
                PPROXY_ALERT_ENTRY pProxyAlertEntry
                    = CONTAINING_RECORD(ple, PROXY_ALERT_ENTRY, Link);
                ple = ple->Flink;
                IGMP_FREE(pProxyAlertEntry);
            }
        }

        InitializeListHead(&g_ProxyAlertsList);
        RELEASE_PROXY_ALERT_LOCK("_DeActivationDeregisterMgm");
    }

    // 
    // if ras interface, then call mgm to release ownership of all ras clients
    //
    if (IS_RAS_SERVER_IF(pite->IfType)) {
        PRAS_TABLE_ENTRY    prte;
        
        pHead = &pite->pRasTable->ListByAddr;
        
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            prte = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, LinkByAddr);

            if (prte->CreationFlags & TAKEN_INTERFACE_OWNERSHIP_WITH_MGM) {

                Error = MgmReleaseInterfaceOwnership(g_MgmIgmprtrHandle, IfIndex,
                                            prte->NHAddr);

                if (Error!=NO_ERROR) {
                    Trace3(ERR, 
                        "error:%d _MgmReleaseInterfaceOwnership() for If:%0x, "
                        "NHAddr:%d.%d.%d.%d",
                        Error, IfIndex, PRINT_IPADDR(prte->NHAddr));
                    IgmpAssertOnError(FALSE);
                }

                prte->CreationFlags &= ~TAKEN_INTERFACE_OWNERSHIP_WITH_MGM;
            }
        }
    }
    


    return Error;
}

//------------------------------------------------------------------------------
//              DeActivateInterfaceInitial
//
// deregister from MGM. Then create a new interface entry structure which 
// replaces the old one in all the lists. Now the old interface entry and 
// all its associated structures can be lazily deleted.
// Also update the global Proxy and Ras table pointers.
//
// Called by _UnBindIfEntry(), _DisableIfEntry()
//------------------------------------------------------------------------------

PIF_TABLE_ENTRY
DeActivateInterfaceInitial (
    PIF_TABLE_ENTRY piteOld
    )
{
    DWORD           IfIndex = piteOld->IfIndex;
    PIF_TABLE_ENTRY piteNew;
    DWORD           dwRetval, Error=NO_ERROR;
    PLIST_ENTRY     pHead, ple, pleNext;
    
    
    Trace0(ENTER1, "Entering _DeActivateInterfaceInitial()");

    
    //
    // deregister from Mgm
    //
    DeActivationDeregisterFromMgm(piteOld);
    

    //
    // allocate memory for the new interface
    //
    piteNew = IGMP_ALLOC(sizeof(IF_TABLE_ENTRY), 0x8, IfIndex);

    PROCESS_ALLOC_FAILURE3(piteNew, 
            "error %d allocating %d bytes for interface %0x",
            Error, sizeof(IF_TABLE_ENTRY), IfIndex, 
            return NULL);



    // copy the old pite fields to the new pite
    CopyMemory(piteNew, piteOld, sizeof(IF_TABLE_ENTRY));


    // copy the old static groups to the new pite
    InitializeListHead(&piteNew->Config.ListOfStaticGroups);
    pHead = &piteOld->Config.ListOfStaticGroups;
    for (ple=pHead->Flink;  ple!=pHead;  ple=pleNext) {

        pleNext = ple->Flink;
        RemoveEntryList(ple);
        InsertTailList(&piteNew->Config.ListOfStaticGroups,
                        ple);
    }

    
    // set the status 
    MGM_DISABLE_IGMPRTR(piteNew);


    
    // LinkByAddr (not inserted in this list as the IF is deactivated)
    InitializeListHead(&piteNew->LinkByAddr);


    //
    // insert the new entry before the old entry, and remove the old 
    // entry from the list of IFs ordered by index and from hash table
    //
    
    InsertTailList(&piteOld->LinkByIndex, &piteNew->LinkByIndex);
    RemoveEntryList(&piteOld->LinkByIndex);

    InsertTailList(&piteOld->HTLinkByIndex, &piteNew->HTLinkByIndex);
    RemoveEntryList(&piteOld->HTLinkByIndex);



    // initialize GI list to empty
    InitializeListHead(&piteNew->ListOfSameIfGroups);
    InitializeListHead(&piteNew->ListOfSameIfGroupsNew);
    piteNew->NumGIEntriesInNewList = 0;


    
    //  set binding of piteOld to NULL so that it doesnt get deleted
    piteOld->pBinding = NULL;


    // reset the Info fields
    ZeroMemory(&piteNew->Info, sizeof(IF_INFO));
    

    //
    // create a new RAS table if it is a RAS server interface, and set ras
    // pointer in global table. I could have reused the ras table, but dont
    // so that resetting the fields is cleaner.
    //
    if ( IS_RAS_SERVER_IF(piteNew->IfType)) {

        PRAS_TABLE_ENTRY prte;

        InitializeRasTable(IfIndex, piteNew);

        //
        // recreate all ras client entries
        //
        pHead = &piteOld->pRasTable->ListByAddr;
        
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            prte = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, LinkByAddr);

            CreateRasClient(piteNew, &prte, prte->NHAddr);
        }
        
        InterlockedExchangePointer(&g_pRasIfEntry, piteNew);
    }


    //
    // if proxy, then update the entry in the global table
    // I reuse the proxy hash table. set it to null in piteOld so that it is not
    // delete there.
    //
    if (g_pProxyIfEntry == piteOld) {
        InterlockedExchangePointer(&g_pProxyIfEntry, piteNew);

        
        // clean the hash table entries
        {
            DWORD               i;
            PPROXY_GROUP_ENTRY  ppge;
            PLIST_ENTRY         pProxyHashTable = piteOld->pProxyHashTable;
            
            if (piteOld->CreationFlags&CREATED_PROXY_HASH_TABLE) {

                for (i=0;  i<PROXY_HASH_TABLE_SZ;  i++) {
                    pHead = &pProxyHashTable[i];

                    for (ple=pHead->Flink;  ple!=pHead;  ) {

                        ppge = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, HT_Link);
                        ple=ple->Flink;

                        // delete all sources
                        {
                            PLIST_ENTRY pHeadSrc, pleSrc;
                            PPROXY_SOURCE_ENTRY pSourceEntry;
                            
                            pHeadSrc = &ppge->ListSources;
                            for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; ) {

                                pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                                    PROXY_SOURCE_ENTRY, LinkSources);
                                pleSrc = pleSrc->Flink;

                                IGMP_FREE(pSourceEntry);
                            }
                        }
                        
                        IGMP_FREE(ppge);
                    }

                    InitializeListHead(pHead);
                }
            }
        }

        piteOld->pProxyHashTable = NULL;
    }


    //
    // socket is created when the interface is activated
    //
    
    piteNew->SocketEntry.Socket = INVALID_SOCKET;
    //piteNew->SocketEntry.pSocketEventsEntry = NULL;
    //InitializeListHead(&piteNew->SocketEntry.LinkByInterfaces);


    // initialize the new timers
    piteNew->QueryTimer.Status = 0;
    piteNew->NonQueryTimer.Status = 0;


    piteNew->pPrevIfGroupEnumPtr = NULL;
    piteNew->PrevIfGroupEnumSignature = 0;
    piteNew->StaticGroupSocket = INVALID_SOCKET;


    // creationFlags already copied.
    piteNew->CreationFlags &= ~CREATION_FLAGS_DEACTIVATION_CLEAR;
    


    Trace0(LEAVE1, "Leaving _DeActivateInterfaceInitial()");
    return piteNew;

}//end _DeActivateInterfaceInitial



//------------------------------------------------------------------------------
//          _DeActivateInterfaceComplete
//
// If ras server, then for each ras client queues a work item to delete it.
// the last ras client will delete the pite entry.
// Deletes the GI entries, and calls _CompleteIfDeletion() if deleted flag 
// or DeactivateDelete flag set on the IF entry.
// This routine assumes that the interface has been removed from any global
// lists that it needs to be removed from, and that the appropriate flags have
// been set. The only way they can still be used is by timers getting fired or
// by input on socket.
//
// Called by:
//    _ActivateInterface:(if it fails), only in this case pite is not deleted.
//    _DeleteIfEntry --> 
//          _DeActivationDeregisterFromMgm & _WF_CompleteIfDeactivateDelete
//    _UnbindIfEntry & _DisableIfEntry -->
//          _DeActivateInterfaceInitial & _WF_CompleteIfDeactivateDelete
// Lock:
//    If called when interface is being deleted, then no interface locks required.
//    else assumes exclusive interface lock.
//    requires exclusive sockets list lock in either case.
//------------------------------------------------------------------------------
VOID
DeActivateInterfaceComplete (
    PIF_TABLE_ENTRY     pite
    )
{
    DWORD           IfIndex = pite->IfIndex;
    DWORD           Error = NO_ERROR, dwRetval;
    PLIST_ENTRY     pHead, ple;
    PGI_ENTRY       pgie;
    BOOL            bProxy = IS_PROTOCOL_TYPE_PROXY(pite);;
    
    
    Trace1(ENTER1, "Entering _DeActivateInterfaceComplete(%d)", IfIndex);


    //
    // do all deactivation here which is common for all interfaces
    // whether ras server or not.
    //



    // 
    // unbind sockets from Input event and then close the sockets
    //
    if (pite->SocketEntry.Socket!=INVALID_SOCKET) {

        //
        // proxy does not bind its socket to input event as it
        // does not want to receive any packets
        //
        if (!bProxy)
            WSAEventSelect(pite->SocketEntry.Socket,
                        pite->SocketEntry.pSocketEventsEntry->InputEvent, 0);

    }

    if (pite->CreationFlags&SOCKETS_CREATED)
        DeleteIfSockets(pite);



    /////////////////////////////////////////////////////////
    // IS_RAS_SERVER_IF
    /////////////////////////////////////////////////////////

    //
    // go through the list of Ras clients. Mark them as deleted, remove them
    // from all global lists, and set work item to delete them.
    //
    if (IS_RAS_SERVER_IF(pite->IfType)) {
    
        PRAS_TABLE          prt = pite->pRasTable;
        PRAS_TABLE_ENTRY    prte;


        // go through the list of all Ras clients and set them to be deleted

        pHead = &prt->ListByAddr;
        for (ple=pHead->Flink;  ple!=pHead;  ) {
        
            prte = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, LinkByAddr);

            ple=ple->Flink;

            
            //
            // if ras client has deleted flag already set, then ignore it.
            //
            if (!(prte->Status&IF_DELETED_FLAG)) {

                //
                // set deleted flag for the ras client, so that no one else will
                // try to access it
                prte->Status |= IF_DELETED_FLAG;


                //
                // remove the RAS client from the Ras table lists so that no one 
                // will access it.
                //
                RemoveEntryList(&prte->HTLinkByAddr);
                RemoveEntryList(&prte->LinkByAddr);


                //
                // clean up the ras client
                //
                DeleteRasClient(prte);
            }

        }

        //
        // delete the timers from pite entry
        //

        ACQUIRE_TIMER_LOCK("_DeActivateInterfaceComplete");

        if (IS_TIMER_ACTIVE(pite->QueryTimer))
            RemoveTimer(&pite->QueryTimer, DBG_Y);

        if (IS_TIMER_ACTIVE(pite->NonQueryTimer))
            RemoveTimer(&pite->NonQueryTimer, DBG_Y);

        RELEASE_TIMER_LOCK("_DeActivateInterfaceComplete");



        pite->CreationFlags = 0; 
        prt->RefCount--;


        //
        // deleting the pite entry(if deleted flag is set), and ras table will 
        // be done by the work item which deletes the last Ras client 
        // (when refcount==0) however if there are no ras clients, then I will 
        // have to do the cleanup here
        //

        if ( ((pite->Status&IF_DELETED_FLAG)
            ||(pite->Status&IF_DEACTIVATE_DELETE_FLAG))
            &&(prt->RefCount==0) )
        {
            CompleteIfDeletion(pite);
        }
    }
    

    
    //------------------------------------------------------------
    // NOT IS_RAS_SERVER_IF: PROXY IF
    //------------------------------------------------------------

    // PROXY INTERFACE. Just clean the hash table, and delete interface if req
    
    else if ( (!IS_RAS_SERVER_IF(pite->IfType)) && bProxy) {
        

        // the proxy hashTable will be deleted if
        // necessary in _CompleteIfDeletion().

    
        //
        // delete the interface if either IF_DELETED_FLAG or 
        // IF_DEACTIVATE_DELETE_FLAG set. (interface not deleted when cleaning
        // up because activate interface failed
        //
        if ( (pite->Status&IF_DELETED_FLAG)
            ||(pite->Status&IF_DEACTIVATE_DELETE_FLAG) ) 
        {
            CompleteIfDeletion(pite);
        }
    }

    //----------------------
    // NOT PROXY interface
    //----------------------
    
    else if ( !IS_RAS_SERVER_IF(pite->IfType) ) {
    
        //
        // take exclusive lock on the If_Group List and remove all timers.
        // From now on no one can enter from outside and no one is inside
        // as all timers have been removed. 

        // have to take the if_group_list lock to make sure that no
        // one is changing it.
        ACQUIRE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_DeActivateInterfaceComplete");

        //
        // Remove all timers
        //
        
        ACQUIRE_TIMER_LOCK("_DeActivateInterfaceComplete");


        // delete all timers contained in GI entries and the sources
        
        pHead = &pite->ListOfSameIfGroups;
        DeleteAllTimers(pHead, NOT_RAS_CLIENT);
        pHead = &pite->ListOfSameIfGroupsNew;
        DeleteAllTimers(pHead, NOT_RAS_CLIENT);
        pite->NumGIEntriesInNewList = 0;
        


        // delete query timer
       
        if (IS_TIMER_ACTIVE(pite->QueryTimer))
            RemoveTimer(&pite->QueryTimer, DBG_Y);

        if (IS_TIMER_ACTIVE(pite->NonQueryTimer))
            RemoveTimer(&pite->NonQueryTimer, DBG_Y);


        RELEASE_TIMER_LOCK("_DeActivateInterfaceComplete");


        RELEASE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_DeActivateInterfaceComplete");
        
        
        //
        // revisit the list and delete all GI entries. Need to take 
        // exclusive lock on the group bucket before deleting the GI entry
        // No need to lock the If-Group list as deleted flag already set and 
        // no one can visit the list from outside or inside(all timers removed).
        //
        DeleteAllGIEntries(pite);


        //
        // if deleted flag set, then also delete the interface
        //

        if ( (pite->Status&IF_DELETED_FLAG)
            ||(pite->Status&IF_DEACTIVATE_DELETE_FLAG) )
        {
            CompleteIfDeletion(pite);
        }
        
    } //deactivated if: Not(ras server if)
        

    // do not use pite, or prt from here as they are deleted.

    if (bProxy)
        Loginfo1(PROXY_DEACTIVATED, "%d",IfIndex, NO_ERROR);
    else
        Loginfo1(RTR_DEACTIVATED, "%d",IfIndex, NO_ERROR);
    
    Trace1(LEAVE, "leaving _DeActivateInterfaceComplete(%d)", IfIndex);
    
} //end _DeActivateInterfaceComplete




//------------------------------------------------------------------------------
//                EnableInterface
//
// sets the status to enabled. If interface is also bound and enabled in
// config, then activate the interface.
//
// Locks: SocketsLock, IfListLock, Exclusive IfLock
//------------------------------------------------------------------------------

DWORD
EnableInterface(
    IN DWORD IfIndex
    )
{
    DWORD Error = NO_ERROR;


    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    Trace1(ENTER1, "entering _EnableInterface(%0x):", IfIndex);
    Trace1(IF, "enabling interface %0x", IfIndex);
    
    
    //
    // enable the interface
    //
    ACQUIRE_SOCKETS_LOCK_EXCLUSIVE("_EnableInterface");
    ACQUIRE_IF_LIST_LOCK("_EnableInterface");
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_EnableInterface");


    Error = EnableIfEntry(IfIndex, TRUE);


    RELEASE_SOCKETS_LOCK_EXCLUSIVE("_EnableInterface");
    RELEASE_IF_LIST_LOCK("_EnableInterface");
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_EnableInterface");



    Trace2(LEAVE1, "leaving _EnableInterface(%0x): %d\n", IfIndex, Error);
    if (Error!=NO_ERROR) {
        Trace1(ERR, "Error enabling interface:%0x\n", IfIndex);
        IgmpAssertOnError(FALSE);
    }
    
    LeaveIgmpApi();

    return Error;
}



//------------------------------------------------------------------------------
//                _EnableInterface_ConfigChanged
//
// Set the status to enabled. If it is also bound, activate the interface.
//
// Locks:  Runs entirely in Exclusive interface lock.
// Calls:  EnableIfEntry() with mode config
//------------------------------------------------------------------------------

DWORD
EnableInterface_ConfigChanged(
    DWORD IfIndex
    )
{
    DWORD             Error=NO_ERROR;


    Trace1(ENTER, "entering _EnableInterface_ConfigChanged(%d):", IfIndex);

    Trace1(IF, 
        "Enabling Interface(%0x) due to change made by _SetInterfaceConfigInfo", 
        IfIndex);

        
    //
    // enable the interface
    //

    Error = EnableIfEntry(IfIndex, FALSE); // FALSE->change made by config


    Trace2(LEAVE, "leaving _EnableInterface_ConfigChanged(%d): %d\n", 
            IfIndex, Error);

    return Error;
    
} //end _DeActivateInterfaceInitial




//------------------------------------------------------------------------------
//            BindInterface                                                        //
//------------------------------------------------------------------------------
DWORD
BindInterface(
    IN DWORD IfIndex,
    IN PVOID pBinding
    )
/*++
Routine Description:
    Sets the binding for the interface and activates it if it is also enabled.
Return Value
      ERROR_INVALID_PARAMETER
      NO_ERROR
Lock:
    runs entirely in Interface Exclusive lock
Calls:
    BindIfEntry()
--*/
{
    DWORD         Error=NO_ERROR;
    

    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    Trace1(ENTER1, "entering BindInterface: %0x", IfIndex);
    Trace1(IF, "binding interface %0x", IfIndex);


    // pBinding should not be NULL
    
    if (pBinding == NULL) {

        Trace0(IF, "error: binding struct pointer is NULL");
        Trace1(LEAVE, "leaving BindInterface: %0x", ERROR_INVALID_PARAMETER);

        LeaveIgmpApi();
        return ERROR_INVALID_PARAMETER;
    }



    //
    // now bind the interface in the interface table
    //

    //
    // take sockets lock, as activate interface might be called, and
    // sockets lock should be taken before interface lock
    //
    ACQUIRE_SOCKETS_LOCK_EXCLUSIVE("_BindInterface");
    ACQUIRE_IF_LIST_LOCK("_BindInterface");
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_BindInterface");


    Error = BindIfEntry(IfIndex, pBinding);


    RELEASE_SOCKETS_LOCK_EXCLUSIVE("_BindInterface");
    RELEASE_IF_LIST_LOCK("_BindInterface");
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_BindInterface");



    Trace2(LEAVE1, "leaving _BindInterface(%x): %d\n", IfIndex, Error);
    if (Error!=NO_ERROR){
        Trace1(ERR, "Error binding interface(%0x)\n", IfIndex);
        IgmpAssertOnError(FALSE);
    }
    LeaveIgmpApi();

    return Error;
}

//------------------------------------------------------------------------------
//          _BindIfEntry
//
// Binds the ip addresses to the interface. The lowest of the ip addresses is
// picked up as the de-facto address for that interface. If the interface is 
// already bound, it makes sure that the bindings are consistent. Currently 
// you cannot change the bindings of an interface.
// If the interface is already enabled, then it is also activated.
//
// Locks: 
//    assumes exclusive interface lock.
// Called by:  _BindInterface().
//------------------------------------------------------------------------------

DWORD
BindIfEntry(
    DWORD IfIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    ) 
{
    PIF_TABLE_ENTRY         pite = NULL;
    DWORD                   i, j, dwSize;
    IPADDR                  MinAddr;
    PIGMP_IF_BINDING        pib;
    PIGMP_IP_ADDRESS        paddr;
    BOOL                    bFound;
    DWORD                   Error = NO_ERROR;
    INT                     cmp;

    
    pib = NULL;


    //
    // retrieve the interface entry
    //

    pite = GetIfByIndex(IfIndex);

    if (pite == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    
    
    //
    // If the interface is already bound, check to see if he is giving
    // us a different binding. If he is, then it is an error. 
    //
    // return from this case. dont break.

    if (IS_IF_BOUND(pite)) {

        Trace1(IF, "interface %0x is already bound", IfIndex);

        pib = pite->pBinding;

        Error = NO_ERROR;


        // number of address bindings before and now should be same
        
        if(pib->AddrCount != pBinding->AddressCount){
            Trace1(IF, "interface %0x is bound and has different binding",
                    IfIndex);
            return ERROR_INVALID_PARAMETER;
        }

        
        //
        // make sure that all address bindings are consistent
        //
        paddr = (PIGMP_IP_ADDRESS)((pib) + 1);

        for(i = 0; i < pBinding->AddressCount; i++) {
            bFound = FALSE;

            for(j = 0; j < pBinding->AddressCount; j++) {
                if((paddr[j].IpAddr == pBinding->Address[i].Address) &&
                   (paddr[j].SubnetMask == pBinding->Address[i].Mask))
                {
                    bFound = TRUE;
                    break;
                }
            }

            if(!bFound) {
                Trace1(IF,
                    "interface %0x is bound and has different binding",
                    IfIndex);
                return ERROR_INVALID_PARAMETER;
            }
        }

        return NO_ERROR;
    }

    //
    // make sure there is at least one address. However, unnumbered 
    // RAS server interfaces might have no IP addresses.
    //
    if ( (pBinding->AddressCount==0)&&(!IS_RAS_ROUTER_IF(pite->IfType)) ) {

        return ERROR_CAN_NOT_COMPLETE;
    }

    BEGIN_BREAKOUT_BLOCK1 {
        
        if (pBinding->AddressCount!=0) {
            //
            // allocate memory to store the binding
            //
            dwSize = sizeof(IGMP_IF_BINDING) +
                        pBinding->AddressCount * sizeof(IGMP_IP_ADDRESS);


            pib = IGMP_ALLOC(dwSize, 0x10, IfIndex);

            PROCESS_ALLOC_FAILURE3(pib,
                    "error %d allocating %d bytes for binding on interface %0x",
                    Error, dwSize, IfIndex, GOTO_END_BLOCK1);


            //
            // copy the bindings
            //

            pib->AddrCount = pBinding->AddressCount;
            paddr = IGMP_BINDING_FIRST_ADDR(pib);
            MinAddr = ~0;
            
            for (i=0;  i<pib->AddrCount;  i++,paddr++) {
                
                paddr->IpAddr = pBinding->Address[i].Address;
                paddr->SubnetMask = pBinding->Address[i].Mask;

                if (INET_CMP(MinAddr, paddr->IpAddr, cmp)>0)
                    MinAddr = paddr->IpAddr;
            }


            //
            // set the Interface effective address to the smallest bound address
            //
            pite->IpAddr = MinAddr;
            pite->Config.IpAddr = MinAddr;

            
            //
            // save the binding in the interface entry
            //
            pite->pBinding = pib;
        }
        
        // dont have to do the below as they are already set to those values
        else {
            pite->IpAddr = pite->Config.IpAddr = 0;
            pite->pBinding = NULL;
        }

        //
        // mark the interface as being bound
        //
        pite->Status |= IF_BOUND_FLAG;



        //
        // if interface is also enabled, it is now active
        // so activate it
        //

        if (IS_IF_ENABLED_BOUND(pite)) {

            //
            // place interface on the list of active interfaces
            //
            Error = InsertIfByAddr(pite);


            //
            // error if another numbered interface with same IpAddr already exists
            //
            if (Error != NO_ERROR) {
                Trace2(IF, "error %d inserting interface %0x in active list",
                        Error, IfIndex);
                GOTO_END_BLOCK1;
            }


            //
            // Activate the Interface
            //
            Error = ActivateInterface(pite);

            //
            // if could not activate the interface then undo the binding
            //
            if (Error != NO_ERROR) {

                Trace1(ERR, 
                    "Unbinding interface(%0x) because it could not be activated",
                    IfIndex);
                IgmpAssertOnError(FALSE);
                RemoveEntryList(&pite->LinkByAddr);

                Error = ERROR_CAN_NOT_COMPLETE;
                GOTO_END_BLOCK1;
            }
         }
        
    } END_BREAKOUT_BLOCK1;


    //
    // if there was any error, then set the status to unbound (pite is null 
    // if interface was not found)
    //
    if (Error!=NO_ERROR) {
        
        if (pite!=NULL)
        {
            pite->Status &= ~IF_BOUND_FLAG; 
            pite->pBinding = NULL;

            pite->IpAddr = pite->Config.IpAddr = 0;
        }

        IGMP_FREE_NOT_NULL(pib); 
    }
    
    return Error;
    
} //end BindIfEntry
    




//------------------------------------------------------------------------------
//            UnBindInterface                                                        //
//------------------------------------------------------------------------------
DWORD
UnBindInterface(
    IN DWORD IfIndex
    )
/*++
Routine Description:
    Calls UnBindIfEntry to unbind the interface.
Calls:
    UnBindIfEntry();
Locks:
    Runs completely in exclusive interface lock
--*/
{

    DWORD Error=NO_ERROR;

    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    Trace1(ENTER, "entering UnBindInterface(%0x):", IfIndex);


    //
    // unbind the interface
    //

    //
    // take sockets lock, as activate interface might be called, and
    // sockets lock should be taken before interface lock
    //
    ACQUIRE_SOCKETS_LOCK_EXCLUSIVE("_UnBindInterface");
    ACQUIRE_IF_LIST_LOCK("_UnBindInterface");
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_UnBindInterface");


    Error = UnBindIfEntry(IfIndex);


    RELEASE_SOCKETS_LOCK_EXCLUSIVE("_UnBindInterface");
    RELEASE_IF_LIST_LOCK("_UnBindInterface");
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_UnBindInterface");


    Trace2(LEAVE, "leaving UnBindInterface(%0x): %d\n", IfIndex, Error);

    LeaveIgmpApi();

    return Error;

}


//------------------------------------------------------------------------------
//          _UnBindIfEntry
//
// If the interface is activated, deactivates it. Removes the binding. 
//
// MayCall: _DeActivateInterfaceComplete().
// Locks: assumes exclusive interface lock.
//------------------------------------------------------------------------------

DWORD
UnBindIfEntry(
    DWORD         IfIndex
    )
{
    DWORD                   Error = NO_ERROR, dwRetval;
    PIF_TABLE_ENTRY         pite, piteNew;
    DWORD                   bProxy;


    BEGIN_BREAKOUT_BLOCK1 {

        //
        // retrieve the interface specified
        //
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Trace1(ERR, "_UnbindInterface called for non existing interface(%0x)",
                    IfIndex);
            IgmpAssertOnError(FALSE);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        //
        // quit if the interface is already unbound
        //
        if (!IS_IF_BOUND(pite)) {

            Error = ERROR_INVALID_PARAMETER;
            Trace1(ERR, "interface %0x is already unbound", IfIndex);
            IgmpAssertOnError(FALSE);
            GOTO_END_BLOCK1;
        }

        
        //
        // clear the "bound" flag
        //
        pite->Status &= ~IF_BOUND_FLAG;


        //
        //  unbind IF
        //
            
        IGMP_FREE(pite->pBinding);
        pite->pBinding = NULL;

        
        //
        // if IF activated (ie also enabled), deactivate it
        // note: check for activated flag, and not for enabled flag
        //
        if (IS_IF_ACTIVATED(pite)) {

            // unset activated flag
            
            pite->Status &= ~IF_ACTIVATED_FLAG;


            // remove the interface from the list of activated interfaces
            
            RemoveEntryList(&pite->LinkByAddr);


            piteNew = DeActivateInterfaceInitial(pite);


            //
            // queue work item to deactivate and delete the interface.
            //
            // CompleteIfDeactivateDelete will delete the Ras clients, GI entries,
            // and deinitialize pite structure
            //

            //
            // set flag to indicate that the interface is being deleted following
            // partial deactivation
            //
            pite->Status |= IF_DEACTIVATE_DELETE_FLAG;


            CompleteIfDeactivateDelete(pite);

            
            #ifdef WORKER_DBG
                Trace2(WORKER, "Queuing IgmpWorker function: %s in %s",
                    "_WF_CompleteIfDeactivateDelete:", "_UnBindIfEntry");
            #endif
            
        }
        
        else {
            pite->IpAddr = pite->Config.IpAddr = 0;
        }

    } END_BREAKOUT_BLOCK1;


    return Error;
    
} //end _UnBindIfEntry







//------------------------------------------------------------------------------
// Function:    _EnableIfEntry
//------------------------------------------------------------------------------
DWORD
EnableIfEntry(
    DWORD   IfIndex,
    BOOL    bChangedByRtrmgr // changed by rtrmg or SetInterfaceConfigInfo
    )
/*++
Routine Description:
    Sets the status to enabled. If the interface is also bound, then activates 
    the interface.
Called by:
    EnableInterface().
MayCall:
    ActivateIfEntry()
Locks:
    Assumes exclusive interface lock.
--*/
{
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         ple, phead;
    PIF_TABLE_ENTRY     pite = NULL;    

    
    BEGIN_BREAKOUT_BLOCK1 {

        //
        // retrieve the interface
        //
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Trace1(IF, "could not find interface %0x",IfIndex);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        if (bChangedByRtrmgr) {
            //
            // quit if the interface is already enabled by the router manager
            //
            if (IS_IF_ENABLED_BY_RTRMGR(pite)) {
                Trace1(IF, "interface %0x is already enabled by the router manager", 
                        IfIndex);
                Error = NO_ERROR;
                GOTO_END_BLOCK1;
            }


            // set the flag to enabled by router manager
            
            pite->Status |= IF_ENABLED_FLAG;

            // print trace if enabled flag not set in the Config.
            if (!IS_IF_ENABLED_IN_CONFIG(pite)) {
                Trace1(IF, 
                    "Interface(%0x) enabled by router manager but not enabled"
                    "in the Config", pite->IfIndex);
            }
        }

        else {
            //
            // quit if the interface is already enabled in config
            //
            if (IS_IF_ENABLED_IN_CONFIG(pite)) {
                Trace1(IF, "interface %0x is already enabled in Config", 
                        IfIndex);
                Error = NO_ERROR;
                GOTO_END_BLOCK1;
            }

            // set the config flag to enabled
            
            pite->Config.Flags |= IGMP_INTERFACE_ENABLED_IN_CONFIG;


            // print trace if interface not enabled by router manager

            if (!IS_IF_ENABLED_BY_RTRMGR(pite)) {
                Trace1(IF, 
                    "Interface(%0x) enabled in config but not enabled by router manager",
                    IfIndex);
                Error = NO_ERROR;
                GOTO_END_BLOCK1;
            }
        }
        
    
        //
        // if interface is already bound, it should be activated
        // if the bInterfaceEnabled flag is also set in config (by the UI)
        //

        if (IS_IF_ENABLED_BOUND(pite)) {


            //
            // place interface on the list of active interfaces
            //
            Error = InsertIfByAddr(pite);


            //
            // error if another interface with same ip address already exists
            //
            if (Error != NO_ERROR) {
                 Trace2(IF, "error %d inserting interface %0x in active list",
                         Error, IfIndex);
                 GOTO_END_BLOCK1;
            }

            //
            // Activate the Interface
            //
            Error = ActivateInterface(pite);

            //
            // if could not activate the interface then disable it again
            //
            if (Error != NO_ERROR) {

                Trace1(ERR,
                    "Disabling interface(%0x) because it could not be activated",
                    IfIndex);
                IgmpAssertOnError(FALSE);
                RemoveEntryList(&pite->LinkByAddr);

                Error = ERROR_CAN_NOT_COMPLETE;
                GOTO_END_BLOCK1;
            }

         }
         
    } END_BREAKOUT_BLOCK1;



    //
    // if an error occured somewhere, set the interface back to the previous 
    // disabled state.(pite may be null if interface was not found).
    //
    if ((Error!=NO_ERROR)&&(pite!=NULL)) {

        if (bChangedByRtrmgr)
            pite->Status &= ~IF_ENABLED_FLAG;
        else
            pite->Config.Flags &= ~IGMP_INTERFACE_ENABLED_IN_CONFIG;
    }

    
    return Error;
    
}//end EnableIfEntry



//------------------------------------------------------------------------------
//            _DisableInterface
//
// If interface is activated, then deactivates it. Finally sets the disabled flag
// Locks: Runs completely in exclusive interface lock.
// Calls: _DisableIfEntry()
//------------------------------------------------------------------------------

DWORD
DisableInterface(
    IN DWORD IfIndex
    )
{      
    DWORD Error=NO_ERROR;

    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    Trace1(ENTER, "entering DisableInterface(%0x):", IfIndex);


    //
    // disable the interface
    //
    ACQUIRE_SOCKETS_LOCK_EXCLUSIVE("_DisableInterface");    
    ACQUIRE_IF_LIST_LOCK("_DisableInterface");
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_DisableInterface");


    Error = DisableIfEntry(IfIndex, TRUE);


    RELEASE_SOCKETS_LOCK_EXCLUSIVE("_DisableInterface");    
    RELEASE_IF_LIST_LOCK("_DisableInterface");
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_DisableInterface");


    Trace2(LEAVE, "leaving DisableInterface(%0x): %d\n", IfIndex, Error);
    LeaveIgmpApi();

    return Error;
}


//------------------------------------------------------------------------------
//            _DisableInterface_ConfigChanged
//
//If interface is activated, then deactivates it. Finally sets the disabled flag
//
// Locks:  assumes IfLists lock and exclusive If lock.
// Calls: _DisableIfEntry() with mode config
// Called by: _SetInterfaceConfigInfo()

//------------------------------------------------------------------------------
DWORD
DisableInterface_ConfigChanged(
    DWORD IfIndex
    )
{      
    DWORD Error=NO_ERROR;

    Trace1(ENTER1, "entering _DisableInterface_ConfigChanged(%d):", IfIndex);

    Trace1(IF, 
        "disabling interface(%0x) due to change made by _SetInterfaceConfigInfo",
        IfIndex);


    Error = DisableIfEntry(IfIndex, FALSE); // false->disabling from config


    Trace2(LEAVE, "leaving _DisableInterface_ConfigChanged(%d): %d\n", 
            IfIndex, Error);

    return Error;
}



//------------------------------------------------------------------------------
//          _DisableIfEntry
//
// if interface is activated, then calls DeActivateInterfaceComplete(). Removes
// the enabled flag.
// Locks: Assumes exclusive interface lock.
// Called by: _DisableInterface()
//------------------------------------------------------------------------------

DWORD
DisableIfEntry(
    DWORD IfIndex,
    BOOL  bChangedByRtrmgr
    )
{
    DWORD                   Error = NO_ERROR;
    PIF_TABLE_ENTRY         pite, piteNew;
    BOOL                    bProxy;
    
    
    BEGIN_BREAKOUT_BLOCK1 {

        //
        // retrieve the interface to be disabled
        //
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Trace1(IF, "could not find interface %0x", IfIndex);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        if (bChangedByRtrmgr) {
            //
            // quit if already disabled by router manager
            //
            if (!IS_IF_ENABLED_BY_RTRMGR(pite)) {
                Trace1(IF, "interface %0x already disabled by router manager", 
                        IfIndex);
                Error = ERROR_INVALID_PARAMETER;
                GOTO_END_BLOCK1;
            }
        }

        else {
            //
            // quit if already disabled in Config
            //
            if (!IS_IF_ENABLED_IN_CONFIG(pite)) {
                Trace1(IF, "interface %0x already disabled in config", 
                        IfIndex);
                Error = ERROR_INVALID_PARAMETER;
                GOTO_END_BLOCK1;
            }
        }

        
        //
        // clear the enabled flag
        //
        if (bChangedByRtrmgr)
            pite->Status &= ~IF_ENABLED_FLAG;
        else
            pite->Config.Flags &= ~IGMP_INTERFACE_ENABLED_IN_CONFIG;

            

        //
        // if IF activated (ie also enabled), deactivate it
        // note: check for activated flag, and not for enabled flag
        //
        
        if (IS_IF_ACTIVATED(pite)) {

            // unset activated flag
            
            pite->Status &= ~IF_ACTIVATED_FLAG;


            // remove the interface from the list of activated interfaces
            
            RemoveEntryList(&pite->LinkByAddr);


            piteNew = DeActivateInterfaceInitial(pite);


            //
            // queue work item to deactivate and delete the interface.
            //
            // CompleteIfDeactivateDelete will delete the Ras clients, GI entries,
            // and deinitialize pite structure
            //

            //
            // set flag to indicate that the interface is being deleted following
            // partial deactivation
            //
            pite->Status |= IF_DEACTIVATE_DELETE_FLAG;


            CompleteIfDeactivateDelete(pite);

            #ifdef WORKER_DBG
                Trace2(WORKER, "Queuing IgmpWorker function: %s in %s",
                    "_WF_CompleteIfDeactivateDelete:", "_DisableIfEntry");
            #endif
        }
    
    } END_BREAKOUT_BLOCK1;

    
    return Error;

} //end _DisableIfEntry



//------------------------------------------------------------------------------
//          _CreateRasClient
//------------------------------------------------------------------------------

DWORD
CreateRasClient (
    PIF_TABLE_ENTRY     pite,      
    PRAS_TABLE_ENTRY   *pprteNew,
    DWORD               NHAddr
    )
{
    DWORD               Error=NO_ERROR;
    PLIST_ENTRY         pHead, ple;
    PRAS_TABLE          prt = pite->pRasTable;
    PRAS_TABLE_ENTRY    prteCur, prte;

    BEGIN_BREAKOUT_BLOCK1 {
        //
        // Create new Ras client entry and initialize the fields
        //

        prte = IGMP_ALLOC(sizeof(RAS_TABLE_ENTRY), 0x20, pite->IfIndex);
        PROCESS_ALLOC_FAILURE2(prte, 
                "error %d allocating %d bytes in CreateRasClient()",
                Error, sizeof(RAS_TABLE_ENTRY), 
                GOTO_END_BLOCK1);

        *pprteNew = prte;


        prte->NHAddr = NHAddr;
        prte->IfTableEntry = pite;
        InitializeListHead(&prte->ListOfSameClientGroups);


        // increment refcount for the ras table
        prt->RefCount++;


        //
        // insert into HashTable
        //
        InsertTailList(&prt->HashTableByAddr[RAS_HASH_VALUE(NHAddr)],
                        &prte->HTLinkByAddr);


        //
        // insert the client into list of clients ordered by IpAddr
        //
        pHead = &prt->ListByAddr;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            prteCur = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, LinkByAddr);
            if (NHAddr>prteCur->NHAddr)
                break;
        }
        InsertTailList(&prt->ListByAddr, &prte->LinkByAddr);


        //
        // Set Interface stats to 0
        //
        ZeroMemory(&prte->Info, sizeof(RAS_CLIENT_INFO));


        prte->Status = IF_CREATED_FLAG;
        prte->CreationFlags = 0;
        
    } END_BREAKOUT_BLOCK1;
    return Error;
}



//------------------------------------------------------------------------------
//                _ConnectRasClient
//
// Called when a new RAS client dials up to the RAS server.
// A new entry is created in the RAS table.
// Locks: shared interface lock
//      exclusive RAS table lock.
// Note:
//      Ras client entry is created even if the interface is not activated
//------------------------------------------------------------------------------

DWORD
APIENTRY
ConnectRasClient (
    ULONG   IfIndex,
    PVOID   pvNHAddr 
    )
{
    PIF_TABLE_ENTRY             pite = NULL;
    PRAS_TABLE                  prt;
    PRAS_TABLE_ENTRY            prte, prteCur;
    PLIST_ENTRY                 pHead, ple;
    DWORD                       Error = NO_ERROR;
    PIP_LOCAL_BINDING           pNHAddrBinding = (PIP_LOCAL_BINDING)pvNHAddr;
    DWORD                       NHAddr = pNHAddrBinding->Address;
    

    // mightdo
    // currently rtrmgr passes 0 for IfIndex. so I set it to the value required
    IfIndex = g_RasIfIndex;

    
    Trace2(ENTER, "Entering ConnectRasClient(%d.%d.%d.%d):IfIndex(%0x)\n", 
            PRINT_IPADDR(NHAddr), IfIndex);
    if (!EnterIgmpApi()) return ERROR_CAN_NOT_COMPLETE;

            
    //
    // take a shared lock on the interface
    //
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_ConnectRasClient");


    BEGIN_BREAKOUT_BLOCK1 {
        //
        // retrieve the RAS interface entry 
        //
        pite = g_pRasIfEntry;

        if ( (pite==NULL)||(g_RasIfIndex!=IfIndex) ) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        //
        // check that it is a RAS server Interface
        //
        if (!IS_RAS_SERVER_IF(pite->IfType)) {
            Error = ERROR_CAN_NOT_COMPLETE;
            Trace2(ERR, 
                "Illegal attempt to connect Ras client(%d.%d.%d.%d) to non-Ras"
                "interface(%0x)", PRINT_IPADDR(NHAddr), IfIndex
                );
            IgmpAssertOnError(FALSE);
            Logerr2(CONNECT_FAILED, "%I%d", NHAddr, 
                    pite->IfIndex, Error);
            GOTO_END_BLOCK1;
        }
        
    } END_BREAKOUT_BLOCK1;

    //
    // if error, return from here
    //
    if (Error!=NO_ERROR) {

        RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_ConnectRasClient");

        LeaveIgmpApi();
        return Error;
    }



    //
    // get pointer to RasTable, write lock RasTable and release interface lock
    //
    prt = pite->pRasTable;
    

    BEGIN_BREAKOUT_BLOCK2 {

        //
        // check if a RAS client with similar address already exists
        //
        prte = GetRasClientByAddr(NHAddr, prt);

        if (prte!=NULL) {
            Trace1(ERR, 
                "Ras client(%d.%d.%d.%d) already exists. _ConnectRasClient failed",
                PRINT_IPADDR(NHAddr)
                );
            IgmpAssertOnError(FALSE);
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK2;
        }


        //
        // Create new Ras client entry and initialize the fields
        //

        prte = IGMP_ALLOC(sizeof(RAS_TABLE_ENTRY), 0x40, IfIndex);

        PROCESS_ALLOC_FAILURE2(prte,
                "error %d allocating %d bytes in _ConnectRasClient()",
                Error, sizeof(RAS_TABLE_ENTRY),
                GOTO_END_BLOCK2);


        prte->NHAddr = NHAddr;
        prte->IfTableEntry = pite;
        InitializeListHead(&prte->ListOfSameClientGroups);


        // increment refcount for the ras table
        prt->RefCount++;

        
        //
        // insert into HashTable
        //
        InsertTailList(&prt->HashTableByAddr[RAS_HASH_VALUE(NHAddr)],
                        &prte->HTLinkByAddr);


        //
        // insert the client into list of clients ordered by IpAddr
        //
        pHead = &prt->ListByAddr;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            prteCur = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, LinkByAddr);
            if (NHAddr>prteCur->NHAddr)
                break;
        }
        InsertTailList(&prt->ListByAddr, &prte->LinkByAddr);


        //
        // Set Interface stats to 0
        //
        ZeroMemory(&prte->Info, sizeof(RAS_CLIENT_INFO));

        
        prte->Status = IF_CREATED_FLAG;
        prte->CreationFlags = 0;

        //
        // call MGM to take ownership of this (interface, NHAddr)
        // This call is not made if the interface is not activated.
        //
        
        if (IS_IF_ACTIVATED(pite)) {
            
            Error = MgmTakeInterfaceOwnership(g_MgmIgmprtrHandle,  IfIndex, NHAddr);
            if (Error!=NO_ERROR) {
                Trace2(MGM, 
                    "_TakeInterfaceOwnership rejected for interface %0x NHAddr(%d.%d.%d.%d)",
                    IfIndex, PRINT_IPADDR(NHAddr));
                Logerr0(MGM_TAKE_IF_OWNERSHIP_FAILED, Error);
            }
            else {
                prte->CreationFlags |= TAKEN_INTERFACE_OWNERSHIP_WITH_MGM;
            }
        }
        // register ras client with MGM when the interface is activated.
        else {
            Trace3(ERR, 
                "ras client(%d.%d.%d.%d) connected to an inactive ras server(%0x:%d)",
                PRINT_IPADDR(NHAddr), IfIndex, pite->Status);
        }

    } END_BREAKOUT_BLOCK2;

    
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_ConnectRasClient");


    LeaveIgmpApi();
    Trace2(LEAVE, "Leaving _ConnectRasClient(%d.%d.%d.%d):%d\n", 
            PRINT_IPADDR(NHAddr), Error);
    return Error;

} //end _ConnectRasClient




//------------------------------------------------------------------------------
//            _DisconnectRasClient
//
// Takes shared interface lock. retrieves the Ras interface, takes write
// lock on the ras table, and then releases the shared interface lock.
//
// Removes the RasClient Entry from the Ras table so that no one can access
// it through a RAS table. Then queues a work item that will delete all
// GI entries.
//
// Calls: _DeleteRasClient()
//------------------------------------------------------------------------------

DWORD
APIENTRY
DisconnectRasClient (
    DWORD        IfIndex,
    PVOID        pvNHAddr
    )
{
    PIF_TABLE_ENTRY             pite = NULL;
    PRAS_TABLE                  prt;
    PRAS_TABLE_ENTRY            prte, prteCur;
    DWORD                       Error = NO_ERROR;
    PLIST_ENTRY                 pHead, ple;
    PGI_ENTRY                   pgie;
    PIP_LOCAL_BINDING           pNHAddrBinding = (PIP_LOCAL_BINDING)pvNHAddr;
    DWORD                       NHAddr = pNHAddrBinding->Address;

    // mightdo
    // currently rtrmgr passes 0 for IfIndex. so I set it to the value required
    IfIndex = g_RasIfIndex;


    Trace2(ENTER, "Entering DisconnectRasClient for IfIndex(%0x), NextHop(%d.%d.%d.%d)",
            IfIndex, PRINT_IPADDR(NHAddr));

    if (!EnterIgmpApi()) return ERROR_CAN_NOT_COMPLETE;


    //
    // take an exclusive lock on the interface
    //
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_DisconnectRasClient");


    BEGIN_BREAKOUT_BLOCK1 {
        //
        // retrieve the RAS interface entry from the global structure.
        //
        if ( (g_RasIfIndex!=IfIndex) || (g_pRasIfEntry==NULL) ) {
            Error = ERROR_INVALID_PARAMETER;
            Trace2(ERR,
                "attempt to disconnect Ras client(%d.%d.%d.%d) from non-Ras "
                "interface(%0x)", PRINT_IPADDR(NHAddr), IfIndex
                );
            IgmpAssertOnError(FALSE);
            Logerr2(DISCONNECT_FAILED, "%I%d", NHAddr,
                    IfIndex, Error);
            GOTO_END_BLOCK1;
        }

        pite = g_pRasIfEntry;

    } END_BREAKOUT_BLOCK1;

    //
    // if error, return from here.
    //
    if (Error!=NO_ERROR) {

        RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_DisconnectRasClient");

        LeaveIgmpApi();
        return Error;
    }


    
    //
    // get pointer to RasTable
    //
    prt = pite->pRasTable;


    BEGIN_BREAKOUT_BLOCK2 {
    
        //
        // retrieve ras client
        //
        prte = GetRasClientByAddr(NHAddr, prt);
        if (prte==NULL) {
            Error = ERROR_INVALID_PARAMETER;
            Trace2(ERR,
                "Illegal attempt to disconnect non-existing Ras client(%d.%d.%d.%d) "
                "from Ras interface(%0x)", PRINT_IPADDR(NHAddr), IfIndex);
            IgmpAssertOnError(FALSE);
            Logerr2(DISCONNECT_FAILED, "%I%d", NHAddr,
                    pite->IfIndex, Error);
            GOTO_END_BLOCK2;
        }
        
        //
        // break if ras client has deleted flag set
        //
        if ( (prte->Status&IF_DELETED_FLAG) ) {
            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK2;
        }


        //
        // set deleted flag for the ras client, so that no one else will
        // try to access it
        prte->Status |= IF_DELETED_FLAG;

        
        //
        // remove the RAS client from the Ras table lists so that no one will
        // access it.
        //
        RemoveEntryList(&prte->HTLinkByAddr);
        RemoveEntryList(&prte->LinkByAddr);


        //
        // release RasClient virtual interface
        //
        if (prte->CreationFlags & TAKEN_INTERFACE_OWNERSHIP_WITH_MGM)
        {
            Error = MgmReleaseInterfaceOwnership(g_MgmIgmprtrHandle, pite->IfIndex,
                                                prte->NHAddr);
            if (Error!=NO_ERROR) {
                Trace2(ERR, 
                    "Error: _MgmReleaseInterfaceOwnership for If:%0x, NHAddr:%d.%d.%d.%d",
                    pite->IfIndex, PRINT_IPADDR(prte->NHAddr));
                IgmpAssertOnError(FALSE);
            }

            prte->CreationFlags &= ~TAKEN_INTERFACE_OWNERSHIP_WITH_MGM;
        }

        //
        // remove the ras client's GI entries from the ras server interface
        // list
        //
        
        ACQUIRE_IF_GROUP_LIST_LOCK(IfIndex, "_DisconectRasClient");
        pHead = &prte->ListOfSameClientGroups;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameClientGroups);
            RemoveEntryList(&pgie->LinkBySameIfGroups);
            InitializeListHead(&pgie->LinkBySameIfGroups);
        }
        RELEASE_IF_GROUP_LIST_LOCK(IfIndex, "_DisconnectRasClient");



        //
        // Delete ras client. The refcount is not changed
        // so the prte, prt, pite fields will be valid.
        //
        DeleteRasClient(prte);

    } END_BREAKOUT_BLOCK2;
    

    // release the interface lock
    
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_DisconnectRasClient");
    
                            
    Trace3(LEAVE, 
        "Leaving _DisconnectRasClient(%d) for IfIndex(%0x), NextHop(%d.%d.%d.%d)\n",
        Error, IfIndex, PRINT_IPADDR(NHAddr)
        );
    LeaveIgmpApi();
    
    return Error;
    
} //end _DisconnectRasClient




//------------------------------------------------------------------------------
//            _SetInterfaceConfigInfo
//
// Resets the interface config. The router parameters might have changed. 
// Also proxy<-->router transition might have taken place.
//
// Locks: takes IfLists lock initiallly itself just in case the interface had to
//    be disabled. Runs completely in exclusive interface lock.
//------------------------------------------------------------------------------    
DWORD
WINAPI
SetInterfaceConfigInfo(
    IN DWORD IfIndex,
    IN PVOID pvConfig,
    IN ULONG ulStructureVersion,
    IN ULONG ulStructureSize,
    IN ULONG ulStructureCount
    )
{
    DWORD                   Error=NO_ERROR;
    PIGMP_IF_CONFIG         pConfigDst;
    PIGMP_MIB_IF_CONFIG     pConfigSrc;
    PIF_TABLE_ENTRY         pite = NULL;
    DWORD                   OldState, OldProtoType, NewProtoType;
    BOOL                    bIgmpProtocolChanged=FALSE, bEnabledStateChanged=FALSE;
    BOOL                    bOldStateEnabled=FALSE;
    
    
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    Trace1(ENTER, "entering SetInterfaceConfigInfo(%d)", IfIndex);
    // make sure it is not an unsupported igmp version structure
    if (ulStructureVersion>=IGMP_CONFIG_VERSION_600) {
        Trace1(ERR, "Unsupported IGMP version structure: %0x",
            ulStructureVersion);
        IgmpAssertOnError(FALSE);
        LeaveIgmpApi();
        return ERROR_CAN_NOT_COMPLETE;
    }

    ACQUIRE_SOCKETS_LOCK_EXCLUSIVE("_SetInterfaceConfigInfo");    
    ACQUIRE_IF_LIST_LOCK("_SetInterfaceConfigInfo");
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_SetInterfaceConfigInfo");


    
    BEGIN_BREAKOUT_BLOCK1 {

        if (pvConfig==NULL) {
            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }
        
        pConfigSrc = (PIGMP_MIB_IF_CONFIG)pvConfig;


        //
        // find the interface specified
        //
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }    


        //
        // validate the new config values
        //
        Error = ValidateIfConfig(pConfigSrc, IfIndex, pite->IfType, 
                    ulStructureVersion, ulStructureSize
                    );
        if (Error!=NO_ERROR)
            GOTO_END_BLOCK1;


        pConfigDst = &pite->Config;


        //
        // make sure you are not setting multiple proxy interfaces
        //
        if (IS_CONFIG_IGMPPROXY(pConfigSrc) 
            &&!IS_CONFIG_IGMPPROXY(pConfigDst)
            && (g_ProxyIfIndex!=0) )
        {
            Error = ERROR_INVALID_PARAMETER;
            Trace1(ERR, "Cannot set multiple Proxy interfaces. Proxy exists on %d",
                    g_ProxyIfIndex);
            IgmpAssertOnError(FALSE);
            Logerr0(PROXY_IF_EXISTS, Error);
                    
            GOTO_END_BLOCK1;
        }

        
        //
        // Process change in IgmpProtocolType (between proxy and router)
        // (no special processing for changes between ver-1 and ver-2)
        //
        if (pConfigSrc->IgmpProtocolType != pConfigDst->IgmpProtocolType)
        {
            bIgmpProtocolChanged = TRUE;
            GOTO_END_BLOCK1;
        }
        else 
            bIgmpProtocolChanged = FALSE;


        OldProtoType = pConfigDst->IgmpProtocolType;


        //
        // if interface enabled state has changed, then process that change
        // I dont have to look for version changes, etc
        //
        if (IGMP_ENABLED_FLAG_SET(pConfigSrc->Flags)
            != IGMP_ENABLED_FLAG_SET(pConfigDst->Flags)) 
        {

            bEnabledStateChanged = TRUE;

            pite->Info.OtherVerPresentTimeWarn = 0;
            
            bOldStateEnabled = IGMP_ENABLED_FLAG_SET(pConfigDst->Flags);
            GOTO_END_BLOCK1;
        }

        else 
            bEnabledStateChanged = FALSE;
            
        

            
        // copy the new config
        
        if (IS_IF_ACTIVATED(pite))
            CopyinIfConfigAndUpdate(pite, pConfigSrc, IfIndex);
        else
            CopyinIfConfig(&pite->Config, pConfigSrc, IfIndex);

        NewProtoType = pConfigDst->IgmpProtocolType;

        /*
        // 
        // if changing from V1 <-> V2
        //
        if ( ((OldProtoType==IGMP_ROUTER_V1) && (NewProtoType==IGMP_ROUTER_V2))
            || ((OldProtoType==IGMP_ROUTER_V2) && (NewProtoType==IGMP_ROUTER_V1)) )
        {
            pite->Info.OtherVerPresentTimeWarn = 0;
        }
        */
                    
    } END_BREAKOUT_BLOCK1;

    

    //
    // change the protocol and check for state changes. 
    // This function will effectively delete the interface with the old
    // protocol and create a new interface with the new protocol.
    //
    if ( (bIgmpProtocolChanged)&&(Error==NO_ERROR) )
        ProcessIfProtocolChange(IfIndex, pConfigSrc);


    //
    // Process State Change: enable or disable interface  
    //
    else if ( (bEnabledStateChanged)&&(Error==NO_ERROR) ) {

        //
        // disable the interface and then copy in the new config
        //
        if (bOldStateEnabled) {

            // old state enabled, new state disabled

            DisableInterface_ConfigChanged(IfIndex);

            //
            // copy the config 
            //
            // get the pite entry again, as disable creates a new one
            //
            
            pite = GetIfByIndex(IfIndex);
            CopyinIfConfig(&pite->Config, pConfigSrc, IfIndex);

            
        }
        //
        // copy the new config before enabling it
        //
        else {

            CopyinIfConfig(&pite->Config, pConfigSrc, IfIndex);
            
            //
            // set the enable state to false, so that the below call can
            // enable the interface.
            //
            pite->Config.Flags &= ~IGMP_INTERFACE_ENABLED_IN_CONFIG;


            // old state disabled, new state enabled

            EnableInterface_ConfigChanged(IfIndex);
        }
    }


    RELEASE_SOCKETS_LOCK_EXCLUSIVE("_SetInterfaceConfigInfo");    
    RELEASE_IF_LIST_LOCK("_SetInterfaceConfigInfo");
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_SetInterfaceConfigInfo");


    
    Trace2(LEAVE, "leaving SetInterfaceConfigInfo(%d):%d\n", IfIndex, Error);

    LeaveIgmpApi();

    return Error;
    
} //end _SetInterfaceConfigInfo



//------------------------------------------------------------------------------
//          _ProcessProtocolChange
//
// Called when the interface protocol has changed (proxy<->router).
// First disables the old interface so that all old protocol data is cleaned up.
// then sets the new config, and enables the interface again (if it was
// enabled before). This process takes care of creation/deletion of sockets, etc
//
// Locks: no locks when called. Except for _Disable(_Enable)Interface, all work
//          is done inside an exclusive IfLock.
// Calls: _DisableInterface(), _EnableInterface() if required.
//------------------------------------------------------------------------------
DWORD
ProcessIfProtocolChange(
    DWORD               IfIndex,
    PIGMP_MIB_IF_CONFIG pConfigSrc
    )
{
    DWORD                   Error=NO_ERROR, dwDisabled;
    PIGMP_IF_CONFIG         pConfigDst;
    PIF_TABLE_ENTRY         pite = NULL;


    Trace1(ENTER, "Entered _ProcessIfProtocolChange(%d)", IfIndex);

    
    //
    // disable the interface so that all protocol specific data is lost
    //
    dwDisabled = DisableIfEntry(IfIndex, TRUE);


    //
    // find the interface specified and copy the config info. The config
    // has already been validated.
    //
    
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_ProcessIfProtocolChange");


    BEGIN_BREAKOUT_BLOCK1 {

        // get interface again
        
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }    

        pConfigDst = &pite->Config;



        //
        // if old interface was Proxy, then remove it from the Global Struct
        // and delete the Proxy_HT related structures
        //
        if (IS_PROTOCOL_TYPE_PROXY(pite)) {

            // _DisableIfEntry would have deleted all the entries in the proxy
            // Hash table
            
            IGMP_FREE(pite->pProxyHashTable);

            InterlockedExchange(&g_ProxyIfIndex, 0);
            InterlockedExchangePointer(&g_pProxyIfEntry, NULL);
        }


        
        //
        // copy the new config values
        //
        CopyinIfConfig(&pite->Config, pConfigSrc, IfIndex);



        //
        // if new interface is Proxy, then add it to the Global Struct
        // and create the Proxy_HT structures
        //

        if (IS_PROTOCOL_TYPE_PROXY(pite)) {
        
            DWORD       dwSize = PROXY_HASH_TABLE_SZ * sizeof(LIST_ENTRY);
            DWORD       i;
            PLIST_ENTRY pProxyHashTable;
            
            pProxyHashTable = pite->pProxyHashTable = IGMP_ALLOC(dwSize, 0x80,IfIndex);

            PROCESS_ALLOC_FAILURE2(pProxyHashTable,
                    "error %d allocating %d bytes for interface table",
                    Error, dwSize,
                    GOTO_END_BLOCK1);


            for (i=0;  i<PROXY_HASH_TABLE_SZ;  i++) {
                InitializeListHead(pProxyHashTable+i);
            }


            InterlockedExchangePointer(&g_pProxyIfEntry, pite);
            InterlockedExchange(&g_ProxyIfIndex, IfIndex);

            pite->CreationFlags |= CREATED_PROXY_HASH_TABLE;

        }

    } END_BREAKOUT_BLOCK1;
    

    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_ProcessIfProtocolChange");


    //
    // enable the interface if the new state requires
    // it to be enabled.
    //
    if ( (Error==NO_ERROR) && (dwDisabled==NO_ERROR) )
        Error = EnableIfEntry(IfIndex, TRUE);


    Trace2(LEAVE, "Leaving _ProcessIfProtocolChange(%d): %d\n", 
            IfIndex, Error);
    return Error;
    
} //end _ProcessIfProtocolChange



//------------------------------------------------------------------------------
//          _GetInterfaceConfigInfo
//
// The Router Manager calls us with a NULL config and ZERO size. We return
// the required size to it.  It then allocates the needed memory and calls
// us a second time with a valid buffer.  We validate parameters each time
// and copy out our config if we can
//
// Return Value
//    ERROR_INSUFFICIENT_BUFFER If the size of the buffer is too small
//    ERROR_INVALID_PARAMETER    ERROR_INVALID_DATA      NO_ERROR
//------------------------------------------------------------------------------

DWORD
WINAPI
GetInterfaceConfigInfo(
    IN     DWORD  IfIndex,
    IN OUT PVOID  pvConfig,
    IN OUT PDWORD pdwSize,
    IN OUT PULONG pulStructureVersion,
    IN OUT PULONG pulStructureSize,
    IN OUT PULONG pulStructureCount
    )
{

    DWORD                   Error = NO_ERROR;
    PIF_TABLE_ENTRY         pite = NULL;
    PIGMP_MIB_IF_CONFIG     pConfigDst;
    PIGMP_IF_CONFIG         pConfigSrc;


    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    Trace3(ENTER1, 
        "entering _GetInterfaceConfigInfo(%d): ConfigPrt(%08x) SizePrt(%08x)",
        IfIndex, pvConfig, pdwSize
        );


    ACQUIRE_IF_LOCK_SHARED(IfIndex, "_GetInterfaceConfigInfo");

    BEGIN_BREAKOUT_BLOCK1 {

        //
        // check the arguments
        //
        if (pdwSize == NULL) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        //
        // find the interface specified
        //
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        pConfigSrc = &pite->Config;


        // get the size of the interface config
        

        //
        // check the buffer size
        //

        if (*pdwSize < pConfigSrc->ExtSize) {
            Error = ERROR_INSUFFICIENT_BUFFER;
        }
        else {
        

            pConfigDst = (PIGMP_MIB_IF_CONFIG)pvConfig;


            //
            // copy the interface config, and set the IP address
            //
            CopyoutIfConfig(pConfigDst, pite);

        }

        *pdwSize = pConfigSrc->ExtSize;

    } END_BREAKOUT_BLOCK1;


    RELEASE_IF_LOCK_SHARED(IfIndex, "_GetInterfaceConfigInfo");

    if (pulStructureCount)
        *pulStructureCount = 1;
    if (pulStructureSize && pdwSize)
        *pulStructureSize = *pdwSize;
    if (pulStructureVersion)
        *pulStructureVersion = IGMP_CONFIG_VERSION_500;

    Trace2(LEAVE1, "leaving _GetInterfaceConfigInfo(%d): %d\n", IfIndex, Error);
    LeaveIgmpApi();

    return Error;
}


DWORD
WINAPI
InterfaceStatus(
    ULONG IfIndex,
    BOOL  bIfActive,
    DWORD dwStatusType,
    PVOID pvStatusInfo
    )
{
    DWORD Error = NO_ERROR;
    
    switch(dwStatusType)
    {
        case RIS_INTERFACE_ADDRESS_CHANGE:
        {
            PIP_ADAPTER_BINDING_INFO pBindInfo
                                    = (PIP_ADAPTER_BINDING_INFO)pvStatusInfo;
            
            if(pBindInfo->AddressCount)
            {
                Error = BindInterface(IfIndex, pvStatusInfo);
            }
            else 
            {
                Error = UnBindInterface(IfIndex);
            }

            break;
        }

        case RIS_INTERFACE_ENABLED:
        {
            Error = EnableInterface(IfIndex);
            break;
        }

        case RIS_INTERFACE_DISABLED:
        {
            Error = DisableInterface(IfIndex);
            break;
        }

    }

    return Error;
}

DWORD
WINAPI
IgmpMibIfConfigSize(
    PIGMP_MIB_IF_CONFIG pConfig
    )
{
    DWORD Size = sizeof(IGMP_MIB_IF_CONFIG);

    if (pConfig->NumStaticGroups && !IS_CONFIG_IGMP_V3(pConfig)) {
        Size += pConfig->NumStaticGroups*sizeof(IGMP_STATIC_GROUP);
    }
    else if (pConfig->NumStaticGroups && IS_CONFIG_IGMP_V3(pConfig)) {

        DWORD i;
        PSTATIC_GROUP_V3 pStaticGroupV3 = GET_FIRST_STATIC_GROUP_V3(pConfig);
                                
        for (i=0;  i<pConfig->NumStaticGroups;  i++) {
            DWORD EntrySize = sizeof(STATIC_GROUP_V3)
                                + pStaticGroupV3->NumSources*sizeof(IPADDR);
            Size += EntrySize;            
            pStaticGroupV3 = (PSTATIC_GROUP_V3)
                             ((PCHAR)(pStaticGroupV3) + EntrySize);
        }
    }

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\fltrdrvr\kdext\ipfext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ipfext.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

//
// globals
//
#include <ntverp.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock.h>

#include "..\defs.h"
#include <ipexport.h>
#include <ipfilter.h>
#include <filter.h>
#include <ipfltdrv.h>

BOOL
ReadFilterDriver(
                 PFILTER_DRIVER pIf
                 );

BOOL
ReadCache(
          DWORD dwIndex, 
          PFILTER_INCACHE pInCache,
          PFILTER_OUTCACHE pOutCache
          );

BOOL
ReadFilter(
           PFILTER_INTERFACE pIf,
           DWORD dwIndex,
           PFILTER pFilter,
           BOOL bInFilter
           );

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                 ChkTarget;
INT                     Item;

DWORD      g_dwFilterInfo;
DWORD      g_dwIfLink;
DWORD      g_dwInIndex,g_dwOutIndex;
DWORD      g_dwCacheSize;
FILTER_INTERFACE g_if;

#define CHECK_SIZE(dwRead,dwReq,bRes){                                        \
        if((dwRead) < (dwReq))                                                \
        {                                                                     \
            dprintf("Requested %s (%d) read %d \n",#dwReq,dwReq,dwRead);      \
            dprintf("Error in %s at %d\n",__FILE__,__LINE__);                 \
            bRes = FALSE;                                                     \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            bRes = TRUE;                                                      \
        }                                                                     \
    }

#define READ_MEMORY_ERROR                                                     \
        dprintf("Error in ReadMemory() in %s at line %d\n",__FILE__,__LINE__);


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
    
    g_dwIfLink = 0;
    g_dwInIndex = g_dwOutIndex = 0;
    
    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
             );
}

VOID
CheckVersion(
             VOID
             )
{
    
    return;
    
#if DBG
    if ((SavedMajorVersion isnot 0x0c) or (SavedMinorVersion isnot VER_PRODUCTBUILD)) 
    {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion isnot 0x0f) || (SavedMinorVersion isnot VER_PRODUCTBUILD)) 
    {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
                    VOID
                    )
{
    return &ApiVersion;
}

//
// Exported functions
//
DECLARE_API( help )

/*++

Routine Description:

    Command help for IP Filter debugger extensions.

Arguments:

    None

Return Value:

    None
    
--*/

{
    dprintf("\n\tIP Filter debugger extension commands:\n\n");
    dprintf("\tNumIf                 - Print the number of interfaces in the filter\n");
    dprintf("\tIfByIndex <index>     - Print the ith interface in the list\n");
    dprintf("\tIfByAddr <ptr>        - Print the interface with given address\n");
    dprintf("\tIfEnumInit            - Inits the If enumerator (to 0)\n");
    dprintf("\tNextIf                - Print the next If enumerated\n");
    dprintf("\tPrintCache <index>    - Print the contents of the ith cache bucket\n");
    dprintf("\tCacheSize             - Print the current cache size\n");
    dprintf("\tPrintPacket           - Dump a packet header and first DWORD of data\n");
    dprintf("\tFilterEnumInit <ptr>  - Inits the in and out filter enumerator for If at addr\n");
    dprintf("\tNextInFilter          - Print the next In Filter\n");
    dprintf("\tNextOutFilter         - Print the next Out Filter\n");
    dprintf("\n\tCompiled on " __DATE__ " at " __TIME__ "\n" );
    return;
}

DECLARE_API( init )
{
    DWORD dwBytesRead, dwCacheSize;
    BOOL bResult;
    
    dwCacheSize = GetExpression("ipfltdrv!g_dwCacheSize");
    if(dwCacheSize is 0)
    {
        dprintf("Couldnt get g_dwCacheSize address from filter driver\n");
        return;
    }
    
    
    if(!ReadMemory(dwCacheSize,&g_dwCacheSize,sizeof(DWORD),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",dwCacheSize);
        READ_MEMORY_ERROR;
        return;
    }
    
    CHECK_SIZE(dwBytesRead,sizeof(DWORD),bResult);
    
    if(!bResult)
    {
        return;
    }
    
    g_dwFilterInfo = GetExpression("ipfltdrv!g_filters");

    if(g_dwFilterInfo is 0)
    {
        dprintf("Couldnt load the g_filters address from the filter driver\n");
        return;
    }
    else
    {
        dprintf("g_filters = %x\n",g_dwFilterInfo);
    }
    
    dprintf("Extension DLL successfully initialized\n");
    
    return;
}

DECLARE_API( numif )
{
    DWORD dwNum = 0,dwBytesRead;
    DWORD dwCurrentList;
    FILTER_DRIVER filter;
    LIST_ENTRY leList;
    BOOL bResult;
    
    if(!ReadFilterDriver(&filter))
    {
        return;
    }
    
    dwCurrentList = (DWORD)filter.leIfListHead.Flink;
    
    while(dwCurrentList isnot (g_dwFilterInfo + FIELD_OFFSET(FILTER_DRIVER,leIfListHead)))
    {
        if(!ReadMemory(dwCurrentList,&leList,sizeof(LIST_ENTRY),&dwBytesRead))
        {
            dprintf("Attempted read at %x\n",dwCurrentList);
            READ_MEMORY_ERROR;
            return;
        }
        
        CHECK_SIZE(dwBytesRead,sizeof(LIST_ENTRY),bResult);
        
        if(!bResult)
        {
            return;
        }
        
        dwNum++;
        dwCurrentList = (DWORD)leList.Flink;
    }
    
    dprintf("Currently there are %d interfaces\n",dwNum);
    
    return;
}


DECLARE_API( ifbyindex )
{
    DWORD dwNum = 0,dwBytesRead;
    DWORD dwCurrentList,dwIndex;
    PFILTER_INTERFACE pIf = NULL;
    FILTER_INTERFACE If;
    FILTER_DRIVER filter;
    LIST_ENTRY leList;
    BOOL bResult;
   
    if(args[0] is 0)
    {
        dprintf("!ipfext.ifbyindex <DWORD>\n");
        return;
    } 
    
    sscanf(args,"%d",&dwIndex);
    
    dprintf("Printing interface# %d\n",dwIndex);
   
    if(!ReadFilterDriver(&filter))
    {
        return;
    }
    
    dwCurrentList = (DWORD)filter.leIfListHead.Flink;
    
    while(dwCurrentList isnot (g_dwFilterInfo + FIELD_OFFSET(FILTER_DRIVER,leIfListHead)))
    {
        if(!ReadMemory(dwCurrentList,&leList,sizeof(LIST_ENTRY),&dwBytesRead))
        {
            dprintf("Attempted read at %x\n",dwCurrentList);
            READ_MEMORY_ERROR;
            return;
        }
        
        CHECK_SIZE(dwBytesRead,sizeof(LIST_ENTRY),bResult);
        
        if(!bResult)
        {
            return;
        }
        
        dwNum++;
        if(dwNum is dwIndex)
        {
            pIf = CONTAINING_RECORD((PLIST_ENTRY)dwCurrentList,FILTER_INTERFACE,leIfLink);
            break;
        }
        
        dwCurrentList = (DWORD)leList.Flink;
    }
    
    if(pIf is NULL)
    {
        dprintf("Interface not found\n");
        return;
    }
    
    if(!ReadMemory((DWORD)pIf,&If,sizeof(FILTER_INTERFACE),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",(DWORD)pIf);
        READ_MEMORY_ERROR;
        return;
    }
    
    CHECK_SIZE(dwBytesRead,sizeof(FILTER_INTERFACE),bResult);
    if(!bResult)
    {
        return;
    }
    
    dprintf("Address of Interface:\t%x\n",pIf);
    dprintf("Next Interface at:\t%x\n",If.leIfLink);
    dprintf("Number Input Filters:\t%d\n",If.dwNumInFilters);
    dprintf("Number Output Filters:\t%d\n",If.dwNumOutFilters);
    dprintf("Input action:\t%s\n",(If.eaInAction is DROP)?"DROP":"FORWARD");
    dprintf("Output action:\t%s\n",(If.eaOutAction is DROP)?"DROP":"FORWARD");
    dprintf("Router Manager Context:\t%x\n",If.pvRtrMgrContext);
    dprintf("Router Manager Index:\t%d\n",If.dwRtrMgrIndex);
    
    return;
}

DECLARE_API( ifbyaddr )
{
    DWORD pIf;
    FILTER_INTERFACE If;
    DWORD dwBytesRead;
    BOOL bResult;

    if(args[0] is 0)
    {
        dprintf("!ipfext.ifbyaddr <DWORD>\n");
        return;
    }

    sscanf(args,"%lx",&pIf);

    dprintf("Printing interface at %x\n",pIf); 

    if(!ReadMemory(pIf,&If,sizeof(FILTER_INTERFACE),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",pIf);
        READ_MEMORY_ERROR;
        return;
    }
    
    CHECK_SIZE(dwBytesRead,sizeof(FILTER_INTERFACE),bResult);
      
    if(!bResult)
    {
        return;
    }
    
    dprintf("Next Interface at:\t%x\n",If.leIfLink);
    dprintf("Number Input Filters:\t%d\n",If.dwNumInFilters);
    dprintf("Number Output Filters:\t%d\n",If.dwNumOutFilters);
    dprintf("Input action:\t%s\n",(If.eaInAction is DROP)?"DROP":"FORWARD");
    dprintf("Output action:\t%s\n",(If.eaOutAction is DROP)?"DROP":"FORWARD");
    dprintf("Router Manager Context:\t%x\n",If.pvRtrMgrContext);
    dprintf("Router Manager Index:\t%d\n",If.dwRtrMgrIndex);
    
    return; 
}

DECLARE_API( ifenuminit )
{
    FILTER_DRIVER filter;
    
    g_dwIfLink = 0;
   
    if(!ReadFilterDriver(&filter))
    {
        return;
    }
    
    if(filter.leIfListHead.Flink is (PLIST_ENTRY)(g_dwFilterInfo + 
                                                  FIELD_OFFSET(FILTER_DRIVER,leIfListHead)))
    {
        dprintf("No interfaces\n");
        return;
    }
    
    g_dwIfLink = (DWORD)filter.leIfListHead.Flink;
    
    dprintf("Enumerator Initialized\n");
    
    return;
}
     
DECLARE_API( nextif )
{
    PFILTER_INTERFACE pIf;
    FILTER_INTERFACE If;
    BOOL bResult;
    DWORD dwBytesRead;
 
    if(g_dwIfLink is 0)
    {
        dprintf("Enumerator not initialized");
        return;
    }
    
    if(g_dwIfLink is (g_dwFilterInfo + FIELD_OFFSET(FILTER_DRIVER,leIfListHead)))
    {
        dprintf("No more interfaces to enumerate\n");
        return;
    }
    
    pIf = CONTAINING_RECORD((PLIST_ENTRY)g_dwIfLink,FILTER_INTERFACE,leIfLink); 

    if(!ReadMemory((DWORD)pIf,&If,sizeof(FILTER_INTERFACE),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",(DWORD)pIf);
        READ_MEMORY_ERROR;
        return;
    }
    
    CHECK_SIZE(dwBytesRead,sizeof(FILTER_INTERFACE),bResult);

    if(!bResult)
    {
        return;
    }
    
    dprintf("Address of Interface:\t%x\n",pIf);
    dprintf("Next Interface at:\t%x\n",If.leIfLink);
    dprintf("Number Input Filters:\t%d\n",If.dwNumInFilters);
    dprintf("Number Output Filters:\t%d\n",If.dwNumOutFilters);
    dprintf("Input action:\t%s\n",(If.eaInAction is DROP)?"DROP":"FORWARD");
    dprintf("Output action:\t%s\n",(If.eaOutAction is DROP)?"DROP":"FORWARD");
    dprintf("Router Manager Context:\t%x\n",If.pvRtrMgrContext);
    dprintf("Router Manager Index:\t%d\n",If.dwRtrMgrIndex);
    
    g_dwIfLink = (DWORD)If.leIfLink.Flink;
    
    return;
}

DECLARE_API( printcache )
{
    struct in_addr addr;
    BYTE bIpAddr1[20], bIpAddr2[20];
    FILTER_DRIVER filter;
    DWORD dwBytesRead;
    FILTER_INCACHE inCache;
    FILTER_OUTCACHE outCache;
    DWORD dwIndex;
    
    if(args[0] is 0)
    {
        dprintf("!ipfext.printcache <DWORD>\n");
        return;
    }

    sscanf(args,"%d",&dwIndex);

    if(dwIndex >= g_dwCacheSize)
    {
        printf("Cache size is %\n",g_dwCacheSize);
        return;
    }
    
    if(!ReadCache(dwIndex,&inCache,&outCache))
    {
        return;
    }
    
    dprintf("In Cache for Bucket %d\n",dwIndex);
    
    addr.s_addr = inCache.uliSrcDstAddr.LowPart;
    strcpy(bIpAddr1,inet_ntoa(addr));
    addr.s_addr = inCache.uliSrcDstAddr.HighPart;
    strcpy(bIpAddr2,inet_ntoa(addr));
    
    dprintf("Addr - Source:\t%s\tDest:\t%d\n",bIpAddr1,bIpAddr2);
    dprintf("Protocol:\t%d\n",inCache.uliProtoSrcDstPort.LowPart);
    dprintf("Port - Source:\t%hd\tDest:\t%hd\n",
            LOWORD(inCache.uliProtoSrcDstPort.HighPart),
            HIWORD(inCache.uliProtoSrcDstPort.HighPart));
    dprintf("Context - In:\t%x\tOut:\t%x\n",
            inCache.pInContext,
            inCache.pOutContext);
    dprintf("Action - In:\t%s\tOut:\t%s\n",
            ((inCache.eaInAction is DROP)?"DROP":"FORWARD"),
            ((inCache.eaOutAction is DROP)?"DROP":"FORWARD"));
    
    dprintf("Out Cache for Bucket %d\n",dwIndex);
    
    addr.s_addr = outCache.uliSrcDstAddr.LowPart;
    strcpy(bIpAddr1,inet_ntoa(addr));
    addr.s_addr = outCache.uliSrcDstAddr.HighPart;
    strcpy(bIpAddr2,inet_ntoa(addr));
    
    dprintf("Addr - Source:\t%s\tDest:\t%d\n",bIpAddr1,bIpAddr2);
    dprintf("Protocol:\t%d\n",outCache.uliProtoSrcDstPort.LowPart);
    dprintf("Port - Source:\t%hd\tDest:\t%hd\n",
            LOWORD(outCache.uliProtoSrcDstPort.HighPart),
            HIWORD(outCache.uliProtoSrcDstPort.HighPart));
    dprintf("Context:\t%x\n",outCache.pOutContext);
    dprintf("Action:\t%s\n",((outCache.eaOutAction is DROP)?"DROP":"FORWARD"));
    
    return;
}

DECLARE_API( cachesize )
{
    dprintf("Cache size is %d\n",g_dwCacheSize);
    return;
}


DECLARE_API( printpacket )
{
    DWORD     dwHdrAddr,dwBytesRead,i,j,k;
    BYTE      pPacket[sizeof(IPHeader)+2*sizeof(DWORD)];
    BOOL      bResult;

    if(args[0] is 0)
    {
        dprintf("!ipfext.printpacket <DWORD>\n");
        return;
    }
    
    sscanf(args,"%lx",&dwHdrAddr);

    if(!ReadMemory(dwHdrAddr,pPacket,sizeof(IPHeader)+2*sizeof(DWORD),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",dwHdrAddr);
        READ_MEMORY_ERROR;
        return;
    } 

    CHECK_SIZE(dwBytesRead,sizeof(IPHeader)+2*sizeof(DWORD),bResult);
    
    if(!bResult)
    {
        return;
    }
    
    k = 0;

    for(i = 0; i < 5; i++)
    {
        for(j = 0; j < 4; j++)
        {
            dprintf("%02x",pPacket[k++]);
        }
        dprintf("\n");
    }
   
    dprintf("--Data--\n");
    dprintf("%02x%02x%02x%02x\n",pPacket[k],pPacket[k+1],pPacket[k+2],pPacket[k+3]); 

    return;
}

DECLARE_API( filterenuminit )
{
    DWORD  pIf;
    DWORD   dwBytesRead;
    BOOL bResult;
    
    if(args[0] is 0)
    {
        dprintf("!ipfext.filterenuminit <DWORD>\n");
        return;
    }

    sscanf(args,"%lx",&pIf);

    dprintf("Enum for interface at %x\n",pIf);
    
    g_dwInIndex = g_dwOutIndex = 0;
    
    if(!ReadMemory(pIf,&g_if,sizeof(FILTER_INTERFACE),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",pIf);
        READ_MEMORY_ERROR;
        return;
    }
    
    CHECK_SIZE(dwBytesRead,sizeof(FILTER_INTERFACE),bResult);
    
    if(!bResult)
    {
        return;
    }
     
    dprintf("Enumerator Initialized\n");
    
    return;
}

DECLARE_API( nextinfilter )
{
    struct in_addr addr;
    BYTE bIpAddr1[20], bIpAddr2[20];
    FILTER inFilter;
    
    if(g_dwInIndex >= g_if.dwNumInFilters)
    {
        dprintf("End of in filter set\n");
        return;
    }
    
    if(!ReadFilter(&g_if,g_dwInIndex,&inFilter,TRUE))
    {
        return;
    }

    addr.s_addr = inFilter.uliSrcDstAddr.LowPart;
    strcpy(bIpAddr1,inet_ntoa(addr));
    addr.s_addr = inFilter.uliSrcDstAddr.HighPart;
    strcpy(bIpAddr2,inet_ntoa(addr));
    
    dprintf("Addr - Source:\t%s\t\tDest:\t%d\n",bIpAddr1,bIpAddr2);
    
    addr.s_addr = inFilter.uliSrcDstMask.LowPart;
    strcpy(bIpAddr1,inet_ntoa(addr));
    addr.s_addr = inFilter.uliSrcDstMask.HighPart;
    strcpy(bIpAddr2,inet_ntoa(addr));
    
    dprintf("Mask - Source:\t%s\t\tDest:\t%d\n",bIpAddr1,bIpAddr2);
    dprintf("Protocol:\t%d\n",inFilter.uliProtoSrcDstPort.LowPart);
    dprintf("Port - Source:\t%hd\tDest:\t%hd\n",
             LOWORD(inFilter.uliProtoSrcDstPort.HighPart),
             HIWORD(inFilter.uliProtoSrcDstPort.HighPart));
    
    dprintf("Protocol Mask:\t%x\n",inFilter.uliProtoSrcDstMask.LowPart);
    dprintf("Port Mask:\t%x\n",inFilter.uliProtoSrcDstMask.HighPart);
    
    g_dwInIndex++;
    
    return;
}

DECLARE_API( nextoutfilter )
{
    struct in_addr addr;
    BYTE bIpAddr1[20], bIpAddr2[20];
    FILTER outFilter;
    
    if(g_dwOutIndex >= g_if.dwNumOutFilters)
    {
        dprintf("End of out filter set\n");
        return;
    }

    if(!ReadFilter(&g_if,g_dwOutIndex,&outFilter,FALSE))
    {
        return;
    }

    addr.s_addr = outFilter.uliSrcDstAddr.LowPart;
    strcpy(bIpAddr1,inet_ntoa(addr));
    addr.s_addr = outFilter.uliSrcDstAddr.HighPart;
    strcpy(bIpAddr2,inet_ntoa(addr));
    
    dprintf("Addr - Source:\t%s\tDest:\t%d\n",bIpAddr1,bIpAddr2);
    
    addr.s_addr = outFilter.uliSrcDstMask.LowPart;
    strcpy(bIpAddr1,inet_ntoa(addr));
    addr.s_addr = outFilter.uliSrcDstMask.HighPart;
    strcpy(bIpAddr2,inet_ntoa(addr));
    
    dprintf("Mask - Source:\t%s\tDest:\t%d\n",bIpAddr1,bIpAddr2);

    
    dprintf("Protocol:\t%d\n",outFilter.uliProtoSrcDstPort.LowPart);
    dprintf("Port - Source:\t%hd\tDest:\t%hd\n",
             LOWORD(outFilter.uliProtoSrcDstPort.HighPart),
             HIWORD(outFilter.uliProtoSrcDstPort.HighPart));
    
    dprintf("Protocol Mask:\t%x\n",outFilter.uliProtoSrcDstMask.LowPart);
    dprintf("Port Mask:\t%x\n",outFilter.uliProtoSrcDstMask.HighPart);
    
    g_dwOutIndex++;

    return;
}

BOOL
ReadCache(
          DWORD dwIndex, 
          PFILTER_INCACHE pInCache,
          PFILTER_OUTCACHE pOutCache
          )
{
    FILTER_DRIVER filter;
    DWORD dwCacheAddr,dwCacheAddrAddr;
    DWORD dwBytesRead;
    BOOL bResult;
 
    if(!ReadFilterDriver(&filter))
    {
        return FALSE;
    }
    
    dwCacheAddrAddr = (DWORD)(filter.pInCache) + (dwIndex * sizeof(PFILTER_INCACHE));
    
    if(!ReadMemory(dwCacheAddrAddr,&dwCacheAddr,sizeof(DWORD),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",dwCacheAddrAddr);
        READ_MEMORY_ERROR;
        return FALSE;
    } 
     
    CHECK_SIZE(dwBytesRead,sizeof(DWORD),bResult);
    
    if(!bResult)
    {
        return FALSE;
    }
       
    if(!ReadMemory(dwCacheAddr,pInCache,sizeof(FILTER_INCACHE),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",dwCacheAddr);
        READ_MEMORY_ERROR;
        return FALSE;
    }

    CHECK_SIZE(dwBytesRead,sizeof(FILTER_INCACHE),bResult);
    
    if(!bResult)
    {
        return FALSE;
    }
    
    dwCacheAddrAddr = (DWORD)(filter.pOutCache) + (dwIndex * sizeof(PFILTER_OUTCACHE));
    
    if(!ReadMemory(dwCacheAddrAddr,&dwCacheAddr,sizeof(DWORD),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",dwCacheAddrAddr);
        READ_MEMORY_ERROR;
        return FALSE;
    } 
     
    CHECK_SIZE(dwBytesRead,sizeof(DWORD),bResult);
    
    if(!bResult)
    {
        return FALSE;
    }
      
    if(!ReadMemory(dwCacheAddr,pOutCache,sizeof(FILTER_OUTCACHE),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",dwCacheAddr);
        READ_MEMORY_ERROR;
        return FALSE;
    }
    
    CHECK_SIZE(dwBytesRead,sizeof(FILTER_OUTCACHE),bResult);
    
    if(!bResult)
    {
        return FALSE;
    }
    
    return TRUE;
}
    
    
BOOL
ReadFilterDriver(
                 PFILTER_DRIVER pIf
                 )
{
    DWORD dwBytesRead;
    BOOL bResult;
    
    if(!ReadMemory(g_dwFilterInfo,pIf,sizeof(FILTER_DRIVER),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",g_dwFilterInfo);
        READ_MEMORY_ERROR;
        return FALSE;
    }
    
    CHECK_SIZE(dwBytesRead,sizeof(FILTER_DRIVER),bResult);
    
    if(!bResult)
    {
        return FALSE;
    }
    
    return TRUE;
}

BOOL
ReadFilter(
           PFILTER_INTERFACE pIf,
           DWORD dwIndex,
           PFILTER pFilter,
           BOOL bInFilter
           )
{
    DWORD dwFilterAddr;
    DWORD dwBytesRead;
    BOOL bResult;

    if(bInFilter)
    {
        dwFilterAddr = (DWORD)(pIf->pInFilterSet) + (dwIndex * sizeof(FILTER));
    }
    else
    {
        dwFilterAddr = (DWORD)(pIf->pOutFilterSet) + (dwIndex * sizeof(FILTER));
    }
    
    if(!ReadMemory(dwFilterAddr,pFilter,sizeof(FILTER),&dwBytesRead))
    {
        dprintf("Attempted read at %x\n",dwFilterAddr);
        READ_MEMORY_ERROR;
        return FALSE;
    }
    
    CHECK_SIZE(dwBytesRead,sizeof(FILTER),bResult);
    
    if(!bResult)
    {
        return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\igmptimer.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: igmptimer.c
//
// Abstract: This module implements the igmptimer
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================



#include "pchigmp.h"

DWORD ksldel = 0; //deldel

//DebugCheck //ksltodo
//DWORD MyDebug = 0x0;
DWORD MyDebug = 0x0; //DebugScanTimerQueue while running
DWORD DebugIgmpVersion = 0x05;
ULONG g_DebugPrint = 0; //flag to enable DebugPrintTimerQueue while running

DWORD DEBUG_CHECK_LOW_INDEX_ARRAY[100][2]; //deldel
DWORD DebugIgmpIndex; //deldel


#if DEBUG_TIMER_LEVEL & DEBUG_TIMER_TIMERID
    DWORD TimerId =0;
#endif
ULONG g_Fire = 0; // global variable



//------------------------------------------------------------------------------
//
// FUNCTION PROTOTYPES USED ONLY IN THIS FILE
//

VOID
SetNextTime(
    DWORD        dwLowIndex
    );

VOID
ResyncTimerBuckets(
    LONGLONG llCurTime
    );
VOID
InsertTimerInSortedList(
    PIGMP_TIMER_ENTRY    pteNew,
    PLIST_ENTRY          pHead
    );


//------------------------------------------------------------------------------
//
// #DEFINES USED ONLY IN THIS FILE
//

//
//approx 16 secs in each bucket: 
//it is approx not accurate as I divide by 2^10 instead of 1000
//TIMER_BUCKET_GRANULARITY should be 2^TIMER_BUCKET_GRANULARITY_SHIFT
//
#define TIMER_BUCKET_GRANULARITY        16
#define TIMER_BUCKET_GRANULARITY_SHIFT   4


#define SEC_CONV_SHIFT                  10
#define TIMER_BUCKET_GRANULARITY_ABS    \
        ((LONGLONG) ((LONGLONG)1 << (TIMER_BUCKET_GRANULARITY_SHIFT + SEC_CONV_SHIFT) ))


#define MAP_TO_BUCKET(dwBucket, ilTime) \
    dwBucket = (DWORD) (((ilTime)-g_TimerStruct.SyncTime) \
                        >> (TIMER_BUCKET_GRANULARITY_SHIFT+SEC_CONV_SHIFT)); \
    dwBucket = dwBucket>NUM_TIMER_BUCKETS-1? NUM_TIMER_BUCKETS-1:  dwBucket


// I fire a timer even if it is set to 10 millisec in the future.
#define FORWARD_TIMER_FIRED 10

//------------------------------------------------------------------------------


ULONG
QueryRemainingTime(
    PIGMP_TIMER_ENTRY pte,
    LONGLONG        llCurTime
    )
{
    if (llCurTime==0)
        llCurTime = GetCurrentIgmpTime();
    return llCurTime>pte->Timeout ? 0 : (ULONG)(pte->Timeout-llCurTime);
}


VOID
DebugCheckLowTimer(
    DWORD Flags
    )
{
    PIGMP_TIMER_GLOBAL    ptg = &g_TimerStruct;
    DWORD i;
    PIGMP_TIMER_ENTRY     pte, pteMin;
    LONGLONG              ilMinTime;
    PLIST_ENTRY           pHead, ple;
    BOOL                  bMatchedTimeout=FALSE;
    
    Trace0(ENTER1, "In _DebugCheckLowTimer");
    
    if (ptg->NumTimers==0)
        return;

    if (g_TimerStruct.TableLowIndex>64 ) {
        CALL_MSG("1");
        return;
    }
    
    if (IsListEmpty(&ptg->TimesTable[ptg->TableLowIndex])){
        CALL_MSG("2");
        return;
    }
        
    for (i=0;  i<=ptg->TableLowIndex&&i<64;  i++) {
    
        pHead = &ptg->TimesTable[i];
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
            CHECK_TIMER_SIGNATURE(pte);

            if (Flags & 1) {
                if (pte->Timeout<ptg->WTTimeout) {
                    CALL_MSG("3");
                    return;
                }
                if (pte->Timeout==ptg->WTTimeout)
                    bMatchedTimeout = TRUE;
            }
            if (i<ptg->TableLowIndex) {
                CALL_MSG("4");
                return;
            }
        }

    }
    if ((Flags & 1) && !bMatchedTimeout && ksldel)
    {
        DebugPrintTimerQueue();
        CALL_MSG("5");
    }
        
    return;
}



//------------------------------------------------------------------------------
//          _InsertTimer
//
// Inserts a timer into the local timer queue. Time should always be relative.
//
// Locks: Assumes lock taken on ptg->CS
// LowIndex might not be correct
//------------------------------------------------------------------------------

DWORD
InsertTimer (
    PIGMP_TIMER_ENTRY    pte,
    LONGLONG             llNewTime,
    BOOL                 bResync, //false if called within callback
    BOOL                 bDbg
    )
{
    LONGLONG             llCurTime = GetCurrentIgmpTime();
    PIGMP_TIMER_GLOBAL   ptg;
    DWORD                dwBucket, Error = NO_ERROR;
    

    CHECK_TIMER_SIGNATURE(pte);
    CHECK_IF_ACQUIRED_TIMER_LOCK();
    DebugCheckLowTimer(bResync);//deldel
    DEBUG_CHECK_LOW_INDEX(1);//deldel

    if (pte->Status & TIMER_STATUS_ACTIVE) {
        UpdateLocalTimer(pte, llNewTime, bDbg);
        return NO_ERROR;
    }

    // deldel
    if (MyDebug&0x1) DebugScanTimerQueue(1);
    


    
    Trace0(ENTER1, "_InsertTimer()");


    // print the queue before inserting the timer
    
    #if DEBUG_TIMER_INSERTTIMER1
        Trace0(TIMER1, "Printing Timer Queue before InsertTimer");
        DebugPrintTimerQueue();
    #endif


    ptg = &g_TimerStruct;
    


    // convert relative time to absolute time
    llNewTime += llCurTime;

    
    pte->Timeout = llNewTime;

    
    MAP_TO_BUCKET(dwBucket, pte->Timeout);


    // print info about the timer being inserted
    
    #if DEBUG_TIMER_ACTIVITY
    {    
        DWORD   TmpdwBucket, dwDiffTime;
        CHAR    str1[20], str2[20];

        MAP_TO_BUCKET(TmpdwBucket, pte->Timeout);
        GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

        Trace7(TIMER, "Inserting timer  <%d><%d><%d> Timeout:%lu   <%s> "
                "<%s> Status:%d", TmpdwBucket, pte->Id, pte->Id2, dwDiffTime, 
                str1, str2, pte->Status);
    }
    #endif

    
    //
    // insert timer in appropriate list
    //
    
    if (dwBucket==0) {    // bucket 0 contains a sorted list
    
        InsertTimerInSortedList(pte, &ptg->TimesTable[0]);
    }
    else {
        InsertTailList(&ptg->TimesTable[dwBucket], &pte->Link);

    }

    DEBUG_CHECK_LOW_INDEX(2);//deldel


    ptg->NumTimers++;
    ptg->TableLowIndex = ptg->TableLowIndex<dwBucket
                            ? ptg->TableLowIndex : dwBucket;

    DEBUG_CHECK_LOW_INDEX(3);//deldel

    //resynchronize timer list
    
    if (bResync) {
        if ( (ptg->TableLowIndex!=0) 
                && (ptg->SyncTime + TIMER_BUCKET_GRANULARITY_ABS < llCurTime) ) {
            
            ResyncTimerBuckets(llCurTime);
        }
    }

    DEBUG_CHECK_LOW_INDEX(4);//deldel

    //
    // if time being inserted is lower than the minimum, then update wait timer
    //
    if ((IS_TIMER_INFINITE(ptg->WTTimeout)) || (pte->Timeout<=ptg->WTTimeout)) {
        ptg->WTTimeout = pte->Timeout;

        if (!IS_TIMER_INFINITE(ptg->WTTimeout)) {

            BOOL bSuccess ;

            bSuccess = ChangeTimerQueueTimer(ptg->WTTimer, ptg->WTTimer1,
                        llCurTime<ptg->WTTimeout
                            ?(ULONG) ((ptg->WTTimeout - llCurTime))
                            : 0,
                        1000000                   // set a periodic timer
                        );
            
            if (!bSuccess) {
                Error = GetLastError();
                Trace1(ERR, "ChangeTimerQueueTimer returned error:%d", Error);
                IgmpAssertOnError(FALSE);
            }
            else {
                #if DEBUG_TIMER_ACTIVITY
                Trace1(TIMER1, "ChangeTimerQueueTimer set to %lu",
                            (ULONG) ((ptg->WTTimeout - llCurTime))/1000);
                #if DEBUG_TIMER_ID
                g_Fire = (ULONG) ((ptg->WTTimeout - llCurTime)/1000);
                #endif
                #endif
            }
        }
    }

    pte->Status = TIMER_STATUS_ACTIVE;


    #if DEBUG_TIMER_INSERTTIMER2
        if (bDbg||g_DebugPrint) {
            Trace0(TIMER1, "   ");
            Trace0(TIMER1, "Printing Timer Queue after _InsertTimer");
            DebugPrintTimerQueue();
        }
    #endif


    //kslksl
    if (MyDebug&0x2) DebugScanTimerQueue(2);
    DebugCheckLowTimer(bResync);//deldel
    DEBUG_CHECK_LOW_INDEX(5);//deldel
    
    Trace0(LEAVE1, "Leaving _InsertTimer()");
    return NO_ERROR;
    
} //end _InsertTimer



//------------------------------------------------------------------------------
//            _UpdateLocalTimer
//
// Change the time in a timer structure and (re)insert it in the timer queue.
// Locks: Assumes lock on the global timer
// LowIndex might not be correct
//------------------------------------------------------------------------------

VOID    
UpdateLocalTimer (
    PIGMP_TIMER_ENTRY    pte,
    LONGLONG             llNewTime,
    BOOL                bDbgPrint
    )
{

    Trace0(ENTER1, "_UpdateLocalTimer():");

    CHECK_TIMER_SIGNATURE(pte);
    CHECK_IF_ACQUIRED_TIMER_LOCK();
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(6);//deldel

    // print info about the timer being updated
    
    #if DEBUG_TIMER_ACTIVITY
    {    
        DWORD       dwBucket, dwDiffTime;
        CHAR        str1[20], str2[20];
        LONGLONG    llCurTime = GetCurrentIgmpTime();

        
        MAP_TO_BUCKET(dwBucket, pte->Timeout);
        GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

        Trace0(TIMER, "   \n");
        Trace8(TIMER, "Updating timer  <%d><%d><%d> Timeout:%lu   <%s> <%s> "
                    "to %d Status:%d\n", dwBucket, pte->Id, pte->Id2, dwDiffTime,
                    str1, str2, (DWORD)llNewTime, pte->Status);
    }
    #endif


    // first remove the timer
    
    if (pte->Status&TIMER_STATUS_ACTIVE) {
        RemoveTimer(pte, DBG_N);
    }
    DEBUG_CHECK_LOW_INDEX(7);//deldel


    // now insert the timer back into the timer queue. Resync flag is set
    
    InsertTimer(pte, llNewTime, TRUE, DBG_N);

    #if DEBUG_TIMER_UPDATETIMER1
        if (bDbgPrint||g_DebugPrint) {
            Trace0(TIMER1, "   ");
            Trace0(TIMER1, "Printing Timer Queue after _UpdateTimer");
            DebugPrintTimerQueue();
        }
    #endif

    //kslksl
    if (MyDebug&0x4) DebugScanTimerQueue(4);
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(8);//deldel

    Trace0(LEAVE1, "_UpdateLocalTimer()");
    return;    
}




//------------------------------------------------------------------------------
//            _RemoveTimer
//
// Removes the timer from the list. Changes the status of the timer to CREATED.
// Assumes global timer lock.
// LowIndex might not be correct
//------------------------------------------------------------------------------

VOID
RemoveTimer (
    PIGMP_TIMER_ENTRY    pte,
    BOOL    bDbg
    )
{
    LONGLONG            llCurTime = GetCurrentIgmpTime();
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    

    Trace0(ENTER1, "_RemoveTimer()");

    CHECK_TIMER_SIGNATURE(pte);
    CHECK_IF_ACQUIRED_TIMER_LOCK();
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(9);//deldel

    // print info about the timer being removed
    
    #if DEBUG_TIMER_ACTIVITY
    {    
        DWORD   dwBucket, dwDiffTime;
        CHAR    str1[20], str2[20];

        
        MAP_TO_BUCKET(dwBucket, pte->Timeout);
        GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

        Trace7(TIMER, "Removing timer  <%d><%d><%d> Timeout:%lu   <%s> <%s> "
                    "Status:%d", dwBucket, pte->Id, pte->Id2, dwDiffTime, str1, 
                    str2, pte->Status);
    }
    #endif
    


    // remove the timer from the timer queue and decrement the number of timers
    
    RemoveEntryList(&pte->Link);
    ptg->NumTimers--;
    


    // reset the minimum timeout for the timer queue, if this timer was the min
    
    if (pte->Timeout==ptg->WTTimeout) {
        
        SetNextTime(ptg->TableLowIndex);
    }
    DEBUG_CHECK_LOW_INDEX(10);//deldel


    // reset the timer status to created
    
    pte->Status = TIMER_STATUS_CREATED;


    // print timer queue
    
    #if DEBUG_TIMER_REMOVETIMER2
        if (bDbg||g_DebugPrint) {
            Trace0(TIMER1, "   ");
            Trace0(TIMER1, "Printing Timer Queue after _RemoveTimer");
            DebugPrintTimerQueue();
        }
    #endif

    //kslksl
    if (MyDebug&0x8) DebugScanTimerQueue(8);

    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(11);//deldel
    
    Trace0(LEAVE1, "Leaving _RemoveTimer()");
    return;
}


//------------------------------------------------------------------------------
//          _SetNextTime
// called when a timer==WTTimeout has been removed or fired,used to set the
// next min time.
// LowIndex might not be correct
//------------------------------------------------------------------------------
VOID
SetNextTime (
    DWORD        dwLowIndex
    )
{
    PIGMP_TIMER_GLOBAL    ptg = &g_TimerStruct;
    PIGMP_TIMER_ENTRY     pte, pteMin=NULL;
    LONGLONG              ilMinTime;
    PLIST_ENTRY           pHead, ple;
    DWORD                 Error = NO_ERROR;
    LONGLONG              llCurTime=GetCurrentIgmpTime();

    //kslksl
    //Trace0(TIMER1, "entering _SetNextTime()");
    DEBUG_CHECK_LOW_INDEX(12);//deldel

    //kslksl
    if (MyDebug&0x11) DebugScanTimerQueue(0x11);

    //
    // if timer list empty, set lowIndex, and timer to infinite, and return.
    //
    if (ptg->NumTimers==0) {
        ptg->TableLowIndex = (DWORD)~0;
        SET_TIMER_INFINITE(ptg->WTTimeout);
        ptg->Status = TIMER_STATUS_INACTIVE;    
        return;
    }

    DEBUG_CHECK_LOW_INDEX(13);//deldel


    //
    // find lowest table index having an entry
    //
    if (dwLowIndex>NUM_TIMER_BUCKETS-1) 
        dwLowIndex = 0;

    for (;  dwLowIndex<=NUM_TIMER_BUCKETS-1;  dwLowIndex++) {
        if (IsListEmpty(&ptg->TimesTable[dwLowIndex]) )
            continue;
        else
            break;
    }
    DEBUG_CHECK_LOW_INDEX(14);//deldel

    ptg->TableLowIndex = dwLowIndex;
    DEBUG_CHECK_LOW_INDEX(15);//deldel


    //kslksl
    //if (dwLowIndex==NUM_TIMER_BUCKETS)
      //  IgmpDbgBreakPoint();
        

    //
    // find timer entry with the lowest time
    //
    if (dwLowIndex==0) {
        pteMin = CONTAINING_RECORD(ptg->TimesTable[0].Flink, 
                                    IGMP_TIMER_ENTRY, Link);
    }
    else {

        // except bucket[0], other buckets are not sorted
        
        pHead = &ptg->TimesTable[dwLowIndex];
        ilMinTime = (((LONGLONG)0x7FFFFFF)<<32)+ ~0;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
            if (pte->Timeout<ilMinTime) {
                ilMinTime = pte->Timeout;
                pteMin = pte;
            }
        }
    }


    //
    // update global time
    //
    if ((IS_TIMER_INFINITE(ptg->WTTimeout)) 
            || (pteMin->Timeout!=ptg->WTTimeout)) 
    {
        ptg->WTTimeout = pteMin->Timeout;


        if (!IS_TIMER_INFINITE(ptg->WTTimeout)) {

            BOOL bSuccess ;
            
            bSuccess = ChangeTimerQueueTimer(ptg->WTTimer, ptg->WTTimer1,
                        llCurTime<ptg->WTTimeout
                            ?(ULONG) ((ptg->WTTimeout - llCurTime))
                            : 0,
                        1000000                   // set a periodic timer
                        );
            if (!bSuccess) {
                Error = GetLastError();
                Trace1(ERR, "ChangeTimerQueueTimer returned error:%d in SetNextTime",
                        Error);
                IgmpAssertOnError(FALSE);
            }
            else {
                #if DEBUG_TIMER_ACTIVITY
                Trace1(TIMER1, "ChangeTimerQueueTimer set to %lu",
                            (ULONG) ((ptg->WTTimeout - llCurTime))/1000);
                #if DEBUG_TIMER_ID
                g_Fire = (ULONG) ((ptg->WTTimeout - llCurTime)/1000);
                #endif
                #endif
            }
        }
            
        ptg->Status = TIMER_STATUS_ACTIVE;
    }
    DEBUG_CHECK_LOW_INDEX(16);//deldel


    //
    // resynchronize timer list if required
    //
    if ( (ptg->TableLowIndex!=0) 
            && (ptg->SyncTime + TIMER_BUCKET_GRANULARITY_ABS > llCurTime) ) {
        
        ResyncTimerBuckets(llCurTime);
    }

    //kslksl
    if (MyDebug&0x12) DebugScanTimerQueue(0x12);
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(17);//deldel

    Trace0(LEAVE1, "_SetNextTime()");
    return; 
    
} //end _SetNextTime



//------------------------------------------------------------------------------
//          _InitializeIgmpTime
// Initialize the igmp absolute timer
//------------------------------------------------------------------------------

VOID
InitializeIgmpTime(
    )
{
    g_TimerStruct.CurrentTime.HighPart = 0;
    g_TimerStruct.CurrentTime.LowPart = GetTickCount();
    return;
}


//------------------------------------------------------------------------------
//          _GetCurrentIgmpTimer
// uses GetTickCount(). converts it into 64 bit absolute timer.
//------------------------------------------------------------------------------
LONGLONG
GetCurrentIgmpTime(
    )
{
    ULONG   ulCurTimeLow = GetTickCount();


    //
    // see if timer has wrapped
    //
    // since multi-threaded, it might get preempted and CurrentTime
    // might get lower than the global variable g_TimerStruct.CurrentTime.LowPart
    // which might be set by another thread. So we also explicitly verify the
    // switch from a very large DWORD to a small one.
    // (code thanks to murlik&jamesg)
    //
    
    if ( (ulCurTimeLow < g_TimerStruct.CurrentTime.LowPart) 
        && ((LONG)g_TimerStruct.CurrentTime.LowPart < 0)
        && ((LONG)ulCurTimeLow > 0) )
    {


        // use global CS instead of creating a new CS
        
        ACQUIRE_GLOBAL_LOCK("_GetCurrentIgmpTime");


        // make sure that the global timer has not been updated meanwhile
        
        if ( (LONG)g_TimerStruct.CurrentTime.LowPart < 0) 
        {
            g_TimerStruct.CurrentTime.HighPart++;
            g_TimerStruct.CurrentTime.LowPart = ulCurTimeLow;
        }
        
        RELEASE_GLOBAL_LOCK("_GetCurrentIgmpTime");
    
    }    
    g_TimerStruct.CurrentTime.LowPart = ulCurTimeLow;


    return g_TimerStruct.CurrentTime.QuadPart;
}



//------------------------------------------------------------------------------
//        _WF_ProcessTimerEvent
//
// Processes the timer queue, firing events and sets the next timer at the end.
// Is queued by the Wait Server Thread.
// 
// Locks: Acquires global timer lock before entering into the timer queue.
//------------------------------------------------------------------------------
VOID
WF_ProcessTimerEvent (
    PVOID    pContext
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    LONGLONG            ilDiffTime, llCurTime = GetCurrentIgmpTime();
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         pHead, ple;
    PIGMP_TIMER_ENTRY   pte;
    LONGLONG            llFiredTimeout;
    #if  DEBUG_TIMER_PROCESSQUEUE2
    BOOL                bDbg = FALSE;
    #endif

    if (!EnterIgmpWorker()) {return;}
    
    Trace0(ENTER1, "Entering _WF_ProcessTimerEvent");


    // acquire timer lock
    
    ACQUIRE_TIMER_LOCK("_WF_ProcessTimerEvent");

DebugCheckLowTimer(1); //deldel

    // print the timer queue

    #if  DEBUG_TIMER_PROCESSQUEUE1
        Trace0(TIMER1, "Printing Timer Queue before processing the timer queue");
        DebugPrintTimerQueue();
    #endif
    

    BEGIN_BREAKOUT_BLOCK1 {
    
            
        // I fire a timer if it is set to within + FORWARD_TIMER_FIRED from now
        llFiredTimeout = llCurTime + FORWARD_TIMER_FIRED;
        
        

        // if there are no timers, then I am done
        
        if (ptg->NumTimers<1) {
            Trace1(TIMER1, "Num timers%d less than 1 in _WF_ProcessTimerEvent", 
                    ptg->NumTimers);
            GOTO_END_BLOCK1;
        }


        
        //
        // find all the timers with lower timeouts and fire callbacks in my context
        //
        BEGIN_BREAKOUT_BLOCK2 {
            for ( ;  ptg->TableLowIndex <= NUM_TIMER_BUCKETS-1;  ) {

                BOOL bDontCheckLowIndex = FALSE;
                
                pHead = &ptg->TimesTable[ptg->TableLowIndex];
            
                for (ple=pHead->Flink;  ple!=pHead;  ) {
                
                    pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
                    
                    ple = ple->Flink;

                    // this timer is fired
                    if (pte->Timeout < llFiredTimeout) {
                    
                        RemoveEntryList(&pte->Link);
                        pte->Status = TIMER_STATUS_FIRED;
                        ptg->NumTimers --;

                        if (IsListEmpty(&ptg->TimesTable[ptg->TableLowIndex])) {

                            for (;  ptg->TableLowIndex<=NUM_TIMER_BUCKETS-1;  ptg->TableLowIndex++) {
                                if (IsListEmpty(&ptg->TimesTable[ptg->TableLowIndex]) )
                                    continue;
                                else
                                    break;
                            }
                            
                            bDontCheckLowIndex = TRUE;
                            if (ptg->TableLowIndex==NUM_TIMER_BUCKETS)
                                ptg->TableLowIndex = ~0;
                        }

                            
                        //or should i queue to other worker threads
                                
                        (pte->Function)(pte->Context);

                        #if  DEBUG_TIMER_PROCESSQUEUE2
                        if (pte->Function!=WT_MibDisplay && pte->Function!=T_QueryTimer)
                            bDbg = TRUE;
                        #endif
                        
                    }
                    else {

                        if (ptg->TableLowIndex==0) //only the 1st bucket is sorted
                            GOTO_END_BLOCK2;
                    }
                }

                if (!bDontCheckLowIndex) {
                    // if any bucket is not empty, then I am done, as I start with LowIndex
                    if (!IsListEmpty(&ptg->TimesTable[ptg->TableLowIndex])) 
                        break;

                    ptg->TableLowIndex++;
                }
                
            } //end for loop
            
        } END_BREAKOUT_BLOCK2;

        if ( (ptg->TableLowIndex!=0) 
                && (ptg->SyncTime + TIMER_BUCKET_GRANULARITY_ABS < llCurTime) ) {
            
            ResyncTimerBuckets(llCurTime);
        }

        
        //
        // set the next lowest time
        //
        SET_TIMER_INFINITE(ptg->WTTimeout);
        SetNextTime(ptg->TableLowIndex);


    } END_BREAKOUT_BLOCK1;


    // print the timer queue

    #if  DEBUG_TIMER_PROCESSQUEUE2
        if (bDbg||g_DebugPrint) {
            Trace0(TIMER1, "   ");
            Trace0(TIMER1, "Printing Timer Queue after processing the timer queue");
            DebugPrintTimerQueue();
        }
    #endif

    //kslksl
    if (MyDebug&0x14) DebugScanTimerQueue(0x14);
DebugCheckLowTimer(1); //deldel

    RELEASE_TIMER_LOCK("_WF_ProcessTimerEvent");

    Trace0(LEAVE1, "Leaving _WF_ProcessTimerEvent()");
    LeaveIgmpWorker();
    return ;
    
} //end _WF_ProcessTimerEvent



//------------------------------------------------------------------------------
//                WT_ProcessTimerEvent
// 
// Callback: fired when the timer set by this dll is timed out by the NtdllTimer
//------------------------------------------------------------------------------

VOID
WT_ProcessTimerEvent (
    PVOID    pContext,
    BOOLEAN  Unused
    )
{    
    //enter/leaveIgmpApi not required as the timer queue is persistent

    Trace0(ENTER1, "Entering _WT_ProcessTimerEvent()");

    QueueIgmpWorker((LPTHREAD_START_ROUTINE)WF_ProcessTimerEvent, pContext);
    
    Trace0(LEAVE1, "Leaving _WT_ProcessTimerEvent()");

    return;
}



//------------------------------------------------------------------------------
//            _InsertTimerInSortedList
// Used to insert a timer in the sorted bucket=0 
//------------------------------------------------------------------------------
VOID    
InsertTimerInSortedList(
    PIGMP_TIMER_ENTRY    pteNew,
    PLIST_ENTRY          pHead
    )
{
    PLIST_ENTRY             ple;
    PIGMP_TIMER_ENTRY       pte;
    LONGLONG                llNewTime;


    llNewTime = pteNew->Timeout;
    
    
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
        pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
        if (llNewTime<= pte->Timeout)
            break;
    }

    InsertTailList(ple, &pteNew->Link);

    return;
}



//------------------------------------------------------------------------------
//          _ResyncTimerBuckets
//
// Called during insert: when the 1st bucket is empty, and other buckets have
// to be moved left   
// LowIndex might not be correct
//------------------------------------------------------------------------------
DWORD DebugIgmpNumShift[30];
PLIST_ENTRY DebugIgmpNumShift1[64][3];
DWORD DebugIgmpNumShiftCount;

VOID 
ResyncTimerBuckets( 
    LONGLONG llCurTime
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    PLIST_ENTRY         pHead, ple, pleCur;
    LIST_ENTRY          le;
    PIGMP_TIMER_ENTRY   pte;
    LONGLONG            lastBucketTime;
    DWORD               numShift, dwCount, dwBucket, i, j;

    Trace0(TIMER1, "entering _ResyncTimerBuckets()");

    //deldel
    for (DebugIgmpNumShiftCount=0;  DebugIgmpNumShiftCount<30; DebugIgmpNumShiftCount++)
        DebugIgmpNumShift[DebugIgmpNumShiftCount] = 0;

        
    DebugCheckLowTimer(0);//deldel
    DEBUG_CHECK_LOW_INDEX(21);//deldel

    //Trace0(TIMER1, "Printing Timer Queue before _ResyncTimerBuckets"); //deldel
    //DebugPrintTimerQueue(); //deldel


    if (ptg->NumTimers == 0)
        return;
        
    //kslksl
    if (MyDebug&0x18) DebugScanTimerQueue(0x18);

    //
    // SyncTime should always be <= to currentTime
    //
    numShift = 0;
    DebugIgmpNumShift[0] = numShift;//deldel
    DebugIgmpNumShiftCount = 0; //deldel
    
    while (numShift<NUM_TIMER_BUCKETS
        && (ptg->SyncTime+TIMER_BUCKET_GRANULARITY_ABS <= llCurTime)
        ) {
        DebugIgmpNumShift1[numShift][0] = &ptg->TimesTable[numShift]; //deldel
        DebugIgmpNumShift1[numShift][1] = ptg->TimesTable[numShift].Flink; //deldel
        DebugIgmpNumShift1[numShift][2] = ptg->TimesTable[numShift].Blink; //deldel
        
        if (!IsListEmpty(&ptg->TimesTable[numShift]))
            break;
            
        ptg->SyncTime += TIMER_BUCKET_GRANULARITY_ABS;
        numShift++;
    }
    DebugIgmpNumShiftCount = DebugIgmpNumShift[1] = numShift;//deldel

    if (numShift==0 || numShift==NUM_TIMER_BUCKETS)
        return;


    //
    // shift all buckets left, except for the last bucket and reinitialize the 
    // list heads
    //
    for (i=0,j=numShift;  i<NUM_TIMER_BUCKETS-1-numShift;  i++,j++) {
        if (IsListEmpty(&ptg->TimesTable[j])) {
            ptg->TimesTable[j].Flink = ptg->TimesTable[j].Blink 
                                         = &ptg->TimesTable[i];
        }
        else {
            ptg->TimesTable[j].Flink->Blink = &ptg->TimesTable[i];
            ptg->TimesTable[j].Blink->Flink = &ptg->TimesTable[i];
        }
    }

        DebugIgmpNumShift[2] = numShift;//deldel

    MoveMemory( (PVOID)&(ptg->TimesTable[0]),  
                (VOID *)&(ptg->TimesTable[numShift]),
                 (sizeof(LIST_ENTRY) * (NUM_TIMER_BUCKETS-1-numShift))
                 );

    for (dwCount=1;  dwCount<=numShift;  dwCount++)
        InitializeListHead(&ptg->TimesTable[NUM_TIMER_BUCKETS-1-dwCount]);

    DebugIgmpNumShift[3] = numShift;//deldel


    //
    // go through the last bucket and redistribute it
    //
    lastBucketTime = ptg->SyncTime
                        + (TIMER_BUCKET_GRANULARITY_ABS*(NUM_TIMER_BUCKETS-1));
    
    pHead = &ptg->TimesTable[NUM_TIMER_BUCKETS-1];

    for (ple=pHead->Flink;  ple!=pHead;  ) {
        pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
        pleCur = ple;
        ple = ple->Flink;

        if (pte->Timeout<lastBucketTime) {
            RemoveEntryList(pleCur);
            MAP_TO_BUCKET(dwBucket, pte->Timeout);
            if (dwBucket==0) {
                InsertTimerInSortedList(pte, &ptg->TimesTable[0]);
            }
            else {
                InsertTailList(&ptg->TimesTable[dwBucket], pleCur);
            }
        }
    }
    DebugIgmpNumShift[4] = numShift;//deldel
    
    DEBUG_CHECK_LOW_INDEX(22);//deldel


    //    
    // sort the times in the first bucket
    //
    InitializeListHead(&le);
    InsertHeadList(&ptg->TimesTable[0], &le);
    RemoveEntryList(&ptg->TimesTable[0]);
    InitializeListHead(&ptg->TimesTable[0]);

    for (ple=le.Flink; ple!=&le;  ) {
        pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
        RemoveEntryList(ple);
        ple = ple->Flink;
        InsertTimerInSortedList(pte, &ptg->TimesTable[0]);
    }

    DEBUG_CHECK_LOW_INDEX(23);//deldel

    DebugIgmpNumShift[5] = numShift;//deldel

    //
    // set the TableLowIndex
    //
    if (ptg->TableLowIndex>=NUM_TIMER_BUCKETS-1) {
        for (ptg->TableLowIndex=0;  ptg->TableLowIndex<=NUM_TIMER_BUCKETS-1;  
                    ptg->TableLowIndex++) 
        {
            if (IsListEmpty(&ptg->TimesTable[ptg->TableLowIndex]) )
                continue;
            else
                break;
        }
        DEBUG_CHECK_LOW_INDEX(24);//deldel

    } 
    else {
    DebugIgmpNumShift[6] = numShift;//deldel
        ptg->TableLowIndex -= numShift;
    DebugIgmpNumShift[7] = numShift;//deldel
        DEBUG_CHECK_LOW_INDEX(25);//deldel
    }


    //#if DEBUG_TIMER_RESYNCTIMER deldel
    //Trace0(TIMER1, "Printing Timer Queue after _ResyncTimerBuckets");
    //DebugPrintTimerQueue();
    //#endif deldel


    //kslksl
    if (MyDebug&0x21) DebugScanTimerQueue(0x21);
    DebugCheckLowTimer(0);//deldel
    DEBUG_CHECK_LOW_INDEX(26);//deldel

    // debugdebug
    if (g_TimerStruct.TableLowIndex>64 && g_TimerStruct.TableLowIndex!=~0) {
        IgmpDbgBreakPoint();
        g_TimerStruct.TableLowIndex = 0;
        SetNextTime(0);
        ResyncTimerBuckets(llCurTime);
    }
    
    Trace0(LEAVE1, "leaving _ResyncTimerBuckets()");
    return;
    
} //end _ResyncTimerBuckets



//------------------------------------------------------------------------------
//          _InitializeTimerGlobal
//
// create the timer CS and WaitTimer. registers a queue and timer with NtdllTimer.
// 
// Called by: _StartProtocol()    
// Locks: no locks taken here.
//------------------------------------------------------------------------------

DWORD
InitializeTimerGlobal (
    )
{
    DWORD               Error = NO_ERROR, i;
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    BOOL                bErr;
    LONGLONG            llCurTime = GetTickCount();

    
    
    Trace0(ENTER1, "Entering _InitializeTimerGlobal()");

    
    bErr = TRUE;
    
    BEGIN_BREAKOUT_BLOCK1 {


        // initialize igmp timer used to get tick count

        InitializeIgmpTime();


        
        //
        // initialize timer critical section
        //
        try {
            InitializeCriticalSection(&ptg->CS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Error = GetExceptionCode();
            Trace1(
                ANY, "exception %d initializing global timer critical section",
                Error
                );
            Logerr0(INIT_CRITSEC_FAILED, Error);

            GOTO_END_BLOCK1;
        }
        
        #if DEBUG_FLAGS_SIGNATURE
        ptg->CSFlag = 0; //deldel
        #endif
        
        // create WaitTimer for igmp
        ptg->WTTimer = CreateTimerQueue();
        
        if ( ! ptg->WTTimer) {
            Error = GetLastError();
            Trace1(ERR, "CreateTimerQueue() failed:%d", Error);
            IgmpAssertOnError(FALSE);
            GOTO_END_BLOCK1;
        }
        


        //
        // create a periodic timer which does not get deletd
        //
        
        if (! CreateTimerQueueTimer(
                    &ptg->WTTimer1,
                    ptg->WTTimer, WT_ProcessTimerEvent,
                    NULL, //context
                    1000000,
                    1000000,
                    0
                    ))
        {
            Error = GetLastError();
            Trace1(ERR, "CreateTimerQueue() failed:%d", Error);
            IgmpAssertOnError(FALSE);
            GOTO_END_BLOCK1;
        }


        
        // set initial timeout to infinite, and SyncTime to the current time
        
        SET_TIMER_INFINITE(ptg->WTTimeout);
        ptg->SyncTime = llCurTime;
        ptg->CurrentTime.QuadPart = llCurTime;

        ptg->NumTimers = 0;



        // initialize the timer buckets
        
        for (i=0;  i<NUM_TIMER_BUCKETS;  i++) {
            InitializeListHead(&ptg->TimesTable[i]);
        }


        // set the TableLowIndex
        ptg->TableLowIndex = (DWORD)~0;


        // set the status of the global timer
        ptg->Status = TIMER_STATUS_CREATED;
        
        bErr = FALSE;

    } END_BREAKOUT_BLOCK1;

    if (bErr) {
        DeInitializeTimerGlobal();
        Trace0(LEAVE1, "Leaving. Could not _InitializeTimerGlobal():");
        return ERROR_CAN_NOT_COMPLETE;
    } 
    else {
        Trace0(LEAVE1, "Leaving _InitializeTimerGlobal()");
        return NO_ERROR;
    }
    
} //end _InitializeTimerGlobal



//------------------------------------------------------------------------------
//        _DeInitializeTimerGlobal
//
// deinitializes the timer CS, and deletes the timer queue with Rtl
//------------------------------------------------------------------------------
VOID
DeInitializeTimerGlobal (
    )
{
    
    DeleteCriticalSection(&g_TimerStruct.CS);


    DeleteTimerQueueEx(g_TimerStruct.WTTimer, NULL);

    
    return;
    
} //end _DeInitializeTimerGlobal



//------------------------------------------------------------------------------
//              _DebugPrintTimerEntry
//
// Assumes DEBUG_TIMER_TIMERID is true
//------------------------------------------------------------------------------
VOID
DebugPrintTimerEntry (
    PIGMP_TIMER_ENTRY   pte,
    DWORD               dwBucket,
    LONGLONG            llCurTime
    )
{
    DWORD               dwDiffTime;
    CHAR                str1[20], str2[20];
    
    #if DEBUG_TIMER_TIMERID

    CHECK_TIMER_SIGNATURE(pte);

    //deldel
    //if (pte->Id==920)
      //  return;
    
    if (dwBucket==(DWORD)~0) {
        MAP_TO_BUCKET(dwBucket, pte->Timeout);
    }

    GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

    if (pte->Timeout - llCurTime > 0) {
        Trace8(TIMER, "----  <%2d><%d><%d> Timeout:%lu   <%s> <%s> Status:%d %x",
                dwBucket, pte->Id, pte->Id2, dwDiffTime, str1, str2, 
                pte->Status, pte->Context);
    }
    else {
        Trace8(TIMER, "----  <%d><%d><%d> Timeout:--%lu <%s> <%s> Status:%d %x %x",
                dwBucket, pte->Id, pte->Id2, dwDiffTime, str1, str2, 
                pte->Status, pte->Context);
    }

    #endif //#if DEBUG_TIMER_TIMERID

    return;
}


//------------------------------------------------------------------------------
//          _GetTimerDebugInfo
//
// returns info regarding what type of timer it is
//------------------------------------------------------------------------------

VOID
GetTimerDebugInfo(
    CHAR                str1[20],
    CHAR                str2[20],
    DWORD              *pdwDiffTime,
    PIGMP_TIMER_ENTRY   pte,
    LONGLONG            llCurTime
    )
{
    LONGLONG    diffTime;

#if DEBUG_TIMER_TIMERID

    diffTime = (pte->Timeout - llCurTime > 0)
                ? pte->Timeout - llCurTime 
                : llCurTime - pte->Timeout;

        
    diffTime /= (LONGLONG)1000; //in seconds
    *pdwDiffTime = (DWORD)diffTime;


    strcpy(str2, "          ");
    switch (pte->Id) {
        case 110: 
        case 120: strcpy(str1, "iGenQuery   "); break;
        case 210: 
        case 220: strcpy(str1, "iOtherQry   "); break;
        case 211: strcpy(str1, "iOtherQry*  "); break;
        case 331:
        case 321: strcpy(str1, "gMemTimer*  "); INET_COPY(str2, pte->Group); break;
        case 300:
        case 320:
        case 330:
        case 340: strcpy(str1, "gMemTimer   "); INET_COPY(str2, pte->Group); break;
        case 400:
        case 410: 
        case 420: strcpy(str1, "gGrpSpQry   "); INET_COPY(str2, pte->Group); break;
        case 510: 
        case 520: strcpy(str1, "gLstV1Rpt   "); INET_COPY(str2, pte->Group); break;
        case 511: strcpy(str1, "gLstV1Rpt*  "); INET_COPY(str2, pte->Group); break;
        case 550: 
        case 560: strcpy(str1, "gLstV2Rpt   "); INET_COPY(str2, pte->Group); break; 
        case 610:
        case 620: strcpy(str1, "gGSrcExp    "); INET_COPY(str2, pte->Group);
                  lstrcat(str2, ":"); INET_CAT(str2, pte->Source); break;
        case 720: 
        case 740: strcpy(str1, "iV1Router   "); break;
        case 741: strcpy(str1, "iV1Router*  "); break;
        case 920:
        case 910: strcpy(str1, "_MibTimer   "); break;
        case 1001: strcpy(str1, "_gSrcQry   "); INET_COPY(str2, pte->Group); break;
        default:  strcpy(str1, "????        "); break;
    
    }

#endif //DEBUG_TIMER_TIMERID

    return;
}

VOID
DebugCheckTimerContexts(
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    PIGMP_TIMER_ENTRY   pte;
    PLIST_ENTRY         pHead, ple;
    DWORD               i;

    
    ACQUIRE_TIMER_LOCK("_DebugPrintTimerQueue");
    //Trace0(ERR, "%d*************", Id);
        for (i=0;  i<NUM_TIMER_BUCKETS;  i++) {
            
            pHead = &ptg->TimesTable[i];
            if (IsListEmpty(pHead)) 
                continue;
            else {    
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                    pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
                    if ( ((ULONG_PTR)pte->Context) & 0x3)
                        IgmpDbgBreakPoint();
                }
            }
        }
    RELEASE_TIMER_LOCK("_DebugPrintTimerQueue");
    return;
}

DWORD g_igmp1, g_igmp2, g_igmp3;
PLIST_ENTRY g_ple1, g_pHead;
PIGMP_TIMER_ENTRY g_pte;

//DebugCheck
DWORD
DebugScanTimerQueue(
    DWORD Id
    )
{
    Trace1(TIMER1, "_TimerQueue:%d", Id);

    #if DEBUG_TIMER_TIMERID
    if ( (g_igmp3++ & 0x7) == 0x7) { //deldel
    //if ( 1){
        DebugPrintTimerQueue();
        return 0;
    }

    for (g_igmp1=0;  g_igmp1<NUM_TIMER_BUCKETS;  g_igmp1++) {
            
        g_pHead = &g_TimerStruct.TimesTable[g_igmp1];
        if (IsListEmpty(g_pHead)) 
            continue;
        else {    
            for (g_ple1=g_pHead->Flink;  g_ple1!=g_pHead;  g_ple1=g_ple1->Flink) {
                g_pte = CONTAINING_RECORD(g_ple1, IGMP_TIMER_ENTRY, Link);
                CHECK_TIMER_SIGNATURE(g_pte);
                g_igmp2 = g_pte->Id;
            }
        }
    }

    return g_igmp1+g_igmp2;
    #else
    return 0;
    #endif
}

//------------------------------------------------------------------------------
//          _DebugPrintTimerQueue
// takes the timer lock
//------------------------------------------------------------------------------
VOID
APIENTRY
DebugPrintTimerQueue (
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    PIGMP_TIMER_ENTRY   pte;
    PLIST_ENTRY         pHead, ple;
    LONGLONG            llCurTime = GetCurrentIgmpTime();
    DWORD               Error=NO_ERROR, i, count;


    //kslksl
    /*if (g_Info.CurrentGroupMemberships > 240)
        return;
  */
#if DEBUG_TIMER_TIMERID
    
    ENTER_CRITICAL_SECTION(&g_CS, "g_CS", "_DebugPrintTimerQueue");
    if (g_RunningStatus != IGMP_STATUS_RUNNING) {
        Error = ERROR_CAN_NOT_COMPLETE;
    }
    else {
        ++g_ActivityCount;
    }
    LEAVE_CRITICAL_SECTION(&g_CS, "g_CS", "_DebugPrintTimerQueue");
    if (Error!=NO_ERROR)
        return;


    if (!EnterIgmpWorker()) {return;}
    


    ACQUIRE_TIMER_LOCK("_DebugPrintTimerQueue");

    
    if (g_TimerStruct.NumTimers==0) {
        Trace0(TIMER, "No timers present in the timer queue");

    }
    else {
        Trace0(TIMER, "---------------------LOCAL-TIMER-QUEUE-------------------------");
        Trace6(TIMER, "-- LastFire:%d FireAfter:%d  WTTimeout<%d:%lu>    SyncTime<%d:%lu>",
                g_Fire, (DWORD)(ptg->WTTimeout - llCurTime),
                TIMER_HIGH(ptg->WTTimeout), TIMER_LOW(ptg->WTTimeout), 
                TIMER_HIGH(ptg->SyncTime), TIMER_LOW(ptg->SyncTime) );
        Trace3(TIMER, "--  NumTimers:<%d>     TableLowIndex:<%lu>        Status:<%d>",
                ptg->NumTimers, ptg->TableLowIndex, ptg->Status);
        Trace0(TIMER, "---------------------------------------------------------------");
        
        count =0;
        for (i=0;  i<NUM_TIMER_BUCKETS;  i++) {
            
            pHead = &ptg->TimesTable[i];
            if (IsListEmpty(pHead)) 
                continue;
            else {    
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                    pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
                    DebugPrintTimerEntry(pte, i, llCurTime);
                    count ++;
                }
            }
        }

        Trace0(TIMER, 
        "---------------------------------------------------------------\n\n");
    }
    RELEASE_TIMER_LOCK("_DebugPrintTimerQueue");


    LeaveIgmpWorker();

#endif //DEBUG_TIMER_TIMERID

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\macros.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File Name: macros.h
//
// Abstract:
//      This file contains many macros and #defines.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//
//=============================================================================

#ifndef _MACROS_H_
#define _MACROS_H

//------------------------------------------------------------------------------
// DEBUG FLAGS
//------------------------------------------------------------------------------

//kslksl
#define SET_MOST_DEBUG  0

// check for memory leaks
#define DEBUG_FLAGS_MEM_ALLOC (1 | SET_MOST_DEBUG)
//#define DEBUG_FLAGS_MEM_LEAK (DBG | DEBUG_FLAGS_MEM_ALLOC)
// set it to above
#define DEBUG_FLAGS_MEM_LEAK 0

// assert on error //deldel replace 1 with 0
#define DEBUG_FLAGS_ASSERT_ON_ERRORS (0 | SET_MOST_DEBUG)

// DebugCheck
#define CALL_MSG(str) {\
    DbgPrint("\nCall Lokeshs with this stack. dont hit go. " str ,__FILE__,__LINE__,NULL);\
    IgmpDbgBreakPoint();\
    DbgPrint("\nCall Lokeshs with this stack. dont hit go. " str ,__FILE__,__LINE__,NULL);\
    }

//------------------------------------------------------------------------------
// TMP DEBUGGING //DebugCheck
//------------------------------------------------------------------------------
extern DWORD DEBUG_CHECK_LOW_INDEX_ARRAY[100][2];
extern DWORD DebugIgmpIndex;

#define DEBUG_CHECK_LOW_INDEX(i) {\
    DebugIgmpIndex = (++DebugIgmpIndex) % 100; \
    DEBUG_CHECK_LOW_INDEX_ARRAY[DebugIgmpIndex][0] = i;\
    DEBUG_CHECK_LOW_INDEX_ARRAY[DebugIgmpIndex][1] = g_TimerStruct.TableLowIndex;\
    if (g_TimerStruct.TableLowIndex>64 && g_TimerStruct.TableLowIndex!=~0) IgmpDbgBreakPoint();\
    if (g_TimerStruct.TableLowIndex>64 && g_TimerStruct.NumTimers!=0) IgmpDbgBreakPoint();\
    }
//    Trace2(ENTER, "%%%%%%LowIndex:(%d) %0x:%d", i, g_TimerStruct.TableLowIndex); \



//------------------------------------------------------------------------------
// some global definitions
//------------------------------------------------------------------------------

#ifndef IPADDR
typedef DWORD   IPADDR;
#endif

#define PROTO_IP_IGMP_PROXY  11

#define INTERSECTION        3
#define RULE5               5


//------------------------------------------------------------------------------
// interface table macros
//------------------------------------------------------------------------------


#define IF_HASH_VALUE(_index) ((_index) % g_pIfTable->NumBuckets)



#define ACQUIRE_IF_LOCK_EXCLUSIVE(_IfIndex, _proc) \
        AcquireDynamicRWLock(&g_pIfTable->aIfBucketDRWL[IF_HASH_VALUE(_IfIndex)],\
                                LOCK_MODE_WRITE, \
                                &g_DynamicRWLStore)
#define RELEASE_IF_LOCK_EXCLUSIVE(_IfIndex, _proc) \
        ReleaseDynamicRWLock(&g_pIfTable->aIfBucketDRWL[IF_HASH_VALUE(_IfIndex)], \
                                LOCK_MODE_WRITE, \
                                &g_DynamicRWLStore)
        
#define ACQUIRE_IF_LOCK_SHARED(_IfIndex, _proc) \
        AcquireDynamicRWLock(&g_pIfTable->aIfBucketDRWL[IF_HASH_VALUE(_IfIndex)], \
                                LOCK_MODE_READ, \
                                &g_DynamicRWLStore)
#define RELEASE_IF_LOCK_SHARED(_IfIndex, _proc) \
        ReleaseDynamicRWLock(&g_pIfTable->aIfBucketDRWL[IF_HASH_VALUE(_IfIndex)], \
                                LOCK_MODE_READ, \
                                &g_DynamicRWLStore)



#define ACQUIRE_IF_LIST_LOCK(_proc) \
        ENTER_CRITICAL_SECTION(&g_pIfTable->IfLists_CS, "g_IfListsCS", _proc);

#define RELEASE_IF_LIST_LOCK(_proc) \
        LEAVE_CRITICAL_SECTION(&g_pIfTable->IfLists_CS, "g_IfListsCS", _proc);


        
#define ACQUIRE_IF_GROUP_LIST_LOCK(_IfIndex, _proc) \
        AcquireDynamicCSLock(&g_pIfTable->aIfBucketDCS[IF_HASH_VALUE(_IfIndex)],\
                                &g_DynamicCSStore)
#define RELEASE_IF_GROUP_LIST_LOCK(_IfIndex, _proc) \
        ReleaseDynamicCSLock(&g_pIfTable->aIfBucketDCS[IF_HASH_VALUE(_IfIndex)],\
                                &g_DynamicCSStore) 


                
//------------------------------------------------------------------------------
// Proxy table macros
//------------------------------------------------------------------------------

#define PROXY_HASH_VALUE(_group) \
        (( ((_group)&0xFF000000)+((_group)&0xFF)) % (PROXY_HASH_TABLE_SZ))



//------------------------------------------------------------------------------
// protocol type macros/interface type macros
//------------------------------------------------------------------------------

#define IS_PROTOCOL_TYPE_PROXY(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_PROXY \
                ||(_pite)->Config.IgmpProtocolType==IGMP_PROXY_V3)

#define IS_PROTOCOL_TYPE_PROXY_V2(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_PROXY)
                
#define IS_PROTOCOL_TYPE_PROXY_V3(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_PROXY_V3)
                
#define IS_PROTOCOL_TYPE_IGMPV1(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_ROUTER_V1)

#define IS_PROTOCOL_TYPE_IGMPV2(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_ROUTER_V2)

#define IS_PROTOCOL_TYPE_IGMPV3(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_ROUTER_V3)

#define IS_PROTOCOL_TYPE_ROUTER(_pite) \
                (!IS_PROTOCOL_TYPE_PROXY(_pite))


#define IGMP_MIB_IF_CONFIG_SIZE_V3(pConfig) \
    IgmpMibIfConfigSize(pConfig)

// internally, FfType does not have protocol type, but when I expose it outside,
// I have to add proxy type if it is a proxy interface.

#define GET_EXTERNAL_IF_TYPE(_pite)  \
    IS_PROTOCOL_TYPE_PROXY(_pite) ? ((_pite->IfType)|IGMP_IF_PROXY) \
                                : (_pite)->IfType


#define ACQUIRE_PROXY_ALERT_LOCK(proc) \
    ENTER_CRITICAL_SECTION(&g_ProxyAlertCS, "g_ProxyAlertCS", proc)
#define RELEASE_PROXY_ALERT_LOCK(proc) \
    LEAVE_CRITICAL_SECTION(&g_ProxyAlertCS, "g_ProxyAlertCS", proc)


//-------------------------------------------------------------------
// ENUM MACROS
//-------------------------------------------------------------------
#define ACQUIRE_ENUM_LOCK_EXCLUSIVE(_proc) \
    ACQUIRE_WRITE_LOCK(&g_EnumRWLock, "g_EnumRWLock", _proc);

#define RELEASE_ENUM_LOCK_EXCLUSIVE(_proc) \
    RELEASE_WRITE_LOCK(&g_EnumRWLock, "g_EnumRWLock", _proc);

#define ACQUIRE_ENUM_LOCK_SHARED(_proc) \
    ACQUIRE_READ_LOCK(&g_EnumRWLock, "g_EnumRWLock", _proc);

#define RELEASE_ENUM_LOCK_SHARED(_proc) \
    RELEASE_READ_LOCK(&g_EnumRWLock, "g_EnumRWLock", _proc);
    
//------------------------------------------------------------------------------
// group table macros
//------------------------------------------------------------------------------

#define GROUP_HASH_VALUE(_group) \
        (((_group) & 0xFF)%GROUP_HASH_TABLE_SZ)

        
#define ACQUIRE_GROUP_LOCK(_group, _proc) {\
    ACQUIRE_ENUM_LOCK_SHARED(_proc);\
    AcquireDynamicCSLockedList( \
            &g_pGroupTable->HashTableByGroup[GROUP_HASH_VALUE(_group)],\
            &g_DynamicCSStore);\
}

#define RELEASE_GROUP_LOCK(_group, _proc) {\
    ReleaseDynamicCSLockedList( \
            &g_pGroupTable->HashTableByGroup[GROUP_HASH_VALUE(_group)],\
            &g_DynamicCSStore);\
    RELEASE_ENUM_LOCK_SHARED(_proc);\
}

        
#define ACQUIRE_GROUP_LIST_LOCK(_proc) { \
            ACQUIRE_LIST_LOCK(&g_pGroupTable->ListByGroup, \
                                "g_pGroupTable->ListByGroup", _proc);\
        }

#define RELEASE_GROUP_LIST_LOCK(_proc) { \
            RELEASE_LIST_LOCK(&g_pGroupTable->ListByGroup, \
                                "g_pGroupTable->ListByGroup", _proc);\
        }

//
// merge the groups list if the number of entries in the new list is more than 50
// or if the size of new list is greater than 4 times the size of actual list
// but in any case not smaller than 10
//
#define MERGE_GROUP_LISTS_REQUIRED() \
    ( (g_pGroupTable->NumGroupsInNewList > 50) \
     || ( (g_pGroupTable->NumGroupsInNewList > \
          g_Info.CurrentGroupMemberships/4)  \
          && (g_pGroupTable->NumGroupsInNewList>10) ))


// insert all elements in l2 at the end of l1, and reinitialize l2
#define CONCATENATE_LISTS(l1, l2) { \
    l2.Flink->Blink = l1.Blink;      \
    l1.Blink->Flink = l2.Flink;      \
    l2.Blink->Flink = &l1;           \
    l1.Blink = l2.Blink;            \
    InitializeListHead(&l2);        \
    }


#define MERGE_IF_GROUPS_LISTS_REQUIRED(_pite)    \
    (_pite->NumGIEntriesInNewList > 20)

#define MERGE_PROXY_LISTS_REQUIRED(_pite)    \
    (_pite->NumGIEntriesInNewList > 20)



//------------------------------------------------------------------------------
// SOCKETS MACROS
//------------------------------------------------------------------------------
#define ACQUIRE_SOCKETS_LOCK_EXCLUSIVE(_proc) \
    ACQUIRE_WRITE_LOCK(&g_SocketsRWLock, "g_SocketsRWLock", _proc);

#define RELEASE_SOCKETS_LOCK_EXCLUSIVE(_proc) \
    RELEASE_WRITE_LOCK(&g_SocketsRWLock, "g_SocketsRWLock", _proc);

#define ACQUIRE_SOCKETS_LOCK_SHARED(_proc) \
    ACQUIRE_READ_LOCK(&g_SocketsRWLock, "g_SocketsRWLock", _proc);

#define RELEASE_SOCKETS_LOCK_SHARED(_proc) \
    RELEASE_READ_LOCK(&g_SocketsRWLock, "g_SocketsRWLock", _proc);





//------------------------------------------------------------------------------
// RAS MACROS
//------------------------------------------------------------------------------

#define IS_NOT_RAS_IF(flag)    ((flag) == IGMP_IF_NOT_RAS)
#define IS_RAS_SERVER_IF(flag) ((flag) == IGMP_IF_RAS_SERVER)
#define IS_RAS_CLIENT_IF(flag) ((flag) == IGMP_IF_RAS_CLIENT)
#define IS_RAS_ROUTER_IF(flag) ((flag) == IGMP_IF_RAS_ROUTER)

#define RAS_HASH_VALUE(ClientAddr) \
    (((ClientAddr) & 0xFF)%(RAS_HASH_TABLE_SZ))



//------------------------------------------------------------------------------
// PACKET MACROS
//------------------------------------------------------------------------------

// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument.
//

#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = ((((a)>>8) & 0x00ff0000) - (((b)>>8) & 0x00ff0000)))))))


#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)


            

//------------------------------------------------------------------------------
// Interface #defines and Macros
//------------------------------------------------------------------------------

//
// status flags
//
#define IF_CREATED_FLAG     0x00000001
#define CREATED_FLAG        0x00000001
#define IF_BOUND_FLAG       0x00000002
#define IF_ENABLED_FLAG     0x00000004
#define IF_DELETED_FLAG     0x80000000
#define DELETED_FLAG        0x80000000

#define MGM_ENABLED_IGMPRTR_FLAG        0x00001000
#define IGMPRTR_MPROTOCOL_PRESENT_FLAG  0x00002000

// interface timers etc have not been set. socket not activated. so enumeration
// might not be correct. Further, if deleting the entry, timers/sockets can
// be ignored
#define IF_ACTIVATED_FLAG    0x00000008
#define IF_DEACTIVATE_DELETE_FLAG   0x00000010


//
// macros for status flags
//

#define IS_IGMPRTR_ENABLED_BY_MGM(pite)    \
                            (pite->Status & MGM_ENABLED_IGMPRTR_FLAG)
#define MGM_ENABLE_IGMPRTR(pite)           \
                            (pite->Status |= MGM_ENABLED_IGMPRTR_FLAG)
#define MGM_DISABLE_IGMPRTR(pite) {\
                            (pite->Status &= ~MGM_ENABLED_IGMPRTR_FLAG);    \
                            (pite->Status &= ~IGMPRTR_MPROTOCOL_PRESENT_FLAG);\
                            }

#define IS_MPROTOCOL_PRESENT_ON_IGMPRTR(pite)    \
                            (pite->Status & IGMPRTR_MPROTOCOL_PRESENT_FLAG)
#define SET_MPROTOCOL_PRESENT_ON_IGMPRTR(pite)           \
                            (pite->Status |= IGMPRTR_MPROTOCOL_PRESENT_FLAG)
#define SET_MPROTOCOL_ABSENT_ON_IGMPRTR(pite) \
                            (pite->Status &= ~IGMPRTR_MPROTOCOL_PRESENT_FLAG)


#define IS_IF_BOUND(pite) \
        ((pite)->Status&IF_BOUND_FLAG)

#define IS_IF_ENABLED_BY_RTRMGR(pite) \
        ((pite)->Status&IF_ENABLED_FLAG)

#define IS_IF_ENABLED_IN_CONFIG(pite) \
        (IGMP_ENABLED_FLAG_SET((pite)->Config.Flags))
        
#define IS_IF_ENABLED(pite) \
        ( IS_IF_ENABLED_BY_RTRMGR(pite) && IS_IF_ENABLED_IN_CONFIG(pite) )


#define IS_IF_ENABLED_BOUND(pite) \
        (IS_IF_ENABLED(pite)&&IS_IF_BOUND(pite))

#define IS_IF_DELETED(pite) \
        ((pite)->Status&IF_DELETED_FLAG)

#define IS_IF_NOT_DELETED(pite) \
        (!((pite)->Status&IF_DELETED_FLAG))


#define IS_IF_ACTIVATED(pite) \
        ( !((pite)->Status&IF_DELETED_FLAG) && ((pite)->Status&IF_ACTIVATED_FLAG) )



//-------------------------------
// QUERIER STATES 0x<Querier><0>
//-------------------------------

#define QUERIER               0x10


#define IS_IF_VER2(pite)        IS_PROTOCOL_TYPE_IGMPV2(pite)
#define IS_IF_VER1(pite)        IS_PROTOCOL_TYPE_IGMPV1(pite)
#define IS_IF_VER3(pite)        IS_PROTOCOL_TYPE_IGMPV3(pite)
#define GET_IF_VERSION(_pite)    (_pite)->Config.IgmpProtocolType
#define IS_QUERIER(pite)        ((pite)->Info.QuerierState & QUERIER)

//
// interlocked operations not required, as state is of type uchar
//
#define SET_QUERIER_STATE_QUERIER(state)         (state |= 0x10)
#define SET_QUERIER_STATE_NON_QUERIER(state)     (state &= 0x01)


#define IF_PROCESS_GRPQUERY(pite) \
    ( (IS_IF_VER2(pite)||IS_IF_VER3(pite)) && !IS_RAS_SERVER_IF(pite->IfType) )

#define IF_PROCESS_LEAVES(pite)  \
    ( IS_IF_VER2(pite) && (IS_QUERIER(pite)) && !IS_RAS_SERVER_IF(pite->IfType))

#define GI_PROCESS_GRPQUERY(pite, pgie) \
    ( IF_PROCESS_GRPQUERY(pite)&& ((pgie->Version==2)||(pgie->Version==3)) )


#define CAN_ADD_GROUPS_TO_MGM(pite)         \
        ( (IS_IGMPRTR_ENABLED_BY_MGM(pite)) \
        && (IS_MPROTOCOL_PRESENT_ON_IGMPRTR(pite) || (IS_QUERIER(pite))) \
        )


//
// INTERFACE STATE
//
#define GET_EXTERNAL_IF_STATE(pite, State) {\
    State = 0;\
    if (IS_IF_ENABLED_BY_RTRMGR(pite)) \
        State |= IGMP_STATE_ENABLED_BY_RTRMGR; \
    if (IS_IF_ENABLED_IN_CONFIG(pite))\
        State |= IGMP_STATE_ENABLED_IN_CONFIG; \
    if (IS_PROTOCOL_TYPE_ROUTER(pite)) {\
        if (IS_IGMPRTR_ENABLED_BY_MGM(pite)) \
            State |= IGMP_STATE_ENABLED_BY_MGM; \
        if (CAN_ADD_GROUPS_TO_MGM(pite)) \
            State |= IGMP_STATE_MGM_JOINS_ENABLED; \
    } \
    else \
        State |= IGMP_STATE_ENABLED_BY_MGM; \
    \
    if (IS_IF_BOUND(pite)) \
        State |= IGMP_STATE_BOUND;\
}

//
//filter macros
//

#define GMI     TRUE
#define LMI     FALSE
#define STATIC  0xff
#define MGM_YES TRUE
#define MGM_NO  FALSE


//------------------------------------------------------------------------------
// other locking macros
//------------------------------------------------------------------------------

#define ACQUIRE_GLOBAL_LOCK(proc) ENTER_CRITICAL_SECTION(&g_CS, "g_CS", proc)
#define RELEASE_GLOBAL_LOCK(proc) LEAVE_CRITICAL_SECTION(&g_CS, "g_CS", proc)



// 
// instead of using goto:end to go to the end of the block, use the following 
//
#define BEGIN_BREAKOUT_BLOCK1    do
#define GOTO_END_BLOCK1          goto END_BREAKOUT_BLOCK_1
#define END_BREAKOUT_BLOCK1      while(FALSE); END_BREAKOUT_BLOCK_1:
#define BEGIN_BREAKOUT_BLOCK2    do
#define GOTO_END_BLOCK2          goto END_BREAKOUT_BLOCK_2
#define END_BREAKOUT_BLOCK2      while(FALSE); END_BREAKOUT_BLOCK_2:


//------------------------------------------------------------------------------
// memory allocation/deallocation macros
//------------------------------------------------------------------------------

#if DEBUG_FLAGS_MEM_ALLOC

typedef struct _MEM_HDR {
    LIST_ENTRY Link;
    ULONG Signature;
    ULONG Id;
    ULONG IfIndex;
    PDWORD Tail;
} MEM_HDR, *PMEM_HDR;    

PVOID
IgmpDebugAlloc(
    DWORD sz,
    DWORD Flags,
    DWORD Id,
    DWORD IfIndex
    );

VOID
IgmpDebugFree(
    PVOID mem
    );
VOID
DebugScanMemory(
    );
VOID
DebugScanMemoryInterface(
    DWORD IfIndex
    );

#define IGMP_ALLOC(sz,Id,If)    IgmpDebugAlloc((sz),0,Id,If)

#define IGMP_ALLOC_AND_ZERO(sz,Id,If) IgmpDebugAlloc((sz),HEAP_ZERO_MEMORY,Id,If)
#define IGMP_FREE(p)            {\
    IgmpDebugFree(p);\
    }
#define IGMP_FREE_NOT_NULL(p)   if (p) IGMP_FREE(p)



#else
#define IGMP_ALLOC(sz,Id,If)          HeapAlloc(g_Heap,0,(sz))

#define IGMP_ALLOC_AND_ZERO(sz,Id,If) HeapAlloc(g_Heap,HEAP_ZERO_MEMORY,(sz))

//deldel
//#define IGMP_FREE(p)            HeapFree(g_Heap, 0, (p))
//#define IGMP_FREE_NOT_NULL(p)   ((p) ? IGMP_FREE(p) : TRUE)

#define IGMP_FREE(p)            {\
    HeapFree(g_Heap, 0, (p));\
    }
//    Trace1(ENTER1, "Freed heap:%0x", PtrToUlong(p));\

    
#define IGMP_FREE_NOT_NULL(p)   if (p)IGMP_FREE(p)

#define IgmpDebugAlloc(sz,Flags,Id,IfIndex)
#define IgmpDebugFree(mem)
#define DebugScanMemoryInterface(IfIndex)
#define DebugScanMemory()


#endif



#define PROCESS_ALLOC_FAILURE2(ptr, TraceMsg, Error,arg2, GotoStmt) \
    if (ptr==NULL) {\
        Error = ERROR_NOT_ENOUGH_MEMORY;\
        Trace2(ERR, TraceMsg, Error, arg2); \
        GotoStmt;\
    }


#define PROCESS_ALLOC_FAILURE3(ptr, TraceMsg, Error,arg2,arg3, GotoStmt) \
    if (ptr==NULL) {\
        Error = ERROR_NOT_ENOUGH_MEMORY;\
        Trace3(ERR, TraceMsg, Error, arg2, arg3); \
        GotoStmt;\
    }



//
// assert macros
//
#if DBG

#define IgmpAssert(exp){                                                \
    if(!(exp))                                                          \
    {                                                                   \
        TracePrintf(TRACEID,                                            \
                    "Assertion failed in %s : %d \n",__FILE__,__LINE__);\
        RouterAssert(#exp,__FILE__,__LINE__,NULL);                      \
    }                                                               \
}
#if DEBUG_FLAGS_ASSERT_ON_ERRORS
#define IgmpAssertOnError(exp) IgmpAssert(exp)
#define IgmpDbgBreakPoint() DbgBreakPoint()
#else
#define IgmpAssertOnError(exp) ;
#define IgmpDbgBreakPoint() ;
#endif

// if not DBG
#else
#define IgmpAssert(exp)  ;
#define IgmpAssertOnError(exp) ;


#define IgmpDbgBreakPoint() /*deldel*/
#endif


#define INSERT_IN_SORTED_LIST(_pInsertList, _pEntry, _Field, _STRUCT, _Link) {\
    \
    _STRUCT *pTmp;\
    PLIST_ENTRY pHead, ple;\
    \
    pHead = _pInsertList;\
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {\
    \
        pTmp = CONTAINING_RECORD(ple, _STRUCT, _Link);\
        if (pTmp->_Field > _pEntry->_Field)\
            break;\
    }\
    \
    InsertTailList(ple, &_pEntry->_Link);\
}

#define SEARCH_IN_SORTED_LIST(_pList,_Value,_Field,_STRUCT,_Link,_pEntry) {\
    PLIST_ENTRY ple;\
    _pEntry = NULL;\
    \
    for (ple=(_pList)->Flink;  ple!=_pList;  ple=ple->Flink) {\
        _pEntry = CONTAINING_RECORD(ple, _STRUCT, _Link);\
        if ((_Value >= _pEntry)->_Field) {\
            if ((_pEntry)->_Field != _Value) \
                _pEntry = NULL;\
            break;\
        }\
    }\
}


//
// NETWORK_TO_LITTLE_ENDIAN macro
//

#define NETWORK_TO_LITTLE_ENDIAN(Group) ( (((Group)&0x000000ff)<<24) \
                                         +(((Group)&0x0000ff00)<<8)  \
                                         +(((Group)&0x00ff0000)>>8)  \
                                         +(((Group)&0xff000000)>>24) )


#define MIN(a,b) ((a)<(b) ? (a) : (b))
#define MAX(a,b) ((a)>(b) ? (a) : (b))

#define IS_NOT_EQ_ANY2(a, A,B) ((a!=A)&&(a!=B))
#define IS_EQ_ANY(a,A,B) ((a==A)||(a==B))

//
// signature macros for Interface-Group lists enumeration
//
#define GET_NEXT_SIGNATURE()  (g_GlobalIfGroupEnumSignature++ | 0x10 )
//#define SET_SIGNATURE(a,b) ((a) = ((b)<<16) | (a&0x00FF))
#define SET_SIGNATURE(a,b) (a = (b))




//
// define enum values
//
#define ADD_FLAG       1
#define DELETE_FLAG    0


#define NON_QUERIER_FLAG        1
#define QUERIER_FLAG            2
#define QUERIER_CHANGE_V1_ONLY  4


#define STATIC_GROUP     1
#define NOT_STATIC_GROUP 0
#define ANY_GROUP_TYPE   2

#define NOT_RAS_CLIENT   0
#define RAS_CLIENT       1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\igmptimer.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File Name: igmptimer.h
//
// Abstract:
//      This module contains declarations related to igmptimer.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//
//=============================================================================

#ifndef _IGMP_TIMER_H_
#define _IGMP_TIMER_H_

VOID
DebugCheckTimerContexts(
    );

//
// set the debug timer flags, so that I can control the amount of tracing 
// printed out.
//
#if DBG
    #ifndef DEBUG_TIMER_LEVEL
    #define DEBUG_TIMER_LEVEL 0x11
    #endif
#else
    #ifdef DEBUG_TIMER_LEVEL
    #undef DEBUG_TIMER_LEVEL
    #endif
    //deldel change to 00 from 11
    #define DEBUG_TIMER_LEVEL 0x00
#endif
#define DBG_Y TRUE
#define DBG_N FALSE

#define DEBUG_TIMER_ACTIVITY        (DEBUG_TIMER_LEVEL & 0x00000001)
#define DEBUG_TIMER_TIMERID         (DEBUG_TIMER_LEVEL & 0x00000010)
#define DEBUG_FLAGS_SIGNATURE       (DEBUG_TIMER_LEVEL & 0x00000010)
#define DEBUG_TIMER_PROCESSQUEUE1   (DEBUG_TIMER_LEVEL & 0x00000020)
#define DEBUG_TIMER_PROCESSQUEUE2   (DEBUG_TIMER_LEVEL & 0x00000040)
#define DEBUG_TIMER_RESYNCTIMER     (DEBUG_TIMER_LEVEL & 0x00000080)

#define DEBUG_TIMER_REMOVETIMER1    (DEBUG_TIMER_LEVEL & 0x00000100)
#define DEBUG_TIMER_REMOVETIMER2    (DEBUG_TIMER_LEVEL & 0x00000200)
#define DEBUG_TIMER_INSERTTIMER1    (DEBUG_TIMER_LEVEL & 0x00001000)
#define DEBUG_TIMER_INSERTTIMER2    (DEBUG_TIMER_LEVEL & 0x00002000)
#define DEBUG_TIMER_UPDATETIMER1    (DEBUG_TIMER_LEVEL & 0x00010000)
#define DEBUG_TIMER_PACKET          (DEBUG_TIMER_LEVEL & 0x00020000)

//------------------------------------------------------------------------------
// GLOBAL DEFINITIONS
//

// number of buckets in Timer Table
// 0-14,14-28,28-42,... last bucket has >63*14=882 secs (all approx)
//
#define NUM_TIMER_BUCKETS         64

#if DEBUG_TIMER_TIMERID
    extern DWORD TimerId;
#endif






typedef struct _IGMP_TIMER_ENTRY {

    LIST_ENTRY          Link;

    LONGLONG            Timeout;
    LPTHREAD_START_ROUTINE   Function;
    PVOID               Context;
    UCHAR               Status;
            
    #if DEBUG_TIMER_TIMERID
    DWORD               Id; 
    DWORD               Id2;
    DWORD               IfIndex;
    DWORD               Group;
    DWORD               Source;
    DWORD               Signature; //0xfadfad01
    #endif
        
} IGMP_TIMER_ENTRY, *PIGMP_TIMER_ENTRY;


#if DEBUG_FLAGS_SIGNATURE && DEBUG_TIMER_TIMERID
#define CHECK_TIMER_SIGNATURE(pte) {\
    if ((pte)->Signature != 0xfadfad01)\
        IgmpDbgBreakPoint();\
    }
#else
#define CHECK_TIMER_SIGNATURE(pte)
#endif

typedef struct _IGMP_TIMER_GLOBAL {

    HANDLE              WTTimer;         // timer set with wait server
    HANDLE              WTTimer1;
    
    LONGLONG            WTTimeout;       // timeout value set with wait server
    LONGLONG            SyncTime;        // time when time queue last reordered
    LARGE_INTEGER       CurrentTime;
    DWORD               NumTimers;
    
    DWORD               TableLowIndex;
    LIST_ENTRY          TimesTable[NUM_TIMER_BUCKETS];    // array of times
    
    UCHAR               Status;
    
    CRITICAL_SECTION    CS;
    BOOL                CSFlag;
    
} IGMP_TIMER_GLOBAL, *PIGMP_TIMER_GLOBAL;

#define GET_IGMP_CURRENT_TIME( ) igmp.WTTimer.CurrentTime.QuadPart


// TIMER_STATUS
#define TIMER_STATUS_CREATED           0x01
#define TIMER_STATUS_INACTIVE          0x02
#define TIMER_STATUS_ACTIVE            0x04
#define TIMER_STATUS_FIRED             0x08
#define TIMER_STATUS_DELETED           0x80


//
// MACROS
//

#define IS_TIMER_ACTIVE(pTimer)         ((pTimer).Status & TIMER_STATUS_ACTIVE)


#define SET_TIMER_INFINITE(time) \
    time = 0
    

#define IS_TIMER_INFINITE(time) \
    (time == 0)

#if DEBUG_FLAGS_SIGNATURE //deldel
#define ACQUIRE_TIMER_LOCK(proc)  { \
        ENTER_CRITICAL_SECTION(&g_TimerStruct.CS, "g_TimerStruct.CS1", proc); \
        ++g_TimerStruct.CSFlag; \
        }

#define RELEASE_TIMER_LOCK(proc)  {\
        --g_TimerStruct.CSFlag; \
        LEAVE_CRITICAL_SECTION(&g_TimerStruct.CS, "g_TimerStruct.CS1", proc); \
        }
#define CHECK_IF_ACQUIRED_TIMER_LOCK() {\
        if (g_TimerStruct.CSFlag<=0) IgmpDbgBreakPoint();\
        }
        
#else
#define ACQUIRE_TIMER_LOCK(proc)  { \
        ENTER_CRITICAL_SECTION(&g_TimerStruct.CS, "g_TimerStruct.CS1", proc); \
        }

#define RELEASE_TIMER_LOCK(proc)  {\
        LEAVE_CRITICAL_SECTION(&g_TimerStruct.CS, "g_TimerStruct.CS1", proc); \
        }
#define CHECK_IF_ACQUIRED_TIMER_LOCK()
#endif


#define SET_TIMER_ID(_pTimer, _Id1, _IfIndex, _Group, _Source) {\
    (_pTimer)->Id = _Id1; \
    (_pTimer)->Id2 = TimerId++;\
    (_pTimer)->IfIndex = _IfIndex;\
    (_pTimer)->Group = _Group; \
    (_pTimer)->Source = _Source; \
    (_pTimer)->Signature = 0xfadfad01; \
    }
//
// currently all times mentioned in the config structure are in seconds
//
#define CONV_CONFIG_TO_INTERNAL_TIME(time) \
        (time *= 1000)
#define CONFIG_TO_INTERNAL_TIME(time) \
        ((time) * 1000)
#define CONV_INTERNAL_TO_CONFIG_TIME(time) \
        (time /= 1000);
#define CONFIG_TO_SYSTEM_TIME(time) \
        (time)
#define SYSTEM_TIME_TO_SEC(time) \
        ((DWORD)((time) / (LONGLONG)1000L))
#define SYSTEM_TIME_TO_MSEC(time) \
        ((DWORD)(time))


        
//
//FUNCTION PROTOTYPES
//

LONGLONG
GetCurrentIgmpTime(
    );    

VOID    
UpdateLocalTimer (
    PIGMP_TIMER_ENTRY   pte,
    LONGLONG            llNewTime,
    BOOL                bDbgPrint
    );

VOID
RemoveTimer (
    PIGMP_TIMER_ENTRY   pte,
    BOOL bDbg
    );

DWORD
InsertTimer (
    PIGMP_TIMER_ENTRY   pte,
    LONGLONG            llNewTime,
    BOOL                bResync,
    BOOL                bDbg
    );

ULONG
QueryRemainingTime(
    PIGMP_TIMER_ENTRY pte,
    LONGLONG        llCurTime
    );


DWORD
InitializeTimerGlobal (
    );

VOID
DeInitializeTimerGlobal (
    );


VOID
DebugPrintTimerEntry (
    PIGMP_TIMER_ENTRY   pte,
    DWORD               dwBucket,
    LONGLONG            llCurTime
    );
VOID
GetTimerDebugInfo(
    CHAR                str1[20],
    CHAR                str2[20],
    DWORD              *pdwDiffTime,
    PIGMP_TIMER_ENTRY   pte,
    LONGLONG            llCurtime
    );

DWORD
DebugScanTimerQueue(
    DWORD Id
    );

VOID
DebugPrintTimerQueue (
    );    

#endif //ifndef _IGMP_TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\makefile.inc ===
$(O)\igmpmsg.mc: log.h
    mapmsg NET IGMPLOG_BASE log.h > $(O)\igmpmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\igmptrace.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File Name: igmptrace.h
//
// Abstract:
//      This module contains declarations related to tracing.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
//=============================================================================

#ifndef _IGMPTRACE_H_
#define _IGMPTRACE_H_

#ifdef MIB_DEBUG
    #if !DBG 
    #undef MIB_DEBUG
    #endif
#endif

//kslksl remove below
#define DBG1 0
//deldel

// constants and macros used for tracing 
//

#define IGMP_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)

#define IGMP_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)

#define IGMP_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IGMP_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IGMP_TRACE_START           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IGMP_TRACE_STOP            ((DWORD)0x00020000 | TRACE_USE_MASK)

#define IGMP_TRACE_IF              ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IGMP_TRACE_CONFIG          ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IGMP_TRACE_RECEIVE         ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IGMP_TRACE_SEND            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IGMP_TRACE_QUERIER         ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IGMP_TRACE_GROUP           ((DWORD)0x00200000 | TRACE_USE_MASK) 
#define IGMP_TRACE_MGM             ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IGMP_TRACE_SOURCES         ((DWORD)0x00800000 | TRACE_USE_MASK)
//kslksl deldel
#define IGMP_TRACE_TIMER           ((DWORD)0x10000000 | TRACE_USE_MASK)
#if DBG
#define IGMP_TRACE_TIMER1          ((DWORD)0x40000000 | TRACE_USE_MASK)
#define IGMP_TRACE_ENTER1          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IGMP_TRACE_MEM             ((DWORD)0x80000000 | TRACE_USE_MASK)
#define IGMP_TRACE_KSL             ((DWORD)0x01000000 | TRACE_USE_MASK)
#else
//deldel
#define IGMP_TRACE_TIMER1          ((DWORD)0x40000000 | TRACE_USE_MASK)
#define IGMP_TRACE_ENTER1          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IGMP_TRACE_MEM             ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_KSL             ((DWORD)0x00000000 | TRACE_USE_MASK)
#endif

#if DBG1


#define IGMP_TRACE_WORKER          ((DWORD)0x01000000 | TRACE_USE_MASK)
//#define IGMP_TRACE_ENTER1          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IGMP_TRACE_LEAVE1          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IGMP_TRACE_MIB             ((DWORD)0x04000000 | TRACE_USE_MASK) 

#define IGMP_TRACE_DYNLOCK         ((DWORD)0x08000000 | TRACE_USE_MASK)
#define IGMP_TRACE_CS              ((DWORD)0x20000000 | TRACE_USE_MASK)
#define IGMP_TRACE_CS1             ((DWORD)0x80000000 | TRACE_USE_MASK)

#else

#define IGMP_TRACE_WORKER          ((DWORD)0x00000000 | TRACE_USE_MASK)
//#define IGMP_TRACE_ENTER1          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_LEAVE1          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_MIB             ((DWORD)0x00000000 | TRACE_USE_MASK) 

#define IGMP_TRACE_DYNLOCK         ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_CS              ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_CS1             ((DWORD)0x00000000 | TRACE_USE_MASK)

#endif




#ifdef LOCK_DBG

#define ENTER_CRITICAL_SECTION(pcs, type, proc)             \
            Trace2(CS,"----To enter %s in %s", type, proc);    \
            EnterCriticalSection(pcs);                         \
            Trace2(CS1,"----Entered %s in %s", type, proc)
            
#define LEAVE_CRITICAL_SECTION(pcs, type, proc)         \
            Trace2(CS1,"----Left %s in %s", type, proc);    \
            LeaveCriticalSection(pcs)

#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
        Trace2(EVENT, "++++To wait for singleObj %s in %s", type, proc);    \
        WaitForSingleObject(event, time);    \
        Trace2(EVENT, "++++WaitForSingleObj returned %s in %s", type, proc)

#define SET_EVENT(event, type, proc) \
        Trace2(EVENT, "++++SetEvent %s in %s", type, proc);    \
        SetEvent(event)
        
#else 
#define ENTER_CRITICAL_SECTION(pcs, type, proc) \
            EnterCriticalSection(pcs)
            
#define LEAVE_CRITICAL_SECTION(pcs, type, proc)    \
            LeaveCriticalSection(pcs)
            
#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
        WaitForSingleObject(event, time)
        
#define SET_EVENT(event, type, proc) \
        SetEvent(event)
            
#endif // LOCK_DBG


#define TRACEID         g_TraceId


#define Trace0(l,a)             \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f,g)
#define Trace7(l,a,b,c,d,e,f,g,h)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f,g,h)
#define Trace8(l,a,b,c,d,e,f,g,h,i)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f,g,h,i)
#define Trace9(l,a,b,c,d,e,f,g,h,i,j)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f,g,h,i,j)


#define TRACEDUMP(l,a,b,c)      \
            TraceDumpEx(TRACEID,l,a,b,c,TRUE)
            



#ifdef ENTER_DBG

#define TraceEnter(X)  TracePrintfEx(TRACEID, IGMP_TRACE_ENTER, "Entered: "X)
#define TraceLeave(X)  TracePrintfEx(TRACEID, IGMP_TRACE_ENTER, "Leaving: "X"\n")
#else   

#define TraceEnter(X)
#define TraceLeave(X)

#endif // ENTER_DBG

//
// Event logging macros
//

#define LOGLEVEL        g_Config.LoggingLevel
#define LOGHANDLE       g_LogHandle

// Error logging

#define Logerr0(msg,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg, "")
#define Logerr1(msg,Format,a,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a))
#define Logerr2(msg,Format,a,b,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) { \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a),(b)); \
        }
#define Logerr3(msg,Format,a,b,c,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) { \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a),(b),(c)); \
        }
#define Logerr4(msg,Format,a,b,c,d,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) { \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a),(b),(c),(d)); \
        }


// Warning logging
#define Logwarn0(msg,err) \
        if (LOGLEVEL >= IGMP_LOGGING_WARN) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_WARNING_TYPE,\
                (err),IGMPLOG_ ## msg, "")
#define Logwarn1(msg,Format,a,err) \
        if (LOGLEVEL >= IGMP_LOGGING_WARN) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_WARNING_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a))
#define Logwarn2(msg,Format,a,b,err) \
        if (LOGLEVEL >= IGMP_LOGGING_WARN) { \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_WARNING_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a),(b)); \
        }

// Information logging
#define Loginfo0(msg,err) \
        if (LOGLEVEL >= IGMP_LOGGING_INFO) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_INFORMATION_TYPE,\
                (err),IGMPLOG_ ## msg, "")

#define Loginfo1(msg,Format,a,err) \
        if (LOGLEVEL >= IGMP_LOGGING_INFO) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_INFORMATION_TYPE,\
                (err),IGMPLOG_ ## msg, Format,(a))

#define Loginfo2(msg,Format,a,b,err) \
        if (LOGLEVEL >= IGMP_LOGGING_INFO) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_INFORMATION_TYPE,\
                (err),IGMPLOG_ ## msg, Format,(a),(b))



//
// IP address conversion macro:
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//

#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )
#define INET_COPY(p1, p2) {\
    LPSTR tmp;\
    tmp = INET_NTOA(p2); \
    if ((tmp)) lstrcpy((p1),tmp); \
    else *(p1) = '\0'; \
    }
    
#define INET_CAT(p1, p2) {\
    LPSTR tmp; \
    tmp = INET_NTOA(p2); \
    if ((tmp)) lstrcat((p1),tmp);\
    }
#endif // _IGMPTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\log.h ===
#define IGMPLOG_BASE                           41000

#define IGMPLOG_INIT_CRITSEC_FAILED            (IGMPLOG_BASE + 1)
/*
 * IGMP was unable to initialize a critical section.
 * The data is the exception code.
 */

#define IGMPLOG_HEAP_CREATE_FAILED             (IGMPLOG_BASE + 2)
/*
 * IGMP was unable to create a heap.
 * The data is the error code.
 */

#define IGMPLOG_HEAP_ALLOC_FAILED              (IGMPLOG_BASE + 3)
/*
 * IGMP was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define IGMPLOG_IGMP_ALREADY_STARTED           (IGMPLOG_BASE + 4)
/*
 * IGMP received a start request when it was already running.
 */

#define IGMPLOG_WSASTARTUP_FAILED              (IGMPLOG_BASE + 5)
/*
 * IGMP was unable to start Windows Sockets.
 * The data is the error code.
 */

#define IGMPLOG_CREATE_RWL_FAILED              (IGMPLOG_BASE + 6)
/*
 * IGMP was unable to create a synchronization object.
 * The data is the error code.
 */

#define IGMPLOG_CREATE_EVENT_FAILED            (IGMPLOG_BASE + 7)
/*
 * IGMP was unable to create an event.
 * The data is the error code.
 */

#define IGMPLOG_CREATE_SEMAPHORE_FAILED        (IGMPLOG_BASE + 8)
/*
 * IGMP was unable to create a semaphore.
 * The data is the error code.
 */

#define IGMPLOG_CREATE_SOCKET_FAILED           (IGMPLOG_BASE + 9)
/*
 * IGMP was unable to create a socket.
 * The data is the error code.
 */

#define IGMPLOG_IGMP_STARTED                   (IGMPLOG_BASE + 10)
/*
 * IGMP has started successfully.
 */

#define IGMPLOG_QUEUE_WORKER_FAILED            (IGMPLOG_BASE + 11)
/*
 * IGMP could not schedule a task to be executed.
 * This may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define IGMPLOG_RECVFROM_FAILED                (IGMPLOG_BASE + 12)
/*
 * IGMP was unable to receive an incoming message
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_PACKET_TOO_SMALL               (IGMPLOG_BASE + 13)
/*
 * IGMP received a packet which was smaller than the minimum size
 * allowed for IGMP packets. The packet has been discarded.
 * It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define IGMPLOG_PACKET_VERSION_INVALID         (IGMPLOG_BASE + 14)
/*
 * IGMP received a packet with an invalid version in its header.
 * The packet has been discarded. It was received on the local interface
 * with IP address %1, and it came from the neighboring router
 * with IP address %2.
 */ 

#define IGMPLOG_PACKET_HEADER_CORRUPT          (IGMPLOG_BASE + 15)
/*
 * IGMP received a packet with an invalid header. The packet has been
 * discarded. It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define IGMPLOG_QUERY_FROM_RAS_CLIENT          (IGMPLOG_BASE + 16)
/*
 * Router received a general query from RAS Client(%1) on interface
 * with IP address %2.
 * RAS clients are not supposed to send queries.
 */

#define IGMPLOG_VERSION_QUERY                 (IGMPLOG_BASE + 17)
/*
 * Different version router with IP Address %1
 * exists on the interface with IP address %2.
 */
 
#define IGMPLOG_SENDTO_FAILED                  (IGMPLOG_BASE + 19)
/*
 * IGMP was unable to send a packet from the interface with IP address %1
 * to the IP address %2.
 * The data is the error code.
 */

#define IGMPLOG_PACKET_VERSION_MISMATCH        (IGMPLOG_BASE + 20)
/*
 * IGMP discarded a version %1 packet received on the interface
 * with IP address %2 from a neighbor with IP address %3.
 * The above interface is configured to accept only version %4 packets.
 */

#define IGMPLOG_ENUM_NETWORK_EVENTS_FAILED     (IGMPLOG_BASE + 21)
/*
 * Igmpv2 was unable to enumerate network events on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_INPUT_RECORD_ERROR             (IGMPLOG_BASE + 22)
/*
 * Igmpv2 detected an error on the local interface with IP address %1.
 * The error occurred while the interface was receiving packets.
 * The data is the error code.
 */

#define IGMPLOG_EVENTSELECT_FAILED             (IGMPLOG_BASE + 23)
/*
 * Igmpv2 was unable to request notification of events
 * on the socket for the local interface with IP address %1.
 * The data is the error code.
 */
 
#define IGMPLOG_CREATE_SOCKET_FAILED_2         (IGMPLOG_BASE + 24)
/*
 * IGMP was unable to create a socket for the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_BIND_FAILED                    (IGMPLOG_BASE + 25)
/*
 * IGMP could not bind to port 520 on the socket for
 * the local interface with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_CONNECT_FAILED                 (IGMPLOG_BASE + 26)
/*
 * IGMP could not be configured on Ras Client %1 on interface with
 * index %2.
 * The data is the error code.
 */
 
#define IGMPLOG_DISCONNECT_FAILED              (IGMPLOG_BASE + 27)
/*
 * Unable to disable IGMP on Ras Client %1 on the interface with
 * index %2.
 * The data is the error code.
 */
 
#define IGMPLOG_SET_MCAST_IF_FAILED            (IGMPLOG_BASE + 28)
/*
 * IGMP could not request multicasting on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_SET_ROUTER_ALERT_FAILED        (IGMPLOG_BASE + 29)
/*
 * IGMP could not set router alert option on the local interface
 * with IP address %1.
 * The data is the error code.
 */
 
#define IGMPLOG_SET_HDRINCL_FAILED             (IGMPLOG_BASE + 30)
/*
 * IGMP could not set the IP header include option on interface
 * with IP address %1.
 * The data is the error code.
 */
 
#define IGMPLOG_JOIN_GROUP_FAILED              (IGMPLOG_BASE + 31)
/*
 * IGMP could not join the multicast group %1
 * on the local interface with IP address %2.
 * The data is the error code.
 */
 
#define IGMPLOG_LEAVE_GROUP_FAILED             (IGMPLOG_BASE + 32)
/*
 * IGMP could not leave the multicast group %1
 * on the local interface with IP address %2.
 * The data is the error code.
 */

#define IGMPLOG_PROTO_ALREADY_STOPPING         (IGMPLOG_BASE + 33)
/*
 * StopProtocol() called to stop Igmp when it is 
 * already being stopped.
 * The data is the error code.
 */

#define IGMPLOG_PROXY_IF_EXISTS                (IGMPLOG_BASE + 34)
/*
 * AddInterface() called to add an Igmp Proxy interface.
 * Igmp proxy already owns another interface.
 * The data is the error code.
 */

#define IGMPLOG_RAS_IF_EXISTS                  (IGMPLOG_BASE + 35)
/*
 * AddInterface() called to add an Igmp Ras interface.
 * Ras Server cannot exist on multiple interfaces.
 * The data is the error code.
 */

#define IGMPLOG_MGM_REGISTER_FAILED             (IGMPLOG_BASE + 36)
/*
 * IGMP Router failed to register with MGM.
 * The data is the error code.
 */

#define IGMPLOG_MGM_PROXY_REGISTER_FAILED       (IGMPLOG_BASE + 37)
/*
 * IGMP Proxy failed to register with MGM.
 * The data is the error code.
 */


 #define IGMPLOG_MGM_TAKE_IF_OWNERSHIP_FAILED   (IGMPLOG_BASE + 38)
/*
 * MgmTakeInterfaceOwnership() failed.
 * The data is the error code.
 */

 #define IGMPLOG_ROBUSTNESS_VARIABLE_EQUAL_1    (IGMPLOG_BASE + 39)
/*
 * The robustness variable is being set to 1 for Igmp router 
 * on Interface %1.
 * You should avoid setting it to 1.
 */

 #define IGMPLOG_INVALID_VALUE                 (IGMPLOG_BASE + 40)
/*
 * One of the values passed to Igmp is invalid.
 * %1
 */

#define IGMPLOG_REGISTER_WAIT_SERVER_FAILED    (IGMPLOG_BASE + 41)
/*
 * The wait-events-timers could not be registered with the 
 * wait server thread. Alertable threads might not have 
 * been initialized in Rtutils.
 * The data is the error code.
 */

#define IGMPLOG_IGMP_STOPPED                   (IGMPLOG_BASE + 42)
/*
 * IGMP has stopped.
 */
 
 #define IGMPLOG_CAN_NOT_COMPLETE              (IGMPLOG_BASE + 43)
 /*
  * Fatal error. Could not complete.
  * The data is the error code.
  */

 #define IGMPLOG_INVALID_VERSION               (IGMPLOG_BASE + 44)
 /*
  * The version field in the IGMP config field is incorrect.
  * Delete and create the IGMP config again.
  */

 #define IGMPLOG_INVALID_PROTOTYPE              (IGMPLOG_BASE + 45)
/*
 * IGMP Protocol type for interface %1 has invalid value %2.
 * The data is the error code.
 */

 #define IGMPLOG_PROXY_ON_RAS_SERVER        (IGMPLOG_BASE + 46)
/*
 * Cannot configure Proxy on RAS server interface %1.
 */

 #define IGMPLOG_INVALID_STATIC_GROUP        (IGMPLOG_BASE + 47)
/*
 * Static group %1 configured on Interface%2 not a valid MCast address.
 */

 #define IGMPLOG_INVALID_STATIC_MODE        (IGMPLOG_BASE + 48)
/*
 * Static group %1 configured on Interface:%2 does not have valid mode.
 */

 #define IGMPLOG_INVALID_STATIC_FILTER        (IGMPLOG_BASE + 49)
/*
 * Static group %1 configured on Interface:%2 has invalid filter.
 */

 #define IGMPLOG_INVALID_ROBUSTNESS        (IGMPLOG_BASE + 50)
/*
 * Invalid robustness variable:%1 configured on Interface:%2. Max 7.
 */

 #define IGMPLOG_INVALID_STARTUPQUERYCOUNT        (IGMPLOG_BASE + 51)
/*
 * Invalid Startup Query Count:%1 configured on Interface:%2.
 */

 #define IGMPLOG_INTERFACE_RTR_ACTIVATED        (IGMPLOG_BASE + 52)
/*
 * IGMP-Rtr-V%1 activated on Interface:%2.
 */

 #define IGMPLOG_INTERFACE_PROXY_ACTIVATED        (IGMPLOG_BASE + 53)
/*
 * IGMP Proxy activated on Interface:%1.
 */

 #define IGMPLOG_ACTIVATION_FAILURE_PROXY        (IGMPLOG_BASE + 54)
/*
 * Failed to install IGMP Proxy on interface:%1.
 */

 #define IGMPLOG_ACTIVATION_FAILURE_RTR        (IGMPLOG_BASE + 55)
/*
 * Failed to install IGMP Rtr-V-%1 on interface:%2.
 */

 #define IGMPLOG_RTR_DEACTIVATED        (IGMPLOG_BASE + 56)
/*
 * Failed to install IGMP Rtr-V-%1 on interface:%2.
 */

 #define IGMPLOG_PROXY_DEACTIVATED        (IGMPLOG_BASE + 57)
/*
 * Failed to install IGMP Rtr-V-%1 on interface:%2.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\mgmigmp.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: mgmigmp.h
//
// Abstract:
//      This file contains prototypes for functions implemented in mgmigmp.h
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//=============================================================================


#ifndef _MGMIGMP_H_
#define _MGMIGMP_H_

                
#define  MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pite,NHAddr, Src,Mask1,Group,Mask2,Flag) {\
    DWORD RetVal;\
    if (CAN_ADD_GROUPS_TO_MGM(pite)) {\
        RetVal = MgmAddGroupMembershipEntry(g_MgmIgmprtrHandle,\
                    Src, Mask1, Group, Mask2, (pite)->IfIndex, NHAddr, Flag);\
        Trace5(MGM, "Add <%d.%d.%d.%d: %d.%d.%d.%d> If:%0x to MGM Mode:%d [%d]",\
            PRINT_IPADDR(Group), PRINT_IPADDR(Src), pite->IfIndex, Flag, RetVal);\
    }\
}

#define  MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(pite,NHAddr, Src,Mask1,Group,Mask2,Flag){\
    DWORD RetVal;\
    if (CAN_ADD_GROUPS_TO_MGM(pite)){\
        RetVal = MgmDeleteGroupMembershipEntry(g_MgmIgmprtrHandle,\
                    Src, Mask1, Group, Mask2, (pite)->IfIndex, NHAddr, Flag);\
        Trace5(MGM, "Delete <%d.%d.%d.%d: %d.%d.%d.%d> If:%0x from MGM Mode:%d [%d]",\
            PRINT_IPADDR(Group), PRINT_IPADDR(Src), pite->IfIndex,Flag,RetVal);\
    }\
}

typedef struct _PROXY_ALERT_ENTRY {
    LIST_ENTRY Link;
    DWORD   Group;
    DWORD   Source;
    DWORD   bPrune;
} PROXY_ALERT_ENTRY, *PPROXY_ALERT_ENTRY;

VOID
WF_ProcessProxyAlert (
    PVOID pContext
    );


DWORD
RegisterProtocolWithMgm(
    DWORD   ProxyOrRouter
    );

    
DWORD
IgmpRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    PDWORD          dwInIfIndex,
    PDWORD          dwInIfNextHopAddr,
    PDWORD          dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    );


DWORD
ProxyRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           *dwInIfIndex,
    DWORD           *dwInIfNextHopAddr,
    DWORD           *dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    );

DWORD
IgmpRtrCreationAlertCallback ( 
    DWORD           Source,
    DWORD           dwSourceMask,
    DWORD           Group,
    DWORD           dwGroupMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    DWORD           dwIfCount,     
    PMGM_IF_ENTRY   Oif
    );

DWORD
ProxyCreationAlertCallback ( 
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    DWORD           dwIfCount,     
    PMGM_IF_ENTRY   pmieOutIfList
    );

DWORD
ProxyPruneAlertCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr,
    BOOL            bMemberDelete,
    PDWORD          pdwTimeout
    );

DWORD 
ProxyJoinAlertCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    BOOL            bMemberUpdate
    );

DWORD 
ProcessProxyGroupChange (
    DWORD           dwSourceAddr,
    DWORD           dwGroup,
    BOOL            bAddFlag,
    BOOL            bStaticGroup
    );


DWORD
RefreshAllMembersCallback (
    DWORD           IfIndex
    );
    
DWORD
IgmpRefreshJoinsCallback (
    DWORD           dwIfIndex,
    DWORD           dwNHAddr
);

DWORD
MgmChangeIgmprtrStatus (
    DWORD   IfIndex,
    BOOL    Flag
    );

DWORD
RefreshMgmIgmprtrGroups (
    PIF_TABLE_ENTRY pite,
    BOOL            Flag
    );
    
#endif //_MGMIGMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\mgmigmp.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: mgmigmp.c
//
// Abstract:
//      This file the calls and callbacks with respect to mgm
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//=============================================================================

#include "pchigmp.h"
#pragma hdrstop

VOID
DebugPrintProxyGroupTable (
    );


    
#define DISABLE_FLAG    0
#define ENABLE_FLAG     1



//------------------------------------------------------------------------------
//          _MgmDisableIgmprtrCallback
//
// This call is made by mgm to igmp. After this call, till igmp is enabled 
// again, no more AddMembership calls will be made to Mgm. However, igmp
// will be owning the interface and will be functioning normally.
//------------------------------------------------------------------------------

DWORD
MgmDisableIgmprtrCallback(
    DWORD   IfIndex,
    DWORD   NHAddr  //not used
    )
{
    return MgmChangeIgmprtrStatus(IfIndex, DISABLE_FLAG);
}



//------------------------------------------------------------------------------
//          _MgmEnableIgmprtrCallback
//
// This call is made by mgm to igmprtr. igmprtr should refresh all group joins.
//------------------------------------------------------------------------------

DWORD
MgmEnableIgmprtrCallback(
    DWORD   IfIndex,
    DWORD   NHAddr  //not used
    )
{
    return MgmChangeIgmprtrStatus(IfIndex, ENABLE_FLAG);
}



//------------------------------------------------------------------------------
//          MgmChangeIgmprtrStatus
//------------------------------------------------------------------------------
DWORD
MgmChangeIgmprtrStatus (
    DWORD   IfIndex,
    BOOL    Flag
    )
{    
    PIF_TABLE_ENTRY     pite;
    DWORD               Error=NO_ERROR, dwRetval;
    BOOL                PrevCanAddGroupsToMgm;
    
    
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    Trace0(ENTER1, "Entering MgmDisableIgmpCallback");


    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "MgmDisableIgmpCallback");

    BEGIN_BREAKOUT_BLOCK1 {
    
        //
        // retrieve the interface entry
        //
        pite = GetIfByIndex(IfIndex);


        //
        // return error if interface does not exist, or it is not activated
        // or is already in that state
        //
        if ( (pite == NULL)||(!IS_IF_ACTIVATED(pite))
            || ((Flag==ENABLE_FLAG)&&(IS_IGMPRTR_ENABLED_BY_MGM(pite)))
            || ((Flag==DISABLE_FLAG)&&(!IS_IGMPRTR_ENABLED_BY_MGM(pite)))
            ) 
        {
            if (Flag==ENABLE_FLAG) {
                Trace1(ERR, 
                    "MgmEnableIgmpCallback(): interface:%0x nonexistant or active",
                    IfIndex);
                IgmpAssertOnError(FALSE);
            }
            else {
                Trace1(ERR, 
                    "MgmDisableIgmpCallback(): interface:%0x nonexistant or inactive",
                    IfIndex);
                IgmpAssertOnError(FALSE);
            }
            
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }
        
        

        PrevCanAddGroupsToMgm = CAN_ADD_GROUPS_TO_MGM(pite);

        
        if (Flag==ENABLE_FLAG) {
            DWORD   dwProtoId, dwComponentId;
            
            // set the status field to enabled.
            MGM_ENABLE_IGMPRTR(pite);

            MgmGetProtocolOnInterface(IfIndex, 0, &dwProtoId, &dwComponentId);
            
            if (dwProtoId!=PROTO_IP_IGMP)
                SET_MPROTOCOL_PRESENT_ON_IGMPRTR(pite);
                
        }
        else {
            // set the flag to disabled and also reset MProtocol present field
            MGM_DISABLE_IGMPRTR(pite);
            
        }            

        if (PrevCanAddGroupsToMgm && !CAN_ADD_GROUPS_TO_MGM(pite))
            Trace1(MGM, "Igmp Router stop propagating groups to MGM on If:%0x",
                        IfIndex);

        if (!PrevCanAddGroupsToMgm && CAN_ADD_GROUPS_TO_MGM(pite))
            Trace1(MGM, "Igmp Router start propagating groups to MGM on If:%0x",
                        IfIndex);
                        

        //
        // for all the groups for this interface, call MgmDeleteGroupMembershipEntry
        //

        if (CAN_ADD_GROUPS_TO_MGM(pite)) {

            if (Flag==ENABLE_FLAG)
                RefreshMgmIgmprtrGroups(pite, ADD_FLAG);
            else 
                RefreshMgmIgmprtrGroups(pite, DELETE_FLAG);

        }         
        

                                            
    } END_BREAKOUT_BLOCK1;


    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "MgmDisableIgmpCallback");

    Trace1(LEAVE1, "Leaving MgmDisableIgmpCallback(%d)", Error);
    LeaveIgmpApi();
    return Error;
}


//------------------------------------------------------------------------------
//          RefreshMgmIgmprtrGroups
//------------------------------------------------------------------------------

DWORD
RefreshMgmIgmprtrGroups (
    PIF_TABLE_ENTRY pite,
    BOOL            Flag
    )
{
    PLIST_ENTRY         pHead, ple;
    PGI_ENTRY           pgie;
    DWORD               Error=NO_ERROR;
    PGI_SOURCE_ENTRY pSourceEntry;
    

    ACQUIRE_ENUM_LOCK_EXCLUSIVE("_RefreshMgmIgmprtrGroups");
    ACQUIRE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_RefreshMgmIgmprtrGroups");

    pHead = &pite->ListOfSameIfGroups;

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

        pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);


        if (Flag==ADD_FLAG) {

            if (pgie->Version==1 || pgie->Version==2
                || (pgie->Version==3 && pgie->FilterType==EXCLUSION) )
            {
                MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pite, pgie->NHAddr, 0, 0,
                    pgie->pGroupTableEntry->Group,
                    0xffffffff, MGM_JOIN_STATE_FLAG);
            }
            else {//ver3 inclusion

                PLIST_ENTRY pSourceHead, pSourceLE;
                
                pSourceHead = &pgie->V3InclusionListSorted;
                for (pSourceLE=pSourceHead->Flink;  pSourceLE!=pSourceHead;  
                    pSourceLE=pSourceLE->Flink)
                {
                    pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, LinkSourcesInclListSorted);
                    MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pite, pgie->NHAddr, pSourceEntry->IpAddr, 0xffffffff,
                        pgie->pGroupTableEntry->Group,
                        0xffffffff, MGM_JOIN_STATE_FLAG);
                }

            }
        }
        else {

            if (pgie->Version==1 || pgie->Version==2
                || (pgie->Version==3 && pgie->FilterType==EXCLUSION) )
            {
                MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(pite, pgie->NHAddr, 0, 0,
                    pgie->pGroupTableEntry->Group,
                    0xffffffff, MGM_JOIN_STATE_FLAG);
            }
            else {//ver3 inclusion

                PLIST_ENTRY pSourceHead, pSourceLE;

                pSourceHead = &pgie->V3InclusionListSorted;
                for (pSourceLE=pSourceHead->Flink;  pSourceLE!=pSourceHead;  
                    pSourceLE=pSourceLE->Flink)
                {
                    pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, LinkSourcesInclListSorted);
                    MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(pite, pgie->NHAddr,
                        pSourceEntry->IpAddr, 0xffffffff,
                        pgie->pGroupTableEntry->Group, 0xffffffff, MGM_JOIN_STATE_FLAG);
                }
            }
        }
    }

    RELEASE_ENUM_LOCK_EXCLUSIVE("_RefreshMgmIgmprtrGroups");
    RELEASE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_RefreshMgmIgmprtrGroups");


    return Error;
}


//------------------------------------------------------------------------------
//              RegisterProtocolWithMgm
//------------------------------------------------------------------------------
DWORD
RegisterProtocolWithMgm(
    DWORD   ProxyOrRouter
    )
{
    DWORD                       Error=NO_ERROR;
    ROUTING_PROTOCOL_CONFIG     rpiInfo; //for mgm

    
    // register router with mgm
    
    if (ProxyOrRouter==PROTO_IP_IGMP) {

        ZeroMemory(&rpiInfo, sizeof(rpiInfo));
        rpiInfo.dwCallbackFlags = 0;
        rpiInfo.pfnRpfCallback 
                    = (PMGM_RPF_CALLBACK)IgmpRpfCallback;
        rpiInfo.pfnCreationAlertCallback 
                    = (PMGM_CREATION_ALERT_CALLBACK)IgmpRtrCreationAlertCallback;
        rpiInfo.pfnPruneAlertCallback 
                    = NULL;
        rpiInfo.pfnJoinAlertCallback 
                    = NULL;
        rpiInfo.pfnWrongIfCallback 
                    = NULL;
        rpiInfo.pfnLocalJoinCallback 
                    = NULL;
        rpiInfo.pfnLocalLeaveCallback 
                    = NULL;
        rpiInfo.pfnEnableIgmpCallback
                    = MgmEnableIgmprtrCallback;
                    
        rpiInfo.pfnDisableIgmpCallback
                    = MgmDisableIgmprtrCallback;

                    
                    
        Error = MgmRegisterMProtocol( &rpiInfo, PROTO_IP_IGMP, IGMP_ROUTER_V2,
                                        &g_MgmIgmprtrHandle);
        if (Error!=NO_ERROR) {
            Trace1(ERR, "Error:%d registering IGMP Router with MGM", Error);
            IgmpAssertOnError(FALSE);
            Logerr0(MGM_REGISTER_FAILED, Error);
            return Error;
        }
    }

    // register proxy with mgm
    
    else {

        //
        // register Igmp proxy with MGM. I register Proxy irrespective of whether
        // this router might be setup as a proxy or not.
        //
        
        rpiInfo.dwCallbackFlags = 0;
        rpiInfo.pfnRpfCallback 
                    = (PMGM_RPF_CALLBACK)ProxyRpfCallback;
        rpiInfo.pfnCreationAlertCallback 
                    = (PMGM_CREATION_ALERT_CALLBACK)ProxyCreationAlertCallback;
        rpiInfo.pfnPruneAlertCallback 
                    = (PMGM_PRUNE_ALERT_CALLBACK)ProxyPruneAlertCallback;
        rpiInfo.pfnJoinAlertCallback 
                    = (PMGM_JOIN_ALERT_CALLBACK)ProxyJoinAlertCallback;
        rpiInfo.pfnWrongIfCallback 
                    = NULL;
        rpiInfo.pfnLocalJoinCallback 
                    = NULL;
        rpiInfo.pfnLocalLeaveCallback 
                    = NULL;


        Error = MgmRegisterMProtocol( &rpiInfo, PROTO_IP_IGMP_PROXY, IGMP_PROXY,
                                        &g_MgmProxyHandle);
                                        
        if (Error!=NO_ERROR) {
            Trace1(ERR, "Error:%d registering Igmp Proxy with Mgm", Error);
            IgmpAssertOnError(FALSE);
            Logerr0(MGM_PROXY_REGISTER_FAILED, Error);            
            return Error;
        }
    }

    return Error;
}


//------------------------------------------------------------------------------
//          IgmpRpfCallback
//------------------------------------------------------------------------------
DWORD
IgmpRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    PDWORD          dwInIfIndex,
    PDWORD          dwInIfNextHopAddr,
    PDWORD          dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    )
/*++
Routine Description:
    Called by MGM when a packet is received on an interface owned by Igmp to see
    if it can go ahead and create an MFE. Igmp does an Rpf check with RTM 
    and returns the value. No check is done to see if the interface is really
    owned by igmp. It doesnt matter if the interface is activated or not.
--*/
{
    DWORD   Error = NO_ERROR;
    
#if RTMv2
    return Error;
#else


    PRTM_IP_ROUTE   prirRpfRoute = (PRTM_IP_ROUTE) pbBuffer; 

    // enterIgmpApi not required, as this call cannot be made when igmp is not up    
    
    //
    // Perform Rpf check with Rtm 
    //
    if (RtmLookupIPDestination(dwSourceAddr, prirRpfRoute)==TRUE) {
    
        if (prirRpfRoute->RR_InterfaceID!=*dwInIfIndex) {

            *dwInIfIndex = prirRpfRoute->RR_InterfaceID;
            
            // the route was found, but the interface is incorrect
            Error = ERROR_INVALID_PARAMETER;
        }
        else {
            // rpf check successful
            Error = NO_ERROR;
        }
    }
    else {
        // route not found
        Error = ERROR_NOT_FOUND;
    }
    
    Trace4(MGM, 
        "Rpf callback for MGroup(%d.%d.%d.%d) Src(%d.%d.%d.%d) IncomingIf(%0x):%d",
        PRINT_IPADDR(dwGroupAddr), PRINT_IPADDR(dwSourceAddr), *dwInIfIndex, Error);


    return Error;
#endif
}



//------------------------------------------------------------------------------
//          ProxyRpfCallback
//------------------------------------------------------------------------------
DWORD
ProxyRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           *dwInIfIndex,
    DWORD           *dwInIfNextHopAddr,
    DWORD           *dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    )
/*++
Routine Description:
    Called by MGM when a packet is received on an interface owned by Proxy to see
    if it can go ahead and create an MFE. Proxy does an Rpf check with RTM 
    and returns the value. No check is done to see if the interface is really
    owned by igmp. It doesnt matter if the interface is activated or not.
--*/
{
    DWORD   Error = NO_ERROR;
    
#if RTMv2
    return Error;
#else
    // enterIgmpApi not required, as this call cannot be made when igmp is not up    
    

    PRTM_IP_ROUTE   prirRpfRoute = (PRTM_IP_ROUTE) pbBuffer; 

    //
    // Perform Rpf check with Rtm 
    //
    if (RtmLookupIPDestination(dwSourceAddr, prirRpfRoute)==TRUE) {
    
        if (prirRpfRoute->RR_InterfaceID!=*dwInIfIndex) {

            *dwInIfIndex = prirRpfRoute->RR_InterfaceID;

        
            // the route was found, but the interface is incorrect
            Error = ERROR_INVALID_PARAMETER;
        }
            
        else {
            // rpf check successful
            Error = NO_ERROR;
        }
    }
    else {
        // route not found
        Error = ERROR_NOT_FOUND;
    }
    
    Trace4(MGM, 
        "Rpf callback for MGroup(%d.%d.%d.%d) Src(%d.%d.%d.%d) IncomingIf(%0x):%d",
        PRINT_IPADDR(dwGroupAddr), PRINT_IPADDR(dwSourceAddr), *dwInIfIndex, Error);


    return Error;
#endif
}

//------------------------------------------------------------------------------
//          IgmpRtrCreationAlertCallback
//------------------------------------------------------------------------------
DWORD
IgmpRtrCreationAlertCallback ( 
    DWORD           Source,
    DWORD           dwSourceMask,
    DWORD           Group,
    DWORD           dwGroupMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    DWORD           dwIfCount,     
    PMGM_IF_ENTRY   Oif
    )
/*++
Routine Description:
    Called when the first interface owned by some other protocol joins any group.
    This routine does nothing, as igmp does not send any joins upstream.
Return Value:
    NO_ERROR
--*/
{
    DWORD       i, IfIndex, NextHop;
    DWORD       Error=NO_ERROR;
    PIF_TABLE_ENTRY         pite;
    PGROUP_TABLE_ENTRY      pge;
    PGI_ENTRY               pgie;
    PGI_SOURCE_ENTRY        pSourceEntry;

    
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    for (i=0;  i<dwIfCount;  i++) {

        IfIndex = Oif[i].dwIfIndex;
        NextHop = Oif[i].dwIfNextHopAddr;
        if (!Oif[i].bIGMP)
            continue;


        ACQUIRE_IF_LOCK_SHARED(IfIndex, "_IgmpRtrCreationAlertCallback");

        //
        // retrieve the interface
        //
        pite = GetIfByIndex(IfIndex);
        if ( (pite==NULL) || !IS_IF_ACTIVATED(pite) ) {

            Oif[i].bIsEnabled = FALSE;
            
            Trace1(IF,
                "_IgmpRtrCreationAlertCallback: interface %0x not found/activated", 
                IfIndex);
            RELEASE_IF_LOCK_SHARED(IfIndex, "_IgmpRtrCreationAlertCallback");
            continue;
        }

        // if interface is not version 3, then return true immediately
        if (!IS_IF_VER3(pite)) {
            Oif[i].bIsEnabled = TRUE;
            RELEASE_IF_LOCK_SHARED(IfIndex, "_IgmpRtrCreationAlertCallback");
            continue;
        }
        
        
        ACQUIRE_GROUP_LOCK(Group, "_IgmpRtrCreationAlertCallback");

        BEGIN_BREAKOUT_BLOCK1 {
        
            pge = GetGroupFromGroupTable(Group, NULL, 0);
            if (pge==NULL) {
                Oif[i].bIsEnabled = FALSE;
                Error = ERROR_CAN_NOT_COMPLETE;
                GOTO_END_BLOCK1;
            }

            pgie = GetGIFromGIList(pge, pite, NextHop, FALSE, NULL, 0);
            if (pgie==NULL) {
                Oif[i].bIsEnabled = FALSE;
                Error = ERROR_CAN_NOT_COMPLETE;
                GOTO_END_BLOCK1;
            }

            // if pgie not ver3 return true immediately
            if (pgie->Version != 3) {
                Oif[i].bIsEnabled = TRUE;
                GOTO_END_BLOCK1;
            }

            
            pSourceEntry = GetSourceEntry(pgie, Source,
                    pgie->FilterType, NULL, 0, 0);
    
            if ( (pgie->FilterType==INCLUSION && pSourceEntry==NULL)
                || (pgie->FilterType==EXCLUSION && pSourceEntry!=NULL) )
            {
                Oif[i].bIsEnabled = FALSE;
            }
            else {
                Oif[i].bIsEnabled = TRUE;
            }
            
        } END_BREAKOUT_BLOCK1;

        RELEASE_GROUP_LOCK(Group, "_IgmpRtrCreationAlertCallback");
        RELEASE_IF_LOCK_SHARED(IfIndex, "_IgmpRtrCreationAlertCallback");
        
    }//for all IFs in Oif

    for (i=0;  i<dwIfCount;  i++) {
        Trace6(MGM,
            "[%d] IGMP-Rtr Creation Alert: <%d.%d.%d.%d : %d.%d.%d.%d> : <%0x:%0x> : :bIgmp:%d",
            Oif[i].bIsEnabled, PRINT_IPADDR(Group), PRINT_IPADDR(Source),
            Oif[i].dwIfIndex, Oif[i].dwIfNextHopAddr, 
            Oif[i].bIGMP
            );
    }
    
    LeaveIgmpApi();

    return NO_ERROR;
}


//------------------------------------------------------------------------------
//          ProxyCreationAlertCallback
//------------------------------------------------------------------------------
DWORD
ProxyCreationAlertCallback ( 
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    DWORD           dwIfCount,     
    PMGM_IF_ENTRY   pmieOutIfList
    )
/*++
Routine Description:
    Called when the first interface owned by some other protocol joins any group.
    This routine does nothing, as igmp does not send any joins upstream.
Return Value:
    NO_ERROR
--*/
{
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    LeaveIgmpApi();

    return NO_ERROR;
}

//------------------------------------------------------------------------------
//          ProxyPruneAlertCallback
//------------------------------------------------------------------------------
DWORD
ProxyPruneAlertCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr,//not used
    BOOL            bMemberDelete,
    PDWORD          pdwTimeout
    )
/*++
Routine Description:
    Called by MGM when the outgoing interface list of an MFE becomes empty,
    or when the last interface for a group goes off.
    Proxy owns the incoming interface. Proxy leaves the Group on the incoming
    interface if no more members exist for that group. Also sets the timeout 
    value for the negative MFE.
--*/
{
    DWORD           Error=NO_ERROR;
    PPROXY_ALERT_ENTRY pProxyAlertEntry;

        
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    if (pdwTimeout!=NULL)
        *pdwTimeout = 300000;

    // ignoring ProxyPruneAlertCallback for MFE deletion
    if (!bMemberDelete) {
        LeaveIgmpApi();
        return NO_ERROR;
    }

    ACQUIRE_PROXY_ALERT_LOCK("_ProxyPruneAlertCallback");

    BEGIN_BREAKOUT_BLOCK1 {
    
        pProxyAlertEntry = IGMP_ALLOC(sizeof(PROXY_ALERT_ENTRY), 0xa00,g_ProxyIfIndex);

        PROCESS_ALLOC_FAILURE2(pProxyAlertEntry,
            "error %d allocating %d bytes",
            Error, sizeof(PROXY_ALERT_ENTRY),
            GOTO_END_BLOCK1);

        pProxyAlertEntry->Group = dwGroupAddr;
        pProxyAlertEntry->Source = dwSourceAddr;
        pProxyAlertEntry->bPrune = TRUE;

        InsertTailList(&g_ProxyAlertsList, &pProxyAlertEntry->Link);
        
        Trace0(WORKER, "Queueing _WF_ProcessProxyAlert() to prune");
        QueueIgmpWorker(WF_ProcessProxyAlert, NULL);

    } END_BREAKOUT_BLOCK1;
    
    RELEASE_PROXY_ALERT_LOCK("_ProxyPruneAlertCallback");

    LeaveIgmpApi();
    return NO_ERROR;
}


VOID
WF_ProcessProxyAlert (
    PVOID pContext
    )
{
    DWORD           ProxyIfIndex, Error = NO_ERROR;
    PIF_TABLE_ENTRY pite;

    
    if (!EnterIgmpWorker()) return;

    Trace0(ENTER1, "Entering WF_ProcessProxyAlert()");


    //
    // acquire lock on the interface and make sure that it exists
    //
    while (1) {
        ProxyIfIndex = g_ProxyIfIndex;
    
        ACQUIRE_IF_LOCK_EXCLUSIVE(ProxyIfIndex, "_Wf_ProcessProxyAlert");

        // the interface was a proxy interface
        if (ProxyIfIndex==g_ProxyIfIndex)
            break;

        // someone changed the proxy interface. so try to access it again.
        else {
            RELEASE_IF_LOCK_EXCLUSIVE(ProxyIfIndex, 
                "_Wf_ProcessProxyAlert");
        }
    }

    
    BEGIN_BREAKOUT_BLOCK1 {

        //
        // make sure that the Proxy handle is correct
        //
            
        pite = g_pProxyIfEntry;

        if ( (g_ProxyIfIndex==0)||(pite==NULL) ) 
        {
            Trace1(ERR, 
                "Proxy(Deletion/Creation)Alert Callback by MGM for "
                "interface(%0x) not owned by Igmp-Proxy",
                g_ProxyIfIndex);
            IgmpAssertOnError(FALSE);
            Error = ERROR_NO_SUCH_INTERFACE;
            GOTO_END_BLOCK1;
        }

        if (!(IS_IF_ACTIVATED(g_pProxyIfEntry))) {
            Trace1(ERR, 
                "Proxy(Deletion/Creation)Alert Callback by MGM for "
                "inactivated Proxy interface(%0x)",
                g_ProxyIfIndex);
            IgmpAssertOnError(FALSE);
            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }

        while (TRUE) {

            PPROXY_ALERT_ENTRY pProxyAlertEntry;
            DWORD           Group, Source;
            BOOL            bPrune;
            
            
            ACQUIRE_PROXY_ALERT_LOCK("_WF_ProcessProxyAlert");

            if (IsListEmpty(&g_ProxyAlertsList)) {
                RELEASE_PROXY_ALERT_LOCK("_WF_ProcessProxyAlert");
                break;
            }

            pProxyAlertEntry = CONTAINING_RECORD(g_ProxyAlertsList.Flink, 
                                    PROXY_ALERT_ENTRY, Link);
            Group = pProxyAlertEntry->Group;
            Source = pProxyAlertEntry->Source;
            bPrune = pProxyAlertEntry->bPrune;
            RemoveEntryList(&pProxyAlertEntry->Link);
            IGMP_FREE(pProxyAlertEntry);


            Trace3(MGM, "Received %s for Grp(%d.%d.%d.%d), Src(%d.%d.%d.%d)",
                (bPrune)? "ProxyPruneAlertCallback"
                    :"ProxyJoinAlertCallback",
                PRINT_IPADDR(Group), PRINT_IPADDR(Source)
                );
                
            RELEASE_PROXY_ALERT_LOCK("_WF_ProcessProxyAlert");


            //
            // delete/add group from Proxy's group list. decrement/increment refcount
            //
            ProcessProxyGroupChange(Source, Group, 
                bPrune?DELETE_FLAG:ADD_FLAG, NOT_STATIC_GROUP);
        }
        
    } END_BREAKOUT_BLOCK1;


    RELEASE_IF_LOCK_EXCLUSIVE(g_ProxyIfIndex, "_ProcessProxyGroupChange");

    
    LeaveIgmpWorker();    
    Trace0(LEAVE1, "Leaving _Wf_ProcessProxyAlert()");
    return;
    
} //_wf_processProxyAlert



//------------------------------------------------------------------------------
//          _ProxyNewMemberCallback
//------------------------------------------------------------------------------
DWORD 
ProxyJoinAlertCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    BOOL            bMemberDelete
    )
{
    DWORD           Error=NO_ERROR;
    PPROXY_ALERT_ENTRY pProxyAlertEntry;

    
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }


    // ignoring ProxyJoinAlertCallback for MFE deletion
    if (!bMemberDelete) {
        LeaveIgmpApi();
        return NO_ERROR;
    }

    ACQUIRE_PROXY_ALERT_LOCK("_ProxyJoinAlertCallback");

    BEGIN_BREAKOUT_BLOCK1 {
    
        pProxyAlertEntry = IGMP_ALLOC(sizeof(PROXY_ALERT_ENTRY), 0x200,g_ProxyIfIndex);

        PROCESS_ALLOC_FAILURE2(pProxyAlertEntry,
            "error %d allocating %d bytes",
            Error, sizeof(PROXY_ALERT_ENTRY),
            GOTO_END_BLOCK1);

        pProxyAlertEntry->Group = dwGroupAddr;
        pProxyAlertEntry->Source = dwSourceAddr;
        pProxyAlertEntry->bPrune = FALSE;

        InsertTailList(&g_ProxyAlertsList, &pProxyAlertEntry->Link);
        
        Trace0(WORKER, "Queueing _WF_ProcessProxyAlert() to Join");
        QueueIgmpWorker(WF_ProcessProxyAlert, NULL);

    } END_BREAKOUT_BLOCK1;
    
    RELEASE_PROXY_ALERT_LOCK("_ProxyJoinAlertCallback");

    LeaveIgmpApi();
    return NO_ERROR;
}



//------------------------------------------------------------------------------
//          ProcessProxyGroupChange
//------------------------------------------------------------------------------
DWORD 
ProcessProxyGroupChange (
    DWORD       dwSourceAddr,
    DWORD       dwGroup,
    BOOL        bAddFlag,
    BOOL        bStaticGroup
    )
/*++
Routine Description:
    Called when a group is being joined/left by some interface. As proxy acts
    as an igmp host on that interface, it does a join/leave for that group
    on that interface. 
    There can be both static and dynamic joins. There is no distinction between 
    them. They will just bump up the refcount.
Return Value:
    ERROR_NO_SUCH_INTERFACE, ERROR_CAN_NOT_COMPLETE, NO_ERROR
Called by:
    
--*/
{
    PIF_TABLE_ENTRY        pite;
    PLIST_ENTRY            ple, pHead;
    DWORD                  Error = NO_ERROR;
    DWORD                  GroupLittleEndian = NETWORK_TO_LITTLE_ENDIAN(dwGroup);
    PLIST_ENTRY pHeadSrc, pleSrc;
    PPROXY_SOURCE_ENTRY pSourceEntry = NULL;


    
    //
    // if Proxy does not exist, or is not activated, then return error
    //
    if ( (g_pProxyIfEntry==NULL) 
            || (!(IS_IF_ACTIVATED(g_pProxyIfEntry))) ) 
    {
        Trace0(ERR, "Leaving ProcessProxyGroupChange(): Proxy not active");
        IgmpAssertOnError(FALSE);
        
        if (g_pProxyIfEntry==NULL)
            return ERROR_NO_SUCH_INTERFACE;
        else
            return ERROR_CAN_NOT_COMPLETE;
    }
        

    pite = g_pProxyIfEntry;


    BEGIN_BREAKOUT_BLOCK1 {
    
        PPROXY_GROUP_ENTRY  ppge, ppgeNew;

        pHead = &pite->pProxyHashTable[PROXY_HASH_VALUE(dwGroup)];

        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            ppge = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, HT_Link);
            if ( GroupLittleEndian <= ppge->GroupLittleEndian )
                break;
        }

        //
        // adding group to proxy
        //     
        if (bAddFlag) {

            //new group addition

            //
            // the group entry does not exist
            //
            //ppge may not be valid(if ple==pHead)
            if ( (ple==pHead)||(dwGroup!=ppge->Group) ) {
                         
                ppgeNew = IGMP_ALLOC(sizeof(PROXY_GROUP_ENTRY), 0x400,0xaaaa);

                PROCESS_ALLOC_FAILURE2(ppgeNew, 
                        "error %d allocating %d bytes for Proxy group entry",
                        Error, sizeof(PROXY_GROUP_ENTRY),
                        GOTO_END_BLOCK1);

                InitializeListHead(&ppgeNew->ListSources);
                ppgeNew->NumSources = 0;
                ppgeNew->Group = dwGroup;
                ppgeNew->GroupLittleEndian = GroupLittleEndian;
                ppgeNew->RefCount = 0;

                InsertTailList(ple, &ppgeNew->HT_Link);

                InsertInProxyList(pite, ppgeNew);

                // set the time when the entry was created.
                ppgeNew->InitTime = GetCurrentIgmpTime();

                ppgeNew->bStaticGroup = (dwSourceAddr==0)? bStaticGroup : FALSE;

                
                //
                // update stats
                //
                InterlockedIncrement(&pite->Info.CurrentGroupMemberships);
                InterlockedIncrement(&pite->Info.GroupMembershipsAdded);

                ppge = ppgeNew;

                // join the group
                if (dwSourceAddr==0) {
                    Error = JoinMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 0);
                    ppgeNew->RefCount = 1;
                }
                // else process source entry later
                
                ppge->FilterType = (dwSourceAddr==0)? EXCLUSION : INCLUSION;
                
            } //end new group entry created

            // increase group refcount
            else if (dwSourceAddr==0) {

                //
                // leave all source mode joins and join *,G
                //
                if (ppge->RefCount==0) {
                    pHeadSrc = &ppge->ListSources;
                    for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; pleSrc=pleSrc->Flink) {

                        pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                            PROXY_SOURCE_ENTRY, LinkSources);
                        Error = LeaveMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                pSourceEntry->IpAddr);
                        pSourceEntry->JoinMode = IGMP_GROUP_NO_STATE;
                        pSourceEntry->JoinModeIntended = IGMP_GROUP_ALLOW;
                    }
                    
                    Error = JoinMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                pite->IfIndex, pite->IpAddr, 0);
                    ppge->FilterType = EXCLUSION;
                }
                
                ppge->RefCount++;
                ppge->bStaticGroup |= bStaticGroup;
                
            } //group entry exists. group join

            if (dwSourceAddr!=0) {

                // check if source already present
                            
                pHeadSrc = &ppge->ListSources;
                for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; pleSrc=pleSrc->Flink) {

                    pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                        PROXY_SOURCE_ENTRY, LinkSources);
                    if (pSourceEntry->IpAddr >= dwSourceAddr)
                        break;
                }

                // create new source 
                if (pleSrc==pHeadSrc ||
                    (pSourceEntry //(dont need to check pSourceEntry)
                        && pSourceEntry->IpAddr!=dwSourceAddr))
                {

                    pSourceEntry = (PPROXY_SOURCE_ENTRY) IGMP_ALLOC_AND_ZERO(sizeof(PROXY_SOURCE_ENTRY), 
                                                                            0x800,g_ProxyIfIndex);
                    PROCESS_ALLOC_FAILURE2(pSourceEntry,
                        "error %d allocating %d bytes",
                        Error,
                        sizeof(PROXY_SOURCE_ENTRY),
                        GOTO_END_BLOCK1);
                        
                    InsertTailList(pleSrc, &pSourceEntry->LinkSources);
                    pSourceEntry->IpAddr = dwSourceAddr;
                    pSourceEntry->RefCount = 1;
                    pSourceEntry->bStaticSource = bStaticGroup;
                    ppge->NumSources++;

                    //
                    // if not joined the whole group. have to join individual 
                    // sources
                    //
                    if (ppge->FilterType==INCLUSION) {
                        Error = JoinMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                dwSourceAddr);
                        pSourceEntry->JoinMode = IGMP_GROUP_ALLOW;
                    }
                    else {
                        pSourceEntry->JoinMode = IGMP_GROUP_NO_STATE;
                    }
                    pSourceEntry->JoinModeIntended = IGMP_GROUP_ALLOW;

                } //end new source

                // join: source already exists
                else 
                    if (pSourceEntry) // dont need to check this. suppress warning
                {
                    //
                    // join back an excluded source
                    //
                    if (pSourceEntry->JoinMode==IGMP_GROUP_BLOCK) {

                        if (!pSourceEntry->bStaticSource) {

                            UnBlockSource(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                dwSourceAddr);
                            RemoveEntryList(&pSourceEntry->LinkSources);
                            IGMP_FREE(pSourceEntry);
                        }

                    }

                    else {//fix this
                        if (bStaticGroup)
                            pSourceEntry->bStaticSource = TRUE;

                        pSourceEntry->RefCount++;
                    }
                }//end: join when existing source
            }
        }

        //
        // deleting group from proxy
        //
        else {

            if ((ple==pHead) || (dwGroup>ppge->Group) ) {
                Error = ERROR_CAN_NOT_COMPLETE;
                GOTO_END_BLOCK1;
            }
            else {

                // leave source
                
                if (dwSourceAddr!=0) {

                    pHeadSrc = &ppge->ListSources;
                    for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; pleSrc=pleSrc->Flink) {

                        pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                            PROXY_SOURCE_ENTRY, LinkSources);
                        if (pSourceEntry->IpAddr >= dwSourceAddr)
                            break;
                    }

                    // leave source: source does not exist
                    if ((pleSrc==pHeadSrc) || (pSourceEntry->IpAddr!=dwSourceAddr)) {

                        // if in exclude mode then create an exclusion entry
                        if (ppge->FilterType==EXCLUSION) {

                            pSourceEntry = (PPROXY_SOURCE_ENTRY) IGMP_ALLOC_AND_ZERO(sizeof(PROXY_SOURCE_ENTRY), 
                                                                                    0x800,g_ProxyIfIndex);
                            PROCESS_ALLOC_FAILURE2(pSourceEntry,
                                "error %d allocating %d bytes",
                                Error,
                                sizeof(PROXY_SOURCE_ENTRY),
                                GOTO_END_BLOCK1);
                                
                            InsertTailList(pleSrc, &pSourceEntry->LinkSources);
                            pSourceEntry->IpAddr = dwSourceAddr;
                            pSourceEntry->RefCount = 1;
                            pSourceEntry->bStaticSource = bStaticGroup;
                            ppge->NumSources++;
                            Error = BlockSource(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                dwSourceAddr);
                            pSourceEntry->JoinMode = IGMP_GROUP_BLOCK;
                            pSourceEntry->JoinModeIntended = IGMP_GROUP_BLOCK;

                        }
                        else { //include mode. trying to leave non-existing source
                            IgmpAssert(FALSE);
                        }
                            
                        GOTO_END_BLOCK1;
                    }

                    // leave source: source exists
                    else {

                        if ( (pSourceEntry->JoinMode==IGMP_GROUP_ALLOW)
                            ||(pSourceEntry->JoinMode==IGMP_GROUP_NO_STATE)
                            ) {
                            if (--pSourceEntry->RefCount==0) {
                                if (pSourceEntry->JoinMode==IGMP_GROUP_ALLOW) {
                                    Error = LeaveMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, dwSourceAddr);
                                }
                                RemoveEntryList(&pSourceEntry->LinkSources);
                                IGMP_FREE(pSourceEntry);
                                
                                if (--ppge->NumSources==0) {

                                    if (ppge->RefCount==0) {
                                        RemoveEntryList(&ppge->HT_Link);
                                        RemoveEntryList(&ppge->LinkBySameIfGroups);
                                        IGMP_FREE(ppge);
                                        InterlockedDecrement(&pite->Info.CurrentGroupMemberships); 
                                    }
                                }
                            }
                            else {
                                if (bStaticGroup)
                                    pSourceEntry->bStaticSource = FALSE;
                            }
                        }
                        else {
                            //if (!pSourceEntry->bStaticSource || ++pSourceEntry->RefCount>2)
                                //IgmpAssert(FALSE);
                                // do nothing. this might happen
                        }
                    }
                } // end leave source

                // leave group
                else  if (--ppge->RefCount == 0) {
                
                    Error = LeaveMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                pite->IfIndex, pite->IpAddr, 0);

                    // if no S,G then delete this group, else join the 
                    // individual sources

                    if (ppge->NumSources==0) {
                        RemoveEntryList(&ppge->HT_Link);
                        RemoveEntryList(&ppge->LinkBySameIfGroups);
                        
                        IGMP_FREE(ppge);

                        //
                        // update stats
                        //
                        InterlockedDecrement(&pite->Info.CurrentGroupMemberships);
                    }
                    else {

                        pHeadSrc = &ppge->ListSources;
                        for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; pleSrc=pleSrc->Flink) {

                            pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                                PROXY_SOURCE_ENTRY, LinkSources);
                                                
                            Error = JoinMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                pSourceEntry->IpAddr);
                            pSourceEntry->JoinMode = IGMP_GROUP_ALLOW;
                            pSourceEntry->JoinModeIntended = IGMP_GROUP_ALLOW;
                        }
                    }
                }
                else {
                    if (bStaticGroup)
                        ppge->bStaticGroup = FALSE;
                }
            }
        }
          
    } END_BREAKOUT_BLOCK1;


    return NO_ERROR;
    
} //end ProcessProxyGroupChange


VOID
DebugPrintProxyGroupTable (
    )
{
    PIF_TABLE_ENTRY        pite;
    PLIST_ENTRY            ple, pHead;
    DWORD                  Error = NO_ERROR, dwCount;
    PPROXY_GROUP_ENTRY     ppge;
    

    //
    // if Proxy does not exist, or is not activated, then return error
    //
    if ( (g_pProxyIfEntry==NULL) 
            || (!(IS_IF_ACTIVATED(g_pProxyIfEntry))) ) 
    {
            return;
    }
        

    pite = g_pProxyIfEntry;

    pHead = &pite->ListOfSameIfGroups; 

    Trace0(KSL, "---------------------------");
    Trace0(KSL, "Printing Proxy GroupTable");
    Trace0(KSL, "---------------------------");

    for (ple=pHead->Flink,dwCount=1;  ple!=pHead;  ple=ple->Flink,dwCount++) {

        ppge = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, LinkBySameIfGroups);

        Trace3(KSL, "%2d. %d.%d.%d.%d %10d", 
                    dwCount, PRINT_IPADDR(ppge->Group), ppge->RefCount);

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\pchigmp.h ===
// Precompiled header for IGMP

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define FD_SETSIZE      256
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <rtm.h>
#include <routprot.h>
#include <mprerror.h>
#include <rtutils.h>
#include <crt\stddef.h>
#include <TCHAR.H>
// defines SIO_RCVALL_IGMPCAST
#include <mstcpip.h>
#include <iprtrmib.h>
#include <mgm.h>
#include <igmprm.h>
#include <iphlpapi.h>
#include "macros.h"
#include "igmptimer.h"
#include "sync.h"
#include "table.h"
#include "table2.h"
#include "global.h"
#include "api.h"
#include "if.h"
#include "mgmigmp.h"
#include "mib.h"
#include "work.h"
#include "log.h"
#include "igmptrace.h"
#include "packet.h"
#include "work1.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\packet.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File: packet.c
//
// Abstract:
//      This module defines SendPacket, JoinMulticastGroup, LeaveMulticastGroup,
//      and xsum.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================

#include "pchigmp.h"
#pragma hdrstop

UCHAR
GetMaxRespCode(
    PIF_TABLE_ENTRY pite,
    DWORD val
    );


UCHAR GetQqic (
    DWORD val
    );
    
//------------------------------------------------------------------------------
//            _SendPacket
//
// Sends the packet. Called for ras server interfaces only for general queries.
// Locks: assumes IfRead lock
// for ver2 group specific query, send packet irrespective of pgie state.
//------------------------------------------------------------------------------
DWORD
SendPacket (
    PIF_TABLE_ENTRY  pite,
    PGI_ENTRY        pgie,        //null for gen query, and group_query_v2
    DWORD            PacketType,  //MSG_GEN_QUERY, 
                                  //MSG_GROUP_QUERY_V2,MSG_GROUP_QUERY_V3
                                  // MSG_SOURCES_QUERY
    DWORD            Group        //destination McastGrp
    )
{
    DWORD                   Error = NO_ERROR;
    SOCKADDR_IN             saSrcAddr, saDstnAddr;
    BYTE                    *SendBufPtr;
    DWORD                   SendBufLen, IpHdrLen=0, NumSources, Count;
    IGMP_HEADER UNALIGNED  *IgmpHeader;
    INT                     iLength;
    BOOL                    bHdrIncl = IS_RAS_SERVER_IF(pite->IfType);
    UCHAR                   RouterAlert[4] = {148, 4, 0, 0};

    //MSG_SOURCES_QUERY
    PIGMP_HEADER_V3_EXT     pSourcesQuery;
    LONGLONG                llCurTime;
    DWORD                   Version;


    Trace0(ENTER1, "Entering _SendPacket()");

    if (PacketType==MSG_GEN_QUERY)
        Version = GET_IF_VERSION(pite);
    else if (PacketType==MSG_GROUP_QUERY_V2)
        Version =2;
    else
        Version = pgie->Version;


    //
    // make sure that the pgie->version has not meanwhile changed
    //
    if ( ((PacketType==MSG_SOURCES_QUERY)||(PacketType==MSG_GROUP_QUERY_V3))
        && pgie->Version!=3
        ) {
        return NO_ERROR;    
    }
    if ( (PacketType==MSG_GROUP_QUERY_V2) && (pgie==NULL || pgie->Version!=2) )
        return NO_ERROR;
        
    //source query and list is empty
    if (PacketType==MSG_SOURCES_QUERY && IsListEmpty(&pgie->V3SourcesQueryList))
        return NO_ERROR;


    SendBufLen = sizeof(IGMP_HEADER)
                    + ((Version==3)?sizeof(IGMP_HEADER_V3_EXT):0);
    IpHdrLen = (bHdrIncl) 
                ? sizeof(IP_HEADER) + sizeof(RouterAlert) : 0;

    if (PacketType==MSG_SOURCES_QUERY) {
        SendBufPtr = (PBYTE) IGMP_ALLOC(SendBufLen + IpHdrLen
                                + sizeof(IPADDR)*pgie->V3SourcesQueryCount, 
                                0x4000,pite->IfIndex);
    }
    else {
        SendBufPtr = (PBYTE) IGMP_ALLOC(SendBufLen+IpHdrLen, 0x8000,pite->IfIndex);
    }
    if (!SendBufPtr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    
    //
    // set destination multicast addr (general queries sent to ALL_HOSTS_MCAST
    // and group specific queries sent to the GroupAddr
    //
    ZeroMemory((PVOID)&saDstnAddr, sizeof(saDstnAddr));
    saDstnAddr.sin_family = AF_INET;
    saDstnAddr.sin_port = 0;    
    saDstnAddr.sin_addr.s_addr = (PacketType==MSG_GEN_QUERY) ? 
                                    ALL_HOSTS_MCAST : Group;


    //
    // set igmp header
    //
    
    IgmpHeader = (IGMP_HEADER UNALIGNED*)
                (bHdrIncl
                ? &SendBufPtr[IpHdrLen]
                : SendBufPtr);


    IgmpHeader->Vertype = IGMP_QUERY;

    // have to divide GenQueryInterval by 100, as it should be in units of 100ms   
    if (PacketType==MSG_GEN_QUERY) {

        // for gen query, set response time if the IF-Ver2 else set it to 0
        IgmpHeader->ResponseTime = GetMaxRespCode(pite,
                                        pite->Config.GenQueryMaxResponseTime/100);
    }
    else {
        IgmpHeader->ResponseTime = GetMaxRespCode(pite,
                                        pite->Config.LastMemQueryInterval/100);
    }

    if (Version==3) {

        llCurTime = GetCurrentIgmpTime();
        pSourcesQuery = (PIGMP_HEADER_V3_EXT)
                                            ((PBYTE)IgmpHeader+sizeof(IGMP_HEADER));

        pSourcesQuery->Reserved =  0;
        pSourcesQuery->QRV = (UCHAR)pite->Config.RobustnessVariable;
        pSourcesQuery->QQIC = GetQqic(pite->Config.GenQueryInterval);

        pSourcesQuery->NumSources = 0;

        if (PacketType==MSG_GROUP_QUERY_V3) {
            pSourcesQuery->SFlag =
                (QueryRemainingTime(&pgie->GroupMembershipTimer, llCurTime)
                           <=pite->Config.LastMemQueryInterval)
                ? 0 : 1;
        }
        // first send gen query and 1st sources query packet without suppress bit
        else {
            pSourcesQuery->SFlag = 0;
        }
    }

    // twice in loop for sources query
    Count = (PacketType==MSG_SOURCES_QUERY)? 0 : 1;

    
    for (  ;  Count<2;  Count++) {

        IgmpHeader->Xsum = 0;
                    

        if (PacketType==MSG_SOURCES_QUERY) {

            PLIST_ENTRY pHead, ple;

            if (Count==1 && (PacketType==MSG_SOURCES_QUERY))
                pSourcesQuery->SFlag = 1;
                

            pHead = &pgie->V3SourcesQueryList;
            for (NumSources=0,ple=pHead->Flink;  ple!=pHead;  ) {

                PGI_SOURCE_ENTRY pSourceEntry = 
                        CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, V3SourcesQueryList);
                ple = ple->Flink;

                if ( (pSourcesQuery->SFlag
                        &&(QueryRemainingTime(&pSourceEntry->SourceExpTimer, llCurTime)
                           >GET_IF_CONFIG_FOR_SOURCE(pSourceEntry).LastMemQueryInterval))
                    || (!pSourcesQuery->SFlag
                        &&(QueryRemainingTime(&pSourceEntry->SourceExpTimer, llCurTime)
                           <=GET_IF_CONFIG_FOR_SOURCE(pSourceEntry).LastMemQueryInterval)) )
                {
                    if (NumSources==0) {
                        Trace4(SEND, 
                            "Sent Sources Query  on IfIndex(%0x) IpAddr(%d.%d.%d.%d) "
                            "for Group(%d.%d.%d.%d) SFlag:%d",
                            pite->IfIndex, PRINT_IPADDR(pite->IpAddr), 
                            PRINT_IPADDR(Group),pSourcesQuery->SFlag
                            );
                    }
                
                    pSourcesQuery->Sources[NumSources++] = pSourceEntry->IpAddr;

                    Trace1(SEND, "      Source:%d.%d.%d.%d", 
                            PRINT_IPADDR(pSourceEntry->IpAddr));
                            
                    if (--pSourceEntry->V3SourcesQueryLeft==0) {
                        RemoveEntryList(&pSourceEntry->V3SourcesQueryList);
                        pSourceEntry->bInV3SourcesQueryList = FALSE;
                        pgie->V3SourcesQueryCount--;
                    }
                }
            }

            if (NumSources==0)
                continue;
            
            pSourcesQuery->NumSources = htons((USHORT)NumSources);
            
            SendBufLen += sizeof(IPADDR)*NumSources;
        }

        IgmpHeader->Group = (PacketType==MSG_GEN_QUERY) ? 0 : Group;

        IgmpHeader->Xsum = ~xsum((PVOID)IgmpHeader, SendBufLen);

    

        //
        // send the packet 
        //
        if (!bHdrIncl) {

            Error = NO_ERROR;
            
            iLength = sendto(pite->SocketEntry.Socket, SendBufPtr, 
                            SendBufLen+IpHdrLen, 0,
                            (PSOCKADDR) &saDstnAddr, sizeof(SOCKADDR_IN)
                            );
                            
            //
            // error messages and statistics updates
            //
            if ( (iLength==SOCKET_ERROR) || ((DWORD)iLength<SendBufLen+IpHdrLen) ) {
                Error = WSAGetLastError();
                Trace4(ERR, 
                    "error %d sending query on McastAddr %d.%d.%d.%d on "
                    "interface %0x(%d.%d.%d.%d)",
                    Error, PRINT_IPADDR(saDstnAddr.sin_addr.s_addr), pite->IfIndex, 
                    PRINT_IPADDR(pite->IpAddr));
                IgmpAssertOnError(FALSE);
                Logwarn2(SENDTO_FAILED, "%I%I", pite->IpAddr, saDstnAddr.sin_addr, Error);
            }
        }

                            
        //
        // for RAS server interface, use HDRINCL option. Build up the ip header and 
        // send the packet to all RAS clients.
        //
        else {
            PIP_HEADER IpHdr;

            IpHdrLen = sizeof(IP_HEADER) + sizeof(RouterAlert);
            
            //
            // igmp follows the ip header containing the routerAlert option
            //

            IpHdr = (IP_HEADER *)((PBYTE)SendBufPtr);

            #define wordsof(x)  (((x)+3)/4) /* Number of 32-bit words */
            
            // Set IP version (4) and IP header length
            IpHdr->Hl = (UCHAR) (IPVERSION * 16 
                            + wordsof(sizeof(IP_HEADER) + sizeof(RouterAlert)));
        
            // No TOS bits are set
            IpHdr->Tos = 0;

            // Total IP length is set in host order
            IpHdr->Len = (USHORT)(IpHdrLen+sizeof(IGMP_HEADER));

            // Stack will fill in the ID
            IpHdr->Id = 0;

            // No offset
            IpHdr->Offset = 0;

            // Set the TTL to 1
            IpHdr->Ttl = 1;

            // Protocol is IGMP
            IpHdr->Protocol = IPPROTO_IGMP;

            // Checksum is set by stack
            IpHdr->Xsum = 0;

            // Set source and destination address
            IpHdr->Src.s_addr = pite->IpAddr;
            IpHdr->Dstn.s_addr = ALL_HOSTS_MCAST;


            // set the router alert option, but still set it
            memcpy( (void *)((UCHAR *)IpHdr + sizeof(IP_HEADER)),
                    (void *)RouterAlert, sizeof(RouterAlert));


            // send packet to all RAS clients, with the destination address in sendto
            // set to the unicast addr of the client
            {
                PLIST_ENTRY         pHead, ple;
                PRAS_TABLE_ENTRY    prte;
                pHead = &pite->pRasTable->ListByAddr;

                Error = NO_ERROR;
                
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                    // get address of ras client
                    prte = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, LinkByAddr);
                    saDstnAddr.sin_addr.s_addr = prte->NHAddr;


                    // send the packet to the client
                    iLength = sendto(pite->SocketEntry.Socket, SendBufPtr, 
                                        SendBufLen+IpHdrLen, 0,
                                        (PSOCKADDR) &saDstnAddr, sizeof(SOCKADDR_IN)
                                    ); 


                    // print error if sendto failed
                    if ((iLength==SOCKET_ERROR) || ((DWORD)iLength<SendBufLen+IpHdrLen) ) {
                        Error = WSAGetLastError();
                        Trace4(ERR, 
                            "error %d sending query to Ras client %d.%d.%d.%d on "
                            "interface %0x(%d.%d.%d.%d)",
                            Error, PRINT_IPADDR(saDstnAddr.sin_addr.s_addr), pite->IfIndex, 
                            PRINT_IPADDR(pite->IpAddr)
                            );
                        IgmpAssertOnError(FALSE);
                        Logwarn2(SENDTO_FAILED, "%I%I", pite->IpAddr,
                            saDstnAddr.sin_addr.s_addr, Error);
                    }
                    else {
                        Trace1(SEND, "sent general query to ras client: %d.%d.%d.%d",
                            PRINT_IPADDR(prte->NHAddr));
                    }
                                                
                }//for loop:sent packet to a RAS client
            }//sent packets to all ras clients
        }//created IPHeader and sent packets to all ras clients
            
    }; //for loop. send both packets

    if (PacketType==MSG_SOURCES_QUERY) {

        pgie->bV3SourcesQueryNow = FALSE;

        // set timer for next sources query
        if (pgie->V3SourcesQueryCount>0) {

            ACQUIRE_TIMER_LOCK("_SendPacket");

            #if DEBUG_TIMER_TIMERID
                SET_TIMER_ID(&pgie->V3SourcesQueryTimer,1001, pite->IfIndex,
                            Group, 0);
            #endif

            if (IS_TIMER_ACTIVE(pgie->V3SourcesQueryTimer)) {
                UpdateLocalTimer(&pgie->V3SourcesQueryTimer,
                    (pite->Config.LastMemQueryInterval/pite->Config.LastMemQueryCount),
                    DBG_Y);
            }
            else {
                InsertTimer(&pgie->V3SourcesQueryTimer,
                    (pite->Config.LastMemQueryInterval/pite->Config.LastMemQueryCount),
                    TRUE, DBG_Y);
            }
            RELEASE_TIMER_LOCK("_SendPacket");
        }
    }
    
    //
    // if successful, print trace and update statistics
    //
    if (Error==NO_ERROR) {

        if (PacketType==MSG_GEN_QUERY) {
        
            Trace2(SEND, "Sent GenQuery  on IfIndex(%0x) IpAddr(%d.%d.%d.%d)",
                    pite->IfIndex, PRINT_IPADDR(pite->IpAddr));
                    
            InterlockedIncrement(&pite->Info.GenQueriesSent);
        } 
        else if (PacketType==MSG_GROUP_QUERY_V2 || PacketType==MSG_GROUP_QUERY_V3) {
            Trace3(SEND, 
                "Sent Group Query  on IfIndex(%0x) IpAddr(%d.%d.%d.%d) "
                "for Group(%d.%d.%d.%d)",
                pite->IfIndex, PRINT_IPADDR(pite->IpAddr), PRINT_IPADDR(Group));
                    
            InterlockedIncrement(&pite->Info.GroupQueriesSent);
        } 
    }

    IGMP_FREE_NOT_NULL(SendBufPtr);
    
    Trace0(LEAVE1, "Leaving _SendPacket()");
    return Error;
    
} //end _SendPacket

DWORD
BlockSource (
    SOCKET Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    )
{
    struct ip_mreq   imOption;
    DWORD            Error = NO_ERROR;
    DWORD            dwRetval;
  
    
   struct ip_mreq_source imr;
   imr.imr_multiaddr.s_addr  = dwGroup;
   imr.imr_sourceaddr.s_addr = Source;
   imr.imr_interface.s_addr  = IpAddr;
   dwRetval = setsockopt(Sock, IPPROTO_IP, IP_BLOCK_SOURCE,
                    (PCHAR)&imr, sizeof(imr));

    if (dwRetval == SOCKET_ERROR) {

        Error = WSAGetLastError();

        Trace5(ERR, 
            "ERROR %d BLOCKING MULTICAST GROUP(%d.%d.%d.%d) "
            "Source:%d.%d.%d.%d ON INTERFACE (%d) %d.%d.%d.%d",
            Error, PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source),
            IfIndex, PRINT_IPADDR(IpAddr));
        IgmpAssertOnError(FALSE);
    }

    Trace2(MGM, "Blocking MCAST: (%d.%d.%d.%d) SOURCE (%d.%d.%d.%d)",
        PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source));
    return Error;
}


DWORD
UnBlockSource (
    SOCKET Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    )
{
    struct ip_mreq   imOption;
    DWORD            Error = NO_ERROR;
    DWORD            dwRetval;
   
    
   struct ip_mreq_source imr;
   imr.imr_multiaddr.s_addr  = dwGroup;
   imr.imr_sourceaddr.s_addr = Source;
   imr.imr_interface.s_addr  = IpAddr;
   dwRetval = setsockopt(Sock, IPPROTO_IP, IP_UNBLOCK_SOURCE,
                    (PCHAR)&imr, sizeof(imr));

    if (dwRetval == SOCKET_ERROR) {

        Error = WSAGetLastError();

        Trace5(ERR, 
            "ERROR %d UN-BLOCKING MULTICAST GROUP(%d.%d.%d.%d) "
            "Source:%d.%d.%d.%d ON INTERFACE (%d) %d.%d.%d.%d",
            Error, PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source),
            IfIndex, PRINT_IPADDR(IpAddr));
        IgmpAssertOnError(FALSE);
    }

    Trace2(MGM, "UnBlocking MCAST: (%d.%d.%d.%d) SOURCE (%d.%d.%d.%d)",
        PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source));
    return Error;
}

   
//------------------------------------------------------------------------------
//            _JoinMulticastGroup
//------------------------------------------------------------------------------
DWORD
JoinMulticastGroup (
    SOCKET    Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    )
{
    struct ip_mreq   imOption;
    DWORD            Error = NO_ERROR;
    DWORD            dwRetval;

    if (Source==0) {
        imOption.imr_multiaddr.s_addr = dwGroup;
        imOption.imr_interface.s_addr = IpAddr;

        dwRetval = setsockopt(Sock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                            (PBYTE)&imOption, sizeof(imOption));

        
    }
    else {
       struct ip_mreq_source imr;

       imr.imr_multiaddr.s_addr  = dwGroup;
       imr.imr_sourceaddr.s_addr = Source;
       imr.imr_interface.s_addr  = IpAddr;
       dwRetval = setsockopt(Sock, IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP,
                        (PCHAR)&imr, sizeof(imr));
    }

    if (dwRetval == SOCKET_ERROR) {

        Error = WSAGetLastError();

        Trace5(ERR, 
            "ERROR %d JOINING MULTICAST GROUP(%d.%d.%d.%d) "
            "Source:%d.%d.%d.%d ON INTERFACE (%d) %d.%d.%d.%d",
            Error, PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source),
            IfIndex, PRINT_IPADDR(IpAddr));
        IgmpAssertOnError(FALSE);

        Logerr2(JOIN_GROUP_FAILED, "%I%I", dwGroup, IpAddr, Error);
    }

    Trace2(MGM, "Joining MCAST: (%d.%d.%d.%d) SOURCE (%d.%d.%d.%d)",
        PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source));
    return Error;
}



//------------------------------------------------------------------------------
//            _LeaveMulticastGroup
//------------------------------------------------------------------------------
DWORD
LeaveMulticastGroup (
    SOCKET  Sock,
    DWORD   dwGroup,
    DWORD   IfIndex,
    IPADDR  IpAddr,
    IPADDR  Source
    )
{
    struct ip_mreq     imOption;
    DWORD            Error = NO_ERROR;
    DWORD            dwRetval;

    if (Source==0) {
        imOption.imr_multiaddr.s_addr = dwGroup;
        imOption.imr_interface.s_addr = IpAddr;

        dwRetval = setsockopt(Sock, IPPROTO_IP, IP_DROP_MEMBERSHIP,
                            (PBYTE)&imOption, sizeof(imOption));
    }
    else {
       struct ip_mreq_source imr;

       imr.imr_multiaddr.s_addr  = dwGroup;
       imr.imr_sourceaddr.s_addr = Source;
       imr.imr_interface.s_addr  = IpAddr;
       dwRetval = setsockopt(Sock, IPPROTO_IP, IP_DROP_SOURCE_MEMBERSHIP,
                        (PCHAR)&imr, sizeof(imr));
    }

    if (dwRetval == SOCKET_ERROR) {

        Error = WSAGetLastError();

        Trace5(ERR, 
            "error %d leaving multicast group(%d.%d.%d.%d) "
            "Source:%d.%d.%d.%d on interface (%d) %d.%d.%d.%d",
            Error, PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source),
            IfIndex, PRINT_IPADDR(IpAddr));
        IgmpAssertOnError(FALSE);
    }
    
    Trace2(MGM, "Leaving MCAST: (%d.%d.%d.%d) SOURCE (%d.%d.%d.%d)",
        PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source));

    return Error;
}


//------------------------------------------------------------------------------
//          _McastSetTtl
// set the ttl value for multicast data. the default ttl for multicast is 1.
//------------------------------------------------------------------------------

DWORD
McastSetTtl(
    SOCKET sock,
    UCHAR ttl
    )
{
    INT         dwTtl = ttl;
    DWORD       Error=NO_ERROR;

    Error = setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL,
                                        (char *)&dwTtl, sizeof(dwTtl));
    if (Error != 0) {
        Error = WSAGetLastError();
        Trace1(ERR, "error:%d: unable to set ttl value", Error);
        IgmpAssertOnError(FALSE);
        return Error;
    }

    return Error;
}


UCHAR
GetMaxRespCode(
    PIF_TABLE_ENTRY pite,
    DWORD val
    )
{
    if (IS_IF_VER1(pite))
        return 0;

    if (IS_IF_VER2(pite))
        return val>255 ? 0 : (UCHAR)val;

    //version 3
    if (val < 128)
        return (UCHAR)val;
        
    {
        DWORD n,mant, exp;

        n = val;
        exp = mant = 0;
        while (n) {
            exp++;
            n = n>>1;
        }
        exp=exp-2-3-3;
        mant = 15;

        if ( ((mant+16)<<(exp+3)) < val)
            exp++;

        mant = (val >> (exp+3)) - 15;

        IgmpAssert(mant<16 && exp <8); //deldel
        Trace4(KSL, "\n=======exp: LMQI:%d:%d exp:%d  mant:%d\n",
                val, (mant+16)<<(exp+3), exp, mant); //deldel
        return (UCHAR)(0x80 + (exp<<4) + mant);
    }
    

}


UCHAR
GetQqic (
    DWORD val
    )
{
    val = val/1000;
    if ((val) > 31744)
        return 0;

    if (val<128)
        return (UCHAR)val;

    {
        DWORD n,mant, exp;

        n = val;
        exp = mant = 0;
        while (n) {
            exp++;
            n = n>>1;
        }
        exp=exp-2-3-3;
        mant = 15;

        if ( ((mant+16)<<(exp+3)) < val)
            exp++;

        mant = (val >> (exp+3)) - 15;

        IgmpAssert(mant<16 && exp <8); //deldel
        Trace4(KSL, "\n=======exp: QQic:%d:%d exp:%d  mant:%d\n",
                val, (mant+16)<<(exp+3), exp, mant); //deldel
        return (UCHAR)(0x80 + (exp<<4) + mant);
    }    
}


//------------------------------------------------------------------------------
// xsum: copied from ipxmit.c
//------------------------------------------------------------------------------

USHORT
xsum(PVOID Buffer, INT Size)
{
    USHORT  UNALIGNED *Buffer1 = (USHORT UNALIGNED *)Buffer; // Buffer expressed as shorts.
    ULONG   csum = 0;

    while (Size > 1) {
        csum += *Buffer1++;
        Size -= sizeof(USHORT);
    }

    if (Size)
        csum += *(UCHAR *)Buffer1;              // For odd buffers, add in last byte.

    csum = (csum >> 16) + (csum & 0xffff);
    csum += (csum >> 16);
    return (USHORT)csum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\mib.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// Module Name: Mib.c
//
// Abstract:
//      This module implements the mib API's:
//          MibGet, MibGetFirst and MibGetNext. 
//      It also implements the Mib Display tracing, which displays the mib
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================
 

#include "pchigmp.h"
#pragma hdrstop
#pragma prefast(disable:69, "dont need to optimize. used in debug tracing only")

DWORD g_IgmpMibDisplay = 1;


//------------------------------------------------------------------------------
// Functions to display the MibTable on the TraceWindow periodically
//------------------------------------------------------------------------------


#ifdef MIB_DEBUG



#define ClearScreen(h) {                                                    \
    DWORD _dwin,_dwout;                                                     \
    COORD _c = {0, 0};                                                      \
    CONSOLE_SCREEN_BUFFER_INFO _csbi;                                       \
    GetConsoleScreenBufferInfo(h,&_csbi);                                   \
    _dwin = _csbi.dwSize.X * _csbi.dwSize.Y;                                \
    FillConsoleOutputCharacter(h,' ',_dwin,_c,&_dwout);                     \
}

#define WRITELINE(h,c,fmt,arg) {                                            \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg);                                                 \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITE_NEWLINE(h,c)      \
    WRITELINE(                  \
        hConsole, c, "%s",      \
        ""                      \
        );    

#define WRITELINE2(h,c,fmt,arg1, arg2) {                                    \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2);                                          \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE3(h,c,fmt,arg1, arg2, arg3) {                              \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, (arg2), (arg3));                                    \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE4(h,c,fmt,arg1, arg2, arg3, arg4) {                        \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4);                              \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE5(h,c,fmt,arg1, arg2, arg3, arg4, arg5) {                  \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5);                        \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE6(h,c,fmt,arg1, arg2, arg3, arg4, arg5, arg6) {            \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6);                  \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE7(h,c,fmt,arg1, arg2,arg3,arg4,arg5,arg6,arg7)  {\
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6, arg7);\
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE8(h,c,fmt,arg1, arg2,arg3,arg4,arg5,arg6,arg7,arg8)  {\
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE9(h,c,fmt,arg1, arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)  {\
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE10(h,c,fmt,arg1, arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)  {\
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,arg10);\
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

DWORD
WT_MibDisplay (
    PVOID   pContext
    )
{
    //enter/leaveIgmpApi not required as the timer queue is persistent
    QueueIgmpWorker(WF_MibDisplay, NULL);

    return 0;
}


//------------------------------------------------------------------------------
//          _WF_MibDisplay
//------------------------------------------------------------------------------    

VOID
WF_MibDisplay(
    PVOID pContext
    ) 
{
    COORD                       c;
    HANDLE                      hConsole;
    DWORD                       Error=NO_ERROR, dwTraceId, dwCurTableId=0, dwEnumCount;
    DWORD                       dwExactSize, dwInSize, dwBufferSize, dwOutSize;
    IGMP_MIB_GET_INPUT_DATA     Query;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse;
    LARGE_INTEGER               llCurrentTime;
    BOOL                        bChanged, bEndOfTables;
    
    if (!EnterIgmpWorker()) { return; }

    if (g_IgmpMibDisplay==0) {

        ACQUIRE_TIMER_LOCK("_WF_MibDisplay");

        g_MibTimer.Status = TIMER_STATUS_CREATED;
        
        #if DEBUG_TIMER_TIMERID
            SET_TIMER_ID(&g_MibTimer, 920, 0, 0, 0);
        #endif

        if (g_Info.CurrentGroupMemberships<=20)
            InsertTimer(&g_MibTimer, 30000, TRUE, DBG_Y);//kslksl
        else if (g_Info.CurrentGroupMemberships<=320)
            InsertTimer(&g_MibTimer, 120000, TRUE, DBG_N);//kslksl
        else
            InsertTimer(&g_MibTimer, 1200000, TRUE, DBG_N);
        RELEASE_TIMER_LOCK("_WF_MibDisplay");

        LeaveIgmpWorker();
        return;
    }
    else if (g_IgmpMibDisplay==0xff) {
        LeaveIgmpWorker();
        return;
    }
    
    TraceGetConsole(g_MibTraceId, &hConsole);


    if (hConsole == NULL) {
        LeaveIgmpWorker();
        return;
    }



    ClearScreen(hConsole);

    Sleep(200);
    c.X = c.Y = 0;


    dwInSize = sizeof(Query);

    Query.GroupAddr = 0;
    Query.TypeId = IGMP_GLOBAL_CONFIG_ID;

    Query.Flags = IGMP_ENUM_ALL_INTERFACES_GROUPS | IGMP_ENUM_ALL_TABLES
                    | IGMP_ENUM_SUPPORT_FORMAT_IGMPV3;
                    
    Query.Count = 20;
    pResponse = NULL;


    //
    // get size of the first entry in the first table
    //

    Query.Count = 20;

    dwOutSize = dwBufferSize = 0;
    Error = MibGetFirst(dwInSize, &Query, &dwOutSize, pResponse);


    if (Error == ERROR_INSUFFICIENT_BUFFER) {

        //
        // allocate a buffer, and set its size
        //
        dwOutSize = dwBufferSize = (dwOutSize<MIB_DEFAULT_BUFFER_SIZE) 
                                    ? MIB_DEFAULT_BUFFER_SIZE : dwOutSize;
        pResponse = IGMP_ALLOC(dwOutSize, 0x801,0);

        PROCESS_ALLOC_FAILURE2(pResponse, 
            "error %d allocating %d bytes. stopping mib display",
            Error, dwOutSize, return);
                

        //
        // perform the query again
        //

        Error = MibGetFirst(dwInSize, &Query, &dwOutSize, pResponse);

    }



    //
    // now that we have the first element in the first table,
    // we can enumerate the elements in the remaining tables using GetNext
    //

    for (dwEnumCount=1;  dwEnumCount<=3;  dwEnumCount++) {
    
        while (Error==NO_ERROR) {

            //bEndOfTables = FALSE;
            //while(bEndOfTables==FALSE) {

            if (dwCurTableId!=pResponse->TypeId) {

                //
                // move to the next line on the console
                //

                ++c.Y;

                WRITELINE(
                    hConsole, c, "%s",
                    "---------------------------------------------------------------"
                    );
                dwCurTableId = pResponse->TypeId;
                bChanged = TRUE;
            }
            else
                bChanged = FALSE;

            
            //
            // print the current element and set up the query
            // for the next element (the display functions  change Query
            // so that it can be used to query the next element)
            //

            switch(pResponse->TypeId) {
                
                case IGMP_GLOBAL_CONFIG_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Global Configuration"
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "--------------------"
                                );
                    }
                    
                    PrintGlobalConfig(hConsole,&c, &Query, pResponse);
                    break;
                }
                
                case IGMP_GLOBAL_STATS_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Global Statistics Information"
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "-----------------------------"
                                );
                    }
                    PrintGlobalStats(hConsole, &c, &Query, pResponse);
                    break;
                }
                
                case IGMP_IF_CONFIG_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Interface Config Table"
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "----------------------"
                                );
                    }
                    
                    PrintIfConfig(hConsole, &c, &Query, pResponse);
                    break;
                }

                case IGMP_IF_STATS_ID:
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Interface Statistics Table"
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "--------------------------"
                                );
                    }
                    PrintIfStats(hConsole, &c, &Query, pResponse);
                    break;

                case IGMP_IF_BINDING_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Interface Binding Table"
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "-----------------------"
                                );
                    }
                    PrintIfBinding(hConsole, &c, &Query, pResponse);
                    break;
                }
                
                case IGMP_IF_GROUPS_LIST_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Interface-MulticastGroups Table"
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "--------------------------------"
                                );
                    }
                    
                    PrintIfGroupsList(hConsole, &c, &Query, pResponse);

                    break;
                }
                
                case IGMP_GROUP_IFS_LIST_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "MulticastGroups-Interface Table"
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "-------------------------------"
                                );
                        WRITELINE(
                            hConsole, c, "%s",
                            "(Ver) GroupAddr            (Up/Exp)Time Flg <IfIndex:IpAddr>      LastReporter  "
                            " V1Host V2Host"
                        );

                        WRITE_NEWLINE(hConsole, c);

                    }

                    PrintGroupIfsList(hConsole, &c, &Query, pResponse);
                    
                    break;
                }

                case IGMP_PROXY_IF_INDEX_ID:
                {
                    WRITELINE(
                            hConsole, c, "%s",
                            "Proxy Interface Index"
                            );
                    WRITELINE(
                            hConsole, c, "%s",
                            "---------------------"
                            );
                    PrintProxyIfIndex(hConsole, &c, &Query, pResponse);

                    break;
                }
                    
                default:
                    bEndOfTables = TRUE;
                    break;
            }


            //
            // query the next MIB element
            //

            Query.Count = 20;

            //kslksl
            IGMP_FREE(pResponse);
            pResponse = IGMP_ALLOC(dwBufferSize, 0xb000,0);


            dwOutSize = dwBufferSize;
            Error = MibGetNext(dwInSize, &Query, &dwOutSize, pResponse);


            if (Error == ERROR_INSUFFICIENT_BUFFER) {

                //
                // allocate a new buffer, and set its size
                //
                dwOutSize = dwBufferSize = (dwOutSize<MIB_DEFAULT_BUFFER_SIZE) 
                                            ? MIB_DEFAULT_BUFFER_SIZE : dwOutSize;

                IGMP_FREE(pResponse);
                pResponse = IGMP_ALLOC(dwOutSize, 0x2000,0);
                PROCESS_ALLOC_FAILURE2(pResponse, 
                    "error %d allocating %d bytes. stopping mib display",
                    Error, dwOutSize, return);


        
                // perform the query again

                Error = MibGetNext(dwInSize, &Query, &dwOutSize, pResponse);

            }
            
        } // while no_error: print all tables

        Query.Flags = IGMP_ENUM_FOR_RAS_CLIENTS;
        Query.IfIndex = g_ProxyIfIndex;
        Query.TypeId = dwEnumCount==1? IGMP_IF_STATS_ID : IGMP_IF_GROUPS_LIST_ID;
        bChanged = TRUE;
    }


    //
    // if memory was allocated, free it now    
    //
    if (pResponse != NULL) { IGMP_FREE(pResponse); }


    //
    // schedule next MIB display
    //

    ACQUIRE_TIMER_LOCK("_WF_MibDisplay");
    
    g_MibTimer.Status = TIMER_STATUS_CREATED;
    
    #if DEBUG_TIMER_TIMERID
        SET_TIMER_ID(&g_MibTimer, 920, 0, 0, 0);
    #endif

    if (g_Info.CurrentGroupMemberships<=20)
        InsertTimer(&g_MibTimer, 20000, TRUE, DBG_N);
    else if (g_Info.CurrentGroupMemberships<=320)
        InsertTimer(&g_MibTimer, 120000, TRUE, DBG_N);
    else
        InsertTimer(&g_MibTimer, 1200000, TRUE, DBG_N);

    RELEASE_TIMER_LOCK("_WF_MibDisplay");

    LeaveIgmpWorker();
    
} //end _WF_MibDisplay





//------------------------------------------------------------------------------
//          _PrintGlobalStats
//------------------------------------------------------------------------------
VOID
PrintGlobalStats(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA       pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA      pResponse
    ) 
{
    PIGMP_GLOBAL_STATS pgs;


    pgs = (PIGMP_GLOBAL_STATS)pResponse->Buffer;

    WRITELINE(
        hConsole, *pc, "Current Group Memberships:            %d",
        pgs->CurrentGroupMemberships
        );
    WRITELINE(
        hConsole, *pc, "Group Memberships Added:              %d",
        pgs->GroupMembershipsAdded
        );

    pQuery->TypeId = IGMP_GLOBAL_STATS_ID;
}


//------------------------------------------------------------------------------
//          _PrintProxyIfIndex
//------------------------------------------------------------------------------
VOID
PrintProxyIfIndex(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA       pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA      pResponse
    ) 
{
    DWORD   *pProxyIfIndex = (PDWORD)pResponse->Buffer;

    WRITELINE(
        hConsole, *pc, "Proxy Interface Index:                0x%0x",
        *pProxyIfIndex
        );

    pQuery->TypeId = IGMP_PROXY_IF_INDEX_ID;
}


//------------------------------------------------------------------------------
//          _PrintGlobalConfig
//------------------------------------------------------------------------------
VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA pResponse
    ) 
{

    PIGMP_MIB_GLOBAL_CONFIG     pConfig;
    LARGE_INTEGER               llTime;
    static  DWORD               dwCount;
    
    llTime.QuadPart = GetCurrentIgmpTime();
    
    pConfig = (PIGMP_MIB_GLOBAL_CONFIG)pResponse->Buffer;

    WRITELINE2(
        hConsole, *pc, "%d. Seconds since start: %lu",
        ++dwCount, 
        (ULONG)((llTime.QuadPart - g_Info.TimeWhenRtrStarted.QuadPart)/1000)
        );

    WRITELINE(
        hConsole, *pc, "Version:                              %x",
        pConfig->Version
        );

    WRITELINE(
        hConsole, *pc, "Logging Level:                        %d",
        pConfig->LoggingLevel
        );
    WRITELINE(
        hConsole, *pc, "Ras Client Stats kept:                %d",
        pConfig->RasClientStats
        );
    

    pQuery->TypeId = IGMP_GLOBAL_CONFIG_ID;
}


//------------------------------------------------------------------------------
//          _PrintIfConfig
//------------------------------------------------------------------------------
VOID
PrintIfConfig(
    HANDLE                     hConsole,
    PCOORD                     pc,
    PIGMP_MIB_GET_INPUT_DATA   pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA  pResponse
    ) 
{
    PIGMP_MIB_IF_CONFIG     pConfig;
    CHAR                    szIfType[50], szProtoType[50];
    DWORD                   LastIfIndex=0, Count;
    

    pConfig = (PIGMP_MIB_IF_CONFIG)pResponse->Buffer;


    for (Count=0;  Count<pResponse->Count;  Count++) {


        WRITE_NEWLINE(hConsole, *pc);

            
        LastIfIndex = pConfig->IfIndex;


            
        switch (pConfig->IfType) {
        
            case IGMP_IF_NOT_RAS :
                lstrcpy(szIfType, "Permanent"); 
                break;
                
            case IGMP_IF_RAS_ROUTER :
                lstrcpy(szIfType, "Demand-dial (Ras router)"); 
                break;
                
            case IGMP_IF_RAS_SERVER :
                lstrcpy(szIfType, 
                        "LocalWorkstation-dial (Ras server)"); 
                break;

            //ras client config will never be returned    

            // is proxy type.
            default :
                if (IS_IFTYPE_PROXY(pConfig->IfType)) {
                    if (pConfig->IfType&IGMP_IF_NOT_RAS)
                        lstrcpy(szIfType, "Permanent (Igmp Proxy)");
                    else
                        lstrcpy(szIfType, "Demand-dial (Igmp Proxy)");
                }
                else
                    lstrcpy(szIfType, "Unknown type");
                break;
        }


        WRITELINE(
            hConsole, *pc, "Interface Index:                      0x%0x",
            pConfig->IfIndex
            );

        WRITELINE(
            hConsole, *pc, "Interface Ip Address:                 %s",
            INET_NTOA(pConfig->IpAddr)
            );

        WRITELINE(
            hConsole, *pc, "Interface Type:                       %s",
            szIfType
            );
        
        switch (pConfig->IgmpProtocolType) {
        
            case IGMP_ROUTER_V1 :
                lstrcpy(szProtoType, "Igmp Router ver-1"); break;
            case IGMP_ROUTER_V2 :
                lstrcpy(szProtoType, "Igmp Router ver-2"); break;
            case IGMP_ROUTER_V3 :
                lstrcpy(szProtoType, "Igmp Router ver-3"); break;
            case IGMP_PROXY :
            case IGMP_PROXY_V3 :
                lstrcpy(szProtoType, "Igmp Proxy"); break;
            default:
            {
                BYTE    str[40];
                sprintf(str, "Illegal protocol Id: %d", pConfig->IgmpProtocolType);
                lstrcpy(szProtoType, str); 
                break;
            }
        }
        
        WRITELINE(
            hConsole, *pc, "Protocol:                             %s",
            szProtoType
            );


        //
        // No config info for proxy
        //
        if (IS_CONFIG_IGMPPROXY(pConfig)) {

            ;
        }


        //
        // print igmp-router config info
        //
        else {


            WRITELINE(
                hConsole, *pc, "Robustness variable:                  %d",
                pConfig->RobustnessVariable
                );
        
            WRITELINE(
                hConsole, *pc, "Startup query interval:               %d",
                pConfig->StartupQueryInterval
                );

            WRITELINE(
                hConsole, *pc, "Startup query count:                  %d",
                pConfig->StartupQueryCount
                );

            WRITELINE(
                hConsole, *pc, "General query interval:               %d",
                pConfig->GenQueryInterval
                );

            WRITELINE(
                hConsole, *pc, "General query max response time:      %d",
                pConfig->GenQueryMaxResponseTime
                );

            WRITELINE(
                hConsole, *pc, "Last member query interval:           %d (ms)",
                pConfig->LastMemQueryInterval
                );

            WRITELINE(
                hConsole, *pc, "Last member query count:              %d",
                pConfig->LastMemQueryCount
                );

            WRITELINE(
                hConsole, *pc, "Other querier present interval:       %d",
                pConfig->OtherQuerierPresentInterval
                );
        
            WRITELINE(
                hConsole, *pc, "Group membership timeout:             %d",
                pConfig->GroupMembershipTimeout
                );

        } //end if not proxy interface

        //
        // print static groups
        //
        if (pConfig->NumStaticGroups>0) {

            PIGMP_STATIC_GROUP  pStaticGroup;
            DWORD               i;
            PCHAR   StaticModes[3] = {"", "IGMP_HOST_JOIN", "IGMPRTR_JOIN_MGM_ONLY"};
                                    
            WRITELINE(
                hConsole, *pc, "NumStaticGroups:                      %d",
                pConfig->NumStaticGroups
                );
            pStaticGroup = GET_FIRST_IGMP_STATIC_GROUP(pConfig);
            for (i=0;  i<pConfig->NumStaticGroups;  i++,pStaticGroup++) {
                WRITELINE3(
                    hConsole, *pc, "    %d. %-15s  %s",
                    i+1, INET_NTOA(pStaticGroup->GroupAddr), 
                    StaticModes[pStaticGroup->Mode]
                );
            }
        }
                

        pConfig = (PIGMP_MIB_IF_CONFIG) 
                    ((PBYTE)(pConfig) + IGMP_MIB_IF_CONFIG_SIZE(pConfig));

    } //end for loop; print each global config

    
    pQuery->TypeId = IGMP_IF_CONFIG_ID;
    pQuery->IfIndex = LastIfIndex;

    return;
} //end _PrintIfConfig





//------------------------------------------------------------------------------
//          _PrintIfStats
//------------------------------------------------------------------------------
VOID
PrintIfStats(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    ) 
{
    PIGMP_MIB_IF_STATS          pStats;
    CHAR                        szIfType[50];
    CHAR                        szProtoType[50], szState[100];
    DWORD                       LastIfIndex=0, Count;


    pStats = (PIGMP_MIB_IF_STATS)pResponse->Buffer;


    for (Count=0;  Count<pResponse->Count;  Count++,pStats++) {


        WRITE_NEWLINE(hConsole, *pc);

            
        LastIfIndex = pStats->IfIndex;

            
        switch (pStats->IfType) {
        
            case IGMP_IF_NOT_RAS :
                lstrcpy(szIfType, "Permanent"); 
                break;
                
            case IGMP_IF_RAS_ROUTER :
                lstrcpy(szIfType, "Demand-dial (Ras router)"); 
                break;
                
            case IGMP_IF_RAS_SERVER :
                lstrcpy(szIfType, 
                        "LocalWorkstation-dial (Ras server)"); 
                break;

            case IGMP_IF_RAS_CLIENT :
                lstrcpy(szIfType, 
                        "RemoteWorkstation-dial (Ras client)");
                break;

            // is proxy type.
            default :
                if (IS_IFTYPE_PROXY(pStats->IfType)) {
                    if (pStats->IfType&IGMP_IF_NOT_RAS)
                        lstrcpy(szIfType, "Permanent (Igmp Proxy)");
                    else
                        lstrcpy(szIfType, "Demand-dial (Igmp Proxy)");
                }
                else
                    lstrcpy(szIfType, "Unknown type");
                break;
        }


        WRITELINE(
            hConsole, *pc, "Interface Index:                      0x%0x",
            pStats->IfIndex
            );
            

        WRITELINE(
            hConsole, *pc, "Interface Type:                       %s",
            szIfType
            );

            
        WRITELINE(
            hConsole, *pc, "Interface Ip Address:                 %s",
            INET_NTOA(pStats->IpAddr)
            );



        //
        // print the protocol type
        //
       
        switch (pStats->IgmpProtocolType) {
        
            case IGMP_ROUTER_V1 :
                lstrcpy(szProtoType, "Igmp Router ver-1"); break;
            case IGMP_ROUTER_V2 :
                lstrcpy(szProtoType, "Igmp Router ver-2"); break;
            case IGMP_ROUTER_V3 :
                lstrcpy(szProtoType, "Igmp Router ver-3"); break;
            case IGMP_PROXY :
            case IGMP_PROXY_V3 :
                lstrcpy(szProtoType, "Igmp Proxy"); break;
        
        }
        
        WRITELINE(
            hConsole, *pc, "Protocol:                             %s",
            szProtoType
            );




        //
        // print the state
        //
        {
            PCHAR szBool[2] = {"N", "Y"};
            szState[0] = '\0';
            if (!(pStats->State&IGMP_STATE_BOUND))
                lstrcat(szState, "<NotBound> ");
                
            lstrcat(szState, "<Enabled-By:");
            lstrcat(szState, " Rtrmgr-");
            lstrcat(szState, szBool[(pStats->State&IGMP_STATE_ENABLED_BY_RTRMGR)>0]);
            lstrcat(szState, " Config-");
            lstrcat(szState, szBool[(pStats->State&IGMP_STATE_ENABLED_IN_CONFIG)>0]);
            lstrcat(szState, " MGM-");
            lstrcat(szState, szBool[(pStats->State&IGMP_STATE_ENABLED_BY_MGM)>0]);
            lstrcat(szState, "> ");
            
            if (!IS_IFTYPE_PROXY(pStats->IfType)) {
                if ( (pStats->State&IGMP_STATE_MGM_JOINS_ENABLED)
                        ==IGMP_STATE_MGM_JOINS_ENABLED )
                {
                    lstrcat(szState, "JoinsFwdToMGM-Y");
                }
                else
                    lstrcat(szState, "JoinsFwdToMGM-N");
            }
        }
        
        WRITELINE(
            hConsole, *pc, "If-Status:                            %s",
            szState
            );


        //
        // if state is not both bound & enabled, I am done
        //
        if ((pStats->State&IGMP_STATE_ACTIVATED)!=IGMP_STATE_ACTIVATED)
            continue;

            
        WRITELINE(
                hConsole, *pc, "Uptime:                               %d",
                pStats->Uptime
                );

                
        ///////////////////
        // Stats for proxy
        ///////////////////
        
        if (IS_IFTYPE_PROXY(pStats->IfType)) {
            
            WRITELINE(
                hConsole, *pc, "Num current group members:            %d",
                pStats->CurrentGroupMemberships
                );

            WRITELINE(
                hConsole, *pc, "Num group memberships added:          %d",
                pStats->GroupMembershipsAdded
                );

        }


        ////////////////////////////////////////////////////////////////
        // print igmp-router/ras-server/ras-router/ras client Stats info
        ////////////////////////////////////////////////////////////////
        
        else  {

            //
            // if Not ras client, print these
            //
            
            if (pStats->IfType!=IGMP_IF_RAS_CLIENT) {
            
                //querier or not querier
                
                if (pStats->QuerierState&QUERIER) 
                {

                    WRITELINE(
                        hConsole, *pc, "State:                                %s",
                        "Querier"
                        );


                    // querier ip addr
                    WRITELINE(
                        hConsole, *pc, "Querier Ip Addr:                      %s",
                        INET_NTOA(pStats->QuerierIpAddr)
                        );
                }
                
                else {

                    WRITELINE(
                        hConsole, *pc, "State:                                %s",
                        "Not Querier"
                        );

                    // querier ip addr
                    WRITELINE(
                        hConsole, *pc, "Querier Ip Addr:                      %s",
                        INET_NTOA(pStats->QuerierIpAddr)
                        );

                        
                    // querier present time left
                    
                    WRITELINE(
                        hConsole, *pc, "QuerierPresentTimeLeft:               %d",
                        pStats->QuerierPresentTimeLeft
                        );
                }

                WRITELINE(
                    hConsole, *pc, "LastQuerierChangeTime:                %d",
                    pStats->LastQuerierChangeTime
                    );
    
                if (pStats->V1QuerierPresentTimeLeft) {
                
                    WRITELINE(
                        hConsole, *pc, "V1QuerierPresentTime:                 %d",
                        pStats->V1QuerierPresentTimeLeft
                        );
                }
                
            } //end not ras-client
            


            WRITELINE(
                hConsole, *pc, "Num current group members:            %d",
                pStats->CurrentGroupMemberships
                );

            WRITELINE(
                hConsole, *pc, "Num group memberships added:          %d",
                pStats->GroupMembershipsAdded
                );

            WRITELINE(
                hConsole, *pc, "Num of Igmp packets received:         %d",
                pStats->TotalIgmpPacketsReceived
                );
        
            WRITELINE(
                hConsole, *pc, "Num Igmp-router proto packets recv:   %d",
                pStats->TotalIgmpPacketsForRouter
                );

            WRITELINE(
                hConsole, *pc, "Num general queries received:         %d",
                pStats->GeneralQueriesReceived
                );

            WRITELINE(
                hConsole, *pc, "Num wrong version queries:            %d",
                pStats->WrongVersionQueries
                );

            WRITELINE(
                hConsole, *pc, "Num Joins received:                   %d",
                pStats->JoinsReceived
                );

            WRITELINE(
                hConsole, *pc, "Num leaves received:                  %d",
                pStats->LeavesReceived
                );
        
            WRITELINE(
                hConsole, *pc, "Num wrong checksum packets:           %d",
                pStats->WrongChecksumPackets
                );

            WRITELINE(
                hConsole, *pc, "Num short packets received:           %d",
                pStats->ShortPacketsReceived
                );

            WRITELINE(
                hConsole, *pc, "Num long packets received:            %d",
                pStats->LongPacketsReceived
                );
        
            WRITELINE(
                hConsole, *pc, "Num packets without RtrAlert:         %d",
                pStats->PacketsWithoutRtrAlert
                );
        
                
        } //end print igmp-router/ras-router/ras-server Stats info



    } //end for loop; print each stats info

    
    pQuery->TypeId = IGMP_IF_STATS_ID;
    pQuery->IfIndex = LastIfIndex;
    
    return;
    
}//end _PrintIfStats


//------------------------------------------------------------------------------
//          _PrintIfBinding
//------------------------------------------------------------------------------
VOID
PrintIfBinding(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    ) 
{

    DWORD                   NumIfs, NumAddrs, NumClients, LastIfIndex;
    CHAR                    szAddr[64];
    PIGMP_MIB_IF_BINDING    pib;
    PIGMP_MIB_IP_ADDRESS    paddr;
    PDWORD                  pRasClientAddr;
    PBYTE                   ptr; //pointer to next binding


    ptr = pResponse->Buffer;
    
    if (pResponse->Count<=0) //prefast
        return;

    for (NumIfs=0;  NumIfs<pResponse->Count;  NumIfs++) {
    
        pib = (PIGMP_MIB_IF_BINDING)ptr;

        WRITE_NEWLINE(hConsole, *pc);
        
        WRITELINE(
            hConsole, *pc, "Interface Index:                      0x%0x",
            pib->IfIndex
        );


        WRITELINE(
            hConsole, *pc, "Address Count:                        %d",
            pib->AddrCount
        );



        //
        // Not ras client
        //
        if (pib->IfType!=IGMP_IF_RAS_CLIENT) {
        
            paddr = IGMP_BINDING_FIRST_ADDR(pib);
            
            for (NumAddrs=0;  NumAddrs<pib->AddrCount;  NumAddrs++,paddr++) {
                INET_COPY(szAddr, paddr->IpAddr);
                
                lstrcat(szAddr, " - ");
                INET_CAT(szAddr, paddr->SubnetMask);
                WRITELINE(
                    hConsole, *pc, "Address Entry:                        %s",
                    szAddr
                    );

                INET_COPY(szAddr, paddr->IpAddr);
                lstrcat(szAddr, " - ");
                INET_CAT(szAddr, paddr->SubnetMask);
                WRITELINE(
                    hConsole, *pc, "Address Entry:                        %s",
                    szAddr
                    );
            }


            //Set pointer to the next Interface binding
            ptr = (PBYTE) (paddr);

        } //end if not ras client



        //
        // Ras client. Print address of ras server, followed by the clients
        //
        else {

            // print ras server address
        
            paddr = IGMP_BINDING_FIRST_ADDR(pib);
            INET_COPY(szAddr, paddr->IpAddr);
            lstrcat(szAddr, " - ");
            INET_CAT(szAddr, paddr->SubnetMask);
            WRITELINE(
                hConsole, *pc, "Ras server Addr                           %s",   
                szAddr
                );



            // print addresses of ras clients
            
            pRasClientAddr = (PDWORD)(paddr+1);

            for (NumClients= 0; NumClients<pib->AddrCount-1; NumClients++,pRasClientAddr++) {
                WRITELINE(
                    hConsole, *pc, "Ras client Addr:                  %s",
                    INET_NTOA(*pRasClientAddr)
                    );
            }


            //Set pointer to the next Interface binding
            ptr = (PBYTE) (pRasClientAddr);
        }
    
            
    } //end print statistics of the interface
    
    
    LastIfIndex = pib->IfIndex;

    pQuery->TypeId = IGMP_IF_BINDING_ID;
    pQuery->IfIndex = LastIfIndex;

    return;
    
}//end _PrintIfBinding



//------------------------------------------------------------------------------
//          _PrintIfGroupsList
//------------------------------------------------------------------------------

VOID
PrintIfGroupsList(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    ) 
{
    DWORD                       i, j, LastIfIndex, Flags;
    CHAR                        szAddr[64], szFlags[4];
    PIGMP_MIB_IF_GROUPS_LIST    pIfGroupList;
    PBYTE                       ptr;
    PMIB_GROUP_INFO_V3          pGIInfo;
    PMIB_PROXY_GROUP_INFO_V3    pGIProxyInfo;
    BOOL                        bProxy;
    DWORD                       bVer3;

    
    ptr = pResponse->Buffer;
    

    pIfGroupList = (PIGMP_MIB_IF_GROUPS_LIST) ptr;
    bProxy = IS_IFTYPE_PROXY(pIfGroupList->IfType);
    bVer3 = pResponse->Flags & IGMP_ENUM_FORMAT_IGMPV3;


    if (pQuery->Flags&IGMP_ENUM_INTERFACE_TABLE_BEGIN) {
    
        WRITE_NEWLINE(hConsole, *pc);
        
        if (bProxy) {
            WRITELINE(
                hConsole, *pc, "%s",
                "ProxyInterface"
            );
        }
        
        WRITELINE(
            hConsole, *pc, "Interface Index: %0x",
            pIfGroupList->IfIndex
        );

        if (pIfGroupList->NumGroups!=0) {
            if (bProxy) {
                WRITELINE(
                    hConsole, *pc, "   %s",
                    "GroupAddr             UpTime Flags"
                );
            }
            else {
                if (!bVer3) {
                    WRITELINE(
                        hConsole, *pc, "   %s",
                        "(Ver)GroupAddr       LastReporter      (Up/Exp)Time Flags V1Host(TimeLeft)"
                    );
                }
                else {
                    WRITELINE(
                        hConsole, *pc, "%s",
                        "(Ver)  GroupAddr            (Up/Exp)Time   Flags V1Host V2Host"
                    );
                }
            }
        }

    }
    
    //
    // print all groups which are members on this interface
    //
    if (bProxy)
        pGIProxyInfo = (PMIB_PROXY_GROUP_INFO_V3)pIfGroupList->Buffer;        
    else
        pGIInfo = (PMIB_GROUP_INFO_V3)pIfGroupList->Buffer;          
    

    for (j=0;  j<pIfGroupList->NumGroups;  j++) {

        Flags = (bProxy)? pGIProxyInfo->Flags: pGIInfo->Flags;
        sprintf(szFlags, "   ");
        
        if (Flags&IGMP_GROUP_TYPE_NON_STATIC)
            szFlags[0] = 'L';
        if (Flags&IGMP_GROUP_TYPE_STATIC)
            szFlags[1] = 'S';
        if (Flags&IGMP_GROUP_FWD_TO_MGM)
            szFlags[2] = 'F';

            
        //
        // proxy interface
        //
        if (bProxy) {

            WRITELINE3(
                hConsole, *pc, "   %-15s  %10d  %s",
                INET_NTOA(pGIProxyInfo->GroupAddr), pGIProxyInfo->GroupUpTime, szFlags
            );

            if (bVer3) {
                DWORD SrcCnt;
                CHAR JoinMode = ' ';
                CHAR JoinModeIntended = ' ';
                
                for (SrcCnt=0;  SrcCnt<pGIProxyInfo->NumSources;  SrcCnt++) {
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & IGMP_GROUP_ALLOW)
                        JoinMode = 'A';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & IGMP_GROUP_BLOCK)
                        JoinMode = 'B';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & IGMP_GROUP_NO_STATE)
                        JoinMode = '-';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & (IGMP_GROUP_ALLOW<<4))
                        JoinModeIntended = 'A';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & (IGMP_GROUP_BLOCK<<4))
                        JoinModeIntended = 'B';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & (IGMP_GROUP_NO_STATE<<4))
                        JoinModeIntended = '-';

                    WRITELINE3(
                        hConsole, *pc, "   - %-15s:%c:%c",
                        INET_NTOA(pGIProxyInfo->Sources[SrcCnt].Source),
                        JoinMode,JoinModeIntended
                    );
                }
            }
        }
        
        //
        // non-proxy interface
        //
        else if (!bProxy && !bVer3){
        
            CHAR    szGroupAddr[64], szLastReporter[64], szExpTime[50];
            DWORD   GroupVersion = (pGIInfo->V1HostPresentTimeLeft)?1:2;
            CHAR    szV1HostPresent[10];
            
            INET_COPY(szGroupAddr, pGIInfo->GroupAddr);
            INET_COPY(szLastReporter, pGIInfo->LastReporter);
            
            szV1HostPresent[0] = 'N'; szV1HostPresent[1] = '\0';
            if (pGIInfo->V1HostPresentTimeLeft!=0)
                sprintf(szV1HostPresent, "%d", pGIInfo->V1HostPresentTimeLeft);
                
            sprintf(szExpTime, "%d", pGIInfo->GroupExpiryTime);
            if ( (Flags&IGMP_GROUP_TYPE_STATIC) 
                    && !(Flags&IGMP_GROUP_TYPE_NON_STATIC) ) {
                sprintf(szExpTime, "inf");
                sprintf(szLastReporter, "      -");
            }

            WRITELINE7(
                hConsole, *pc, "[%d]   %-13s %-15s %7d|%3s   %3s    %-10s",
                GroupVersion, szGroupAddr, szLastReporter, pGIInfo->GroupUpTime, 
                    szExpTime, szFlags, szV1HostPresent
            );
        }
        else if (!bProxy && bVer3) {

            CHAR    szGroupAddr[64], szExpTime[50], szFilter[10];
            CHAR    szV1HostPresent[10], szV2HostPresent[10];
            DWORD   GroupVersion = pGIInfo->Version, SrcCnt=0;
            
            INET_COPY(szGroupAddr, pGIInfo->GroupAddr);
            
            szV1HostPresent[0] = szV2HostPresent[0] = 'N';
            szV1HostPresent[1] = szV2HostPresent[1] = '\0';
            
            if (pGIInfo->V1HostPresentTimeLeft!=0)
                sprintf(szV1HostPresent, "%d", pGIInfo->V1HostPresentTimeLeft);
            if (pGIInfo->V2HostPresentTimeLeft!=0)
                sprintf(szV2HostPresent, "%d", pGIInfo->V2HostPresentTimeLeft);


            if (GroupVersion==3 && pGIInfo->FilterType==INCLUSION)
                sprintf(szExpTime, "-na");
            else //if (pGIInfo->FilterType==exclusion)
                sprintf(szExpTime, "%d", pGIInfo->GroupExpiryTime);


            if ( (Flags&IGMP_GROUP_TYPE_STATIC) 
                    && !(Flags&IGMP_GROUP_TYPE_NON_STATIC) ) {
                sprintf(szExpTime, "inf");
            }
            if (GroupVersion==3) {
                sprintf(szFilter, "%s", pGIInfo->FilterType==INCLUSION? "[IN]" : 
                        "[EX]");
            }
            else
                strcpy(szFilter, "    ");
                
            WRITELINE8(
                hConsole, *pc, "[%d]   %-13s%s    %7d|%3s   %3s    %5s    %-5s",
                GroupVersion, szGroupAddr, szFilter, pGIInfo->GroupUpTime, 
                    szExpTime, szFlags, szV1HostPresent, szV2HostPresent
            );

            if (GroupVersion==3) {
                for (SrcCnt=0;  SrcCnt<pGIInfo->NumSources;  SrcCnt++) {
                    if (pGIInfo->Sources[SrcCnt].SourceExpiryTime==~0)
                        sprintf(szExpTime, "%s", "inf");
                    else {
                        sprintf(szExpTime, "%d", 
                            pGIInfo->Sources[SrcCnt].SourceExpiryTime/1000);
                    }
                    WRITELINE3(
                        hConsole, *pc, "    - %-13s        %7d|%-s",
                        INET_NTOA(pGIInfo->Sources[SrcCnt].Source),
                        pGIInfo->Sources[SrcCnt].SourceUpTime,
                        szExpTime
                    );
                }
            }
        }
        

        //
        // increment pGIInfo/pGIProxyInfo
        //
        if (bProxy) {
            if (bVer3)
                pGIProxyInfo = (PMIB_PROXY_GROUP_INFO_V3)
                                    &pGIProxyInfo->Sources[pGIProxyInfo->NumSources];
            else
                pGIProxyInfo = (PMIB_PROXY_GROUP_INFO_V3)
                                    ((PMIB_PROXY_GROUP_INFO)pGIProxyInfo+1);
        }
        else {
            if (bVer3) 
                pGIInfo = (PMIB_GROUP_INFO_V3) 
                            &pGIInfo->Sources[pGIInfo->NumSources];
            else
                pGIInfo = (PMIB_GROUP_INFO_V3) ((PMIB_GROUP_INFO)pGIInfo+1);
        }
    }
    
    
    pQuery->TypeId = IGMP_IF_GROUPS_LIST_ID;
    pQuery->IfIndex = pIfGroupList->IfIndex;

    return;
    
}//end _PrintIfGroupsList



//------------------------------------------------------------------------------
//          _PrintGroupIfsList
//------------------------------------------------------------------------------
VOID
PrintGroupIfsList(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    ) 
{
    DWORD                       i, j, LastGroupAddr;
    CHAR                        szGroupAddr[22];
    PIGMP_MIB_GROUP_IFS_LIST    pGroupIfsList;
    PMIB_GROUP_INFO_V3          pGIInfo;    
    PBYTE                       ptr;
    DWORD                       bVer3;


    ptr = pResponse->Buffer;
    bVer3 = pResponse->Flags & IGMP_ENUM_FORMAT_IGMPV3;

    if (pResponse->Count<=0) //prefast
        return;
        
    for (i=0;  i<pResponse->Count;  i++) {
    
        pGroupIfsList = (PIGMP_MIB_GROUP_IFS_LIST) ptr;
    
        INET_COPY(szGroupAddr, pGroupIfsList->GroupAddr);
        

        //
        // print all GIs which are members on this group
        //
        pGIInfo = (PMIB_GROUP_INFO_V3)pGroupIfsList->Buffer;

        for (j=0;  j<pGroupIfsList->NumInterfaces;  j++) {
            CHAR    szIpAddr[16], szLastReporter[16], szV1Host[4], 
                    szV1HostTimeLeft[10], szFlags[5], szGroupExpTime[10];

                    
            sprintf(szFlags, "   ");        
            if (pGIInfo->Flags&IGMP_GROUP_TYPE_NON_STATIC)
                szFlags[0] = 'L';
            if (pGIInfo->Flags&IGMP_GROUP_TYPE_STATIC)
                szFlags[1] = 'S';
            if (pGIInfo->Flags&IGMP_GROUP_FWD_TO_MGM)
                szFlags[2] = 'F';
                
            INET_COPY(szIpAddr, pGIInfo->IpAddr);

            if (!bVer3){

                CHAR    szExpTime[50];
                DWORD   GroupVersion = (pGIInfo->V1HostPresentTimeLeft)?1:2;
                CHAR    szV1HostPresent[10];

                INET_COPY(szGroupAddr, pGIInfo->GroupAddr);
                INET_COPY(szLastReporter, pGIInfo->LastReporter);

                szV1HostPresent[0] = '\0';
                if (pGIInfo->V1HostPresentTimeLeft!=0)
                    sprintf(szV1HostPresent, "%d", pGIInfo->V1HostPresentTimeLeft);

                sprintf(szExpTime, "%d", pGIInfo->GroupExpiryTime);
                if ( (pGIInfo->Flags&IGMP_GROUP_TYPE_STATIC)
                        && !(pGIInfo->Flags&IGMP_GROUP_TYPE_NON_STATIC) ) {
                    sprintf(szExpTime, "inf");
                    sprintf(szLastReporter, "      -");
                }

                WRITELINE9(
                    hConsole, *pc,
                    "[%d]   %-12s      %7d|%-3s   %3s  <%d:%-14s> %-12s %5s",
                    GroupVersion, szGroupAddr,
                    pGIInfo->GroupUpTime, szExpTime, szFlags,
                    pGIInfo->IfIndex, szIpAddr, 
                    szLastReporter, szV1HostPresent
                );
            }
            else {

                CHAR    szExpTime[50], szFilter[10];
                CHAR    szV1HostPresent[10], szV2HostPresent[10];
                DWORD   GroupVersion = pGIInfo->Version, SrcCnt=0;

                INET_COPY(szGroupAddr, pGroupIfsList->GroupAddr);

                szV1HostPresent[0] = szV2HostPresent[0] = 'N';
                szV1HostPresent[1] = szV2HostPresent[1] = '\0';
                
                if (pGIInfo->V1HostPresentTimeLeft!=0)
                    sprintf(szV1HostPresent, "%d", pGIInfo->V1HostPresentTimeLeft);
                if (pGIInfo->V2HostPresentTimeLeft!=0)
                    sprintf(szV2HostPresent, "%d", pGIInfo->V2HostPresentTimeLeft);

                if (GroupVersion==3 && pGIInfo->FilterType==INCLUSION)
                    sprintf(szExpTime, "-na");
                else //if (pGIInfo->FilterType==exclusion)
                    sprintf(szExpTime, "%d", pGIInfo->GroupExpiryTime);

                if ( (pGIInfo->Flags&IGMP_GROUP_TYPE_STATIC)
                        && !(pGIInfo->Flags&IGMP_GROUP_TYPE_NON_STATIC) ) {
                    sprintf(szExpTime, "inf");
                }
                if (GroupVersion==3) {
                    strcpy(szFilter, pGIInfo->FilterType==INCLUSION?"[IN]" :
                            "[EX]");
                }
                else
                    strcpy(szFilter, "    ");

                WRITELINE10(
                    hConsole, *pc,
                    "[%d]   %-12s%s  %7d|%-3s   %3s   <%d:%-14s>  %20s   %5s",
                    GroupVersion, szGroupAddr, szFilter,
                    pGIInfo->GroupUpTime, szExpTime, szFlags, 
                    pGIInfo->IfIndex, szIpAddr,
                    szV1HostPresent, szV2HostPresent
                );

                if (GroupVersion==3) {
                    for (SrcCnt=0;  SrcCnt<pGIInfo->NumSources;  SrcCnt++) {
                        if (pGIInfo->Sources[SrcCnt].SourceExpiryTime==~0)
                            sprintf(szExpTime, "%s", "inf");
                        else {
                            sprintf(szExpTime, "%d", 
                                pGIInfo->Sources[SrcCnt].SourceExpiryTime/1000);
                        }
                        WRITELINE3(
                            hConsole, *pc, "    - %-12s      %7d|%s",
                            INET_NTOA(pGIInfo->Sources[SrcCnt].Source),
                            pGIInfo->Sources[SrcCnt].SourceUpTime,
                            szExpTime
                        );
                    }
                }
            }

            if (bVer3)
                pGIInfo = (PMIB_GROUP_INFO_V3)
                            &pGIInfo->Sources[pGIInfo->NumSources];
            else
                pGIInfo = (PMIB_GROUP_INFO_V3) ((PMIB_GROUP_INFO)pGIInfo+1);
                
        } //for loop: end print all GIs

        ptr = (PBYTE)pGIInfo;

    }
    
    LastGroupAddr= pGroupIfsList->GroupAddr;

    
    pQuery->TypeId = IGMP_GROUP_IFS_LIST_ID;
    pQuery->GroupAddr = LastGroupAddr;

    return;
    
}//end _PrintGroupIfsList


#endif MIB_DEBUG




DWORD
ListLength(
    PLIST_ENTRY pHead
    )
{
    DWORD Len=0;
    PLIST_ENTRY ple;
    
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink,Len++)
        ;
    return Len;
}


//------------------------------------------------------------------------------
//          _MibGet
//
// Called by an admin (SNMP) utility.  It actually passes through the
// IP Router Manager, but all that does is demux the call to the
// desired routing protocol
//
// Calls: _MibGetInternal() with GETMODE_EXACT.
// Locks: Takes no locks. _MibGetInternal() will get the locks it requires
//------------------------------------------------------------------------------
DWORD
APIENTRY
MibGet(
    IN     DWORD  dwInputSize,
    IN     PVOID  pInputData,
    IN OUT PDWORD pdwOutputSize,
       OUT PVOID  pOutputData
    )
{
    DWORD                       Error=NO_ERROR;
    PIGMP_MIB_GET_INPUT_DATA    pQuery;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse;


    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }



    Trace1(MIB, "entering _MibGet(): dwInputSize(%d)", dwInputSize);


    if ( (pInputData == NULL)
        || (dwInputSize < sizeof(IGMP_MIB_GET_INPUT_DATA))
        || (pdwOutputSize == NULL)
       ) 
    {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {

        pQuery = (PIGMP_MIB_GET_INPUT_DATA)pInputData;

        // with GETMODE_EXACT you can get only one
        pQuery->Count = 1;
        
        pResponse = (PIGMP_MIB_GET_OUTPUT_DATA)pOutputData;

        Error = MibGetInternal(pQuery, pResponse, pdwOutputSize, GETMODE_EXACT);

    }


    Trace1(MIB, "leaving _MibGet(): %d", Error);
    LeaveIgmpApi();

    return Error;
}


//------------------------------------------------------------------------------
//        MibGetFirst
//
// Calls: _MibGetInternal() with GETMODE_FIRST
// Locks: No locks taken here. _MibGetInternal() takes the locks it requires
//------------------------------------------------------------------------------
DWORD
APIENTRY
MibGetFirst(
    IN     DWORD  dwInputSize,
    IN     PVOID  pInputData,
    IN OUT PDWORD pdwOutputSize,
       OUT PVOID  pOutputData
    )
{
    DWORD                       Error=NO_ERROR;
    PIGMP_MIB_GET_INPUT_DATA    pQuery;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse;


    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    Trace4(MIB, "entering _MibGetFirst(): dwInputSize(%d) pInputData(%08x)"
            "pdwOutputSize(%08x) pOutputData(%08x)",
            dwInputSize, pInputData, pdwOutputSize, pOutputData);


    if ( (pInputData == NULL) 
        || (dwInputSize < sizeof(IGMP_MIB_GET_INPUT_DATA))
        || (pdwOutputSize == NULL)
        )
    {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {
        pQuery = (PIGMP_MIB_GET_INPUT_DATA)pInputData;
        if (pQuery->Count<=0)
            pQuery->Count = 1;

        pResponse = (PIGMP_MIB_GET_OUTPUT_DATA)pOutputData;

        Error = MibGetInternal(pQuery, pResponse, pdwOutputSize, GETMODE_FIRST);
    }


    Trace1(MIB, "leaving _MibGetFirst: %d", Error);
    LeaveIgmpApi();

    return Error;
}



//------------------------------------------------------------------------------
//         _MibGetNext
//
// This call returns the entry in the table AFTER the one specified in the input.
// If the end of the table being queried has been reached, this function will
// return the FIRST entry from the NEXT table, where "NEXT" here means the
// table whose ID is one greater than the ID passed in.
// In any case, this function writes the required size to pdwOutputSize and
// writes the ID of the object that WOULD have been returned into the output
// buffer.
//
// Calls:
//      _MibGetInternal() with GETMODE_NEXT. If end of table reached, calls
//      _MibGetInternal() again with GETMODE_FIRST for the next table.
//------------------------------------------------------------------------------
DWORD
APIENTRY
MibGetNext(
    IN     DWORD  dwInputSize,
    IN     PVOID  pInputData,
    IN OUT PDWORD pdwOutputSize,
       OUT PVOID  pOutputData
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       dwOutSize = 0, dwBufSize = 0;
    PIGMP_MIB_GET_INPUT_DATA    pQuery;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse;



    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    Trace4(MIB, "entering _MibGetNext(): dwInputSize(%d) pInputData(%08x) "
            "pdwOutputSize(%08x)  pOutputData(%08x)",
            dwInputSize, pInputData, pdwOutputSize, pOutputData);



    if (pInputData == NULL ||
        dwInputSize < sizeof(IGMP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {

        pQuery = (PIGMP_MIB_GET_INPUT_DATA)pInputData;
        pResponse = (PIGMP_MIB_GET_OUTPUT_DATA)pOutputData;
        if (pQuery->Count<=0)
            pQuery->Count = 1;
            
        dwOutSize = *pdwOutputSize;

        Error = MibGetInternal(pQuery, pResponse, pdwOutputSize, GETMODE_NEXT);


        if ((Error==ERROR_NO_MORE_ITEMS) && (pQuery->Flags&IGMP_ENUM_ALL_TABLES) )
        {

            //
            // need to wrap to the first entry in the next table,
            // if there is a next table
            //
            *pdwOutputSize = dwOutSize;

            //
            // wrap to next table by incrementing the type ID
            //
            do {
                ++pQuery->TypeId;

                Error = MibGetInternal(pQuery, pResponse, pdwOutputSize, 
                                        GETMODE_FIRST);
                
            } while ( (Error==ERROR_INVALID_PARAMETER)&&(pQuery->TypeId<=IGMP_LAST_TABLE_ID) );
            
            --pQuery->TypeId;
        }

    }


    Trace1(MIB, "leaving _MibGetNext(): %d", Error);

    LeaveIgmpApi();

    return Error;
}


//------------------------------------------------------------------------------
// Function:    _MibGetInternal
//
// This handles the actual structure access required to read MIB data.
// Each table supported by IGMP supports three modes of querying;
// EXACT, FIRST, and NEXT, which correspond to the functions _MibGet(),
// _MibGetFirst(), and _MibGetNext() respectively.
//------------------------------------------------------------------------------

DWORD
MibGetInternal(
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode
    ) 
{
    DWORD     Error = NO_ERROR, dwBufferSize;

    
    //
    // first we use pdwOutputSize to compute the size of the buffer
    // available for storing returned structures (the size of Buffer)
    //

    if (pResponse == NULL) {
        dwBufferSize = 0;
    }
    else {
        if (*pdwOutputSize < sizeof(IGMP_MIB_GET_OUTPUT_DATA)) {
            dwBufferSize = 0;
        }
        else {
            dwBufferSize = *pdwOutputSize
                            - sizeof(IGMP_MIB_GET_OUTPUT_DATA) + 1;

            //kslksl
            if (dwBufferSize>150)
                dwBufferSize -= 150;
        }
    }

    *pdwOutputSize = 0;


    // set flag for ras stats if pQuery has it and config supports it
    if (pResponse!=NULL) {
        pResponse->Flags = 0;
        if ( (pQuery->Flags&IGMP_ENUM_FOR_RAS_CLIENTS) 
            && (g_Config.RasClientStats) ) 
        {
            pResponse->Flags |= IGMP_ENUM_FOR_RAS_CLIENTS;
        }
    }
    
    
    //
    // determine which type of data is to be returned
    //

    switch (pQuery->TypeId) {

    case IGMP_GLOBAL_STATS_ID: 
    {

        //
        // there is only one global config object,
        // so GETMODE_NEXT will return ERROR_NO_MORE_ITEMS
        //

        if (pResponse!=NULL) 
            pResponse->TypeId = IGMP_GLOBAL_STATS_ID; 

        if (dwGetMode == GETMODE_NEXT) {
            Error = ERROR_NO_MORE_ITEMS;
            break;
        }

        *pdwOutputSize = sizeof(IGMP_MIB_GLOBAL_STATS);


        if (pResponse == NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER; 
            break; 
        }


        // make sure that the buffer size is big enough
        
        if (dwBufferSize < sizeof(IGMP_MIB_GLOBAL_STATS)) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }


        // set the values
        
        else {

            PIGMP_MIB_GLOBAL_STATS   pGlobalStats;

            pGlobalStats = (PIGMP_MIB_GLOBAL_STATS)pResponse->Buffer;


            pGlobalStats->CurrentGroupMemberships 
                    = g_Info.CurrentGroupMemberships;
                    
            pGlobalStats->GroupMembershipsAdded
                    = g_Info.GroupMembershipsAdded;
                                
        }

        pResponse->Count = 1;
        
        break;
        
    }//end case IGMP_GLOBAL_STATS_ID


    case IGMP_GLOBAL_CONFIG_ID: {

        //
        // there is only one global config object,
        // so GETMODE_NEXT will return ERROR_NO_MORE_ITEMS
        //

        if (pResponse!=NULL) 
            pResponse->TypeId = IGMP_GLOBAL_CONFIG_ID; 

        if (dwGetMode == GETMODE_NEXT) {
            Error = ERROR_NO_MORE_ITEMS;
            break;
        }

        *pdwOutputSize = sizeof(IGMP_MIB_GLOBAL_CONFIG);


        if (pResponse == NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER; 
            break; 
        }

        if (dwBufferSize < sizeof(IGMP_MIB_GLOBAL_CONFIG)) {
            Error = ERROR_INSUFFICIENT_BUFFER;
        }
        else {
        
            CopyMemory(pResponse->Buffer, &g_Config,
                        sizeof(IGMP_MIB_GLOBAL_CONFIG));
        }


        pResponse->Count = 1;

        break;
            
    } //end case IGMP_GLOBAL_CONFIG_ID


    case IGMP_PROXY_IF_INDEX_ID :
    {
        //
        // there can be only one proxy interface.
        // so GETMODE_NEXT will return ERROR_NO_MORE_ITEMS
        //

        if (pResponse!=NULL) 
            pResponse->TypeId = IGMP_PROXY_IF_INDEX_ID; 

        if (dwGetMode == GETMODE_NEXT) {
            Error = ERROR_NO_MORE_ITEMS;
            break;
        }

        *pdwOutputSize = sizeof(DWORD);


        if (pResponse == NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER; 
            break; 
        }


        // make sure that the buffer size is big enough
        
        if (dwBufferSize < sizeof(DWORD)) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }


        // set the values
        
        else {

            DWORD  *pProxyIndex;

            pProxyIndex = (DWORD*)pResponse->Buffer;

            *pProxyIndex = g_ProxyIfIndex;                                
        }

        pResponse->Count = 1;
        
        break;

    } //end case IGMP_PROXY_IF_INDEX_ID


    
    case IGMP_IF_BINDING_ID :
    {

        Error = MibGetInternalIfBindings(pQuery, pResponse, pdwOutputSize, 
                                        dwGetMode, dwBufferSize);
        
        break;
    }


    case IGMP_IF_STATS_ID: {
        //
        // set the size needed. It will be set again at the end to the 
        // exact size used.
        //
            
        if (pQuery->Count==0) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        Error = MibGetInternalIfStats(pQuery, pResponse, pdwOutputSize, dwGetMode,
                                dwBufferSize);
        
        break;
        
    } //end case IGMP_IF_STATS_ID



    case IGMP_IF_CONFIG_ID: 
    {

        if (pQuery->Count==0) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }


        Error = MibGetInternalIfConfig(pQuery, pResponse, pdwOutputSize, 
                                dwGetMode, dwBufferSize);

        break;
        
    } //end case IGMP_IF_CONFIG_ID
    

    // I cant get the list of groups for a RAS server interface
    
    case IGMP_IF_GROUPS_LIST_ID :
    {
        PIGMP_MIB_IF_GROUPS_LIST pIfGroupList;

        if (pQuery->Count==0) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        while (1) {
            
            Error = MibGetInternalIfGroupsInfo(pQuery, pResponse, pdwOutputSize, 
                                            dwGetMode, dwBufferSize);

            if ( (Error!=NO_ERROR) || (pResponse==NULL) )
                break;
                
            pIfGroupList = (PIGMP_MIB_IF_GROUPS_LIST)pResponse->Buffer;

            if ( (pIfGroupList->NumGroups==0)
                && (pQuery->Flags&IGMP_ENUM_ALL_INTERFACES_GROUPS)
                && (pQuery->Flags&IGMP_ENUM_INTERFACE_TABLE_END)
                && !(pQuery->Flags&IGMP_ENUM_INTERFACE_TABLE_BEGIN)
                && !(pQuery->Flags&IGMP_ENUM_INTERFACE_TABLE_CONTINUE) )
            {
                continue;
            }
            else
                break;
        }
        
        break;
        
    } //end case IGMP_IF_GROUPS_LIST_ID
                        
       
    case IGMP_GROUP_IFS_LIST_ID :
    {
        if (pQuery->Count==0) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }
        
        Error = MibGetInternalGroupIfsInfo(pQuery, pResponse, pdwOutputSize, 
                                        dwGetMode, dwBufferSize);

        break;
        
    } //end  case IGMP_GROUP_IFS_LIST_ID


    // set this for group statistics        ERROR_NO_MORE_ITEMS
    default: {
  
        Error = ERROR_INVALID_PARAMETER;
    }
    
    } //end switch


    if (pdwOutputSize)
        *pdwOutputSize += sizeof(IGMP_MIB_GET_OUTPUT_DATA);

    //kslksl
    if (pdwOutputSize && Error==ERROR_INSUFFICIENT_BUFFER)
        *pdwOutputSize = *pdwOutputSize+500;

    
    return Error;
    
} //_MibGetInternal                       


    
//------------------------------------------------------------------------------
//              MibGetInternalIfBindings
//
// Returns the binding info of pQuery->Count number of interfaces.
//
//Locks: 
//  Takes the IfLists lock so that the InterfaceList does not change in between.
//  It also prevents the bindings from being changed, as (Un)Bind If takes this lock.
//------------------------------------------------------------------------------

DWORD
MibGetInternalIfBindings (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    ) 
{
    PIF_TABLE_ENTRY             pite;
    PIGMP_MIB_IF_BINDING        pBindingDst;
    PIGMP_IF_BINDING            pBindingSrc;
    DWORD                       dwSize, dwSizeCur=0, dwCount, Error=NO_ERROR;

    
    Trace0(MIB, "Entering _MibGetInternalIfBinding");

    if (pResponse!=NULL) { 
        pResponse->TypeId = IGMP_IF_BINDING_ID; 
        pBindingDst = (PIGMP_MIB_IF_BINDING)pResponse->Buffer;
    }



    ACQUIRE_IF_LIST_LOCK("_MibGetInternalBindings");


    
    for (dwCount=0, dwSize=0;  dwCount<pQuery->Count;  ) {
        //
        // retrieve the interface whose binding is to be read
        //

        pite = GetIfByListIndex(pQuery->IfIndex, dwGetMode, &Error);        

        //
        // if the interface was found, it may mean that the index
        // specified was invalid, or it may mean that a GETMODE_NEXT
        // retrieval was attempted on the last interface, in which case
        // ERROR_NO_MORE_ITEMS would have been returned.
        //

        if (pite == NULL) {
         
            if (dwCount>0) 
                Error = NO_ERROR;
                
            // count==0
            else {
                if (Error == NO_ERROR)
                    Error = ERROR_INVALID_PARAMETER;
                *pdwOutputSize = 0;
            }

            break; //from for loop
        }


        // dont have to take the interface lock, as IfLists lock is
        // taken before bindings are changed.


        //
        // compute the size of the interface binding retrieved,
        // and write it over the caller's supplied size
        //

        pBindingSrc = pite->pBinding;
        dwSizeCur = (pBindingSrc
                        ? sizeof(IGMP_MIB_IF_BINDING)
                            +pBindingSrc->AddrCount*(sizeof(IGMP_MIB_IP_ADDRESS))
                        : sizeof(IGMP_MIB_IF_BINDING));
                    
         


        //
        // if no buffer was specified, indicate one should be allocated
        //

        if (pResponse == NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break; //for loop
        }



        //
        // if the buffer is not large enough,
        // indicate that it should be enlarged
        //

        if (dwBufferSize < dwSize + dwSizeCur) {
            if (dwCount==0)
                Error = ERROR_INSUFFICIENT_BUFFER;

            break; //from for loop
        }


        //
        // copy the binding
        //

        if (pBindingSrc!=NULL) {

            pBindingDst->AddrCount = pBindingSrc->AddrCount;

            CopyMemory(pBindingDst+1, pBindingSrc+1, 
                pBindingSrc->AddrCount*(sizeof(IGMP_MIB_IP_ADDRESS)));
        }
        
        else {
            pBindingDst->AddrCount = 0;
        }


        pBindingDst->IfIndex = pite->IfIndex;
        pBindingDst->IfType = GET_EXTERNAL_IF_TYPE(pite);

        GET_EXTERNAL_IF_STATE(pite, pBindingDst->State);

        pQuery->IfIndex = pite->IfIndex;
        pQuery->RasClientAddr = 0;

        dwCount++;
        dwSize += dwSizeCur;
        pBindingDst = (PIGMP_MIB_IF_BINDING) ((PBYTE)pBindingDst + dwSizeCur);


        // if GetMode==GETMODE_FIRST change it to GETMODE_NEXT.
        if (dwGetMode==GETMODE_FIRST) 
            dwGetMode = GETMODE_NEXT; 

    }//end for loop

    //set size if bindings have been copied. else it has already been set
    if (dwCount>0) {
        *pdwOutputSize = dwSize;
    } 
    else {
        *pdwOutputSize = dwSizeCur;
    }

    
    if (pResponse!=NULL) {
        pResponse->Count = dwCount;
    }


    RELEASE_IF_LIST_LOCK("_MibGetInternalBindings");


    Trace0(MIB, "Leaving _MibGetInternalIfBinding");
    return Error;
    
} //end _MibGetInternalIfBindings


//------------------------------------------------------------------------------
//              _MibGetInternalGroupIfsInfo
//------------------------------------------------------------------------------
DWORD
MibGetInternalGroupIfsInfo (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    ) 
{
    LONGLONG                    llCurTime = GetCurrentIgmpTime();
    BOOL                        bRasTableLock=FALSE, bGroupBucketLock=FALSE;
    PIGMP_MIB_GROUP_IFS_LIST    pHeader;
    PMIB_GROUP_INFO_V3          pGIInfo;
    PGI_ENTRY                   pgie;
    PLIST_ENTRY                 pHead, ple;
    DWORD                       dwSize, dwCurSize, Error=NO_ERROR, dwCount, dwNumIfs, i;
    DWORD                       PrevGroup, Group, dwNumIfsCopied;
    PRAS_TABLE_ENTRY            prte;
    PRAS_TABLE                  prt, prtOld;
    PGROUP_TABLE_ENTRY          pge;
    BOOL                        bEnumV3;

    //Trace3(MEM, "_MibGetInternalGroupIfsInfo buffer: %0x -> %0x: %d", 
    //(DWORD)pResponse->Buffer, ((DWORD)pResponse->Buffer)+dwBufferSize, dwBufferSize);//deldel
    
    Trace0(MIB, "Entering _MibGetInternalGroupIfsInfo()");

    bEnumV3 = pQuery->Flags & IGMP_ENUM_SUPPORT_FORMAT_IGMPV3;
    
    //
    // The data returned for each Interface is variable length
    //
    if (pResponse!=NULL) {
        pResponse->TypeId = IGMP_GROUP_IFS_LIST_ID;
        pHeader = (PIGMP_MIB_GROUP_IFS_LIST) pResponse->Buffer;

        //
        //  if GETMODE_FIRST: merge the new and main group lists
        //
        if (dwGetMode==GETMODE_FIRST) {
        
            ACQUIRE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");
            MergeGroupLists();
            RELEASE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");
        }
    }

    
    PrevGroup = pQuery->GroupAddr;
    
    for (dwCount=0, dwSize=0;  dwCount<pQuery->Count;  ) {

        ACQUIRE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");
        bRasTableLock = FALSE;

        //
        // retrieve the groups whose information is to be retrieved
        //
        pge = GetGroupByAddr(PrevGroup, dwGetMode, &Error);

        if (pge == NULL) {

            if (dwCount>0)
                Error = NO_ERROR;
            else {
                if (Error==NO_ERROR)  
                    Error = ERROR_INVALID_PARAMETER;
                *pdwOutputSize = 0;
            }

                
            RELEASE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");

            break;
        }

        Group = pge->Group;


        if (!IS_MCAST_ADDR(Group)) {

            Trace0(ERR, "==========================================================");
            Trace2(ERR, "bad group(%d.%d.%d.%d)(pge:%0x) MibGetInternalGroupIfsInfo",
                        PRINT_IPADDR(pge->Group), (ULONG_PTR)pge);
            Trace0(ERR, "==========================================================");

            IgmpAssert(FALSE);
        }
        
        RELEASE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");


        //
        // have to release the group list lock before I acquire the group bucket
        // lock to prevent deadlock.
        //
       
        //
        // take group bucket lock
        //
        ACQUIRE_GROUP_LOCK(Group, "_MibGetInternalGroupIfsInfo");
        bGroupBucketLock = TRUE;

        
        // get the group again as it could have been deleted.
        pge = GetGroupFromGroupTable (Group, NULL, 0);

        // if the group has been meanwhile deleted, then continue
        if (pge==NULL) {
            RELEASE_GROUP_LOCK(Group, "_MibGetInternalGroupIfsInfo");
            bGroupBucketLock = FALSE;
            continue;
        }

        
        //
        // compute the size of the data returned
        //
        dwNumIfs = pge->NumVifs;

        if (bEnumV3) {
        
            pHead = &pge->ListOfGIs;
            
            dwCurSize = sizeof(IGMP_MIB_GROUP_IFS_LIST) +
                                dwNumIfs*sizeof(MIB_GROUP_INFO_V3);

            i = 0;
            for (ple=pHead->Flink;  (ple!=pHead)&&(i<dwNumIfs);  
                    ple=ple->Flink,i++) 
            {
                pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkByGI);

                if (pgie->Version==3) {
                    dwCurSize += ( (pgie->NumSources + 
                                        ListLength(&pgie->V3ExclusionList))
                                    *sizeof(IGMP_MIB_GROUP_SOURCE_INFO_V3) );
                }
            }

        }
        else {
            dwCurSize = sizeof(IGMP_MIB_GROUP_IFS_LIST) +
                                dwNumIfs*sizeof(IGMP_MIB_GROUP_INFO);
                                
            if (pResponse == NULL) {
                Error = ERROR_INSUFFICIENT_BUFFER;
                break;
            }      
        }

        //
        // if the buffer is not large enough, break from the loop
        //

        if (dwBufferSize < dwSize + dwCurSize) {

            if (dwCount==0)
                Error = ERROR_INSUFFICIENT_BUFFER;

            break;//from for loop
        }
        

        // set fields for group info
        
        pHeader->GroupAddr = pge->Group;
        pHeader->NumInterfaces = dwNumIfs;

        //
        // set groupAddr in pQuery so that in the next query, the info for other groups will
        // be passed
        //
        pQuery->GroupAddr = pge->Group;


        //
        // copy stats for interfaces that have joined the group.
        //
        pGIInfo = (PMIB_GROUP_INFO_V3)pHeader->Buffer;

        pHead = &pge->ListOfGIs;
        dwNumIfsCopied = 0;
        for (ple=pHead->Flink;  (ple!=pHead)&&(dwNumIfsCopied<dwNumIfs);  
                ple=ple->Flink,dwNumIfsCopied++) 
        {
            DWORD GIVersion;
            
            pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkByGI);

            GIVersion = pgie->Version;
            
            pGIInfo->IfIndex = pgie->IfIndex;
            
            //
            // if rasServerIf, then I return the NHAddr in IpAddr field
            // else return the IpAddr of this field
            //
            pGIInfo->IpAddr = (IS_RAS_SERVER_IF(pgie->pIfTableEntry->IfType))
                                ? pgie->NHAddr
                                : pgie->pIfTableEntry->IpAddr;


            pGIInfo->GroupExpiryTime
                            = (pgie->Info.GroupExpiryTime==~0)
                            ? ~0
                            : SYSTEM_TIME_TO_SEC(pgie->Info.GroupExpiryTime-llCurTime);
            pGIInfo->LastReporter = pgie->Info.LastReporter;


            pGIInfo->GroupUpTime = 
                        SYSTEM_TIME_TO_SEC(llCurTime-pgie->Info.GroupUpTime);

                        
            if (llCurTime<pgie->Info.V1HostPresentTimeLeft)
                pGIInfo->V1HostPresentTimeLeft = 
                    SYSTEM_TIME_TO_SEC(pgie->Info.V1HostPresentTimeLeft-llCurTime);
            else
                pGIInfo->V1HostPresentTimeLeft = 0;

            if ( llCurTime>=pgie->Info.V2HostPresentTimeLeft)
                pGIInfo->V2HostPresentTimeLeft = 0;
            else {
                pGIInfo->V2HostPresentTimeLeft = 
                        SYSTEM_TIME_TO_SEC(pgie->Info.V2HostPresentTimeLeft-llCurTime);
            }

            
            pGIInfo->Flags = 0;
            if (pgie->bStaticGroup)
                pGIInfo->Flags |= IGMP_GROUP_TYPE_STATIC;
            if (pgie->GroupMembershipTimer.Status&TIMER_STATUS_ACTIVE)
                pGIInfo->Flags |= IGMP_GROUP_TYPE_NON_STATIC;
            if (CAN_ADD_GROUPS_TO_MGM(pgie->pIfTableEntry))
                pGIInfo->Flags |= IGMP_GROUP_FWD_TO_MGM;

            if (bEnumV3) {

                PGI_SOURCE_ENTRY pSourceEntry;
                DWORD V3NumSources, V3SourcesSize;
                PLIST_ENTRY pHeadSrc, pLESrc;



                V3NumSources = pgie->NumSources + ListLength(&pgie->V3ExclusionList);
                V3SourcesSize = sizeof(IGMP_MIB_GROUP_SOURCE_INFO_V3)*V3NumSources;
                pGIInfo->Version = pgie->Version;
                pGIInfo->Size = sizeof(MIB_GROUP_INFO_V3) + V3SourcesSize;
                pGIInfo->FilterType = pgie->FilterType;
                pGIInfo->NumSources = V3NumSources;

                pHeadSrc = &pgie->V3InclusionListSorted;
                i = 0;
                for (pLESrc=pHeadSrc->Flink;  pLESrc!=pHeadSrc; pLESrc=pLESrc->Flink,i++) {


                    pSourceEntry = CONTAINING_RECORD(pLESrc, GI_SOURCE_ENTRY,
                                        LinkSourcesInclListSorted);
                    pGIInfo->Sources[i].Source = pSourceEntry->IpAddr;

                    pGIInfo->Sources[i].SourceExpiryTime
                            = (pSourceEntry->bInclusionList)
                            ? QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                            : ~0;

                    pGIInfo->Sources[i].SourceUpTime
                        = (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000;
                }

                pHeadSrc = &pgie->V3ExclusionList;
                for (pLESrc=pHeadSrc->Flink;  pLESrc!=pHeadSrc;  pLESrc=pLESrc->Flink,i++){

                    pSourceEntry = CONTAINING_RECORD(pLESrc, GI_SOURCE_ENTRY, LinkSources);
                    pGIInfo->Sources[i].Source = pSourceEntry->IpAddr;

                    pGIInfo->Sources[i].SourceExpiryTime
                            = (pSourceEntry->bInclusionList)
                            ? QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                            : ~0;

                    pGIInfo->Sources[i].SourceUpTime
                        = (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000;
                }

                pGIInfo = (PMIB_GROUP_INFO_V3)
                             ((PCHAR)pGIInfo + pGIInfo->Size);
                //Trace1(MEM, "NextPGIInfo: %0x:", (DWORD)pGIInfo);//deldel
            }
            else {
                pGIInfo = (PMIB_GROUP_INFO_V3)((PMIB_GROUP_INFO)pGIInfo + 1);
                //Trace1(MEM, "NextPGIInfo: %0x:", (DWORD)pGIInfo);//deldel
            }
            
        }

        //
        // everything fine. Copied one more stats struct
        //
        dwCount++;
        dwSize += dwCurSize;
        pHeader = (PIGMP_MIB_GROUP_IFS_LIST) pGIInfo;
        PrevGroup = pge->Group;


        // release the group bucket lock
        RELEASE_GROUP_LOCK(Group, "_MibGetInternalGroupIfsInfo");
        bGroupBucketLock = FALSE;


        // if GetMode==GETMODE_FIRST change it to GETMODE_NEXT.
        if (dwGetMode==GETMODE_FIRST) 
            dwGetMode = GETMODE_NEXT; 
            
    } //end for loop


    // check if group bucket lock has to be released
    if (bGroupBucketLock==TRUE) {
        RELEASE_GROUP_LOCK(Group, "_MibGetInternalGroupIfsInfo");
        bGroupBucketLock = FALSE;
    }
        
    if (pResponse!=NULL) {
        pResponse->Count = dwCount;
        pResponse->Flags |= IGMP_ENUM_FORMAT_IGMPV3;
    }

    
    //
    // set the actual size if some info was copied, else let size
    // remain
    //
    if (dwCount>0) 
        *pdwOutputSize = dwSize;
    else
        *pdwOutputSize = dwCurSize;
 


    Trace0(MIB, "Leaving _MibGetInternalGroupIfsInfo");
    return Error;
    
} //end _MibGetInternalGroupIfsInfo



//------------------------------------------------------------------------------
//          _MibGetInternalIfConfig
//
// no locks assumed. takes IfList lock
//------------------------------------------------------------------------------

DWORD
MibGetInternalIfConfig (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    )
{

    //
    // the interface config struct is variable size.
    // there may be multiple instances.
    //

    PIGMP_IF_TABLE          pTable = g_pIfTable;
    PIF_TABLE_ENTRY         pite;
    PIGMP_MIB_IF_CONFIG     pIfConfigDst;
    PIGMP_IF_CONFIG         pIfConfigSrc;
    DWORD                   dwCount, dwSize, dwSizeCur=0, Error = NO_ERROR;
    
        
    if (pResponse!=NULL) {
        pResponse->TypeId = IGMP_IF_CONFIG_ID; 
        
        pIfConfigDst = (PIGMP_MIB_IF_CONFIG)pResponse->Buffer;
    }

    // acquire IfLists lock so that you can access the interface lists
    ACQUIRE_IF_LIST_LOCK("MibGetInternalIfConfig");
    


    for (dwCount=0,dwSize=0;  dwCount<pQuery->Count;  ) {

        
        //
        // retrieve the interface whose config are to be read
        //

        pite = GetIfByListIndex(pQuery->IfIndex, dwGetMode, &Error);


        // I dont have to take the interface lock, as the IfLists lock is 
        // taken before interface config is changed or interface is deleted.
        //ACQUIRE_IF_LOCK_SHARED(IfIndex, "MibGetInternal");
        

        //
        // if the interface was not found, it may mean
        // the specified index was invalid, or it may mean
        // that the GETMODE_NEXT was called on the last interface
        // in which case ERROR_NO_MORE_ITEMS was returned.
        // In any case, we make sure Error indicates an error
        // and then return the value.
        //
        // if the interface was found but no output buffer was passed,
        // indicate in the error that memory needs to be allocated.
        //
        // otherwise, copy the config struct of the interface
        //

        if (pite == NULL) {
            if (dwCount>0) {
                Error = NO_ERROR;
            }
            // count==0
            else {
                if (Error == NO_ERROR)
                    Error = ERROR_INVALID_PARAMETER;
                *pdwOutputSize = 0;
            }

            break; //from for loop
        }

        pIfConfigSrc = &pite->Config;

        dwSizeCur = pIfConfigSrc->ExtSize;


        //
        // if no buffer was specified, indicate one should be allocated
        //        
        if (pResponse==NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }
        
        //
        // see if adequate buffer is left for the next struct
        //
        if (dwBufferSize < dwSize+dwSizeCur) {
            if (dwCount==0) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            }
            break;//from for loop
        }

        
        
        //
        // copy the interface config, and set the IP address
        //
        CopyoutIfConfig(pIfConfigDst, pite);

        pQuery->IfIndex = pite->IfIndex;
        pQuery->RasClientAddr = 0;
            
        dwCount++;
        dwSize += dwSizeCur;
        pIfConfigDst = (PIGMP_MIB_IF_CONFIG) (((PBYTE)pIfConfigDst)+ dwSizeCur);

        // if GetMode==GETMODE_FIRST change it to GETMODE_NEXT.
        if (dwGetMode==GETMODE_FIRST) 
            dwGetMode = GETMODE_NEXT; 

    }//end for loop

    //
    //set the actual size if some info was copied, else let size set earlier
    //remain
    //
    if (dwCount>0) {
        *pdwOutputSize = dwSize;
    } 
    else {
        *pdwOutputSize = dwSizeCur;
    }


    if (pResponse!=NULL)
        pResponse->Count = dwCount;
    
    
    RELEASE_IF_LIST_LOCK("_MibGetInternalIfConfig");

    Trace0(MIB, "Leaving _MibGetInternalIfConfig");
    return Error;

} //end _MibGetInternalIfConfig



//------------------------------------------------------------------------------
//              _MibGetInternalIfGroupsInfo
//
// Enumerates the list of GIs hanging from an interface
// Locks: no locks assumed.
//------------------------------------------------------------------------------
DWORD
MibGetInternalIfGroupsInfo (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    )
{
    LONGLONG                    llCurTime = GetCurrentIgmpTime();
    PIGMP_MIB_IF_GROUPS_LIST    pHeader;
    PMIB_GROUP_INFO_V3          pGroupInfo;
    PMIB_PROXY_GROUP_INFO_V3  pProxyGroupInfo;
    PGI_ENTRY                   pgie;
    PLIST_ENTRY                 pHead, ple;
    DWORD                       dwCurSize=0, Error=NO_ERROR, dwNumGroups, 
                                dwNumIfGroups, dwNumGroupsCopied, SizeofGroupEntry,
                                PrevQueryFlags = pQuery->Flags;
    PIF_TABLE_ENTRY             pite;
    PRAS_TABLE_ENTRY            prte;
    PRAS_TABLE                  prt;    
    BOOL                        bCopied, bProxy=FALSE, 
                                bRasClientEnum=FALSE, bRasServerEnum=FALSE, bRasIfLock=FALSE;
    DWORD                       lePrevGroup = NETWORK_TO_LITTLE_ENDIAN(pQuery->GroupAddr);
    USHORT                      PrevEnumSignature = pQuery->Signature;
    BOOL                        bEnumV3, bInsufficientBuffer=FALSE;


    //Trace3(MEM, "_MibGetInternalIfGroupsInfo buffer: %0x -> %0x: %d", 
    //(DWORD)pResponse->Buffer, ((DWORD)pResponse->Buffer)+dwBufferSize, dwBufferSize);//deldel
            
    Trace0(MIB, "Entering _MibGetInternalIfGroupsInfo()");

    bEnumV3 = PrevQueryFlags & IGMP_ENUM_SUPPORT_FORMAT_IGMPV3; 

    CLEAR_IGMP_ENUM_INTERFACE_TABLE_FLAGS(pQuery->Flags);


    if ( (PrevQueryFlags & IGMP_ENUM_INTERFACE_TABLE_END)
        && !(PrevQueryFlags & IGMP_ENUM_ALL_INTERFACES_GROUPS)
        && !(PrevQueryFlags & IGMP_ENUM_FOR_RAS_CLIENTS) )
    {

        pQuery->GroupAddr = 0;
        pQuery->Signature = 0;
        return ERROR_NO_MORE_ITEMS;
    }


    
    //
    // Initialize 
    //
    if (pResponse!=NULL) {
        pResponse->TypeId = IGMP_IF_GROUPS_LIST_ID;
        pHeader = (PIGMP_MIB_IF_GROUPS_LIST) pResponse->Buffer;
    }



    //
    // acquire IfLists lock so that the interfaces list can be accessed
    //
    ACQUIRE_IF_LIST_LOCK("_MibGetInternalIfGroupsInfo");
    

    //
    // retrieve the interface (and ras client)
    //

    if (PrevQueryFlags & IGMP_ENUM_FOR_RAS_CLIENTS) {

        if (pQuery->IfIndex==0)
            pQuery->IfIndex = g_RasIfIndex;

        Error = GetIfOrRasForEnum(pQuery, pResponse, dwGetMode,
                                        &pite, &prt, &prte, &bRasIfLock, 
                                        IGMP_ENUM_FOR_RAS_CLIENTS);
    }
    
    else if ( (PrevQueryFlags & IGMP_ENUM_INTERFACE_TABLE_CONTINUE) 
            || ((pQuery->IfIndex!=0)&&(pQuery->GroupAddr!=0)&&
                (!(PrevQueryFlags & IGMP_ENUM_INTERFACE_TABLE_END)) ) )
    {


        // continuing from the previous call. so get the same interface again.
        
        Error = GetIfOrRasForEnum(pQuery, pResponse, GETMODE_EXACT,
                                            &pite, &prt, &prte, &bRasIfLock, 0);


        // 
        // if the interface has meanwhile been deleted, then get the next interface
        // only if all interface group lists are  being enumerated.
        //
        if ( (pite==NULL) && (pQuery->Flags&IGMP_ENUM_ALL_INTERFACES_GROUPS) ) {
        
            // the interface was deleted. so I continue with the next interface
        
            Error = GetIfOrRasForEnum(pQuery, pResponse, GETMODE_NEXT,
                            &pite, &prt, &prte, &bRasIfLock, 0);
        

            if (pResponse) {
                pResponse->Flags |= IGMP_ENUM_INTERFACE_TABLE_BEGIN;
                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_BEGIN;
            }
        }
            
    }

    else {

        // enumerating a new interface
        
        Error = GetIfOrRasForEnum(pQuery, pResponse, dwGetMode,
                            &pite, &prt, &prte, &bRasIfLock, 0);

        if (pResponse) {
            pResponse->Flags |= IGMP_ENUM_INTERFACE_TABLE_BEGIN;
            pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_BEGIN;
        }
    }

    
    //
    // The required interface or the next interface not found. Return error.
    //
    if (pite == NULL) {

        //
        // GetIfOrRasForEnum returns no_error if there are no interfaces.
        // but I will return invalid_parameter
        //
        if (Error == NO_ERROR)
            Error = ERROR_INVALID_PARAMETER;
            
        *pdwOutputSize = 0;

        if (pResponse)
            pResponse->Count = 0;

        RELEASE_IF_LIST_LOCK("_MibGetInternalIfGroupsInfo");

        Trace1(MIB, "Leaving _MibGetInternalIfGroupsInfo(%d)", Error);
        return Error;
    }


    //
    // get the shared interface lock so that its fields can no longer be
    // changed. As IF_LISTS lock is taken, the inteface state cannot get changed
    //
    if (!bRasIfLock)
        ACQUIRE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfGroupsInfo");

    ACQUIRE_ENUM_LOCK_EXCLUSIVE("_MibGetInternalIfGroupsInfo");

    bRasClientEnum = prte != NULL;
    bRasServerEnum = IS_RAS_SERVER_IF(pite->IfType) && !bRasClientEnum;
    bEnumV3 = bEnumV3 && (IS_PROTOCOL_TYPE_IGMPV3(pite)||IS_PROTOCOL_TYPE_PROXY(pite));

    ACQUIRE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_MibGetInternalIfGroupsInfo");
    
    BEGIN_BREAKOUT_BLOCK1 {

        bProxy = IS_PROTOCOL_TYPE_PROXY(pite);


        // set size for groupEntry

        SizeofGroupEntry = (bProxy)
                            ? (bEnumV3?sizeof(MIB_PROXY_GROUP_INFO_V3):sizeof(MIB_PROXY_GROUP_INFO))
                            : (bEnumV3?sizeof(MIB_GROUP_INFO_V3):sizeof(IGMP_MIB_GROUP_INFO));


        
        //
        // if no buffer passed or buffer less than that required for 1 group entry, 
        // set the required buffer size to MIB_DEFAULT_BUFFER_SIZE and break.
        //

        if (bEnumV3 && bRasClientEnum)
        {
            DWORD RequiredSize = sizeof(IGMP_MIB_IF_GROUPS_LIST);
            pHead = &prte->ListOfSameClientGroups;

            for (ple = pHead->Flink;  (ple!=pHead);  
                    ple=ple->Flink) 
            {
                DWORD       V3SourcesSize, V3NumSources;
                
                pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameClientGroups);

                V3NumSources = pgie->NumSources + ListLength(&pgie->V3ExclusionList);
                V3SourcesSize = sizeof(IGMP_MIB_GROUP_SOURCE_INFO_V3)*V3NumSources;

                RequiredSize += SizeofGroupEntry+V3SourcesSize;
            }
            RequiredSize += 300;

            if ((pResponse==NULL) || dwBufferSize<RequiredSize)
            {
                Error = ERROR_INSUFFICIENT_BUFFER;
                dwCurSize = RequiredSize;
                bCopied = FALSE;
                bInsufficientBuffer = TRUE;
                GOTO_END_BLOCK1;
            }
        }
        
        if ( (pResponse==NULL) 
            || (!bEnumV3 && !bRasClientEnum&&
                (dwBufferSize < sizeof(IGMP_MIB_IF_GROUPS_LIST) + SizeofGroupEntry))
            || (!bEnumV3 && bRasClientEnum
                &&(dwBufferSize<sizeof(IGMP_MIB_IF_GROUPS_LIST) 
                    + SizeofGroupEntry*prte->Info.CurrentGroupMemberships) ) 
            || (bEnumV3 && (dwBufferSize<MIB_DEFAULT_BUFFER_SIZE)) )
        {
        
            Error = ERROR_INSUFFICIENT_BUFFER;

            if (bEnumV3) {
                dwCurSize = MIB_DEFAULT_BUFFER_SIZE;
            }
            else {
                dwCurSize = (pQuery->Flags&IGMP_ENUM_ONE_ENTRY) 
                        ? sizeof(IGMP_MIB_IF_GROUPS_LIST) + sizeof(IGMP_MIB_GROUP_INFO)
                        : bRasClientEnum
                            ? sizeof(IGMP_MIB_IF_GROUPS_LIST) 
                                 + SizeofGroupEntry*(prte->Info.CurrentGroupMemberships+5)
                            : MIB_DEFAULT_BUFFER_SIZE;
            }
            
            // dont change pQuery->GroupAddr
            bCopied = FALSE;
            bInsufficientBuffer = TRUE;
            GOTO_END_BLOCK1;
        }



        //
        // set dwNumIfGroups
        //
        if (!IS_IF_ACTIVATED(pite)) {
            dwNumIfGroups = 0;
        }    
        
        else {
        
            if (bProxy) {
                dwNumIfGroups = pite->Info.CurrentGroupMemberships;
            }    
            
            //
            // if no ras client stats (if flag not set in the query, or ras
            // stats not being kept).
            //
            else if ( bRasClientEnum && !g_Config.RasClientStats )
            {
                dwNumIfGroups = 0;
            }

            else {
                dwNumIfGroups = (bRasClientEnum)
                                ? prte->Info.CurrentGroupMemberships
                                : pite->Info.CurrentGroupMemberships;
            }
        }
        

        
        //
        // calculate how many group entries will fit in the buffer left.
        // dwNumGroups cannot be greater than dwNumIfGroups and 
        // enumerate only 1 group if IGMP_ENUM_ONE_ENTRY flag set.
        //

        // note: dwNumGroups can be 0, only if dwNumIfGroups is 0

       
        dwNumGroups = bEnumV3? 100
                      : (dwBufferSize - sizeof(IGMP_MIB_IF_GROUPS_LIST)) 
                        / SizeofGroupEntry;

        dwNumGroups = MIN(dwNumIfGroups, dwNumGroups);

        if (pQuery->Flags&IGMP_ENUM_ONE_ENTRY)
            dwNumGroups = MIN(dwNumGroups, 1);

        

        // initialize size required for this interface groups
        
        dwCurSize = sizeof(IGMP_MIB_IF_GROUPS_LIST);



        // 
        // set fields in the Interface header that will be returned to the caller
        //
        
        pHeader->IfIndex = pite->IfIndex;

        if (bRasClientEnum) {
            pHeader->IpAddr = prte->NHAddr;
            pHeader->IfType = IGMP_IF_RAS_CLIENT;        
        }
        else {
            pHeader->IpAddr = pite->IpAddr;
            pHeader->IfType = GET_EXTERNAL_IF_TYPE(pite);
            
        }
        


        //
        // set fields in pQuery
        //
        
        pQuery->IfIndex = pite->IfIndex;
        pQuery->RasClientAddr = (bRasClientEnum) ? prte->NHAddr : 0;



        //
        // if not activated, just copy the interface header and return with 0 groups
        //
        
        if (!IS_IF_ACTIVATED(pite)) {
        
            dwNumGroupsCopied = 0;
    
            // set pQuery fields
            pQuery->GroupAddr = 0;
            pQuery->Flags |= (IGMP_ENUM_INTERFACE_TABLE_BEGIN
                             | IGMP_ENUM_INTERFACE_TABLE_END);
            pResponse->Flags |= (IGMP_ENUM_INTERFACE_TABLE_BEGIN
                             | IGMP_ENUM_INTERFACE_TABLE_END);

            // set interface header fields
            pHeader->NumGroups = 0;

            dwCurSize = sizeof(IGMP_MIB_IF_GROUPS_LIST);
            bCopied = TRUE;
            GOTO_END_BLOCK1;
        }


        ple = NULL;

        //--------------------------------------------------
        // if interface not proxy, then copy the group info.
        //---------------------------------------------------
        if (!bProxy) {

            pGroupInfo = (PMIB_GROUP_INFO_V3)(pHeader->Buffer);


            // merge the lists if this interface is being enumerated for the first time.
            if (lePrevGroup==0)
                MergeIfGroupsLists(pite);
                
            
            pHead = (bRasClientEnum) ? &prte->ListOfSameClientGroups  
                                 : &pite->ListOfSameIfGroups;



            // if continuing enumeration, then walk down to the next group
            // ras client wont get into this block
            
            if (lePrevGroup!=0)  {

                //
                // get next entry from where we left off last time
                //
                if ( (PrevEnumSignature==pite->PrevIfGroupEnumSignature)
                    && (PrevEnumSignature!=0) ){

                    // had reached end of enumeration
                    if (pite->pPrevIfGroupEnumPtr==NULL)
                        dwNumGroups = 0;

                    else 
                        ple = &((PGI_ENTRY)pite->pPrevIfGroupEnumPtr)->LinkBySameIfGroups;
                    
                }

                //
                // get next entry by searching through the list
                //
                else {

                    for (ple=pHead->Flink;  (ple!=pHead); ple=ple->Flink) {
                        pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);
                        if (lePrevGroup<pgie->pGroupTableEntry->GroupLittleEndian)
                            break;
                    }
                }
            }

            //
            // starting enumeration from the beginning of the list
            //
            else {
                ple = pHead->Flink;
            }

            

            // 
            // finally copy the groups(!proxy)
            //
            
            dwNumGroupsCopied = 0;
            for ( ;  (ple!=pHead)&&(dwNumGroupsCopied<dwNumGroups);  
                    ple=ple->Flink,dwNumGroupsCopied++) 
            {
                PLIST_ENTRY pleNext;
                DWORD       LastReporter, GroupUpTime, GroupExpiryTime;
                DWORD       V3SourcesSize=0;
                DWORD       IncrementSize=0, V3NumSources=0;
                
                pgie = bRasClientEnum
                            ? CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameClientGroups)
                            : CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);

                if (bEnumV3){
                    V3NumSources = pgie->NumSources + ListLength(&pgie->V3ExclusionList);
                    V3SourcesSize = sizeof(IGMP_MIB_GROUP_SOURCE_INFO_V3)*V3NumSources;
                }

                IncrementSize = SizeofGroupEntry+V3SourcesSize;
                
                if (dwCurSize+IncrementSize > dwBufferSize){
                    if (dwNumGroupsCopied==0) {
                        dwCurSize += IncrementSize;
                        bCopied = FALSE;
                        bInsufficientBuffer = TRUE;
                    }
                    break;
                }



                dwCurSize += IncrementSize;
                
                pGroupInfo->GroupAddr = pgie->pGroupTableEntry->Group;
                pGroupInfo->IpAddr = pgie->pIfTableEntry->IpAddr;

                GroupUpTime = SYSTEM_TIME_TO_SEC(llCurTime-pgie->Info.GroupUpTime);
                GroupExpiryTime = (pgie->Info.GroupExpiryTime==~0)
                                ? ~0
                                : SYSTEM_TIME_TO_SEC(pgie->Info.GroupExpiryTime-llCurTime);
                LastReporter = pgie->Info.LastReporter;

                
                if (bRasServerEnum) {

                    DWORD GroupExpiryTimeTmp;
                    PGI_ENTRY   pgieNext;

                    for (pleNext=ple->Flink; pleNext!=pHead;  pleNext=pleNext->Flink) {
                    
                        pgieNext = CONTAINING_RECORD(pleNext, GI_ENTRY, LinkBySameIfGroups);
                        
                        if (pgieNext->pGroupTableEntry->Group != pgie->pGroupTableEntry->Group)
                            break;
                            
                        GroupUpTime = MAX(GroupUpTime, 
                                        SYSTEM_TIME_TO_SEC(llCurTime-pgieNext->Info.GroupUpTime));
                        GroupExpiryTimeTmp = (pgieNext->Info.GroupExpiryTime==~0)
                                        ? ~0
                                        : SYSTEM_TIME_TO_SEC(pgieNext->Info.GroupExpiryTime-llCurTime);
                        if (GroupExpiryTimeTmp > GroupExpiryTime) {
                            GroupExpiryTime = GroupExpiryTimeTmp;
                            LastReporter = pgieNext->Info.LastReporter;
                        }
                    }

                    ple = pleNext->Blink;
                }
                
                pGroupInfo->GroupUpTime = GroupUpTime;
                pGroupInfo->GroupExpiryTime = GroupExpiryTime;
                pGroupInfo->LastReporter = LastReporter;

                if ( (llCurTime>=pgie->Info.V1HostPresentTimeLeft) || bRasServerEnum)
                    pGroupInfo->V1HostPresentTimeLeft = 0;
                else {
                    pGroupInfo->V1HostPresentTimeLeft = 
                            SYSTEM_TIME_TO_SEC(pgie->Info.V1HostPresentTimeLeft-llCurTime);
                }
                if ( (llCurTime>=pgie->Info.V2HostPresentTimeLeft) || bRasServerEnum)
                    pGroupInfo->V2HostPresentTimeLeft = 0;
                else {
                    pGroupInfo->V2HostPresentTimeLeft = 
                            SYSTEM_TIME_TO_SEC(pgie->Info.V2HostPresentTimeLeft-llCurTime);
                }

                pGroupInfo->Flags = 0;
                if ( (pgie->bStaticGroup) && (!bRasServerEnum) )
                    pGroupInfo->Flags |= IGMP_GROUP_TYPE_STATIC;
                if ( (pgie->GroupMembershipTimer.Status&TIMER_STATUS_ACTIVE) || (bRasServerEnum) )
                    pGroupInfo->Flags |= IGMP_GROUP_TYPE_NON_STATIC;
                if (CAN_ADD_GROUPS_TO_MGM(pite))
                    pGroupInfo->Flags |= IGMP_GROUP_FWD_TO_MGM;


                if (bEnumV3) {

                    PGI_SOURCE_ENTRY pSourceEntry;
                    DWORD i=0;
                    PLIST_ENTRY pHeadSrc, pLESrc;
                    
                    pGroupInfo->Version = pgie->Version;
                    pGroupInfo->Size = sizeof(MIB_GROUP_INFO_V3) + V3SourcesSize;
                    pGroupInfo->FilterType = pgie->FilterType;
                    pGroupInfo->NumSources = V3NumSources;

                    pHeadSrc = &pgie->V3InclusionListSorted;
                    for (pLESrc=pHeadSrc->Flink;  pLESrc!=pHeadSrc;  pLESrc=pLESrc->Flink,i++) {

                        
                        pSourceEntry = CONTAINING_RECORD(pLESrc, GI_SOURCE_ENTRY,
                                            LinkSourcesInclListSorted);
                        pGroupInfo->Sources[i].Source = pSourceEntry->IpAddr;

                        //kslksl
                        ASSERT(pGroupInfo->Sources[i].Source !=0);
                            
                        pGroupInfo->Sources[i].SourceExpiryTime
                                = (pSourceEntry->bInclusionList)
                                ? QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                                : ~0;
                            
                        pGroupInfo->Sources[i].SourceUpTime
                            = (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000;
                    }
                    
                    pHeadSrc = &pgie->V3ExclusionList;
                    for (pLESrc=pHeadSrc->Flink;  pLESrc!=pHeadSrc;  pLESrc=pLESrc->Flink,i++) {

                        pSourceEntry = CONTAINING_RECORD(pLESrc, GI_SOURCE_ENTRY, LinkSources);
                        pGroupInfo->Sources[i].Source = pSourceEntry->IpAddr;

                        pGroupInfo->Sources[i].SourceExpiryTime
                                = (pSourceEntry->bInclusionList)
                                ? QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                                : ~0;
                            
                        pGroupInfo->Sources[i].SourceUpTime
                            = (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000;
                    }
                    
                    pGroupInfo = (PMIB_GROUP_INFO_V3)
                                 ((PCHAR)pGroupInfo + pGroupInfo->Size);
                }
                else
                    pGroupInfo = (PMIB_GROUP_INFO_V3)((PMIB_GROUP_INFO)pGroupInfo + 1);

                //Trace1(MEM, "NextpGroupInfo:%0x", (DWORD)pGroupInfo);//deldel
            }



            //
            // if reached the end of the group list or the group list is empty
            //
            if (((ple==pHead&&dwNumGroupsCopied!=0) || (dwNumIfGroups==0)||(dwNumGroups==0))
                &&!bInsufficientBuffer && !bRasClientEnum)
            {

                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_END;
                pQuery->GroupAddr = 0;

    
                // reset pointers for next enumeration
                pite->pPrevIfGroupEnumPtr = NULL;
                pite->PrevIfGroupEnumSignature = 0;
            }
            
            //
            // else have more GI entries to enumerate
            //
            else if (!bRasClientEnum) {
                
                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_CONTINUE;

                if (ple!=pHead) {

                    PGI_ENTRY   pgieNext;
                    
                    // get the next entry from which enum should continue
                    pgieNext = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);
                
                
                    // update pQuery->GroupAddr
                    pQuery->GroupAddr = pgieNext->pGroupTableEntry->Group;


                    // update pointers for next enumeration
                    pite->pPrevIfGroupEnumPtr  = pgieNext;
                }
                else {
                    pQuery->GroupAddr = 0xffffffff;
                    pite->pPrevIfGroupEnumPtr  = NULL;
                }

                
                pite->PrevIfGroupEnumSignature = GET_NEXT_SIGNATURE();

                SET_SIGNATURE(pQuery->Signature, pite->PrevIfGroupEnumSignature);

            }
        }


        //--------------------------
        // proxy interface
        //--------------------------
        else {
            PPROXY_GROUP_ENTRY  pProxyEntry;
            PLIST_ENTRY pHeadSrc, pleSrc;
            DWORD SrcCnt;
            PPROXY_SOURCE_ENTRY pSourceEntry;

            pProxyGroupInfo = (PMIB_PROXY_GROUP_INFO_V3)(pHeader->Buffer);


            // merge the lists if this interface is being enumerated for the first time.
            if (lePrevGroup==0)
                MergeProxyLists(pite);
                
            
            pHead = &pite->ListOfSameIfGroups;

            

            // if continuing enumeration, then walk down to the next group
            
            if (lePrevGroup!=0)  {

                //
                // get next entry from where we left off last time
                //
                if ( (PrevEnumSignature==pite->PrevIfGroupEnumSignature)
                    && (PrevEnumSignature!=0) )
                {

                    // had reached end of enumeration
                    if (pite->pPrevIfGroupEnumPtr==NULL)
                        dwNumGroups = 0;

                    else 
                        ple = &((PPROXY_GROUP_ENTRY)pite->pPrevIfGroupEnumPtr)->LinkBySameIfGroups;
                    
                }

                //
                // get next entry by searching through the list
                //
                else {

                    for (ple=pHead->Flink;  (ple!=pHead); ple=ple->Flink) {
                        pProxyEntry = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, 
                                                        LinkBySameIfGroups);
                        if (lePrevGroup<pProxyEntry->GroupLittleEndian)
                            break;
                    }
                }
            }

            //
            // starting enumeration from the beginning of the list
            //
            else {
                ple = pHead->Flink;
            }

            

            // 
            // finally copy the groups
            //
            
            dwNumGroupsCopied = 0;
            for ( ;  (ple!=pHead)&&(dwNumGroupsCopied<dwNumGroups);  
                    ple=ple->Flink,dwNumGroupsCopied++) 
            {
                DWORD V3SourcesSize=0, IncrementSize;
                
                pProxyEntry= CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, 
                                                LinkBySameIfGroups);


                if (bEnumV3){
                    V3SourcesSize
                        = pProxyEntry->NumSources*sizeof(IGMP_MIB_GROUP_SOURCE_INFO_V3);
                }

                IncrementSize = SizeofGroupEntry+V3SourcesSize;
                
                if (dwCurSize+IncrementSize > dwBufferSize){
                    if (dwNumGroupsCopied==0) {
                        dwCurSize += IncrementSize;
                        bCopied = FALSE;
                        bInsufficientBuffer = TRUE;
                    }
                    break;
                }



                dwCurSize += IncrementSize;

                
                pProxyGroupInfo->GroupAddr = pProxyEntry->Group;
                pProxyGroupInfo->GroupUpTime
                         = SYSTEM_TIME_TO_SEC(llCurTime-pProxyEntry->InitTime);

                pProxyGroupInfo->Flags = 0;
                if (pProxyEntry->bStaticGroup) {
                    pProxyGroupInfo->Flags |= IGMP_GROUP_TYPE_STATIC;
                    if (pProxyEntry->RefCount>0)
                        pProxyGroupInfo->Flags |= IGMP_GROUP_TYPE_NON_STATIC;
                }
                else {
                    pProxyGroupInfo->Flags |= IGMP_GROUP_TYPE_NON_STATIC;
                }

                if (!bEnumV3) {
                    pProxyGroupInfo = (PMIB_PROXY_GROUP_INFO_V3)
                        ((PMIB_PROXY_GROUP_INFO)pProxyGroupInfo+1);
                }
                else {

                    //kslksl
/*                    PLIST_ENTRY pHeadSrc, pleSrc;
                    DWORD SrcCnt;
                    PPROXY_SOURCE_ENTRY pSourceEntry;
*/

                    pProxyGroupInfo->NumSources = pProxyEntry->NumSources;
                    pProxyGroupInfo->Size = IncrementSize; 

                    pHeadSrc = &pProxyEntry->ListSources;
                    for (pleSrc=pHeadSrc->Flink,SrcCnt=0;  pleSrc!=pHeadSrc; 
                            pleSrc=pleSrc->Flink,SrcCnt++) 
                    {

                        pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                            PROXY_SOURCE_ENTRY, LinkSources);
                        pProxyGroupInfo->Sources[SrcCnt].Source
                                = pSourceEntry->IpAddr;
                        pProxyGroupInfo->Sources[SrcCnt].Flags = pSourceEntry->JoinMode;
                        pProxyGroupInfo->Sources[SrcCnt].Flags += 
                                            (pSourceEntry->JoinModeIntended<<4);

                    }

                    
                    pProxyGroupInfo = (PMIB_PROXY_GROUP_INFO_V3)
                        &pProxyGroupInfo->Sources[pProxyGroupInfo->NumSources];
                    //Trace1(MEM, "next proxy: %0x:", (DWORD)pProxyGroupInfo);//deldel
                }
            }//copy all sources



            //
            // if reached the end of the group list or the group list is empty
            //
            if ( ((ple==pHead&&dwNumGroupsCopied!=0)||(dwNumIfGroups==0)||(dwNumGroups==0))
                && !bInsufficientBuffer)
                //||(ple->Flink==pHead))  
            {

                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_END;
                pQuery->GroupAddr = 0;

    
                // reset pointers for next enumeration
                pite->pPrevIfGroupEnumPtr = NULL;
                pite->PrevIfGroupEnumSignature = 0;
            }
            
            //
            // else have more GI entries to enumerate
            //
            else {
                PPROXY_GROUP_ENTRY   pProxyNext;

                
                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_CONTINUE;


                if (ple!=pHead) {
                    // get the next entry from which enum should continue
                    pProxyNext = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, 
                                                    LinkBySameIfGroups);
                    
                    
                    // update pQuery->GroupAddr
                    pQuery->GroupAddr = pProxyNext->Group;


                    // update pointers for next enumeration
                    pite->pPrevIfGroupEnumPtr  = pProxyNext;
                    
                }
                else {
                    pQuery->GroupAddr = 0xffffffff;
                    pite->pPrevIfGroupEnumPtr = NULL;
                }

                pite->PrevIfGroupEnumSignature = GET_NEXT_SIGNATURE();

                SET_SIGNATURE(pQuery->Signature, pite->PrevIfGroupEnumSignature);
            }

        } //end proxy interface



        //
        // if only one interface is being enumerated, and the number of groups being
        // enumerated is 0 inspite of adequate buffer, then return NO_MORE_ITEMS
        //
        
        if ( !bInsufficientBuffer && (dwNumGroupsCopied==0)
            &&(!(pQuery->Flags&IGMP_ENUM_ALL_INTERFACES_GROUPS)) ) 
        {
        
            pQuery->GroupAddr = 0;
            Error = ERROR_NO_MORE_ITEMS;
        }    
            
        if (!bInsufficientBuffer)
            bCopied = TRUE;

        
    } END_BREAKOUT_BLOCK1; // inside shared interface lock.

    // release the shared interface lock

    RELEASE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_MibGetInternalIfGroupsInfo");
    RELEASE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfGroupsInfo");
    RELEASE_ENUM_LOCK_EXCLUSIVE("_MibGetInternalIfGroupsInfo");


    if (pResponse!=NULL) {

        pResponse->Count = (bCopied) ? 1 : 0;

        if (bCopied)
            pHeader->NumGroups = dwNumGroupsCopied;
        if (bEnumV3)
            pResponse->Flags |= IGMP_ENUM_FORMAT_IGMPV3;
    }        

    if (bInsufficientBuffer)
        pQuery->Flags |= PrevQueryFlags;


        
    //
    //set the actual size if some info was copied, else let size
    //remain
    //
    *pdwOutputSize = dwCurSize;
    

    RELEASE_IF_LIST_LOCK("_MibGetInternalIfGroupsInfo");


    Trace0(MIB, "Leaving _MibGetInternalIfGroupsInfo()");
    return Error;
    
} //end _MibGetInternalIfGroupsInfo
    
   

//------------------------------------------------------------------------------
//              MibGetInternalIfStats
//------------------------------------------------------------------------------
DWORD
MibGetInternalIfStats (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    ) 
{
    DWORD               Error = NO_ERROR, dwCount, dwSize;
    PIGMP_IF_TABLE      pTable = g_pIfTable;
    PIF_TABLE_ENTRY     pite;
    PRAS_TABLE_ENTRY    prte;
    PRAS_TABLE          prt;
    PIGMP_MIB_IF_STATS  pStatsDst;
    PIF_INFO            pIfStatsSrc;
    LONGLONG            llCurTime = GetCurrentIgmpTime();
    BOOL                bDone, bCopied, bRasIfLock=FALSE;
    
    

    Trace0(MIB, "Entering _MibGetInternalIfStats()");

    
    *pdwOutputSize = pQuery->Count*sizeof(IGMP_MIB_IF_STATS);
                     

    //
    // the interface statistics struct is fixed-length.
    // there may be multiple instances.
    //

    if (pResponse!=NULL) {    
        pResponse->TypeId = IGMP_IF_STATS_ID; 
        pStatsDst = (PIGMP_MIB_IF_STATS) pResponse->Buffer;
    }
    

    // acquire IfLists lock so that the interfaces list can be accessed
    ACQUIRE_IF_LIST_LOCK("_MibGetInternalIfStats");


    for (dwCount=0, dwSize=0;  dwCount<pQuery->Count;  ) {

        //
        // retrieve the interface. If the ras flag was set and ras statistics
        // are kept, then ras client statistics are also returned.
        // If no more relevant structures, then return ERROR_NO_MORE_ITEMS.
        //

        //
        // the pResponse IfIndex,RasClientAddr fields are updated appropriately.
        // if a lock is acquired on the ras table, then bRasIfLock is set to
        // TRUE;
        //

        Error = GetIfOrRasForEnum(pQuery, pResponse, dwGetMode, 
                                    &pite, &prt, &prte, &bRasIfLock, 0);

        if (pite == NULL) {
            if (dwCount>0) {
                Error = NO_ERROR;
            }
            // count==0
            else {
                if (Error == NO_ERROR)
                    Error = ERROR_INVALID_PARAMETER;
                *pdwOutputSize = 0;
            }
            break; //from for loop
        }


        //
        // if no buffer was specified, indicate one should be allocated
        // the required buffer size has already been set.
        //
        if (pResponse==NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        
        //
        // acquire IfLists locks so that interfaces list cannot be changed
        //
        if (!bRasIfLock)
            ACQUIRE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfStats");

        
        BEGIN_BREAKOUT_BLOCK1 {
            //
            // if the buffer is not large enough, break from the loop
            //

            if (dwBufferSize < dwSize+sizeof(IGMP_MIB_IF_STATS)) {
                if (dwCount==0)
                    Error = ERROR_INSUFFICIENT_BUFFER;

                bDone = TRUE;
                bCopied = FALSE;
                GOTO_END_BLOCK1;
            }

            

            
            //
            // copy the interface stats. Copy field by field as access to this 
            // structure is not synchronized
            //

            //
            // copy interface stats
            //
            if (prte==NULL) {

                pIfStatsSrc = &pite->Info;

                if (!IS_IF_ACTIVATED(pite))
                    ZeroMemory(pStatsDst, sizeof(*pStatsDst));
                    

                //
                //copy if index, addr
                //
                pStatsDst->IfIndex = pite->IfIndex;
                pStatsDst->IpAddr = pite->IpAddr;
                pStatsDst->IfType = GET_EXTERNAL_IF_TYPE(pite);
                GET_EXTERNAL_IF_STATE(pite, pStatsDst->State);

                
                pQuery->IfIndex = pite->IfIndex;
                pQuery->RasClientAddr = 0;
                

                pStatsDst->IgmpProtocolType =
                        pite->Config.IgmpProtocolType;
                        
                //
                // if this interface is not activated, then continue from the
                // next one
                //
                if (!IS_IF_ACTIVATED(pite)) {
                    bDone = FALSE; bCopied = TRUE;
                    GOTO_END_BLOCK1;
                }

                
                pStatsDst->QuerierState = pIfStatsSrc->QuerierState;
                

                pStatsDst->QuerierIpAddr =
                        pIfStatsSrc->QuerierIpAddr;

                pStatsDst->ProxyIfIndex = g_ProxyIfIndex;

                
                //if I am the querier set to 0 
                pStatsDst->QuerierPresentTimeLeft = IS_QUERIER(pite) ?
                        0 :
                        SYSTEM_TIME_TO_SEC(pIfStatsSrc->QuerierPresentTimeout - llCurTime);

                pStatsDst->LastQuerierChangeTime
                        = SYSTEM_TIME_TO_SEC(llCurTime - pIfStatsSrc->LastQuerierChangeTime);

                pStatsDst->V1QuerierPresentTimeLeft = 
                    (IS_IF_VER2(pite) && (pIfStatsSrc->V1QuerierPresentTime > llCurTime))
                    ? SYSTEM_TIME_TO_SEC(pIfStatsSrc->V1QuerierPresentTime - llCurTime)
                    : 0;

                {
                    LARGE_INTEGER liUptime;
                    liUptime.QuadPart = (llCurTime-pIfStatsSrc->TimeWhenActivated)/1000;
                    pStatsDst->Uptime = liUptime.LowPart;
                }
                
                pStatsDst->TotalIgmpPacketsReceived
                        = pIfStatsSrc->TotalIgmpPacketsReceived;
                pStatsDst->TotalIgmpPacketsForRouter
                        = pIfStatsSrc->TotalIgmpPacketsForRouter;
                pStatsDst->GeneralQueriesReceived
                        = pIfStatsSrc->GenQueriesReceived;
                pStatsDst->WrongVersionQueries
                        = pIfStatsSrc->WrongVersionQueries;
                pStatsDst->JoinsReceived 
                        = pIfStatsSrc->JoinsReceived;
                pStatsDst->LeavesReceived
                        = pIfStatsSrc->LeavesReceived;
                pStatsDst->CurrentGroupMemberships
                        = pIfStatsSrc->CurrentGroupMemberships;
                pStatsDst->GroupMembershipsAdded
                        = pIfStatsSrc->GroupMembershipsAdded;
                pStatsDst->WrongChecksumPackets 
                        = pIfStatsSrc->WrongChecksumPackets;
                pStatsDst->ShortPacketsReceived
                        = pIfStatsSrc->ShortPacketsReceived;
                pStatsDst->LongPacketsReceived
                        = pIfStatsSrc->LongPacketsReceived;
                pStatsDst->PacketsWithoutRtrAlert
                        = pIfStatsSrc->PacketsWithoutRtrAlert;
            }


            //
            // copy ras client statistics
            //
            else {

                ZeroMemory(pStatsDst, sizeof(*pStatsDst));

                pStatsDst->IfIndex = pite->IfIndex;
                pStatsDst->IpAddr = pite->IpAddr;
                pStatsDst->IfType = IGMP_IF_RAS_CLIENT;
                GET_EXTERNAL_IF_STATE(pite, pStatsDst->State);
 
                pQuery->IfIndex = pite->IfIndex;
                pQuery->RasClientAddr = prte->NHAddr;


                //
                // if this interface is not activated, then continue from the
                // next one
                //
                if (!IS_IF_ACTIVATED(pite)) {
                    bDone = FALSE; bCopied = TRUE;
                    GOTO_END_BLOCK1;
                }
                
                    
                pStatsDst-> TotalIgmpPacketsReceived
                        = prte->Info.TotalIgmpPacketsReceived;
                pStatsDst->TotalIgmpPacketsForRouter
                        = prte->Info.TotalIgmpPacketsForRouter;
                pStatsDst->GeneralQueriesReceived
                        = prte->Info.GenQueriesReceived;
                pStatsDst->JoinsReceived 
                        = prte->Info.JoinsReceived;
                pStatsDst->LeavesReceived
                        = prte->Info.LeavesReceived;
                pStatsDst->CurrentGroupMemberships
                        = prte->Info.CurrentGroupMemberships;
                pStatsDst->GroupMembershipsAdded
                        = prte->Info.GroupMembershipsAdded;
                pStatsDst->WrongChecksumPackets 
                        = prte->Info.WrongChecksumPackets;
                pStatsDst->ShortPacketsReceived
                        = prte->Info.ShortPacketsReceived;
                pStatsDst->LongPacketsReceived
                        = prte->Info.LongPacketsReceived;
            }

            bCopied = TRUE;

            bDone = FALSE;
            
        } END_BREAKOUT_BLOCK1;

        RELEASE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfStats");
        bRasIfLock = FALSE;

        
        if (bCopied) {
            //
            // everything fine. Copied one more stats struct
            //
            dwCount++;
            dwSize += sizeof(IGMP_MIB_IF_STATS);
            pStatsDst++;
        }

        
        // if current mode is get first, then change it to get next
        if (dwGetMode==GETMODE_FIRST)
            dwGetMode = GETMODE_NEXT;


                
        if (bDone)
            break;

    }//end for loop

    if (pResponse!=NULL)
        pResponse->Count = dwCount;

    //
    //set the actual size if some info was copied, else let size set earlier
    //remain
    //
    if (dwCount>0) {
        *pdwOutputSize = dwSize;
    }
        
        
    // release interface lock

    if (bRasIfLock && pite)
        RELEASE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfStats");
        
    RELEASE_IF_LIST_LOCK("_MibGetInternalIfStats");


    Trace0(MIB, "Leaving _MibGetInternalIfStats()");
    return Error;
    
} //end _MibGetInternalIfStats



//------------------------------------------------------------------------------
//      GetIfOrRasForEnum
// First gets the required interface. If ras stats enabled and asked,
// then gets the ras client.
//
// Locks On return:
//      if *bRasTableLock==TRUE then this procedure has taken read lock on the
//      ras table and has not released it.
//      Assumes shared interface lock.
//------------------------------------------------------------------------------

DWORD
GetIfOrRasForEnum(
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    DWORD                       dwGetMode,
    PIF_TABLE_ENTRY             *ppite,
    PRAS_TABLE                  *pprt,
    PRAS_TABLE_ENTRY            *pprte,  // on return set to null if no ras stats
    BOOL                        *bRasIfLock,
    DWORD                       dwEnumForRasClients
    )
{
    DWORD  Error = NO_ERROR, 
           bRasClientsEnum = dwEnumForRasClients & IGMP_ENUM_FOR_RAS_CLIENTS;


    *ppite = NULL;
    *pprt = NULL;
    *pprte = NULL;

    
    //
    // get the interface depending on the mode
    //
    if (bRasClientsEnum)
        *ppite = GetIfByListIndex(pQuery->IfIndex, GETMODE_EXACT, &Error);
    else
        *ppite = GetIfByListIndex(pQuery->IfIndex, dwGetMode, &Error);

    //
    // return if valid interface could not be found or not rasClient
    //
    if ( (*ppite==NULL) || (Error!=NO_ERROR) || !bRasClientsEnum)
        return Error;
    
    //
    // do ras client processing
    //
    
    BEGIN_BREAKOUT_BLOCK1 {


        ACQUIRE_IF_LOCK_SHARED((*ppite)->IfIndex, "_GetIfOrRasForEnum");
        *bRasIfLock = TRUE;

        //
        // current interface not ras server interface. So done.
        //
        if (!IS_RAS_SERVER_IF((*ppite)->IfType))
            GOTO_END_BLOCK1;
        
        //
        // no ras client stats (if flag not set in the query, or ras
        // stats not being kept). So done.
        //
        if ( !bRasClientsEnum || !g_Config.RasClientStats )
        {
            GOTO_END_BLOCK1;
        }


        //
        // if mode: GETMODE_EXACT: then search for the ras client.
        // if ras client not found, then I set the interface to null
        //
        if (dwGetMode==GETMODE_EXACT) {

            // if pQuery->RasClientAddr==0, then he is not asking for ras client
            // So done.

            if (pQuery->RasClientAddr==0)
                GOTO_END_BLOCK1;

                        
            *pprte = GetRasClientByAddr(pQuery->RasClientAddr, 
                                        (*ppite)->pRasTable);

            //                          
            // if ras client not found in GETMODE_EXACT, then dont return IF
            // and release read lock on ras table.
            //
            if (*pprte==NULL) {

                if (*bRasIfLock) {
                    *bRasIfLock = FALSE;
                    RELEASE_IF_LOCK_SHARED((*ppite)->IfIndex, "_GetIfOrRasForEnum");
                }

                *ppite = NULL;
                GOTO_END_BLOCK1;
            }

            *pprt = (*ppite)->pRasTable;
        }

        
        //
        // GETMODE_NEXT : if pQuery->RasClientAddr, then find the first ras
        // client, else find the next ras client
        //
        
        else if ( (dwGetMode==GETMODE_NEXT) || (dwGetMode==GETMODE_FIRST) ){
        
            BOOL    bFoundRasClient = FALSE;

            *pprt = (*ppite)->pRasTable;
            
            //
            // if the pQuery->RasClientAddr==0, then get the first ras client
            //
            if (pQuery->RasClientAddr==0) {

                if (!IsListEmpty(&(*pprt)->ListByAddr)) {
                
                    bFoundRasClient = TRUE;
                    *pprte = CONTAINING_RECORD((*pprt)->ListByAddr.Flink,
                                               RAS_TABLE_ENTRY, LinkByAddr);
                }
            }

            else {
                PRAS_TABLE_ENTRY    prtePrev, prteCur;
                PLIST_ENTRY         pHead, ple;

                
                // get the prev ras client through hash table
                prtePrev = GetRasClientByAddr(pQuery->RasClientAddr, 
                                        (*ppite)->pRasTable);

                //                        
                // if ras client not found, then go through the ordered list
                // and get a ras client with next higher addr
                //
                if (prtePrev==NULL) {

                    pHead = &(*pprt)->ListByAddr;
                    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                        prteCur = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, 
                                                    LinkByAddr);
                        if (pQuery->RasClientAddr>prteCur->NHAddr)
                            break;
                    }

                    if (ple!=pHead) {
                        bFoundRasClient = TRUE;
                        *pprte = prteCur;
                    }

                }

                //
                // get the next ras client through the ras client list
                //
                else {
                    ple = prtePrev->LinkByAddr.Flink;

                    // more entries present. found next ras client entry
                    if (ple != &(*pprt)->ListByAddr) {

                        bFoundRasClient = TRUE;
                        *pprte = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, 
                                                    LinkByAddr);
                        *pprt = (*ppite)->pRasTable;
                    }
                }
            }

            // if ras client is not found, then I set the interface also to NULL
            if (bFoundRasClient==FALSE) {

                if (*bRasIfLock)
                    RELEASE_IF_LOCK_SHARED((*ppite)->IfIndex, "_GetIfOrRasForEnum");

                *bRasIfLock = FALSE;
                *ppite = NULL;
                *pprte = NULL;
                *pprt = NULL;

                Error = ERROR_NO_MORE_ITEMS;
            }
            else 
                *pprt = (*ppite)->pRasTable;
                
        } //getmode==GETMODE_NEXT
        
    } END_BREAKOUT_BLOCK1;

    if ( (Error!= NO_ERROR) && (*bRasIfLock) ) {
        *bRasIfLock = FALSE;
        RELEASE_IF_LOCK_SHARED((*ppite)->IfIndex, "_GetIfOrRasForEnum");
    }
    
    return Error;
    
} //end _GetIfOrRasForEnum


//------------------------------------------------------------------------------
// Function:    _GetIfByListIndex
//
// if GETMODE_FIRST: retrieves the 1st entry in the list ordered by index.
// if GETMODE_EXACT: retrieves the entry from the hash table
// if GETMODE_NEXT:  retrieves the prev entry from hash table, and then
//                   retrieves the next entry from the list ordered by index.
//
// Locks: Assumes IfList lock.
//------------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByListIndex(
    DWORD         IfIndex,
    DWORD         dwGetMode,
    PDWORD        pdwErr
    )
{

    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY     ple, pHead;


    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }

    pite = NULL;


    //
    // GETMODE_FIRST: return record at head of list;
    // if list is empty, return NULL.
    //
    if (dwGetMode == GETMODE_FIRST) {

        if (IsListEmpty(&g_pIfTable->ListByIndex)) { 
            //*pdwErr = ERROR_NO_MORE_ITEMS;
            return NULL; 
        }
        else {
            ple = g_pIfTable->ListByIndex.Flink;
            return CONTAINING_RECORD(ple, IF_TABLE_ENTRY, LinkByIndex);
        }
    }


    //
    // get the entry requested from the hash table.
    //
    pite = GetIfByIndex(IfIndex);


    //
    // GETMODE_EXACT: return the entry 
    //
    if (dwGetMode==GETMODE_EXACT)
        return pite;

        
    //
    // GETMODE_NEXT: return the item after the one retrieved
    //
    if (dwGetMode==GETMODE_NEXT) {

        // the previous entry was found. return the next one.
        
        if (pite!=NULL) {

            ple = &pite->LinkByIndex;

            //
            // if entry found is last one, return NULL,
            // otherwise return the following entry
            //

            if (ple->Flink == &g_pIfTable->ListByIndex) {
                if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
                pite = NULL;
            }
            else {
                ple = ple->Flink;
                pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, LinkByIndex);
            }
        }

        //
        // the previous entry was not found.
        // go throught the list of interfaces ordered by index, and retrieve the 
        // interface with next higher index
        //
        else {
            pHead = &g_pIfTable->ListByIndex;
            for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, LinkByIndex);
                if (pite->IfIndex>IfIndex)
                    break;
            }
        }
    }

    return pite;
    
}//end _GetIfByListIndex


//------------------------------------------------------------------------------
//          _GetGroupByAddr
//
// Locks: assumes lock on the group list
//------------------------------------------------------------------------------
PGROUP_TABLE_ENTRY
GetGroupByAddr (
    DWORD       Group, 
    DWORD       dwGetMode,
    PDWORD      pdwErr
    )
{
    PLIST_ENTRY         ple, pHead;
    PGROUP_TABLE_ENTRY  pge;
    DWORD               GroupLittleEndian = NETWORK_TO_LITTLE_ENDIAN(Group);
    
    

    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }

    pHead = &g_pGroupTable->ListByGroup.Link;
    pge = NULL;

    //
    // return record at head of list if mode is GETMODE_FIRST;
    // if list is empty, return NULL.
    //

    if (dwGetMode == GETMODE_FIRST) {
        if (pHead->Flink == pHead) { return NULL; }
        else {
            ple = pHead->Flink;
            return CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, LinkByGroup);
        }
    }

    
    // get the entry requested

    pge = GetGroupFromGroupTable (Group, NULL, 0);



    //
    // if mode is GETMODE_NEXT, return the item after the one retrieved
    //

    if (dwGetMode == GETMODE_NEXT) {

        //
        // if the previous group was found, then return the one following it in the list
        //
        if (pge != NULL) {
        
            ple = &pge->LinkByGroup;

            //
            // if entry found is last one, return NULL,
            // otherwise return the following entry
            //

            if (ple->Flink == pHead) {
                if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
                pge = NULL;
            }
            else {
                ple = ple->Flink;
                pge = CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, LinkByGroup);
            }
        }
        //
        // previous group was not found. Go through the list and return the greater group.
        //
        else {
    
            pHead = &g_pGroupTable->ListByGroup.Link;

            for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                pge = CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, LinkByGroup);
                
                if (pge->GroupLittleEndian > GroupLittleEndian)
                    break;
            }

            if (ple==pHead) {
                if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
                pge = NULL;
            }
            // else pge points to the entry to be returned.
        }
    }

    return pge;
    
}//end _GetGroupByAddr




DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    )
{

      //
    // Not supported
    //

    return NO_ERROR;

}
    

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    )
{
    //
    // Not supported
    //

    return NO_ERROR;
}


DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    )
{
    //
    // Not supported
    //

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\packet.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: packet.c
//
// Abstract:
//      This module contains declarations for packet.c
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================

#ifndef _PACKET_H_
#define _PACKET_H_

DWORD
SendPacket (
    PIF_TABLE_ENTRY  pite,
    PGI_ENTRY        pgie,
    DWORD            PacketType,  //MSG_GEN_QUERY, MSG_GROUP_QUERY_V2(v3),SOURCES_Q
    DWORD            Group        //destination McastGrp
    );    

DWORD
JoinMulticastGroup (
    SOCKET   Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    DWORD    dwIpAddr,
    IPADDR   Source
    );    

    
DWORD
LeaveMulticastGroup (
    SOCKET    Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    DWORD    dwIpAddr,
    IPADDR   Source
    );
    
DWORD
BlockSource (
    SOCKET Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    );

DWORD
UnBlockSource (
    SOCKET Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    );

DWORD
McastSetTtl(
    SOCKET sock,
    UCHAR ttl
    );

//
//    packet context struct
//
typedef struct _PACKET_CONTEXT {

    DWORD           IfIndex;
    DWORD           DstnMcastAddr;
    DWORD           InputSrc;
    DWORD           Length;
    DWORD           Flags;
    BYTE            Packet[1];

} PACKET_CONTEXT, *PPACKET_CONTEXT;

#define CREATE_PACKET_CONTEXT(ptr, pktLen, Error) {\
    ptr = IGMP_ALLOC(sizeof(PACKET_CONTEXT)+(pktLen)-1,0xa0000,0xaaaa);\
    if (ptr==NULL) {    \
        Error = ERROR_NOT_ENOUGH_MEMORY;    \
        Trace2(ANY, "Error %d allocating %d bytes for Work context", \
                Error, sizeof(PACKET_CONTEXT)+(pktLen)-1); \
        Logerr0(HEAP_ALLOC_FAILED, Error); \
    } \
}


#pragma pack(1)

// Structure of an IGMP header.
typedef struct _IGMP_HEADER {

    UCHAR       Vertype;              //  Type of igmp message
    UCHAR       ResponseTime;         // max. resp. time for igmpv2 messages; will be 0
    USHORT      Xsum;
    union {
        DWORD       Group;
        struct {
            USHORT      Reserved;
            USHORT      NumGroupRecords;
        };
    };
} IGMP_HEADER, *PIGMP_HEADER;


#define MIN_PACKET_SIZE     sizeof(IGMP_HEADER)
#define INPUT_PACKET_SZ     1000
#define IPVERSION           4


typedef struct _IGMP_HEADER_V3_EXT {
    BYTE        QRV      :3;
    BYTE        SFlag    :1;
    BYTE        Reserved :4;
    BYTE        QQIC;
    USHORT      NumSources;
    IPADDR      Sources[0];
    
} IGMP_HEADER_V3_EXT, *PIGMP_HEADER_V3_EXT;


#define GET_QQIC_FROM_CODE(qqic) qqic <= 127? qqic : ((qqic&0x0f) + 16) << ((qqic&0x70) + 3)

//
// GROUP_RECORD
//
typedef struct _GROUP_RECORD {

    UCHAR       RecordType;
    UCHAR       AuxDataLength;
    USHORT      NumSources;
    IPADDR      Group;
    IPADDR      Sources[0];

} GROUP_RECORD, *PGROUP_RECORD;

#define GET_GROUP_RECORD_SIZE(pGroupRecord) \
    (pGroupRecord->NumSources+2)*sizeof(IPADDR))

#define GET_FIRST_GROUP_RECORD(pHdr) \
    (PGROUP_RECORD)((PCHAR)(pHdr)+MIN_PACKET_SIZE)
    
#define GET_NEXT_GROUP_RECORD(pGroupRecord) \
    ((PGROUP_RECORD) ((UCHAR)pGroupRecord + \
                    GET_GROUP_RECORD_SIZE(pGroupRecord)))

#define IS_IN    1
#define IS_EX   2
#define TO_IN   3
#define TO_EX   4
#define ALLOW  5
#define BLOCK     6


typedef struct _IP_HEADER {

    UCHAR              Hl;              // Version and length.
    UCHAR              Tos;             // Type of service.
    USHORT             Len;             // Total length of datagram.
    USHORT             Id;              // Identification.
    USHORT             Offset;          // Flags and fragment offset.
    UCHAR              Ttl;             // Time to live.
    UCHAR              Protocol;        // Protocol.
    USHORT             Xsum;            // Header checksum.
    struct in_addr     Src;             // Source address.
    struct in_addr     Dstn;            // Destination address.
    
} IP_HEADER, *PIP_HEADER;

#pragma pack()


//
//    MACROS
//

//
// message types// work types
//
#define MSG_GEN_QUERY           1
#define MSG_GROUP_QUERY_V2         2
#define MSG_REPORT              3
#define MSG_LEAVE               4
#define MSG_SOURCES_QUERY       5
#define MSG_GROUP_QUERY_V3      6

#define DELETE_MEMBERSHIP       11
#define DELETE_SOURCE           12
#define SHIFT_TO_V3             13
#define MOVE_SOURCE_TO_EXCL     14

#define PROXY_PRUNE             100
#define PROXY_JOIN              101


//
// igmp type field
//
#define     IGMP_QUERY          0x11    //Membership query
#define     IGMP_REPORT_V1      0x12    //Version 1 membership report
#define     IGMP_REPORT_V2      0x16    //Version 2 membership report
#define     IGMP_LEAVE          0x17    //Leave Group
#define     IGMP_REPORT_V3      0x22    //Version 3 membership report

//
// igmp version
//
#define     IGMPV1              2       //IGMP version 1
#define     IGMPV2              3       //IGMP version 2



//
// igmp multicast groups
//
#define     ALL_HOSTS_MCAST      0x010000E0
#define     ALL_ROUTERS_MCAST    0x020000E0
#define     ALL_IGMP_ROUTERS_MCAST  0x160000E0


//
// message macros
//
#define SEND_GEN_QUERY(pite) \
    SendPacket(pite, NULL, MSG_GEN_QUERY, 0)

#define SEND_GROUP_QUERY_V2(pite, pgie, Group) \
    SendPacket(pite, pgie, MSG_GROUP_QUERY_V2, Group)
    
#define SEND_GROUP_QUERY_V3(pite, pgie, Group) \
    SendPacket(pite, pgie, MSG_GROUP_QUERY_V3, Group)

#define SEND_SOURCES_QUERY(pgie) \
    SendPacket((pgie)->pIfTableEntry, pgie, MSG_SOURCES_QUERY, (pgie)->pGroupTableEntry->Group)
    

// 224.0.0.0 < group <240.0.0.0
// 
#define IS_MCAST_ADDR(Group) \
    ( (0x000000E0!=(Group))  \
      && (0x000000E0 <= ((Group)&0x000000FF) ) \
      && (0x000000F0 >  ((Group)&0x000000FF) ) ) 


//
// is the group 224.0.0.x
//
#define LOCAL_MCAST_GROUP(Group) \
    (((Group)&0x00FFFFFF) == 0x000000E0)

#define SSM_MCAST_GROUP(Group) \
    (((Group)&0x000000FF) == 0x000000E8)

USHORT
xsum(
    PVOID Buffer, 
    INT Size
    );


#endif //_PACKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\mib.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: mib.h
//
// Abstract:
//      This module contains declarations related to mibs.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================


#ifndef _MIB_H_
#define _MIB_H_



#define MIB_PROXY_GROUP_INFO   IGMP_MIB_GROUP_INFO
#define PMIB_PROXY_GROUP_INFO  PIGMP_MIB_GROUP_INFO
#define MIB_PROXY_GROUP_INFO_V3  MIB_GROUP_INFO_V3
#define PMIB_PROXY_GROUP_INFO_V3 PMIB_GROUP_INFO_V3

#define GETMODE_EXACT   0
#define GETMODE_FIRST   1
#define GETMODE_NEXT    2




//
// EXTERNAL PROTOTYPES
//
DWORD
WT_MibDisplay (
    PVOID   pContext
    );

    
DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

//
// Local prototype
//
DWORD
MibGetInternal(
    PIGMP_MIB_GET_INPUT_DATA pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA pResponse,
    PDWORD pdwOutputSize,
    DWORD dwGetMode
    );
    
PIF_TABLE_ENTRY
GetIfByListIndex(
    DWORD     	IfIndex,
    DWORD     	dwGetMode,
    PDWORD     	pdwErr
    );

VOID
WF_MibDisplay(
    PVOID pContext
    );

VOID
PrintGlobalStats(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA       pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA      pResponse
    );
    
VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA pResponse
    );

    
VOID
PrintIfConfig(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );
    

VOID
PrintIfStats(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );

    
VOID
PrintIfBinding(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );

VOID
PrintIfGroupsList(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );

VOID    
PrintGroupIfsList(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );

VOID
PrintProxyIfIndex(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA       pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA      pResponse
    );
    
PGROUP_TABLE_ENTRY
GetGroupByAddr (
    DWORD       Group, 
    DWORD     	dwGetMode,
    PDWORD     	pdwErr
    );

DWORD
GetIfOrRasForEnum(
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    DWORD                       dwGetMode,
    PIF_TABLE_ENTRY             *ppite,
    PRAS_TABLE                  *pprt,
    PRAS_TABLE_ENTRY            *pprte,
    BOOL                        *bRasIfLock,
    DWORD                       Flags
    );

DWORD
MibGetInternalIfStats (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );
DWORD
MibGetInternalIfConfig (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );
DWORD
MibGetInternalIfBindings (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );
DWORD
MibGetInternalIfGroupsInfo (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );

DWORD
MibGetInternalGroupIfsInfo (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );

DWORD
ListLength(
    PLIST_ENTRY pHead
    );
    
#endif //_MIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ip\igmp\sync.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
// File:    sync.c
//
// History:
//  Abolade Gbadegesin
//  K.S.Lokesh (added Dynamic locking)
//
// Synchronization routines used by IGMP.
//============================================================================


#include "pchigmp.h"


// for debugging, Set ids for each dynamic lock

#ifdef LOCK_DBG
    DWORD   DynamicCSLockId;
    DWORD   DynamicRWLockId;
#endif;





//----------------------------------------------------------------------------
// Function:    QueueIgmpWorker  
//
// This function is called to queue a Igmp function in a safe fashion;
// if cleanup is in progress or if Igmp has stopped, this function
// discards the work-item.
//----------------------------------------------------------------------------

DWORD
QueueIgmpWorker(
    LPTHREAD_START_ROUTINE pFunction,
    PVOID pContext
    ) {

    DWORD Error = NO_ERROR;
    BOOL bSuccess;

    
    EnterCriticalSection(&g_CS);

    if (g_RunningStatus != IGMP_STATUS_RUNNING) {

        //
        // cannot queue a work function when Igmp has quit or is quitting
        //

        Error = ERROR_CAN_NOT_COMPLETE;
    }
    else {

        ++g_ActivityCount;
        bSuccess = QueueUserWorkItem(pFunction, pContext, 0);

        if (!bSuccess) {

            Error = GetLastError();
            
            Trace1(ERR, "Error: Attempt to queue work item returned:%d",    
                    Error);
            IgmpAssertOnError(FALSE);
                    
            --g_ActivityCount;
        }
    }

    LeaveCriticalSection(&g_CS);

    return Error;
}



//----------------------------------------------------------------------------
// Function:    EnterIgmpAPI
//
// This function is called to when entering a Igmp api, as well as
// when entering the input thread and timer thread.
// It checks to see if Igmp has stopped, and if so it quits; otherwise
// it increments the count of active threads.
//----------------------------------------------------------------------------

BOOL
EnterIgmpApi(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&g_CS);

    if (g_RunningStatus == IGMP_STATUS_RUNNING) {

        //
        // Igmp is running, so the API may continue
        //

        ++g_ActivityCount;

        bEntered = TRUE;
    }
    else {

        //
        // Igmp is not running, so the API exits quietly
        //

        bEntered = FALSE;
    }

    LeaveCriticalSection(&g_CS);

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    EnterIgmpWorker
//
// This function is called when entering a Igmp worker-function.
// Since there is a lapse between the time a worker-function is queued
// and the time the function is actually invoked by a worker thread,
// this function must check to see if Igmp has stopped or is stopping;
// if this is the case, then it decrements the activity count, 
// releases the activity semaphore, and quits.
//----------------------------------------------------------------------------

BOOL
EnterIgmpWorker(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&g_CS);

    if (g_RunningStatus == IGMP_STATUS_RUNNING) {

        //
        // Igmp is running, so the function may continue
        //

        bEntered = TRUE;
    }
    else
    if (g_RunningStatus == IGMP_STATUS_STOPPING) {

        //
        // Igmp is not running, but it was, so the function must stop.
        // 

        --g_ActivityCount;

        ReleaseSemaphore(g_ActivitySemaphore, 1, NULL);

        bEntered = FALSE;
    }
    else {

        //
        // Igmp probably never started. quit quietly
        //

        bEntered = FALSE;
    }

    LeaveCriticalSection(&g_CS);

    return bEntered;
}


//----------------------------------------------------------------------------
// Function:    LeaveIgmpWorkApi
//
// This function is called when leaving a Igmp API. 
// It in turn calls LeaveIgmpWorker
//----------------------------------------------------------------------------
VOID
LeaveIgmpApi(
    ) {
    LeaveIgmpWorker();
    return;
}



//----------------------------------------------------------------------------
// Function:    LeaveIgmpWorker
//
// This function is called when leaving a Igmp API or worker function.
// It decrements the activity count, and if it detects that Igmp has stopped
// or is stopping, it releases the activity semaphore.
//----------------------------------------------------------------------------

VOID
LeaveIgmpWorker(
    ) {

    EnterCriticalSection(&g_CS);

    --g_ActivityCount;

    if (g_RunningStatus == IGMP_STATUS_STOPPING) {

        ReleaseSemaphore(g_ActivitySemaphore, 1, NULL);
    }

    LeaveCriticalSection(&g_CS);

}




//----------------------------------------------------------------------------
// Function:    CreateReadWriteLock
//
// Initializes a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    pRWL->RWL_ReaderCount = 0;

    try {
        InitializeCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return STATUS_NO_MEMORY;
    }

    pRWL->RWL_ReaderDoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (pRWL->RWL_ReaderDoneEvent != NULL) {
        return GetLastError();
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    DeleteReadWriteLock
//
// Frees resources used by a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    CloseHandle(pRWL->RWL_ReaderDoneEvent);
    pRWL->RWL_ReaderDoneEvent = NULL;
    DeleteCriticalSection(&pRWL->RWL_ReadWriteBlock);
    pRWL->RWL_ReaderCount = 0;
}




//----------------------------------------------------------------------------
// Function:    AcquireReadLock
//
// Secures shared ownership of the lock object for the caller.
//
// readers enter the read-write critical section, increment the count,
// and leave the critical section
//----------------------------------------------------------------------------

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL
    ) {
    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock); 
    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&pRWL->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
// Function:    ReleaseReadLock
//
// Relinquishes shared ownership of the lock object.
//
// the last reader sets the event to wake any waiting writers
//----------------------------------------------------------------------------

VOID
ReleaseReadLock (
    PREAD_WRITE_LOCK pRWL
    ) {

    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) < 0) {
        SetEvent(pRWL->RWL_ReaderDoneEvent); 
    }
}



//----------------------------------------------------------------------------
// Function:    AcquireWriteLock
//
// Secures exclusive ownership of the lock object.
//
// the writer blocks other threads by entering the ReadWriteBlock section,
// and then waits for any thread(s) owning the lock to finish
//----------------------------------------------------------------------------

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock);
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) >= 0) { 
        WaitForSingleObject(pRWL->RWL_ReaderDoneEvent, INFINITE);
    }
}






//----------------------------------------------------------------------------
// Function:    ReleaseWriteLock
//
// Relinquishes exclusive ownership of the lock object.
//
// the writer releases the lock by setting the count to zero
// and then leaving the ReadWriteBlock critical section
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    pRWL->RWL_ReaderCount = 0;
    LeaveCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
}





//------------------------------------------------------------------------------
//          _InitializeDynamicLocksStore
//
// Initialize the global struct from which dynamic CS or RW locks are allocated
//------------------------------------------------------------------------------

DWORD
InitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE   pDLStore //ptr to Dynamic CS Store
    )
{
    DWORD Error = NO_ERROR;

    BEGIN_BREAKOUT_BLOCK1 {

        //
        // initialize the main CS lock which protects the list of free locks
        //
        
        try {
            InitializeCriticalSection(&pDLStore->CS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Error = GetExceptionCode();
            Trace1(ERR, "Error initializing critical section in IGMPv2.dll",
                        Error);
            IgmpAssertOnError(FALSE);
            Logerr0(INIT_CRITSEC_FAILED, Error);
            
            GOTO_END_BLOCK1;
        }


        // initialize list of free locks
        
        InitializeListHead(&pDLStore->ListOfFreeLocks);


        // initialize counts for number of locks free and allocated to 0.
        
        pDLStore->CountAllocated = pDLStore->CountFree = 0;

        
    } END_BREAKOUT_BLOCK1;

    return Error;
}


//------------------------------------------------------------------------------
//          _DeInitializeDynamicLocksStore
//
// Delete the main CS lock and the other free locks. Print warning if any
// locks have been allocated and not freed.
//------------------------------------------------------------------------------
VOID
DeInitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pDLStore,
    LOCK_TYPE               LockType  //if True, then store of CS, else of RW locks
    )
{
    PDYNAMIC_CS_LOCK    pDCSLock;
    PDYNAMIC_RW_LOCK    pDRWLock;
    PLIST_ENTRY         pHead, ple;

    
    Trace0(ENTER1, "Entering _DeInitializeDynamicLocksStore()");
    
    if (pDLStore==NULL)
        return;


        
    // delete the main CS lock
    
    DeleteCriticalSection(&pDLStore->CS);


    // print warning if any dynamic lock has not been freed
    
    if (pDLStore->CountAllocated>0) {
        Trace1(ERR, 
            "%d Dynamic locks have not been freed during Deinitialization",
            pDLStore->CountAllocated);
        IgmpAssertOnError(FALSE);
    }


    
    // delete all dynamic CS/RW locks. I dont free the memory (left to heapDestroy)
    
    pHead = &pDLStore->ListOfFreeLocks;
    for (ple=pHead->Flink;  ple!=pHead;  ) {
        
        // if bCSLocks flag, then it is a store of CS locks
        if (LockType==LOCK_TYPE_CS) {
        
            pDCSLock = CONTAINING_RECORD(ple, DYNAMIC_CS_LOCK, Link);
            ple = ple->Flink;

            DeleteCriticalSection(&pDCSLock->CS);
            IGMP_FREE(pDCSLock);
        }

        // delete the RW lock
        else {
        
            pDRWLock = CONTAINING_RECORD(ple, DYNAMIC_RW_LOCK, Link);
            ple = ple->Flink;

            DELETE_READ_WRITE_LOCK(&pDRWLock->RWL);
            IGMP_FREE(pDRWLock);
        }
    }

    Trace0(LEAVE1, "Leaving _DeInitializeDynamicLocksStore()");
    return;
}



//------------------------------------------------------------------------------
//          _AcquireDynamicCSLock
//
// Acquires the MainLock associated with the table, Acquires a new dynamic
// lock if required, increments the count, releases the MainLock and 
// locks the LockedList.
//------------------------------------------------------------------------------

DWORD
AcquireDynamicCSLock (
    PDYNAMIC_CS_LOCK        *ppDCSLock,
    PDYNAMIC_LOCKS_STORE    pDCSStore
    )
{
    // acquire the main lock for the Dynamic CS store
    
    ENTER_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
            "_AcquireDynamicCSLock");


    //
    // If it is not already locked then allocate a lock
    //
    if (*ppDCSLock==NULL) {

        *ppDCSLock = GetDynamicCSLock(pDCSStore);


        // if could not get a lock, then igmp is in serious trouble
        
        if (*ppDCSLock==NULL) {
        
            LEAVE_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
                    "_AcquireDynamicCSLock");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    
    // increment Count in the Dynamic Lock

    (*ppDCSLock)->Count++;
    DYNAMIC_LOCK_CHECK_SIGNATURE_INCR(*ppDCSLock);


    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
                            "_AcquireDynamicCSLock");


    //
    // enter dynamic lock's CS lock
    //
    ENTER_CRITICAL_SECTION(&(*ppDCSLock)->CS, "pDynamicLock", 
        "_AcquireDynamicCSLock");
        
    
    return NO_ERROR;
    
} //end _AcquireDynamicCSLock



//------------------------------------------------------------------------------
//          _GetDynamicCSLock
//
// If a free lock is available, returns it. Else allocates a new CS lock
// Lock: Assumes the DCSStore MainLock
//------------------------------------------------------------------------------

PDYNAMIC_CS_LOCK
GetDynamicCSLock (
    PDYNAMIC_LOCKS_STORE   pDCSStore
    )
{
    PDYNAMIC_CS_LOCK    pDCSLock;
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         ple;
    
    
    //
    // free dynamic lock available. Return it
    //
    if (!IsListEmpty(&pDCSStore->ListOfFreeLocks)) {

        pDCSStore->CountFree--;
        pDCSStore->CountAllocated++;

        ple = RemoveTailList(&pDCSStore->ListOfFreeLocks);

        pDCSLock = CONTAINING_RECORD(ple, DYNAMIC_CS_LOCK, Link);
        
        /*Trace1(LEAVE1, "Leaving GetDynamicCSLock.1(%d):reusing lock", 
                pDCSLock->Id);
        */

        return pDCSLock;
    }


    // allocate memory for a new dynamic lock
    
    pDCSLock = IGMP_ALLOC(sizeof(DYNAMIC_CS_LOCK), 0x20000,0);

    PROCESS_ALLOC_FAILURE2(pDCSLock,
        "error %d allocating %d bytes for dynamic CS lock",
        Error, sizeof(DYNAMIC_CS_LOCK), 
        return NULL);


    pDCSStore->CountAllocated++;

    //
    // initialize the fields
    //
    
    try {
        InitializeCriticalSection(&pDCSLock->CS);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Error = GetExceptionCode();
        Trace1(ERR, 
            "Error(%d) initializing critical section for dynamic CS lock", 
            Error);
        IgmpAssertOnError(FALSE);
        Logerr0(INIT_CRITSEC_FAILED, Error);

        return NULL;
    }

    // no need to initialize the link field
    //InitializeListEntry(&pDCSLock->List);
    
    pDCSLock->Count = 0;
    #ifdef LOCK_DBG
        pDCSLock->Id = ++DynamicCSLockId;
    #endif
    DYNAMIC_LOCK_SET_SIGNATURE(pDCSLock);


    //Trace1(LEAVE1, "Leaving _GetDynamicCSLock(%d:%d):new lock", DynamicCSLockId);
    //Trace2(DYNLOCK, "CS: %d %d", pDCSLock->Id, DynamicCSLockId);

    return pDCSLock;
    
} //end _GetDynamicCSLock




//------------------------------------------------------------------------------
//          _ReleaseDynamicCSLock
//
// Acquires the MainLock associated with the table, decrements the count, 
// releases the DynamicLock if count becomes 0 and releases the MainLock.
//------------------------------------------------------------------------------
VOID
ReleaseDynamicCSLock (
    PDYNAMIC_CS_LOCK    *ppDCSLock,
    PDYNAMIC_LOCKS_STORE   pDCSStore
    )
{
    PDYNAMIC_CS_LOCK    pDCSLock = *ppDCSLock;
    
    
    // acquire the main lock for the Dynamic CS store
    
    ENTER_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
                        "_ReleaseDynamicCSLock");

    DYNAMIC_LOCK_CHECK_SIGNATURE_DECR(pDCSLock);


    // leave the dynamic lock CS
    
    LEAVE_CRITICAL_SECTION(&pDCSLock->CS, "pDynamicLock", 
                        "_ReleaseDynamicCSLock");


          
    // Decrement Count in the Dynamic Lock. Free the dynamic lock if count==0
  
    if (--pDCSLock->Count==0) {

        FreeDynamicCSLock(pDCSLock, pDCSStore);

        // make the pDCSLock NULL so that it is known that it is not locked
        *ppDCSLock = NULL;
        
    }


    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
            "_ReleaseDynamicCSLock");

            
    //Trace0(LEAVE1, "Leaving _ReleaseDynamicCSLock()");

    return;
    
} //end _ReleaseDynamicCSLock


//------------------------------------------------------------------------------
//          _FreeDynamicCSLock
//------------------------------------------------------------------------------
VOID
FreeDynamicCSLock (
    PDYNAMIC_CS_LOCK    pDCSLock,
    PDYNAMIC_LOCKS_STORE   pDCSStore
    )
{
    // decrement count of allocated locks
    
    pDCSStore->CountAllocated--;

    //