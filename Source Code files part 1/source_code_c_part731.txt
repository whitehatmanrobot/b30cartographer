mma = %d\n",(USHORT)pGDIInfo->ciDevice.RedGamma, (USHORT)pGDIInfo->ciDevice.GreenGamma, (USHORT)pGDIInfo->ciDevice.BlueGamma);

#endif

    if( lRet < 1 )
    {
#if DBG
        DbgPrint( "Rasdd!GetPalette8BPP returns %ld\n", lRet );
#endif

        return(0);
    }
    /*
     *    Convert the HT derived palette to the engine's desired format.
     */

    for( _iI = 0; _iI < lRet; _iI++ )
    {
        pPD->ulPalCol[ _iI ] = RGB( pe[ _iI ].peRed,
                                    pe[ _iI ].peGreen,
                                    pe[ _iI ].peBlue );
    #if  PRINT_INFO
        DbgPrint("Pallette entry %d= (r = %d, g = %d, b = %d)\n",_iI,pe[ _iI ].peRed, pe[ _iI ].peGreen, pe[ _iI ].peBlue);

    #endif

    }

    pPD->iPalGdi               = lRet;
    pdevinfo->iDitherFormat    = BMF_8BPP;
    pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
    pGDIInfo->ulHTOutputFormat = HT_FORMAT_8BPP;


    /*
     * Since the GPC spec does not support this flag yet,
     * we have to manually set it.
     */
    pRPDev->fColorFormat |= DC_ZERO_FILL;
    /*
     * Since the Color laserJet zero fills we are going to
     * put white in palette entry 0 and black in 7
     */
    if (pRPDev->fColorFormat & DC_ZERO_FILL)
    {
        pPD->ulPalCol[ 7 ]       = RGB (0x00, 0x00, 0x00);
        pPD->ulPalCol[ 0 ]       = RGB (0xff, 0xff, 0xff);
        pPD->iWhiteIndex         = 0;
        pPD->iBlackIndex         = 7;
    }


    return lRet;
}


/************************** Function Header *********************************
 * lSetup24BitPalette
 *      Function to read in the 256 color palette from GDI into the
 *      palette data structure in Dev Info.
 *
 * RETURNS:
 *      The number of colors in the palette. Returns 0 if the call fails.
 *
 * HISTORY:
 *  10:43 on Wed 06 Sep 1995    -by-    Sandra Matts
 *      Created it to support the Color LaserJet
 *
 ****************************************************************************/
long lSetup24BitPalette (pPD, pdevinfo, pGDIInfo)
PAL_DATA  *pPD;
DEVINFO   *pdevinfo;             /* Where to put the data */
GDIINFO   *pGDIInfo;
{

    pPD->iPalGdi               = 0;
    pPD->iWhiteIndex           = 0x00ffffff;
    pdevinfo->iDitherFormat    = BMF_24BPP;
    pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
    pGDIInfo->ulHTOutputFormat = HT_FORMAT_24BPP;

    return 1;
}
/****************************** Function Header ****************************
 * v8BPPLoadPal
 *      Download the palette to the HP Color laserJet in 8BPP
 *      mode.  Takes the data we retrieved from the HT code during
 *      DrvEnablePDEV.
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 *  14:46 on Thu 29 June 1995    -by-    Sandra Matts
 *     Initial version
 *
 ****************************************************************************/

void
v8BPPLoadPal( pPDev )
PDEV   *pPDev;
{
    /*
     *   Program the palette according to PCL5 spec.
     *   The syntax is Esc*v#a#b#c#I
     *      #a is the first color component
     *      #b is the second color component
     *      #c is the third color component
     *      #I assigns the color to the specified palette index number
     *   For example, Esc*v0a128b255c5I assigns the 5th index
     *   of the palette to the color 0, 128, 255
     *
     */

    int   iI,
          iIndex;

    PAL_DATA  *pPD;

    pPD = pPDev->pPalData;

    /*TBD: how do we output a palette to the device?
    for( iI = 0; iI < pPD->iPalDev; ++iI )
    {
        WriteChannel (pPDev, CMD_DC_PC_ENTRY, RED_VALUE (pPD->ulPalCol [iI]),
            GREEN_VALUE (pPD->ulPalCol [iI]), BLUE_VALUE (pPD->ulPalCol [iI]),
            (ULONG) iI);
    }
    */
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\rastpdev.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    RastPdev.h

Abstract:

    Unidrv RASTPDEV and related info header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    12/06/96 -alvins-
        Created

        dd-mm-yy -author-
                description

--*/
#ifndef _RASTPDEV_H_
#define _RASTPDEV_H_

#include        "win30def.h"

/* flags for fRMode */
#define PFR_SENDSRCWIDTH    0x00000001  // send source width
#define PFR_SENDSRCHEIGHT   0x00000002  // send source height
#define PFR_SENDBEGINRASTER 0x00000004  // send begin raster command
#define PFR_RECT_FILL       0x00000008  // enable rules checking
#define PFR_RECT_HORIZFILL  0x00000010  // enable horizontal rules check
#define PFR_BLOCK_IS_BAND   0x00000020  /* Derryd:Full band sent to OemFlGrx */
#define PFR_ENDBLOCK        0x00000100  // need to send end of block command
#define PFR_COMP_TIFF       0x00000200  // enable TIFF compression
#define PFR_COMP_FERLE      0x00000400  // enable FERLE compression
#define PFR_COMP_DISABLED   0x00000800  // enable no compression
#define PFR_COMP_DRC        0x00001000  // enable DRC compression
#define PFR_COMP_OEM        0x00002000  // enable OEM compression
/*
 *   fDump values
 */

#define RES_DM_GDI             0x0040   // GDI bitmap format
#define RES_DM_LEFT_BOUND      0x0080   // Optimize by bounding rect
#define RES_DM_COLOR           0x0100   // Color support is available
/*
 *   fBlockOut values
 */

#define RES_BO_LEADING_BLNKS    0x0001  // Strip leading blanks
#define RES_BO_TRAILING_BLNKS   0x0002  // Strip trailing blanks
#define RES_BO_ENCLOSED_BLNKS   0x0004  // Strip enclosed blanks
#define RES_BO_UNIDIR           0x0008  // send unidir command for raster
#define RES_BO_MIRROR           0x0010  // mirror the data
#define RES_BO_MULTIPLE_ROWS    0x0020  // Multiple lines of data can be sent
#define RES_BO_NO_YMOVE_CMD     0x0040  // No Y movement so can't strip blanks

/*
 *   fCursor values
 */

#define RES_CUR_X_POS_ORG       0x0001       // X Position is at X start point
             // of graphic data after rendering data
#define RES_CUR_X_POS_AT_0      0x0002       // X position at leftmost place
             // on page after rendering data
#define RES_CUR_Y_POS_AUTO      0x0004       // Y position automatically moves
             // to next Y row
//#define RES_CUR_CR_GRX_ORG      0x0008       // CR moves X pos to X start point of
             // of graphic data

//
// RASTERPDEV structure
//
#define DC_MAX_PLANES   4
typedef struct _RASTERPDEV {
    DWORD   fRMode;
    DWORD   *pdwTrans;           /* Transpose table,  if required */
    DWORD   *pdwColrSep;         /* Colour separation data, if required */
    DWORD   *pdwBitMask;         /* Bitmask table,  white skip code */
    VOID    *pHalftonePattern;  /* Custom halftone table */
    BYTE    rgbOrder[DC_MAX_PLANES]; /*Colour plane/palette order*/
    DWORD   rgbCmdOrder[DC_MAX_PLANES];
    PAL_DATA    *pPalData;          /* Palette information */
    DWORD   dwRectFillCommand;  // command to use for rules
    WORD    fColorFormat;       /* color flags DEVCOLOR: */
    WORD    fDump;              // Dump method flags.
    WORD    fBlockOut;          // Block out method flags.
    WORD    fCursor;            // Cursor position flags.
    short   sMinBlankSkip;      // Min. # of bytes of null data that must occur before
    short   sNPins;             // Minimum height of the image to be rendered together.
    short   sPinsPerPass;       // Physical number of pins fired in one pass.
    short   sDevPlanes;         /* # of planes in the device color model, */
    short   sDevBPP;            /* Device Bits per pixel  - if Pixel model */
    short   sDrvBPP;            // Drv Bits per pixel
    BOOL    bTTY;               // Is printer type TTY
    int     iLookAhead;         // look ahead region for deskjet types
    void    *pRuleData;         // pointer to rules structure
    VOID    *pvRenderData;       /* Rendering summary data, PRENDER */
    VOID    *pvRenderDataTmp;    /* Temporary copy for use in banding */
    //
    // callback functions
    //
    PFN_OEMCompression      pfnOEMCompression;
    PFN_OEMHalftonePattern  pfnOEMHalftonePattern;
    PFN_OEMImageProcessing  pfnOEMImageProcessing;
    PFN_OEMFilterGraphics   pfnOEMFilterGraphics;
    DWORD   dwIPCallbackID;      /* OEM Image Processing CallbackID */
#ifdef TIMING
    DWORD   dwTiming;           // used for timing
    DWORD   dwDocTiming;
#endif
} RASTERPDEV, *PRASTERPDEV;

/*
 *   DEVCOLOR.fGeneral bit flags:
 */
#define DC_PRIMARY_RGB      0x0001   // use RGB as 3 primary colors.
                             // Default: use CMY instead.
#define DC_EXTRACT_BLK      0x0002   // Separate black ink/ribbon is available.
                             // Default: compose black using CMY.
                             // It is ignored if DC_PRIMARY_RGB is set
#define DC_CF_SEND_CR       0x0004   // send CR before selecting graphics
                             // color. Due to limited printer buffer
#define DC_SEND_ALL_PLANES  0x0008  /* All planes must be sent, e.g. PaintJet */
#define DC_OEM_BLACK        0x0010  // OEM is responsible for creating black
                                    // and inverting data
#define DC_EXPLICIT_COLOR   0x0020  /* Send command to select colour */
#define DC_SEND_PALETTE     0x0040  /* Device is Palette Managed; Seiko 8BPP */
/* sandram
 * add field to send dithered text for Color LaserJet - set foreground color.
 */
//#define DC_FG_TEXT_COLOR    0x0080  /* Send command to select text foreground color */

#define DC_ZERO_FILL        0x0100  /* This model fills raster to the end of the page with zeros */

//* define color order
#define DC_PLANE_RED    1
#define DC_PLANE_GREEN  2
#define DC_PLANE_BLUE   3
#define DC_PLANE_CYAN   4
#define DC_PLANE_MAGENTA    5
#define DC_PLANE_YELLOW 6
#define DC_PLANE_BLACK  7


//-------------------------------------------
// fTechnology--used as an ID, not a bitfield
//-------------------------------------------
#define GPC_TECH_DEFAULT       0   // Default technology
#define GPC_TECH_PCL4          1   // Uses PCL level 4 or above
#define GPC_TECH_CAPSL         2   // Uses CaPSL level 3 or above
#define GPC_TECH_PPDS          3   // Uses PPDS
#define GPC_TECH_TTY           4   // TTY printer--user configurable

/*
 *    fCompMode
 */
#define CMP_ID_TIFF4        0x0001
#define CMP_ID_FERLE        0x0002
#define CMP_ID_DRC          0x0004
#define CMP_ID_OEM          0x0008


#endif  // !_RASTPDEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\raster.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    Implementation of the interface between Control module and Raster module

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created

--*/

#include "raster.h"
#include "rastproc.h"
#include "rmrender.h"
#include "unirc.h"
#include "xlraster.h"

// internal function declarations
void vSetHTData(PDEV *, GDIINFO *);
BOOL bInitColorOrder(PDEV *);
DWORD PickDefaultHTPatSize(DWORD,DWORD);
VOID  v8BPPLoadPal(PDEV *);
BOOL bEnoughDRCMemory(PDEV *);

#ifdef TIMING
#include <stdio.h>
void  DrvDbgPrint(
    char *,
    ...);
#endif

// parameter definitions
static RMPROCS RasterProcs =
{
    RMStartDoc,
    RMStartPage,
    RMSendPage,
    RMEndDoc,
    RMNextBand,
    RMStartBanding,
    RMResetPDEV,
    RMEnableSurface,
    RMDisableSurface,
    RMDisablePDEV,
    RMCopyBits,
    RMBitBlt,
    RMStretchBlt,
    RMDitherColor,
    RMStretchBltROP,
    RMPaint,
    RMPlgBlt
};

CONST BYTE  cxcyHTPatSize[HT_PATSIZE_MAX_INDEX+1] = {

        2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16
#ifndef WINNT_40
        ,84,91
#endif        
    };


#define VALID_YC            0xFFFE
#define GAMMA_LINEAR        10000
#define GAMMA_DEVICE_HT     8000
#define GAMMA_SUPERCELL     GAMMA_LINEAR
#define GAMMA_DITHER        9250
#define GAMMA_GEN_PROFILE   0xFFFF


CONST COLORINFO DefColorInfoLinear =
{
    { 6400, 3300,       0 },        // xr, yr, Yr
    { 3000, 6000,       0 },        // xg, yg, Yg
    { 1500,  600,       0 },        // xb, yb, Yb
    {    0,    0,VALID_YC },        // xc, yc, Yc Y=0=HT default
    {    0,    0,       0 },        // xm, ym, Ym
    {    0,    0,       0 },        // xy, yy, Yy
    { 3127, 3290,   10000 },        // xw, yw, Yw

    10000,                          // R gamma
    10000,                          // G gamma
    10000,                          // B gamma

     712,    121,                   // M/C, Y/C
      86,    468,                   // C/M, Y/M
      21,     35                    // C/Y, M/Y
};


//*******************************************************
BOOL
RMInit (
    PDEV    *pPDev,
    DEVINFO *pDevInfo,
    GDIINFO *pGDIInfo
    )
/*++

Routine Description:

    This function is called to initialize raster related information in
    pPDev, pDevInfo and pGDIInfo

Arguments:

    pPDev           Pointer to PDEV structure
    pDevInfo        Pointer to DEVINFO structure
    pGDIInfo        Pointer to GDIINFO structure

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    BOOL bRet = FALSE;
    PRASTERPDEV pRPDev;

    // Validate Input Parameters and ASSERT.
    ASSERT(pPDev);
    ASSERT(pDevInfo);
    ASSERT(pGDIInfo);

    // initialize the hook flag
    pPDev->fHooks |= HOOK_BITBLT | HOOK_STRETCHBLT | HOOK_COPYBITS;

    // initialize Proc jump table
    pPDev->pRasterProcs = &RasterProcs;

    // initialize Raster Pdev
    if (!bInitRasterPDev(pPDev))
        return FALSE;

    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    //
    // Set up the default HALFTONE and colour calibration data.
    //
    vSetHTData( pPDev, pGDIInfo );

    //
    // initialize graphic capabilities
    //
    pDevInfo->flGraphicsCaps |= (GCAPS_ARBRUSHOPAQUE | GCAPS_HALFTONE | GCAPS_MONO_DITHER | GCAPS_COLOR_DITHER);

    // initialize DevInfo parameters for rendering
    // test whether standard dither or custom pattern
#ifndef WINNT_40    
    if (pGDIInfo->ulHTPatternSize == HT_PATSIZE_USER) {
        pDevInfo->cxDither = (USHORT)pPDev->pHalftone->HalftonePatternSize.x;
        pDevInfo->cyDither = (USHORT)pPDev->pHalftone->HalftonePatternSize.y;
    }
    else 
#endif    
    {
        pDevInfo->cxDither =
        pDevInfo->cyDither = cxcyHTPatSize[pGDIInfo->ulHTPatternSize];
    }
    pPDev->dwHTPatSize = pDevInfo->cyDither;
    // if no quality macro setting, overwrite with halftone type
    //
    if ((pPDev->pdmPrivate->dwFlags & DXF_CUSTOM_QUALITY) ||
            (pPDev->pdmPrivate->iQuality != QS_BEST &&
             pPDev->pdmPrivate->iQuality != QS_BETTER &&
             pPDev->pdmPrivate->iQuality != QS_DRAFT))
        pPDev->pdm->dmDitherType = pGDIInfo->ulHTPatternSize;

    return TRUE;
}

//*******************************************************
BOOL
bInitRasterPDev(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This routine allocates the RASTERPDEV and initializes various fields.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

--*/

{
    PRASTERPDEV pRPDev;
    GLOBALS     *pGlobals = pPDev->pGlobals;
    PLISTNODE pListNode;

    if ( !(pRPDev = MemAllocZ(sizeof(RASTERPDEV))) )
    {
        ERR(("Unidrv!RMInit: Can't Allocate RASTERPDEV\n"));
        return FALSE;
    }
    pPDev->pRasterPDEV = pRPDev;

    // map all callback functions
    //

    if (pPDev->pOemHookInfo)
    {
        pRPDev->pfnOEMCompression =
            (PFN_OEMCompression)pPDev->pOemHookInfo[EP_OEMCompression].pfnHook;
        pRPDev->pfnOEMHalftonePattern =
            (PFN_OEMHalftonePattern)pPDev->pOemHookInfo[EP_OEMHalftonePattern].pfnHook;
        if (pPDev->pColorModeEx && pPDev->pColorModeEx->dwIPCallbackID > 0)
        {
            pRPDev->pfnOEMImageProcessing = (PFN_OEMImageProcessing)
                pPDev->pOemHookInfo[EP_OEMImageProcessing].pfnHook;
        }
        pRPDev->pfnOEMFilterGraphics =
            (PFN_OEMFilterGraphics)pPDev->pOemHookInfo[EP_OEMFilterGraphics].pfnHook;
    }
    // Determine the pixel depth, # planes and color order
    //
    if (!(bInitColorOrder(pPDev)))
    {
        ERR(("Invalid Color Order"));
        pPDev->pRasterPDEV = NULL;
        MemFree(pRPDev);
        return FALSE;
    }

    //* Determine whether to set DC_EXPLICIT_COLOR flag
    if (pGlobals->bUseCmdSendBlockDataForColor)
        pRPDev->fColorFormat |= DC_EXPLICIT_COLOR;

    //* Determine DC_CF_SEND_CR flag
    if (pGlobals->bMoveToX0BeforeColor)
        pRPDev->fColorFormat |= DC_CF_SEND_CR;

    //* Determine DC_SEND_ALL_PLANES flag
    if (pGlobals->bRasterSendAllData)
        pRPDev->fColorFormat |= DC_SEND_ALL_PLANES;


    /*TBD: if there is a filter callback, set BLOCK_IS_BAND
    //
    if (I've got a filter callback?)
        pRPDev->fRMode |= PFR_BLOCK_IS_BAND;
    */

    // Initialize whether there are SRCBMPWIDTH / SRCBMPHEIGHT commands
    if (COMMANDPTR(pPDev->pDriverInfo,CMD_SETSRCBMPWIDTH))
        pRPDev->fRMode |= PFR_SENDSRCWIDTH;
    if (COMMANDPTR(pPDev->pDriverInfo,CMD_SETSRCBMPHEIGHT))
        pRPDev->fRMode |= PFR_SENDSRCHEIGHT;

    // Initialize whether there is a BEGINRASTER command
    if (COMMANDPTR(pPDev->pDriverInfo,CMD_BEGINRASTER))
        pRPDev->fRMode |= PFR_SENDBEGINRASTER;

    // Initialize rules testing
    // If Rectangle width and height commands exist assume we have black or
    // gray rectangles unless only white rect command exist. This is because
    // some devices have no explicit rectangle commands while others only have
    // white rectangles.
    // 
    if (pPDev->fMode & PF_RECT_FILL)
    {
        pRPDev->fRMode |= PFR_RECT_FILL | PFR_RECT_HORIZFILL;
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL))
            pRPDev->dwRectFillCommand = CMD_RECTBLACKFILL;
        else if (COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL))
            pRPDev->dwRectFillCommand = CMD_RECTGRAYFILL;
        else if (COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL))
            pRPDev->fRMode &= ~(PFR_RECT_FILL | PFR_RECT_HORIZFILL);
    }
    // Initialize whether to send ENDBLOCK commands
    if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENDBLOCKDATA))
        pRPDev->fRMode |= PFR_ENDBLOCK;

    //* Initialize resolution fields
    //
    pRPDev->sMinBlankSkip = (short)pPDev->pResolutionEx->dwMinStripBlankPixels;
    pRPDev->sNPins = (WORD)pPDev->pResolutionEx->dwPinsPerLogPass;
    pRPDev->sPinsPerPass = (WORD)pPDev->pResolutionEx->dwPinsPerPhysPass;

    //* initialize fDump flags
    //
    if (pGlobals->bOptimizeLeftBound)
        pRPDev->fDump |= RES_DM_LEFT_BOUND;
    if (pGlobals->outputdataformat == ODF_H_BYTE)
        pRPDev->fDump |= RES_DM_GDI;

    //* initialize fBlockOut flags
    //
    //* first map the GPD blanks parameters to GPC
    pListNode = LISTNODEPTR(pPDev->pDriverInfo,pPDev->pGlobals->liStripBlanks);
    while (pListNode)
    {
        if (pListNode->dwData == SB_LEADING)
            pRPDev->fBlockOut |= RES_BO_LEADING_BLNKS;
        else if (pListNode->dwData == SB_ENCLOSED)
            pRPDev->fBlockOut |= RES_BO_ENCLOSED_BLNKS;
        else if (pListNode->dwData == SB_TRAILING)
            pRPDev->fBlockOut |= RES_BO_TRAILING_BLNKS;
        pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
    }
    // Do we need to set to uni directional printing?
    //
    if (pPDev->pResolutionEx->bRequireUniDir)
        pRPDev->fBlockOut |= RES_BO_UNIDIR;

    // Can we output multiple rows at a time?
    //
    if (pPDev->pGlobals->bSendMultipleRows)
        pRPDev->fBlockOut |= RES_BO_MULTIPLE_ROWS;

    // Set flag if we need to mirror the individual raster bytes
    //
    if (pPDev->pGlobals->bMirrorRasterByte)
        pRPDev->fBlockOut |= RES_BO_MIRROR;

    // initialize fCursor flags
    //
    pRPDev->fCursor = 0;
    if (pGlobals->cyafterblock == CYSBD_AUTO_INCREMENT)
        pRPDev->fCursor |= RES_CUR_Y_POS_AUTO;

    if (pGlobals->cxafterblock == CXSBD_AT_GRXDATA_ORIGIN)
        pRPDev->fCursor |= RES_CUR_X_POS_ORG;

    else if (pGlobals->cxafterblock == CXSBD_AT_CURSOR_X_ORIGIN)
        pRPDev->fCursor |= RES_CUR_X_POS_AT_0;

    //
    // check for compression modes
    //
    if (!pRPDev->pfnOEMFilterGraphics)
    {
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENABLETIFF4))
        {
            pRPDev->fRMode |= PFR_COMP_TIFF;
        }
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENABLEFERLE))
        {
            pRPDev->fRMode |= PFR_COMP_FERLE;
        }
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENABLEDRC) &&
            !pPDev->pGlobals->bSendMultipleRows &&
            pRPDev->sDevPlanes == 1 && bEnoughDRCMemory(pPDev))
        {
            // For DRC we disable moving the left boundary
            //
            pRPDev->fBlockOut &= ~RES_BO_LEADING_BLNKS;
            pRPDev->fDump &= ~RES_DM_LEFT_BOUND;
            //
            // If there is a source width command we also disable
            // TRAILING blanks
            //
            if (pRPDev->fRMode & PFR_SENDSRCWIDTH)
                pRPDev->fBlockOut &= ~RES_BO_TRAILING_BLNKS;
            //
            // For DRC we disable all rules
            pRPDev->fRMode &= ~PFR_RECT_FILL;

            pRPDev->fRMode |= PFR_COMP_DRC;
        }
        if (COMMANDPTR(pPDev->pDriverInfo,CMD_ENABLEOEMCOMP))
        {
            if (pRPDev->pfnOEMCompression)
                pRPDev->fRMode |= PFR_COMP_OEM;
        }
        // for these compression modes it is more efficient to
        // disable horizontal rules code and enclosed blanks
        //
        if (pRPDev->fRMode & (PFR_COMP_TIFF | PFR_COMP_DRC | PFR_COMP_FERLE))
        {
            pRPDev->fRMode &= ~PFR_RECT_HORIZFILL;
            pRPDev->fBlockOut &= ~RES_BO_ENCLOSED_BLNKS;
        }
    }
    return TRUE;
}

//**************************************************************
BOOL
bInitColorOrder(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This routine initializes the order to print the color planes
    for those devices that specify multiple plane output. It also
    maps the appropriate color command for each color.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

--*/

{
    PCOLORMODEEX pColorModeEx;
    PLISTNODE pListNode;
    DWORD dwIndex;
    DWORD dwColorCmd;
    BYTE ColorIndex;
    INT dwPlanes = 0;
    INT iDevNumPlanes;
    PRASTERPDEV pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    // check if structure exists
    if (pPDev->pColorModeEx)
    {
        short sDrvBPP;
        sDrvBPP = (short)pPDev->pColorModeEx->dwDrvBPP;
        pRPDev->sDevBPP = (short)pPDev->pColorModeEx->dwPrinterBPP;
        pRPDev->sDevPlanes = (short)pPDev->pColorModeEx->dwPrinterNumOfPlanes;
        pRPDev->dwIPCallbackID = pPDev->pColorModeEx->dwIPCallbackID;
        //
        // calculate equivalent output pixel depth and
        // test for valid formats
        //
        if (pRPDev->sDevPlanes == 1)
        {
            if (pRPDev->sDevBPP != 1 &&
                pRPDev->sDevBPP != 8 &&
                pRPDev->sDevBPP != 24)
            {
                ERR (("Unidrv: Invalid DevBPP\n"));
                return FALSE;
            }
            pRPDev->sDrvBPP = pRPDev->sDevBPP;
        }
        else if ((pRPDev->sDevBPP == 1) &&
                (pRPDev->sDevPlanes == 3 || pRPDev->sDevPlanes == 4))
        {
            pRPDev->sDrvBPP = 4;
        }
#ifdef MULTIPLANE
        else if ((pRPDev->sDevBPP == 2) &&
                (pRPDev->sDevPlanes == 3 || pRPDev->sDevPlanes == 4))
        {
            pRPDev->CyanLevels = 2;
            pRPDev->MagentaLevels = 2;
            pRPDev->YellowLevels = 2;
            pRPDev->BlackLevels = 1;
            pRPDev->sDevBitsPerPlane = 2;
            pRPDev->sDrvBPP = 8;
        }
        else if (pRPDev->sDevPlanes > 4 && pRPDev->sDevPlanes <= 8)
        {
            pRPDev->CyanLevels = 3;
            pRPDev->MagentaLevels = 3;
            pRPDev->YellowLevels = 3;
            pRPDev->BlackLevels = 3;
            pRPDev->sDevBitsPerPlane = 1;
            pRPDev->sDrvBPP = 8;
        }
#endif
        else
            pRPDev->sDrvBPP = 0;

        // test for valid input, input must match render depth
        // or there must be a callback function
        //
        if (pRPDev->sDrvBPP != sDrvBPP &&
            (pRPDev->dwIPCallbackID == 0 ||
             pRPDev->pfnOEMImageProcessing == NULL) &&
            pPDev->ePersonality != kPCLXL &&
            pPDev->ePersonality != kPCLXL_RASTER)
        {
            ERR (("Unidrv: OEMImageProcessing callback required\n"))
            return FALSE;
        }
        //
        // if color mode we need to determine the color order to
        // send the different color planes
        //
        if (pPDev->pColorModeEx->bColor && pRPDev->sDrvBPP > 1)
        {
            //* Initialize 8BPP and 24BPP flags
            pRPDev->sDevPlanes = (short)pPDev->pColorModeEx->dwPrinterNumOfPlanes;
            if (pRPDev->sDevPlanes > 1)
            {
                iDevNumPlanes = pRPDev->sDevPlanes;

                pListNode = LISTNODEPTR(pPDev->pDriverInfo,pPDev->pColorModeEx->liColorPlaneOrder);
                while (pListNode && dwPlanes < iDevNumPlanes)
                {
                    switch (pListNode->dwData)
                    {
                    case COLOR_CYAN:
                        ColorIndex = DC_PLANE_CYAN;
                        dwColorCmd = CMD_SENDCYANDATA;
                        break;
                    case COLOR_MAGENTA:
                        ColorIndex = DC_PLANE_MAGENTA;
                        dwColorCmd = CMD_SENDMAGENTADATA;
                        break;
                    case COLOR_YELLOW:
                        ColorIndex = DC_PLANE_YELLOW;
                        dwColorCmd = CMD_SENDYELLOWDATA;
                        break;
                    case COLOR_RED:
                        ColorIndex = DC_PLANE_RED;
                        dwColorCmd = CMD_SENDREDDATA;
                        pRPDev->fColorFormat |= DC_PRIMARY_RGB;
                        break;
                    case COLOR_GREEN:
                        ColorIndex = DC_PLANE_GREEN;
                        dwColorCmd = CMD_SENDGREENDATA;
                        pRPDev->fColorFormat |= DC_PRIMARY_RGB;
                        break;
                    case COLOR_BLUE:
                        ColorIndex = DC_PLANE_BLUE;
                        dwColorCmd = CMD_SENDBLUEDATA;
                        pRPDev->fColorFormat |= DC_PRIMARY_RGB;
                        break;
                    case COLOR_BLACK:
                        ColorIndex = DC_PLANE_BLACK;
                        dwColorCmd = CMD_SENDBLACKDATA;
                        break;
#ifdef MULTIPLANE
                    // TBD
#endif                        
                    default:
                        ERR (("Invalid ColorPlaneOrder value"));
                        return FALSE;
                        break;
                    }
                    // verify the command exists
                    if (COMMANDPTR(pPDev->pDriverInfo,dwColorCmd) == NULL)
                        return FALSE;

#ifdef MULTIPLANE
                    if (iDevNumPlanes >= 6)
                    {
                        pRPDev->rgbOrder[dwPlanes] = ColorIndex+4;
                        pRPDev->rgbCmdOrder[dwPlanes] = CMD_SENDBLACKDATA;
                        dwPlanes++;
                    }
#endif                    
                    pRPDev->rgbOrder[dwPlanes] = ColorIndex;
                    pRPDev->rgbCmdOrder[dwPlanes] = dwColorCmd;
                    dwPlanes++;
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
                }
                // GPD must define all planes
                if (dwPlanes < iDevNumPlanes)
                    return FALSE;

                //* Determine DC_EXTRACT_BLK flag
                if (iDevNumPlanes == 4)
                    pRPDev->fColorFormat |= DC_EXTRACT_BLK;
            }
            else if (pRPDev->sDevPlanes != 1)
                return FALSE;

            // if we have an OEM callback then it is
            // responsible for black generation and data inversion
            //
            if (pRPDev->pfnOEMImageProcessing)
                pRPDev->fColorFormat |= DC_OEM_BLACK;

            pRPDev->fDump |= RES_DM_COLOR;
        }
        // monochrome but could have pixel depth
        else {
            pRPDev->sDevPlanes = 1;
            pRPDev->rgbOrder[0] = DC_PLANE_BLACK;
            pRPDev->rgbCmdOrder[0] = CMD_SENDBLOCKDATA;
        }
    }
    // no ColorMode so use default: monochrome mode
    else {
        pRPDev->sDrvBPP = 1;
        pRPDev->sDevBPP = 1;
        pRPDev->sDevPlanes = 1;
        pRPDev->rgbOrder[0] = DC_PLANE_BLACK;
        pRPDev->rgbCmdOrder[0] = CMD_SENDBLOCKDATA;
    }
    return TRUE;
}

//*************************************************
void
vSetHTData(
    PDEV *pPDev,
    GDIINFO *pGDIInfo
)
/*++

Routine Description:
    Fill in the halftone information required by GDI.  These are filled
    in from the GPD data or from default values.

Arguments:
    pPDev           Pointer to PDEV structure
    pGDIInfo        Pointer to GDIINFO structure

Return Value:

--*/
{
    INT         iPatID;
    PRASTERPDEV pRPDev = pPDev->pRasterPDEV;
    PHALFTONING pHalftone = pPDev->pHalftone;
    DWORD       dwType = REG_DWORD;
    DWORD       ul;
    int         iGenProfile;


    // set to spotdiameter, if zero, GDI calculates its own value
    // Set MS bit designating a percentage value * 10.
    //
    if (pPDev->pResolutionEx->dwSpotDiameter >= 10000)
    {
        pPDev->fMode |= PF_SINGLEDOT_FILTER;
        pGDIInfo->ulDevicePelsDPI = ((pPDev->pResolutionEx->dwSpotDiameter - 10000) * 10) | 0x8000;
    }
    else
        pGDIInfo->ulDevicePelsDPI = (pPDev->pResolutionEx->dwSpotDiameter * 10) | 0x8000;

    // RASDD always sets this to BLACK_DYE only
    // HT_FLAG_: SQUARE_DEVICE_PEL/HAS_BLACK_DYE/ADDITIVE_PRIMS/OUTPUT_CMY
    //
    pGDIInfo->flHTFlags   = HT_FLAG_HAS_BLACK_DYE;
    
#ifdef MULTIPLANE
    if (pRPDev->sDevBitsPerPlane)
    {
        pGDIInfo->flHTFlags |= MAKE_CMY332_MASK(pRPDev->CyanLevels,
                                                pRPDev->MagentaLevels,
                                                pRPDev->YellowLevels);
    }
#endif    
    
    // 
    // For 16 and 24bpp devices GDI will not do device color
    // mapping unless this flag is set in the GPD
    //
#ifndef WINNT_40    
    if (pPDev->pGlobals->bEnableGDIColorMapping)
        pGDIInfo->flHTFlags |= HT_FLAG_DO_DEVCLR_XFORM;
    if (pPDev->pdmPrivate->iQuality != QS_BEST &&  
        !(pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS))
    {
        pGDIInfo->flHTFlags |= HT_FLAG_PRINT_DRAFT_MODE;
    }
#endif
    // At this point we need to determine the halftoning pattern
    // to be utilized depending on whether this is a standard halftone
    // custom halftone or oem supplied dither method
    //

    // if standard halftone ID map to standard pattern size values
    //
#ifndef WINNT_40
    if (!pHalftone || pHalftone->dwHTID == HT_PATSIZE_AUTO)
    {
        if (pPDev->sBitsPixel == 1)
            iPatID = PickDefaultHTPatSize((DWORD)pGDIInfo->ulLogPixelsX,
                                          (DWORD)pGDIInfo->ulLogPixelsY);
        else if (pPDev->sBitsPixel == 8)
            iPatID = HT_PATSIZE_4x4_M;

        else if (pPDev->sBitsPixel >= 24)
            iPatID = HT_PATSIZE_8x8_M;

        else
            iPatID = HT_PATSIZE_SUPERCELL_M;
    }
    else if (pHalftone->dwHTID <= HT_PATSIZE_MAX_INDEX)
    {
        iPatID = pHalftone->dwHTID;
    }
    else
    {
        iPatID = HT_PATSIZE_USER;
    }
#else    
    if (!pHalftone || pHalftone->dwHTID == HT_PATSIZE_AUTO || pHalftone->dwHTID > HT_PATSIZE_MAX_INDEX)
    {
	    if (pPDev->sBitsPixel == 8)
    	    iPatID = HT_PATSIZE_4x4_M;

		else if (pPDev->sBitsPixel == 4 && pGDIInfo->ulLogPixelsX < 400)
			iPatID = HT_PATSIZE_6x6_M;
    
    	else
        	iPatID = PickDefaultHTPatSize((DWORD)pGDIInfo->ulLogPixelsX,
                                          (DWORD)pGDIInfo->ulLogPixelsY);
	}
	else
		iPatID = pHalftone->dwHTID;
#endif
    //
    // setup ciDevice to point to default color space based
    // on halftone method and render depth
    //
    // 22-Jan-1998 Thu 01:17:54 updated  -by-  Daniel Chou (danielc)
    //  for saving the data, we will assume gamma 1.0 and has dye correction to
    //  start with then modify as necessary
    //

    pGDIInfo->ciDevice = DefColorInfoLinear;

    if (pPDev->sBitsPixel >= 24 && pRPDev->pfnOEMImageProcessing) 
    {

        //
        // No dye correction and the gamma is linear 1.0
        //

        ZeroMemory(&(pGDIInfo->ciDevice.MagentaInCyanDye),
                   sizeof(LDECI4) * 6);

    } 
    else 
    {

        LDECI4  Gamma;


        if (pPDev->sBitsPixel >= 8) {

            Gamma = GAMMA_DEVICE_HT;

        } 
#ifndef WINNT_40        
        else if ((iPatID == HT_PATSIZE_SUPERCELL) ||
                   (iPatID == HT_PATSIZE_SUPERCELL_M)) 
        {
            Gamma = GAMMA_SUPERCELL;
        } 
#endif        
        else 
        {
            Gamma = GAMMA_DITHER;
        }

        pGDIInfo->ciDevice.RedGamma   =
        pGDIInfo->ciDevice.GreenGamma =
        pGDIInfo->ciDevice.BlueGamma  = Gamma;
    }

    //
    // If this flag is set in the registry we inform GDI halftoning
    // to ignore all color settings and pass data through raw
    // for calibration purposes
    //
    if( !EngGetPrinterData( pPDev->devobj.hPrinter, L"ICMGenProfile", &dwType,
                       (BYTE *)&iGenProfile, sizeof(iGenProfile), &ul ) &&
        ul == sizeof(iGenProfile) && iGenProfile == 1 )
    {
        pGDIInfo->ciDevice.RedGamma   =
        pGDIInfo->ciDevice.GreenGamma =
        pGDIInfo->ciDevice.BlueGamma  = GAMMA_GEN_PROFILE;
    }
    else
    {
        //
        // now modify with any GPD parameters
        //
        if ((int)pPDev->pResolutionEx->dwRedDeviceGamma >= 0)
            pGDIInfo->ciDevice.RedGamma = pPDev->pResolutionEx->dwRedDeviceGamma;
        if ((int)pPDev->pResolutionEx->dwGreenDeviceGamma >= 0)
            pGDIInfo->ciDevice.GreenGamma = pPDev->pResolutionEx->dwGreenDeviceGamma;
        if ((int)pPDev->pResolutionEx->dwBlueDeviceGamma >= 0)
            pGDIInfo->ciDevice.BlueGamma = pPDev->pResolutionEx->dwBlueDeviceGamma;
        if ((int)pPDev->pGlobals->dwMagentaInCyanDye >= 0)
            pGDIInfo->ciDevice.MagentaInCyanDye = pPDev->pGlobals->dwMagentaInCyanDye;
        if ((int)pPDev->pGlobals->dwYellowInCyanDye >= 0)
            pGDIInfo->ciDevice.YellowInCyanDye = pPDev->pGlobals->dwYellowInCyanDye;
        if ((int)pPDev->pGlobals->dwCyanInMagentaDye >= 0)
            pGDIInfo->ciDevice.CyanInMagentaDye = pPDev->pGlobals->dwCyanInMagentaDye;
        if ((int)pPDev->pGlobals->dwYellowInMagentaDye >= 0)
            pGDIInfo->ciDevice.YellowInMagentaDye = pPDev->pGlobals->dwYellowInMagentaDye;
        if ((int)pPDev->pGlobals->dwCyanInYellowDye >= 0)
            pGDIInfo->ciDevice.CyanInYellowDye = pPDev->pGlobals->dwCyanInYellowDye;
        if ((int)pPDev->pGlobals->dwMagentaInYellowDye >= 0)
            pGDIInfo->ciDevice.MagentaInYellowDye = pPDev->pGlobals->dwMagentaInYellowDye;
    }
    //
    // test for a custom pattern
    //
#ifndef WINNT_40    
    if (iPatID == HT_PATSIZE_USER)
    {
        DWORD dwX,dwY,dwPats,dwRC,dwCallbackID,dwPatSize,dwOnePatSize;
        int iSize = 0;
        PBYTE pRes = NULL;

        dwX = pHalftone->HalftonePatternSize.x;
        dwY = pHalftone->HalftonePatternSize.y;
        dwRC = pHalftone->dwRCpatternID;

        pGDIInfo->ulHTPatternSize = HT_PATSIZE_DEFAULT;

        if (dwX < HT_USERPAT_CX_MIN || dwX > HT_USERPAT_CX_MAX ||
            dwY < HT_USERPAT_CY_MIN || dwY > HT_USERPAT_CY_MAX)
        {
            ERR (("Unidrv!RMInit: Missing or invalid custom HT size\n"));
            return;
        }
        dwPats = pHalftone->dwHTNumPatterns;
        dwCallbackID = pHalftone->dwHTCallbackID;

        // calculate the size of the halftone pattern
        //
        dwOnePatSize = ((dwX * dwY) + 3) & ~3;
        dwPatSize = dwOnePatSize * dwPats;

        // test for resource ID which means the pattern is
        // in the resource dll.
        //
        if (dwRC > 0)
        {
            RES_ELEM ResInfo;
            if (!BGetWinRes(&pPDev->WinResData,(PQUALNAMEEX)&dwRC,RC_HTPATTERN,&ResInfo))
            {
                ERR (("Unidrv!RMInit: Can't find halftone resource\n"));
                return;
            }
            else if ((DWORD)ResInfo.iResLen < dwPatSize && dwCallbackID <= 0)
            {
                ERR (("Unidrv!RMInit: Invalid resource size\n"));
                return;
            }
            pRes = ResInfo.pvResData;
            iSize = ResInfo.iResLen;
        }
        else if (dwCallbackID <= 0)
        {
            ERR (("Unidrv!RMInit: no OEMHalftonePattern callback ID\n"));
            return;
        }
        //
        // test whether we need to make the OEMHalftonePattern callback
        // this will either unencrypt the resource pattern or it will
        // generate a halftone pattern on the fly.
        //
        if (dwCallbackID > 0)
        {
            PBYTE pPattern;
            // allocate memory for the callback
            //
            if ((pPattern = MemAllocZ(dwPatSize)) != NULL)
            {
                BOOL  bStatus = FALSE;

                FIX_DEVOBJ(pPDev,EP_OEMHalftonePattern);


                if (pRPDev->pfnOEMHalftonePattern)
                {
                    if(pPDev->pOemEntry)
                    {
                        if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                        {
                                HRESULT  hr ;
                                hr = HComHalftonePattern((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                            (PDEVOBJ)pPDev,pPattern,dwX,dwY,dwPats,dwCallbackID,pRes,iSize) ;
                                if(SUCCEEDED(hr))
                                    bStatus =  TRUE ;  //  cool !
                        }
                        else
                        {
                            bStatus = pRPDev->pfnOEMHalftonePattern((PDEVOBJ)pPDev,pPattern,dwX,dwY,dwPats,dwCallbackID,pRes,iSize) ;
                        }
                    }
                }


                if(!bStatus)
                {
                    MemFree (pPattern);
                    ERR (("\nUnidrv!RMInit: Failed OEMHalftonePattern call\n"));
                    return;
                }
                else
                {
                    pRes = pPattern;
                    pRPDev->pHalftonePattern = pPattern;
                }
            }
            else
            {
                ERR (("\nUnidrv!RMInit: Failed Custom Halftone MemAlloc\n"));
                return;
            }
        }
        //
        // if we still have a valid custom pattern we will now
        // update the GDIINFO structure
        //
        pGDIInfo->cxHTPat = dwX;
        pGDIInfo->cyHTPat = dwY;
        pGDIInfo->pHTPatA = pRes;
        if (dwPats == 3)
        {
            pGDIInfo->pHTPatB = &pRes[dwOnePatSize];
            pGDIInfo->pHTPatC = &pRes[dwOnePatSize*2];
        }
        else {
            pGDIInfo->pHTPatB = pRes;
            pGDIInfo->pHTPatC = pRes;
        }
    }
#endif    
    pGDIInfo->ulHTPatternSize = iPatID;
    return;
}
//*************************************************************
DWORD
PickDefaultHTPatSize(
    DWORD   xDPI,
    DWORD   yDPI
    )

/*++

Routine Description:

    This function return default halftone pattern size used for
    a particular device resolution

Arguments:

    xDPI            - Device LOGPIXELS X

    yDPI            - Device LOGPIXELS Y

Return Value:

    DWORD   HT_PATSIZE_xxxx

--*/
{
    DWORD   HTPatSize;

    //
    // use the smaller resolution as the pattern guide
    //

    if (xDPI > yDPI)
        xDPI = yDPI;

    if (xDPI >= 2400)
        HTPatSize = HT_PATSIZE_16x16_M;

    else if (xDPI >= 1800)
        HTPatSize = HT_PATSIZE_14x14_M;

    else if (xDPI >= 1200)
        HTPatSize = HT_PATSIZE_12x12_M;

    else if (xDPI >= 800)
        HTPatSize = HT_PATSIZE_10x10_M;

    else if (xDPI >= 300)
        HTPatSize = HT_PATSIZE_8x8_M;

    else
        HTPatSize = HT_PATSIZE_6x6_M;

    return(HTPatSize);
}
//*************************************************************
BOOL
bEnoughDRCMemory(
    PDEV *pPDev
    )
/*++

Routine Description:

    This function determines whether the device has sufficient
    memory to enable DRC compression.

Arguments:

    pPDev           - pointer to PDEV structure

Return Value:

    TRUE if sufficient memory, else FALSE

--*/
{
    //
    // if this is a page printer then we will require that there be enough
    // free memory to store the entire raster page at 1bpp
    //
    if (pPDev->pGlobals->printertype != PT_PAGE ||
        !(COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION)) ||
        (pPDev->pMemOption && (int)pPDev->pMemOption->dwInstalledMem >
        (pPDev->sf.szImageAreaG.cx * pPDev->sf.szImageAreaG.cy >> 3)))
    {
        return TRUE;
    }
    VERBOSE (("Unidrv: Insufficient memory for DRC\n"));
    return FALSE;
}
#ifndef DISABLE_NEWRULES
//*************************************************************
VOID
OutputRules(
    PDEV *pPDev
    )
/*++

Routine Description:

    This function outputs any rules that still remain after rendering
	the current band or page.

Arguments:

    pPDev           - pointer to PDEV structure

Return Value:

    none

--*/
{
    if (pPDev->pbRulesArray && pPDev->dwRulesCount)
    {
        PRECTL pRect;
        DWORD i;
        DRAWPATRECT PatRect;
        PatRect.wStyle = 0;     // black rectangle
        PatRect.wPattern = 0;   // pattern not used

//		DbgPrint("Black rules = %u\n",pPDev->dwRulesCount);

        for (i = 0;i < pPDev->dwRulesCount;i++)
        {
            pRect = &pPDev->pbRulesArray[i];
            PatRect.ptPosition.x = pRect->left;
            PatRect.ptPosition.y = pRect->top;
            PatRect.ptSize.x = pRect->right - pRect->left;
            PatRect.ptSize.y = pRect->bottom - pRect->top;
            if (pPDev->fMode & PF_SINGLEDOT_FILTER)
            {
                if (PatRect.ptSize.y < 2)
                    PatRect.ptSize.y = 2;
                if (PatRect.ptSize.x < 2)
                    PatRect.ptSize.x = 2;
            }
            DrawPatternRect(pPDev,&PatRect);
        }
        pPDev->dwRulesCount = 0;
    }
}
#endif
//*************************************************************
VOID
EnableMirroring(
    PDEV *pPDev,
    SURFOBJ *pso
    )
/*++

Routine Description:

    This function mirrors the data in the current band or page.

Arguments:

    pPDev           - pointer to PDEV structure
    pso             - pointer to SURFOBJ structure containing the bitmap

Return Value:

    none

--*/
{
    INT     iScanLine;
    INT     iLastY;
    INT     i;
    
    // if the surface hasn't been used then no point in mirroring it
    //
    if (!(pPDev->fMode & PF_SURFACE_USED))
        return;
        
    // precalculate necessary shared loop parameters
    //
    iScanLine = (((pso->sizlBitmap.cx * pPDev->sBitsPixel) + 31) & ~31) / BBITS;
    iLastY = pPDev->rcClipRgn.bottom - pPDev->rcClipRgn.top;

    // First test whether we need to do landscape mirroring
    // If so we will mirror the data top to bottom by swapping scan lines
    //
    if (pPDev->pOrientation && pPDev->pOrientation->dwRotationAngle != ROTATE_NONE)
    {
        BYTE ubWhite;
        INT  iTmpLastY = iLastY;
        
        // determined erase byte
        //
        if (pPDev->sBitsPixel == 4)
            ubWhite = 0x77;
        else if (pPDev->sBitsPixel == 8)
            ubWhite = (BYTE)((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex;
        else
            ubWhite = 0xff;
        
        // loop once per scan line swapping the rows
        //
        iLastY--;
        for (i = 0;i < iLastY;i++,iLastY--)
        {
            BYTE    *pBits1,*pBits2;

            pBits1 = (PBYTE)pso->pvBits + (iScanLine * i);
            pBits2 = (PBYTE)pso->pvBits + (iScanLine * iLastY);
            
            // test if bottom line has data
            //
            if (pPDev->pbRasterScanBuf[iLastY / LINESPERBLOCK] & 1)
            {
                // test if top line has data, if so swap data
                //
                if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK] & 1)
                {
                    INT j = iScanLine >> 2;
                    do {
                        DWORD dwTmp = ((DWORD *)pBits1)[j];
                        ((DWORD *)pBits1)[j] = ((DWORD *)pBits2)[j];
                        ((DWORD *)pBits2)[j] = dwTmp;
                    } while (--j > 0);
                }
                else
                {
                    CopyMemory(pBits1,pBits2,iScanLine);
                    FillMemory(pBits2,iScanLine,ubWhite);
                }
            }
            // test if top line has data
            //
            else if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK] & 1)
            {
                CopyMemory(pBits2,pBits1,iScanLine);
                FillMemory(pBits1,iScanLine,ubWhite);
            }
            // neither scan line has data but we need to erase both anyway
            //
            else
            {
                FillMemory(pBits1,iScanLine,ubWhite);
                FillMemory(pBits2,iScanLine,ubWhite);
            }
     
        }
        // set all bits since everything has been erased
        for (i = 0;i < iTmpLastY;i += LINESPERBLOCK)
        {
            pPDev->pbRasterScanBuf[i / LINESPERBLOCK] = 1;
        }            
    }
    //
    // We are doing portrait mirroring, test for 1bpp
    //
    else if (pPDev->sBitsPixel == 1)
    {
        BYTE ubMirror[256];
        INT iLastX;
        INT iShift;

        // create byte mirroring table
        //
        for (i = 0;i < 256;i++)
        {
            BYTE bOut = 0;
            if (i & 0x01) bOut |= 0x80;
            if (i & 0x02) bOut |= 0x40;
            if (i & 0x04) bOut |= 0x20;
            if (i & 0x08) bOut |= 0x10;
            if (i & 0x10) bOut |= 0x08;
            if (i & 0x20) bOut |= 0x04;
            if (i & 0x40) bOut |= 0x02;
            if (i & 0x80) bOut |= 0x01;
            ubMirror[i] = bOut;
        }
        // create shift value to re-align data
        //
        iShift = (8 - (pso->sizlBitmap.cx & 0x7)) & 0x7;
        
        // loop once per scan line and mirror left to right
        //
        for (i = 0;i < iLastY;i++)
        {
            BYTE *pBits = (PBYTE)pso->pvBits + (iScanLine * i);
            if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK])
            {
                INT j;
                INT iLastX;
                
                // test whether we need to pre-shift the data
                //
                if (iShift)
                {
                    iLastX = (pso->sizlBitmap.cx + 7) / 8;
                    iLastX--;
                    while (iLastX > 0)
                    {
                        pBits[iLastX] = (pBits[iLastX-1] << (8-iShift)) | (pBits[iLastX] >> iShift);
                        iLastX--;
                    }
                    pBits[0] = (BYTE)(pBits[0] >> iShift);
                }
                // Now we are ready to mirror the bytes
                //                
                j = 0;
                iLastX = (pso->sizlBitmap.cx + 7) / 8;
                while (j < iLastX)
                {
                    BYTE ubTmp;
                    iLastX--;
                    ubTmp = ubMirror[pBits[iLastX]];
                    pBits[iLastX] = ubMirror[pBits[j]];
                    pBits[j] = ubTmp;
                    j++;
                }
            }
        }        
    }    
    //
    // We are doing portrait mirroring, test for 4bpp
    //
    else if (pPDev->sBitsPixel == 4)
    {
        BYTE ubMirror[256];

        // create byte mirroring table
        //
        for (i = 0;i < 256;i++)
        {
            ubMirror[i] = ((BYTE)i << 4) | ((BYTE)i >> 4);
        }
        // loop once per scan line and mirror left to right
        //
        for (i = 0;i < iLastY;i++)
        {
            BYTE *pBits = (PBYTE)pso->pvBits + (iScanLine * i);
            if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK])
            {
                INT j = 0;
                INT iLastX = (pso->sizlBitmap.cx + 1) / 2;
                while (j < iLastX)
                {
                    BYTE ubTmp;
                    iLastX--;
                    ubTmp = ubMirror[pBits[iLastX]];
                    pBits[iLastX] = ubMirror[pBits[j]];
                    pBits[j] = ubTmp;
                    j++;
                }
            }
        }        
    }    
    //
    // We are doing portrait mirroring, test for 8bpp
    //
    else if (pPDev->sBitsPixel == 8)
    {
        // loop once per scan line and mirror left to right
        //
        for (i = 0;i < iLastY;i++)
        {
            BYTE *pBits = (PBYTE)pso->pvBits + (iScanLine * i);
            if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK])
            {
                INT j = 0;
                INT iLastX = pso->sizlBitmap.cx - 1;
                while (j < iLastX)
                {
                    BYTE ubTmp = pBits[iLastX];
                    pBits[iLastX] = pBits[j];
                    pBits[j] = ubTmp;
                    iLastX--;
                    j++;
                }
            }
        }        
    }    
    //
    // We are doing portrait mirroring, 24bpp
    //
    else
    {
        // loop once per scan line and mirror left to right
        //
        for (i = 0;i < iLastY;i++)
        {
            BYTE *pBits = (PBYTE)pso->pvBits + (iScanLine * i);
            if (pPDev->pbRasterScanBuf[i / LINESPERBLOCK])
            {
                INT j = 0;
                INT iLastX = (pso->sizlBitmap.cx * 3) - 3;
                while (j < iLastX)
                {
                    BYTE ubTmp[3];
                    memcpy(&ubTmp[0],&pBits[iLastX],3);
                    memcpy(&pBits[iLastX],&pBits[j],3);
                    memcpy(&pBits[j],&ubTmp,3);
                    iLastX -= 3;
                    j += 3;
                }
            }
        }        
    }    
}
//*************************************************************
PDWORD
pSetupOEMImageProcessing(
    PDEV *pPDev,
    SURFOBJ *pso
    )
/*++

Routine Description:

    This function initializes all the relevant parameters and then
    calls the OEMImageProcessing function.

Arguments:

    pPDev           - pointer to PDEV structure
    pso             - pointer to SURFOBJ structure
    pptl            - pointer to current position of band

Return Value:

    Pointer to modified bitmap if any

--*/
{
#ifndef DISABLE_SUBBANDS
    BITMAPINFOHEADER bmi;
    IPPARAMS State;
    RASTERPDEV *pRPDev;
    PBYTE               pbResult = NULL ;
    INT iStart, iEnd ,iScanLine, iLastY;

    pRPDev = pPDev->pRasterPDEV;

    //
    // initialize the state structure
    //
    State.dwSize = sizeof (IPPARAMS);
    State.bBanding = pPDev->bBanding;
    //
    // Determine the pointer to the halftone option name
    //
    if (pPDev->pHalftone)
    {
        State.pHalftoneOption =
            OFFSET_TO_POINTER(pPDev->pDriverInfo->pubResourceData,
            pPDev->pHalftone->GenericOption.loKeywordName);
    }
    else
        State.pHalftoneOption = NULL;

    //
    // Set blank band flag if this band hasn't been erased or
    // drawn on.
    if ((pPDev->fMode & PF_SURFACE_USED) && 
            ((pPDev->fMode & PF_ROTATE) ||
             (pRPDev->sDrvBPP != 0) || 
             ((LINESPERBLOCK % pRPDev->sNPins) != 0)))
    {
        CheckBitmapSurface(pso, NULL);
    }

    //
    // loop once per strip
    //
    iScanLine = (((pso->sizlBitmap.cx * pPDev->sBitsPixel) + 31) & ~31) / BBITS;
    iLastY = pPDev->rcClipRgn.bottom - pPDev->rcClipRgn.top;

if(pPDev->iBandDirection == SW_UP)
{
    iStart = iLastY;
    do
    {
        // search for contiguous sub-bands of white or non-white
        //
        PBYTE pBits;
        BYTE Mode;

        iEnd = iStart ;
        iStart = ((iEnd - 1)/ LINESPERBLOCK) * LINESPERBLOCK ;

        //  first band (end of bitmap) may be partial.

        Mode = pPDev->pbRasterScanBuf[iStart / LINESPERBLOCK];
        while (iStart)  //  not yet at start of bitmap
        {
            int  iPreview  =  iStart - LINESPERBLOCK;

            if (Mode != pPDev->pbRasterScanBuf[iPreview / LINESPERBLOCK])
                break;
            iStart = iPreview  ;
        }

        // initialize starting position of the sub-band
        //
        State.ptOffset.x = pPDev->rcClipRgn.left;
        State.ptOffset.y = pPDev->rcClipRgn.top + iStart;

        // test whether to set blank flag
        //
        if (Mode)
            State.bBlankBand = FALSE;
        else
            State.bBlankBand = TRUE;

        //
        // initialize the bitmapinfo structure
        //
        bmi.biSize = sizeof (BITMAPINFOHEADER);
        bmi.biWidth = pso->sizlBitmap.cx;
        bmi.biHeight = iEnd - iStart;
        bmi.biPlanes = 1;
        bmi.biBitCount = pPDev->sBitsPixel;
        bmi.biSizeImage = iScanLine * bmi.biHeight;
        bmi.biCompression = BI_RGB;
        bmi.biXPelsPerMeter = pPDev->ptGrxRes.x;
        bmi.biYPelsPerMeter = pPDev->ptGrxRes.y;
        bmi.biClrUsed = 0;
        bmi.biClrImportant = 0;

        // update the bitmap pointer
        //
        pBits = (PBYTE)pso->pvBits + (iScanLine * iStart);

        // update the pPDev pointer for this callback
        //
        FIX_DEVOBJ(pPDev,EP_OEMImageProcessing);

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                HRESULT  hr ;
                hr = HComImageProcessing((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                    (PDEVOBJ)pPDev,
                    pBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State, &pbResult);
                if(SUCCEEDED(hr))
                    ;  //  cool !
            }
            else
            {
                pbResult = pRPDev->pfnOEMImageProcessing(
                    (PDEVOBJ)pPDev,
                    pBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State);
            }
            if (pbResult == NULL)
            {
#if DBG
                DbgPrint ("unidrv!ImageProcessing: OEMImageProcessing returned error\n");
#endif
                break;
            }
        }
    } while (iStart  /* iEnd < iLastY */);

}
else
{

    iEnd = 0;
    do
    {
        // search for contiguous sub-bands of white or non-white
        //
        PBYTE pBits;
        BYTE Mode;
        iStart = iEnd;
        Mode = pPDev->pbRasterScanBuf[iEnd / LINESPERBLOCK];
        while (1)
        {
            iEnd += LINESPERBLOCK;
            if (iEnd >= iLastY)
                break;
            if (Mode != pPDev->pbRasterScanBuf[iEnd / LINESPERBLOCK])
                break;
        }
        //
        // limit this section to the end of the band
        //
        if (iEnd > iLastY)
            iEnd = iLastY;
            
        // initialize starting position of the sub-band
        //
        State.ptOffset.x = pPDev->rcClipRgn.left;
        State.ptOffset.y = pPDev->rcClipRgn.top + iStart;
        
        // test whether to set blank flag
        //
        if (Mode)
            State.bBlankBand = FALSE;
        else
            State.bBlankBand = TRUE;

        //
        // initialize the bitmapinfo structure
        //
        bmi.biSize = sizeof (BITMAPINFOHEADER);
        bmi.biWidth = pso->sizlBitmap.cx;
        bmi.biHeight = iEnd - iStart;
        bmi.biPlanes = 1;
        bmi.biBitCount = pPDev->sBitsPixel;
        bmi.biSizeImage = iScanLine * bmi.biHeight;
        bmi.biCompression = BI_RGB;
        bmi.biXPelsPerMeter = pPDev->ptGrxRes.x;
        bmi.biYPelsPerMeter = pPDev->ptGrxRes.y;
        bmi.biClrUsed = 0;
        bmi.biClrImportant = 0;
        
        // update the bitmap pointer
        //
        pBits = (PBYTE)pso->pvBits + (iScanLine * iStart);

        // update the pPDev pointer for this callback
        //
        FIX_DEVOBJ(pPDev,EP_OEMImageProcessing);

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                HRESULT  hr ;
                hr = HComImageProcessing((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                    (PDEVOBJ)pPDev,
                    pBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State, &pbResult);
                if(SUCCEEDED(hr))
                    ;  //  cool !
            }
            else
            {
                pbResult = pRPDev->pfnOEMImageProcessing(
                    (PDEVOBJ)pPDev,
                    pBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State);
            }
            if (pbResult == NULL)
            {
#if DBG
                DbgPrint ("unidrv!ImageProcessing: OEMImageProcessing returned error\n");
#endif            
                break;
            }
        }
    } while (iEnd < iLastY);
}
#else
    BITMAPINFOHEADER bmi;
    IPPARAMS State;
    RASTERPDEV *pRPDev;
    PBYTE               pbResult = NULL ;

    pRPDev = pPDev->pRasterPDEV;

    //
    // initialize the state structure
    //
    State.dwSize = sizeof (IPPARAMS);
    State.bBanding = pPDev->bBanding;
    //
    // Determine the pointer to the halftone option name
    //
    if (pPDev->pHalftone)
    {
        State.pHalftoneOption =
            OFFSET_TO_POINTER(pPDev->pDriverInfo->pubResourceData,
            pPDev->pHalftone->GenericOption.loKeywordName);
    }
    else
        State.pHalftoneOption = NULL;

    //
    // Set blank band flag if this band hasn't been erased or
    // drawn on.
    if (pPDev->fMode & PF_SURFACE_USED)
    {
        CheckBitmapSurface(pso, NULL);
        State.bBlankBand = FALSE;
    }
    else
        State.bBlankBand = TRUE;

    // initialize starting position of the band
    //
    State.ptOffset.x = pPDev->rcClipRgn.left;
    State.ptOffset.y = pPDev->rcClipRgn.top;
    //
    // initialize the bitmapinfo structure
    //
    bmi.biSize = sizeof (BITMAPINFOHEADER);
    bmi.biWidth = pso->sizlBitmap.cx;
    bmi.biHeight = pso->sizlBitmap.cy;
    bmi.biPlanes = 1;
    bmi.biBitCount = pPDev->sBitsPixel;
    bmi.biCompression = BI_RGB;
    bmi.biSizeImage = (((bmi.biWidth * bmi.biBitCount) + 31) & ~31) *
                            bmi.biHeight;
    bmi.biXPelsPerMeter = pPDev->ptGrxRes.x;
    bmi.biYPelsPerMeter = pPDev->ptGrxRes.y;
    bmi.biClrUsed = 0;
    bmi.biClrImportant = 0;

    // update the pPDev pointer for this callback
    //
    FIX_DEVOBJ(pPDev,EP_OEMImageProcessing);

    if(pPDev->pOemEntry)
    {
        if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
        {
                HRESULT  hr ;
                hr = HComImageProcessing((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                    (PDEVOBJ)pPDev,
                    pso->pvBits,
                    &bmi,
                    (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                    pRPDev->dwIPCallbackID,
                    &State, &pbResult);
                if(SUCCEEDED(hr))
                    ;  //  cool !
        }
        else
        {
            pbResult = pRPDev->pfnOEMImageProcessing(
                (PDEVOBJ)pPDev,
                pso->pvBits,
                &bmi,
                (PBYTE)&((PAL_DATA *)(pPDev->pPalData))->ulPalCol[0],
                pRPDev->dwIPCallbackID,
                &State);
        }
    }
#endif
    return  (PDWORD)pbResult ;
}
//******************************************************************
BOOL
RMStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    )
/*++

Routine Description:

    This function is called to allow any raster module initialization
    at DrvStartDoc time.

Arguments:

    pso         Pointer to SURFOBJ
    pDocName    Pointer to document name
    jobId       Job ID

Return Value:

    TRUE for success and FALSE for failure

--*/
{
#ifdef TIMING
    ENG_TIME_FIELDS TimeTab;
    PDEV *pPDev = (PDEV *) pso->dhpdev;
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;
    EngQueryLocalTime(&TimeTab);
    pRPDev->dwDocTiming = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
    DrvDbgPrint("Unidrv!StartDoc\n");
#endif
    return TRUE;
}

//************************ Function Header ***********************************
BOOL
RMEndDoc (
    SURFOBJ *pso,
    FLONG   flags
    )
/*++

Routine Description:

    This function is called at DrvEndDoc to allow the raster module
    to clean up any raster related initializations

Arguments:

    pso         Pointer to SURFOBJ
    FLONG       flags

Return Value:

    TRUE for success and FALSE for failure

--*/
{
#ifdef TIMING
    DWORD eTime;
    char    buf[80];
    ENG_TIME_FIELDS TimeTab;
    PDEV *pPDev = (PDEV *) pso->dhpdev;
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;
    EngQueryLocalTime(&TimeTab);
    eTime = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
    sprintf (buf,"Unidrv!EndDoc: %ld\n",eTime - pRPDev->dwDocTiming);
    DrvDbgPrint(buf);
#endif
    return TRUE;
}

//******************************************************************
BOOL
RMStartPage (
    SURFOBJ *pso
    )
/*++

Routine Description:

    This function is called to allow any raster module initialization
    at DrvStartPage time.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    return  TRUE;
}

//************************ Function Header ***********************************
BOOL
RMSendPage (
    SURFOBJ *pso
    )
/*++

Routine Description:

    This function is called at DrvSendPage to allow the raster module
    to output any raster data to the printer.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    PDEV  *pPDev;               /* Access to all that is important */
    RENDER   RenderData;        /* Rendering data passed to bRender() */
    PRASTERPDEV pRPDev;        /* raster module PDEV */

    // all we need to do now is render the bitmap (output it to the printer)
    // we must be careful however since the control module also calls this
    // function after the last band has been output in banding mode. In this
    // case we don't want to output any data
    //
    pPDev = (PDEV *) pso->dhpdev;
    pRPDev = pPDev->pRasterPDEV;

    //
    // Reset palette data
    //
    if (pPDev->ePersonality == kPCLXL_RASTER && pPDev->pVectorPDEV)
    {
        PCLXLResetPalette((PDEVOBJ)pPDev);
    }

    if (pso->iType == STYPE_BITMAP)
    {
        PDWORD pBits;
        // 
        // test whether mirroring should be enabled
        //
        if (pPDev->fMode2 & PF2_MIRRORING_ENABLED)
            EnableMirroring(pPDev,pso);
        //
        // Decide whether to make OEM callback function
        //
        if (pRPDev->pfnOEMImageProcessing && !pPDev->bBanding)
        {
            if ((pBits = pSetupOEMImageProcessing(pPDev,pso)) == NULL)
                return FALSE;
        }
        else
            pBits = pso->pvBits;

        //
        // test whether unidrv is doing the dump
        //
        if (pRPDev->sDrvBPP)
        {
            if( pRPDev->pvRenderData != NULL )
            {
                // if we are not in banding mode we need to
                // render the data for the entire page.
                //
                if (!pPDev->bBanding)
                {
                    RenderData = *(RENDER *)(pRPDev->pvRenderData);

                    if( bRenderStartPage( pPDev ) )
                    {
#ifndef DISABLE_NEWRULES
                        OutputRules(pPDev);
#endif                        
                        bRender( pso, pPDev, &RenderData, pso->sizlBitmap, pBits );
                            ((RENDER *)(pRPDev->pvRenderData))->plrWhite =  RenderData.plrWhite;
                    }
                }
                // now we clean up our structures in
                // both banding and non-banding cases
                //
                bRenderPageEnd( pPDev );
            }
        }
        return TRUE;
    }
    return FALSE;
}


//************************ Function Header ***********************************
BOOL
RMNextBand (
    SURFOBJ *pso,
    POINTL *pptl
    )
/*++

Routine Description:

    This function is called at DrvSendPage to allow the raster module
    to output any raster data to the printer.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    RASTERPDEV *pRPDev;
    PDEV  *pPDev;                       /* Access to all that is important */

    pPDev = (PDEV *) pso->dhpdev;
    pRPDev = pPDev->pRasterPDEV;

    // only output if raster band or surface is dirty
    // if not just return true
    if (pPDev->fMode & PF_ENUM_GRXTXT)
    {
        PDWORD pBits;
        // 
        // test whether mirroring should be enabled
        //
        if (pPDev->fMode2 & PF2_MIRRORING_ENABLED)
            EnableMirroring(pPDev,pso);
        //
        // Decide whether to make OEM callback function
        //
        if (pRPDev->pfnOEMImageProcessing)
        {
            if ((pBits = pSetupOEMImageProcessing(pPDev,pso)) == NULL)
                return FALSE;
        }
        else
            pBits = pso->pvBits;

        //
        // test whether unidrv is doing the dump
        //
        if (pRPDev->sDrvBPP)
        {
            if( pRPDev->pvRenderData == NULL )
                return  FALSE;

            //
            // Reset palette data
            //
            if (pPDev->ePersonality == kPCLXL_RASTER && pPDev->pVectorPDEV)
            {
                PCLXLResetPalette((PDEVOBJ)pPDev);
            }

#ifndef DISABLE_NEWRULES
            OutputRules(pPDev);
#endif                        
            if( !bRender( pso, pPDev, pRPDev->pvRenderDataTmp, pso->sizlBitmap, pBits ) )
            {
                if ( ((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite )
                    MemFree(((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite);

                ((RENDER *)(pRPDev->pvRenderData))->plrWhite =
                   ((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite = NULL;
                return(FALSE);
            }

            if ( ((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite )
                MemFree(((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite);

            ((RENDER *)(pRPDev->pvRenderData))->plrWhite =
               ((RENDER *)(pRPDev->pvRenderDataTmp))->plrWhite = NULL;

        }
    }
    return(TRUE);
}

//************************ Function Header ***********************************
BOOL
RMStartBanding (
    SURFOBJ *pso,
    POINTL *pptl
    )
/*++

Routine Description:

    Called to tell the driver to prepare for banding and return the
    origin of the first band.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    PDEV      *pPDev;           /* Access to all that is important */
    RASTERPDEV *pRPDev;         /* raster module PDEV */

    pPDev = (PDEV *) pso->dhpdev;

    pRPDev = pPDev->pRasterPDEV;   /* For our convenience */

    //
    if (pRPDev->sDrvBPP)
    {

        if( pRPDev->pvRenderData == NULL )
            return  FALSE;          /* Should not happen, nasty if it does */

        if( !bRenderStartPage( pPDev ) )
            return   FALSE;

        /* reset the render data for this band */

        *(RENDER *)(pRPDev->pvRenderDataTmp) = *(RENDER *)(pRPDev->pvRenderData);

    }
    return(TRUE);
}

//************************ Function Header ***********************************
BOOL
RMResetPDEV (
    PDEV  *pPDevOld,
    PDEV  *pPDevNew
    )
/*++

Routine Description:
    Called when an application wishes to change the output style in the
    midst of a job.  Typically this would be to change from portrait to
    landscape or vice versa.  Any other sensible change is permitted.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:
   TRUE  - device successfully reorganised
   FALSE - unable to change - e.g. change of device name.

Note:

--*/
{
    // as near as I can tell I don't need to do anything
    // for the raster module.
    return TRUE;
}

//************************ Function Header ***********************************
BOOL
RMEnableSurface (
    PDEV *pPDev
    )
/*++

Routine Description:


Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    TRUE for success and FALSE for failure
Note:

--*/
{
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;

    if (DRIVER_DEVICEMANAGED (pPDev))   // device surface
        return TRUE;

    //Initialize the RPDev Paldata.
    ASSERT(pPDev->pPalData);
    pRPDev->pPalData = pPDev->pPalData;              /* For all the others! */

    //
    // initialize render parameters if we are doing
    // the dump function
    //
    if (pRPDev->sDrvBPP)
    {
        ULONG iFormat;
        // determine the bitmap format
        switch (pRPDev->sDrvBPP)
        {
        case 1:
            iFormat = BMF_1BPP;
            break;
        case 4:
            iFormat = BMF_4BPP;
            break;
        case 8:
            iFormat = BMF_8BPP;
            break;
        case 24:
            iFormat = BMF_24BPP;
            break;
        default:
            ERR(("Unknown sBitsPixel in RMEnableSurface"));
            return FALSE;
        }

        // if these calls fail, control will call RMDisableSurface
        //
        if( !bSkipInit( pPDev ) || !bInitTrans( pPDev ) )
        {
            return  FALSE;
        }

        /*
         *   Also initialise the rendering structures.
         */

        if( !bRenderInit( pPDev, pPDev->szBand, iFormat ) )
        {
            return  FALSE;
        }
    }
    return TRUE;
}

//************************ Function Header ***********************************
VOID
RMDisableSurface (
    PDEV *pPDev
    )
/*++

Routine Description:

    This function is called at DrvDisableSurface to allow the raster module
    to cleanup any required stuff usually generated at EnableSurface time.

Arguments:

    pso         Pointer to SURFOBJ

Return Value:

    void

--*/
{
    RASTERPDEV  *pRPDev;          /* Unidrive stuff */


    pRPDev = pPDev->pRasterPDEV;

    /*
     *    Free the rendering storage.
     */
    if (pRPDev->sDrvBPP)
    {
        vRenderFree( pPDev );

        if( pRPDev->pdwTrans )
        {
            MemFree( pRPDev->pdwTrans );
            pRPDev->pdwTrans = NULL;
        }

        if( pRPDev->pdwColrSep )
        {
            MemFree( pRPDev->pdwColrSep );
            pRPDev->pdwColrSep = NULL;
        }

        if( pRPDev->pdwBitMask )
        {
            MemFree( pRPDev->pdwBitMask );
            pRPDev->pdwBitMask = NULL;
        }
    }
}

//************************ Function Header ***********************************
VOID
RMDisablePDEV (
    PDEV *pPDev
    )
/*++

Routine Description:

    Called when the engine has finished with this PDEV.  Basically
    we throw away all connections etc. then free the heap.

Arguments:

    pPDev         Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;

    /*
     *    Undo all that has been done with the PDEV.  Basically this means
     *  freeing the memory we consumed.
     */

    // test for valid raster PDEV
    if (pRPDev)
    {
        // Delete custom halftone pattern
        if (pRPDev->pHalftonePattern)
            MemFree(pRPDev->pHalftonePattern);

        // Delete the raster module PDEV
        MemFree(pRPDev);
    }

    //
    // PCLXL raster mode
    // Free XLRASTER
    //
    if (pPDev->ePersonality == kPCLXL_RASTER && pPDev->pVectorPDEV)
    {
        PCLXLFreeRaster((PDEVOBJ)pPDev);
    }
    return;
}

BOOL
RMInitDevicePal(
    PDEV        *pPDev,
    PAL_DATA    *pPal
    )
/*++

Routine Description:

    This function calculates a device palette to be download
    to the printer for planar mode devices

Arguments:

    pPDev           - pointer to PDEV structure
    pPal            - pointer to PAL_DATA structure
Return Value:

--*/
{
    int i,j;
    int RMask,GMask,BMask;
    ULONG *pPalette;
    RASTERPDEV *pRPDev;

    pRPDev = pPDev->pRasterPDEV;

    if (pPal == NULL || pRPDev == NULL || pRPDev->sDevPlanes != 3
        || pPal->wPalDev < 8 || (!(pPalette = pPal->pulDevPalCol)) )
    {
        ERR (("Unidrv!RMInitDevicePal: Invalid Parameters, pPal = %p, \
               pRPDev = %p, pRPDev->sDevPlanes = %d,pPal->wPalDev = %d,\
               pPalette = %p\n",pPal,pRPDev,pRPDev->sDevPlanes,pPal->wPalDev,\
               pPalette));

        return FALSE;
    }

    //
    // Determine which bits map to which color
    //
    for (i = 0;i < 3;i++)
    {
        switch (pRPDev->rgbOrder[i])
        {
        case DC_PLANE_CYAN:
        case DC_PLANE_RED:
            RMask = 1 << i;
            break;
        case DC_PLANE_MAGENTA:
        case DC_PLANE_GREEN:
            GMask = 1 << i;
            break;
        case DC_PLANE_YELLOW:
        case DC_PLANE_BLUE:
            BMask = 1 << i;
            break;
        }
    }
    //
    // create the palette entries
    //

    for (i = 0;i < 8;i++)
    {
        //
        // if CMY mode complement index
        //
        if (pRPDev->fColorFormat & DC_PRIMARY_RGB)
            j = i;
        else
            j = ~i;

        pPalette[i] = RGB((j & RMask) ? 255 : 0,
                              (j & GMask) ? 255 : 0,
                              (j & BMask) ? 255 : 0);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\rmdebug.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    rmdebug.h

Abstract:

    Raster module Debugging header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    02/14/97 -alvins-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _RMDEBUG_H
#define _RMDEBUG_H

#if DBG

/* Debugging Macroes */
#define IFTRACE(b, xxx)          {if((b)) {VERBOSE((xxx));}}
#define PRINTVAL( Val, format)   {\
            if (giDebugLevel <= DBG_VERBOSE) \
                DbgPrint("Value of "#Val " is "#format "\n",Val );\
            }

#define TRACE( Val )             {\
            if (giDebugLevel <= DBG_VERBOSE) \
                DbgPrint(#Val"\n");\
            }


#else  //!DBG Retail Build

/* Debugging Macroes */
#define IFTRACE(b, xxx)
#define PRINTVAL( Val, format)
#define TRACE( Val )

#endif //DBG

#endif  // !_RMDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\rastproc.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    rastproc.h

Abstract:

    Interface between Control module and Render module

Environment:

    Windows NT Unidrv driver

Revision History:

    12/05/96 -alvins-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _RASTPROC_H_
#define _RASTPROC_H_

// internal function declarations

BOOL bInitRasterPDev(PDEV *);
long lSetup8BitPalette (PRASTERPDEV, PAL_DATA *, DEVINFO *, GDIINFO *);
long lSetup24BitPalette (PAL_DATA *, DEVINFO *, GDIINFO *);

// extern interface declarations

    BOOL    RMStartDoc (SURFOBJ *,PWSTR,DWORD);

    BOOL    RMStartPage (SURFOBJ *);

    BOOL    RMSendPage (SURFOBJ *);

    BOOL    RMEndDoc (SURFOBJ *,FLONG);

    BOOL    RMNextBand (SURFOBJ *, POINTL *);

    BOOL    RMStartBanding (SURFOBJ *, POINTL *);

    BOOL    RMResetPDEV (PDEV *,PDEV  *);

    BOOL    RMEnableSurface (PDEV *);

    VOID    RMDisableSurface (PDEV *);

    VOID    RMDisablePDEV (PDEV *);

    BOOL    RMCopyBits (
        SURFOBJ *,
        SURFOBJ *,
        CLIPOBJ *,
        XLATEOBJ *,
        RECTL  *,
        POINTL *
        );

    BOOL    RMBitBlt (
        SURFOBJ    *,
        SURFOBJ    *,
        SURFOBJ    *,
        CLIPOBJ    *,
        XLATEOBJ   *,
        RECTL      *,
        POINTL     *,
        POINTL     *,
        BRUSHOBJ   *,
        POINTL     *,
        ROP4
        );

    BOOL    RMStretchBlt (
        SURFOBJ    *,
        SURFOBJ    *,
        SURFOBJ    *,
        CLIPOBJ    *,
        XLATEOBJ   *,
        COLORADJUSTMENT *,
        POINTL     *,
        RECTL      *,
        RECTL      *,
        POINTL     *,
        ULONG
        );
    BOOL    RMStretchBltROP(
        SURFOBJ         *,
        SURFOBJ         *,
        SURFOBJ         *,
        CLIPOBJ         *,
        XLATEOBJ        *,
        COLORADJUSTMENT *,
        POINTL          *,
        RECTL           *,
        RECTL           *,
        POINTL          *,
        ULONG            ,
        BRUSHOBJ        *,
        DWORD
        );

    BOOL    RMPaint(
        SURFOBJ         *,
        CLIPOBJ         *,
        BRUSHOBJ        *,
        POINTL          *,
        MIX
        );

    BOOL    RMPlgBlt (
        SURFOBJ    *,
        SURFOBJ    *,
        SURFOBJ    *,
        CLIPOBJ    *,
        XLATEOBJ   *,
        COLORADJUSTMENT *,
        POINTL     *,
        POINTFIX   *,
        RECTL      *,
        POINTL     *,
        ULONG
        );

    ULONG   RMDitherColor (PDEV *, ULONG, ULONG, ULONG *);


#endif  // !_RASTPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\render.c ===
/***************************** Module Header ********************************
 * render.c
 *      High level functions associated with rendering a bitmap to a
 *      printer.  Basic operation depends upon whether we are going to
 *      rotate the bitmap - either because the printer cannot,  or it
 *      is faster if we do it.
 *        With rotation,  allocate a chunk of memory and transpose the
 *      output bitmap into it.  Call the normal processing code,  but
 *      with this allocated memory and new fake bitmap info.  After
 *      processing this chunk,  transpose the next and process.  Repeat
 *      until the entire bitmap has been rendered.  Free the memory, return.
 *        Without rotation,  simply pass the bitmap onto the rendering
 *      code,  to process in one hit.
 *
 *
 *  Copyright (C) 1991 - 1999, Microsoft Corporation
 *
 ***************************************************************************/

#include        "raster.h"
#include        "compress.h"
#include        "rmrender.h"
#include        "fontif.h"
#include        "rmdebug.h"
#include        "xlraster.h"

/*
 *   Constants used to calculate the amount of memory to request if we
 *  need to transpose the engine's bitmap before sending to the printer.
 *  If at least one head pass will fit within the the TRANSPOSE_SIZE
 *  buffer,  then request this amount of storage.  If not,  calculate how
 *  much is needed and request that much.
 */

#define TRANSPOSE_SIZE          0x20000         /* 128k */


//used when we can grow the block height
#define DEF_BLOCK_SIZE          0x08000         /* 32k  */
#define MAX_BLOCK_SIZE          0x40000         /* 256k */



/*
 *   Set a limit to the number of interlaced lines that we can print.
 *  Interlacing is used to increase the resolution of dot matrix printers,
 *  by printing lines in between lines.  Typically the maximum interlace
 *  will be 2,  but we allow more just in case.  This size determines the
 *  size of an array allocated on the stack.  The array is of ints,  so
 *  there is not much storage consumed by setting this high a value.
 */
#define MAX_INTERLACE   10      /* Dot matrix style interlace factor */

/*
 *   Local function prototypes.
 */

BOOL  bRealRender( PDEV *, DWORD *, RENDER * );
BOOL  bOnePassOut( PDEV *, BYTE *, RENDER * );
BOOL  bOneColourPass( PDEV *, BYTE *, RENDER * );
INT   iLineOut( PDEV *, RENDER *, BYTE *, INT, INT );
void  vInvertBits( DWORD *, INT );
//void  vFindWhiteInvertBits ( RASTERPDEV *, RENDER *, DWORD *);
BOOL  bLookAheadOut( PDEV *, INT, RENDER *, INT );

#ifdef TIMING
#include <stdio.h>
void  DrvDbgPrint(
    char * pch,
    ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, pch);

    EngDebugPrint("",pch,ap);

    va_end(ap);
}
#endif
/************************ Function Header ***********************************
 * bRenderInit
 *      Called during DrvEnableSurface time - we initialise a RENDER_DATA
 *      structure which will be used for the duration of this surface.
 *
 * RETURNS:
 *      TRUE/FALSE,  FALSE means a minidriver problem or no memory.
 *
 * HISTORY:
 *  Monday November 29 1993     -by-    Norman Hendley   [normanh]
 *      Implement multiple scanline printing; fixed & variable block height.
 *
 *  10:58 on Tue 10 Nov 1992    -by-    Lindsay Harris   [lindsayh]
 *      Moved from start of bRender() - second incarnation.
 *
 ****************************************************************************/

BOOL
bRenderInit( pPDev, sizl, iFormat )
PDEV   *pPDev;                /* Our key to the universe */
SIZEL   sizl;                 /* Size of processing band, <= sizlPage */
INT     iFormat;              /* GDI bitmap format */
{

    INT        cbOutBand;       /* Bytes per output band: based on # pins */
    INT        cbOneBlock;      /* Bytes per minimum sized block if block variable */
    INT        iBPP;            /* Bits per pel - expect 1 or 4 */
    INT        iIndex;          /* Loop paramter */
    INT        iBytesPCol;      /* Bytes per column - only for colour */

    RASTERPDEV   *pRPDev;         /* The unidrive PDEV - printer details */

    RENDER    *pRD;             /* Miscellaneous rendering data */


#ifdef TIMING
    ENG_TIME_FIELDS TimeTab;
    pRPDev = pPDev->pRasterPDEV;
    EngQueryLocalTime(&TimeTab);
    pRPDev->dwTiming = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
#endif
    ASSERTMSG(!(sizl.cx == 0 || sizl.cy == 0),("unidrv!bRenderInit - null shadow bitmap\n"));

    /*
     *    Allocate storage for our RENDER structure,  then set it all to
     *  zero,  so that it is in a known safe state.
     */

    pRPDev = pPDev->pRasterPDEV;
    if( !(pRD = (RENDER *) MemAllocZ(
            ( pPDev->bBanding) ? sizeof(RENDER) * 2 : sizeof( RENDER ))))
        return   FALSE;

    pRPDev->pvRenderData = pRD;

    pRPDev->pvRenderDataTmp = ( pPDev->bBanding ) ? pRD+1 : NULL;

    /*
     *  Various operations depend upon what format bitmap we have.  So
     *  now is the time to set this all up.
     */
    pRD->dwDevWhiteIndex = 0;
    switch( iFormat )
    {
    case  BMF_1BPP:
        iBPP = 1;
        pRD->bWhiteLine = bIsLineWhite;
        pRD->bWhiteBand = bIsBandWhite;
        pRD->ubFillWhite = 0;
        pRD->vLtoPTransFn = vTrans8N;
        break;

    case  BMF_4BPP:
        iBPP = 4;
        if ((pRPDev->fColorFormat & DC_OEM_BLACK) &&
           !(pRPDev->fColorFormat & DC_PRIMARY_RGB))
        {
            pRD->bWhiteLine = bIsLineWhite;
            pRD->bWhiteBand = bIsBandWhite;
            pRD->ubFillWhite = 0;
        }
        else
        {
            if (pRPDev->fColorFormat & DC_PRIMARY_RGB)
                pRD->dwDevWhiteIndex = 0x77777777;
            pRD->bWhiteLine = bIsRGBLineWhite;
            pRD->bWhiteBand = bIsRGBBandWhite;
            pRD->ubFillWhite = 0x77;
        }
        pRD->vLtoPTransFn = vTrans8N4BPP;
        break;

    case  BMF_8BPP:
        iBPP = 8;
        pRD->bWhiteLine = bIs8BPPLineWhite;
        pRD->bWhiteBand = bIs8BPPBandWhite;
        pRD->dwDevWhiteIndex = pRD->ubFillWhite = (BYTE)pRPDev->pPalData->iWhiteIndex;
        pRD->dwDevWhiteIndex |= pRD->dwDevWhiteIndex << 8;
        pRD->dwDevWhiteIndex |= pRD->dwDevWhiteIndex << 16;
        pRD->vLtoPTransFn = vTrans8BPP;
        break;

    case  BMF_24BPP:
        iBPP = 24;
        pRD->bWhiteLine = bIs24BPPLineWhite;
        pRD->bWhiteBand = bIs24BPPBandWhite;
        pRD->ubFillWhite = 0xff;
        pRD->dwDevWhiteIndex = ~(DWORD)0;
        pRD->vLtoPTransFn = vTrans24BPP;
        break;

    default:
#if DBG
        DbgPrint( "Unidrv!bRender: not 1, 4, 8 or 24 bits per pel bitmap\n" );
#endif
        SetLastError( ERROR_INVALID_PARAMETER );

        return  FALSE;
    }

    pRD->iBPP = iBPP;

    // If there is no Y movement commands we need to send every scan
    // so we don't want to find white lines
    // PCLXL GPD files don't have YMOVE commands. But it needs to find white
    // lines.
    if (pPDev->arCmdTable[CMD_YMOVERELDOWN] == NULL &&
        pPDev->arCmdTable[CMD_YMOVEABSOLUTE] == NULL &&
        pPDev->arCmdTable[CMD_SETLINESPACING] == NULL &&
        pPDev->ePersonality != kPCLXL_RASTER)
    {
        pRD->bWhiteLine = pRD->bWhiteBand = bIsNeverWhite;
        pRPDev->fBlockOut |= RES_BO_NO_YMOVE_CMD;
    }

    // initialize bTTY for TTY device
    pRD->PrinterType = pPDev->pGlobals->printertype;

    if( pRPDev->sMinBlankSkip == 0 || iBPP == 24)
    {
        /*  Presume this means skip should not be performed.  */
        pRPDev->fBlockOut &= ~RES_BO_ENCLOSED_BLNKS;
    }

    pRD->iCursor = pRPDev->fCursor;

    pRD->iFlags = 0;           /* Nothing set,  yet */
    pRD->fDump = pRPDev->fDump;
    pRD->Trans.pdwTransTab = pRPDev->pdwTrans;
    pRD->pdwBitMask = pRPDev->pdwBitMask;
    pRD->pdwColrSep = pRPDev->pdwColrSep;       /* Colour translation */

    pRD->ix = sizl.cx;
    pRD->iy = sizl.cy;

    pRD->iSendCmd = CMD_SENDBLOCKDATA;  //CMD_RES_SENDBLOCK;

    pRD->cBLine = pRD->ix * iBPP;             /* Bits in scanline */
    pRD->cDWLine = (pRD->cBLine + DWBITS - 1) / DWBITS;
    pRD->cBYLine = pRD->cDWLine * DWBYTES;

    pRD->iPassHigh = pRPDev->sNPins;

    // Derryd   : Minidriver Callback
    if (pRPDev->fRMode & PFR_BLOCK_IS_BAND )   //means callback wants entire band as one block
    {
        //don't want any stripping, because would mean creating new buffers
         pRPDev->fBlockOut &= ~(RES_BO_LEADING_BLNKS |
                                             RES_BO_TRAILING_BLNKS | RES_BO_ENCLOSED_BLNKS);
         pRD->fDump &= ~RES_DM_LEFT_BOUND;
         pRD->iPassHigh = pRD->iy ;
    }
    // end

    if (pPDev->ePersonality == kPCLXL_RASTER)
    {
        pRPDev->fBlockOut |= RES_BO_LEADING_BLNKS | RES_BO_TRAILING_BLNKS;
        pRPDev->fBlockOut &= ~RES_BO_ENCLOSED_BLNKS;
    }

    //Set the key fields which enable us print multiple scanlines

    if (pRD->fDump & RES_DM_GDI)   //GDI style graphics
    {
        // No interlacing on these devices
        pRD->iInterlace = 1;

        // iHeight is fixed & the minimum size block we can print
        pRD->iHeight= pRD->iPassHigh;

        //iNumScans can grow if device allows it.
        pRD->iNumScans= pRD->iHeight;

        //in case minidriver developer sets otherwise
        //Existing code relies on this being one for GDI style graphics
        pRD->iBitsPCol = 1;
    }
    else    //Old dot matrix column style graphics
    {
        pRD->iBitsPCol = pRPDev->sPinsPerPass;
        pRD->iInterlace = pRD->iPassHigh / pRD->iBitsPCol;

        // questionable choice, but enables easier checking later
        pRD->iNumScans= 1;

        //our one constant between graphics modes
        pRD->iHeight= pRD->iBitsPCol;
    }


    pRD->iPosnAdv = pRD->iHeight;  // can be negative


    if( pRD->iInterlace > MAX_INTERLACE )
    {
#if DBG
        DbgPrint( "unidrv!bRenderInit: Printer Interlace too big to handle\n" );
#endif
        SetLastError( ERROR_INVALID_PARAMETER );

        return   FALSE;
    }

    // We'll need to scan the bitmap in blocks rather than single lines
    //
    if (pRD->iNumScans > 1)
         pRD->bWhiteLine = pRD->bWhiteBand;

    /*
     *   Calculate the size needed for the output transpose buffer.  This
     *  is the buffer used to convert the data into the pin order needed
     *  for dot matrix printers.
     */

    if( pPDev->fMode & PF_ROTATE )
    {
        /*   We do the rotation,  so the Y dimension is the one to use. */
        cbOutBand = pRD->iy;
    }
    else
        cbOutBand = pRD->ix;           /* Format as it comes in */


    //used for dangling scanline scenario
    cbOneBlock = ((cbOutBand * iBPP + DWBITS - 1) / DWBITS) *
                   DWBYTES * pRD->iHeight;



    // In this case we don't know how large our final blocks will be.
    // Set a reasonable limit of 32k & use that for compression & white
    // space stripping buffers.
    // Calculate what the corresponding max number of scanlines should be.

    if (pRPDev->fBlockOut & RES_BO_MULTIPLE_ROWS)
    {
        INT tmp = ((cbOutBand * iBPP + DWBITS - 1) / DWBITS) * DWBYTES;
        cbOutBand = pPDev->pGlobals->dwMaxMultipleRowBytes;
        if (cbOutBand < tmp)
            cbOutBand = DEF_BLOCK_SIZE;
        else if (cbOutBand > MAX_BLOCK_SIZE)
            cbOutBand = MAX_BLOCK_SIZE;
        pRD->iMaxNumScans = cbOutBand / tmp;
    }
    else
    {
        pRD->iMaxNumScans = pRD->iHeight;
        cbOutBand = cbOneBlock;
    }

    //
    // If each data byte needs to be mirrored before output
    // we will generate the table here
    //
    if (pRPDev->fBlockOut & RES_BO_MIRROR)
    {
        INT i;
        if ((pRD->pbMirrorBuf = MemAlloc(256)) == NULL)
            return FALSE;
        for (i = 0;i < 256;i++)
        {
            BYTE bOut = 0;
            if (i & 0x01) bOut |= 0x80;
            if (i & 0x02) bOut |= 0x40;
            if (i & 0x04) bOut |= 0x20;
            if (i & 0x08) bOut |= 0x10;
            if (i & 0x10) bOut |= 0x08;
            if (i & 0x20) bOut |= 0x04;
            if (i & 0x40) bOut |= 0x02;
            if (i & 0x80) bOut |= 0x01;
            pRD->pbMirrorBuf[i] = bOut;
        }
    }

    //
    // time to do more color depth specific calculations
    //

    switch( iBPP )
    {
    case  4:              /* 4 bits per pel - printer is planar */

        /*  Colour, so select the colour rendering function */
        pRD->bPassProc = bOneColourPass;
        pRD->Trans.pdwTransTab = pRPDev->pdwColrSep;

        //
        // map the color order to the required data offset for planar data
        // rgbOrder valid values are emum {none,r,g,b,c,m,y,k}
        //
        iBytesPCol = (pRD->iBitsPCol + BBITS - 1) / BBITS;
        {
            INT offset  = (pRPDev->fColorFormat & DC_PRIMARY_RGB) ? 1 : 4 ;

            for( iIndex = 0; iIndex < COLOUR_MAX; ++iIndex )
            {
                INT tmp = pRPDev->rgbOrder[iIndex] - offset;

                pRD->iColOff[ iIndex ] = iBytesPCol * (COLOUR_MAX - 1 - tmp);
            }
        }
        pRD->pbColSplit = MemAlloc( cbOutBand / 4 );
        if( pRD->pbColSplit == 0 )
            return  FALSE;

        //
        // If we need to send every color plane we must disable LEADING and ENCLOSED
        // white space removal for 4bpp. However, as long as we're not sending RGB data
        // we can still enable TRAILING white space removal.
        //
        if (pRPDev->fColorFormat & DC_SEND_ALL_PLANES)
        {
            pRD->iFlags |= RD_ALL_COLOUR;
            pRD->fDump &= ~RES_DM_LEFT_BOUND;

            if (pRPDev->fColorFormat & DC_PRIMARY_RGB)
                pRPDev->fBlockOut &= ~(RES_BO_LEADING_BLNKS | RES_BO_ENCLOSED_BLNKS | RES_BO_TRAILING_BLNKS);
            else
                pRPDev->fBlockOut &= ~(RES_BO_LEADING_BLNKS | RES_BO_ENCLOSED_BLNKS);
        }

        break;

    case  1:                  /* 1 bit per pel - monochrome */
    case  8:                  /* Seiko special - 8 bits per pel */

        pRD->bPassProc = bOnePassOut;
        pRD->Trans.pdwTransTab = pRPDev->pdwTrans;
        pRD->pbColSplit = 0;           /* No storage allocated either! */

        break;

    case 24:

        pRD->bPassProc = bOnePassOut;
        pRD->Trans.pdwTransTab = NULL;
        pRD->pbColSplit = 0;           /* No storage allocated either! */

        break;
    }

    /*
     *     There are potentially 2 transpose operations.  For printers
     *  which print more than one line per pass,  AND which require the
     *  data in column order across the page (this defines dot matrix
     *  printers),  we need to transpose per output head pass.  This is
     *  not required for devices like laser printers,  which require
     *  the data one scan line at a time.
     *     Note also that this operation is unrelated to the larger
     *  question of rotating the PAGE image before rendering - for sending
     *  a landscape image to a printer that can only print portrait mode.
     */


    if (pRD->fDump & RES_DM_GDI)   // GDI style graphics
    {

        if( iBPP == 4 )
        {
            /*  Paintjet style printer - need to colour separate  */
            pRD->vTransFn = vTransColSep;
        }
        else
        {
            /*   LaserJet style printer - one pin per head pass */
            pRD->vTransFn = 0;         /* Nothing to call */
        }
        //This allows us use iIsBandWhite with multi scanline printing
        pRD->iTransHigh = pRD->iHeight;
    }
    else
    {
        /*
         *   General dot matrix case.   Apart from selecting an active
         * transpose function,  we must allocate a transpose buffer;
         * this is required for fiddling with the bit order in the lines
         * of data to be sent to the printer.
         */

        pRD->iTransWide = pRD->ix * iBPP;
        pRD->iTransHigh = pRD->iBitsPCol;
        pRD->iTransSkip = (pRD->iTransHigh + BBITS - 1) / BBITS;

        /*  How to change the address pointer during transpose operations */
        pRD->cbTLine = pRD->cDWLine * DWBYTES * pRD->iInterlace;

        if( pRD->iBitsPCol == BBITS )
        {
            /*
             *   When the printer has 8 pins,  we have a special transpose
             *  function which is faster than the more general case.
             *  So,  use that one!
             */
            pRD->vTransFn = vTrans8x8;
        }
        else if (pRD->PrinterType != PT_TTY)
            pRD->vTransFn = vTrans8N;          /* The general case */
        else
            pRD->vTransFn = NULL;          /* Txtonly no need to transpose */
    }

    if( pRD->vTransFn )
    {
        /*
         *    Determine the amount of memory needed for the transpose buffer.
         * The scan lines are DWORD aligned,  but there may be any number of
         * scan lines involved.  The presumption is that the output of
         * the transpose function will be packed on byte boundaries,  so
         * storage size only needs to be rounded up to the nearest byte size.
         */

        if( !(pRD->pvTransBuf = MemAlloc( cbOutBand )) )
            return  FALSE;
    }
    else
        pRD->pvTransBuf = 0;           /* No store, nothing to free */


    pRD->iyBase = 0;           /* When multiple passes are required */
    pRD->ixOrg = 0;            /* Graphics origin - laserjet style */

    //We need a buffer so we can strip leading and/or trailing white space
    //on multiple scan line devices.
    //We also need to set up a buffer to mask non-interesting data at end
    //of page if ScanLines_Left < iNumScans
    //This is not a concern for old dot matrix style graphics as the
    //transpose code takes care of it.
    if ( ((pRD->iNumScans > 1) || (pRPDev->fBlockOut & RES_BO_MULTIPLE_ROWS))
                                && (!(pRPDev->fRMode & PFR_BLOCK_IS_BAND ) ))
    {
        if ( !(pRD->pStripBlanks = MemAlloc(cbOutBand)))
            return FALSE;
        if (pRD->iNumScans > 1)
            if ( !(pRD->pdwTrailingScans = MemAlloc( cbOneBlock)) )
                 return  FALSE;
    }

    //
    // We need to determine which compression modes are enabled
    //
    if (pRPDev->fRMode & PFR_COMP_TIFF)
    {
        pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_ENABLETIFF4;
    }
    if (pRPDev->fRMode & PFR_COMP_FERLE)
    {
        pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_ENABLEFERLE;
    }
    if (pRPDev->fRMode & PFR_COMP_DRC)
    {
        pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_ENABLEDRC;
    }
    if (pRPDev->fRMode & PFR_COMP_OEM)
    {
        pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_ENABLEOEMCOMP;
    }
    //
    // if compression is available we need to allocate a buffer for
    // each active compression type
    //
    if (pRD->dwNumCompCmds)
    {
        INT i = pRD->dwNumCompCmds;
        //
        // calculate the size for the buffers
        //
        pRD->dwCompSize = cbOutBand + (cbOutBand >> 5) + COMP_FUDGE_FACTOR;

        //
        // if there is FERLE or OEM compression we can enable
        // no compression as a valid compression type
        //
        if (pRPDev->fRMode & (PFR_COMP_FERLE | PFR_COMP_OEM))
        {
            if (COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION))
            {
                pRD->pdwCompCmds[pRD->dwNumCompCmds++] = CMD_DISABLECOMPRESSION;
            }
            //
            // need to allocate a larger buffer for RLE or OEM compression if
            // no compression is not an option since it must have enough space
            //
            else
                pRD->dwCompSize = cbOutBand + (cbOutBand >> 1) + COMP_FUDGE_FACTOR;
        }

        //
        // loop once per compression type to allocate buffers
        //
        while (--i >= 0)
        {
            // allocate compression buffer
            //
            pRD->pCompBufs[i] = MemAlloc (pRD->dwCompSize);
            if (!pRD->pCompBufs[i])
                return FALSE;
            //
            // if delta row, allocate buffer for previous row
            // and initialize it to zero assuming blank row
            //
            if (pRD->pdwCompCmds[i] == CMD_ENABLEDRC)
            {
                pRD->pDeltaRowBuffer = MemAlloc(cbOutBand);
                if (!pRD->pDeltaRowBuffer)
                    return FALSE;
            }
        }
    }
    pRD->dwLastCompCmd = CMD_DISABLECOMPRESSION;
    /*
     *    Adjustments to whether we rotate the bitmap, and if so, which way.
     */

    if( pPDev->fMode & PF_ROTATE )
    {
        /*   Rotation is our responsibility  */

        if( pPDev->fMode & PF_CCW_ROTATE90 )
        {
            /*   Counter clockwise rotation - LaserJet style */
            pRD->iyPrtLine = pPDev->sf.szImageAreaG.cx - 1;
            pRD->iPosnAdv = -pRD->iPosnAdv;
            pRD->iXMoveFn = YMoveTo;
            pRD->iYMoveFn = XMoveTo;
        }
        else
        {
            /*   Clockwise rotation - dot matrix style */
            pRD->iyPrtLine = 0;
            pRD->iXMoveFn = XMoveTo;
            pRD->iYMoveFn = YMoveTo;
        }
    }
    else
    {
        /*  No rotation: either portrait, or printer does it */
        pRD->iyPrtLine = 0;
        pRD->iXMoveFn = XMoveTo;
        pRD->iYMoveFn = YMoveTo;
    }
    pRD->iyLookAhead = pRD->iyPrtLine;       /* For DeskJet lookahead */

    /*
     *    When we hit the lower level functions, we want to know how many
     *  bytes are in the buffer of stuff to be sent to the printer.  This
     *  depends upon the number of bits per pel,  number of pels and the
     *  the number of scan lines processed at the same time.
     *     The only oddity is that when we have a 4 BPP device, the
     *  planes are split before we get to the lowest level, and so we
     *  we need to reduce the size by 4 to obtain the real length.
     */


    // Note when printing a block of scanlines iMaxBytesSend will be the max byte
    // count for each scanline, not of the block , which is dword aligned.

    pRD->iMaxBytesSend = (pRD->cBLine * pRD->iBitsPCol + BBITS - 1) / BBITS;

    if( iBPP == 4 )
        pRD->iMaxBytesSend = (pRD->iMaxBytesSend + 3) / 4;



    return   TRUE;             /* Must be OK if we made it this far */

}


/************************ Function Header *********************************
 * bRenderStartPage
 *      Called at the start of a new page.  This is mostly to assist in
 *      banding,   where much of the per page initialisation would be
 *      done more than once.
 *
 * RETURNS:
 *      TRUE/FALSE,   FALSE largely being failure to allocate memory.
 *
 * HISTORY:
 *  09:42 on Fri 19 Feb 1993    -by-    Lindsay Harris   [lindsayh]
 *      First incarnation, to solve some banding problems.
 *
 ***************************************************************************/

BOOL
bRenderStartPage( pPDev )
PDEV   *pPDev;                  /* Access to everything */
{
#ifndef DISABLE_RULES
    RASTERPDEV   *pRPDev;


    pRPDev = pPDev->pRasterPDEV;


    /*
     *    If the printer can handle rules,  now is the time to initialise
     *  the rule finding code.
     */

    if( pRPDev->fRMode & PFR_RECT_FILL )
        vRuleInit( pPDev, pRPDev->pvRenderData );
#endif
    return  TRUE;
}



/************************ Function Header *********************************
 * bRenderPageEnd
 *      Called at the end of rendering a page.  Basically frees up the
 *      per page memory,  cleans up any dangling bits and pieces, and
 *      otherwise undoes vRenderPageStart.
 *
 * RETURNS:
 *      TRUE/FALSE,   FALSE being a failure of memory freeing operations.
 *
 * HISTORY:
 *  15:16 on Fri 09 Apr 1993    -by-    Lindsay Harris   [lindsayh]
 *      White text support.
 *
 *  09:44 on Fri 19 Feb 1993    -by-    Lindsay Harris   [lindsayh]
 *      First incarnation.
 *
 **************************************************************************/

BOOL
bRenderPageEnd( pPDev )
PDEV   *pPDev;
{
#ifndef DISABLE_RULES
    RASTERPDEV *pRPDev = pPDev->pRasterPDEV;

    /*    Finish up with the rules code - includes freeing memory  */
    if( pRPDev->fRMode & PFR_RECT_FILL )
        vRuleEndPage( pPDev );
#endif
    return  TRUE;
}


/************************ Function Header ***********************************
 * vRenderFree
 *      Free up any and all memory used by rendering.  Basically this is
 *      the complementary function to bRenderInit().
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 *  12:46 on Tue 10 Nov 1992    -by-    Lindsay Harris   [lindsayh]
 *      Removed from bRender() when initialisation code was moved out.
 *
 *****************************************************************************/

void
vRenderFree( pPDev )
PDEV   *pPDev;            /* All that we need */
{

    /*
     *   First verify that we have a RENDER structure to free!
     */

    RENDER   *pRD;        /*  For our convenience */
    PRASTERPDEV pRPDev = pPDev->pRasterPDEV;

    if( pRD = pRPDev->pvRenderData )
    {
        if( pRD->pvTransBuf )
        {
            /*
             *    Dot matrix printers require a transpose for each print head
             *  pass,  so we now free the memory used for that.
             */

            MemFree ( pRD->pvTransBuf );
        }

        if( pRD->pbColSplit )
            MemFree ( pRD->pbColSplit );
        if( pRD->pStripBlanks )
            MemFree ( pRD->pStripBlanks );

        if( pRD->pdwTrailingScans)
            MemFree ( pRD->pdwTrailingScans );

        if (pRD->pbMirrorBuf)
            MemFree (pRD->pbMirrorBuf);

        if( pRD->plrWhite)
        {
//            WARNING(("Freeing plrWhite in vRenderFree\n"));
            MemFree ( pRD->plrWhite );
        }
        // free compression buffers
        //
        if (pRD->dwNumCompCmds)
        {
            DWORD i;
            for (i = 0;i < pRD->dwNumCompCmds;i++)
            {
                if (pRD->pCompBufs[i])
                    MemFree (pRD->pCompBufs[i]);
            }
            if (pRD->pDeltaRowBuffer)
                MemFree(pRD->pDeltaRowBuffer);
        }
        MemFree ( (LPSTR)pRD );
        pRPDev->pvRenderData = NULL;       /* Won't do it again! */
    }

#ifndef DISABLE_RULES
    if( pRPDev->fRMode & PFR_RECT_FILL )
        vRuleFree( pPDev );             /*  Could do this in DisableSurface */
#endif


    return;

}

/************************ Function Header ***********************************
 * bRender
 *      Function to take a bitmap and render it to the printer.  This is the
 *      high level function that basically hides the requirement of
 *      bitmap transposing from the real rendering code.
 *
 * Auguments
 *  SURFOBJ *pso;           Surface object
 *  PDEV    *pPDev;         Our PDEV:  key to everything
 *  RENDER  *pRD;           The RENDER structure of our dreams
 *  SIZEL    sizl;          Bitmap size
 *  DWORD   *pBits;         Actual data to process
 *
 *  This code still has a lot of room for optimization.  The current
 *  implementation makes multiple passes over the entire bitmap.  This
 *  guarantees that there will rarely be an internal (8K or 16K) or
 *  external (64K to 256K) cache hit slowing things down significantly.
 *  Any possiblity to make all passes a count of scans totaling
 *  8K (minus code) or less will have significant performance advantages.
 *  Also attempting to avoid writes will have significant advantages.
 *
 *  As a first pass at attempting this, the HP laserjet code has been
 *  optimized to merge the invertion pass in with the rule processing
 *  pass along with the detection of blank scans.  It also eliminates
 *  the inversion of inverting (writing) the left and right edges of
 *  scans that are white.  It processes the scans in 34 scan bands which
 *  will have great cache effects if the area between the left and
 *  right edges of non white data total less than 4K to 6K and reasonable
 *  cache effects in all cases since it at least stay in the external
 *  cache.  In the future, this code should also be modified to ouput
 *  the scans as soon as it is done processing the rules for each band.
 *  Currently it processes all scans on the page for rules and then
 *  calls the routine to output the scans.  This would trully make it
 *  a one pass alogrithm.
 *
 *  As of 12/30/93, only the HP laserjets have been optimized in this way.
 *  All raster printers could probably be optimized particularly when
 *  any transposing is necessary, detecting the left and right edges
 *  of scans that are white.  Transposing is expensive.  It is probably
 *  less important for dot matrix printers that take so long to output
 *  but it is still burning up CPU time that might be better served
 *  giving a USER bet responsiveness from apps while printing in the
 *  back ground.
 *
 *  The optimizations to the HP LaserJet had the following results.  All
 *  numbers are in terms of number of instructions and were pretty closely
 *  matched with total times to render an entire 8.5 X 11 300dpi page.
 *
 *                    OLD       OPTIMIZED
 *  Blank page      8,500,000     950,000
 *  full text page 15,500,000   8,000,000
 *
 *
 * RETURNS:
 *      TRUE for successful completion,  else FALSE.
 *
 * HISTORY:
 *  30-Dec-1993 -by-  Eric Kutter [erick]
 *      optimized for HP laserjet
 *
 *  14:23 on Tue 10 Nov 1992    -by-    Lindsay Harris   [lindsayh]
 *      Split up for journalling - initialisation moved up above.
 *
 *  16:11 on Fri 11 Jan 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it,  before DDI spec'd on how we are called.
 *
 ****************************************************************************/

BOOL
bRender(
    SURFOBJ *pso,
    PDEV    *pPDev,
    RENDER  * pRD,
    SIZEL   sizl,
    DWORD   *pBits )
{

    BOOL       bRet;            /* Return value */
    INT        iBPP;            /* Bits per pel - expect 1 or 4 */

    RASTERPDEV   *pRPDev;         /* The unidrive PDEV - printer details */

#ifdef TIMING
    ENG_TIME_FIELDS TimeTab;
    DWORD sTime,eTime;

    pRPDev = pPDev->pRasterPDEV;
    EngQueryLocalTime(&TimeTab);
    sTime = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
    {
        char buf[80];
        sprintf (buf,"Unidrv!bRender: GDI=%d, %dx%dx%d\n",
            sTime-pRPDev->dwTiming,sizl.cx,sizl.cy,pRD->iBPP);
        DrvDbgPrint(buf);
    }
#else
    pRPDev = pPDev->pRasterPDEV;
#endif

    // if all scan lines need to be output then we need to
    // make sure we don't send the extra scan lines at the
    // end of the last band
    //
    if (pRPDev->fBlockOut & RES_BO_NO_YMOVE_CMD)
    {
        if (!(pPDev->fMode & PF_ROTATE))
        {
            if ((pRD->iyPrtLine + sizl.cy) > pPDev->rcClipRgn.bottom)
                sizl.cy = pPDev->rcClipRgn.bottom - pRD->iyPrtLine;
        }
    }
    //
    // if this band is blank we will update our position
    // and then just return
    //
    else if (!(pPDev->fMode & PF_SURFACE_USED) &&
          (pRD->PrinterType == PT_PAGE || !pPDev->iFonts))
    {
        if (pPDev->fMode & PF_ROTATE)
        {
            if (pPDev->fMode & PF_CCW_ROTATE90)
                pRD->iyPrtLine -= sizl.cx;
            else
                pRD->iyPrtLine += sizl.cx;
        }
        else
            pRD->iyPrtLine += sizl.cy;

#ifdef TIMING
        DrvDbgPrint ("Unidrv!bRender: Skipping blank band\n");
#endif
        return TRUE;
    }


    iBPP = pRD->iBPP;            /* Speedier access as local variable */

    // this code filters the raster data so that any set pixel
    // will have at least one adjacent horizontal pixel set and
    // at least one adjacent vertical pixel set
    //
    if (iBPP == 1 && (pPDev->fMode & PF_SINGLEDOT_FILTER))
    {
        INT cy,i;
        cy = sizl.cy;
        while (--cy >= 0)
        {
            DWORD *pdwC,*pdwB,*pdwA;

            // Calculate pointers
            //
            pdwC = &pBits[pRD->cDWLine*cy];
            //
            // We will do horizontal filter first
            //
            if (pPDev->pbRasterScanBuf[cy / LINESPERBLOCK])
            {
                BYTE bA,bL,*pC;
                // skip leading white space
                for (i = 0;i < pRD->cDWLine;i++)
                    if (pdwC[i] != ~0) break;

                pC = (BYTE *)pdwC;
                bL = (BYTE)~0;
                i *= DWBYTES;
                while (i < pRD->cBYLine)
                {
                    bA = pC[i];
                    pC[i] &= (((bA >> 1) | (bL << 7)) | ~((bA >> 2) | (bL << 6)));
                    bL = bA;
                    i++;
                }
            }
            // Test if adjacent scan line is blank
            //
            if (cy && pPDev->pbRasterScanBuf[(cy-1) / LINESPERBLOCK])
            {
                // test if scan line is blank
                pdwB = &pdwC[-pRD->cDWLine];
                pdwA = &pdwB[-pRD->cDWLine];
                if (pPDev->pbRasterScanBuf[cy / LINESPERBLOCK] == 0)
                {
                    RECTL rcTmp;
                    // test if anything needs to be set here
                    //
                    i = pRD->cDWLine;
                    while (--i >= 0)
                        if ((~pdwA[i] | pdwB[i]) != ~0) break;
                    //
                    // if line is blank we can skip it
                    if (i < 0) continue;

                    // we need to clear this block
                    //
                    rcTmp.top = cy;
                    rcTmp.bottom = cy;
                    rcTmp.left = rcTmp.right = 0;
                    CheckBitmapSurface(pso,&rcTmp);
                }
                // this is the normal case
                //
                if (cy > 1 && pPDev->pbRasterScanBuf[(cy-2) / LINESPERBLOCK])
                {
                    for (i = 0;i < pRD->cDWLine;i++)
                    {
                        pdwC[i] &= ~pdwA[i] | pdwB[i];
                    }
                }
                // in this case line A is blank
                //
                else
                {
                    for (i = 0;i < pRD->cDWLine;i++)
                    {
                        pdwC[i] &= pdwB[i];
                    }
                }
            }
        }
    }
    // test whether we need to erase the rest of the bitmap
    //
    if (pPDev->bTTY)    // bug fix 194505
    {
        pPDev->fMode &= ~PF_SURFACE_USED;
    }
    else if ((pRPDev->fBlockOut & RES_BO_NO_YMOVE_CMD) ||
        (pPDev->fMode & PF_SURFACE_USED &&
        ((pPDev->fMode & PF_ROTATE) ||
          pRPDev->sPinsPerPass != 1 ||
          pRPDev->sNPins != 1)))
    {
        CheckBitmapSurface(pso,NULL);
    }
#ifdef TIMING
    if (!(pPDev->fMode & PF_SURFACE_ERASED) && pPDev->pbRasterScanBuf)
    {
        INT i,j,k;
        char buf[80];
        k = (pPDev->szBand.cy + LINESPERBLOCK - 1) / LINESPERBLOCK;
        for (i = 0, j = 0;i < k;i++)
            if (pPDev->pbRasterScanBuf[i] == 0) j++;
        sprintf (buf,"Unidrv!bRender: Skipped %d of %d blocks\n",j,k);
        DrvDbgPrint(buf);
    }
#endif



    /*
     *  Initialize the fields for optimizing the rendering of the bitmap.
     *  The main purpose is to have a single pass over the bits.  This
     *  can significantly speed up rendering due to cache effects.  In
     *  the old days, we took at least 3 passes over the entire bitmap for
     *  laserjets.  One to invert the bits, one+ to find rules, and then
     *  a third to output the data.  We now delay the invertion of the
     *  bits until after rules are found.  We also keep left/right information
     *  of non white space for each row.  This way, any white on the edges
     *  or completely white rows are only touch once and from then on, only
     *  DWORDS with black need be touched.  Also, the invertion is expensive
     *  since it causes writing every DWORD.
     */

    pRD->plrWhite   = NULL;
    pRD->plrCurrent = NULL;
    pRD->clr        = 0;

    //
    // Set flag to clear delta row buffer
    //
    pRD->iFlags |= RD_RESET_DRC;

    /*
     *   Various operations depend upon what format bitmap we have.  So
     * now is the time to set this all up.
     */

    //
    // If 1 bit per pixel mode we need to explicitly invert the
    // data, but we may do it later in rules.
    // The only other data this is allowed to be inverted is
    // 4BPP and it is done in the transform functions
    //
    if (pRD->iBPP == 1 && (pPDev->fMode & PF_SURFACE_USED))
        pRD->bInverted = FALSE;
    else
        pRD->bInverted = TRUE;

    /*
     *   Check if rotation is required.  If so,  allocate storage,
     *  start transposing, etc.
     */

    if( pPDev->fMode & PF_ROTATE )
    {
        /*
         *   Rotation is the order of the day.  First chew up some memory
         * for the transpose function.
         */

        INT   iTHigh;                   /* Height after transpose */
        INT   cTDWLine;                 /* DWORDS per line after transpose */
        INT   iAddrInc;                 /* Address increment AFTER transpose */
        INT   iDelta;                   /* Transpose book keeping */
        INT   cbTransBuf;               /* Bytes needed for L -> P transpose */
        INT   ixTemp;                   /* Maintain pRD->ix around this op */

        TRANSPOSE  tpBig;               /* For the landscape transpose */
        TRANSPOSE  tpSmall;             /* For the per print head pass */
        TRANSPOSE  tp;                  /* Banding: restore after we clobber */

        /*
         *    First step is to determine how large to make the area
         *  wherein the data will be transposed for later rendering.
         *  Take the number of scan lines,   and round this up to a
         *  multiple of DWORDS.  Then find out how many of these will
         *  fit into a reasonable size chunk of memory.  The number
         *  should be a multiple of the number of pins per pass -
         *  this to make sure we don't have partial head passes,  if
         *  that is possible.
         */

        /*
         *  OPTIMIZATION POTENTIAL - deterimine left/right edges of non
         *  white area and only transpose that portion (at least for
         *  laser printers).  There are often areas of white at the
         *  top and or bottom.  In the case of the HP laser printers,
         *  only the older printers (I believe series II) go through
         *  this code.  LaserJet III and beyond can do graphics in
         *  landscape so don't need this. (erick 12/20/93)
         */

        tp = pRD->Trans;              /* Keep a safe copy for later use */
        ixTemp = pRD->ix;

        cTDWLine = (sizl.cy * iBPP + DWBITS - 1) / DWBITS;

        cbTransBuf = DWBYTES * cTDWLine * pRD->iPassHigh;
        if( cbTransBuf < TRANSPOSE_SIZE )
            cbTransBuf = TRANSPOSE_SIZE;

        iTHigh = cbTransBuf / (cTDWLine * DWBYTES);


        if( iTHigh > sizl.cx )
        {
            /*   Bigger than we need,  so shrink to actual size */
            iTHigh = sizl.cx;          /* Scan lines we have to process */

            /*   Make multiple of pins per pass - round up */
            if( pRD->iPassHigh == 1 )
            {
                /*
                 *   LaserJet/PaintJet style,  so round to byte alignment.
                 */
                if (iBPP < BBITS)
                    iTHigh = (iTHigh + BBITS / iBPP - 1) & ~(BBITS / iBPP - 1);
            }
            else
                iTHigh += (pRD->iPassHigh - (iTHigh % pRD->iPassHigh)) %
                        pRD->iPassHigh;
        }
        else
        {
            /*   Make multiple of pins per pass - round down */
            if( pRD->iPassHigh == 1 )
            {
                if (iBPP < BBITS)
                    iTHigh &= ~(BBITS / iBPP - 1);         /* Byte alignment for LJs */
            }
            else
                iTHigh -= iTHigh % pRD->iPassHigh;
        }

        cbTransBuf = iTHigh * cTDWLine * DWBYTES;

        pRD->iy = iTHigh;

        /*   Set up data for the transpose function */
        tpBig.iHigh = sizl.cy;
        tpBig.iSkip = cTDWLine * DWBYTES;       /* Bytes per transpose output */
        tpBig.iWide = iTHigh * iBPP;            /* Scanlines we will process */
        tpBig.cBL = pRD->ix * iBPP;

        pRD->ix = sizl.cy;

        tpBig.cDWL = (tpBig.cBL + DWBITS - 1) / DWBITS;
        tpBig.iIntlace = 1;     /* Landscape -> portrait: no interlace */
        tpBig.cBYL = tpBig.cDWL * DWBYTES;
        tpBig.icbL = tpBig.cDWL * DWBYTES;
        tpBig.pdwTransTab = pRPDev->pdwTrans;    /* For L -> P rotation */


        if( !(tpBig.pvBuf = MemAlloc( cbTransBuf )) )
        {
            bRet = FALSE;
        }
        else
        {
            /*  Have the memory,  start pounding away  */
            INT   iAdj;                 /* Alignment adjustment, first band */


            bRet = TRUE;                /* Until proven guilty */

            /*
             *   Recompute some of the transpose data for the smaller
             *  bitmap produced from our call to transpose.
             */
            pRD->iTransWide = sizl.cy * iBPP;          /* Smaller size */
            pRD->cBLine = pRD->ix * iBPP;
            pRD->iMaxBytesSend = (pRD->cBLine * pRD->iBitsPCol + BBITS - 1) /
                        BBITS;
            if( iBPP == 4 )
                pRD->iMaxBytesSend = (pRD->iMaxBytesSend+3) / 4;

            pRD->cDWLine = (pRD->cBLine + DWBITS - 1) / DWBITS;
            pRD->cBYLine = pRD->cDWLine * DWBYTES;
            pRD->cbTLine = pRD->cDWLine * DWBYTES * pRD->iInterlace;
            tpSmall = pRD->Trans;      /* Keep it for later reuse */


            /*
             *   Set up the move commands required when rendering.  In this
             *  instance,  the X and Y operations are interchanged.
             */

            iAddrInc = (pRD->iy * iBPP) / BBITS;       /* Bytes per scanline */

            if( pPDev->fMode & PF_CCW_ROTATE90 )
            {
                /*
                 *   This is typified by the LaserJet Series II case.
                 *  The output bitmap should be rendered from the end
                 *  to the beginning,  the scan line number decreases from
                 *  one line to the next (moving down the output page),
                 *  and the X and Y move functions are interchanged.
                 */

                tpSmall.icbL = -tpSmall.icbL;           /* Scan direction */

                /*
                 *    Need to process bitmap in reverse order.  This means
                 *  shifting the address to the right hand end of the
                 *  first scan line,  then coming back one transpose pass
                 *  width.  Also set the address increment to be negative,
                 *  so that we work our way towards the beginning.
                 */

                /*
                 *    To simplify the transpose loop following,  we start
                 *  rendering the bitmap from the RHS.  The following
                 *  statement does just that:  the sizl.cx / BBITS is
                 *  the number of used bytes in the scan line, iAddrInc
                 *  is the number per transpose pass,  so subtracting it
                 *  will put us at the beginning of the last full band
                 *  on this transpose.
                 */

/* !!!LindsayH - should sizl.cx be sizl.cx * iBPP ????? */
                iAdj = (BBITS - (sizl.cx & (BBITS - 1))) % BBITS;
                sizl.cx += iAdj;                /* Byte multiple */

                (BYTE *)pBits += (sizl.cx * iBPP) / BBITS - iAddrInc;

                iAddrInc = -iAddrInc;
            }
            else
            {
                /*
                 *    Typified by HP PaintJet printers - those that have no
                 *  landscape mode,  and where the output is rendered from
                 *  the start of the bitmap towards the end,  where the
                 *  scan line number INCREASES by one from one line to the
                 *  the next (moving down the output page),  and the X and Y
                 *  move functions are as expected.
                 */
                pBits += tpBig.cDWL * (sizl.cy - 1);    /* Start of last row */
                tpBig.icbL = -tpBig.icbL;       /* Backwards through memory */

                iAdj = 0;
            }


            while( bRet && (iDelta = (int)sizl.cx) > 0 )
            {
                pRD->Trans = tpBig;    /* For the chunk transpose */

                if( (iDelta * iBPP) < pRD->iTransWide )
                {
                    /*  Last band - reduce the number of rows */
                    pRD->iTransWide = iDelta * iBPP;   /* The remainder */
                    pRD->iy = iDelta;                  /* For bRealRender */
                    if( iAddrInc < 0 )
                    {
                        iDelta = -iDelta;               /* The OTHER dirn */
                        (BYTE *)pBits += -iAddrInc + (iDelta * iBPP) / BBITS;
                    }
                }

                /*  Transpose this chunk of data unless it is empty */
                if (pPDev->fMode & PF_SURFACE_USED)
                    pRD->vLtoPTransFn( (BYTE *)pBits, pRD );

                pRD->Trans = tpSmall;


                pRD->iy -= iAdj;
                bRet = bRealRender( pPDev, tpBig.pvBuf, pRD );
                pRD->iy += iAdj;
                iAdj = 0;

                /*  Skip to the next chunk of input data */
                (BYTE *)pBits += iAddrInc;      /* May go backwards */
                pRD->iyBase += pRD->iy;
                sizl.cx -= pRD->iy;
            }

            MemFree ( tpBig.pvBuf );
        }


        pRD->Trans = tp;
        pRD->ix = ixTemp;
    }
    else
    {
        /*
         *   Simple case - no rotation,  so process the bitmap as is.
         *  This means starting at the FIRST scan line which we have
         *  set to the top of the image.
         *     Set up the move commands required when rendering.  In this
         *  instance,  the X and Y operations are their normal way.
         */

        INT   iyTemp;

        iyTemp = pRD->iy;
        pRD->iy = sizl.cy;

        bRet = bRealRender( pPDev, pBits, pRD );

        pRD->iy = iyTemp;
    }

    /*
     *  Turn unidirection off
     */
    if (pRD->iFlags & RD_UNIDIR)
    {
        pRD->iFlags &= ~RD_UNIDIR;
        WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_UNIDIRECTIONOFF));
    }

    /*
     *   Return from graphics mode,  to be civilised.
     */
    if( pRD->iFlags & RD_GRAPHICS)
    {
        if (pRD->dwLastCompCmd != CMD_DISABLECOMPRESSION)
        {
            pRD->dwLastCompCmd = CMD_DISABLECOMPRESSION;
            WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION));
        }
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_ENDRASTER));
        pRD->iFlags &= ~RD_GRAPHICS;

    }

#ifdef TIMING
    EngQueryLocalTime(&TimeTab);
    eTime = (((TimeTab.usMinute*60)+TimeTab.usSecond)*1000)+
        TimeTab.usMilliseconds;
    eTime -= sTime;
    {
        char buf[80];
        sprintf (buf,"Unidrv!bRender: %ld\n",eTime);
        DrvDbgPrint(buf);
    }
#endif
    return  bRet;
}

/************************ Function Header ***********************************
 * bRealRender
 *      The REAL rendering function.  By the time we reach here,  the bitmap
 *      is in the correct orientation,  and so we need to be serious
 *      about rendering it.
 *
 * RETURNS:
 *      TRUE for successful rendering,  else FALSE.
 *
 * HISTORY:
 *  Friday 26 November          -by-    Norman Hendley    [normanh]
 *      Added multiple scanline per send block support
 *
 *  16:22 on Fri 11 Jan 1991    -by-    Lindsay Harris   [lindsayh]
 *      Started on it.
 *
 ****************************************************************************/

BOOL
bRealRender( pPDev, pBits, pRData )
PDEV           *pPDev;          /* Our PDEV:  key to everything */
DWORD          *pBits;          /* Actual data to process */
RENDER         *pRData;         /* Details of rendering process */
{

    /*
     *    Process the bitmap in groups of scan lines.  The number in the
     *  the group is determined by the printer.  Laser printers are
     *  processed one scan line at a time,  while dot matrix are processed
     *  according to the number of pins they can fire at once.  This
     *  information is generated by our caller from the printer
     *  characterisation data,  or otherwise!
     */

    INT   iLine;                /* Current scan line */
    INT   cDWPass;              /* DWORDS per head pass */
    INT   iDWLine;              /* DWORDS processed per interlace scan */
    INT   iILAdv;               /* Line advance per interlace operation */
    INT   iHeadLine;            /* Decide when graphics pass required */
    INT   iTHKeep;              /* Local copy of iTransHigh: we change it */
    INT   iHeight;
    INT   iNumScans;            /* local copy*/
    BOOL  bCheckBlocks;

    RASTERPDEV * pRPDev;
    PAL_DATA *pPD;
    INT iWhiteIndex;

    INT   iILDone[ MAX_INTERLACE ];     /* For head pass reduction */

    PLEFTRIGHT plr = NULL;      /* left/right of non white area */

    pRPDev = pPDev->pRasterPDEV;
    pPD     = pRPDev->pPalData;
    iWhiteIndex = pPD->iWhiteIndex;

    iHeight = pRData->iHeight;
    cDWPass = pRData->cDWLine * iHeight;

    if( pRData->iPosnAdv < 0 )
    {
        /*   Data needs to be sent in reverse order,  so adjust now */
        pBits += cDWPass * (pRData->iy / pRData->iPassHigh - 1);
        cDWPass = -cDWPass;
        iDWLine = -pRData->cDWLine;
        iILAdv = -1;
    }
    else
    {
        /*  Usual case,  but some special local variables */
        iDWLine = pRData->cDWLine;
        iILAdv = 1;
    }

/* if the bits have already been inverted, don't bother with the rule proc.
 * The bits will be inverted for the multi scan line devices inside
 * bRuleProc because multi scan line implementation assumes
 * that bits are inverted. The function bRuleProc is changed to take
 * take care of multi scan line support  (erick)
 */
    if(!pRData->bInverted)
    {
        if (pRPDev->fRMode & PFR_RECT_FILL)
        {
            if (!bRuleProc( pPDev, pRData, pBits ))
                vInvertBits(pBits, pRData->iy * pRData->cDWLine);
        }
        else if (pRData->iNumScans != 1 || pRData->iPassHigh != 1 ||
                    (pRPDev->fBlockOut & RES_BO_NO_YMOVE_CMD))
            vInvertBits(pBits, pRData->iy * pRData->cDWLine);
        else {
            pRData->bWhiteLine = bIsNegatedLineWhite;
            pRData->bWhiteBand = bIsNegatedLineWhite;
        }
    }

    iHeadLine = 0;
    for( iLine = 0; iLine < pRData->iInterlace; ++iLine )
        iILDone[ iLine ] = 0;


    iTHKeep = pRData->iTransHigh;

    plr = (pRData->iMaxNumScans > 1) ? NULL : pRData->plrWhite;

    if (!(pPDev->fMode & PF_SURFACE_ERASED) && pPDev->pbRasterScanBuf)
        bCheckBlocks = TRUE;
    else
        bCheckBlocks = FALSE;
    //normanh  This code could be made tighter. My concern in adding multiple
    //scanline support was not to risk breaking existing code.
    //For improved performance, having separate code paths for GDI style &
    //old dot matrix style graphics could be considered


    for( iLine = 0; iLine < pRData->iy; iLine += iNumScans )
    {

        /*
         *    Check to see if there is graphics data in the current
         *  print pass.  This only happens once at the start of each
         *  print pass.
         */

        BOOL bIsWhite = FALSE;         /* Set if no graphics in this pass*/
        BYTE   *pbData;                 /* pointer to data we will send */
        /*
         *   Have we been aborted?  If so,  return failure NOW.
         */

        if(pPDev->fMode & PF_ABORTED )
            return  FALSE;

        iNumScans = pRData->iNumScans;
        if (!(pPDev->fMode & PF_SURFACE_USED))
        {
            bIsWhite = TRUE;
        }
        else if (plr != NULL)
        {
            if (plr[iLine].left > plr[iLine].right)
                bIsWhite = TRUE;

            pRData->plrCurrent = plr + iLine;
        }
        else if (bCheckBlocks && pPDev->pbRasterScanBuf[iLine / LINESPERBLOCK] == 0)
        {
            //
            // Since this whole block is white we will try to skip to the first line
            // of the next block rather than loop for each scan line. However we need
            // to make sure we don't skip past the end of the band.
            //
            if (((pRData->PrinterType == PT_PAGE) || !(pPDev->iFonts)) &&
                (pRData->iInterlace == 1))
            {
                if ((iNumScans = pRData->iy - iLine) > LINESPERBLOCK)
                    iNumScans = LINESPERBLOCK;
            }
            bIsWhite = TRUE;
        }

        if( iILDone[ iHeadLine ] == 0 )
        {
            if( (pRData->iy - iLine) < pRData->iPassHigh )
            {
                /*
                 *   MESSY:  the end of the page,  and there are some
                 * dangling scan lines.  Since this IS the end of the
                 * page,  we can fiddle with RENDER information, since
                 * this will no longer be used after this time.  iTransHigh
                 * is used for rendering operations.  They will be
                 * adjusted now so that we do not flow off the end of
                 * the engine's bitmap.
                 */

                pRData->iTransHigh = (pRData->iy - iLine +
                        pRData->iInterlace - 1) / pRData->iInterlace;

                if (plr == NULL && !bIsWhite)
                    bIsWhite = pRData->bWhiteBand( pBits, pRData, iWhiteIndex );

                /*
                 *   If this band is all white,  we can set the iLDone
                 *  entry,  since we now know that this remaining part
                 *  of the page/band is white,  and so we do not wish to
                 *  consider it further.   Note that interlaced output
                 *  allows the possibility that some other lines in this
                 *  area will be output.
                 *    Note that the value (iBitsPCol - 1) may be larger than
                 *  the number of lines remaining in this band.  However
                 *  this is safe to do,  since we drop out of this function
                 *  before reaching the excess lines, and the array data
                 *  is initialised on every call to this function.
                 */
                if( bIsWhite )
                    iILDone[ iHeadLine ] = pRData->iBitsPCol - 1;
                else
                {
                    /*
                    *   Need to consider a special case in here.  If the
                    * printer has > 8 pins,  and there are 8 or more
                    * scan lines to be dropped off the bottom,  then the
                    * transpose function will not clear the remaining
                    * part of the buffer,  since it only zeroes up
                    * to 7 scan lines at the bottom of the transpose area.
                    * Hence,  if we meet these conditions,  we zero the
                    * area before calling the transpose operation.
                    *
                    *   It can be argued that this should happen in the
                    * transpose code,  but it is really a special case that
                    * can only happen at this location.
                    */
                    if( pRData->vTransFn &&
                            (iHeight - pRData->iTransHigh) >= BBITS )
                    {
                    /*   Set the memory to zero.  */
                        ZeroMemory( pRData->pvTransBuf,
                            DWBYTES * pRData->cDWLine * pRData->iHeight );
                    }

                    // Another special case; block of scanlines
                    // Copy the data we're interesed in , into a white buffer of
                    // block size
                    if (iNumScans > 1)
                    {
                        DWORD iDataLeft = DWBYTES * pRData->cDWLine * (pRData->iy - iLine);
                        FillMemory((PBYTE)pRData->pdwTrailingScans+iDataLeft,
                            (pRData->cDWLine * iHeight * DWBYTES) - iDataLeft,
                            pRData->ubFillWhite);
                        CopyMemory(pRData->pdwTrailingScans,pBits,iDataLeft);
                        pBits = pRData->pdwTrailingScans;
                    }
                }
            }
            else
            {
                if (plr == NULL && !bIsWhite)
                {
                    bIsWhite = pRData->bWhiteLine( pBits, pRData, iWhiteIndex );
                }
            }


            /*  Data to go,  so go send it to the printer  */

            if( !bIsWhite )
            {

                pbData = (BYTE *)pBits;             /* What we are given */


                 // This is not elegant. This code is not structured to what we need to
                 // do here when printing multiple scanlines.
                 // What we do is basically take control from the outer loop, increase the
                 // block size to what we want to print, print it & then increase outer
                 // loop counters appropriately

                 // Found First non-white scanline
                 // Grow the block height until we hit a white scanline,
                 // reach the max block height, or end of page
                 // Note the following loop will execute only if the device is
                 // capable of increasing the block height: iHeight < iMaxNumScans

                while (((pRData->iNumScans + iHeight) < pRData->iMaxNumScans) &&
                       ((iLine + iHeight + iHeight) <= pRData->iy) &&
                       (!bCheckBlocks || pPDev->pbRasterScanBuf[(iLine+iHeight) / LINESPERBLOCK]) &&
                       !(pRData->bWhiteBand((DWORD *)(pBits + cDWPass),pRData,iWhiteIndex)))
                {
                    pRData->iNumScans += iHeight;
                    pBits += cDWPass;
                    iLine += iHeight;
                }

                /*
                *   Time to transpose the data into the order required to be
                * sent to the printer.  For single pin printers (Laserjets),
                * nothing happens at this stage,  but for dot matrix printers,
                * typically n scan lines are sent in bit column order,  so now
                * the bits are transposed into that order.
                */

                if( pRData->vTransFn )
                {
                    /*
                    *  this will not work with lazy invertion used with rule
                    *  detection for HP laserjet's. (erick 12/20/93)
                    */

                    ASSERTMSG(plr == NULL,("unidrv!bRealRender - vTrans with rules\n"));

                    /*   Transpose activity - do some transposing now */
                    pRData->vTransFn( pbData, pRData );

                    pbData = pRData->pvTransBuf;        /* Data to process */
                }

                if( !pRData->bPassProc( pPDev, pbData, pRData ) )
                    return  FALSE;

                // Have we grown the block height
                if (pRData->iNumScans > iHeight)
                {
                    // Update our Y cursor position remembering iTLAdv can be negative
                    pRData->iyPrtLine += iILAdv * (pRData->iNumScans - iHeight);

                    // Reset to minimum block height
                    pRData->iNumScans = iHeight;
                }

                iILDone[ iHeadLine ] = pRData->iBitsPCol -1;
            }
            //
            // Set flag to clear delta row buffer since we are
            // skipping white lines
            //
            else
                pRData->iFlags |= RD_RESET_DRC;

        }
        else
            --iILDone[ iHeadLine ];

        /*
         *   Output some text.   The complication here is that we have just
         *  printed a bunch of scan lines,  so we need to print text that
         *  is positioned within any of those.  This means we need to
         *  scan through all those lines now,  and print any fonts that
         *  are positioned within them.
         */
        if ((pRData->PrinterType != PT_PAGE) && (pPDev->iFonts) )
        {
            /*   Possible text, so go to it  */

            BOOL      bRetn;

            if( pPDev->dwLookAhead > 0 )
            {
                /*  DeskJet style lookahead region to handle */
                bRetn = bLookAheadOut( pPDev, pRData->iyPrtLine, pRData,
                      iILAdv );
            }
            else
            {
                /*  Plain vanilla dot matrix  */
                bRetn = BDelayGlyphOut( pPDev, pRData->iyPrtLine );
            }

            if( !bRetn )
                return  FALSE;         /* Bad news no matter how you see it */

        }
        pRData->iyPrtLine += iILAdv * iNumScans;     /* Next line to print */

        pBits += iDWLine * iNumScans;                /* May step backward */

        /*
         *   Keep track of the location of the head relative to the
         * graphics band.   For multiple pin printers,  we only print
         * graphics data on the first few scan lines,  the exact number
         * depending upon the interlace factor.  For example, an 8 pin printer
         * with interlace set to 1,  then graphics data is output only
         * on scan lines 0, 8, 16, 24,.....  We proces all of the scan
         * lines for text,  since the text may appear on any line.
         */

        iHeadLine = (iHeadLine + 1) % pRData->iInterlace;
    }
    pRData->iTransHigh = iTHKeep;
    return  TRUE;
}


/************************** Function Header *******************************
 * bOneColourPass
 *      Transforms an output pass consisting of colour data (split into
 *      sequences of bytes per colour) into a single, contiguous array
 *      of data that is then passed to bOnePassOut.  We also check that
 *      some data is to be set,  and set the colour as required.
 *
 * RETURNS:
 *      TRUE/FALSE,  as returned from bOnePassOut
 *
 * HISTORY:
 *   Friday December 3rd 1993   -by-    Norman Hendley   [norman]
 *      Trivial change to allow multiple scanlines
 *
 *  14:11 on Tue 25 Jun 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it to complete (untested) colour support.
 *
 *************************************************************************/

BOOL
bOneColourPass( pPDev, pbData, pRData )
PDEV    *pPDev;         /* The key to everything */
BYTE    *pbData;        /* Actual bitmap data */
RENDER  *pRData;        /* Information about rendering operations */
{

    register  BYTE  *pbIn,  *pbOut;             /* Copying data */
    register  INT    iBPC;

    INT   iColour;                      /* Colour we are handling */
    INT   iColourMax;                   /* Number of colour iterations */

    INT   iByte;                        /* Byte number of output */

    INT   iBytesPCol;                   /* Bytes per column */

    INT   iTemp;

    BYTE  bSum;                         /* Check for empty line */

    RASTERPDEV  *pRPDev;                  /* For convenience */


    pRPDev = pPDev->pRasterPDEV;

    iBytesPCol = (pRData->iBitsPCol + BBITS - 1) / BBITS;

    iColourMax = pRPDev->sDevPlanes;

    iTemp = pRData->cBYLine;



    /*
     *   The RENDERDATA structure value for the count of DWORDS per
     *  scanline should now be reduced to the number of bits per plane.
     *  The reason is that colour separation takes place in here,  so
     *  bOnePassOut() only sees the data for a single plane.  This means
     *  that bOnePassOut() is then independent of colour/monochrome.
     */

    pRData->cBYLine = iTemp / COLOUR_MAX;

    /*
     *    Disable the automatic cursor adjustment at the end of the line.
     *  This only happens on the last colour pass,  so we delay accounting
     *  for the printing until then.
     */
    pRData->iCursor = pRPDev->fCursor & ~RES_CUR_Y_POS_AUTO;


    for( iColour = 0; iColour < iColourMax; ++iColour )
    {
        /*
         *   Separate out the data for this particular colour.  Basically,
         *  it means copy n bytes, skip COLOUR_MAX * n bytes,  copy n bytes
         *  etc,  up to the end of the line.  Then call bOnePassOut with
         *  this data.
         */

        if( iColour == (iColourMax - 1) )
        {
            /*   Reinstate the automatic cursor position adjustment */
            pRData->iCursor |= pRPDev->fCursor & RES_CUR_Y_POS_AUTO;
        }
        pbIn = pbData + pRData->iColOff[ iColour ];

        pbOut = pRData->pbColSplit;             /* Colour splitting data */
        bSum = 0;

        // now we need to repack the color data
        //
        iByte = pRData->iMaxBytesSend * pRData->iNumScans;

        if (iBytesPCol == 1)
        {
            // This repacks a specific color plane
            // into concurrent planar data
            // It does multiple bytes per loop
            // for performance.
            DWORD dwSum = 0;
            while (iByte >= 4)
            {
                pbOut[0] = pbIn[0];
                pbOut[1] = pbIn[4];
                pbOut[2] = pbIn[8];
                pbOut[3] = pbIn[12];
                dwSum |= *((DWORD *)pbOut)++;
                pbIn += COLOUR_MAX*4;
                iByte -= 4;
            }
            bSum = dwSum ? 1 : 0;
            while (--iByte >= 0)
            {
                bSum |= *pbOut++ = *pbIn;
                pbIn += 4;
            }
        }
        else if (iBytesPCol == 3)
        {
            // special case 24 pin printers
            do {
                bSum |= *pbOut = *pbIn;
                bSum |= pbOut[1] = pbIn[1];
                bSum |= pbOut[2] = pbIn[2];
                pbIn += 3 * COLOUR_MAX;
                pbOut += 3;
            } while ((iByte -= 3) > 0);
        }
        else {
            // generic data repacking for V_BYTE devices
            //
            do {
                iBPC = iBytesPCol;
                do {
                    bSum |= *pbOut++ = *pbIn++;
                } while (--iBPC);
                pbIn += (COLOUR_MAX-1) * iBytesPCol;
            } while ((iByte -= iBytesPCol) > 0);
        }

        /*
         *   Check to see if any of this colour is to be printed.  We are
         *  called here if there is any non-white on the line.  However,
         *  it could,  for instance,  be red only,  and so it is wasteful
         *  of printer time to send a null green pass!
         */
        if( (pRData->iFlags & RD_ALL_COLOUR) || bSum )
        {
            //
            // Send a separate color command from the data to select
            // the color plane
            //
            if( pRPDev->fColorFormat & DC_EXPLICIT_COLOR )
                SelectColor (pPDev, iColour);

            //
            // The color command is sent with the data so we determine
            // which command should be used.
            //
            else
                pRData->iSendCmd = pRPDev->rgbCmdOrder[iColour];

            //
            // OK, lets output 1 color plane of data
            //
            if( !bOnePassOut( pPDev, pRData->pbColSplit, pRData ) )
            {
                pRData->cBYLine = iTemp;
                return  FALSE;
            }
        }

    }
    pRData->cBYLine = iTemp;            /* Correct value for other parts */

    return  TRUE;
}
/************************* Function Header ***********************************
 *  SelectColor
 *          Selects color, 0 must be the last color to be selected.
 *          Assumes that color info contains parameters for selecting
 *          black cyan magenta yellow
 *          Keep track of the current color selection, to reduce the amount
 *          of data sent to the printer
 *
 * RETURNS:
 *         Nothing.
 *
 * HISTORY:
 *
 *****************************************************************************/

void
SelectColor(
    PDEV *pPDev,
    INT color
)
{
    PRASTERPDEV pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    if( color >= 0 && color != pPDev->ctl.sColor )
    {
        // check to see if to send CR or not.
        if( pRPDev->fColorFormat & DC_CF_SEND_CR )
            XMoveTo( pPDev, 0, MV_PHYSICAL );

        WriteChannel(pPDev,COMMANDPTR(pPDev->pDriverInfo,
            pRPDev->rgbCmdOrder[color]));
        pPDev->ctl.sColor = (short)color;
    }
}

/************************** Function Header ********************************
 * bOnePassOut
 *      Function to process a group of scan lines and turn the data into
 *      commands for the printer.
 *
 * RETURNS:
 *      TRUE for success,  else FALSE.
 *
 * HISTORY:
 *  30-Dec-1993 -by-  Eric Kutter [erick]
 *      optimized for HP laserjet
 *  14:26 on Thu 17 Jan 1991    -by-    Lindsay Harris   [lindsayh]
 *      Started on it,  VERY loosely based on Windows 16 UNIDRV.
 *
 *  Thu 25 Nov 1993             -by-    Norman Hendley   [normanh]
 *      Enabled multple scanlines & multiple parameters
 *
 ***************************************************************************/

BOOL
bOnePassOut( pPDev, pbData, pRData )
PDEV           *pPDev;          /* The key to everything */
BYTE           *pbData;         /* Actual bitmap data */
register RENDER  *pRData;       /* Information about rendering operations */
{

    INT  iLeft;         /* Left bound of output buffer,  as a byte index */
    INT  iRight;        /* Right bound, as array index of output buffer */
    INT  iBytesPCol;    /* Bytes per column of print data */
    INT  iMinSkip;      /* Minimum null byte count before skipping */
    INT  iNumScans;     /* Number Of Scanlines in Block */
    INT   iWidth;       /* Width of one scanline in multiscanline printing
                     * before stripping */
    INT   iSzBlock;     /* size of Block */


    WORD  fCursor;      /* Temporary copy of cursor modes in Resolution */
    WORD  fDump;        /* Device capabilities */
    WORD  fBlockOut;    /* Output minimising details */

    RASTERPDEV  *pRPDev;  /* Unidrv's pdev */
    DWORD dwWhiteIndex;

    PLEFTRIGHT plr = pRData->plrCurrent;

    pRPDev = pPDev->pRasterPDEV;

    fDump = pRData->fDump;
    fCursor = pRPDev->fCursor;
    fBlockOut = pRPDev->fBlockOut;

    if (pRData->iBPP == 24)
        iBytesPCol = 3;
    else
        iBytesPCol = (pRData->iBitsPCol + BBITS - 1) / BBITS;

    iMinSkip = (int)pRPDev->sMinBlankSkip;

    iNumScans= pRData->iNumScans;
    iWidth = pRData->cBYLine;     // bytes per line
    iSzBlock= iWidth * iNumScans;

    iRight = pRData->iMaxBytesSend;

    dwWhiteIndex = pRData->dwDevWhiteIndex;

    /*
     *    IF we can skip any leading null data,  then do so now.  This
     *  reduces the amount of data sent to the printer,  and so can
     *  be beneficial to speed up data transmission time.
     */

    if  ((fBlockOut & RES_BO_LEADING_BLNKS) || ( fDump & RES_DM_LEFT_BOUND ))
    {
         if (iNumScans == 1) //Don't slow the single scanline code
         {
            /*  Look for the first non zero column */

            iLeft = 0;

            if (plr != NULL)
            {
                ASSERTMSG ((WORD)iRight >= (plr->right * sizeof(DWORD)),("unidrv!bOnePassOut - invalid right\n"));
                ASSERTMSG (fBlockOut & RES_BO_TRAILING_BLNKS,("unidrv!bOnePassOut - invalid fBlockOut\n"));
                iLeft  = plr->left * sizeof(DWORD);
                iRight = (plr->right+1) * sizeof(DWORD);
            }
            // since the left margin is zero this buffer will be DWORD aligned
            // this allows for faster white space detection
            // NOTE: we don't currently support 8 bit indexed mode
            else
            {
                while ((iLeft+4) <= iRight && *(DWORD *)&pbData[iLeft] == dwWhiteIndex)
                    iLeft += 4;
            }
            while (iLeft < iRight && pbData[iLeft] == (BYTE)dwWhiteIndex)
                iLeft++;

            /*  Round it to the nearest column  */
            iLeft -= iLeft % iBytesPCol;

            /*
             *   If less than the minimum skip amount,  ignore it.
             */
            if((plr == NULL) && (iLeft < iMinSkip))
                iLeft = 0;

         }
         else
         {
            INT pos;

            pos = iSzBlock +1;
            for (iLeft=0; iRight > iLeft &&  pos >= iSzBlock ;iLeft++)
                for (pos =iLeft; pos < iSzBlock && pbData[ pos] == (BYTE)dwWhiteIndex ;pos += iWidth)
                    ;

            iLeft--;

            /*  Round it to the nearest column  */
            iLeft -= iLeft % iBytesPCol;

            /*
             *   If less than the minimum skip amount,  ignore it.
             */

            if( iLeft < iMinSkip )
                iLeft = 0;
         }
    }
    else
    {
        iLeft = 0;
    }

    /*
     *    Check for eliminating trailing blanks.  If possible,  now
     *  is the time to find the right end of the data.
     */

    if( fBlockOut & RES_BO_TRAILING_BLNKS )
    {
        /*  Scan from the RHS to the first non-zero byte */

        if (iNumScans == 1)
        {
            if (plr != NULL)
                iRight = (plr->right+1) * sizeof(DWORD);

            // if the number of bytes to check is large
            // we will optimize to check it using DWORDS
            else if ((iRight - iLeft) >= 8)
            {
                // first we need to DWORD align the right position
                // we will be aligned when the 2 LSB's of iRight are 0
                //
                while (iRight & 3)
                    if (pbData[--iRight] != (BYTE)dwWhiteIndex)
                        goto DoneTestingBlanks;

                // OK now that we are DWORD aligned we can check
                // for white space a DWORD at a time
                //
                while ((iRight -= 4) >= iLeft && *(DWORD *)&pbData[iRight] == dwWhiteIndex);
                iRight += 4;
            }
            // now we can quickly test any remaining bytes
            //
            while (--iRight >= iLeft && pbData[iRight] == (BYTE)dwWhiteIndex);
        }
        else
        {
            INT pos;

            pos = iSzBlock +1;
            while(iRight > iLeft &&  pos > iSzBlock)
                for (pos = --iRight; pos < iSzBlock && pbData[ pos] == (BYTE)dwWhiteIndex ;pos += iWidth)
                    ;
        }
DoneTestingBlanks:
        iRight += iBytesPCol - (iRight % iBytesPCol);
    }


    /*
     *   If possible,  switch to unidirectional printing for graphics.
     *  The reason is to improve output quality,  since head position
     *  is not as reproducible in bidirectional mode.
     */
    if( (fBlockOut & RES_BO_UNIDIR) && !(pRData->iFlags & RD_UNIDIR) )
    {
        pRData->iFlags |= RD_UNIDIR;
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_UNIDIRECTIONON) );
    }

    if( fBlockOut & RES_BO_ENCLOSED_BLNKS )
    {
        /*
         *   We can skip blank patches in the middle of the scan line.
         *  This is only worthwhile when the number of blank columns
         *  is > iMinSkip,  because there is also overhead in not
         *  sending blanks,  especially the need to reposition the cursor.
         */

        INT   iIndex;           /* Scan between iLeft and iRight */
        INT   iBlank;           /* Start of blank area */
        INT   iMax;
        INT   iIncrement;

        iBlank = 0;             /* None to start with */

        if (iNumScans ==1)
        {
            iMax = iBytesPCol;
            iIncrement =1;
        }
        else
        {
            iMax = iSzBlock;
            iIncrement = iWidth;
        }

        for( iIndex = iLeft; iIndex < iRight; iIndex += iBytesPCol )
        {
            INT  iI;
            for( iI = 0; iI < iMax; iI +=iIncrement )
            {
                if( pbData[iIndex + iI] )
                    break;
            }

            if( iI < iMax )
            {
                /*
                 *   If this is the end of a blank stretch,  then consider
                 *  the possibility of not sending the blank part.
                 */
                if( iBlank && (iIndex - iBlank) >= iMinSkip )
                {
                /*  Skip it!  */

                    iLineOut( pPDev, pRData, pbData, iLeft, iBlank );
                    iLeft = iIndex;
                }
                iBlank = 0;             /* Back in the printed zone */
            }
            else
            {
                /*
                 *    A blank column - remember it if this is the first.
                 */
                if( iBlank == 0 )
                    iBlank = iIndex;            /* Record start of blank */
            }

        }
        /*  What's left over needs to go too! */
        if( iLeft != iIndex )
            iLineOut( pPDev, pRData, pbData, iLeft, iIndex );
    }
    else
    {
        //
        // PCLXL raster mode
        //
        if (pPDev->ePersonality == kPCLXL_RASTER)
        {
            DWORD dwcbOut;


            if (S_OK != PCLXLSetCursor((PDEVOBJ)pPDev,
                                        pRData->ixOrg,
	        pRData->iyPrtLine) ||
                S_OK != PCLXLSendBitmap((PDEVOBJ)pPDev,
                                        pRData->iBPP,
    	        pRData->iNumScans,
	        pRData->cBYLine,
	        iLeft,
	        iRight,
	        pbData,
	        &dwcbOut))
            {
                return FALSE;
            }

        }
        else
        {
            /*   Write the whole of the (remaining) scan line out */
            /*   For multiple scanlines, iRight is right side of top scanline */

            iLineOut( pPDev, pRData, pbData, iLeft, iRight );
        }

    }
    return  TRUE;
}

/************************** Function Header *********************************
 * iLineOut
 *      Sends the passed in line of graphics data to the printer,  after
 *      setting the X position, etc.
 *
 * RETURNS:
 *      Value from WriteSpoolBuf: number of bytes written.
 *
 * HISTORY:
 *  30-Dec-1993 -by-  Eric Kutter [erick]
 *      optimized for HP laserjet
 *  Mon 29th November 1993      -by-    Norman Hendley   [normanh]
 *      Added multiple scanline support
 *
 *  10:38 on Wed 15 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it during render speed ups
 *
 ****************************************************************************/

int
iLineOut( pPDev, pRData, pbOut, ixPos, ixEnd )
PDEV     *pPDev;          /* The key to everything */
RENDER   *pRData;       /*  Critical rendering information */
BYTE     *pbOut;        /*  Area containing data to send */
INT       ixPos;        /*  X location to start the output */
INT       ixEnd;        /*  Byte address of first byte to NOT send */
{

    INT    iBytesPCol;          /* Bytes per output col; dot matrix */
    INT    ixErr;               /* Error in setting X location */
    INT    ixLeft;              /* Left position in dots */
    INT    cbOut;               /* Number of bytes to send */
    INT    iRet;                /* Return value from output function */
    INT    iNumScans;           /* local copy          */
    INT    iScanWidth;          /* Width of scanline, used for multi-scanline printing*/
    INT    iCursor;             /* Cursor behavior flag */
    DWORD  fRMode;              // local copy

    BYTE     *pbSend;           /* Address of data to send out */

    RASTERPDEV  *pRPDev;

    if (ixPos < 0)
    {
        ERR (("Unidrv!iLineOut: ixPos < 0\n"));
        ixPos = 0;
    }

    pRPDev = pPDev->pRasterPDEV;
    fRMode = pRPDev->fRMode;

    iNumScans = pRData->iNumScans;
    iCursor = pRData->iCursor;

    /*
     *   Set the Y position - safe to do so at anytime.
     */
    pRData->iYMoveFn( pPDev, pRData->iyPrtLine, MV_GRAPHICS );

    if ((iBytesPCol = pRData->iBitsPCol) != 1)
        iBytesPCol /= BBITS;

#if DBG
    if( (ixEnd - ixPos) % iBytesPCol )
    {
        DbgPrint( "unidrv!iLineOut: cbOut = %ld, NOT multiple of iBytesPCol = %ld\n",
        ixEnd - ixPos, iBytesPCol );

        return  0;
    }
#endif


    /*
     *    Set the preferred left limit and number of columns to send.
     *  Note that the left limit may be adjusted to the left if the
     *  command to set the X position cannot set it exactly.
     *    Note also that some printers are unable to set the x position
     *  while in graphics mode,  so for these,  we ignore what may be
     *  able to be skipped.
     */

    if( pRData->fDump & RES_DM_LEFT_BOUND)
    {
        INT iMinSkip = pRPDev->sMinBlankSkip;
        if (!(pRData->iFlags & RD_GRAPHICS))
            iMinSkip >>= 2;
        if (ixPos < pRData->ixOrg || (pRData->ixOrg + iMinSkip) < ixPos)
        {
            /*
             *     Need to move left boundary.  This may mean
             *  exiting graphics mode if we are already there,  since
             *  that is the only way to change the origin!
             */

            if( pRData->iFlags & RD_GRAPHICS )
            {
                pRData->iFlags &= ~RD_GRAPHICS;
                if (pRData->dwLastCompCmd != CMD_DISABLECOMPRESSION)
                {
                    pRData->dwLastCompCmd = CMD_DISABLECOMPRESSION;
                    WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION));
                }
                WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_ENDRASTER));
            }
            //
            // Save the new graphics origin
            //
            pRData->ixOrg = ixPos;
        }
        else
        {
            // we can't optimize the left edge, better make it white

            if (pRData->plrCurrent != NULL)
                ZeroMemory(&pbOut[pRData->ixOrg], ixPos - pRData->ixOrg);

            ixPos = pRData->ixOrg;
        }
    }
    /*
     *    Adjust the right side position to dot column version.
     */

    if( pRData->iBitsPCol == 1 )
    {
        /*  Laserjet style - work in byte units  */
        if (pRData->iBPP == 8)
            ixLeft = ixPos;              /* In dot/column units */
        else if (pRData->iBPP == 24)
            ixLeft = (ixPos * BBITS) / 24;
        else
            ixLeft = ixPos * BBITS;
    }
    else
    {
        /*   Dot matrix printers */
        ixLeft = ixPos / iBytesPCol;
    }


    /*
     *   Move as close as possible to the position along this scanline.
     * This is true regardless of orientation - this move is ALONG the
     * direction of the scan line.
     */
    if( ixErr = pRData->iXMoveFn( pPDev, ixLeft, MV_GRAPHICS ) )
    {
        /*
         *   Fiddle factor - the head location could not
         * be exactly set, so send extra graphics data to
         * compensate.
         *   NOTE:  Presumption is that this will NEVER try to move
         *  the head past the left most position.  If it does,  then
         *  we will be referencing memory lower than the scan line
         *  buffer!
         */

        if( pRData->iBitsPCol == 1 )
        {
            /*
             *    We should not come in here - there are some difficulties
             *  in adjusting the position because there is also a byte
             *  alignment requirement.
             */
#if DBG
            DbgPrint( "+++BAD NEWS: ixErr != 0 for 1 pin printer\n" );
#endif
        }
        else
        {
            /*
             *    Should adjust our position by the number of additional cols
             *  we wish to send.  Also recalculate the array index position
             *  corresponding to the new graphical position,
             */
             if (ixLeft <= ixErr)
                ixPos = 0;
             else
                ixPos = (ixLeft - ixErr) * iBytesPCol;
        }

    }

    // For a multiple scanline block the printable data will not be contiguous.
    // We have already identified where to strip white space
    // Only now can we actually remove the white data

    if(( iNumScans > 1 ) && !( fRMode & PFR_BLOCK_IS_BAND ))
    {
        cbOut = iStripBlanks( pRData->pStripBlanks, pbOut, ixPos,
                    ixEnd, iNumScans, pRData->cBYLine);
        ixEnd = ixEnd - ixPos;
        ixPos = 0;
        pbOut = pRData->pStripBlanks;
    }


    // Calculate the width of the source data in bytes and check
    // whether we need to output this to the device. If so, we
    // evidently need to exit raster mode first

    iScanWidth = ixEnd - ixPos;
    if ((DWORD)iScanWidth != pPDev->dwWidthInBytes)
    {
        pPDev->dwWidthInBytes = iScanWidth;
        if (fRMode & PFR_SENDSRCWIDTH)
        {
            if( pRData->iFlags & RD_GRAPHICS )
            {
                pRData->iFlags &= ~RD_GRAPHICS;
                if (pRData->dwLastCompCmd != CMD_DISABLECOMPRESSION)
                {
                    pRData->dwLastCompCmd = CMD_DISABLECOMPRESSION;
                    WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION) );
                }
                WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_ENDRASTER) );
            }
            WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETSRCBMPWIDTH));
        }
    }

    //
    // Check whether we should send the source height to the device
    //
    if ((DWORD)iNumScans != pPDev->dwHeightInPixels)
    {
        pPDev->dwHeightInPixels = iNumScans;
        if (fRMode & PFR_SENDSRCHEIGHT)
            WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETSRCBMPHEIGHT));
    }

    //
    // Make sure we are in raster mode at this point
    //
    if( !(pRData->iFlags & RD_GRAPHICS))
    {
        pRData->iFlags |= RD_GRAPHICS;
        if (fRMode & PFR_SENDBEGINRASTER)
            WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_BEGINRASTER));
    }

    //
    //  Calculate the number of bytes to send.
    //  If compression is available, use it first.
    //
    cbOut = iScanWidth * iNumScans ;

    pbSend = &pbOut[ ixPos ];

    //
    //  Mirror each data byte if required
    //
    if (pRData->pbMirrorBuf)
    {
        INT i = cbOut;
        PBYTE pMirror = pRData->pbMirrorBuf;
        while (--i >= 0)
            pbSend[i] = pMirror[pbSend[i]];
    }
    //
    // If there are compression modes we want to determine the
    // most efficient algorithm of those that are enabled.
    //
    if (pRData->dwNumCompCmds)
    {
        DWORD i;
        INT iBestCompSize;
        DWORD dwBestCompCmd;
        INT iCompLimit;
        INT iLastCompLimit;
        PBYTE pBestCompPtr;

        //
        // test whether to initialize dwDeltaRowBuffer
        //
        if (pRData->pDeltaRowBuffer && pRData->iFlags & RD_RESET_DRC)
        {
            pRData->iFlags &= ~RD_RESET_DRC;
            ZeroMemory(pRData->pDeltaRowBuffer,pRData->iMaxBytesSend);
        }

        // initialize to size of buffer
        //
        iCompLimit = iLastCompLimit = pRData->dwCompSize;
        dwBestCompCmd = 0;

        // loop until we've compressed using all active compression modes
        // and have found the most efficient
        //
        for (i = 0;i < pRData->dwNumCompCmds;i++)
        {
            INT iTmpCompSize;
            PBYTE pTmpCompBuffer = pRData->pCompBufs[i];
            DWORD dwTmpCompCmd = pRData->pdwCompCmds[i];
            //
            // do the appropriate compression
            //
            iTmpCompSize = -1;
            switch (dwTmpCompCmd)
            {
            case CMD_ENABLETIFF4:
                iTmpCompSize = iCompTIFF(pTmpCompBuffer,pbSend,cbOut);
                break;
            case CMD_ENABLEFERLE:
                iTmpCompSize = iCompFERLE(pTmpCompBuffer,pbSend,cbOut,iLastCompLimit);
                break;
            case CMD_ENABLEOEMCOMP:
                FIX_DEVOBJ(pPDev,EP_OEMCompression);
                //  also add these members to the struct _PDEV   (unidrv2\inc\pdev.h)
                //  POEM_PLUGINS    pOemEntry;

                //  note add macro FIX_DEVOBJ in unidrv2\inc\oemkm.h so it also does this:

                //  (pPDev)->pOemEntry = ((pPDev)->pOemHookInfo[ep].pOemEntry)
                //        (pOemEntry is defined as type POEM_PLUGIN_ENTRY in printer5\inc\oemutil.h)
                //

                if(pPDev->pOemEntry)
                {
                    if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                    {
                            HRESULT  hr ;
                            hr = HComCompression((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                        (PDEVOBJ)pPDev,pbSend,pTmpCompBuffer,cbOut,iLastCompLimit, &iTmpCompSize);
                            if(SUCCEEDED(hr))
                                ;  //  cool !
                    }
                    else
                    {
                        iTmpCompSize = pRPDev->pfnOEMCompression((PDEVOBJ)pPDev,pbSend,pTmpCompBuffer,cbOut,iLastCompLimit);
                    }
                }
                break;
            case CMD_ENABLEDRC:
                iTmpCompSize = iCompDeltaRow(pTmpCompBuffer,pbSend,
                    pRData->pDeltaRowBuffer,pRData->iMaxBytesSend,iLastCompLimit);
                break;
            case CMD_DISABLECOMPRESSION:
                iTmpCompSize = cbOut;
                pTmpCompBuffer = pbSend;
                break;
            }
            //
            // decide if new compression is smaller than last
            //
            if (iTmpCompSize >= 0)
            {
                if (dwTmpCompCmd == pRData->dwLastCompCmd)
                {
                    if (iTmpCompSize >= iLastCompLimit)
                        continue;

                    iLastCompLimit = iCompLimit = iTmpCompSize - COMP_FUDGE_FACTOR;
                }
                else if (iTmpCompSize < iCompLimit)
                {
                    iCompLimit = iTmpCompSize;
                    if (iLastCompLimit > (iTmpCompSize + COMP_FUDGE_FACTOR))
                        iLastCompLimit = iTmpCompSize + COMP_FUDGE_FACTOR;
                }
                else
                    continue;

                iBestCompSize = iTmpCompSize;
                pBestCompPtr = pTmpCompBuffer;
                dwBestCompCmd = dwTmpCompCmd;
                if (iCompLimit <= 1)
                    break;
            }
        }

        // if DRC is enabled we need to save the scan line
        //
        if (pRData->pDeltaRowBuffer)
            CopyMemory (pRData->pDeltaRowBuffer,pbSend,pRData->iMaxBytesSend);

        //
        // verify we found a valid compression technique
        // otherwise use no compression mode
        //
        if (dwBestCompCmd == 0)
        {
            dwBestCompCmd = CMD_DISABLECOMPRESSION;
            if (!(COMMANDPTR(pPDev->pDriverInfo,CMD_DISABLECOMPRESSION)))
            {
                ERR (("Unidrv: No valid compression found\n"));
                pPDev->fMode |= PF_ABORTED;
            }
        }
        else
        {
            // update the output pointer and size with the best
            // compression method.
            //
            pbSend = pBestCompPtr;
            cbOut = iBestCompSize;
        }

        // if we've changed compression modes we need to
        // output the new mode to the printer
        //
        if (dwBestCompCmd != pRData->dwLastCompCmd)
        {
//            DbgPrint ("New Comp: %ld,y=%ld,size=%ld\n",dwBestCompCmd,
//                pRData->iyPrtLine,cbOut);
            pRData->dwLastCompCmd = dwBestCompCmd;
            WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,dwBestCompCmd));
        }
    }

    // update data block size
    // output the raster command and
    // output the actual raster data
    //
    pPDev->dwNumOfDataBytes = cbOut;

    WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,pRData->iSendCmd));

    //
    // if callback, adjust the pdev and make the OEM callback
    //
    if (pRPDev->pfnOEMFilterGraphics)
    {
        FIX_DEVOBJ(pPDev,EP_OEMFilterGraphics);

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                    HRESULT  hr ;
                    hr = HComFilterGraphics((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                (PDEVOBJ)pPDev, pbSend, cbOut);
                    if(SUCCEEDED(hr))
                        iRet = cbOut;  //  cool !
                    else
                        iRet = 0 ;  //  hackey, the OEM function should return # bytes written to spooler
                                        //  but too late to change the interface now.
            }
            else
            {
                iRet = pRPDev->pfnOEMFilterGraphics((PDEVOBJ)pPDev, pbSend, cbOut);
            }
        }

    }
    //
    // otherwise we just write out the data ourselves
    //
    else
        iRet = WriteSpoolBuf(pPDev, pbSend, cbOut );

    // Test whether to send end of block command
    //
    if (fRMode & PFR_ENDBLOCK)
        WriteChannel (pPDev,COMMANDPTR(pPDev->pDriverInfo,CMD_ENDBLOCKDATA));

    //
    // Test whether to reset fonts after sending raster data
    //
    if (pPDev->fMode & PF_RESELECTFONT_AFTER_GRXDATA)
    {
        VResetFont(pPDev);
    }

    /*
     *    Adjust our idea of the printer's cursor position.  IF the printer
     *  does not change the cursor's X position after printing,  then we leave
     *  it where it now is,  otherwise we set to what the printer has.
     */

    if( !(iCursor & RES_CUR_X_POS_ORG) )
    {
        if( iCursor & RES_CUR_X_POS_AT_0 )
        {
            /*
             *    This type of printer sets the cursor to the left hand
             *  side after printing,  so set that as our current position.
             */
            pRData->iXMoveFn( pPDev, 0, MV_PHYSICAL | MV_UPDATE );
        }
        else
        {
            /*
             *   Cursor remains at end of output.  So,  set that as our
             *  position too.  But first,  calculate the RHS dot position.
             */

            INT   ixRight;

            if( pRData->iBitsPCol == 1 )
                ixRight = ixEnd * BBITS;        /*  Laserjet style */
            else
                ixRight = ixEnd / iBytesPCol;   /*   Dot matrix printers */


            pRData->iXMoveFn( pPDev, ixRight, MV_UPDATE | MV_GRAPHICS );
        }
    }

    /*
     *    If the printer moves the Y position after printing,  then now
     *  is the time to adjust our Y position.
     */
    if( iCursor & RES_CUR_Y_POS_AUTO )
    {
        pRData->iYMoveFn( pPDev, pRData->iPosnAdv,
                MV_UPDATE | MV_RELATIVE | MV_GRAPHICS );
    }

    return  iRet;
}
//*******************************************************
void
vInvertBits (
    DWORD  *pBits,
    INT    cDW
    )
/*++

Routine Description:

    This function inverts a group of bits. This is used to convert
    1 bit data from 0 = black and 1 = white to the opposite.

Arguments:

    pRD         Pointer to RENDER structure
    pBits       Pointer to data buffer to invert

Return Value:

    none

--*/
{
#ifndef _X86_
    INT cDWT = cDW >> 2;
    while( --cDWT >= 0 )
    {
        pBits[0] ^= ~((DWORD)0);
        pBits[1] ^= ~((DWORD)0);
        pBits[2] ^= ~((DWORD)0);
        pBits[3] ^= ~((DWORD)0);
        pBits += 4;
    }
    cDWT = cDW & 3;
    while (--cDWT >= 0)
        *pBits++ ^= ~((DWORD)0);

#else
//
// if intel processor, do it in assembly, for some reason
// the compiler always does the NOT in three vs one instruction
//
__asm
{
    mov ecx,cDW
    mov eax,pBits
    sar ecx,2
    jz  SHORT IB2
IB1:
    not DWORD PTR [eax]
    not DWORD PTR [eax+4]
    not DWORD PTR [eax+8]
    not DWORD PTR [eax+12]
    add eax,16
    dec ecx
    jnz IB1
IB2:
    mov ecx,cDW
    and ecx,3
    jz  SHORT IB4
IB3:
    not DWORD PTR [eax]
    add eax,4
    dec ecx
    jnz IB3
IB4:
}
#endif
}

#if 0
//*******************************************************
void
vFindWhiteInvertBits (
    RASTERPDEV *pRPDev,
    RENDER *pRD,
    DWORD  *pBits
    )
/*++

Routine Description:

    This function determines the leading and trailing white
    space for this buffer and inverts all the necessary bits
    such that 0's are white and 1's are black.

Arguments:
    pRPDev      Pointer to RASTERPDEV structure
    pRD         Pointer to RENDER structure
    pBits       Pointer to data buffer to invert

Return Value:

    none

--*/
{
    DWORD cDW = pRD->cDWLine;
    DWORD cLine = pRD->iy;

    //
    // if the MaxNumScans is 1 then it is useful to determine
    // the first and last non-white dword and store them as left
    // and right in the plrWhite structure. Only the non-white
    // data needs to be inverted in this case
    //
    if (pRD->iMaxNumScans == 1 &&
        ((pRPDev->fBlockOut & RES_BO_LEADING_BLNKS) ||
         (pRD->fDump & RES_DM_LEFT_BOUND)) &&
         (pRPDev->fBlockOut & RES_BO_TRAILING_BLNKS))
    {
        PLEFTRIGHT plr;
        DWORD dwMask = pRD->pdwBitMask[pRD->cBLine % DWBITS];
        if (dwMask != 0)
            dwMask = ~dwMask;
        // allocate blank space structure
        //
        if (pRD->plrWhite == NULL || (pRD->clr < cLine))
        {
            if (pRD->plrWhite != NULL)
                MemFree (pRD->plrWhite);
            pRD->plrWhite = MemAlloc(sizeof(LEFTRIGHT) * cLine);
            pRD->clr = cLine;

            // can't allocate structure so invert everything
            //
            if (pRD->plrWhite == NULL)
            {
                vInvertBits( pBits, cDW * cLine );
                return;
            }
        }
        plr = pRD->plrWhite;
        while (cLine-- > 0)
        {
            DWORD *pdwIn = pBits;
            DWORD *pdwLast = &pBits[cDW-1];
            DWORD dwLast = *pdwLast | dwMask;

            // find leading blanks, set last dword to zero
            // for faster checking
            //
            *pdwLast = 0;
            while (*pdwIn == -1)
                pdwIn++;

            *pdwLast = dwLast;

            // find trailing blanks
            //
            if (dwLast == (DWORD)-1)
            {
                pdwLast--;
                if (pdwIn < pdwLast)
                {
                    while (*pdwLast == (DWORD)-1)
                        pdwLast--;
                }
            }
            plr->left = pdwIn - pBits;
            plr->right = pdwLast - pBits;

            // invert remaining dwords
            //
            while (pdwIn <= pdwLast)
                *pdwIn++ ^= ~((DWORD)0);

            // increment to next line
            pBits += cDW;
            plr++;
        }
    }
    // MaxNumScans > 1 so invert everything
    //
    else
        vInvertBits( pBits, cDW * cLine );

}
#endif
/************************** Function Header *********************************
 * bLookAheadOut
 *      Process text for printers requiring a lookahead region.  These are
 *      typified by the HP DeskJet family,  where the output needs to be
 *      sent before the printer reaches that point in the raster scan.
 *      The algorithm is explained in the DeskJet manual.
 *
 * RETURNS:
 *      TRUE/FALSE,  FALSE being some substantial failure.
 *
 * HISTORY:
 *  10:43 on Mon 11 Jan 1993    -by-    Lindsay Harris   [lindsayh]
 *      Created it to support the DeskJet.
 *
 ****************************************************************************/

BOOL
bLookAheadOut( pPDev, iyVal, pRD, iILAdv )
PDEV     *pPDev;         /* Our PDEV,  gives us access to all our data */
INT       iyVal;         /* Scan line being processed. */
RENDER   *pRD;           /* The myriad of data about what we do */
INT       iILAdv;        /* Add to scan line number to get next one */
{
    /*
     *    First step is to find the largest font in the lookahead region.
     *  The position sorting code does this for us.
     */

    INT     iTextBox;         /* Scan lines to look for text to send */
    INT     iIndex;           /* Loop parameter */

    RASTERPDEV   *pRPDev;       /* The active stuff */


    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    iTextBox = ILookAheadMax( pPDev, iyVal, pPDev->dwLookAhead );

    iIndex = pRD->iyLookAhead - iyVal;
    iyVal = pRD->iyLookAhead;                 /* Base address of scan */

    while( iIndex < iTextBox )
    {
        if( !BDelayGlyphOut( pPDev, iyVal ) )
            return   FALSE;                    /* Doomsday is here */

        ++iIndex;
        ++iyVal;
    }

    pRD->iyLookAhead = iyVal;

    return   TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\rmrender.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    Definitions, structures and constants for unidrv rendering

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created

--*/
#ifndef _RMRENDER_H_
#define _RMRENDER_H_

/*
 *    Miscellaneous constants involved in rendering.
 */

#define BBITS   8               /* Bits per BYTE */
#define WBITS   (sizeof( WORD ) * BBITS)
#define WBYTES  (sizeof( WORD ))
#define DWBITS  (sizeof( DWORD ) * BBITS)
#define DWBYTES (sizeof( DWORD ))

#define COLOUR_MAX      4       /* Maximum number of colours to send to printer */

#define MAX_COMPRESS_MODES 5


/*
 *   Data compression function prototypes.
 */

typedef  int  (* COMPFN)( BYTE *, BYTE *, int );


/*
 *   The following structures contain the important information used
 * when rendering the bitmap image to the printer.  Data is largely
 * calculated once for all future references (for this pdev).
 */

/*   Data specific to transpose operations  */
typedef  struct
{
    void  *pvBuf;               /* Where the output is placed  */
    int    iSkip;               /* Bytes to skip to separte output bytes */
    int    iHigh;               /* Number of input scan lines to transpose */
    int    iWide;               /* Number of pixels in input scan lines */
    int    cDWL;                /* DWORDS per scan line - input */
    int    cBYL;                /* BYTES per scan line - input */
    int    cBL;                 /* BITS per scan line */
    int    iIntlace;            /* Interlace factor */
    int    icbL;                /* Bytes to change pointer per line */
    DWORD *pdwTransTab;         /* Transpose table OR colour separation */
} TRANSPOSE;

typedef struct _LEFTRIGHT
{
    WORD left;
    WORD right;
} LEFTRIGHT, *PLEFTRIGHT;

/*   Overall rendering data */
typedef  struct _RENDER
{
    int   iPassHigh;            /* Scan lines processed per print pass */
    int   iyBase;               /* Processing bitmap in multiple passes */
    int   iyPrtLine;            /* Scan line # as printer sees it */
    int   iyLookAhead;          /* How far ahead we have looked - DeskJet */
    int   iBitsPCol;            /* Bits per column per head pass */
    WORD  iFlags;               /* Flag bits - see below for meaning */
    WORD  fDump;                /* Local copy of fDump from Resolution */
    int   iCursor;              /* Resolution.fCursor copy */
    int   ixOrg;                /* Reference point for graphics commands */
    int   iPosnAdv;             /* Scan lines moved after head pass printed */
    int   iNumScans;            /* Number of scan lines to be printed in one block */
    int   iMaxNumScans;         /* How high we can grow our block */
    int   iHeight;              /* Height in pixels of block to be processed*/

    int   ix;                   /* Input bitmap x size, pels */
    int   iy;                   /* Input bitmap y size, pels */
    int   iBPP;                 /* Pel format (#bits per pel) */
    int   iMaxBytesSend;        /* Number of bytes to process in bottom level */

    int   iSendCmd;             /* Command OCD to send with data block */
    DWORD dwDevWhiteIndex;      // white index for testing leading,trailing
                                // white space

    DWORD *pdwBitMask;          /* Bitmask table,  built as needed */
    DWORD *pdwColrSep;          /* Colour separation table */
    DWORD *pdwTrailingScans;     /* Buffer for dangling scanlines */
    BYTE  *pStripBlanks;

    BYTE  *pbColSplit;          /* For splitting colour bytes */
    BYTE  *pbMirrorBuf;         /* buffer for mirroring data */

    DWORD   dwNumCompCmds;      // number of different compression modes to run
    DWORD dwCompSize;           // size of compression buffer
    DWORD dwLastCompCmd;        // last compression command sent to device
    DWORD pdwCompCmds[MAX_COMPRESS_MODES];// table of active compression commands
    PBYTE pCompBufs[MAX_COMPRESS_MODES];  // pointers to compression buffers
    PBYTE pDeltaRowBuffer;      // previous scan line buffer for delta row compression

    int    iColOff[ COLOUR_MAX ];       /* Address shifting in sepn buffer */

    void  (*vTransFn)( BYTE *, struct _RENDER * );
                /* Transpose function for multi-pin printers */
    void  (*vLtoPTransFn)( BYTE *, struct _RENDER * );
                /* Landscape to portrait transpose fn */

    TRANSPOSE  Trans;           /* The transpose data  */

    int   (*iXMoveFn)( PDEV *, int, int );        /* X positioning function */
    int   (*iYMoveFn)( PDEV *, int, int );        /* Y positioning function */

    BOOL  (*bPassProc)( PDEV *, BYTE *, struct _RENDER * );     /* Color/mono */

    BOOL  (*bWhiteLine)( DWORD *, struct _RENDER *, int );   /* A white scan line? */
    BOOL  (*bWhiteBand)( DWORD *, struct _RENDER *, int );   /* A white band? */


    BOOL   bInverted;           /* have the bits been inverted yet */
    PLEFTRIGHT plrWhite;        /* list of left/right pairs for each row */
    PLEFTRIGHT plrCurrent;      /* left/right pair for current row */
    DWORD clr;                  /* count of left/right scans             */
    BYTE    ubFillWhite;        // This value is used to initialize buffers
    PRINTERTYPE PrinterType;    // type of printer, SERIAL,PAGE,TTY
} RENDER;

/*   Make access to transpose data easier  */
#define pvTransBuf      Trans.pvBuf
#define iTransSkip      Trans.iSkip
#define iTransHigh      Trans.iHigh
#define iTransWide      Trans.iWide
#define cDWLine         Trans.cDWL
#define cBYLine         Trans.cBYL
#define cBLine          Trans.cBL
#define iInterlace      Trans.iIntlace
#define cbTLine         Trans.icbL

/*
 *   Bits in iFlags above:
 */

#define RD_GRAPHICS     0x0001          /* Printer is in graphics mode */
#define RD_RESET_DRC    0x0002          /* Need to reset DRC buffer */
#define RD_UNIDIR       0x0004          /* Printer in unidirectional mode */
#define RD_ALL_COLOUR   0x0008          /* Set if ALL colour bands must be sent */


/********************************
 *    Function prototypes
 ********************************/

/*
 *   Initialisation functions.
 */

BOOL  bSkipInit( PDEV * );
BOOL  bInitTrans( PDEV * );

/*
 *   Functions to initialise the RENDER structure, and clean it up when done.
 */

BOOL  bRenderInit( PDEV  *, SIZEL, int );
void  vRenderFree( PDEV * );

/*
 *    Functions to call at the start and finish of each page.
 */

BOOL  bRenderStartPage( PDEV * );
BOOL  bRenderPageEnd( PDEV * );

/*
 *   The top level rendering function.
 */

BOOL bRender( SURFOBJ *, PDEV *, RENDER *, SIZEL, DWORD * );

/*
 *   Bitmap edge finding function.   There are versions for each flavour
 *  of bitmap we support.  There is also the one for we always send all
 *  the scan lines.
 */

BOOL bIsBandWhite( DWORD *, RENDER *, int );
BOOL bIsLineWhite( DWORD *, RENDER *, int );
BOOL bIsNegatedLineWhite( DWORD *, RENDER *, int );

BOOL bIsRGBBandWhite( DWORD *, RENDER *, int );
BOOL bIsRGBLineWhite( DWORD *, RENDER *, int );

BOOL bIs8BPPBandWhite( DWORD *, RENDER *, int );
BOOL bIs8BPPLineWhite( DWORD *, RENDER *, int );

BOOL bIs24BPPBandWhite( DWORD *, RENDER *, int );
BOOL bIs24BPPLineWhite( DWORD *, RENDER *, int );

BOOL bIsNeverWhite( DWORD *, RENDER *, int );

int iStripBlanks( BYTE *, BYTE *, int, int, int,int);
/*
 *      Functions associated with finding rules in the bitmap.  This
 *  is really helpful for LaserJet style printers.
 */

void vRuleInit( PDEV *, RENDER * );
void vRuleFree( PDEV * );
BOOL bRuleProc( PDEV *, RENDER *, DWORD * );
void vRuleEndPage( PDEV  * );


/*
 *    Functions related to transposing the bitmap from one format to
 *  another.  These are for protrait/landscape conversion,  or for
 *  turning the output data into the order required for dot matrix
 *  style printers,  where the data is in column order.
 */


/*  Special case: 8 x 8 transpose for dot matrix printers */
void vTrans8x8( BYTE  *, RENDER  * );

/*  The more general case */
void vTrans8N( BYTE  *, RENDER  * );

/* Transpose for 4 bits per pel colour bitmap */
void vTrans8N4BPP( BYTE *, RENDER * );

/* Transpose for 8 bits per pel colour bitmap */
void vTrans8BPP( BYTE *, RENDER * );

/* Transpose for 24 bits per pel colour bitmap */
void vTrans24BPP( BYTE *, RENDER * );

/*  Colour separation for single pin colour printers (e.g. PaintJet) */
void vTransColSep( BYTE *, RENDER  * );

void vInvertBits(DWORD *, int);

/* Output 24 bit data */
BOOL b24BitOnePassOut( PDEV *, BYTE *, RENDER *);

void SelectColor( PDEV *, int );

int  iLineOut( PDEV *,RENDER *, BYTE *, int, int );

#endif  // !_RMRENDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\stretch.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    stretch.c


Abstract:

    This module contains all the StretchBlt/BitBlt codes which handle halftoned
    sources

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "raster.h"

#define DW_ALIGN(x)             (((DWORD)(x) + 3) & ~(DWORD)3)

#define ROP4_NEED_MASK(Rop4)    (((Rop4 >> 8) & 0xFF) != (Rop4 & 0xFF))
#define ROP3_NEED_PAT(Rop3)     (((Rop3 >> 4) & 0x0F) != (Rop3 & 0x0F))
#define ROP3_NEED_SRC(Rop3)     (((Rop3 >> 2) & 0x33) != (Rop3 & 0x33))
#define ROP3_NEED_DST(Rop3)     (((Rop3 >> 1) & 0x55) != (Rop3 & 0x55))
#define ROP4_FG_ROP(Rop4)       (Rop4 & 0xFF)
#define ROP4_BG_ROP(Rop4)       ((Rop4 >> 8) & 0xFF)

#if DBG
BOOL    DbgWhiteRect = FALSE;
BOOL    DbgBitBlt = FALSE;
BOOL    DbgCopyBits = FALSE;
#define _DBGP(i,x)            if (i) { (DbgPrint x); }
#else
#define _DBGP(i,x)

#endif //DBG



#define DELETE_SURFOBJ(pso, phBmp)                                      \
{                                                                       \
    if (pso)      { EngUnlockSurface(pso); pso=NULL;                  } \
    if (*(phBmp)) { EngDeleteSurface((HSURF)*(phBmp)); *(phBmp)=NULL; } \
}

#ifdef WINNT_40 //NT 4.0

#if DBG
BOOL    DbgDitherColor = FALSE;
#endif

extern HSEMAPHORE   hSemBrushColor;
extern LPDWORD      pBrushSolidColor;

#endif //WINNT_40




ROP4 InvertROPs(
    ROP4    Rop4
    )
/*++

Routine Description:

    This function remaps ROPs intended for RGB mode into CMY mode for 8bpp
    monochrome printing.

--*/
{
    // Rops are remapped for CMY vs RGB rendering by reversing the order of
    // the bits in the ROP and inverting the result.
    //
    if ((Rop4 & 0xff) == ((Rop4 >> 8) & 0xff))
    {
        ROP4 NewRop = 0;
        if (Rop4 & 0x01) NewRop |= 0x8080;  
        if (Rop4 & 0x02) NewRop |= 0x4040;
        if (Rop4 & 0x04) NewRop |= 0x2020;
        if (Rop4 & 0x08) NewRop |= 0x1010;
        if (Rop4 & 0x10) NewRop |= 0x0808;  
        if (Rop4 & 0x20) NewRop |= 0x0404;
        if (Rop4 & 0x40) NewRop |= 0x0202;
        if (Rop4 & 0x80) NewRop |= 0x0101;
        NewRop ^= 0xFFFF;
#ifdef DBGROP        
        if (NewRop != Rop4)
        {
            DbgPrint ("ROP remapped: %4x -> %4x\n",Rop4,NewRop);            
        }
#endif    
        Rop4 = NewRop;
    }
/*    
    if (Rop4 == 0xB8B8)     // required for bug 22915
        Rop4 = 0xE2E2;
    else if (Rop4 == 0x0000) // BLACKNESS
        Rop4 = 0xFFFF;
    else if (Rop4 == 0xFFFF) // WHITENESS
        Rop4 = 0x0000;
    else if (Rop4 == 0x8888) // SRCAND, required for bug 36192
        Rop4 = 0xEEEE;
    else if (Rop4 == 0xEEEE) // SRCPAINT, remap so it differs from SCRAND
        Rop4 = 0x8888;
    else if (Rop4 == 0xC0C0) // MERGECOPY
        Rop4 = 0xFCFC;
    else if (Rop4 == 0xFBFB) // PATPAINT
        Rop4 = 0x2020;
*/        
    return Rop4;
}


BOOL DrawWhiteRect(
    PDEV    *pPDev,
    RECTL   *pDest,
    CLIPOBJ *pco
    )
/*++

Routine Description:

    This function sends a white rectangle directly to the device if fonts
    have been sent to the printer for this band. This is used to clear
    the region where an image will be drawn.

Arguments:

    pPDev       - pointer to PDEV structure
    pDest       - pointer to destination RECTL
    pco         - pointer to CLIPOBJ

--*/
{
    RECTL  rcClip;
    BYTE   bMask;
    BOOL   bSendRectFill;
    LONG   i;
    PBYTE  pbScanBuf;
    BOOL   bMore;
    DWORD  dwMaxRects;

    if (DRIVER_DEVICEMANAGED (pPDev))   // Device Managed Surface
        return 0;

    //
    // only send the clearing rectangle if the device supports rectangles,
    // text has been downloaded, it is not a complex clip region.
    //
    if (!(pPDev->fMode & PF_RECT_FILL) ||
            !(pPDev->fMode & PF_DOWNLOADED_TEXT) ||
            (pco && pco->iDComplexity == DC_COMPLEX && pco->iFComplexity != FC_RECT4) ||
            !(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL)) ||
            pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS ||
            pPDev->fMode2 & PF2_MIRRORING_ENABLED)
    {
        return 0;
    }
    //
    // if complex clip but FC_RECT4 then there won't be more than 4 rectangles
    //
    if (pco && pco->iFComplexity == FC_RECT4)
    {
        if (CLIPOBJ_cEnumStart(pco,TRUE,CT_RECTANGLES,CD_ANY,4) == -1)
            return 0;
    }
    bMore = FALSE;
    dwMaxRects = 0;
    do 
    {
        //
        // clip to printable region or band
        //
        rcClip.left = MAX(0, pDest->left);
        rcClip.top = MAX(0, pDest->top);
        rcClip.right = MIN(pPDev->szBand.cx,pDest->right);
        rcClip.bottom = MIN(pPDev->szBand.cy,pDest->bottom);

        //
        // if clip rectangle or complex clip FC_RECT4 we need to apply
        // clip rectangle to input rectangle.
        //
        if (pco)
        {
            if (pco->iDComplexity == DC_RECT)
            {
                if (rcClip.left < pco->rclBounds.left)
                    rcClip.left = pco->rclBounds.left;
                if (rcClip.top < pco->rclBounds.top)
                    rcClip.top = pco->rclBounds.top;
                if (rcClip.right > pco->rclBounds.right)
                    rcClip.right = pco->rclBounds.right;
                if (rcClip.bottom > pco->rclBounds.bottom)
                    rcClip.bottom = pco->rclBounds.bottom;
            }
            else if (pco->iFComplexity == FC_RECT4)
            {
                ENUMRECTS eRect;
                bMore = CLIPOBJ_bEnum(pco,(ULONG)sizeof(ENUMRECTS),(ULONG *)&eRect);
                if (eRect.c != 1)
                    continue;
                if (rcClip.left < eRect.arcl[0].left)
                    rcClip.left = eRect.arcl[0].left;
                if (rcClip.top < eRect.arcl[0].top)
                    rcClip.top = eRect.arcl[0].top;
                if (rcClip.right > eRect.arcl[0].right)
                    rcClip.right = eRect.arcl[0].right;
                if (rcClip.bottom > eRect.arcl[0].bottom)
                    rcClip.bottom = eRect.arcl[0].bottom;
            }
        }
        //
        // At this point we will check whether anything has been directly downloaded to the
        // printer (ie text) to see if we need to even bother drawing the erase rectangle.
        //
        bMask = BGetMask(pPDev, &rcClip);
        bSendRectFill = FALSE;
        for (i = rcClip.top; i < rcClip.bottom ; i++)
        {
            if (pPDev->pbScanBuf[i] & bMask)
            {
                bSendRectFill = TRUE;
                break;
            }
        }

        //
        // check if we end up with an empty rect.
        //
        if (bSendRectFill && rcClip.right > rcClip.left && rcClip.bottom > rcClip.top)
        {
            DRAWPATRECT PatRect;
            PatRect.wStyle = 1;     // white rectangle
               PatRect.wPattern = 0;   // pattern not used
            PatRect.ptPosition.x = rcClip.left;
            PatRect.ptPosition.y = rcClip.top;
            PatRect.ptSize.x = rcClip.right - rcClip.left;
            PatRect.ptSize.y = rcClip.bottom - rcClip.top;
            DrawPatternRect(pPDev,&PatRect);
            dwMaxRects++;
            _DBGP(DbgWhiteRect,("DrawWhiteRect (%d,%d) (%d,%d)\n",
                rcClip.left+pPDev->rcClipRgn.left,
                rcClip.top+pPDev->rcClipRgn.top,
                rcClip.right+pPDev->rcClipRgn.left,
                rcClip.bottom+pPDev->rcClipRgn.top));
        }
    } while (bMore && dwMaxRects < 4);
    return (BOOL)dwMaxRects;
}


LONG
GetBmpDelta(
    DWORD   SurfaceFormat,
    DWORD   cx
    )

/*++

Routine Description:

    This function calculate total bytes needed for a single scan line in the
    bitmap according to its format and alignment requirement.

Arguments:

    SurfaceFormat   - Surface format of the bitmap, this is must one of the
                      standard format which defined as BMF_xxx

    cx              - Total Pels per scan line in the bitmap.

Return Value:

    The return value is the total bytes in one scan line if it is greater than
    zero


Author:

    19-Jan-1994 Wed 16:19:39 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DWORD   Delta = cx;

    switch (SurfaceFormat) {

    case BMF_32BPP:

        Delta <<= 5;
        break;

    case BMF_24BPP:

        Delta *= 24;
        break;

    case BMF_16BPP:

        Delta <<= 4;
        break;

    case BMF_8BPP:

        Delta <<= 3;
        break;

    case BMF_4BPP:

        Delta <<= 2;
        break;

    case BMF_1BPP:

        break;

    default:

        _DBGP(1, ("\nGetBmpDelta: Invalid BMF_xxx format = %ld", SurfaceFormat));
        break;
    }

    Delta = (DWORD)DW_ALIGN((Delta + 7) >> 3);
    return((LONG)Delta);
}




SURFOBJ *
CreateBitmapSURFOBJ(
    PDEV    *pPDev,
    HBITMAP *phBmp,
    LONG    cxSize,
    LONG    cySize,
    DWORD   Format
    )

/*++

Routine Description:

    This function create a bitmap and lock the bitmap to return a SURFOBJ

Arguments:

    pPDev   - Pointer to our PDEV

    phBmp   - Pointer the HBITMAP location to be returned for the bitmap

    cxSize  - CX size of bitmap to be created

    cySize  - CY size of bitmap to be created

    Format  - one of BMF_xxx bitmap format to be created

Return Value:

    SURFOBJ if sucessful, NULL if failed


Author:

    19-Jan-1994 Wed 16:31:50 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    SURFOBJ *pso = NULL;
    SIZEL   szlBmp;


    szlBmp.cx = cxSize;
    szlBmp.cy = cySize;

    if (*phBmp = EngCreateBitmap(szlBmp,
                                 GetBmpDelta(Format, cxSize),
                                 Format,
                                 BMF_TOPDOWN | BMF_NOZEROINIT,
                                 NULL)) {

        if (EngAssociateSurface((HSURF)*phBmp, (HDEV)pPDev->devobj.hEngine, 0)) {

            if (pso = EngLockSurface((HSURF)*phBmp)) {

                //
                // Sucessful lock it down, return it
                //

                return(pso);

            } else {

                _DBGP(1, ("\nCreateBmpSurfObj: EngLockSruface(hBmp) failed!"));
            }

        } else {

            _DBGP(1, ("\nCreateBmpSurfObj: EngAssociateSurface() failed!"));
        }

    } else {

        _DBGP(1, ("\nCreateBMPSurfObj: FAILED to create Bitmap Format=%ld, %ld x %ld",
                                        Format, cxSize, cySize));
    }

    DELETE_SURFOBJ(pso, phBmp);

    return(NULL);
}





BOOL
IsHTCompatibleSurfObj(
    PAL_DATA    *pPD,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo
    )
/*++

Routine Description:

    This function determine if the surface obj is compatble with plotter
    halftone output format.

Arguments:

    pPD         - Pointer to the PAL_DATA

    psoDst      - Our desitnation format

    psoSrc      - Source format to be checked againest

    pxlo        - engine XLATEOBJ for source -> postscript translation

Return Value:

    BOOLEAN true if the psoSrc is compatible with halftone output format, if
    return value is true, the pDrvHTInfo->pHTXB is a valid trnaslation from
    indices to 3 planes

Revision History:


--*/

{
    ULONG   *pSrcPal = NULL;
    UINT    SrcBmpFormat;
    UINT    DstBmpFormat;
    UINT    cPal;
    BOOL    Ok = TRUE;



    if ((SrcBmpFormat = (UINT)psoSrc->iBitmapFormat) >
        (DstBmpFormat = (UINT)psoDst->iBitmapFormat))
    {
        return(FALSE);
    }

    if ((!pxlo) || (pxlo->flXlate & XO_TRIVIAL))
    {
#ifdef WINNT_40
        //
        // The palette in NT4 always indexed, so if the the xlate is trivial
        // but the Source type is not indexed then we have problem
        //

        if ((pxlo) &&
            ((pxlo->iSrcType & (PAL_INDEXED      |
                                PAL_BITFIELDS    |
                                PAL_BGR          |
                                PAL_RGB)) != PAL_INDEXED))
        {
            return FALSE;
        }
#endif
        return((BOOL)(SrcBmpFormat == DstBmpFormat));
    }

    switch (DstBmpFormat)
    {
    case BMF_1BPP:
    case BMF_4BPP:
    case BMF_8BPP:

        //
        // If we cannot get the source palette memory, we will be in the
        // loop forever.
        //

        if ((pPD->wPalGdi > 0)              &&
            (pxlo->flXlate & XO_TABLE)      &&
            (cPal = (UINT)pxlo->cEntries))
        {
            if ((pSrcPal = (ULONG *)MemAlloc(cPal * sizeof(ULONG))))
            {
                ULONG   *pUL;

                XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, cPal, pSrcPal);

                //
                // Assume palette is OK unless we can't find a match
                //

                pUL = pSrcPal;
                while (cPal--)
                {
                    ULONG   *pMyPal = pPD->ulPalCol;
                    ULONG   Pal = *pUL++;
                    UINT    j = (UINT)pPD->wPalGdi;

                    do
                    {
                        if (*pMyPal++ == Pal)
                            break;
                    } while (--j);
                        //
                    // Didn't find matching color so set to FALSE
                    //
                    if (j == 0)
                    {
                        Ok = FALSE;
                        break;
                    }
                }
                MemFree(pSrcPal);
            }
        }
        else
            Ok = FALSE;

        break;

    case BMF_24BPP:

        //
        // Since device surface is 24-bpp, we will assume all source OK
        //
        break;

    default:

        _DBGP(1, ("\nUnidrv:IsHTCompatibleSurfObj: Invalid Dest format = %ld",
                                                DstBmpFormat));
        Ok = FALSE;
        break;
    }

    return(Ok);
}

BOOL
CreateMaskSurface(
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMsk,
    ULONG       iTransColor
    )
/*++

Routine Description:

    This function creates a mask surface based on the transparent color of the source surface.
    
Arguments:

    psoMsk      - Mask surface to be created

    psoSrc      - Source format to be checked againest

    iTransColor - Transparent color to compare against

Revision History:


--*/

{
    BYTE *pSrc;
    BYTE *pMsk;
    INT iRow,iCol;
    union {
        BYTE  bColor[4];
        USHORT sColor[2];
        ULONG lColor;
    } u;

    //
    // Check for NULL pointers. 
    // We dont create mask for 1bpp surface, because the
    // mask surface will either be identical to the original
    // surface or it will be its inverse. The same
    // affect can be achieved by manipulating the pxlo
    //
    if ( NULL == psoSrc ||
         NULL == psoMsk ||
         NULL == psoSrc->pvScan0 ||
         NULL == psoMsk->pvScan0 ||
         psoSrc->iBitmapFormat == BMF_1BPP )
    {
        ASSERT((FALSE, "Invalid Parameter"));
        return FALSE;
    }
    
    u.lColor = iTransColor;
    for (iRow = 0;iRow < psoSrc->sizlBitmap.cy;iRow++)
    {
        BYTE Mask = 0xFF;
        pSrc = (BYTE *)(psoSrc->pvScan0) + (psoSrc->lDelta * iRow);
        pMsk = (BYTE *)(psoMsk->pvScan0) + (psoMsk->lDelta * iRow);

        memset(pMsk,0xff,(psoMsk->sizlBitmap.cx+7) >> 3);
        
        if (psoSrc->iBitmapFormat == BMF_8BPP)
        {
            for (iCol = 0;iCol < psoSrc->sizlBitmap.cx;iCol++)
            {
                if (*pSrc == u.bColor[0])
                {
                    pMsk[iCol >> 3] &= ~(0x80 >> (iCol & 7));
                }
                pSrc += 1;
            }
        }
        else if (psoSrc->iBitmapFormat == BMF_16BPP)
        {
            for (iCol = 0;iCol < psoSrc->sizlBitmap.cx;iCol++)
            {
                if (*(USHORT *)pSrc == u.sColor[0])
                {
                    pMsk[iCol >> 3] &= ~(0x80 >> (iCol & 7));
                }
                pSrc += 2;           
            }
        }
        else if (psoSrc->iBitmapFormat == BMF_24BPP)
        {
            for (iCol = 0;iCol < psoSrc->sizlBitmap.cx;iCol++)
            {
                if (pSrc[0] == u.bColor[0] && pSrc[1] == u.bColor[1] && pSrc[2] == u.bColor[2])
                {
                    pMsk[iCol >> 3] &= ~(0x80 >> (iCol & 7));
                }
                pSrc += 3;           
            }
        }
        else if (psoSrc->iBitmapFormat == BMF_32BPP)
        {
            for (iCol = 0;iCol < psoSrc->sizlBitmap.cx;iCol++)
            {
                if (*(ULONG *)pSrc == u.lColor)
                {
                    pMsk[iCol >> 3] &= ~(0x80 >> (iCol & 7));
                }
                pSrc += 4;           
            }
        }
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
            for (iCol = 0;iCol < psoSrc->sizlBitmap.cx;iCol++)
            {
                if (((*pSrc >> 4) & 0xf) == u.bColor[0])
                {
                    pMsk[iCol >> 3] &= ~(0x80 >> (iCol & 7));
                }
                iCol++;
                if ((*pSrc & 0xf) == u.bColor[0])
                {
                    pMsk[iCol >> 3] &= ~(0x80 >> (iCol & 7));
                }
                pSrc += 1;           
            }
        }
    }    
    return TRUE;
}


BOOL
RMBitBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc,
    PPOINTL     pptlMask,
    BRUSHOBJ   *pbo,
    PPOINTL     pptlBrush,
    ROP4        Rop4
    )

/*++

Routine Description:

    This function will try to bitblt the source to the destination

Arguments:

    per winddi spec.


Return Value:

    BOOLEAN

Author:

    17-Feb-1993 Wed 12:39:03 created  -by-  Daniel Chou (danielc)
        NOTE:   Currently only if SRCCOPY/SRCMASKCOPY will halftone


Revision History:

    01-Feb-1994 Tue 21:51:40 updated  -by-  Daniel Chou (danielc)
        Re-written, it now will handle any ROP4 which have soruces involved
        either foreground or background.  It will half-tone the source first
        if it is not compatible with unidrv destiantion format, then it passed
        the compatible source to the EngBitBlt()


    17-May-1995 Wed 23:08:15 updated  -by-  Daniel Chou (danielc)
        Updated so it will do the brush origin correctly, also speed up by
        calling EngStretchBlt directly when SRCCOPY (0xCCCC) is passed.


--*/

{
    PDEV            *pPDev;
    SURFOBJ         *psoNewSrc;
    HBITMAP         hBmpNewSrc;
    RECTL           rclNewSrc;
    RECTL           rclOldSrc;
    POINTL          BrushOrg;
    DWORD           RopBG;
    DWORD           RopFG;
    BOOL            Ok;

    pPDev = (PDEV *)psoDst->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

#ifndef DISABLE_NEWRULES
    if (pPDev->pbRulesArray && pPDev->dwRulesCount < (MAX_NUM_RULES-4) &&
            Rop4 == 0xF0F0 && pbo && pxlo == NULL &&
            (pco == NULL || pco->iDComplexity != DC_COMPLEX || pco->iFComplexity == FC_RECT4) &&
            ((psoDst->iBitmapFormat != BMF_24BPP &&
            pbo->iSolidColor == (ULONG)((PAL_DATA*)(pPDev->pPalData))->iBlackIndex) ||
            (psoDst->iBitmapFormat == BMF_24BPP &&
            pbo->iSolidColor == 0)))
    {
      // 
      // if complexity is rect4 then we could add up to 4 rectangles
      //
      BOOL bMore = FALSE;
      if (pco && pco->iFComplexity == FC_RECT4)
      {
            if (CLIPOBJ_cEnumStart(pco,TRUE,CT_RECTANGLES,CD_ANY,4) == -1)
                goto SkipRules;
      }
      do
      {
        PRECTL pRect= &pPDev->pbRulesArray[pPDev->dwRulesCount];
        *pRect = *prclDst;
        //
        // if clip rectangle then clip the rule
        //
        if (pco)
        {
            if (pco->iDComplexity == DC_RECT)
            {
                if (pRect->left < pco->rclBounds.left)
                    pRect->left = pco->rclBounds.left;
                if (pRect->top < pco->rclBounds.top)
                    pRect->top = pco->rclBounds.top;
                if (pRect->right > pco->rclBounds.right)
                    pRect->right = pco->rclBounds.right;
                if (pRect->bottom > pco->rclBounds.bottom)
                    pRect->bottom = pco->rclBounds.bottom;
            }
            else if (pco->iFComplexity == FC_RECT4)
            {
                ENUMRECTS eRect;
                bMore = CLIPOBJ_bEnum(pco,(ULONG)sizeof(ENUMRECTS),(ULONG *)&eRect);
                if (eRect.c != 1)
                {
                    continue;
                }
                if (pRect->left < eRect.arcl[0].left)
                    pRect->left = eRect.arcl[0].left;
                if (pRect->top < eRect.arcl[0].top)
                    pRect->top = eRect.arcl[0].top;
                if (pRect->right > eRect.arcl[0].right)
                    pRect->right = eRect.arcl[0].right;
                if (pRect->bottom > eRect.arcl[0].bottom)
                    pRect->bottom = eRect.arcl[0].bottom;
            }
        }
        if (pRect->left < pRect->right && pRect->top < pRect->bottom)
        {
            DWORD i;
            for (i = 0;i < pPDev->dwRulesCount;i++)
            {
                    PRECTL pRect2= &pPDev->pbRulesArray[i];
                    //
                    //	test if this rectangle can be combined with another
                    //
                    if (pRect->top == pRect2->top && 
                        pRect->bottom == pRect2->bottom &&
                        pRect->left <= pRect2->right &&
                        pRect->right >= pRect2->left)
                    {
                        if (pRect2->left > pRect->left)
                            pRect2->left = pRect->left;
                        if (pRect2->right < pRect->right)
                            pRect2->right = pRect->right;
                        pPDev->dwRulesCount--;
                        break;
                    }
                    else if (pRect->left == pRect2->left && 
                        pRect->right == pRect2->right &&
                        pRect->top <= pRect2->bottom &&
                        pRect->bottom >= pRect2->top)
                    {
                        if (pRect2->top > pRect->top)
                            pRect2->top = pRect->top;
                        if (pRect2->bottom < pRect->bottom)
                            pRect2->bottom = pRect->bottom;
                        pPDev->dwRulesCount--;
                        break;
                    }
            }
            pPDev->dwRulesCount++;
        }        
      } while (bMore && pPDev->dwRulesCount < MAX_NUM_RULES);
      return TRUE;
    }

SkipRules:
#endif
    //
    // Send white rectangle to printer to clear any previously
    // downloaded text or graphics for PATCOPY and SRCCOPY rops
    //
    if (Rop4 == 0xF0F0 || Rop4 == 0xCCCC)
        DrawWhiteRect(pPDev,prclDst,pco);

    //
    // We will looked if we need the source, if we do then we check if the
    // source is compatible with halftone format, if not then we halftone the
    // source and passed the new halftoned source along to the EngBitBlt()
    //

    psoNewSrc  = NULL;
    hBmpNewSrc = NULL;
    RopBG      = ROP4_BG_ROP(Rop4);
    RopFG      = ROP4_FG_ROP(Rop4);


    if (((ROP3_NEED_PAT(RopBG)) ||
         (ROP3_NEED_PAT(RopBG)))    &&
        (pptlBrush)) {

        BrushOrg = *pptlBrush;

        _DBGP(DbgBitBlt, ("\nRMBitBlt: BrushOrg for pattern PASSED IN as (%ld, %ld)",
                BrushOrg.x, BrushOrg.y));

    } else {

        BrushOrg.x =
        BrushOrg.y = 0;

        _DBGP(DbgBitBlt, ("\nRMBitBlt: BrushOrg SET by UNIDRV to (0,0), non-pattern"));
    }

    if (((ROP3_NEED_SRC(RopBG)) ||
         (ROP3_NEED_SRC(RopFG))) &&
        (!IsHTCompatibleSurfObj((PAL_DATA *)pPDev->pPalData,
            psoDst, psoSrc, pxlo)))
    {

        rclNewSrc.left   =
        rclNewSrc.top    = 0;
        rclNewSrc.right  = prclDst->right - prclDst->left;
        rclNewSrc.bottom = prclDst->bottom - prclDst->top;
        rclOldSrc.left   = pptlSrc->x;
        rclOldSrc.top    = pptlSrc->y;
        rclOldSrc.right  = rclOldSrc.left + rclNewSrc.right;
        rclOldSrc.bottom = rclOldSrc.top + rclNewSrc.bottom;

        _DBGP(DbgBitBlt, ("\nRMBitBlt: Blt Source=(%ld, %ld)-(%ld, %ld)=%ld x %ld [psoSrc=%ld x %ld]",
                        rclOldSrc.left, rclOldSrc.top,
                        rclOldSrc.right, rclOldSrc.bottom,
                        rclOldSrc.right - rclOldSrc.left,
                        rclOldSrc.bottom - rclOldSrc.top,
                        psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy));
        _DBGP(DbgBitBlt, ("\nUnidrv!RMBitBlt: DestRect=(%ld, %ld)-(%ld, %ld), BrushOrg = (%ld, %ld)",
                        prclDst->left, prclDst->top,
                        prclDst->right, prclDst->bottom,
                        BrushOrg.x, BrushOrg.y));

        //
        // If we have a SRCCOPY then call EngStretchBlt directly
        //

        if (Rop4 == 0xCCCC) {

            _DBGP(DbgBitBlt, ("\nUnidrv!RMBitBlt(SRCCOPY): No Clone, call EngStretchBlt() ONLY\n"));

            //
            // At here, the brush origin guaranteed at (0,0)
            //
            CheckBitmapSurface(psoDst,prclDst);
            return(EngStretchBlt(psoDst,
                                 psoSrc,
                                 psoMask,
                                 pco,
                                 pxlo,
                                 NULL,
                                 &BrushOrg,
                                 prclDst,
                                 &rclOldSrc,
                                 pptlMask,
                                 HALFTONE));
        }
        //
        // Modify the brush origin, because when we blt to the clipped bitmap
        // the origin is at bitmap's 0,0 minus the original location
        //

        BrushOrg.x -= prclDst->left;
        BrushOrg.y -= prclDst->top;

        _DBGP(DbgBitBlt, ("\nUnidrv!RMBitBlt: BrushOrg Change to (%ld, %ld)",
                        BrushOrg.x, BrushOrg.y));

        _DBGP(DbgBitBlt, ("\nUnidrv!RMBitBlt: Clone SOURCE: from (%ld, %ld)-(%ld, %ld) to (%ld, %ld)-(%ld, %ld)=%ld x %ld\n",
                            rclOldSrc.left, rclOldSrc.top,
                            rclOldSrc.right, rclOldSrc.bottom,
                            rclNewSrc.left, rclNewSrc.top,
                            rclNewSrc.right, rclNewSrc.bottom,
                            rclOldSrc.right - rclOldSrc.left,
                            rclOldSrc.bottom - rclOldSrc.top));

        if ((psoNewSrc = CreateBitmapSURFOBJ(pPDev,
                                             &hBmpNewSrc,
                                             rclNewSrc.right,
                                             rclNewSrc.bottom,
                                             psoDst->iBitmapFormat))    &&
            (EngStretchBlt(psoNewSrc,       // psoDst
                           psoSrc,          // psoSrc
                           NULL,            // psoMask
                           NULL,            // pco
                           pxlo,            // pxlo
                           NULL,            // pca
                           &BrushOrg,       // pptlBrushOrg
                           &rclNewSrc,      // prclDst
                           &rclOldSrc,      // prclSrc
                           NULL,            // pptlmask
                           HALFTONE))) {

            //
            // If we cloning sucessful then the pxlo will be NULL because it
            // is identities for the halftoned surface to our engine managed
            // bitmap
            //

            psoSrc     = psoNewSrc;
            pptlSrc    = (PPOINTL)&(rclNewSrc.left);
            pxlo       = NULL;
            BrushOrg.x =
            BrushOrg.y = 0;

        }
        else {
            _DBGP(1, ("\nUnidrv:RMBitblt: Clone Source to halftone FAILED"));
        }
    }
    
    //
    // Check if we need to clear the bitmap surface. If it hasn't been cleared
    // but we are only going to draw a white region on it we can skip the white
    // PATCOPY bitblt.
    //
    if (!(pPDev->fMode & PF_SURFACE_USED) &&
            Rop4 == 0xF0F0 && pbo &&
#ifndef DISABLE_NEWRULES
            (pPDev->pbRulesArray == NULL || pPDev->dwRulesCount == 0) &&
#endif            
            ((psoDst->iBitmapFormat != BMF_24BPP &&
              pbo->iSolidColor == (ULONG)((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex) ||
             (psoDst->iBitmapFormat == BMF_24BPP &&
              pbo->iSolidColor == 0x00FFFFFF)))
    {
        _DBGP (DbgBitBlt, ("\nUnidrv:RMBitblt: Skipping white bitblt\n"));
        Ok = TRUE;
    }
    else
    {
        // test whether to remap rops for 8bpp mono mode
        if (pPDev->fMode2 & PF2_INVERTED_ROP_MODE)
        {
            Rop4 = InvertROPs(Rop4);
        }
        
        // set dirty surface flag
        CheckBitmapSurface(psoDst,prclDst);

        Ok = EngBitBlt(psoDst,
                       psoSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclDst,
                       pptlSrc,
                       pptlMask,
                       pbo,
                      &BrushOrg,
                       Rop4);
    }
    DELETE_SURFOBJ(psoNewSrc, &hBmpNewSrc);
    return(Ok);
}




BOOL
RMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            BltMode
    )

/*++

Routine Description:

    This function do driver's stretch bitblt, it actually call HalftoneBlt()
    to do the actual work

Arguments:

    per above


Return Value:

    BOOLEAN

Author:

    24-Mar-1992 Tue 14:06:18 created  -by-  Daniel Chou (danielc)


Revision History:

    27-Jan-1993 Wed 07:29:00 updated  -by-  Daniel Chou (danielc)
        clean up, so gdi will do the work, we will always doing HALFTONE mode


--*/

{
    PDEV    *pPDev;           /*  Our main PDEV */


    UNREFERENCED_PARAMETER(BltMode);


    pPDev = (PDEV *)psoDest->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

    // test whether we need to clear any device text that
    // may be under the graphics
    //
    DrawWhiteRect(pPDev,prclDest,pco);

    // set dirty surface flag since we're drawing in it
    CheckBitmapSurface(psoDest,prclDest);
    return(EngStretchBlt(psoDest,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         pca,
                         pptlBrushOrg,
                         prclDest,
                         prclSrc,
                         pptlMask,
                         HALFTONE));
}


BOOL
RMStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode,
    BRUSHOBJ        *pbo,
    DWORD           rop4
    )

/*++

Routine Description:

    This function do driver's stretch bitblt, it actually call HalftoneBlt()
    to do the actual work

Arguments:

    per above


Return Value:

    BOOLEAN

--*/

{
#ifndef WINNT_40
    PDEV    *pPDev;           /*  Our main PDEV */

    pPDev = (PDEV *)psoDst->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;


    // test whether we need to clear any device text that
    // may be under the graphics, rop must be SRCCOPY
    //
    if (rop4 == 0xCCCC)
        DrawWhiteRect(pPDev,prclDst,pco);

    // test whether to remap rops for 8bpp mono mode
    //
    if (pPDev->fMode2 & PF2_INVERTED_ROP_MODE)
    {
        rop4 = InvertROPs(rop4);
    }

    //
    // GDI doesn't support Halftoning for StretchBltROP unless the rop is SRCCOPY
    // Therefore to fix bug 36192, we will create a new surface to stretchblt with 
    // halftone and then will bitblt the result to the actual destination with the rop4
    //
#ifndef DISABLE_SBR_GDIWORKAROUND
    if (rop4 != 0xCCCC && psoMask == NULL &&
            ROP3_NEED_SRC(ROP4_FG_ROP(rop4)) && 
            psoDst->iBitmapFormat <= BMF_4BPP && psoSrc->iBitmapFormat >= BMF_4BPP)
    {
        SURFOBJ         *psoNewSrc;
        HBITMAP         hBmpNewSrc;
        RECTL           rclNewSrc;
        POINTL          BrushOrg;
        BOOL            Ok;
        DWORD           xHTOffset=0;
        DWORD           yHTOffset=0;

//        DbgPrint("StretchBltROP: rop4=%x,iFormat=%d->%d, Dest=%d,%d\n",rop4,psoSrc->iBitmapFormat,psoDst->iBitmapFormat,prclDst->left,prclDst->top);
        //
        // determine offset into temporary surface to get halftone patterns to align
        //
        if (pPDev->dwHTPatSize > 0)
        {
            xHTOffset = prclDst->left % pPDev->dwHTPatSize;
            yHTOffset = prclDst->top % pPDev->dwHTPatSize;
        }

        rclNewSrc.left   =
        rclNewSrc.top    = 0;
        rclNewSrc.right  = (prclDst->right - prclDst->left) + xHTOffset;
        rclNewSrc.bottom = (prclDst->bottom - prclDst->top) + yHTOffset;
        //
        // Modify the brush origin, because when we blt to the clipped bitmap
        // the origin is at bitmap's 0,0 minus the original location
        //
        BrushOrg.x = -prclDst->left;
        BrushOrg.y = -prclDst->top;

        if ((psoNewSrc = CreateBitmapSURFOBJ(pPDev,
                                             &hBmpNewSrc,
                                             rclNewSrc.right,
                                             rclNewSrc.bottom,
                                             psoDst->iBitmapFormat)))
        {
            rclNewSrc.left += xHTOffset;
            rclNewSrc.top += yHTOffset;
            if ((EngStretchBlt(psoNewSrc,       // psoDst
                           psoSrc,          // psoSrc
                           NULL,            // psoMask
                           NULL,            // pco
                           pxlo,            // pxlo
                           NULL,            // pca
                           pptlBrushOrg,    // pptlBrushOrg
                           &rclNewSrc,      // prclDst
                           prclSrc,         // prclSrc
                           NULL,            // pptlmask
                           HALFTONE))) 
            {

                //
                // If we cloning sucessful then the pxlo will be NULL because it
                // is identities for the halftoned surface to our engine managed
                // bitmap
                //
                PPOINTL pptlSrc    = (PPOINTL)&(rclNewSrc.left);
                pxlo       = NULL;
                BrushOrg.x =
                BrushOrg.y = 0;

                // set dirty surface flag
                CheckBitmapSurface(psoDst,prclDst);

                Ok = EngBitBlt(psoDst,
                       psoNewSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclDst,
                       pptlSrc,
                       pptlMask,
                       pbo,
                      &BrushOrg,
                       rop4);
                DELETE_SURFOBJ(psoNewSrc, &hBmpNewSrc);
                if (!Ok)
                    _DBGP(1,("RMStretchBltROP: Clone bitblt failed\n"));
                return Ok;
            }
            else {
                _DBGP(1,("RMStretchBltROP: Clone Source to halftone FAILED\n"));
            }
        }
        DELETE_SURFOBJ(psoNewSrc, &hBmpNewSrc);
    }
#endif        

    // set dirty surface flag since we're drawing in it
    CheckBitmapSurface(psoDst,prclDst);
    return(EngStretchBltROP(psoDst,
                            psoSrc,
                            psoMask,
                            pco,
                            pxlo,
                            pca,
                            pptlBrushOrg,
                            prclDst,
                            prclSrc,
                            pptlMask,
                            HALFTONE,
                            pbo,
                            rop4));
#else
    return TRUE;
#endif
}

BOOL
RMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix)
/*++

Routine Description:

    Implementation of DDI entry point DrvPaint.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface on which to draw
    pco - Limits the area to be modified on the Dstination
    pbo - Points to a BRUSHOBJ which defined the pattern and colors to fill with
    pptlBrushOrg - Specifies the origin of the halftone brush
    mix - Defines the foreground and background raster operations to use for
          the brush

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
#define MIXCOPYPEN (R2_COPYPEN | (R2_COPYPEN << 8))
#define MIXWHITE   (R2_WHITE | (R2_WHITE << 8))

    PDEV *pPDev = (PDEV *)pso->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

    //
    // Send white rectangle to printer to clear any previously
    // downloaded text or graphics for COPYPEN or WHITE rop2's
    //
    if ((mix == MIXCOPYPEN || mix == MIXWHITE) && pco && pco->iDComplexity == DC_RECT)
    {
        RECTL rclDst;
        rclDst.left = pco->rclBounds.left;
        rclDst.top = pco->rclBounds.top;
        rclDst.right = pco->rclBounds.right;
        rclDst.bottom = pco->rclBounds.bottom;
        DrawWhiteRect(pPDev,&rclDst,pco);
    }
    //
    // Check whether to erase surface
    //
    CheckBitmapSurface(pso,&pco->rclBounds);

    //
    // Call GDI to do the paint function
    //
    return EngPaint(pso, pco, pbo, pptlBrushOrg, mix);
}

BOOL
RMCopyBits(
   SURFOBJ  *psoDst,
   SURFOBJ  *psoSrc,
   CLIPOBJ  *pco,
   XLATEOBJ *pxlo,
   RECTL    *prclDst,
   POINTL   *pptlSrc
   )

/*++

Routine Description:

    Convert between two bitmap formats

Arguments:

    Per Engine spec.

Return Value:

    BOOLEAN


Author:

    24-Jan-1996 Wed 16:08:57 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDEV    *pPDev;           /*  Our main PDEV */

    pPDev = (PDEV *)psoDst->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

    // Handle the case which has to be passed to Engine.
    //
    if (IsHTCompatibleSurfObj((PAL_DATA *)pPDev->pPalData,
            psoDst, psoSrc, pxlo)  )
    {
        DrawWhiteRect(pPDev,prclDst,pco);
        CheckBitmapSurface(psoDst,prclDst);
        return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
    }
    else {

        POINTL  ptlBrushOrg;
        RECTL   rclSrc;
        RECTL   rclDst;

        rclDst        = *prclDst;
        rclSrc.left   = pptlSrc->x;
        rclSrc.top    = pptlSrc->y;
        rclSrc.right  = rclSrc.left + (rclDst.right - rclDst.left);
        rclSrc.bottom = rclSrc.top  + (rclDst.bottom - rclDst.top);

        //
        // Validate that we only BLT the available source size
        //

        if ((rclSrc.right > psoSrc->sizlBitmap.cx) ||
            (rclSrc.bottom > psoSrc->sizlBitmap.cy)) {

            WARNING(("RMCopyBits: Engine passed SOURCE != DEST size, CLIP IT"));

            rclSrc.right  = psoSrc->sizlBitmap.cx;
            rclSrc.bottom = psoSrc->sizlBitmap.cy;

            rclDst.right  = (LONG)(rclSrc.right - rclSrc.left + rclDst.left);
            rclDst.bottom = (LONG)(rclSrc.bottom - rclSrc.top + rclDst.top);
        }

        ptlBrushOrg.x =
        ptlBrushOrg.y = 0;

        _DBGP(DbgCopyBits, ("\nUnidrv!RMCopyBits: Format Src=%ld, Dest=%ld, Halftone it\n",
                                    psoSrc->iBitmapFormat, psoDst->iBitmapFormat));
        _DBGP(DbgCopyBits, ("\nUnidrv!RMCopyBits: Source Size: (%ld, %ld)-(%ld, %ld) = %ld x %ld\n",
                                rclSrc.left, rclSrc.top, rclSrc.right, rclSrc.bottom,
                                rclSrc.right - rclSrc.left, rclSrc.bottom - rclSrc.top));
        _DBGP(DbgCopyBits, ("\nUnidrv!RMCopyBits: Dest Size: (%ld, %ld)-(%ld, %ld) = %ld x %ld\n",
                                rclDst.left, rclDst.top, rclDst.right, rclDst.bottom,
                                rclDst.right - rclDst.left, rclDst.bottom - rclDst.top));

        return(DrvStretchBlt(psoDst,
                             psoSrc,
                             NULL,
                             pco,
                             pxlo,
                             NULL,
                             &ptlBrushOrg,
                             &rclDst,
                             &rclSrc,
                             NULL,
                             HALFTONE));
    }
}



ULONG
RMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )

/*++

Routine Description:

    This is the hooked brush creation function, it ask CreateHalftoneBrush()
    to do the actual work.


Arguments:

    dhpdev      - DHPDEV passed, it is our pDEV

    iMode       - Not used

    rgbColor    - Solid rgb color to be used

    pulDither   - buffer to put the halftone brush.

Return Value:

    BOOLEAN

Author:

    24-Mar-1992 Tue 14:53:36 created  -by-  Daniel Chou (danielc)


Revision History:

    27-Jan-1993 Wed 07:29:00 updated  -by-  Daniel Chou (danielc)
        clean up, so gdi will do the work.



--*/

{
    #ifndef WINNT_40 //NT 5.0
    UNREFERENCED_PARAMETER(dhpdev);
    UNREFERENCED_PARAMETER(iMode);
    UNREFERENCED_PARAMETER(rgbColor);
    UNREFERENCED_PARAMETER(pulDither);

    return(DCR_HALFTONE);

    #else // NT 4.0

    DWORD   RetVal;

    UNREFERENCED_PARAMETER(dhpdev);
    UNREFERENCED_PARAMETER(iMode);
    UNREFERENCED_PARAMETER(pulDither);

    EngAcquireSemaphore(hSemBrushColor);

    if (pBrushSolidColor) {

        *pBrushSolidColor = (DWORD)(rgbColor & 0x00FFFFFF);

        _DBGP(DbgDitherColor, ("\nDrvDitherColor(BRUSH=%08lx)\t\t",
                            *pBrushSolidColor));

        pBrushSolidColor  = NULL;
        RetVal            = DCR_SOLID;

    } else {

        _DBGP(DbgDitherColor, ("\nDrvDitherColor(HALFTONE=%08lx)\t\t", rgbColor));

        RetVal = DCR_HALFTONE;
    }

    EngReleaseSemaphore(hSemBrushColor);

    return(RetVal);

    #endif //!WINNT_40
}

BOOL
RMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfx,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            BltMode
    )

/*++

Routine Description:

    This function does driver's plgblt.

Arguments:

    per above


Return Value:

    BOOLEAN

--*/

{
    PDEV    *pPDev;           /*  Our main PDEV */

    pPDev = (PDEV *)psoDst->dhpdev;

    // if this isn't a graphics band we will return true
    // without doing anything
    if (!(pPDev->fMode & PF_ENUM_GRXTXT))
        return TRUE;

    //
    // test for no rotation, as this is another case the GDI EngPlgBlt call fails
    // bug #336711, 3/8/01 
    //
    if (pptfx[0].x == pptfx[2].x && pptfx[0].y == pptfx[1].y && pptfx[0].y < pptfx[2].y)
    {
        RECTL rclDst;
        rclDst.top = pptfx[0].y >> 4;
        rclDst.left = pptfx[0].x >> 4;
        rclDst.bottom = pptfx[2].y >> 4;
        rclDst.right = pptfx[1].x >> 4;

        // blt surface into destination
        //
        CheckBitmapSurface(psoDst,&rclDst);
        return EngStretchBlt(psoDst,           // psoDst
                           psoSrc,             // psoSrc
                           psoMask,            // psoMask
                           pco,                // pco
                           pxlo,               // pxlo
                           pca,                // pca
                           pptlBrushOrg,       // pptlBrushOrg
                           &rclDst,            // prclDst
                           prclSrc,            // prclSrc
                           pptlMask,               // pptlmask
                           HALFTONE); 
    }
    // test for 90/270 rotation as GDI's EngPlgBlt sometimes fails if it has to do
    // both rotation and scaling. In those case this function will rotate the
    // data to an intermediate surface before scaling to the destination surface.
    //
    if (psoMask == NULL && pptfx[0].x == pptfx[1].x && pptfx[0].y == pptfx[2].y &&
        (pPDev->pdmPrivate->iLayout == ONE_UP || psoSrc->iBitmapFormat == BMF_1BPP))
    {
        SURFOBJ         *psoNewSrc = NULL;
        HBITMAP         hBmpNewSrc = NULL;
        RECTL           rclNewSrc;
        BOOL iRet;
        RECTL rclDst;
        POINTFIX pFix[3];            

        rclNewSrc.left   =
        rclNewSrc.top    = 0;
        rclNewSrc.bottom = (prclSrc->right - prclSrc->left);
        rclNewSrc.right = (prclSrc->bottom - prclSrc->top);

        // rotate 90 degrees
        //
        if (pptfx[2].x < pptfx[0].x)
        {
                pFix[0].y = pFix[2].y = 0;
                pFix[0].x = pFix[1].x = (rclNewSrc.right << 4);
                pFix[2].x = 0;
                pFix[1].y = (rclNewSrc.bottom << 4);

                rclDst.top = pptfx[2].y >> 4;
                rclDst.left = pptfx[2].x >> 4;
                rclDst.bottom = pptfx[1].y >> 4;
                rclDst.right = pptfx[1].x >> 4;
        }
        // rotate 270 degrees
        // 
        else
        {
                pFix[0].y = pFix[2].y = (rclNewSrc.bottom << 4);
                pFix[0].x = pFix[1].x = 0;
                pFix[2].x = (rclNewSrc.right << 4);
                pFix[1].y = 0;

                rclDst.top = pptfx[1].y >> 4;
                rclDst.left = pptfx[1].x >> 4;
                rclDst.bottom = pptfx[2].y >> 4;
                rclDst.right = pptfx[2].x >> 4;
        }
        // Only enable EngPlgBlt workaround when scaling up. EngPlgBlt appears to work
        // ok when scaling down and it is more efficient in that mode. This also fixes
        // the rounding error associated with scaling down (bug #356514).
        //
        if ((rclNewSrc.right < abs(rclDst.right - rclDst.left) &&
            rclNewSrc.bottom < abs(rclDst.bottom - rclDst.top)) ||
            psoSrc->iBitmapFormat == BMF_1BPP)
        {
/*        
#if DBG
            DbgPrint("PlgBlt:Src=L%d,T%d,R%d,B%d;Dst=L%d,T%d,R%d,B%d\n",
                prclSrc->left,prclSrc->top,prclSrc->right,prclSrc->bottom,
                rclDst.left,rclDst.top,rclDst.right,rclDst.bottom);
#endif            
*/
            // Create an intermediate surface and rotate the source data into 
            // the surface with no scaling.
            //        
            if ((psoNewSrc = CreateBitmapSURFOBJ(pPDev,
                                             &hBmpNewSrc,
                                             rclNewSrc.right,
                                             rclNewSrc.bottom,
                                             psoSrc->iBitmapFormat)))
            {
                if ((iRet = EngPlgBlt(psoNewSrc,
                         psoSrc,
                         psoMask,
                         NULL,
                         NULL,
                         pca,
                         pptlBrushOrg,
                         pFix,
                         prclSrc,
                         pptlMask,
                         BltMode)))
                {        
                    // blt new surface into destination
                    //
                    if (psoSrc->iBitmapFormat != BMF_1BPP)
                    {
                        BltMode = HALFTONE;
                    }
                    CheckBitmapSurface(psoDst,&rclDst);
                    iRet = EngStretchBlt(psoDst,       // psoDst
                           psoNewSrc,          // psoSrc
                           NULL,            // psoMask
                           pco,                // pco
                           pxlo,               // pxlo
                           pca,                // pca
                           pptlBrushOrg,       // pptlBrushOrg
                           &rclDst,            // prclDst
                           &rclNewSrc,         // prclSrc
                           NULL,               // pptlmask
                           BltMode); 
                }
                DELETE_SURFOBJ(psoNewSrc, &hBmpNewSrc);
                return iRet;
            }
        }
    }
    
    // set dirty surface flag since we're drawing in it
    CheckBitmapSurface(psoDst,NULL);
    return(EngPlgBlt(psoDst,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         pca,
                         pptlBrushOrg,
                         pptfx,
                         prclSrc,
                         pptlMask,
                         HALFTONE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\transpos.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    The module contains the functions associated with transposing bitmaps.
    This includes rotation of 1, 4, 8, and 24 bit formats as well as special
    transformations of color formats for planar of vertical head devices.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created

--*/
#include        "raster.h"
#include        "rmrender.h"


/*
 *   The transpose table:  maps one byte into two longs,  such that the
 * 8 bits of the byte turn into 64 bits: each bit of the original is
 * turned into one byte of output.
 *   THUS:
 * Input byte:   hgfedcba
 *   transposes into output bytes:
 *      0000000a  0000000b  0000000c  0000000d
 *      0000000e  0000000f  0000000g  0000000h
 *
 *   The table is allocated at DrvEnableSurface time,  thus ensuring that
 *  we do not allocate memory that we are not going to use.
 */

#define TABLE_SIZE      (256 * 2 * sizeof( DWORD ))

/*
 *   We also need a similar table for colour separation.  This one
 *  consists of 256 DWORDs,  and is used to split the RGB(K) format
 *  input byte into an output DWORD with the two R bits in one byte,
 *  the two G bits in the next byte etc.  Used for single pin colour
 *  printers,  like the HP PaintJet.
 *   The table is generated according to the following rule:
 *
 *  INPUT BYTE:  KRGBkrgb
 *
 *  OUTPUT DWORD:  000000Kk 000000Rr 000000Gg 000000Bb
 */

#define SEP_TABLE_SIZE  (256 * sizeof( DWORD ))



//*******************************************************
BOOL
bInitTrans (
    PDEV *pPDev
    )
/*++

Routine Description:

    This function initializes the transpose tables.  This is done to make
    the table independent of whether the processor is big endian or little
    endian since the data is generated by the processor that is going
    to use it!

Arguments:

    pPDev           Pointer to PDEV structure

Return Value:

    TRUE for success and FALSE for failure (MemAlloc failure)

--*/
{
    /*
     *   Function to generate the transposition table.  There is nothing
     * difficult about generating the table.  The only trick is the use
     * of the union.  This allows us to setup a DWORD table with the
     * byte ordering of the hardware on which we are running.  This is
     * achieved by writing the data into the BYTE entry,  then using
     * the same memory as a DWORD to be put away into memory.  The reason
     * for using DWORDS is to get maximum benefit from memory references
     * in the inner loop of the transpose functions.
     *   Note that the 8/24 bits per pel case is special, as we are shuffling
     * bytes around, and thus do not need any tables.  For this case,
     * return TRUE without allocating any storage.
     */

    register  DWORD   *pdw;
    register  int   iShift,  j;

    int    i;
    PRASTERPDEV pRPDev = pPDev->pRasterPDEV;

    union
    {
        BYTE   b[ 8 ];          /* Exactly 64 bits */
        DWORD  dw[ 2 ];         /* Also exactly 64 bits */
    } u;


    if( pRPDev->sDevBPP == 8 || pRPDev->sDevBPP == 24)
    {
        pRPDev->pdwTrans = NULL;

        return   TRUE;              /* Byte operations - no table needed */
    }

    if( !(pRPDev->pdwTrans = (DWORD *)MemAlloc( TABLE_SIZE )) )
        return  FALSE;


    pdw = pRPDev->pdwTrans;              /* Speedier access */


    /*
     *   Colour requires different tables,  as the pixel data consists of
     * 4 bits which need to move in a single group.
     */

    if( pRPDev->fDump & RES_DM_COLOR )
    {
        /*
         *   First generate the landscape to portrait transpose data.
         *  The only complication is maintaining 4 bit nibbles as a single
         *  entity.
         */
        u.dw[0] = 0;
        for (iShift = 0; iShift < 256; iShift++)
        {
            u.b[1] = (BYTE)((iShift >> 4) & 0x0f);
            u.b[3] = (BYTE)(iShift & 0x0f);
            *pdw = u.dw[0];
            *(pdw+1) = u.dw[0] << 4;
            pdw += 2;
        }
        /*
         * There is an additional transpose operation that requires
         * 4 bit pixel data be transformed to another format.
         */
        pRPDev->pdwColrSep = (DWORD *)MemAlloc( (pRPDev->fDump & RES_DM_GDI) ?
                                                        SEP_TABLE_SIZE : TABLE_SIZE );
        if( pRPDev->pdwColrSep == NULL )
        {
            MemFree((LPSTR)pRPDev->pdwTrans );
            pRPDev->pdwTrans = 0;

            return   FALSE;
        }

        pdw = pRPDev->pdwColrSep;    /* Speedier access */

        if( pRPDev->fDump & RES_DM_GDI )
        {

           /*
            *  HP Paintjet type devices require separating the RGB pixels
            *  (2 per colour per byte) into bytes where the two bits for
            *  each color are consecutive.
            */
            for( i = 0; i <= 0xff; i++ )
            {
                u.dw[ 0 ] = 0;

                iShift = i;
                if (!(pRPDev->fColorFormat & DC_OEM_BLACK))
                {
                    //
                    // if required combine the RGB to CMY(K) conversion
                    //
                    if ( !(pRPDev->fColorFormat & DC_PRIMARY_RGB))
                    {
                        iShift = (~iShift) & 0x77;
                        if (pRPDev->fColorFormat & DC_EXTRACT_BLK)
                        {
                            if( (iShift & 0x07) == 0x07 )
                                iShift = (iShift & ~0x07) | 0x08;

                            if( (iShift & 0x70) == 0x70 )
                                iShift = (iShift & ~0x70) | 0x80;
                        }
                    }
                    else
                        iShift &= 0x77;
                }

                /*   The two bits Bb  */
                u.b[ 3 ] = (BYTE)(((iShift >> 3) & 0x02) | (iShift & 0x1));
                iShift >>= 1;


                /*   The two bits Gg  */
                u.b[ 2 ] = (BYTE)(((iShift >> 3) & 0x02) | (iShift & 0x1));
                iShift >>= 1;


                /*   The two bits Rr  */
                u.b[ 1 ] = (BYTE)(((iShift >> 3) & 0x02) | (iShift & 0x1));
                iShift >>= 1;


                /*   The two bits Kk  */
                u.b[ 0 ] = (BYTE)(((iShift >> 3) & 0x02) | (iShift & 0x1));

                *pdw++ = u.dw[ 0 ];             /* Safe for posterity */
            }
        }
        else
        {
            /*
             *   The dot matrix case.  Here we will call the relevant
             * transpose function,  but use the modified table below.  This
             * table will do the colour separation,  and will result in the
             * transpose operation splitting up the data for each head pass.
             */

            for( i = 0; i <= 0xff; i++ )
            {
                /*  Each bit of i goes into one byte of the output  */
                u.dw[ 0 ] = 0;
                u.dw[ 1 ] = 0;

                iShift = i;
                if (!(pRPDev->fColorFormat & DC_OEM_BLACK))
                {
                    //
                    // if required combine the RGB to CMY(K) conversion
                    //
                    if ( !(pRPDev->fColorFormat & DC_PRIMARY_RGB))
                    {
                        iShift = (~iShift) & 0x77;
                        if (pRPDev->fColorFormat & DC_EXTRACT_BLK)
                        {
                            if( (iShift & 0x07) == 0x07 )
                                iShift = (iShift & ~0x07) | 0x08;

                            if( (iShift & 0x70) == 0x70 )
                                iShift = (iShift & ~0x70) | 0x80;
                        }
                    }
                    else
                        iShift &= 0x77;
                }

                for( j = 8; --j >= 0; )
                {
                    u.b[ j ] = (BYTE)(iShift & 0x1);
                    iShift >>= 1;
                }

                /*   Store the result  */
                *pdw = u.dw[0];
                *(pdw+1) = u.dw[1];
                pdw += 2;
            }
        }
    }
    else
    {
        /*
         *   Monochrome case - simple transpositions.
         */

        for( i = 0; i <= 0xff; i++ )
        {
            /*  Each bit of i goes into one byte of the output  */
            iShift = i;
            u.dw[ 0 ] = 0;
            u.dw[ 1 ] = 0;

            for( j = 8; --j >= 0; )
            {
                u.b[ j ] = (BYTE)(iShift & 0x1);
                iShift >>= 1;
            }

            /*   Store the result  */
            *pdw = u.dw[0];
            *(pdw+1) = u.dw[1];
            pdw += 2;
        }
    }

    return  TRUE;
}

//*******************************************************
void
vTrans8x8 (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    Function to transpose the input array into the output array,
    where the input data is to be considered 8 rows of bitmap data,
    and the output area is dword aligned.

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    The technique is quite simple,  though not necessarily obvious.
     *  Take an 8 scan line by 8 bits block of data,  and transform it
     *  into 8 bytes with bits in the scan line order,  rather than
     *  along the scan line as supplied.
     *    To do this as quickly as possible, each byte to be converted
     *  is used as an index into a lookup table;  each table entry is
     *  64 bits long (a pair of longs above).  These 64 bits are ORed
     *  with the running total of 64 bits (the two variables, dw0, dw1);
     *  shift the running total one bit left.  Repeat this operation
     *  for the corresponding byte in the next scan line - this is
     *  the new table lookup index.  Repeat for all 8 bytes in the 8
     *  scan lines being processed.  Store the 64 bit temporary results
     *  in the output dword array.  Move to the next byte in the
     *  scan line,  and repeat the loop for this column.
     */

    register  DWORD  dw0,  dw1;         /* Inner loop temporaries */
    register  BYTE  *pbTemp;
    register  DWORD *pdw;

    register  int    cbLine;            /* Bytes per line in scan data */
    register  int    i;                 /* Loop variable. */


    int      iWide;                     /* Pixels across the bitmap */
    DWORD   *pdwOut;                    /* Destination */
    DWORD   *pdwTrans;                  /* Local copy of output buffer */


    /*
     *   Some initialisation:  byte count,  area limits, etc.
     */


    cbLine = pRData->cbTLine;
    pdwOut = pRData->pvTransBuf;
    pdwTrans = pRData->Trans.pdwTransTab;

    if( pRData->iTransHigh != 8 )
    {
        /*  This can happen at the end of a page. */

        vTrans8N( pbIn,  pRData );

        return;
    }


    /*
     *   Scan across the lines in groups of 8 bits.  In the case that the
     *  input is not a multiple of 8,  we will produce a few extra
     *  bytes at the end;  the caller should allow for this when allocating
     *  storage for pdwOut.  The consequence is that the last few
     *  bytes will contain garbage; presumably the caller will not
     *  process them further.
     */

    for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
    {
        dw0 = 0;
        dw1 = 0;

        /*
         *   Loop DOWN the scanlines at the starting byte location,
         * generating the transposed data as we go.
         */

        for( i = BBITS, pbTemp = pbIn++; --i >= 0; pbTemp += cbLine )
        {
            dw0 <<= 1;
            dw1 <<= 1;
            pdw = pdwTrans + (*pbTemp << 1);
            dw0 |= *pdw;
            dw1 |= *(pdw + 1);
        }

        /*   Store the two temporary values in the output buffer. */
        *pdwOut = dw0;
        *(pdwOut + 1) = dw1;
        pdwOut += 2;
    }

    return;
}

//*******************************************************
void
vTrans8N (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    Function to transpose the input array into the output array,
    where the input data is to be considered N rows of bitmap data,
    and the output area is byte aligned.

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    The technique is quite simple,  though not necessarily obvious.
     *  Take an 8 scan line by 8 bits block of data,  and transform it
     *  into 8 bytes with bits in the scan line order,  rather than
     *  along the scan line as supplied.
     *    To do this as quickly as possible, each byte to be converted
     *  is used as an index into a lookup table;  each table entry is
     *  64 bits long (a pair of longs above).  These 64 bits are ORed
     *  with the running total of 64 bits (the two variables, dw0, dw1);
     *  shift the running total one bit left.  Repeat this operation
     *  for the corresponding byte in the next scan line - this is
     *  the new table lookup index.  Repeat for all 8 bytes in the 8
     *  scan lines being processed.  Store the 64 bit temporary results
     *  in the output dword array.  Move to the next byte in the
     *  scan line,  and repeat the loop for this column.
     *    This function is based on the special 8 X 8 case (vTrans8x8).
     *  The significant differences are that the transposed data needs
     *  to be written byte at a time (instead of DWORD at a time),
     *  and that there are N scan lines to convert in each loop.
     */

    DWORD  dw0,  dw1;         /* Inner loop temporaries */
    BYTE  *pbTemp;
    DWORD *pdw;
    int    cbLine;            /* Bytes per line in scan data */
    int    i;                 /* Loop variable. */
    int    iBand;             /* For moving down the scan lines */

    int      iSkip;                     /* Output interleave factor */
    int      iWide;                     /* Pixels across the bitmap */

    BYTE    *pbOut;                     /* Destination, local copy */
    BYTE    *pbBase;                    /* Start addr of 8 scan line group */
    BYTE    *pbOutTmp;                  /* For output loop */

    DWORD   *pdwTrans;                  /* Speedier access */
    BOOL    bOptimize = FALSE;



    /*
     *   Set up the local variables from the RENDER structure passed in.
     */

    cbLine = pRData->cbTLine;
    iSkip = pRData->iTransSkip;
    pbOut = pRData->pvTransBuf;                 /* Reserved for us! */
    pdwTrans = pRData->Trans.pdwTransTab;

    // if the translation table isn't inverting bits and the rows are DWORD aligned
    // we can optimize the algorithm by initializing everything to white
    // and then skipping the rotation of 32x8 white areas.
    //
    if (pdwTrans[0] == 0 && !(cbLine & 3) && pRData->iPassHigh == 1)
    {
        bOptimize = TRUE;
        FillMemory (pbOut, pRData->iTransWide * iSkip, 0xff);
    }
    /*
     *     To ease MMU thrashing,  we scan ACROSS the bitmap in 8 line
     *  groups.  This results in closer memory references,  and so less
     *  page faults and so faster execution.  Hence,  the outer most loop
     *  loops DOWN the scanlines.  The next inner loop scans across groups
     *  of 8 scan lines at a time,  while the inner most loop transposes
     *  one byte by 8 scan lines of bitmap image.
     *     Note that processing the data this way causes a slight increase
     *  in scattered memory addresses when writing the output data.
     *  There is no way to avoid one or the other memory references being
     *  scattered;  however,  the output area is smaller than the input
     *  input,  so scattering here will be less severe to the MMU.
     */
    for( iBand = pRData->iTransHigh; iBand >= BBITS; iBand -= BBITS )
    {
        /*
         *    Have selected the next group of 8 scan lines to process,
         *  so scan from left to right,  transposing data in 8 x 8 bit
         *  groups.  This is the size that can be done very quickly with
         *  a 32 bit environment.
         */

        pbBase = pbIn;
        pbIn += BBITS * cbLine;         /* Next address */

        pbOutTmp = pbOut;
        ++pbOut;                /* Onto the next byte sequence */

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            //
            // White space optimization. If input data is white then
            // we don't have to output rotated data since the
            // output buffer is already initialized to white.
            //
            if (bOptimize)
            {
                // test whether we are dword aligned so we can check
                // 32x8 area for white
                if (!((ULONG_PTR)pbBase & 3) && iWide >= DWBITS)
                {
                    if (*(DWORD *)&pbBase[0] == -1 &&
                        *(DWORD *)&pbBase[cbLine] == -1 &&
                        *(DWORD *)&pbBase[cbLine*2] == -1 &&
                        *(DWORD *)&pbBase[cbLine*3] == -1 &&
                        *(DWORD *)&pbBase[cbLine*4] == -1 &&
                        *(DWORD *)&pbBase[cbLine*5] == -1 &&
                        *(DWORD *)&pbBase[cbLine*6] == -1 &&
                        *(DWORD *)&pbBase[cbLine*7] == -1)
                    {
                        pbBase += 4;
                        iWide -= BBITS * 3;
                        pbOutTmp += iSkip * DWBITS;
                        continue;
                    }
                }
                // check 8x8 area for white
                else
                {
                    if (pbBase[0] == (BYTE)-1 &&
                        pbBase[cbLine] == (BYTE)-1 &&
                        pbBase[cbLine*2] == (BYTE)-1 &&
                        pbBase[cbLine*3] == (BYTE)-1 &&
                        pbBase[cbLine*4] == (BYTE)-1 &&
                        pbBase[cbLine*5] == (BYTE)-1 &&
                        pbBase[cbLine*6] == (BYTE)-1 &&
                        pbBase[cbLine*7] == (BYTE)-1)
                    {
                        pbBase++;
                        pbOutTmp += iSkip * BBITS;
                        continue;
                    }
                }
            }
            /*
             *    Process the bitmap byte at a time moving across, and
             *  8 scan lines high.  This corresponds to transposing an
             *  8 x 8 bit array.  We can do that quickly.
             */
            pbTemp = pbBase++;
            dw0 = 0;
            dw1 = 0;
            for( i = BBITS; --i >= 0; pbTemp += cbLine )
            {
                /*   The INNER loop - the bit swapping operations */
                dw0 <<= 1;
                dw1 <<= 1;
                pdw = pdwTrans + (*pbTemp << 1);
                dw0 |= *pdw;
                dw1 |= *(pdw + 1);
            }

            /*   Store the two temporary values in the output buffer. */
            *pbOutTmp = (BYTE)dw0;

            pbOutTmp += iSkip;
            dw0 >>= BBITS;              /* One byte's worth */
            *pbOutTmp = (BYTE)dw0;

            pbOutTmp += iSkip;
            dw0 >>= BBITS;
            *pbOutTmp = (BYTE)dw0;

            pbOutTmp += iSkip;
            dw0 >>= BBITS;
            *pbOutTmp = (BYTE)dw0;

            pbOutTmp += iSkip;
            *pbOutTmp = (BYTE)dw1;

            pbOutTmp += iSkip;
            dw1 >>= BBITS;
            *pbOutTmp = (BYTE)dw1;

            pbOutTmp += iSkip;
            dw1 >>= BBITS;
            *pbOutTmp = (BYTE)dw1;

            pbOutTmp += iSkip;
            dw1 >>= BBITS;
            *pbOutTmp = (BYTE)dw1;

            pbOutTmp += iSkip;  /* Next chunk of output data */
        }
    }

    /*
     *    There may be some scan lines remaining.  If so,  iBand will
     *  be > 0,  and that indicates the number of output scan lines
     *  remaining.
     */

    if( iBand > 0 )
    {

        /*
         *   This is basically the same as the stripped down version
         *  in the outer loop above.  Note that the output data is still
         *  byte aligned,  IT IS PRESUMED THAT THE 'MISSING' LINES ARE
         *  ZERO FILLED.  This may not be what is desired - it is for
         *  transposing bits to output to a dot matrix printer where
         *  the page length is not a multiple of the number of pins.
         *  I don't know if that can ever happen.
         */

        pbBase = pbIn;
        pbOutTmp = pbOut;

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            /*
             *    Process the bitmap byte at a time moving across, and
             *  8 scan lines high.  This corresponds to transposing an
             *  8 x 8 bit array.  We can do that quickly.
             */
            dw0 = 0;
            dw1 = 0;
            pbTemp = pbBase++;

            /*
             *    The inner loop now only transposes as many scan lines
             *  as the bitmap actually contains - we must not run off
             *  the end of memory.
             */

            for( i = iBand; --i >= 0; pbTemp += cbLine )
            {
                /*   The INNER loop - the bit swapping operations */
                dw0 <<= 1;
                dw1 <<= 1;
                pdw = pdwTrans + (*pbTemp << 1);
                dw0 |= *pdw;
                dw1 |= *(pdw + 1);

            }

            // white fill remaining bits
            //
            pdw = pdwTrans + (pRData->ubFillWhite << 1);
            i = BBITS - iBand;
            while (--i >= 0)
            {
                dw0 <<= 1;
                dw1 <<= 1;
                dw0 |= *pdw;
                dw1 |= *(pdw + 1);
            }

            /*   Store the two temporary values in the output buffer. */
            pbTemp = pbOutTmp;
            *pbTemp = (BYTE)dw0;

            pbTemp += iSkip;
            dw0 >>= BBITS;              /* One byte's worth */
            *pbTemp = (BYTE)dw0;

            pbTemp += iSkip;
            dw0 >>= BBITS;
            *pbTemp = (BYTE)dw0;

            pbTemp += iSkip;
            dw0 >>= BBITS;
            *pbTemp = (BYTE)dw0;

            pbTemp += iSkip;
            *pbTemp = (BYTE)dw1;

            pbTemp += iSkip;
            dw1 >>= BBITS;
            *pbTemp = (BYTE)dw1;

            pbTemp += iSkip;
            dw1 >>= BBITS;
            *pbTemp = (BYTE)dw1;

            pbTemp += iSkip;
            dw1 >>= BBITS;
            *pbTemp = (BYTE)dw1;

            pbOutTmp += BBITS * iSkip;  /* Next chunk of output data */
        }

    }

    return;
}


/*
 *   Define the number of pels transposed per loop iteration.  In the case
 * of a colour bitmap, this is 2,  since there are 4 bits per pel, thus
 * 2 per byte.
 */

#define PELS_PER_LOOP   (BBITS / 4)


//*******************************************************
void
vTrans8N4BPP (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    Function to transpose the input array into the output array,
    where the input data is to be considered N rows of bitmap data,
    and the output area is byte aligned.
    This version works on 4 bits per pel bitmaps (colour for us).

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    The technique is quite simple,  though not necessarily obvious.
     *  Take an 8 scan line by 8 bits block of data,  and transform it
     *  into 8 bytes with bits in the scan line order,  rather than
     *  along the scan line as supplied.
     *    To do this as quickly as possible, each byte to be converted
     *  is used as an index into a lookup table;  each table entry is
     *  64 bits long (a pair of longs above).  These 64 bits are ORed
     *  with the running total of 64 bits (the two variables, dw0, dw1);
     *  shift the running total one bit left.  Repeat this operation
     *  for the corresponding byte in the next scan line - this is
     *  the new table lookup index.  Repeat for all 8 bytes in the 8
     *  scan lines being processed.  Store the 64 bit temporary results
     *  in the output dword array.  Move to the next byte in the
     *  scan line,  and repeat the loop for this column.
     *    This function is based on the special 8 X 8 case (vTrans8x8).
     *  The significant differences are that the transposed data needs
     *  to be written byte at a time (instead of DWORD at a time),
     *  and that there are N scan lines to convert in each loop.
     */

    register  DWORD  dw0,  dw1;         /* Inner loop temporaries */
    register  BYTE  *pbTemp;
    register  DWORD *pdw;

    register  int    cbLine;            /* Bytes per line in scan data */
    register  int    i;                 /* Loop variable. */
    register  int    iBand;             /* For moving down the scan lines */

    int      iSkip;                     /* Output interleave factor */
    int      iWide;                     /* Pixels across the bitmap */

    DWORD   *pdwOut;                    /* Destination, local copy */
    BYTE    *pbBase;                    /* Start addr of 8 scan line group */
    DWORD   *pdwOutTmp;                 /* For output loop */

    DWORD   *pdwTrans;                  /* Speedier access */


    /*
     *   Set up the local variables from the RENDER structure passed in.
     *  See the above function for explanation of iSkip.
     */

    cbLine = pRData->cbTLine;
    iSkip = pRData->iTransSkip / DWBYTES;
    pdwOut = pRData->pvTransBuf;                        /* Reserved for us! */
    pdwTrans = pRData->Trans.pdwTransTab;

    /*
     *     To ease MMU thrashing,  we scan ACROSS the bitmap in 8 line
     *  groups.  This results in closer memory references,  and so less
     *  page faults and faster execution.  Hence,  the outer most loop
     *  loops DOWN the scanlines.  Then next inner loop scans across groups
     *  of 8 scan lines at a time,  while the inner most loop transposes
     *  one byte by 8 scan lines of bitmap image.
     *     Note that processing the data this way causes a slight increase
     *  in scattered memory addresses when writing the output data.
     *  There is no way to avoid one or the other memory references being
     *  scattered;  however,  the output area is smaller than the input
     *  input,  so scattering here will be less severe on the MMU.
     */


    for( iBand = pRData->iTransHigh; iBand >= BBITS; iBand -= BBITS )
    {

        /*
         *    Have selected the next group of 8 scan lines to process,
         *  so scan from left to right,  transposing data in 8 x 8 bit
         *  groups.  This is the size that can be done very quickly with
         *  a 32 bit environment.
         */

        pbBase = pbIn;
        pbIn += BBITS * cbLine;         /* Next address */

        pdwOutTmp = pdwOut;
        ++pdwOut;               /* Onto the next byte sequence */

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            /*
             *    Process the bitmap byte at a time moving across, and
             *  8 scan lines high.  This corresponds to transposing an
             *  8 x 8 pixel array.  We can do that quickly.
             */

            pbTemp = pbBase++;

            dw0 = *(pdwTrans + 1 + (*pbTemp << 1));
            pbTemp += cbLine;
            dw0 |= *(pdwTrans + (*pbTemp << 1));
            pbTemp += cbLine;

            dw0 >>= 8;

            dw0 |= *(pdwTrans + 1 + (*pbTemp << 1));
            pbTemp += cbLine;
            dw0 |= *(pdwTrans + (*pbTemp << 1));
            pbTemp += cbLine;

            dw1 = *(pdwTrans + 1 + (*pbTemp << 1));
            pbTemp += cbLine;
            dw1 |= *(pdwTrans + (*pbTemp << 1));
            pbTemp += cbLine;

            dw1 >>= 8;

            dw1 |= *(pdwTrans + 1 + (*pbTemp << 1));
            pbTemp += cbLine;
            dw1 |= *(pdwTrans + (*pbTemp << 1));

            *(WORD *)pdwOutTmp = (WORD)dw0;
            *(((WORD *)pdwOutTmp)+1) = (WORD)dw1;
            *(pdwOutTmp+iSkip) = (dw1 & 0xffff0000) | (dw0 >> 16);
            pdwOutTmp += PELS_PER_LOOP * iSkip; /* Next chunk of output data */
        }

    }

    /*
     *    There may be some scan lines remaining.  If so,  iBand will
     *  be > 0,  and that indicates the number of output scan lines
     *  remaining.
     */

    if( iBand > 0 )
    {

        /*
         *   This is basically the same as the stripped down version
         *  in the outer loop above.  Note that the output data is still
         *  byte aligned,  IT IS PRESUMED THAT THE 'MISSING' LINES ARE
         *  ZERO FILLED.  This may not be what is desired - it is for
         *  transposing bits to output to a dot matrix printer where
         *  the page length is not a multiple of the number of pins.
         *  I don't know if that can ever happen.
         */

        pbBase = pbIn;
        pdwOutTmp = pdwOut;

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            /*
             *    Process the bitmap byte at a time moving across, and
             *  8 scan lines high.  This corresponds to transposing an
             *  8 x 8 bit array.  We can do that quickly.
             */
            pbTemp = pbBase++;

            dw0 = *(pdwTrans + 1 + (*pbTemp << 1));
            dw1 = 0;
            if (iBand > 1)
            {
                pbTemp += cbLine;
                dw0 |= *(pdwTrans + (*pbTemp << 1));
                dw0 >>= 8;
                if (iBand > 2)
                {
                    pbTemp += cbLine;
                    dw0 |= *(pdwTrans + 1 + (*pbTemp << 1));
                    if (iBand > 3)
                    {
                        pbTemp += cbLine;
                        dw0 |= *(pdwTrans + (*pbTemp << 1));
                        if (iBand > 4)
                        {
                            pbTemp += cbLine;
                            dw1 = *(pdwTrans + 1 + (*pbTemp << 1));
                            if (iBand > 5)
                            {
                                pbTemp += cbLine;
                                dw1 |= *(pdwTrans + (*pbTemp << 1));
                                dw1 >>= 8;
                                if (iBand > 6)
                                {
                                    pbTemp += cbLine;
                                    dw1 |= *(pdwTrans + 1 + (*pbTemp << 1));
                                }
                            }
                            else
                                dw1 >>= 8;
                        }
                    }
                }
            }
            else
                dw0 >>= 8;

            *(WORD *)pdwOutTmp = (WORD)dw0;
            *(((WORD *)pdwOutTmp)+1) = (WORD)dw1;
            *(pdwOutTmp+iSkip) = (dw1 & 0xffff0000) | (dw0 >> 16);

            pdwOutTmp += 2 * iSkip;     /* Next chunk of output data */
        }

    }

    return;
}

//*******************************************************
void
vTransColSep (
    register BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    Function to transpose the colour bits in a 4 Bits Per Pel colour
    bitmap into an array of bytes,  where the bytes are ordered in
    the same way as the original bits.  An example of this is provided
    in the explanation for the SEP_TABLE_SIZE value at the top of this file.

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    Operation is quite simple - pass along the input array byte
     *  at a time,  and use each 4 byte group to generate a DWORD of
     *  output - placed in pdwOut.  The previously generated translation
     *  table is especially formulated to do this job!
     *
     *    NOTE:  pdwOut and pbIn MAY POINT TO THE SAME ADDRESS!  THERE IS
     *  NO OVERLAP IN OPERATIONS TO CAUSE CONFUSION.
     */

    register  DWORD   dwTemp;
    register  DWORD  *pdwSep;

    int      iI;
    int      iBlock;
    DWORD   *pdwOut;            /* Destination - DWORD aligned */
    DWORD   dwWhite;


    iBlock = pRData->cDWLine * pRData->iNumScans;

    pdwSep = pRData->pdwColrSep;                /* Colour separation table */
    pdwOut = pRData->pvTransBuf;                /* Where the data goes */


    /*   Loop through the line in 4 byte groups */

    //
    // calculate the white conversion value
    //
    dwWhite = *(pdwSep + 0x77);
    dwWhite |= (dwWhite << 2) | (dwWhite << 4) | (dwWhite << 6);

    //
    // convert the data to planar including RGB to CMY(K)
    //
    for (iI = iBlock; --iI >= 0;)
    {
        if (*(DWORD *)pbIn == 0x77777777L)
        {
            *pdwOut++ = dwWhite;
        }
        else
        {
            dwTemp = *(pdwSep + *pbIn);

            dwTemp <<= 2;
            dwTemp |= *(pdwSep + pbIn[1]);

            dwTemp <<= 2;
            dwTemp |= *(pdwSep + pbIn[2]);

            *pdwOut++ = (dwTemp << 2) | *(pdwSep + pbIn[3]);
        }
        pbIn += DWBYTES;
    }

    return;

}


//*******************************************************
void
vTrans8BPP (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    The transpose function for 8 bits per pel bitmaps.  This is rather
    easy, as all we do is shuffle bytes!

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{

    /*
     *    Scan along the input bitmap,  writing the data to the output
     *  in column order.  This results in reduced MMU thrashing, as
     *  the output addresses are all limited to a much smaller range
     *  than the incoming addresses.
     */

    register  BYTE   *pbBase;             /* Scan along input bitmap */
    register  BYTE   *pbOut;              /* The output scan column pointer */

    int     iBand;                 /* Count down scan lines */
    int     iSkip;                 /* Offset between output bytes */
    int     iWide;                 /* Loop across the input scan line */
    int     cbLine;                /* Bytes per input scan line */

    BYTE   *pbOutBase;             /* Start of column of output data */


    /*
     *   Set up the local copies (for faster access) of data passed in.
     */

    cbLine = pRData->cbTLine;
    iSkip = pRData->iTransSkip;
    pbOutBase = pRData->pvTransBuf;       /* Base output buffer address */


    for( iBand = pRData->iTransHigh; iBand > 0; --iBand )
    {
        /*
         *    This loop processes scan lines in the input bitmap. As
         *  we progress across the scan line, the output data is written
         *  in column order.
         */

        pbBase = pbIn;
        pbIn += cbLine;            /* Next scan line, DWORD aligned */

        pbOut = pbOutBase;
        ++pbOutBase;               /* One column across output area */

        for( iWide = pRData->iTransWide; iWide > 0; iWide -= BBITS )
        {
            /*
             *   This loop traverses the input scan line, taking bytes
             *  and writing them to the output area in column order.
             */

            *pbOut = *pbBase++;
            pbOut += iSkip;
        }
    }

    return;
}

//*******************************************************
void
vTrans24BPP (
    BYTE  *pbIn,
    RENDER  *pRData
    )
/*++

Routine Description:

    The transpose function for 8 bits per pel bitmaps.  This is rather
    easy, as all we do is shuffle bytes!

Arguments:

    pbIn        Pointer to input data buffer to transform
    pRData      Pointer to render structure containing all the
                necessary information about transforming

Return Value:

    none

--*/
{
    /*
     *    Scan along the input bitmap,  writing the data to the output
     *  in column order.  This results in reduced MMU thrashing, as
     *  the output addresses are all limited to a much smaller range
     *  than the incoming addresses.
     */

    register  BYTE   *pbBase;             /* Scan along input bitmap */
    register  BYTE   *pbOut;              /* The output scan column pointer */

    int     iBand;                 /* Count down scan lines */
    int     iSkip;                 /* Offset between output bytes */
    int     iWide;                 /* Loop across the input scan line */
    int     iCol;
    int     iRow;
    int     cbLine;                /* Bytes per input scan line */
    int     iBytesLeftOver;

    BYTE   *pbOutBase;             /* Start of column of output data */


    /*
     *   Set up the local copies (for faster access) of data passed in.
     */

    iSkip = pRData->iTransSkip;
    cbLine = pRData->cbTLine;
    pbOutBase = pRData->pvTransBuf;       /* Base output buffer address */
    iCol =  pRData->iTransWide/pRData->iBPP;
    iRow = pRData->iTransHigh;
    iBytesLeftOver = (pRData->iTransHigh *pRData->iBPP) % DWBITS;

    for( iBand = iRow; iBand > 0; --iBand )
    {
        /*
         *    This loop processes scan lines in the input bitmap. As
         *  we progress across the scan line, the output data is written
         *  in column order.
         */

        pbBase = pbIn;
        pbIn += cbLine;            /* Next scan line, DWORD aligned */

        pbOut = pbOutBase;
        pbOutBase+=3;               /* One column across output area */

        for( iWide = iCol; iWide > 0; --iWide )
        {
            /*
             *   This loop traverses the input scan line, taking bytes
             *  and writing them to the output area in column order.
             */
            *pbOut = *pbBase++;
            *(pbOut+1) = *pbBase++;
            *(pbOut+2) = *pbBase++;
            pbOut += iSkip;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\rules.c ===
/************************* Module Header ************************************
 * rules.c
 *      Functions to rummage over the final bitmap and replace black
 *      rectangular areas with rules.  The major benefit of this is
 *      to reduce the volume of data sent to the printer.  This speeds
 *      up printing by reducing the I/O bottleneck.
 *
 *      Strategy is based on Ron Murray's work for the PM PCL driver.
 *
 * CREATED:
 *  11:39 on Thu 16 May 1991    -by-    Lindsay Harris   [lindsayh]
 *
 *  Copyright (C) 1991 - 1999,  Microsoft Corporation.
 *
 *****************************************************************************/

//#define _LH_DBG 1

#include "raster.h"
#include "rastproc.h"
#include "rmrender.h"

/*
 *   The structure that maps BYTES into DWORDS.
 */
typedef  union
{
    DWORD   dw;                 /* Data as a DWORD  */
    BYTE    b[ DWBYTES ];       /* Data as bytes */
}  UBDW;

/*
 *   The RULE structure stores details of the horizontal rules we have
 *  so far found.  Each rule contains the start address (top left corner)
 *  and end address (bottom right corner) of the area.
 */
typedef  struct
{
    WORD   wxOrg;               /* X origin of this rule */
    WORD   wyOrg;               /* Y origin */
    WORD   wxEnd;               /* X end of rule */
    WORD   wyEnd;               /* Y end of rule */
} RULE;

#define HRULE_MAX_OLD   15      /* Maximum horizontal rules per stripe */
#define HRULE_MAX_NEW   32      /* Maximum horizontal rules per stripe */
#define HRULE_MIN       2       /* Minimum DWORDs for a horizontal rule */
#define HRULE_MIN_HCNT  2       /* Minimum number of horizontal rules */

#define LJII_MAXHEIGHT  34      /* maximum height of laserjet II rules */
/*
 *   Other RonM determined data is:-
 *      34 scan lines per stripe
 *      14 null bytes between raster column operations
 *     112 raster rows maximum in raster column searching.
 *              The latter reduces the probability of error 21.
 */

/*
 *   Define the structure to hold the various pointers, tables, etc used
 * during the rule scanning operations.  The PDEV structure holds a pointer
 * to this,  to simplify access and freeing of the memory.
 */

typedef  struct
{
    int     iLines;             /*  Scan lines processed per pass */
    int     cdwLine;            /*  Dwords per scan line */
    int     iyPrtLine;          /*  Actual line number as printer sees it */

    int     ixScale;            /*  Scale factor for X variables */
    int     iyScale;            /*  Scale factor for Y */
    int     ixOffset;           /*  X Offset for landscape shift */
    int     iMaxRules;          /*  Maximum number of rules to allow per stripe */

    RENDER *pRData;             /*  Rendering info - useful everywhere */

                /*  Entries for finding vertical rules.  */
    DWORD  *pdwAccum;           /*  Bit accumulation this stripe */

                /*  Horizontal rule parameters.  */
    RULE    HRule[ HRULE_MAX_NEW ]; /*  Horizontal rule details */
    short  *pRTVert;            /*  Vertical run table */
    short  *pRTLast;            /*  Run table for the last line */
    short  *pRTCur;             /*  Current line run table */
    RULE  **ppRLast;            /*  Rule descriptor for the last scan line */
    RULE  **ppRCur;             /*  Current scan line rule details */

}  RULE_DATA;



#if _LH_DBG

/*  Useful for debugging purposes  */
#define NO_RULES        0x0001          /* Do not look for rules */
#define NO_SEND_RULES   0x0002          /* Do not transmit rules, but erase */
#define NO_SEND_HORZ    0x0004          /* Do not send horizontal rules */
#define NO_SEND_VERT    0x0008          /* Do not send vertical rules */
#define NO_CLEAR_HORZ   0x0010          /* Do not erase horizontal rules */
#define NO_CLEAR_VERT   0x0020          /* Do not erase vertical rules */
#define RULE_VERBOSE    0x0040          /* Print rule dimensions */
#define RULE_STRIPE     0x0080          /* Draw a rule at the end of stripe */
#define RULE_BREAK      0x0100          /* Enter debugger at init time */

static  int  _lh_flags = 0;

#endif

/*  Private function headers  */

static  void vSendRule( PDEV *, int, int, int, int );


/*************************** Module Header ********************************
 * vRuleInit
 *      Called at the beginning of rendering a bitmap.  Function allocates
 *      storage and initialises it for later.  Storage is only allocated
 *      as needed.  Second and later calls will only initialise the
 *      previously allocated storage.
 *
 * RETURNS:
 *      Nothing
 *
 * HISTORY:
 *  13:20 on Thu 16 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it,  based on Ron Murray's ideas.
 *
 **************************************************************************/

void
vRuleInit( pPDev, pRData )
PDEV   *pPDev;          /* Record the info we want */
RENDER *pRData;         /* Useful rendering info */
{

    int    cbLine;              /*  Byte count per scan line */
    int    cdwLine;             /*  DWORDs per scan line - often used */
    int    iI;                  /*  Loop parameter  */

    RULE_DATA  *pRD;
    RASTERPDEV    *pRPDev;        /* For access to scaling information */


    if( pRData->iBPP != 1 )
        return;                 /* Can't handle colour */

    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    /*
     *    Calculate the size of the input scan lines.  We do this because
     *  we need to consider whether we rotate or not;  the information in
     *  the RENDER structure passed in does not consider this until later.
     */

//    cdwLine = pPDev->fMode & PF_ROTATE ? pRPDev->szlPage.cy :
//                                          pRPDev->szlPage.cx;
    cdwLine = pPDev->fMode & PF_ROTATE ? pPDev->sf.szImageAreaG.cy :
                                         pPDev->sf.szImageAreaG.cx;
    cdwLine = (cdwLine + DWBITS - 1) / DWBITS;
    cbLine = cdwLine * DWBYTES;



    if( pRD = pRPDev->pRuleData )
    {
        /*
         *    This can happen if the document switches from  landscape
         *  to portrait,  for example.   The code in vRuleFree will
         *  throw away all out memory and then set the pointer to NULL,
         *  so that we allocate anew later on.
         */

        if( (int)pRD->cdwLine != cdwLine )
            vRuleFree( pPDev );                 /*  Free it all up! */
    }

    /*
     *   First step is to allocate a RULE_DATA structure from our heap.
     *  Then we can allocate the other data areas in it.
     */

    if( (pRD = pRPDev->pRuleData) == NULL )
    {
        /*
         *   Nothing exists,  so first step is to allocate it all.
         */
        if( !(pRD = (RULE_DATA *)MemAllocZ(sizeof( RULE_DATA ) )) )
            return;


        pRPDev->pRuleData = pRD;

        /*
         *    Allocate storage for the vertical rule finding code.
         */
        if( !(pRD->pdwAccum = (DWORD *)MemAllocZ( cbLine )) )
        {

            vRuleFree( pPDev );

            return;
        }
#ifndef DISABLE_HRULES
        /*
         *    Allocate storage for the horizontal rule finding code.
         */
        if (pRPDev->fRMode & PFR_RECT_HORIZFILL)
        {
            iI = cdwLine * sizeof( short );

            if( !(pRD->pRTVert = (short *)MemAlloc( iI )) ||
                !(pRD->pRTLast = (short *)MemAlloc( iI )) ||
                !(pRD->pRTCur = (short *)MemAlloc( iI )) )
            {

                vRuleFree( pPDev );

                return;
            }

            /*
             *   Storage for the horizontal rule descriptors.  These are pointers
             *  to the array stored in the RULE_DATA structure.
            */

            iI = cdwLine * sizeof( RULE * );

            if( !(pRD->ppRLast = (RULE **)MemAlloc( iI )) ||
                !(pRD->ppRCur = (RULE **)MemAlloc( iI )) )
            {

                vRuleFree( pPDev );

                return;
            }
        }
#endif
    }
    // determine maximum number of rules to allow, we allow more for
    // FE_RLE since we know these devices can handle the additional rules
    //
    if (pRPDev->fRMode & PFR_COMP_FERLE)
        pRD->iMaxRules = HRULE_MAX_NEW;
    else
    {
        pRD->iMaxRules = HRULE_MAX_OLD;
        if (pRPDev->fRMode & PFR_RECT_HORIZFILL)
            pRD->iMaxRules -= HRULE_MIN_HCNT;
    }

    /*
     *   Storage now available,  so initialise the bit vectors, etc.
     */

    if (pPDev->ptGrxRes.y >= 1200)
        pRD->iLines = 128;
    else if (pPDev->ptGrxRes.y >= 600)
        pRD->iLines = 64;
    else
        pRD->iLines = LJII_MAXHEIGHT;   // optimized for laserjet series II

    pRD->cdwLine = cdwLine;

    pRD->pRData = pRData;       /* For convenience */

    pRD->ixScale = pPDev->ptGrxScale.x;
    pRD->iyScale = pPDev->ptGrxScale.y;

    if ((pPDev->fMode & PF_CCW_ROTATE90) &&
        pPDev->ptDeviceFac.x < pPDev->ptGrxScale.x &&
        pPDev->ptDeviceFac.x > 0)
    {
        pRD->ixOffset = pPDev->ptGrxScale.x - 1;
    }
    else
        pRD->ixOffset = 0;
    return;
}


/************************** Module Header **********************************
 * vRuleFree
 *      Frees the storage allocated in vRuleInit.
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 *  13:24 on Thu 16 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created.
 *
 ***************************************************************************/

void
vRuleFree( pPDev )
PDEV   *pPDev;          /* Points to our storage areas */
{
    RULE_DATA  *pRD;
    RASTERPDEV *pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;

    if( pRD = pRPDev->pRuleData )
    {

        /*  Storage allocated,  so free it  */

        if( pRD->pdwAccum )
            MemFree( (LPSTR)pRD->pdwAccum );
        if( pRD->pRTVert )
            MemFree( (LPSTR)pRD->pRTVert );
        if( pRD->pRTLast )
            MemFree( (LPSTR)pRD->pRTLast );
        if( pRD->pRTCur )
            MemFree( (LPSTR)pRD->pRTCur );

        if( pRD->ppRLast )
            MemFree( (LPSTR)pRD->ppRLast );
        if( pRD->ppRCur )
            MemFree( (LPSTR)pRD->ppRCur );

        MemFree (pRD);
        pRPDev->pRuleData = 0;           /* Not there now that it's gone! */
    }
    return;
}

/**************************** Module Header ********************************
 * vRuleProc
 *      Function to find the rules in a bitmap stripe,  then to send them
 *      to the printer and erase them from the bitmap.
 *
 *  This function has been optimized to combine invertion and whitespace
 *  edge detection into a single pass.  Refer to the comments in bRender
 *  for a description.
 *
 *  Future optimizations include:
 *      call the output routines for each 34 scan band as the
 *      band is done with rule detection. (while it's still in the cache).
 *
 *      For various reasons, mainly due to the limitations of the ,
 *      HP LaserJet Series II, the maximum number of rules is limited to
 *      15 per 34 scan band and no coalescing is performed.  This should
 *      be made to be a per printer parameter so that the newer laserjets
 *      don't need to deal with this limitation.
 *
 *      The rules should be coalesced between bands.  I believe this can
 *      cause problems, however, for the LaserJet Series II.
 *
 *      If the printer supports compression (HP LaserJet III and on I believe)
 *      no hrules should be detected (according to info from LindsayH).
 *
 * RETURNS:
 *      Nothing.  Failure is benign.
 *
 * HISTORY:
 *  30-Dec-1993 -by-  Eric Kutter [erick]
 *      optimized for HP laserjet
 *
 *  13:29 on Thu 16 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it,  from Ron Murray's PM PCL driver ideas.
 *
 ****************************************************************************/

// given a bit index 0 - 31, this table gives a mask to see if the bit is on
// in a DWORD.

DWORD gdwBitOn[DWBITS] =
{
    0x00000080,
    0x00000040,
    0x00000020,
    0x00000010,
    0x00000008,
    0x00000004,
    0x00000002,
    0x00000001,

    0x00008000,
    0x00004000,
    0x00002000,
    0x00001000,
    0x00000800,
    0x00000400,
    0x00000200,
    0x00000100,

    0x00800000,
    0x00400000,
    0x00200000,
    0x00100000,
    0x00080000,
    0x00040000,
    0x00020000,
    0x00010000,

    0x80000000,
    0x40000000,
    0x20000000,
    0x10000000,
    0x08000000,
    0x04000000,
    0x02000000,
    0x01000000
};

// given a bit index from 1 - 31, this table gives all bits right of that index
// in a DWORD.

DWORD gdwBitMask[DWBITS] =
{
    0xffffff7f,
    0xffffff3f,
    0xffffff1f,
    0xffffff0f,
    0xffffff07,
    0xffffff03,
    0xffffff01,
    0xffffff00,

    0xffff7f00,
    0xffff3f00,
    0xffff1f00,
    0xffff0f00,
    0xffff0700,
    0xffff0300,
    0xffff0100,
    0xffff0000,

    0xff7f0000,
    0xff3f0000,
    0xff1f0000,
    0xff0f0000,
    0xff070000,
    0xff030000,
    0xff010000,
    0xff000000,

    0x7f000000,
    0x3f000000,
    0x1f000000,
    0x0f000000,
    0x07000000,
    0x03000000,
    0x01000000,
    0x00000000,
};

#if DBG
BOOL gbDoRules  = 1;
#endif

BOOL
bRuleProc( pPDev, pRData, pdwBits )
PDEV     *pPDev;                /* All we wanted to know */
RENDER   *pRData;               /* All critical rendering information */
DWORD    *pdwBits;              /* The base of the data area. */
{

    register  DWORD  *pdwOr;   /* Steps through the accumulation array */
    register  DWORD  *pdwIn;    /* Passing over input vector */
    register  int     iIReg;    /* Inner loop parameter */

    int   i;
    int   iI;           /* Loop parameter */
    int   iLim;         /* Loop limit */
    int   iLine;        /* The outer loop */
    int   iLast;        /* Remember the previous horizontal segment */
    int   cdwLine;      /* DWORDS per scan line */
    int   idwLine;      /* SIGNED dwords per line - for address fiddling */
    int   iILAdv;       /* Line number increment,  scan line to scan line */
    int   ixOrg;        /* X origin of this rule */
    int   iyPrtLine;    /* Line number, as printer sees it.  */
    int   iyEnd;        /* Last scan line this stripe */
    int   iy1Short;     /* Number of scan lines minus 1 - LJ bug?? */
    int   iLen;         /* Length of horizontal run */
    int   cHRules;      /* Count of horizontal rules in this stripe */
    int   cRuleLim;     /* Max rules allowed per stripe */

    DWORD dwMask;       /* Chop off trailing bits on bitmap */

    RULE_DATA  *pRD;    /* The important data */
    RASTERPDEV *pRPDev; // pointer to raster pdev
    BYTE       *pbRasterScanBuf; // pointer to surface block status

    PLEFTRIGHT plrCur;  /* left/right structure for current row */
    PLEFTRIGHT plr = pRData->plrWhite; /* always points to the top of the segment */

#if _LH_DBG
    if( _lh_flags & NO_RULES )
        return(FALSE);                 /* Nothing wanted here */
#endif

    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;
    if( !(pRD = pRPDev->pRuleData) )
        return(FALSE);                 /*  Initialisation failed */

    if( pRD->cdwLine != pRData->cDWLine )
    {
        /*
         *   This code detects the case where vRuleInit() was called with
         * the printer set for landscape mode, and then we are called here
         * after the transpose and so are (effectively) in portrait mode.
         * If the old parameters are used,  heap corruption will occur!
         * This should not be necessary, as we ought to call vRuleInit()
         * at the correct time, but that means hacking into the rendering
         * code.
         */

#if DBG
        DbgPrint( "unidrv!bRuleProc: cdwLine differs: old = %ld, new = %ld\n",
                                 pRD->cdwLine, pRData->cDWLine );

#endif
        vRuleFree( pPDev );
        vRuleInit( pPDev, pRData );

        if( !(pRD = pRPDev->pRuleData) )
        {
            return(FALSE);
        }
    }


    idwLine = cdwLine = pRData->cDWLine;
    iILAdv = 1;
    if( pRData->iPosnAdv < 0 )
    {
        idwLine = -idwLine;
        iILAdv = -1;
    }

    iyPrtLine = pRD->iyPrtLine = pRData->iyPrtLine;

    dwMask = *(pRPDev->pdwBitMask + pRData->ix % DWBITS);
    if( dwMask == 0 )
        dwMask = ~((DWORD)0);           /* All bits are in use */

    /*
     *  setup the left/right structure.  If we can not allocate enough memory
     *  free the rule structure and return failure.
     */

    if ((plr == NULL) || ((int)pRData->clr < pRData->iy))
    {
        if (plr != NULL)
            MemFree(plr);

        pRData->plrWhite = (PLEFTRIGHT)MemAlloc(sizeof(LEFTRIGHT)*pRData->iy);

        if (pRData->plrWhite == NULL)
        {
            vRuleFree( pPDev );
            return(FALSE);
        }

        plr = pRData->plrWhite;
        pRData->clr = pRData->iy;
    }
    //
    // Determine if block erasing of the bitmap is enabled
    //
    if (!(pPDev->fMode & PF_SURFACE_ERASED))
        pbRasterScanBuf = pPDev->pbRasterScanBuf;
    else
        pbRasterScanBuf = NULL;


    /*
     *    Outer loop processes through the bitmap in chunks of iLine,
     *  the number of lines we like to process in one pass.  iLine is
     *  the basic vertical granularity for vertical rule finding.
     *  Any line less than iLines high will NOT be detected by this
     *  mechanism.
     */

    /*
     *   NOTE:  iy1Short is used to bypass what appears to be a bug in
     *  the LaserJet Series II microcode.  It does not print a rule on
     *  the last scan line of a portrait page.  SO,  we stop scanning
     *  on the second last line,  and so will send any data here.  It
     *  will be transmitted as normal scan line data.
     *
     *  We also need to setup the left/right table for the last scan
     *  and invert it.
     */
    if (pRD->iLines == LJII_MAXHEIGHT)
    {
        iy1Short = pRData->iy - 1;          /* Bottom line not printed! */

        plr[iy1Short].left  = 1;            /* assume last row  blank  */
        plr[iy1Short].right = 0;

        if (!pbRasterScanBuf || pbRasterScanBuf[iy1Short / LINESPERBLOCK])
        {
            pdwIn = pdwBits + idwLine * iy1Short;
            pdwIn[cdwLine-1] |= ~dwMask;    // make unused bits white
            for (i = 0; i < cdwLine; ++i, pdwIn++)
            {
                *pdwIn = ~*pdwIn;
                if(*pdwIn  &&  plr[iy1Short].left)
                {
                    plr[iy1Short].left  = 0;            /*  last row not blank*/
                    plr[iy1Short].right = cdwLine - 1;
                }
            }
        }
    }
    else
        iy1Short = pRData->iy;

    //
    // This is the main loop for rules. It processes iLim scan lines per
    // pass looking for vertical rules of that height. Hozizontal rules
    // are created where no vertical rules have occurred.
    //
    //  NOTE:  iLim is initialised inside the loop!

    for( iLine = 0; iLine < iy1Short; iLine += iLim )
    {
        BOOL bAllWhite = TRUE;

        DWORD  *pdw;
        int left,right;     /* bounds for verticle rules */

        iLim = iy1Short - iLine;
        if( iLim >= 2 * pRD->iLines )
            iLim = pRD->iLines;         /* Limit to nominal band size */

        //
        //  Fill in the left/right structure with the values of the first
        //  nonwhite dword for each scan line.  The bits have still not
        //  been inverted at this point.  So 0's are black and 1's are
        //  white.
        //

        pdw   = pdwBits;
        left  = 0;
        right = cdwLine-1;

        for (iI = 0, plrCur = plr; iI < iLim; plrCur++, ++iI)
        {
            // if surface block erasing is enabled check for blank block
            //
            if (pbRasterScanBuf && !pbRasterScanBuf[(iLine+iI) / LINESPERBLOCK])
            {
                plrCur->left  = 1;            /* assume last row  blank  */
                plrCur->right = 0;
            }
            // this scan line was erased so need to check if still white
            //
            else
            {
                DWORD *pdwLast = &pdw[cdwLine-1];       // pointer to last dword
                DWORD dwOld    = *pdwLast | ~dwMask;    // make unused bits white

                // find the first non white DWORD in this scan line
                // we set the last DWORD to black so we don't have
                // to test for the end of line

                *pdwLast = 0;           // set last dword temporarily to black
                pdwIn = pdw;

                while (*pdwIn == (DWORD)-1)
                    ++pdwIn;

                *pdwLast = dwOld;       // restore original value

                /*
                *  find the last non white DWORD.  If the last dword is white,
                *  see if pdwIn reached the end of the scan.  If not, work
                *  backwards with pdwLast.
                */
                if (dwOld == (DWORD)-1)
                {
                    if (pdwIn < pdwLast)
                    {
                        do {
                            pdwLast--;
                        } while (*pdwLast == (DWORD)-1);
                    }
                    else
                        pdwLast--;
                }
                // update the per row and per segment left and right dword indexes

                plrCur->left  = (WORD)(pdwIn - pdw);
                plrCur->right = (WORD)(pdwLast - pdw);
            }
            // Adjust the overall left and right margin for blank space
            // If any dword is zero within this pass no vertical rules
            // can be found, so we want to avoid looking
            //
            if (plrCur->left > left)
                left = plrCur->left;

            if (plrCur->right < right)
                right = plrCur->right;

            // turn off bAllWhite if any black was found
            //

            bAllWhite &= (plrCur->left > plrCur->right);

            pdw += idwLine;
        }


        // non-white pass so lets look for rules
        //
        if (!bAllWhite)
        {
            // Initialize the accumulation array to all 1's (white)
            // to begin searching for vertical rules.

            RtlFillMemory(pRD->pdwAccum, cdwLine * DWBYTES,-1);

    #if DBG
        if (gbDoRules)
        {
    #endif
            cRuleLim = pRD->iMaxRules;           /* Rule limit for this stripe */

            // if any scan line in this pass was all white there won't
            // be any vertical rules to find.
            //
            if (left <= right)
            {
                int cdw;
                int iBit;
                int iWhite;

                // vertical rules are found by or'ing together all the
                // scan lines in this pass. Wherever a 0 bit still exists
                // designates a vertical black line the height of the pass
                // This is where we or the scan lines together

                /*   Set the accumulation array to the first scan  */

                pdw = pdwBits + left;
                cdw = right - left + 1;

                memcpy(pRD->pdwAccum + left , pdw, cdw * DWBYTES);

                /*
                 *   Scan across the bitmap - fewer page faults in mmu.
                 */

                for( iI = 1; iI < iLim; ++iI )
                {
                    pdw   += idwLine;
                    pdwIn  = pdw;
                    pdwOr  = pRD->pdwAccum + left;
                    //
                    // or 4 dwords at a time for speed
                    //
                    iIReg = cdw >> 2;

                    while(--iIReg >= 0)
                    {
                        pdwOr[0] |= pdwIn[0];
                        pdwOr[1] |= pdwIn[1];
                        pdwOr[2] |= pdwIn[2];
                        pdwOr[3] |= pdwIn[3];
                        pdwOr += 4;
                        pdwIn += 4;
                    }
                    //
                    // or remaining dwords
                    //
                    iIReg = cdw & 3;
                    while (--iIReg >= 0)
                        *pdwOr++ |= *pdwIn++;
                }

                /*
                 *   Can now determine what happened in this band.  First step is
                 *  to figure out which rules started in this band.  Any 0 bit
                 *  in the output array corresponds to a rule extending the whole
                 *  band.  If the corresponding bit in the pdwAccum array
                 *  is NOT set, then we record the rule as starting in the
                 *  first row of this stripe.
                 */

                iyEnd = iyPrtLine + (iLim - 1) * iILAdv;                /* Last line */

                iWhite = DWBITS;
                for( iI = left, iBit = 0; iI <= right;)
                {
                    DWORD dwTemp;
                    int ixEnd;

                    // we can skip any dword that is all 1's (white)
                    //
                    if((iBit == 0) && ((dwTemp = pRD->pdwAccum[ iI ]) == (DWORD)-1) )
                    {
                        iWhite += DWBITS;
                        ++iI;
                        continue;
                    }

                    /* find the first black bit */
                    iWhite -= iBit;
                    while (dwTemp & gdwBitOn[iBit])
                        ++iBit;

                    iWhite += iBit;

                    /* set the origin     */

                    ixOrg = iI * DWBITS + iBit;

                    // find the length by looking for first white bit
                    //
                    do
                    {
                        if (++iBit == DWBITS)
                        {
                            iBit = 0;

                            if (++iI > right)
                            {
                                dwTemp = (DWORD)-1;
                                break;
                            }

                            dwTemp = pRD->pdwAccum[ iI ];
                        }
                    } while (!(dwTemp & gdwBitOn[iBit]));
#ifndef OLDSTUFF
                    //
                    // Now that we have found a rule we need to determine
                    // whether it is worthwhile to actually use it. If the rule won't
                    // result in at least 4 white bytes and we just had another rule
                    // we will skip it. If we are in rapidly changing data with data runs
                    // of less than 4 bytes then this isn't of any benefit
                    //
                    ixEnd = iI * DWBITS + iBit;
                    if ((iWhite < 16) && (((ixEnd & ~7) - ixOrg) < 32))
                    {
                        int iCnt;
                        for (iCnt = ixOrg;iCnt < ixEnd;iCnt++)
                             pRD->pdwAccum[iCnt / DWBITS] |= gdwBitOn[iCnt & 31];
                    }
                    // save this rule if there is enough space
                    //
                    else if (cRuleLim)
                    {
                        cRuleLim--;
                        pRD->HRule[cRuleLim].wxOrg = (WORD)ixOrg;
                        pRD->HRule[cRuleLim].wxEnd = (WORD)ixEnd;
                    }
                    // too many rules so look for a smaller one
                    //
                    else
                    {
                        WORD wDx1,wDx2;
                        int iCnt,iIndex;
                        wDx1 = MAX_WORD;
                        iCnt = pRD->iMaxRules;
                        iIndex = 0;
                        while (iCnt)
                        {
                            iCnt--;
                            wDx2 = pRD->HRule[iCnt].wxEnd - pRD->HRule[iCnt].wxOrg;
                            if (wDx2 < wDx1)
                            {
                                wDx1 = wDx2;
                                iIndex = iCnt;
                            }
                        }
                        wDx2 = ixEnd - ixOrg;

                        // if this is a bigger rule, substitute
                        // for the smallest earlier rule
                        if (wDx2 > wDx1)
                        {
                            // clear original rule
                            for (iCnt = pRD->HRule[iIndex].wxOrg;iCnt < pRD->HRule[iIndex].wxEnd;iCnt++)
                                pRD->pdwAccum[iCnt / DWBITS] |= gdwBitOn[iCnt & 31];

                            // update to new values
                            pRD->HRule[iIndex].wxEnd = (WORD)ixEnd;
                            pRD->HRule[iIndex].wxOrg = (WORD)ixOrg;
                        }
                        // new rule is too small so flush it
                        //
                        else
                        {
                            for (iCnt = ixOrg;iCnt < ixEnd;iCnt++)
                                pRD->pdwAccum[iCnt / DWBITS] |= gdwBitOn[iCnt & 31];
                        }
                    }

                    /* check if there are any remaining black bits in this DWORD */

                    if (!(gdwBitMask[iBit] & ~dwTemp))
                    {
                        iWhite = DWBITS - iBit;
                        ++iI;
                        iBit = 0;
                    }
                    else
                        iWhite = 0;
                }
                //
                // OK, time to output the rules
                iI = pRD->iMaxRules;
                while ( iI > cRuleLim)
                {
                    iI--;
                    vSendRule( pPDev, pRD->HRule[iI].wxOrg,iyPrtLine,pRD->HRule[iI].wxEnd-1,iyEnd);
                    pRD->HRule[iI].wxOrg = pRD->HRule[iI].wxEnd = 0;
                }
#else
                #if _LH_DBG
                    if( !(_lh_flags & NO_SEND_VERT) )
                #endif

                    //
                    vSendRule( pPDev, ixOrg, iyPrtLine, iI * DWBITS + iBit - 1, iyEnd );

                    /* check if there are any remaining black bits in this DWORD */

                    if (!(gdwBitMask[iBit] & ~dwTemp))
                    {
                        ++iI;
                        iBit = 0;
                    }

                    // quit looking if we've created the maximum number of rules
                    if (--cRuleLim == 0)
                        break;
                }

                /*
                 *  if we ended due to too many rules, zap any remaining bits.
                 */

                if ((cRuleLim == 0) && (iI <= right))
                {
                    /* make accum bits white */

                    if (iBit > 0)
                    {
                        pRD->pdwAccum[iI] |= gdwBitMask[iBit];
                        ++iI;
                    }

                    RtlFillMemory((PVOID)&pRD->pdwAccum[iI],(right - iI + 1) * DWBYTES,-1);
                }
#endif
            }
#ifndef DISABLE_HRULES
            // first check whether to bother with HRULES
            // if we didn't allocate a buffer then that means
            // we don't want them to run
            if (pRD->pRTVert)
            {
               /*
                *    Horizontal rules.  We scan on DWORDs.  These are rather
                *  coarse,  but seem reasonable for a first pass operation.
                *
                *    Step 1 is to find any VERTICAL rules that will pass the
                *  horizontal test.  This allows us to filter vertical rules
                *  from the horizontal data - we don't want to send them twice!
                */
                ZeroMemory( pRD->pRTVert, cdwLine * sizeof( short ) );

                for( iI = left, pdwIn = pRD->pdwAccum + left; iI <= right; ++iI, ++pdwIn )
                {
                    if (*pdwIn != 0)
                        continue;

                    ixOrg = iI;

                    /* find a run of black */

                    do {
                        ++iI;
                        ++pdwIn;
                    } while ((iI <= right) && (*pdwIn == 0));

                    pRD->pRTVert[ixOrg] = (short)(iI - ixOrg);
                }


                /*
                 *   Start scanning this stripe for horizontal runs.
                 */

                if (pRD->iMaxRules >= (cRuleLim + HRULE_MIN_HCNT))
                    cRuleLim += HRULE_MIN_HCNT;

                cHRules = 0;    /* Number of horizontal rules found */
                ZeroMemory( pRD->pRTLast, cdwLine * sizeof( short ) );

                for (iI = 0; (iI < iLim) && (cHRules < cRuleLim); ++iI, iyPrtLine += iILAdv)
                {
                    int iDW;
                    int iFirst;
                    PVOID pv;

                    plrCur = plr + iI;

                    pdwIn = pdwBits + iI * idwLine;
                    iLast = -1;

                    ZeroMemory( pRD->pRTCur, cdwLine * sizeof( short ) );
                    ZeroMemory( pRD->ppRCur, cdwLine * sizeof( RULE *) );

                    for (iDW = plrCur->left; iDW < plrCur->right;++iDW)
                    {
                        /* is this the start of a verticle rule already? */

                        if (pRD->pRTVert[iDW])
                        {
                            /* skip over any verticle rules */

                            iDW += (pRD->pRTVert[iDW] - 1);
                            continue;
                        }

                        /* are there at least two consecutive DWORDS of black */

                        if ((pdwIn[iDW] != 0) || (pdwIn[iDW+1] != 0))
                        {
                            continue;
                        }

                        /* yes, see how many.  Already got two. */

                        ixOrg = iDW;
                        iDW += 2;

                        while ((iDW <= plrCur->right) && (pdwIn[iDW] == 0))
                        {
                            ++iDW;
                        }

                        /*
                         *  now remember the run, setting second short of the
                         *  previous run to the start of this and first short
                         *  of this run to its size.  Note for the first run
                         *  iLast will be -1, so the offset of the first run
                         *  will be a negative value in pRTCur[0].  If the first
                         *  run starts at offset 0, pRTCur[0] will be positive
                         *  and the offset is not needed.
                         */

                        iLen = iDW - ixOrg;

                        pRD->pRTCur[iLast + 1] = -(short)ixOrg;
                        pRD->pRTCur[ixOrg] = (short)iLen;

                        iLast = ixOrg;
                    }

                    /*
                     *  Process the segments found along this scanline.  Processing
                     *  means either adding to an existing rule,  or creating a
                     *  new rule, with possible termination of an existing one.
                     */

                    iFirst = -pRD->pRTCur[0];

                    if( iFirst != 0 )
                    {
                        /*
                         *  if the pRTCur[0] is positive, the first scan starts
                         *  at 0 and the first value is a length.  Note it
                         *  has already been negated so we check for negative.
                         */

                        if (iFirst < 0)
                            iFirst = 0;

                        /*
                         *   Found something,  so process it.  Note that the
                         * following loop should be executed at least once, since
                         * iFirst may be 0 the first time through the loop.
                         */

                        pdwIn = pdwBits + iI * idwLine; /* Line start address */

                        do
                        {
                            RULE *pRule;

                            if( pRD->pRTLast[ iFirst ] != pRD->pRTCur[ iFirst ] )
                            {
                                /*  A new rule - create an entry for it  */
                                if( cHRules < cRuleLim )
                                {
                                    pRule = &pRD->HRule[ cHRules ];
                                    ++cHRules;

                                    pRule->wxOrg = (WORD)iFirst;
                                    pRule->wxEnd = (WORD)(iFirst + pRD->pRTCur[ iFirst ]);
                                    pRule->wyOrg = (WORD)iyPrtLine;
                                    pRule->wyEnd = pRule->wyOrg;

                                    pRD->ppRCur[ iFirst ] = pRule;
                                }
                                else
                                {
                                    pRD->pRTCur[ iFirst ] = 0;   /* NO zapping */
                                }
                            }
                            else
                            {
                                /*   An extension of an earlier rule  */
                                pRule = pRD->ppRLast[ iFirst ];
                                if( pRule )
                                {
                                    /*
                                     *   Note that the above if() should not be
                                     * needed,  but there have been occasions when
                                     * this code has been executed with pRule = 0,
                                     * which causes all sorts of unpleasantness.
                                     */

                                    pRule->wyEnd = (WORD)iyPrtLine;
                                    pRD->ppRCur[ iFirst ] = pRule;
                                }
                            }

                            //  Zap the bits for this horizontal rule.
                            //
                                if( (ixOrg = pRD->pRTCur[ iFirst ]) > 0 )
                            {
                                pdwOr = pdwIn + iFirst; /* Start address of data */

                                while( --ixOrg >= 0 )
                                    *pdwOr++ = (DWORD)-1;              /* Zap them */
                            }

                        } while(iFirst = -pRD->pRTCur[ iFirst + 1 ]);
                    }

                    pv = pRD->pRTLast;
                    pRD->pRTLast = pRD->pRTCur;
                    pRD->pRTCur = pv;

                    pv = pRD->ppRLast;
                    pRD->ppRLast = pRD->ppRCur;
                    pRD->ppRCur = pv;

                } // for iI

                /*
                 *   Can now send the horizontal rules,  since we have all that
                 *  are of interest.
                 */

                for( iI = 0; iI < cHRules; ++iI )
                {
                    RULE   *pRule = &pRD->HRule[ iI ];

                    vSendRule( pPDev, DWBITS * pRule->wxOrg, pRule->wyOrg,
                                    DWBITS * pRule->wxEnd - 1, pRule->wyEnd );
                }
            }
#endif  // DISABLE_HRULES
    #if DBG // gbDoRules
        }
    #endif


            // At this point we need to remove the vertical rules that
            // have been sent a scan line at a time. This is done by ANDing
            // with the complement of the bit array pdwAccum.
            // It is also at this point that we do the data inversion where
            // 0 will be white instead of 1.

            pdwOr  = pRD->pdwAccum;
            pdwIn  = pdwBits;
            plrCur = plr;

            for (iI = 0;iI < iLim; iI++)
            {
                int iCnt = plrCur->right - plrCur->left + 1;
                if (iCnt > 0)
                {
                    DWORD *pdwTmp = &pdwIn[plrCur->left];
                    //
                    // if no vertical rules were created no point in doing the
                    // masking so we will use a faster algorithm
                    //
                    if (cRuleLim == pRD->iMaxRules)
                    {
                        while (iCnt & 3)
                        {
                            *pdwTmp++ ^= (DWORD)-1;
                            iCnt--;
                        }
                        iCnt >>= 2;
                        while (--iCnt >= 0)
                        {
                            pdwTmp[0] ^= (DWORD)-1;
                            pdwTmp[1] ^= (DWORD)-1;
                            pdwTmp[2] ^= (DWORD)-1;
                            pdwTmp[3] ^= (DWORD)-1;
                            pdwTmp += 4;
                        }
                    }
                    //
                    // vertical rules so we better mask with the rules array
                    //
                    else
                    {
                        DWORD *pdwTmpOr = &pdwOr[plrCur->left];
                        while (iCnt & 3)
                        {
                            *pdwTmp = ~*pdwTmp & *pdwTmpOr++;
                            pdwTmp++;
                            iCnt--;
                        }
                        iCnt >>= 2;
                        while (--iCnt >= 0)
                        {
                            pdwTmp[0] = ~pdwTmp[0] & pdwTmpOr[0];
                            pdwTmp[1] = ~pdwTmp[1] & pdwTmpOr[1];
                            pdwTmp[2] = ~pdwTmp[2] & pdwTmpOr[2];
                            pdwTmp[3] = ~pdwTmp[3] & pdwTmpOr[3];
                            pdwTmp += 4;
                            pdwTmpOr += 4;
                        }
                    }
                }
                //
                // if the MaxNumScans == 1 then we need to check for any additional
                // white space created because of the rules removal
                //
                if (pRData->iMaxNumScans == 1)
                {
                    while ((plrCur->left <= plrCur->right) && (pdwIn[plrCur->left] == 0))
                        ++plrCur->left;

                    while ((plrCur->left <= plrCur->right) && (pdwIn[plrCur->right] == 0))
                        --plrCur->right;
                }
                //
                // we need to zero out the white margins since they
                // haven't been inverted.
                //
                else
                {
                    ZeroMemory(pdwIn,plrCur->left * DWBYTES);
                    ZeroMemory(&pdwIn[plrCur->right+1],
                        (cdwLine-plrCur->right-1) * DWBYTES);
                }
                pdwIn += idwLine;
                ++plrCur;
            }
        } // bAllWhite
        // If  the entire scan is white and device supports multi scan line
        // invert the bits;because for multi scan line support, bits have to
        // be inverted.
        else if (pRData->iMaxNumScans > 1)
        {
            pdwIn = pdwBits;
            for( iI = 0; iI < iLim; ++iI )
            {
                ZeroMemory(pdwIn,cdwLine*DWBYTES);
                pdwIn += idwLine;
            }
        }

        /* advance to next stripe */

        pdwBits += iLim * idwLine;              /* Start address next stripe */

        iyPrtLine = pRD->iyPrtLine += iILAdv * iLim;

        plr += iLim;

#if _LH_DBG
        /*
         *   If desired,  rule a line across the end of the stripe.  This
         * can be helpful during debugging.
         */

        if( _lh_flags & RULE_STRIPE )
            vSendRule( pPDev, 0, iyPrtLine, 2399, iyPrtLine );
#endif
    }

    return(TRUE);
}

/*************************** Module Header ********************************
 * vRuleEndPage
 *      Called at the end of a page, and completes any outstanding rules.
 *
 * RETURNS:
 *      Nothing
 *
 * HISTORY:
 *  17:25 on Mon 20 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it,  specifically for landscape mode.
 *
 ***************************************************************************/

void
vRuleEndPage( pPDev )
PDEV   *pPDev;
{
    /*
     *   Scan for any remaining rules that reach to the end of the page.
     *  This means that any 1 bits remaining in pdwAccum array have
     *  made it,  so they should be sent.  Only vertical rules will be
     *  seen in here - horizontal rules are sent at the end of each stripe.
     */

    register  int  iIReg;       /* Loop parameter */

    int     ixOrg;              /* Start of last rule,  if >= 0 */
    WORD    iyOrg;              /* Ditto, but for y */
    int     iI;                 /* Loop index */
    int     cdwLine;            /* DWORDS per line */
    int     iyMax;              /* Number of scan lines */
    int     iCol;               /* Column number being processed */

    RULE_DATA  *pRD;


    /*
     *   NOTE:   To meet the PDK ship schedule,  the rules finding code
     *  has been simplified somewhat.  As a consequence of this,  this
     *  function no longer performs any useful function.  Hence, we
     *  simply return.  We could delete the function call from the
     *  rendering code,  but at this stage I prefer to leave the
     *  call in,  since it probably will be needed later.
     */

    //return;

//!!! NOTE: this code has not be modified to deal with the LEFT/RIGHT rules

#if _LH_DBG
    if( _lh_flags & NO_RULES )
        return;                 /* Nothing wanted here */
#endif

    if( !(pRD = ((PRASTERPDEV)pPDev->pRasterPDEV)->pRuleData) )
        return;                         /* No doing anything! */
   /* Local Free plrWhite*/
    if( pRD->pRData->plrWhite )
    {
        MemFree( pRD->pRData->plrWhite );
        pRD->pRData->plrWhite = NULL;
    }
    return;
}

/****************************** Function Header ****************************
 *  vSendRule
 *      Function to send a rule command to the printer.  We are given the
 *      four corner coordinates,  from which the command is derived.
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 *  Tuesday 30 November 1993    -by-    Norman Hendley   [normanh]
 *      minor check to allow CaPSL rules - black fill only -
 *  10:57 on Fri 17 May 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it.
 *
 ***************************************************************************/

static  void
vSendRule( pPDev, ixOrg, iyOrg, ixEnd, iyEnd )
PDEV   *pPDev;
int     ixOrg;          /* The X starting position */
int     iyOrg;          /* The Y starting location */
int     ixEnd;          /* The X end position */
int     iyEnd;          /* The Y end position */
{

    /*
     *   This code is VERY HP LaserJet specific.  Basic step is to set
     *  the cursor position to (ixOrg, iyOrg),  then set the rule length
     *  and width before issuing the rule command.
     */

    int        iTemp;           /* Temporary - for swapping operations */

    RASTERPDEV   *pRPDev;
    RULE_DATA *pRD;
    BOOL  bNoFillCommand;



#if _LH_DBG
    if( _lh_flags & NO_SEND_RULES )
    {
        if( _lh_flags & RULE_VERBOSE )
        {
            DbgPrint( "NOT SENDING RULE: (%ld, %ld) - (%ld, %ld)\n",
                                                ixOrg, iyOrg, ixEnd, iyEnd );

        }
        return;                 /* Nothing wanted here */
    }

    if( _lh_flags & RULE_VERBOSE )
    {
        DbgPrint( "SENDING RULE: (%ld, %ld) - (%ld, %ld)\n",
                                            ixOrg, iyOrg, ixEnd, iyEnd );
    }

#endif

    pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;           /* For convenience */
    pRD = pRPDev->pRuleData;


    /*
     *   Make sure the start position is < end position.  In landscape
     *  this may not happen.
     */
    if( ixOrg > ixEnd )
    {
        /*  Swap them */
        iTemp = ixOrg;
        ixOrg = ixEnd;
        ixEnd = iTemp;
    }
    if( iyOrg > iyEnd )
    {
        /*  Swap them */
        iTemp = iyOrg;
        iyOrg = iyEnd;
        iyEnd = iTemp;
    }

    if( pPDev->fMode & PF_ROTATE )
    {
        /*
         *    We are rotating the bitmap before sending,  so we should
         *  swap the X and Y coordinates now.  This is easier than reversing
         *  the function calls later, since we need to adjust nearly every
         *  call.
         */

        iTemp = ixOrg;
        ixOrg = iyOrg;
        iyOrg = iTemp;

        iTemp = ixEnd;
        ixEnd = iyEnd;
        iyEnd = iTemp;
    }


    /*
     *  Set the start position.
     */

    XMoveTo (pPDev, (ixOrg * pRD->ixScale) - pRD->ixOffset, 0 );
    YMoveTo( pPDev, iyOrg * pRD->iyScale, 0 );

    /*
     *     Set size of rule (rectangle area).
     * But, first convert from device units (300 dpi) to master units.
     */


    // Hack for CaPSL & other devices with different rule commands. Unidrv will always
    // send the co-ordinates for a rule. The Chicago CaPSL minidriver relies on this.
    // Check if a fill command exists, if not always send the co-ords. With CaPSL
    // these commands actually do the fill also , black (100% gray) only.

    bNoFillCommand = (!pRPDev->dwRectFillCommand) ?
        TRUE : FALSE;


    iTemp = (ixEnd - ixOrg + 1) * pRD->ixScale;
    if (iTemp != (int)pPDev->dwRectXSize || bNoFillCommand)
    {
        /*   A new width, so send the data and remember it for next time */
        pPDev->dwRectXSize = iTemp;
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETRECTWIDTH));
    }

    iTemp = (iyEnd - iyOrg + 1) * pRD->iyScale;
    if (iTemp != (int)pPDev->dwRectYSize || bNoFillCommand)
    {
        pPDev->dwRectYSize = iTemp;
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETRECTHEIGHT));
    }

    /*
     *   Black fill is the maximum grey fill.
     */
    if (!bNoFillCommand)
    {
        pPDev->dwGrayPercentage = pPDev->pGlobals->dwMaxGrayFill;
        WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo,pRPDev->dwRectFillCommand));
    }

    /*
     *    If the rule changes the end coordinates,  then adjust them now.
     */
    if( pPDev->pGlobals->cxafterfill == CXARF_AT_RECT_X_END )
    {
        XMoveTo(pPDev, ixEnd, MV_GRAPHICS | MV_UPDATE | MV_RELATIVE);
    }

    if( pPDev->pGlobals->cyafterfill == CYARF_AT_RECT_Y_END )
    {
        YMoveTo(pPDev, iyEnd, MV_GRAPHICS | MV_UPDATE | MV_RELATIVE);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\whiteskp.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    raster.c

Abstract:

    Functions to scan a bitmap for white regions.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created (mostly stolen from Lindsayh)

--*/


#include        "raster.h"
#include        "rmrender.h"

/*
 *    The following union allows machine independent conversion from
 *  DWORDS to BYTES.
 */

typedef  union
{
    DWORD   dw;                 /* Data as a DWORD  */
    BYTE    b[ DWBYTES ];       /* Data as bytes */
}  UBDW;


/*
 *   Following array is used to test the leftover bits from scanning.  The
 *  rational is that only some of the bits in the last word are part
 *  of the bitmap,  so only they must be tested.  It is initialised at
 *  DLL initialisation time.
 *      NOTE:  There are 33 entries in this array:  This is intentional!
 *  Depending upon circumstances,  either the 0 or 32nd entry will be
 *  used for a dword that is all ones.
 *
 **** THIS ARRAY IS NOW DYNAMICALLY ALLOCATED IN bSkipInit().  ************
 */


#define TABLE_SIZE      ((DWBITS + 1) * sizeof( DWORD ))

/*
 *   RGB_WHITE is the bit pattern found in a white entry for an RGB format
 *  4 bits per pel bitmap.  This is the only special case required when
 *  scanning the source bitmap for white.  In all other cases (monochrome
 *  and CMY),  white is represented by a 0 nibble.
 */

#define RGB_WHITE       0x77777777

/*
 *   Also want to know about the 8 bit per pel white index.
 */

#define BPP8_WHITE      0xffffffff

/*
 *  Define BPP values for clarify
 */
#define BPP1   1
#define BPP4   4
#define BPP8   8
#define BPP24  24


//*****************************************************
BOOL
bSkipInit(
    PDEV *pPDev
    )
/*++

Routine Description:

    The job here is to initialise the table that is used to mask off
    the unused bits in a scanline.  All scanlines are DWORD aligned,
    and we take advantage of that fact when looking for white space.
    However,  the last DWORD may not be completely used,  so we have
    a masking table used to check only those bits of interest.
    The table depends upon byte ordering within words,  and this is
    machine dependent,  so we generate the table.  This provides
    machine independence,  since the machine that is going to use
    the table generates it!    This function is called when the DLL
    is loaded,  so we are not called often.
    The union 'u' provides the mapping between BYTES and DWORDS,
    and so is the key to this function.  The union is initialised
    using the BYTE array,  but it stored in memory using the DWORD.


Arguments:

    pPDev           Pointer to PDEV structure

Return Value:

    TRUE for success and FALSE for failure

--*/
{

    register  int    iIndex;
    register  DWORD *pdw;

    UBDW  u;            /* The magic union */
    PRASTERPDEV pRPDev = pPDev->pRasterPDEV;

    u.dw = 0;

    if( !(pRPDev->pdwBitMask = (DWORD *)MemAlloc( TABLE_SIZE )) )
        return  FALSE;


    pdw = pRPDev->pdwBitMask;

    for( iIndex = 0; iIndex < DWBITS; ++iIndex )
    {
        *pdw++ = u.dw;

        /*   The left most bit in the scan line is the MSB of the byte */
        u.b[ iIndex / BBITS ] |= 1 << (BBITS - 1 - (iIndex & (BBITS - 1)));
    }

    /* ALL bits are involved in the last one */
    *pdw = (DWORD)~0;


    return   TRUE;
}

//*******************************************************
BOOL
bIsBandWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    int iWhiteIndex
)
/*++

Routine Description:

    Scan a band of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer. This routine also
    masks off the unused bits at the end of each scan line.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against, only
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwBits;
    register  DWORD  *pdwLim;

    int   iLines;               /* Number of scan lines to check */

    DWORD  dwMask;              /* Mask to zap the trailing bits */
    BOOL   bRet;

    //Always TRUE for Txtonly as we don't want to send any graphics.
    if(pRData->PrinterType == PT_TTY)
        return TRUE;


    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will usually be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRData->iTransHigh;

    bRet = TRUE;

    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        /* pDWLim is the DWORD past the data of interest - not used */
        pdwLim = pdwBits + pRData->cDWLine;

        /*  Clear out undefined bits at end of line  */
        *(pdwLim - 1) &= dwMask;


        /* Need to continue masking regardless */
        if (bRet)
        {
            while (*pdwBits == 0 && ++pdwBits < pdwLim);

            if( pdwBits < pdwLim )
                bRet = FALSE;
        }

        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine * pRData->iInterlace;

    }

    return  bRet;
}


//**********************************************************
BOOL
bIsLineWhite(
    register DWORD *pdwBits,
    register RENDER *pRData,
    int iWhiteIndex
)
/*++

Routine Description:

    Scan a horizontal row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    scan line should be sent to the printer. This routine also
    masks off the unused bits at the end of each scan line.

Arguments:

    pdwBits         Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against, only
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwLim;


    DWORD  dwMask;              /* Mask to zap the trailing bits */

    //Always TRUE for Txtonly as we don't want to send any graphics.
    if(pRData->PrinterType == PT_TTY)
        return TRUE;

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */


    /* pDWLim is the DWORD past the data of interest - not used */
    pdwLim = pdwBits + pRData->cDWLine;

    /*  Clear out undefined bits at end of line  */
    *(pdwLim - 1) &= dwMask;

    while (*pdwBits == 0 && ++pdwBits < pdwLim);

    if( pdwBits < pdwLim )
        return   FALSE;

    return  TRUE;
}
//**********************************************************
BOOL
bIsNegatedLineWhite(
    DWORD *pdwBits,
    RENDER *pRData,
    int iWhiteIndex
)
/*++

Routine Description:

    Scan a horizontal row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    scan line should be sent to the printer. This routine also
    masks off the unused bits at the end of each scan line.

Arguments:

    pdwBits         Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against, only
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    DWORD  *pdwLim;
    int     iCnt;


    DWORD  dwMask;              /* Mask to zap the trailing bits */

    //Always TRUE for Txtonly as we don't want to send any graphics.
    if(pRData->PrinterType == PT_TTY)
        return TRUE;

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    /*  Clear out undefined bits at end of line  */
    pdwBits[pRData->cDWLine-1] |= ~dwMask;

    //
    // For performance we test 4 dwords at a time for white
    //
    pdwLim = pdwBits;
    iCnt = pRData->cDWLine >> 2;
    while (--iCnt >= 0)
    {
        if ((pdwBits[0] & pdwBits[1] & pdwBits[2] & pdwBits[3]) != -1)
            goto InvertTheBits;
        pdwBits += 4;
    }
    //
    // test any left over dwords for white
    //
    iCnt = pRData->cDWLine & 3;
    while (--iCnt >= 0)
    {
        if (*pdwBits != -1)
            goto InvertTheBits;
        pdwBits++;
    }
    return  TRUE;
    //
    // if this isn't a white line we need to invert the bits
    //
InvertTheBits:
    dwMask = (DWORD)(pdwBits - pdwLim);
    ZeroMemory (pdwLim,dwMask*DWBYTES);
    vInvertBits(pdwBits,pRData->cDWLine-dwMask);
    return FALSE;
}

//***************************************************
BOOL
bIsRGBBandWhite (
    DWORD   *pdwBitsIn,
    RENDER  *pRData,
    int     iWhiteIndex
    )
/*++

Routine Description:

    Scan a band of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwBits;
    register  DWORD  *pdwLim;

    int   iLines;               /* Number of scan lines to check */

    DWORD  dwMask;              /* Mask to zap the trailing bits */

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRData->iTransHigh;

    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        /* pDWLim is the DWORD past the data of interest - not used */
        pdwLim = pdwBits + pRData->cDWLine;

        /*  Clear out undefined bits at end of line  */
        *(pdwLim - 1) &= dwMask;
        *(pdwLim - 1) |= ~dwMask & RGB_WHITE;


        /*
         *   NOTE:   This test is more complex than needed because the
         *  engine ignores palette entries when doing BLTs.  The WHITENESS
         *  rop sets all bits to 1.  Hence,  we choose to ignore the
         *  MSB in the comparison:  this means we detect white space
         *  with an illegal palette entry.  This makes GDI people happy,
         *  but not me.
         */
        do {
            if ((*pdwBits & RGB_WHITE) != RGB_WHITE)
                return FALSE;
        } while (++pdwBits < pdwLim);

        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine * pRData->iInterlace;

    }
    return  TRUE;
}

//*******************************************************
BOOL
bIsRGBLineWhite (
    register  DWORD *pdwBits,
    RENDER          *pRData,
    int             iWhiteIndex
    )
/*++

Routine Description:

    Scan a single row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    DWORD  dwCnt;

    DWORD  dwMask;              /* Mask to zap the trailing bits */

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    /*  Clear out undefined bits at end of line  */
    dwCnt = pRData->cDWLine;
    pdwBits[dwCnt-1] &= dwMask;
    pdwBits[dwCnt-1] |= ~dwMask & RGB_WHITE;

    // test four dwords at a time
    //
    while (dwCnt >= 4)
    {
        if ((*pdwBits & pdwBits[1] & pdwBits[2] & pdwBits[3] & RGB_WHITE) != RGB_WHITE)
            return FALSE;
        pdwBits += 4;
        dwCnt -= 4;
    }
    while (dwCnt--)
    {
        if ((*pdwBits & RGB_WHITE) != RGB_WHITE)
            return FALSE;
        pdwBits++;
    }

    return  TRUE;
}

//**********************************************************
BOOL
bIs8BPPBandWhite (
    DWORD   *pdwBitsIn,
    RENDER  *pRData,
    int     iWhiteIndex
    )
/*++

Routine Description:

    Scan a band of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwBits;
    register  DWORD  *pdwLim;

    int   iLines;               /* Number of scan lines to check */

    DWORD  dwMask;              /* Mask to zap the trailing bits */
    DWORD  dwWhiteIndex;

    dwWhiteIndex = (DWORD)iWhiteIndex;

    /*
     *  As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRData->iTransHigh;

    /*
     * Need to set up the white index to be a dword multiple.
     * iwhiteIndex looks like 0x000000ff but the comparison
     * is done on dword boundaries so a stream of white looks
     * like 0xffffffff.
     */
    dwWhiteIndex |= dwWhiteIndex << 8;
    dwWhiteIndex |= dwWhiteIndex << 16;

    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        /* pDWLim is the DWORD past the data of interest - not used */
        pdwLim = pdwBits + pRData->cDWLine;

        /*  Clear out undefined bits at end of line  */
        *(pdwLim - 1) &= dwMask;
        *(pdwLim - 1) |= ~dwMask & dwWhiteIndex;

        while(*pdwBits ==  dwWhiteIndex && ++pdwBits < pdwLim);

        if( pdwBits < pdwLim )
            return  FALSE;

        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine * pRData->iInterlace;

    }

    return  TRUE;
}

//**********************************************************
BOOL
bIs8BPPLineWhite (
    DWORD   *pdwBits,
    RENDER  *pRData,
    int     iWhiteIndex
    )
/*++

Routine Description:

    Scan a single row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBits         Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwLim;


    DWORD  dwMask;              /* Mask to zap the trailing bits */
    DWORD  dwWhiteIndex;

    dwWhiteIndex = (DWORD)iWhiteIndex;


    /*
     * Need to set up the white index to be a dword multiple.
     * iwhiteIndex looks like 0x000000ff but the comparison
     * is done on dword boundaries so a stream of white looks
     * like 0xffffffff.
     */

    dwWhiteIndex |= dwWhiteIndex << 8;
    dwWhiteIndex |= dwWhiteIndex << 16;
    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */


    /* pDWLim is the DWORD past the data of interest - not used */
    pdwLim = pdwBits + pRData->cDWLine;

    /*  Clear out undefined bits at end of line  */
    *(pdwLim - 1) &= dwMask;
    *(pdwLim - 1) |= ~dwMask & dwWhiteIndex;

    while(*pdwBits ==  dwWhiteIndex && ++pdwBits < pdwLim);

    if( pdwBits < pdwLim )
        return   FALSE;


    return  TRUE;
}

//**********************************************************
BOOL
bIs24BPPBandWhite (
    DWORD   *pdwBitsIn,
    RENDER  *pRData,
    int     iWhiteIndex
    )
/*++

Routine Description:

    Scan a band of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{

    register  DWORD  *pdwBits;
    register  DWORD  *pdwLim;

    int   iLines;               /* Number of scan lines to check */

    DWORD  dwMask;              /* Mask to zap the trailing bits */
    DWORD  dwWhiteIndex;

    dwWhiteIndex = (DWORD)iWhiteIndex;
    dwWhiteIndex |= dwWhiteIndex << 8;

    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some trailing
     *  bits;  these are handled individually - if we get that far.
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));
    if( dwMask == 0 )
        dwMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRData->iTransHigh;


    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        /* pDWLim is the DWORD past the data of interest - not used */
        pdwLim = pdwBits + pRData->cDWLine;

        /*  Clear out undefined bits at end of line  */
        *(pdwLim - 1) &= dwMask;
        *(pdwLim - 1) |= ~dwMask & BPP8_WHITE;


        /*
         *   NOTE:   This test is more complex than needed because the
         *  engine ignores palette entries when doing BLTs.  The WHITENESS
         *  rop sets all bits to 1.  Hence,  we choose to ignore the
         *  MSB in the comparison:  this means we detect white space
         *  with an illegal palette entry.  This makes GDI people happy,
         *  but not me.
         */
        while(*pdwBits ==  dwWhiteIndex && ++pdwBits < pdwLim);

        if( pdwBits < pdwLim )
            return  FALSE;

        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine * pRData->iInterlace;

    }


    return  TRUE;
}

//*******************************************************
BOOL
bIs24BPPLineWhite (
    register  DWORD *pdwBits,
    RENDER          *pRData,
    int             iWhiteIndex
    )
/*++

Routine Description:

    Scan a single row of the bitmap, and return TRUE if it is
    all WHITE,  else FALSE.  This is used to decide whether a
    band should be sent to the printer.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against
                    included here for functional compatibility

Return Value:

    TRUE if entire bitmap is white, else FALSE

--*/
{
    DWORD  dwMask;              /* Mask to zap the trailing bits */
    LONG   iLimit = pRData->cDWLine;

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwMask = *(pRData->pdwBitMask + (pRData->cBLine % DWBITS));

    if( dwMask != 0 )
    {
        /*  Clear out undefined bits at end of line  */
        pdwBits[iLimit-1] &= dwMask;
        pdwBits[iLimit-1] |= ~dwMask & BPP8_WHITE;
    }

    /*
     *  As a speed optimisation, scan the bits in 4 DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required. First we will test the odd dwords.
     */

    while (iLimit & 3)
    {
        iLimit--;
        if (*pdwBits++ != ~0)
            return FALSE;
    }
    iLimit >>= 2;
    while (--iLimit >= 0)
    {
        pdwBits += 4;
        if ((pdwBits[-4] & pdwBits[-3] & pdwBits[-2] & pdwBits[-1]) != BPP8_WHITE)
            return FALSE;
    }
    return  TRUE;
}


//*******************************************************
BOOL
bIs1BPPRegionWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    RECTL *pRect
)
/*++

Routine Description:

    This function scans a specific region of the bitmap and returns
    TRUE if it is all white, else FALSE.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    pRect           Pointer to RECT structure describing the
                    region of the bitmap to test for white

Return Value:

    TRUE if region is all white else false

--*/
{

    DWORD  *pdwBits;

    int   iLines;               /* Number of scan lines to check */
    int     iWords;             // number of words to check per line

    DWORD  dwEndMask;              /* Mask to zap the trailing bits */
    DWORD  dwBegMask;           // mask to zap leading bits


    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some leading and
     *  trailing bits which are handled individually
     */

    /*   Mask to clear last few bits of scanline,  if not full DWORD */
    dwEndMask = *(pRData->pdwBitMask + (pRect->right % DWBITS));
    dwBegMask = ~(*(pRData->pdwBitMask + (pRect->left % DWBITS)));
    if( dwEndMask == 0 )
        dwEndMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRect->bottom - pRect->top;

    // calculate offset in buffer for top and left offsets
    pdwBitsIn += (pRData->cDWLine * pRect->top) + (pRect->left / DWBITS);

    // calculate number of words to test
    iWords = ((pRect->right + DWBITS - 1) / DWBITS) - (pRect->left / DWBITS);

    // if only 1 dword combine begin and end masks
    if (iWords == 0)
    {
        dwBegMask &= dwEndMask;
    }
    iWords--;
    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        //*  test beginning dword
        if (~(*pdwBits) & dwBegMask)
            return FALSE;

        pdwBits++;

        //* test remaining dwords if necessary
        if (iWords >= 0) {
            if (iWords > 0)
            {
                int iCnt = iWords;
                if (iCnt & 1)
                {
                    if (pdwBits[0] != ~0)
                        return FALSE;
                    pdwBits++;
                }
                if (iCnt & 2)
                {
                    if ((pdwBits[0] & pdwBits[1]) != ~0)
                        return FALSE;
                    pdwBits += 2;
                }
                while ((iCnt -= 4) >= 0)
                {
                    if ((pdwBits[0] & pdwBits[1] & pdwBits[2] & pdwBits[3]) != ~0)
                        return FALSE;
                    pdwBits += 4;
                }
            }
            //* test last dword
            if (~(*pdwBits) & dwEndMask)
                return FALSE;
        }
        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine;
    }
    return TRUE;
}

//**************************************************
BOOL
bIs4BPPRegionWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    RECTL *pRect
)
/*++

Routine Description:

    This function scans a specific region of the bitmap and returns
    TRUE if it is all white, else FALSE.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    pRect           Pointer to RECT structure describing the
                    region of the bitmap to test for white

Return Value:

    TRUE if region is all white else false

--*/
{

    DWORD  *pdwBits;

    int   iLines;               /* Number of scan lines to check */
    int     iWords;             // number of words to check per line
    int    iRight;
    int    iLeft;

    DWORD  dwEndMask;              /* Mask to zap the trailing bits */
    DWORD  dwBegMask;           // mask to zap leading bits


    /*
     *   As a speed optimisation,  scan the bits in DWORD size clumps.
     *  This substantially reduces the number of iterations and memory
     *  references required.  There will ususally be some leading and
     *  trailing bits which are handled individually
     */

    //* Adjust horizontal positions by BPP
    iRight = pRect->right * BPP4;
    iLeft = pRect->left * BPP4;

    //*  Mask to clear first and last bits of scanline,  if not full DWORD
    //*
    dwEndMask = *(pRData->pdwBitMask + (iRight % DWBITS));
    dwBegMask = ~(*(pRData->pdwBitMask + (iLeft % DWBITS)));
    if( dwEndMask == 0 )
        dwEndMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRect->bottom - pRect->top;

    // calculate offset in buffer for top and left offsets
    pdwBitsIn += (pRData->cDWLine * pRect->top) + (iLeft / DWBITS);

    // calculate number of words to test
    iWords = ((iRight + DWBITS - 1) / DWBITS) - (iLeft / DWBITS);

    // if only 1 dword combine begin and end masks
    if (iWords == 0)
        dwBegMask &= dwEndMask;

    //*  MSB of each pixel is ignored so combine with pixel mask
    //*  see bIsRGBLineWhite for why MSB is ignored
    dwEndMask &= RGB_WHITE;
    dwBegMask &= RGB_WHITE;

    iWords--;
    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        //*  test beginning dword
        if ((*pdwBits & dwBegMask) != dwBegMask)
            return FALSE;

        pdwBits++;

        //* test remaining dwords if necessary
        if (iWords >= 0) {
            if (iWords > 0)
            {
                DWORD dwTmp = RGB_WHITE;
                int iCnt = iWords;
                while (iCnt & 3)
                {
                    dwTmp &= *pdwBits++;
                    iCnt--;
                }
                iCnt >>= 2;
                while (--iCnt >= 0)
                {
                    dwTmp &= pdwBits[0];
                    dwTmp &= pdwBits[1];
                    dwTmp &= pdwBits[2];
                    dwTmp &= pdwBits[3];
                    pdwBits += 4;
                }
                if (dwTmp != RGB_WHITE)
                    return FALSE;
            }
            //* test last dword
            if ((*pdwBits & dwEndMask) != dwEndMask)
                return FALSE;
        }
        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine;
    }
    return TRUE;
}

//**************************************************
BOOL
bIs8BPPRegionWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    RECTL *pRect,
    int iWhiteIndex
    )
/*++

Routine Description:

    This function scans a specific region of the bitmap and returns
    TRUE if it is all white, else FALSE.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    pRect           Pointer to RECT structure describing the
                    region of the bitmap to test for white

Return Value:

    TRUE if region is all white else false

--*/
{

    DWORD  *pdwBits;

    int   iLines;               /* Number of scan lines to check */
    int     iWords;             // number of words to check per line
    int iRight;
    int iLeft;

    DWORD  dwEndMask;              /* Mask to zap the trailing bits */
    DWORD  dwBegMask;           // mask to zap leading bits

    DWORD  dwWhiteIndex;

    //* calculate WhiteIndex for 4 bytes at a time
    dwWhiteIndex = (DWORD)iWhiteIndex;
    dwWhiteIndex |= dwWhiteIndex << 8;
    dwWhiteIndex |= dwWhiteIndex << 16;

    //* Adjust horizontal positions by BPP
    iRight = pRect->right * BPP8;
    iLeft = pRect->left * BPP8;

    //*  Mask to clear first and last bits of scanline,  if not full DWORD
    //*
    dwEndMask = *(pRData->pdwBitMask + (iRight % DWBITS));
    dwBegMask = ~(*(pRData->pdwBitMask + (iLeft % DWBITS)));
    if( dwEndMask == 0 )
        dwEndMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRect->bottom - pRect->top;

    // calculate offset in buffer for top and left offsets
    pdwBitsIn += (pRData->cDWLine * pRect->top) + (iLeft / DWBITS);

    // calculate number of words to test
    iWords = ((iRight + DWBITS - 1) / DWBITS) - (iLeft / DWBITS);

    // if only 1 dword combine begin and end masks
    if (iWords == 0)
        dwBegMask &= dwEndMask;
    iWords--;
    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        //*  test beginning dword
        if ((*pdwBits & dwBegMask) != (dwWhiteIndex & dwBegMask))
            return FALSE;

        pdwBits++;

        //* test remaining dwords if necessary
        if (iWords >= 0) {
            if (iWords > 0)
            {
                int iCnt = iWords;
                do {
                    if (*pdwBits != dwWhiteIndex)
                        return FALSE;
                    pdwBits++;
                } while (--iCnt);
            }
            //* test last dword
            if ((*pdwBits & dwEndMask) != (dwWhiteIndex & dwEndMask))
                return FALSE;
        }
        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine;
    }
    return TRUE;
}

//****************************************************
BOOL
bIs24BPPRegionWhite(
    DWORD *pdwBitsIn,
    RENDER *pRData,
    RECTL *pRect
    )
/*++

Routine Description:

    This function scans a specific region of the bitmap and returns
    TRUE if it is all white, else FALSE.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    pRect           Pointer to RECT structure describing the
                    region of the bitmap to test for white

Return Value:

    TRUE if region is all white else false

--*/
{

    DWORD  *pdwBits;

    int   iLines;               // Number of scan lines to check */
    int     iWords;             // number of words to check per line
    int iRight;
    int iLeft;

    DWORD  dwEndMask;           // Mask to zap the trailing bits */
    DWORD  dwBegMask;           // mask to zap leading bits

    //* Adjust horizontal positions by BPP
    iRight = pRect->right * BPP24;
    iLeft = pRect->left * BPP24;

    //*  Mask to clear first and last bits of scanline,  if not full DWORD
    //*
    dwEndMask = *(pRData->pdwBitMask + (iRight % DWBITS));
    dwBegMask = ~(*(pRData->pdwBitMask + (iLeft % DWBITS)));
    if( dwEndMask == 0 )
        dwEndMask = (DWORD)~0;            /* Size is DWORD multiple */

    iLines = pRect->bottom - pRect->top;

    // calculate offset in buffer for top and left offsets
    pdwBitsIn += (pRData->cDWLine * pRect->top) + (iLeft / DWBITS);

    // calculate number of words to test
    iWords = ((iRight + DWBITS - 1) / DWBITS) - (iLeft / DWBITS);

    // if only 1 dword combine begin and end masks
    if (iWords == 0)
        dwBegMask &= dwEndMask;

    iWords--;
    while( --iLines >= 0 )
    {

        /*   Calculate the starting address for this scan */
        pdwBits = pdwBitsIn;

        //*  test beginning dword
        if ((*pdwBits & dwBegMask) != dwBegMask)
            return FALSE;

        pdwBits++;

        //* test remaining dwords if necessary
        if (iWords >= 0) {
            if (iWords > 0)
            {
                int iCnt = iWords;
                while (iCnt & 3)
                {
                    if (*pdwBits != ~0)
                        return FALSE;
                    pdwBits++;
                    iCnt--;
                }
                iCnt >>= 2;
                while (--iCnt >= 0)
                {
                    if ((pdwBits[0] & pdwBits[1] & pdwBits[2] & pdwBits[3]) != ~0)
                        return FALSE;
                    pdwBits += 4;
                }
            }
            //* test last dword
            if ((*pdwBits & dwEndMask) != dwEndMask)
                return FALSE;
        }
        /*   Onto the next scan line */
        pdwBitsIn += pRData->cDWLine;
    }
    return TRUE;
}

//*********************************************************
BOOL
bIsRegionWhite(
    SURFOBJ    *pso,
    RECTL   *pRect
    )

/*++

Routine Description:

    This routine determines whether a given region of the
    shadow bitmap is white.

Arguments:

    pPDev - Pointer to PDEV.
    pRect - Pointer to clip window within shadow bitmap

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    01-07-97: Created by alvins
--*/

{
    PDEV *pPDev = (PDEV *)pso->dhpdev;
    PRASTERPDEV pRPDev = (PRASTERPDEV)pPDev->pRasterPDEV;
    RENDER *pRD;
    RECTL Rectl;
    int y1,y2;

    // If the render structure hasn't been initialize how can
    // there have been data drawn in it. Also check the dirty flag
    if (!(pPDev->fMode & PF_SURFACE_USED) || pRPDev == NULL)
        return TRUE;

    pRD = pRPDev->pvRenderData;
    if (pRD == NULL)
        return TRUE;

    // lets make sure these values are positive
    // and there's still something to test
    //
    Rectl.left = pRect->left > 0 ? pRect->left : 0;
    Rectl.top = pRect->top > 0 ? pRect->top : 0;
    Rectl.right = pRect->right > 0 ? pRect->right : 0;
    Rectl.bottom = pRect->bottom > 0 ? pRect->bottom : 0;

    if (Rectl.left == Rectl.right || Rectl.top == Rectl.bottom)
        return TRUE;

    // if not surface then also assume all white
    if (pso->iType != STYPE_BITMAP)
        return TRUE;

    // need to actually check data at this point
    y1 = Rectl.top / LINESPERBLOCK;
    y2 = (Rectl.bottom-1) / LINESPERBLOCK;
    while (y1 <= y2)
    {
        RECTL tRectl = Rectl;

        if (pPDev->pbRasterScanBuf == NULL || pPDev->pbRasterScanBuf[y1])
        {
            // test a block at a time if we've block erased the surface
            //
            if (pPDev->pbRasterScanBuf)
            {
                if ((y1*LINESPERBLOCK) > tRectl.top)
                    tRectl.top = y1 * LINESPERBLOCK;
                y1++;
                if ((y1*LINESPERBLOCK) < tRectl.bottom)
                    tRectl.bottom = y1 * LINESPERBLOCK;
            }
            // surface is not block erased so make this last loop
            //
            else
                y1 = y2+1;

            switch (pRD->iBPP)
            {
            case 1:
                if (!bIs1BPPRegionWhite(pso->pvBits,pRD,&tRectl))
                    return FALSE;
                break;
            case 4:
                if (!bIs4BPPRegionWhite(pso->pvBits,pRD,&tRectl))
                    return FALSE;
                break;
            case 8:
                if (!bIs8BPPRegionWhite(pso->pvBits,pRD,&tRectl,pRPDev->pPalData->iWhiteIndex))
                    return FALSE;
                break;
            case 24:
                if (!bIs24BPPRegionWhite(pso->pvBits,pRD,&tRectl))
                    return FALSE;
                break;
            // if I don't recognize the format, I'll assume its empty
            default:
                return TRUE;
            }
        }
        else
            y1++;
    }
    return TRUE;
}

//*******************************************************
BOOL
bIsNeverWhite (
    register  DWORD *pdwBits,
    RENDER          *pRData,
    int             iWhiteIndex
    )
/*++

Routine Description:

    This function always returns FALSE and exists only to provide
    a common function call format for all the IsWhite Line/Band
    functions.

Arguments:

    pdwBitsIn       Pointer to area to scan for white
    pRData          Pointer to RENDER structure
    iWhiteIndex     White value to compare against

Return Value:

    FALSE

--*/
{

    return   FALSE;
}

//******************************************************
int
iStripBlanks(
    BYTE *pbOut,
    BYTE *pbIn,
    int  iLeft,
    int  iRight,
    int  iHeight,
    int  iWidth
    )
/*++

Routine Description:

    This function strips already identified white space
    from the buffer.

Arguments:

    pbOut       Pointer to output buffer
    pbIn        Pointer source buffer
    iLeft       First non-white leading byte
    iRight      First white trailing byte
    iHeight     Number of scanlines
    iWidth      Width of source scanlines

Return Value:

    Number of bytes in new buffer

--*/
{
    int i,j;
    BYTE * pbSrc;
    BYTE * pbTgt;
    int iDelta;

    iDelta = iRight - iLeft;
    pbTgt = pbOut;
    pbSrc = pbIn+iLeft;
    for (i = 0; i < iHeight; i++)
    {
        CopyMemory(pbTgt,pbSrc,iDelta);
        pbTgt += iDelta;
        pbSrc += iWidth;
    }
    return (iDelta * iHeight);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\control\vectorc.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    vectorc.c

Abstract:

    Implementation of the interface between Control module and Vector module

Environment:

    Windows 2000/Whistler Unidrv driver

Revision History:

    2/29/2000 -hsingh-
        Created

--*/


#include "vectorc.h"

//
// This functions is defined in control\data.c
//
extern PWSTR
PGetROnlyDisplayName(
    PDEV    *pPDev,
    PTRREF      loOffset,
    PWSTR       wstrBuf,
    WORD    wsize
    )  ;



/*++
Routine Name:
    VMInit

Routine Description:

    This function is called by the unidrv control module to initialize the vector 
    jump table. This function reads the personility from the gpd and depending 
    on whether the personality is pclxl/hpgl2, it calls the appropriate
    InitVectorProcTable() and initializes pPDev->pVectorProcs to the return value.
    If there is no *Personality or *rcPersonalityID keyword in 
    gpd, or if the Personality is nether of pclxl/hpgl2, 
    pPDev->pVectorProcs is set to NULL. 
    pPDev->ePersonality is also updated appropriately.

Arguments:

    pPDev           Pointer to PDEV structure
    pDevInfo        Pointer to DEVINFO structure
    pGDIInfo        Pointer to GDIINFO structure

Return Value:

    TRUE for success and FALSE for failure
    Even if there is no personality specified in the gpd, we still return TRUE i.e.
    it is ok for pPDev->pVectorProcs to be initialized to NULL.

--*/

BOOL
VMInit (
    PDEV    *pPDev,
    DEVINFO *pDevInfo,
    GDIINFO *pGDIInfo
    )
{
    BOOL bRet = FALSE;
    PWSTR pPersonalityName = NULL;
    WCHAR   wchBuf[MAX_DISPLAY_NAME];

    // Validate Input Parameters and ASSERT.
    ASSERT(pPDev);
    ASSERT(pPDev->pUIInfo);
    ASSERT(pDevInfo);
    ASSERT(pGDIInfo);

    //
    // Initialize to default values.
    //
    pPDev->pVectorProcs = NULL; // It should be NULL anyway, but just making sure.
    pPDev->ePersonality = kNoPersonality;

    //
    // Get the personality Name. This should have been defined as
    // *Personality or *rcPersonalityID in the gpd. 
    // Use the generic function PGetROnlyDisplayName 
    // defined in control\data.c
    //
    if ( !(pPersonalityName = PGetROnlyDisplayName(pPDev, pPDev->pUIInfo->loPersonality,
                                                  wchBuf, MAX_DISPLAY_NAME )) ) 

    {
        //
        // If pPersonalityName == NULL, do not initialize vector table.
        //
        return TRUE;
    }

    //
    // Initialize the jump table depending on the personality specified in the gpd.
    //
    if ( !wcscmp(pPersonalityName, _T("HPGL2" )) ) // WARNING: This is not localizable.... what to do??
    {
        pPDev->pVectorProcs = HPGLInitVectorProcTable(pPDev, pDevInfo, pGDIInfo);
        if (pPDev->pVectorProcs)
        {
            pPDev->ePersonality = kHPGL2;
        }
    }
    else if ( !wcscmp(pPersonalityName, _T("PCLXL" )) )
    {
        pPDev->pVectorProcs  = PCLXLInitVectorProcTable(pPDev, pDevInfo, pGDIInfo);
        if (pPDev->pVectorProcs)
        {
            pPDev->ePersonality = kPCLXL;
        }
        else
        {
            pPDev->ePersonality = kPCLXL_RASTER;
        }

    }

    //
    // else if the personality specified is not one of hpgl2 or pclxl,
    // just return TRUE. 
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\comnfile.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
//
//    commonfiles.h
//
// Abstract:
//
//
// Environment:
//
//    Windows NT 5.0 Unidrv driver
//
/////////////////////////////////////////////////////////////////////////////
#ifndef COMMONFILES_H
#define COMMONFILES_H

//
// To build an NT 4.0 render module:
//     define KERNEL_MODE and undefine USERMODE_DRIVER
// To build an NT 5.0 render module:
//     define KERNEL_MODE and define USERMODE_DRIVER
// To build an NT 4.0 and NT 5.0 UI module:
//     undefine KERNEL_MODE and undefine USERMODE_DRIVER
//

////// #include <tchar.h>

//
// windows include files
//
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#ifdef OEMCOM
#include <objbase.h>
#endif
#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <winddi.h>
#ifdef __cplusplus
}
#endif
#include <excpt.h>

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

#include "winsplkm.h"

#elif !defined(KERNEL_MODE)// !KERNEL_MODE

#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <compstui.h>
#include <winddiui.h>

#endif // defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

#include <printoem.h>

#include "gldebug.h"

//
// Directory seperator character
//
#define PATH_SEPARATOR  '\\'

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

//#define WritePrinter        EngWritePrinter
//#define GetPrinterDriver    EngGetPrinterDriver
//#define GetPrinterData      EngGetPrinterData
//#define SetPrinterData      EngSetPrinterData
//#define EnumForms           EngEnumForms
//#define GetPrinter          EngGetPrinter
//#define GetForm             EngGetForm
//#define SetLastError        EngSetLastError
//#define GetLastError        EngGetLastError
//#define MulDiv              EngMulDiv

//#undef  LoadLibrary
//#define LoadLibrary         EngLoadImage
//#define FreeLibrary         EngUnloadImage
//#define GetProcAddress      EngFindImageProcAddress

#define MemAlloc(size)      EngAllocMem(0, size, gdwDrvMemPoolTag)
#define MemAllocZ(size)     EngAllocMem(FL_ZERO_MEMORY, size, gdwDrvMemPoolTag)
#define MemFree(p)          { if (p) EngFreeMem(p); }

#else // !KERNEL_MODE

#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }

//
// DLL instance handle - You must initialize this variable when the driver DLL
// is attached to a process.
//

// BUGBUG -sandram do we need this var?
//extern HINSTANCE    ghInstance;

#endif // !KERNEL_MODE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\glcommon.cpp ===
///////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
//Module Name:
//
//	glcommon.cpp
//
//Abstract:
//
//	This file contains function implementations common to both
//	user and kernel mode DLLs.
//
//Environment:
//
//	Windows 2000/Whistler 
//
///////////////////////////////////////////////////////////// 

#include "hpgl2col.h" //Precompiled header file

//
// If this is an NT 5.0 user-mode render module then include
// winspool.h so that GetPrinterData will be defined.
//
#if defined(KERNEL_MODE) && defined(USERMODE_DRIVER)
#include <winspool.h>
#endif

////////////////////////////////////////////////////////
//      Function Prototypes
////////////////////////////////////////////////////////

#ifdef KERNEL_MODE
                         
/////////////////////////////////////////////////////////////////////////
//
// Function Name:
//
//  HPGLDriverDMS
//
// Description:
//
//  Informs the unidrv host module that this plug in module is a Device
//  Managed Surface (DMS) and defines the features that will be hooked
//  through the HOOK_* constants.
//
// Notes:
//
//  Don't hook out LINETO since HOOK_STROKEANDFILLPATH will draw
//  the lines.
//
// Input:
//
//  PVOID pdevobj - The DEVOBJ
//  PVOID pvBuffer - buffer to place HOOK constant into
//  DWORD cbSize - probably the size of pvBuffer
//  PDWORD pcbNeeded - used to tell the caller more mem is needed
//
// Modifies:
//
//  None.
//
// Returns:
//
//	BOOL : TRUE if successful, FALSE otherwise
//
/////////////////////////////////////////////////////////////////////////
BOOL
HPGLDriverDMS(
    PVOID   pdevobj,
    PVOID   pvBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    POEMDEVMODE pOEMDM   = NULL; 
    PDEVOBJ     pDevObj  = NULL;


    TERSE(("HPGLDriverDMS\n"));

    REQUIRE_VALID_DATA( pdevobj, return FALSE );
    pDevObj = (PDEVOBJ)pdevobj;

#if 0 
//TEMP
    POEMPDEV    poempdev = NULL;
    poempdev = POEMPDEV((PDEV *) pVectorPDEV)->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    pOEMDM = (POEMDEVMODE)pDevObj->pOEMDM;
    /*/
    ASSERT(pOEMDM);
    /*/
    REQUIRE_VALID_DATA( pOEMDM, return FALSE );
    //*/
    REQUIRE_VALID_DATA( pvBuffer, return FALSE );
    // REQUIRE( cbSize >= sizeof( DWORD ), ERROR_INVALID_DATA, return FALSE );
#endif

// MONOCHROME. I cant figure out how to get poempdev here. Initially it was the OEM Devmode
// but it is no longer used in monochrome version of driver. so we have to use poempdev
// and i am trying to figure out how to get it. Till then lets just use if (1)
// I think we can use if (TRUE) because the very fact that this function is called indicates
// that HPGL has been chosen as the Graphics Language in the Advanced menu. Had it not
// been chosen HPGLInitVectorProcTable would have returned NULL and this function would not have
// been called.
// So now the question is. Why to put a condition if the condition is to be hardcoded to 
// to TRUE. Well, cos eventually I want to have a condition here so that the structure is 
// same as Color driver, but cannot figure out what kind of condition will be appropriate here.
//

//    if (poempdev->UIGraphicsMode == HPGL2)
    if (TRUE)
    {
        VERBOSE(("\nPrivate Devmode is HP-GL/2\n"));
        *(PDWORD)pvBuffer =
            HOOK_TEXTOUT    |
            HOOK_COPYBITS   |
            HOOK_BITBLT     |
            HOOK_STRETCHBLT |
            HOOK_PAINT      |
#ifndef WINNT_40
            HOOK_PLGBLT     |
            HOOK_STRETCHBLTROP  |
            HOOK_TRANSPARENTBLT |
            HOOK_ALPHABLEND     |
            HOOK_GRADIENTFILL   |
#endif
            HOOK_STROKEPATH |
            HOOK_FILLPATH   |
            HOOK_STROKEANDFILLPATH;
    }
    else
    {
        VERBOSE(("\nPrivate Devmode is Raster\n"));
        *(PDWORD)pvBuffer = 0;
    }        

    return TRUE;
}

#endif // #ifdef KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\gldebug.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.

Module Name:

    gldebug.h

Abstract:

    Macros used for debugging purposes

Environment:

    Windows NT printer drivers

Revision History:

    03/16/96 -davidx-
        Created it.

--*/


#ifndef _GLDEBUG_H_
#define _GLDEBUG_H_

#include "debug.h"

///////////////////////////////////////////////////////////////////////////
// REQUIRE macros
//
// REQUIRE_VALID_POINTER(ptr, err, exitclause)
//
//   General purpose macro to check pointer, set last error and bug out with
//   the given exit clause.
//
// REQUIRE_VALID_ALLOC(ptr, exitclause)
//
//   Special case version of REQIRE_VALID_POINTER for use when allocating mem.
//
// REQUIRE_VALID_DATA(ptr, exitclause)
//
//   Special case version of REQUIRE_VALID_POINTER for use when checking a 
//   data pointer.
//
// These macros are meant as an alternative to the use of ASSERT (which
// behaves differently in DBG and release modes).  For simple pointer
// checking of parameters and allocations use these macros in the
// following ways:
//
// void Foo(ISomeType *pSome)
// {
//     // Example #1: no return type--use "return" for pSome exit clause
//     REQUIRE_VALID_DATA(pSome, return);
//     //...
// }
//
// HRESULT Bar(ISomeType *pSome)
// {
//     // Example #2: return a value--use desired value with return
//     REQUIRE_VALID_DATA(pSome, return E_POINTER);
//
//     // Example #3: use other macro for allocations
//     PBYTE pData = (PBYTE) MemAlloc(CHUNK_O_DATA);
//     REQUIRE_VALID_ALLOC(pData, return E_OUTOFMEMORY);
//
//     HRESULT hRet = S_OK;
//     switch(pSome->m_bleah)
//     {
//     case SNAFU:
//         ISomeType *pGump = GetSomething();
//         // Example #4: use assignment and break for exit clause
//         REQUIRE_VALID_DATA(pGump, hRet = E_FAIL; break);
//         break;
//     }
//     return hRet;
// }
//
///////////////////////////////////////////////////////////////////////////
#define REQUIRE_VALID_POINTER(ptr, err, exitclause) { if ( !(ptr) ) { SetLastError(err); exitclause; } }

#define REQUIRE_VALID_ALLOC(ptr, exitclause) REQUIRE_VALID_POINTER(ptr, ERROR_OUTOFMEMORY, exitclause)
#define REQUIRE_VALID_DATA(ptr, exitclause) REQUIRE_VALID_POINTER(ptr, ERROR_INVALID_DATA, exitclause)


#endif	// !_GLDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\glvminit.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.

Module Name:

        glvminit.h

Abstract:

        Declaration of functions that this plugin supports. 
        (look in vectorif.h) 

Environment:

        Windows NT Unidrv driver

Revision History:

        02/29/00 -hsingh-
                Created

        mm-dd-yy -author-
                description

--*/


#ifndef _GLVMINIT_H_
#define _GLVMINIT_H_

#include "vectorc.h"

// extern interface declarations
#ifdef __cplusplus
extern "C" {
#endif




    //
    // Part. 1
    // Functions listed in oemkm.h
    //
        BOOL
        HPGLDriverDMS(
                PVOID   pdevobj,
                PVOID   pvBuffer,
                DWORD   cbSize,
                PDWORD  pcbNeeded
                );

        INT
        HPGLCommandCallback(
                PDEVOBJ pdevobj,
                DWORD   dwCmdCbID,
                DWORD   dwCount,
                PDWORD  pdwParams
                );

        LONG
        HPGLImageProcessing(
                PDEVOBJ             pdevobj,
                PBYTE               pSrcBitmap,
                PBITMAPINFOHEADER   pBitmapInfoHeader,
                PBYTE               pColorTable,
                DWORD               dwCallbackID,
                PIPPARAMS           pIPParams,
                OUT PBYTE           *ppbResult
                );

        LONG
        HPGLFilterGraphics(
                PDEVOBJ     pdevobj,
                PBYTE       pBuf,
                DWORD       dwLen
                );

        
        LONG
        HPGLCompression(
                PDEVOBJ     pdevobj,
                PBYTE       pInBuf,
                PBYTE       pOutBuf,
                DWORD       dwInLen,
                DWORD       dwOutLen,
                INT     *piResult
                );

        LONG
        HPGLHalftonePattern(
                PDEVOBJ     pdevobj,
                PBYTE       pHTPattern,
                DWORD       dwHTPatternX,
                DWORD       dwHTPatternY,
                DWORD       dwHTNumPatterns,
                DWORD       dwCallbackID,
                PBYTE       pResource,
                DWORD       dwResourceSize
                );


        LONG
        HPGLMemoryUsage(
                PDEVOBJ         pdevobj,
                POEMMEMORYUSAGE pMemoryUsage
                );

        LONG
        HPGLTTYGetInfo(
                PDEVOBJ     pdevobj,
                DWORD       dwInfoIndex,
                PVOID       pOutputBuf,
                DWORD       dwSize,
                DWORD       *pcbcNeeded
                );

        LONG
        HPGLDownloadFontHeader(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG
        HPGLDownloadCharGlyph(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                HGLYPH      hGlyph,
                PDWORD      pdwWidth,
                OUT DWORD   *pdwResult
                );

        LONG
        HPGLTTDownloadMethod(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG
        HPGLOutputCharStr(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                DWORD       dwType,
                DWORD       dwCount,
                PVOID       pGlyph
                );

        
        LONG
        HPGLSendFontCmd(
                PDEVOBJ      pdevobj,
                PUNIFONTOBJ  pUFObj,
                PFINVOCATION pFInv
                );

        BOOL
        HPGLTextOutAsBitmap(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

    //
    // Part 2.
    // Functions listed in enable.c
    // The order of functions listed is same as the order in 
    // static DRVFN UniDriverFuncs[]  in unidrv2\control\enable.c
    //
        PDEVOEM APIENTRY
        HPGLEnablePDEV(
                PDEVOBJ   pdevobj,
                PWSTR     pPrinterName,
                ULONG     cPatterns,
                HSURF    *phsurfPatterns,
                ULONG     cjGdiInfo,
                GDIINFO  *pGdiInfo,
                ULONG     cjDevInfo,
                DEVINFO  *pDevInfo,
                DRVENABLEDATA  *pded
                );

        BOOL
        HPGLResetPDEV(
                PDEVOBJ  pPDevOld,
                PDEVOBJ  pPDevNew
                );

        VOID
        HPGLCompletePDEV(
                DHPDEV  dhpdev,
                HDEV    hdev
                );

        VOID
        HPGLDisablePDEV(
                PDEVOBJ pPDev
                );

        BOOL
        HPGLEnableSurface(
                PDEVOBJ pPDev
                );

        VOID
        HPGLDisableSurface(
                PDEVOBJ pPDev
                );

        VOID
        HPGLDisableDriver(
                VOID
                );

        BOOL
        HPGLStartDoc(
                SURFOBJ *pso,
                PWSTR   pDocName,
                DWORD   jobId
                );

        BOOL
        HPGLStartPage(
                SURFOBJ *pso
                );

        BOOL
        HPGLSendPage(
                SURFOBJ *pso
                );

        BOOL
        HPGLEndDoc(
                SURFOBJ *pso,
                FLONG   flags
                );

        BOOL
        HPGLStartBanding(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        HPGLNextBand(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        HPGLPaint(
                SURFOBJ         *pso,
                CLIPOBJ         *pco,
                BRUSHOBJ        *pbo,
                POINTL          *pptlBrushOrg,
                MIX             mix
                );

        BOOL
        HPGLBitBlt(
                SURFOBJ    *psoTrg,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclTrg,
                POINTL     *pptlSrc,
                POINTL     *pptlMask,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrush,
                ROP4        rop4
                );

        BOOL
        HPGLStretchBlt(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode
                );

#ifndef WINNT_40
        BOOL
        HPGLStretchBltROP(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode,
                BRUSHOBJ   *pbo,
                DWORD       rop4
                );

        BOOL
        HPGLPlgBlt(
                SURFOBJ         *psoDst,
                SURFOBJ         *psoSrc,
                SURFOBJ         *psoMask,
                CLIPOBJ         *pco,
                XLATEOBJ        *pxlo,
                COLORADJUSTMENT *pca,
                POINTL          *pptlBrushOrg,
                POINTFIX        *pptfixDest,
                RECTL           *prclSrc,
                POINTL          *pptlMask,
                ULONG           iMode
                );

#endif

        BOOL
        HPGLCopyBits(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                POINTL     *pptlSrc
                );

        ULONG
        HPGLDitherColor(
                DHPDEV  dhpdev,
                ULONG   iMode,
                ULONG   rgbColor,
                ULONG  *pulDither
                );

        BOOL
        HPGLRealizeBrush(
                BRUSHOBJ   *pbo,
                SURFOBJ    *psoTarget,
                SURFOBJ    *psoPattern,
                SURFOBJ    *psoMask,
                XLATEOBJ   *pxlo,
                ULONG       iHatch
                );

        BOOL 
        HPGLLineTo(
                SURFOBJ    *pso,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                LONG        x1,
                LONG        y1,
                LONG        x2,
                LONG        y2,
                RECTL      *prclBounds,
                MIX         mix
                );
        
        BOOL
        HPGLStrokePath(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                LINEATTRS  *plineattrs,
                MIX         mix
                );
        
        BOOL
        HPGLFillPath(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                MIX         mix,
                FLONG       flOptions 
                );
        
        BOOL
        HPGLStrokeAndFillPath(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pboStroke,
                LINEATTRS  *plineattrs,
                BRUSHOBJ   *pboFill,
                POINTL     *pptlBrushOrg,
                MIX         mixFill,
                FLONG       flOptions
                );
        
#ifndef WINNT_40
        BOOL
        HPGLGradientFill(
                SURFOBJ    *psoDest,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                TRIVERTEX  *pVertex,
                ULONG       nVertex,
                PVOID       pMesh,
                ULONG       nMesh,
                RECTL      *prclExtents,
                POINTL     *pptlDitherOrg,
                ULONG       ulMode
                );

        BOOL
        HPGLAlphaBlend(
                SURFOBJ    *psoDest,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDest,
                RECTL      *prclSrc,
                BLENDOBJ   *pBlendObj
                );

        BOOL
        HPGLTransparentBlt(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                ULONG      iTransColor,
                ULONG      ulReserved
                );

#endif

        BOOL
        HPGLTextOut(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

        ULONG
        HPGLEscape(
                SURFOBJ    *pso,
                ULONG       iEsc,
                ULONG       cjIn,
                PVOID       pvIn,
                ULONG       cjOut,
                PVOID       pvOut
                );

        PIFIMETRICS
        HPGLQueryFont(
                DHPDEV      dhpdev,
                ULONG_PTR   iFile,
                ULONG       iFace,
                ULONG_PTR  *pid
                );

        PVOID
        HPGLQueryFontTree(
                DHPDEV      dhpdev,
                ULONG_PTR   iFile,
                ULONG       iFace,
                ULONG       iMode,
                ULONG_PTR  *pid 
                );

        LONG
        HPGLQueryFontData(
                DHPDEV      dhpdev,
                FONTOBJ    *pfo,
                ULONG       iMode,
                HGLYPH      hg,
                GLYPHDATA  *pgd,
                PVOID       pv,
                ULONG       cjSize
                );

        ULONG
        HPGLGetGlyphMode(
                DHPDEV  dhpdev,
                FONTOBJ *pfo
                );

        ULONG
        HPGLFontManagement(
                SURFOBJ *pso,
                FONTOBJ *pfo,
                ULONG   iMode,
                ULONG   cjIn,
                PVOID   pvIn,
                ULONG   cjOut,
                PVOID   pvOut
                );

        BOOL
        HPGLQueryAdvanceWidths(
                DHPDEV  dhpdev,
                FONTOBJ *pfo,
                ULONG   iMode,
                HGLYPH *phg,
                PVOID  *pvWidths,
                ULONG   cGlyphs
                );


#ifdef __cplusplus
}
#endif

#endif  // !_GLVMINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\glvminit.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    glvminit.cpp

Abstract:
    This module contains the initial unidrv-hpgl handshaking function. 

Author:

[Environment:]
    Windows 2000 Unidrv driver

[Notes:]

Revision History:


--*/

#include "hpgl2col.h" //Precompiled header file

#include "vectorc.h"
#include "glvminit.h"

//
// Local function declaration.
//
BOOL bIsGraphicsModeHPGL2 (
                   IN  PDEV    *pPDev
                   );


//
// The jump table. Initializing the jump table with the functions that  
// hpgl2 driver supports.
//
static VMPROCS HPGLProcs =
{
    HPGLDriverDMS,
    HPGLCommandCallback,
    NULL,                       // HPGLImageProcessing
    NULL,                       // HPGLFilterGraphics
    NULL,                       // HPGLCompression
    NULL,                       // HPGLHalftonePattern
    NULL,                       // HPGLMemoryUsage
    NULL,                       // HPGLTTYGetInfo
    NULL,                       // HPGLDownloadFontHeader
    NULL,                       // HPGLDownloadCharGlyph
    NULL,                       // HPGLTTDownloadMethod
    NULL,                       // HPGLOutputCharStr
    NULL,                       // HPGLSendFontCmd
    HPGLTextOutAsBitmap,                       
    HPGLEnablePDEV,
    HPGLResetPDEV,
    NULL,                       // HPGLCompletePDEV,
    HPGLDisablePDEV,
    NULL,                       // HPGLEnableSurface,
    NULL,                       // HPGLDisableSurface,
    HPGLDisableDriver,
    HPGLStartDoc,
    HPGLStartPage,
    HPGLSendPage,
    HPGLEndDoc,
    HPGLStartBanding,
    HPGLNextBand,
    HPGLPaint,
    HPGLBitBlt,
    HPGLStretchBlt,
#ifndef WINNT_40
    HPGLStretchBltROP,
    HPGLPlgBlt,
#endif
    HPGLCopyBits,
    HPGLDitherColor,
    HPGLRealizeBrush,
    HPGLLineTo,
    HPGLStrokePath,
    HPGLFillPath,
    HPGLStrokeAndFillPath,
#ifndef WINNT_40
    HPGLGradientFill,
    HPGLAlphaBlend,
    HPGLTransparentBlt,
#endif
    HPGLTextOut,
    HPGLEscape,
#ifdef HOOK_DEVICE_FONTS
    HPGLQueryFont,
    HPGLQueryFontTree,
    HPGLQueryFontData,
    HPGLGetGlyphMode,
    HPGLFontManagement,
    HPGLQueryAdvanceWidths
#else
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
#endif
};

PVMPROCS HPGLInitVectorProcTable (             
                            PDEV    *pPDev,
                            DEVINFO *pDevInfo,
                            GDIINFO *pGDIInfo )
{
    ASSERT (pPDev);
    UNREFERENCED_PARAMETER(pDevInfo);
    UNREFERENCED_PARAMETER(pGDIInfo);

    if ( bIsGraphicsModeHPGL2 (pPDev) )
    {
        return &HPGLProcs;
    }
    return NULL;
}


/*++

Routine Name:
    bIsGraphicsModeHPGL2

Routine Description:
    Finds out whether the Graphics Mode chosen by the user from the Advanced Page 
    in the UI is HP-GL/2.

Arguments:
    IN  PDEV    *pPDev,  : Unidrv's PDEV

Return Value:
    TRUE : If the graphics mode chosen by user is HP-GL/2
    FALSE: Otherwise 

Last Error:
    Not changed.
 

--*/


BOOL bIsGraphicsModeHPGL2 ( 
                    IN  PDEV    *pPDev
                    )
{
    
    CHAR pOptionName[MAX_DISPLAY_NAME];
    DWORD cbNeeded = 0, cOptions = 0;

    //
    // The strings below are exactly as the ones in gpd
    // *Feature: GraphicsMode
    // *Option: HPGL2MODE
    // *Option: RASTERMODE
    // 
    if (  BGetDriverSettingForOEM(pPDev,
                                "GraphicsMode",     //This is not unicode
                                pOptionName,
                                MAX_DISPLAY_NAME,
                                &cbNeeded,
                                &cOptions)  &&
           !strcmp (pOptionName, "HPGL2MODE" )          //HPGL2 is not unicode
        )
    {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\glpdev.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.

Module Name:
    glpdev.h

Abstract:
    This module contains the definitions of various data structures
    used by the driver. 
    The main structure is the OEMPDEV

Author:


[Environment:]
    Windows 2000/Whistler Unidrv driver


[Notes:]

Revision History:


--*/

#ifndef _GLPDEV_H
#define _GLPDEV_H

#include "brshcach.h"
#include "oemdev.h"
#include "prcomoem.h"

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CDCB'      // Command Callback & DDI test dll
#define PCL_RGB_ENTRIES  770 // 3 * 256 = 768 -- a little wary in NT km. //dz 
#define NUM_PURE_COLORS     8   // C, M, Y, K, W, R, G, B.
#define NUM_PURE_GRAYS      2   // Black and White.
#define PALETTE_MAX         256  //max entries in raster palette
#define PCL_BRUSH_RGB       0
#define PCL_BRUSH_GRAY      1
#define PCL_BRUSH_PATTERN   2
#define PCL_BRUSH_NULLBRUSH 3
#define PCL_MITERJOIN_LIMIT 10
#define DPI_1200            1200
#define DPI_600             600
#define DPI_300             300
#define DPI_150             150
#define HPGL_INVALID_COLOR   0xffffffff 

#define UNDEFINED_PATTERN_NUMBER ((LONG)-1)

//
// The default PCL ROP code is 252.  Setup a default ROP3 value and
// a default ROP4 value using 252.
//
#define DEFAULT_ROP3        0xFC // 252: TSo
#define DEFAULT_ROP         (((DEFAULT_ROP3) << 8) | (DEFAULT_ROP3))
#define ROP4_SRC_COPY       0xCCCC  //SRC_COPY_ROP = 0xCCCC


//
// The unidriver now sets the ROP at the beginning of each page.  I don't want
// to guess at the value, but this is the current one.  Don't use this for
// anthing unless you have to.
//
#define UNIDRV_ROP3         0xB8 // 184: TSDTxax

#define INVALID_ROP3        0xFFFFFFFF

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

//
// Warning: the following enum order must match the order in OEMHookFuncs[].
//
enum {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
#ifdef HOOK_DEVICE_FONTS
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,
#endif

    MAX_DDI_HOOKS,
};

#define BBITS           8                   // Bits per BYTE
#define WBITS           (sizeof( WORD ) * BBITS)
#define WBYTES          (sizeof( WORD ))
#define DWBITS          (sizeof( DWORD ) * BBITS)
#define DWBYTES         (sizeof( DWORD ))

#ifndef _ERENDERLANGUAGE
#define _ERENDERLANGUAGE
typedef enum { ePCL, 
               eHPGL,
               eUNKNOWN
               } ERenderLanguage;
#endif

// Note: Constants match HPGL spec when possible.
typedef enum { ePIX_PLACE_INTERSECT = 0, 
               ePIX_PLACE_CENTER = 1 } EPixelPlacement;

typedef enum { eLINE_END_BUTT = 1, 
               eLINE_END_SQUARE = 2, 
               eLINE_END_TRIANGULAR = 3, 
               eLINE_END_ROUND = 4 } ELineEnd;

typedef enum { eLINE_JOIN_MITERED = 1, 
               eLINE_JOIN_MITERED_BEVELED = 2, 
               eLINE_JOIN_TRIANGULAR = 3, 
               eLINE_JOIN_ROUND = 4, 
               eLINE_JOIN_BEVELED = 5, 
               eLINE_JOIN_NONE = 6 } ELineJoin;

typedef enum { eNULLOBJECT          = 0xFF,
               eTEXTOBJECT          = 0,
               eHPGLOBJECT          = 1,
               eRASTEROBJECT        = 2,
               eRASTERPATTERNOBJECT = 3,
               eTEXTASRASTEROBJECT  = 4 //Text printed as Graphics
             } EObjectType;

//
// PCL defines
// 0 as transparent and 1 as opaque. (Esc*v#0, Esc*v#N).
// HPGL says TR0 is transparency off i.e. Opaque
// while TR1 is Transparent.
// So if eTransparent is passed in and we are in HP-GL mode
// then TR1 should be passed instead of TR0
//
typedef enum { eTRANSPARENT = 0,
               eOPAQUE = 1 } ETransparency;

typedef enum { kPen ,
               kBrush } ESTYLUSTYPE;

//
// Current Pattern Page 16-16 of PCL Implementors guide v6.0
//
typedef enum { kSolidBlackFg,   // 0 This is also the default in PCL
               kSolidWhite,     // 1  
               kHPShade,        // 2
               kHPHatch,        // 3
               kUserDefined,    // 4
             } ECURRENTPATTERNTYPE;

//
// We have 8 palettes to use: 0-7
// Unidriver text uses palette 0
// 16, 24, and 32 bit cid commands all use the 24 bit palette
// HPGL uses palette 1
//
typedef enum { eUnknownPalette = -1,
               eHPGL_CID_PALETTE = 1,
               eRASTER_PATTERN_CID_PALETTE = 3,
               eTEXT_CID_PALETTE = 5,
               eRASTER_CID_24BIT_PALETTE = 6,
               eRASTER_CID_8BIT_PALETTE = 7,
               eRASTER_CID_4BIT_PALETTE = 8,
               eRASTER_CID_1BIT_PALETTE = 9 } ECIDPalette;

typedef enum { eDEVICE_RGB = 0,
               eDEVICE_CMY = 1,
               eCOLORIMETRIC_RGB = 2,
               eCIE_LAB = 3,
               eLUM_CHROM = 4 } EColorSpace;

typedef enum { eSolidLine, eCustomLine, eDefinedLine } ELineType;

typedef struct _LINETYPE
{
    ELineType eType;
    FLOATOBJ foPatternLength;
    INT iId;
} LINETYPE, *PLINETYPE;

/*dz POINTUI, COLORTABLETYPE and PCLPATTERNTYPE were moved here from 
  realize.h  putting them here allows the raster code to use these
  structures.
*/

// Brush data types

//dz there is probably a predefined POINT Structure to use
typedef struct _POINTUI { //POINTUI
  UINT x;
  UINT y;
} POINTUI, *PPOINTUI;

typedef struct _COLORTABLETYPE {    // COLORTABLETYPE
  ULONG     iUniq;                  // Unique Palette ID as extracted from XLATEOBJ.
  BYTE      Depth;                  // The depth of the palette. HP_e8bit only.
  BYTE      byData[PCL_RGB_ENTRIES];    // This is pData necessary for HP_eIndexedPixel case.
  ULONG     cEntries;               // Number of entries in the palette.
} COLORTABLE, *PCOLORTABLE;

//
// Raster palette 
// The requirement for the ulValidPalID entry can be explained by an
// example.
// 1,4,8bpp images are downloaded using palettes (BGetPalette in palette.cpp). 
// We create a different palette for each bpp image (look at ECIDPalette above).
// A palette for 4bpp image has 16 colors while that for 8bpp has 256 colors. 
// Suppose a 4bpp image is followed by 8bpp image. When palette for 4bpp image
// is being downloaded  eRASTER_CID_4BIT_PALETTE is the active palette.
// When palette for 8bpp image is downloaded eRASTER_CID_8BIT_PALETTE is the
// active palette. Can the palette entries downloaded in 4bpp case be re-used
// in 8bpp case.(i.e. after downloading 16 colors in first case, can we download 
// only 256-16 colors in second case).
// Answer is NO, cos the palette ID's in both are cases are different. 
// Colors from one palette id cannot be carried over to colors to a different
// palette ID. So we use the ulValidPalID to record which color has been downloaded
// for which palette.
// if ulValidPalID[0] = 1, it means that color is downloaded for eRASTER_CID_1BIT_PALETTE
// if ulValidPalID[0] = 4, it means that color is downloaded for eRASTER_CID_4BIT_PALETTE
// if ulValidPalID[0] = 8, it means that color is downloaded for eRASTER_CID_8BIT_PALETTE
// if ulValidPalID[0] = 9, it means that color is downloaded for eRASTER_CID_8BIT_PALETTE
//  (0x9 = 0x0001 | 0x1000)   and for eRASTER_CID_1BIT_PALETTE
//
// It should be evident that this method can be used only for 2^n bpp. and n <=5 
// because sizeof(ULONG) = 32 and 2^5=32.
//

typedef  struct _HPGLPAL_DATA {
    ULONG    pEntries;                  // Number of entries in the palette.
    INT     iWhiteIndex;                // Index for white entry (background) 
    INT     iBlackIndex;                // Index for black entry (background) 
    ULONG   ulDirty [ PALETTE_MAX ];    // need to reselect the palette entry - the color has changed
    ULONG   ulPalCol[ PALETTE_MAX ];    // Palette entries!  
    ULONG   ulValidPalID[PALETTE_MAX ]; // The palette entry is valid for which palette.
} HPGLPAL_DATA;

//
// Defines a realized bitmap pattern brush object
//

typedef struct _PCLPATTERNTYPE { 
    //LONG        iPatIndex;         // Index to special patterns: HS_DDI_MAX, HS_xxx...
    LONG        lPatIndex;         // Pattern Number of downloaded pattern. Used for cache'ing.
    ECURRENTPATTERNTYPE eCurPatType;
    BYTE        compressionEnum;   // The compression associated with this pattern.
    BYTE        colorMappingEnum;  // HP_eDirectPixel, or HP_eIndexedPixel. If DirectPixel, Palette is invalid.
    BYTE        PersistenceEnum;   // The persistence of this pattern.
    SIZEL       size;              // size of the bitmap
    POINTUI     destSize;          // Specifies target size for the bitmap.
    ULONG       iBitmapFormat;     // bitmap format from GDI - psoSrc->iBitmapFormat
    LONG        lDelta;            // byte offset from one line to the next
     COLORTABLE  ColorTable;        // The palette associated with this pattern.
    HPGLPAL_DATA    palData;           // Raster palette;
    ULONG       cBytes;            // Number of bytes of bitmap data.
    PBYTE       pBits;             // bitmap data

} PCLPATTERN, *PPCLPATTERN;

typedef LONG PENID; // Pen ids: These map to the numerical ids of pens used by HPGL
typedef LONG PATID; // Pattern ids:

typedef struct _SolidMarkerImp
{
    LONG  lPatternID; // To be used for monochrome printers.
    DWORD dwRGBColor; // To be used for monochrome&color printers.
    PENID iPenNumber; // To be used for color      printers.
} SolidMarkerImp;

typedef enum { FT_eSOLID        = 1,
               FT_eHPGL_PEN     = 2,
               FT_ePERCENT_FILL = 10,
               FT_eHPGL_BRUSH   = 11,
               FT_eHATCH_FILL   = 21,
               FT_ePCL_PEN      = 22,
               FT_ePCL_BRUSH    = 22 } EFillType;

typedef struct _PatternMakerImp
{
    LONG             lPatternID;
    EFillType        eFillType;
    POINTL           origin;
} PatternMarkerImp;

typedef struct _PercentFillImp
{
    WORD wPercent;
    PENID iPenNumber; //Required for color printers.
} PercentFillImp;

typedef struct HatchFillImp
{
    ULONG          iHatch;
    SolidMarkerImp ColorInfo; //Hatch brush also have color associated with it.
} HatchFillImp;

typedef enum { MARK_eSOLID_COLOR, 
               MARK_eNULL_PEN, 
               MARK_eRASTER_FILL,
               MARK_eHATCH_FILL,
               MARK_ePERCENT_FILL } EMarkerType;

// Use ULONG instead of enum for fill mode to avoid possible casting problems 
// in sprintf.
const ULONG FILL_eODD_EVEN = 0;
const ULONG FILL_eWINDING = 1;
typedef ULONG EMarkerFill;
// typedef enum { FILL_eODD_EVEN = 0, FILL_eWINDING = 1 } EMarkerFill;

typedef struct _HPGLMARKER
{
    EMarkerType eType;
    EMarkerFill eFillMode;       // Fill mode for a brush.  Meaningless for pens.
                                 // M = Monochrome, C = Color 
    LONG             lPatternID; // Pattern(MC), SolidColor(M), Hatch(MC), Percent(MC)
    DWORD            dwRGBColor; // Solid(MC)
    PENID            iPenNumber; // Solid (C)
    ULONG            iHatch;     // Hatch(MC)
    ULONG            iPercent;   // Hatch(MC)
    POINTL           origin;     // Pattern(MC)

    EFillType        eFillType;  // FT_?
    ERenderLanguage  eDwnldType; //whether the pattern was downloaded as HPGL/PCL

/***
    union 
    {
        SolidMarkerImp Solid;
        PatternMarkerImp Pattern;
        PercentFillImp Percent;
        HatchFillImp Hatch;
    } u;
**/
} HPGLMARKER, *PHPGLMARKER;

#define PENPOOLSIZE 5
typedef struct _PENPOOL
{
    PENID firstPenID;
    PENID lastPenID;
    struct 
    {
        INT useCount;
        COLORREF color;
    } aPens[PENPOOLSIZE];
} PENPOOL, *PPENPOOL;

typedef struct _HPGLSTATE
{
    // ROP: How will this be stored?  Is this the same as transparency mode?
    EPixelPlacement ePixelPlacement;
    RECTL           rClipRect;
    FLOATOBJ        fLineWidth;
    INT             iLineType;
    ELineEnd        eLineEnd;
    ELineJoin       eLineJoin;
    FLOATOBJ        fMiterLimit;
    LINETYPE        LineType;
    PENPOOL         PenPool;
    PENPOOL         BrushPool;
    CLIPOBJ         *pComplexClipObj;
    PatternMarkerImp Pattern;
    INT             iNumPens;
} HPGLSTATE, *PHPGLSTATE;

typedef struct _RASTERSTATE
{
    PCLPATTERN PCLPattern;
} RASTERSTATE, *PRASTERSTATE;

//
// Configure Image Commands and related data structures
//
typedef struct _CIDSHORT
{
    BYTE    ubColorSpace;
    BYTE    ubPixelEncodingMode;
    BYTE    ubBitsPerIndex;
    BYTE    ubPrimary1;
    BYTE    ubPrimary2;
    BYTE    ubPrimary3;
} CIDSHORT, *PCIDSHORT;

typedef enum { eSHORTFORM = 0,
               eLONGFORM = 1 } ECIDFormat;

// Use these flags in bInitHPGL to control the initialization of
// various HPGL settings.  Note that these won't always be used as
// you expect.  There are some sticky initialization issues and if
// you change these TEST THE RESULTS! -and on multiple pages! JFF
#define INIT_HPGL_STARTPAGE 0x01
#define INIT_HPGL_STARTDOC  0x02

//
// Flags used to initialize the color commands
//
#define PF_INIT_TEXT_STARTPAGE    0x01
#define PF_INIT_TEXT_STARTDOC     0x02
#define PF_INIT_RASTER_STARTPAGE  0x04
#define PF_INIT_RASTER_STARTDOC   0x08
//
// Flags for SelectTransparancy
//
// Just overwrite the transparency. 
#define PF_FORCE_SOURCE_TRANSPARENCY     (0x01)
#define PF_FORCE_PATTERN_TRANSPARENCY    (0x01 << 1)
//
// Do not change the transparency.
//
#define PF_NOCHANGE_SOURCE_TRANSPARENCY  (0x01 << 2)
#define PF_NOCHANGE_PATTERN_TRANSPARENCY (0x01 << 3)

//
// Flags for job start and page start commands
//
#define PF_STARTDOC        0x01
#define PF_STARTPAGE       0x02

//
// BUGBUG sandram - find out how GDI defines the DMBIN_USER
// for front tray and rear tray
//
#define DMBIN_HPFRONTTRAY       0x0102
#define DMBIN_HPREARTRAY        0x0101
//
// BUGBUG - sandram: Our data structures should DWORD aligned
// to run correctly on Intel and Alpha.
// We're very lucky it's working now.
//


//
// Following are the flags for OEMPDEV->Flags
// PDEVF_CANCEL_JOB : To indicate job cancel
// PDEVF_IN_COMMONROPBLT : Is set when dwCommonROPBlt() is entered, and reset on exit. This
//                        helps in catching recursion.
// PDEVF_USE_HTSURF : The driver is declared a color driver (i.e. destination surface is 24bpp) 
//                    but in fact driver is monochrome. So we create a monochrome shadow bitmap 
//                    to render color images. So whenever that bitmap has to be 
//                    used, we set this flag.
// PDEVF_INVERT_BITMAP : When bitmap needs to be inverted before rendering.
//                       The function that sets it should also unset it.
//

#define PDEVF_CANCEL_JOB            0x80000000
#define PDEVF_IN_COMMONROPBLT        (0x00000001)
#define PDEVF_USE_HTSURF            (0x00000001 << 1) // same as 0x2
#define PDEVF_HAS_CLIPRECT          (0x00000001 << 2) // same as 0x4
#define PDEVF_INVERT_BITMAP         (0x00000001 << 3) // same as 0x8
#define PDEVF_RENDER_IN_COPYBITS    (0x00000001 << 4) // same as 0x10
#define PDEVF_RENDER_TRANSPARENT    (0x00000001 << 5) // same as 0x10


struct IPrintOemDriverUni;

#define HPGLPDEV_SIG 'hpgl'

typedef struct _OEMPDEV {
    //
    // Start this pdev with a signature, to differentiate it from pclxl's pdev
    //
    DWORD dwSig;

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // This test DLL hooks out every drawing DDI. So it needs to remember
    // Unidrv's hook function pointer so it call back.
    //
    PFN             pfnUnidrv[MAX_DDI_HOOKS];
    ERenderLanguage eCurRenderLang;
    BOOL            bInitHPGL;
    WORD            wInitCIDPalettes;
    WORD            wJobSetup;
    BOOL            bTextTransparencyMode;
    BOOL            bTextAsBitmapMode;
    HPGLSTATE       HPGLState;
    RASTERSTATE     RasterState;
    EObjectType     eCurObjectType;
    ECIDPalette     eCurCIDPalette;
    ULONG           uCurFgColor;
    DWORD           dwCursorOriginX;
    DWORD           dwCursorOriginY;
    ROP4            CurrentROP3;     // keep track of the current ROP (MIX)
    OEMHALFTONE     CurHalftone;     //
    OEMCOLORCONTROL CurColorControl; // Keep track of previous Color Smart settings
    int             iPalType;
    int             CurSourceTransparency;
    int             CurPatternTransparency;
    ETransparency   CurHPGLTransparency; //Transparency, eOPAQUE=OFF, eTRANSPARENT=ON
    IPrintOemDriverUni* pOEMHelp; // Note: I'm NOT going to refcount this pointer!
    HPALETTE        hOEMPalette;

    //
    // The fields below were earlier in OEMDEVMODE. But since merging the plugin within
    // unidrv, we are copying them here. 
    //
    OEMGRAPHICSMODE UIGraphicsMode; 
    OEMRESOLUTION   dmResolution;
    OEMPRINTERMODEL PrinterModel;

    //
    // BrushCache
    //
    BrushCache *pBrushCache;
    BrushCache *pPCLBrushCache;

    // 
    // Other 
    //

    DWORD         dwFlags;
    LONG          lRecursionLevel;
    WORD          Rop3CopyBits; // Can I use CurrentROP3 ?????
    SURFOBJ      *psoHTBlt;     // Shadow bitmap.
    RECTL         rclHTBlt;
    BOOL          bColorPrinter;
    BOOL          bStick; 
    ULONG         ulNupCompr;   // What shall be the compression factor for values values 
                                // of nup. i.e. if iLayout = NINE_UP, this value is 3

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\oem.h ===
////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
//Module Name:
//
//    oem.h
//
//Abstract:
//
//    This file contains definitions and declarations of GPD resource ID.
//
//Environment:
//
//    Windows NT 5.0
//
///////////////////////////////////////////////////////////////

#ifndef _INCLUDE_OEM_H_
#define _INCLUDE_OEM_H_

#ifndef WIN32
#define WIN32
#endif

//#ifndef RIP_ENABLED
//#define RIP_ENABLED
//#endif

//#ifndef FASTRASTER_ENABLED
//#define FASTRASTER_ENABLED
//#endif

#include "comnfile.h"

#ifdef __cplusplus
extern "C" {
#endif

//
//User Mode specific includes
//
#ifndef KERNEL_MODE
#include <commctrl.h>
#endif // !KERNEL_MODE

#ifdef __cplusplus
} // extern "C"
#endif

#include "oemdev.h"

#ifndef KERNEL_MODE
// start of ui additions
#define FLAG_OPTITEM        0x80000000
#define FLAG_PROPSHEET      0x40000000

#define PT_LOAD			1
#define PT_SELECT		2
#define PT_SETDEVMODE	3
#define GM_LOAD			21
#define GM_SELECT		22
#define GM_SETDEVMODE	23

#define OEM_DOCPROP_PAGES 2		// Number of PropPages to add to the Document Defaults PropSheet.
#define OEM_PRNPROP_PAGES 1		// Number of PropPages to add to the Printer Properties PropSheet.

#define OPTITEM_COUNT 1			// Number of Items to add to the Tree View in the Device Settings
								// PropPage of the Pinter Properties PropSheet.
#define MAX_STRING_LENGTH 64

// Helper Macros------------------------------------------------------------------------------------------
#define LOADSTR( id, strBuffer )  LoadString( pOemUIParam->hModule, id, strBuffer, sizeof(tmp))
#define ADDSTR( id, strBuffer ) SendDlgItemMessage( hDlg, id, CB_ADDSTRING, (WPARAM)0, (LPARAM)strBuffer )
#define SETITEM( id, item ) SendDlgItemMessage( hDlg, id , CB_SETITEMDATA, (WPARAM)cbIndex, (LPARAM)item )

#define DUPLEXED( dmDuplex ) (dmDuplex == DMDUP_HORIZONTAL) || \
							 (dmDuplex == DMDUP_VERTICAL)

#define ISVALID_PAPERTYPE( type ) (type == TRANSPARENCY) || \
								  (type == LABELS) || \
								  (type == CARDSTOCK)
// end Helper Macros--------------------------------------------------------------------------------------

// Needs to be added to the string table
#define HPCLJ4500_DEFAULTS L"HP Color LaserJet 4500 Document Defaults"

typedef struct _TABEXTRADATA
{
	OEMCOLOROPTIONS COptions;
} TABEXTRADATA, *PTABEXTRADATA;

//
// MANUALINFO structure
//
// Used during the manipulation of the Manual Settings Dialog Box.
//
typedef struct _MANUALINFO
{
	HANDLE		  hModule;
	PTABEXTRADATA pTabControl1;
	PTABEXTRADATA pTabControl2;
	PTABEXTRADATA pTabControl3;
	BOOL		  defaults;
	LPWSTR		  lpwstrHelpFile;
	HANDLE		  hPrinter;
	HANDLE		  hOEMHeap;
} MANUALINFO, *PMANUALINFO;

//
// OEMSTATEINFO structure
//
// Each OEM added property page allocates memory for this structure.
// Its purpose is to hold Private Devmode information temporarily until
// the user clicks OK, APPLY or changes from one property sheet to another.
// If any of these 3 events occur, the OEMSTATEINFO structure is written
// to the Private Devmode.  If in the event the user clicks the CANCEL
// button, the OESTATEINFO is discarded.
//
typedef struct _OEMSTATEINFO
{
	POEMDEVMODE		pOEMPrivateDMState;
	POEMUIPSPARAM	pOemUIParam;
	BOOL			defaults;
} OEMSTATEINFO, *POEMSTATEINFO;

typedef struct _OEMPS_USERDATA {

    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    HANDLE          hOemPage[2];
    DWORD           dwMode;
	LPWSTR			lpwstrHelpFile;

} OEMPS_USERDATA, *POEMPS_USERDATA;



#define IDD_OPTIONS_PROPERTYPAGE        101
#define IDB_COLORSMART                  102
#define IDI_COLOR_SETUP					103
#define IDD_COLORSETUP_PROPERTYPAGE     104
#define IDS_UNSPECIFIED_TYPE			105
#define IDS_PLAIN_TYPE					106
#define IDS_PREPRINTED_TYPE				107
#define IDS_LETTERHEAD_TYPE				108
#define IDS_TRANSPARENCY_TYPE			109
#define IDS_GLOSS_TYPE					110
#define IDS_PREPUNCHED_TYPE				111
#define IDS_LABELS_TYPE					112
#define IDS_BOND_TYPE					113
#define IDS_RECYCLED_TYPE				114
#define IDS_COLOR_TYPE					115
#define IDS_HEAVY_TYPE					116
#define IDS_CARDSTOCK_TYPE				117
#define IDS_COLORTREATMENT				118
#define IDS_DOCPROP_OPTITEM				119
#define IDS_PRNPROP_OPTITEM				120
#define IDD_DEVICE_PROPPAGE				121
#define IDS_HPGL2_MODE                  122
#define IDS_RASTER_MODE                 123
#define IDD_MANUAL_DIALOG				124
#define IDS_TEXT						125
#define IDS_GRAPHICS					126
#define IDS_PHOTOS						127
#define IDS_TRAY1						128
#define	IDS_TRAY2						129
#define	IDS_TRAY3						130
#define	IDS_INSTALLED					131
#define	IDS_NOTINSTALLED				132
#define IDS_OPTIONAL_TRAY3				133
#define IDS_OPTIONAL_DUPLEXER			134
#define IDS_600DPI						135
#define IDS_RET_DISPLAY					136
#define IDS_RET_ON						137
#define IDS_RET_OFF						138
#define IDS_PRINTER_DEFAULT				139
#define IDS_AUTO_SOURCE					140
#define IDS_GMODE						141
#define	IDS_GFINISH						142
#define	IDS_PFONTS						143
#define	IDS_CSMART						144
#define IDS_CTREATMENT					145
#define IDS_MANUAL						146
#define IDS_FRASTER						147
#define IDS_FONTSMART					148
#define IDS_FONTSMART_ERROR				149
#define IDS_ERROR						150
#define IDS_300DPI						151
#define IDD_ABOUT_DIALOG				153
#define IDB_HPLOGO						154
#define IDS_NORMAL_QUALITY				155
#define IDS_ECONOMODE_QAULITY			156
#define IDS_PRESENTATION_QUALITY		157
#define IDS_RIP_MODE					158
#define IDS_OEMMETAFILE_SPOOLING		159
#define IDS_ENABLE						160
#define IDS_DISABLE						161
#define IDS_FRONT_FEED					162
#define IDS_REAR_FEED					163
#define IDS_CUSTOM                      164

//
//	Help IDs
//
#define IDH_UNIDRV_COLOR_SETUP			12001

#define IDC_GRAPHICS_COMBO              1006
#define IDC_TRUETYPE_CHECK              1007
#define IDC_METAFILE_CHECK              1008
#define IDC_PRINTERFONT_CHECK           1009
#define IDC_GLOSS_CHECK                 1010
#define IDC_FONTSMART_BUTTON            1011
#define IDC_DEFAULTS_BUTTON             1012
#define IDC_PAPERTYPE_COMBO             1013
#define IDC_PAPERTYPE_STATIC            1014
#define IDC_GRAPHICS_STATIC             1015
#define IDC_CTREATMENT_GROUPBOX         1016
#define IDC_COLORSMART_RADIO            1017
#define IDC_COLORSMART_LOGO             1018
#define IDC_MANUAL_RADIO                1019
#define IDC_DEFAULTS2_BUTTON            1020
#define IDC_OPTIONS_BUTTON2             1022
#define IDC_DEVICE_TREEVIEW				1023
#define IDC_DEVICE_GROUPBOX				1024
#define IDC_TAB_CONTROL	                1025
#define IDC_CCONTROL_GROUPBOX           1026
#define IDC_HALFTONE_GROUPBOX           1027
#define IDC_VIVID_RADIO                 1028
#define IDC_SCRNMATCH_RADIO             1029
#define IDC_DETAIL_RADIO                1030
#define IDC_SMOOTH_RADIO                1031
#define IDC_DEFAULTS3_BUTTON            1032
#define IDC_CANCEL                      1033
#define IDC_FASTRASTER_CHECK			1034
#define ID_CONTEXT_HELP					1035
#define	IDC_ABOUT_BUTTON				1036
#define IDC_HPLOGO						1037
#define IDC_HP_STATIC					1038
#define IDC_COPYRIGHT_STATIC			1039
#define IDC_VERSION_STATIC				1040
#define IDC_PRODUCT_STATIC				1041
#define IDC_COMPANY_STATIC				1042
#define IDC_PRODUCTVERSION_STATIC		1043
#define IDC_NOADJUST_RADIO				1044
#define IDC_BASIC_RADIO					1045
#define IDC_OS_VERSION_STATIC			1046
#define IDC_OSVERSION_STATIC			1047

#define REGVAL_OEM_OPTITEM      TEXT("OEMTestOptItem")
#define REGVAL_OEM_PROPSHEET    TEXT("OEMTestPropSheet")
// end of UI additions

//
// Tree view item level
//

#define TVITEM_LEVEL1 1
#define TVITEM_LEVEL2 2

//
// UserData value
//

#define UNKNOWN_ITEM 0
#define PS_INJECTION 1


#endif // !KERNEL_MODE



// Macros used by various modules
#ifdef KERNEL_MODE

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

#endif // KERNEL_MODE

#endif // _INCLUDE_OEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\oemdev.h ===
////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
//Module Name:
//
//    oemdev.h
//
//Abstract:
//
//    OEM DEVMODE
//
//Environment:
//
//    Windows NT printer driver
//
//////////////////////////////////////////////////////////////////

#ifndef _INCLUDE_OEMDEV_H_
#define _INCLUDE_OEMDEV_H_

#ifndef WIN32
#define WIN32
#endif

///////////////////////////////////////////////////////////////////////////
//	Defines
///////////////////////////////////////////////////////////////////////////
//
// VERSION number
//
#define OEM_DEVMODE_VERSION_1_0 0x00010000
#define HELPFILE_NAME_LENGTH    256

//
// Printer Model Defined Constants.
//
// Any new supported printer model needs to be added to this list.
//
#define HP_MODEL_NOT_SUPPORTED		0
#define HP_HPCLJ5					1
#define	HP_HPC4500					2


#ifdef PSCRIPT
//
//	Postscript stuff
//

typedef struct _CMD_INJECTION {
    DWORD dwbSize;
    DWORD dwIndex;
    DWORD loOffset;
} CMD_INJECTION;

#define NUM_OF_PS_INJECTION 5

typedef struct _OEMDEVMODE {
    OEM_DMEXTRAHEADER DMExtraHdr;
    CMD_INJECTION     InjectCmd[NUM_OF_PS_INJECTION];
} OEMDEVMODE, *POEMDEVMODE;

#else

typedef enum _OEMGRAPHICSMODE
{
	// In Raster Graphics Mode, control is sent back to the Unidriver and GDI.
	// In HPGL2 Graphics Mode, all processing is done by the our kernel mode
	// dll.

    HPGL2,
    RASTER,
	RIP
} OEMGRAPHICSMODE;

typedef enum _OEMHALFTONE
{
	// Monarch distinguishes between the Text and Graphics
	// halftones.  So, four different halftones are needed for
	// Monarch.
	// Bedrock + does not distinguish between text and graphics.

	TEXT_DETAIL,		/* Esc*t0J  */	
	TEXT_SMOOTH,		/* Esc*t15J */	
	GRAPHICS_DETAIL,	/* Esc*t15J */
	GRAPHICS_SMOOTH,	/* Esc*t18J */
	CLJ5_DETAIL,		/* Esc*t0J  */
	CLJ5_SMOOTH,		/* Esc*t15J */
	CLJ5_BASIC,	   		/* Esc*t18J */  
	HALFTONE_NOT_SET
}	OEMHALFTONE;

typedef enum _OEMCOLORCONTROL
{
	VIVID,
	SCRNMATCH,
	CLJ5_SCRNMATCH,
	NOADJ,
	COLORCONTROL_NOT_SET
} OEMCOLORCONTROL;

typedef struct _OEMCOLOROPTIONS
{
	OEMHALFTONE Halftone;
	OEMCOLORCONTROL ColorControl;
} OEMCOLOROPTIONS, *POEMCOLOROPTIONS;

typedef enum _OEMRESOLUTION
{
	// Monarch supports both 300 and 600 dpi.  Ideally monarch should only
	// use 600 dpi but for debugging purposes 300 dpi is used as well.

	// Bedrock + supports only 300 dpi.

	PDM_150DPI,
	PDM_300DPI,
	PDM_600DPI,
	PDM_1200DPI
} OEMRESOLUTION;

typedef enum _OEMPAPERTYPE
{
	// All of the following paper types are supported by
	// the Monarch.  Only PLAIN, GLOSSY, and TRANSPARENCY
	// are supported by Bedrock +

	UNSPECIFIED, // Default Paper Type
	PLAIN,
	PREPRINTED,
	LETTERHEAD,
	TRANSPARENCY,
	GLOSSY,
	PREPUNCHED,
	LABELS,
	BOND,
	RECYCLED,
	COLOR,
	HEAVY,
	CARDSTOCK
} OEMPAPERTYPE;

typedef enum _OEMPRINTERMODEL
{
    HPCLJ5,
    HPC4500,
	MODEL_NOT_NEEDED
} OEMPRINTERMODEL;

//
//	Whether or not the document will print in monochrome mode or color.
//
typedef enum _OEMCOLORMODE
{
	MONOCHROME_MODE,
	COLOR_MODE
} OEMCOLORMODE;

typedef struct _OEMDEVMODE
{
	OEM_DMEXTRAHEADER DMExtraHdr;
	BOOL	        DirtyDefaults;
	BOOL	        DirtyColors;
	BOOL	        DirtyOptions;
    BOOL            ColorTreatment; 
    OEMCOLOROPTIONS Text;
	OEMCOLOROPTIONS Graphics;
	OEMCOLOROPTIONS Photos;
	OEMPAPERTYPE	OemPaperType;
	BOOL	        TrueType;
	BOOL	        ListPrinterFonts;
	BOOL	        MetafileSpool;	
	BOOL	        GlossFinish;
    OEMGRAPHICSMODE UIGraphicsMode;
	LONG	        Duplex;
	OEMRESOLUTION   dmResolution;	
	BOOL	        bFastRaster;
    OEMPRINTERMODEL PrinterModel;
	BOOL	        bUpdateTreeview;
	OEMCOLORMODE    eOemColorMode;
    WCHAR           lpwstrHelpFile[HELPFILE_NAME_LENGTH];

} OEMDEVMODE, *POEMDEVMODE;

#endif // PSCRIPT
#endif // _INCLUDE_OEMDEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\clip.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft
// 
// Module Name:
// 
//   clip.c
// 
// Abstract:
// 
//   [Abstract]
//
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   08/06/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

///////////////////////////////////////////////////////////////////////////////
// Local Macros.

///////////////////////////////////////////////////////////////////////////////
// Local function prototypes
static BOOL SelectClipMode(PDEVOBJ, FLONG);


///////////////////////////////////////////////////////////////////////////////
// SelectClipMode()
//
// Routine Description:
// 
//   Specify whether to use zero-winding or odd-even rule for clipping
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   flOptions - FP_WINDINGMODE or FP_ALTERNATEMODE
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectClipMode(PDEVOBJ pDevObj, FLONG flOptions)
{
    BYTE    ClipMode;

    VERBOSE(("Entering SelectClipMode...\n"));

    ASSERT_VALID_PDEVOBJ(pDevObj);

    // REVISIT 1/30/97 AHILL
    // Both the Postscript driver and NT seem to be assuming that clipping
    // is always even-odd rule, no matter what the fill rule.  I can't find
    // any docs to back this up, but it's the only way I can get output to
    // work correctly.  I'll hack for now, and hope we don't regress.  If
    // everything stays OK, I'll clean this routine up a bit.
    //
    //ClipMode = eClipEvenOdd;

    if (flOptions & FP_WINDINGMODE)
    {
        ClipMode = eClipWinding;
    }
    else if (flOptions & FP_ALTERNATEMODE)
    {
        ClipMode = eClipEvenOdd;
    }
    else
    {
        WARNING(("Unknown clip mode: %x\n", flOptions));
        return FALSE;
    }

    VERBOSE(("Exiting SelectClipMode...\n"));

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// SelectClip()
//
// Routine Description:
// 
//   Select the specified path as the clipping path on the printer
//   If this routine is called, it is assumed that the clipping mode should
//   be EvenOdd.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   pco - Specifies the new clipping path
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectClip(PDEVOBJ pDevObj, CLIPOBJ *pco)
{
    BOOL        bRet;

    VERBOSE(("Entering SelectClip...\n"));

    ASSERT_VALID_PDEVOBJ(pDevObj);

    bRet = SelectClipEx(pDevObj, pco, FP_ALTERNATEMODE);

    VERBOSE(("Exiting SelectClip...\n"));

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// SelectClipEx()
//
// Routine Description:
// 
//   Select the specified path as the clipping path on the printer
//
//   The clipping region will either be NULL, or one of the following:
//   1) DC_TRIVIAL: meaning clipping need not be considered, which we
//      interpret as clip-to-imageable-area.
//   2) DC_RECT: the clipping region is a single rectangle.
//   3) DC_COMPLEX: the clipping region is multiple rectangles or a path.
//      If the engine has used this clipping region before, or plans to do
//      so in the future, pco-iUniq is a unique, non-zero number.
//
//   Notes:
//      The ALLOW_DISABLED_CLIPPING flag was something Sandra and I were trying
//      to work out so that she could enable/disable complex clipping (which can
//      take a *really* long time) with a registry setting.  However, it looks 
//      like the EngGetPrinterData call isn't working like I expected, and that
//      wasn't what she wanted anyway. JFF
//
//      The COMPLEX_CLIPPING_REGION flag was just a way for me to think out loud
//      about how I might implement arbitrary clipping if our FW could support it.
//      Rather than have seperate versions of this file--or its routines--I just 
//      used this flag to keep my thoughts from getting compiled in. JFF
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   pco - Specifies the new clipping path
//	 flOptions - fill mode: alternate or winding, see SelectClipMode (nyi)
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
#ifdef ALLOW_DISABLED_CLIPPING
#define COMPLEXCLIPPING (LPWSTR)"ComplexClipping"
#endif

BOOL SelectClipEx(PDEVOBJ pDevObj, CLIPOBJ *pco, FLONG flOptions)
{
    PHPGLSTATE  pState;
    DWORD dwUseComplexClip; // Whether to use complex clipping
    DWORD dwBytesNeeded;    // Just used for GetPrinterData, we'll ignore the value


    VERBOSE(("Entering SelectClipEx...\n"));

    ASSERT_VALID_PDEVOBJ(pDevObj);

    pState = GETHPGLSTATE(pDevObj);

    // If we don't find a complex region the state should reflect that.
    pState->pComplexClipObj = NULL;

#ifdef ALLOW_DISABLED_CLIPPING
    // For now we will use a registry item to control the clipping 
    // so that complex clipping can be turned off (and not make horribly large
    // jobs).
    dwUseComplexClip = 0; // By default don't use complex clipping.
    EngGetPrinterData(pDevObj->hPrinter, 
                      COMPLEXCLIPPING, 
                      NULL, 
                      (PBYTE)&dwUseComplexClip, 
                      sizeof(DWORD), 
                      &dwBytesNeeded);
    if (pco && (pco->iDComplexity == DC_COMPLEX) && !dwUseComplexClip)
    {
        WARNING(("Complex clipping region ignored via registry setting.\n"));
        HPGL_ResetClippingRegion(pDevObj, NORMAL_UPDATE);
        return TRUE;
    }
#endif

    if (pco == NULL)
    {
        HPGL_ResetClippingRegion(pDevObj, NORMAL_UPDATE);
    }
    else
    {
        switch (pco->iDComplexity)
        {
        case DC_TRIVIAL:
            HPGL_ResetClippingRegion(pDevObj, NORMAL_UPDATE);
            break;

        case DC_RECT:
            HPGL_SetClippingRegion(pDevObj, &(pco->rclBounds), NORMAL_UPDATE);
            break;

        case DC_COMPLEX:
            //
            // Set the clipping region to the region that is superset of
            // all clipping regions 
            //
            HPGL_SetClippingRegion(pDevObj, &(pco->rclBounds), NORMAL_UPDATE);

            //
            // Save the clipping region.  We will enumerate the clipping
            // rectangles during SelectOpenPath or SelectClosedPath.
            //
#ifdef COMPLEX_CLIPPING_REGION
            SelectComplexClipRegion(pDevObj, CLIPOBJ_ppoGetPath(pco));
#else
            pState->pComplexClipObj = pco;
#endif
            break;

        default:
            // What should I do here?
            ERR(("Invalid pco->iDComplexity.\n"));
            HPGL_ResetClippingRegion(pDevObj, NORMAL_UPDATE);
            break;
        }
    }

#ifdef COMMENTEDOUT
    // Determine whether we should use zero-winding or odd-even rule
    // for clipping.
    //
    if (! SelectClipMode(pdev, flOptions))
    {
        Error(("Cannot select clip mode\n"));
        return FALSE;
    }

#endif

    VERBOSE(("Exiting SelectClipEx...\n"));

    return TRUE;
}

BOOL SelectComplexClipRegion(PDEVOBJ pDevObj, PATHOBJ *pClipPath)
{
    //
    // If, for some reason, the clip path turns out to be NULL don't 
    // fret.  Just reset the clipping region and return.
    //
    if (pClipPath == NULL)
    {
        HPGL_ResetClippingRegion(pDevObj, NORMAL_UPDATE);
        return TRUE;
    }

    //
    // I assume that the clip region must be a closed path (otherwise 
    // stuff would leak out).
    //

    // At this point what I would do is modify the EvaluateOpenPath and
    // EvaluateClosedPath functions to be "object oriented."  I would
    // create a data structure that held function pointers for:
    // pfnBeginClosedShape
    // pfnBeginClosedSubShape
    // pfnAddPolyPtToShape
    // pfnAddBezierPtToShape
    // pfnEndClosedSubShape
    // pfnEndClosedShape
    //
    // In the case of polylines and polygons these would evaluate to:
    // HPGL_BeginPolygonMode
    // HPGL_BeginSubPolygon
    // HPGL_AddPolyPt
    // HPGL_AddBezierPt
    // HPGL_EndSubPolygon
    // HPGL_EndPolygonMode
    //
    // In the case of a clipping path I would create these functions
    // HPGL_BeginClipRegion
    // HPGL_BeginClipSubRegion
    // HPGL_AddClipPolyPt
    // HPGL_AddClipBezierPt
    // HPGL_EndClipSubRegion
    // HPGL_EndClipRegion
    //
    // Then either function would be able to call EvaluateClosedPath()
    // Note that this also might allow me to combine EvaluateClosedPath
    // and EvaluateOpenPath.

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\brshcach.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    brshcach.h

Abstract:

    Header file for BrushCache

Environment:

    Windows NT Unidriver.

Revision History:

    04/12/99
        Created it.


--*/

#ifndef _BRSHCACH_H_
#define _BRSHCACH_H_

#include "glpdev.h"
#include "rasdata.h"

#ifndef _ERENDERLANGUAGE
#define _ERENDERLANGUAGE
typedef enum { ePCL,
               eHPGL,
               eUNKNOWN
               } ERenderLanguage;
#endif

typedef struct _HPGL2BRUSH {
    BRUSHTYPE       BType;
    DWORD           dwPatternID;
    DWORD           dwRGB;
    DWORD           dwRGBGray64Scale;
    DWORD           dwCheckSum;
    DWORD           dwHatchType;
    BOOL            bDwnlded;   // Whether the pattern has been downloaded.
    ERenderLanguage eDwnldType; // downloaded as HPGL/PCL
    BOOL            bStick;     // If TRUE, this brush wont be replaced by another brush 
} HPGL2BRUSH, *PHPGL2BRUSH;

#define ADD_ARRAY_SIZE 8

class BrushCache
{
public:
    BrushCache::
    BrushCache(VOID);

    BrushCache::
    ~BrushCache(VOID);

    LRESULT
    ReturnPatternID( 
                 IN  BRUSHOBJ  *pbo,
                 IN  ULONG      iHatch,
                 IN  DWORD     dwColor,
                 IN  SURFOBJ   *pso,
                 IN  BOOL       bIsPrinterColor,
                 IN  BOOL       bStick,
                 OUT DWORD     *pdwID,
                 OUT BRUSHTYPE  *pBrushType);

    LRESULT GetHPGL2BRUSH(DWORD dwID, PHPGL2BRUSH pBrush);
    LRESULT Reset(VOID);
    BOOL    BIsValid(VOID);
    BOOL    BSetDownloadType ( DWORD     dwPatternID,
                               ERenderLanguage  eDwnldType);

    BOOL    BGetDownloadType ( DWORD     dwPatternID,
                               ERenderLanguage  *peDwnldType);
                               
    BOOL    BSetDownloadedFlag ( DWORD     dwPatternID,
                                 BOOL      bDownloaded);

    BOOL    BGetDownloadedFlag ( DWORD     dwPatternID,
                                 BOOL      *pbDownloaded);

    BOOL    BSetStickyFlag ( DWORD     dwPatternID,
                             BOOL      bStick);

    BOOL    BGetWhetherRotated ( VOID );
                                 

private:

    BOOL  BIncreaseArray(VOID);
    DWORD DwGetBMPChecksum( SURFOBJ *pso);
    DWORD DwGetInputBPP( SURFOBJ *pso);
    LRESULT AddBrushEntry( PDWORD pdwID,
                           BRUSHTYPE BT,
                           DWORD dwRGB,
                           DWORD dwCheckSum,
                           DWORD dwHatchType);


    DWORD       m_dwCurrentPatternNum;
    DWORD       m_dwMaxPatternArray;
    BOOL        m_bCycleStarted;
    PHPGL2BRUSH m_pPatternArray;
};

#endif // !_BRSHCACH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\clip.h ===
///////////////////////////////////////////////////////////////////////////////
// 
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
// 
//   clip.h
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   08/06/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#ifndef CLIP_H
#define CLIP_H

enum { eClipEvenOdd, eClipWinding };

BOOL SelectClip(PDEVOBJ pDevObj, CLIPOBJ *pco);

BOOL SelectClipEx(PDEVOBJ pDevObj, CLIPOBJ *pco, FLONG flOptions);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\brshcach.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    brshcach.cpp

Abstract:

    Implementation of BrushCache.

Environment:

    Windows NT Unidriver

Revision History:

    04/12/99
        Created it.

--*/

#include "hpgl2col.h" //Precompiled header file

//
// Constructor and Destructor
//

BrushCache::
BrushCache(
    VOID)
/*++

Routine Description:

    Constructor of BrushCache

Arguments:

    None

Return Value:

    None

Note:


--*/
    :m_dwCurrentPatternNum(0),
     m_dwMaxPatternArray(0),
     m_bCycleStarted(FALSE)
{
    if (m_pPatternArray = (PHPGL2BRUSH)MemAllocZ(MAX_PATTERNS * sizeof(HPGL2BRUSH)))
    {
        m_dwMaxPatternArray  = MAX_PATTERNS;
    }
}

BrushCache::
~BrushCache(
    VOID)
/*++

Routine Description:

    Destructor of BrushCache

Arguments:

Return Value:

Note:

--*/
{
    if (m_pPatternArray)
        MemFree(m_pPatternArray);
}

//
// Public functions
//
LRESULT
BrushCache::
ReturnPatternID(
    IN  BRUSHOBJ    *pbo,
    IN  ULONG       iHatch,
    IN  DWORD       dwColor,
    IN  SURFOBJ     *pso,
    IN  BOOL        bIsPrinterColor, 
    IN  BOOL        bStick,
    OUT DWORD       *pdwID,
    OUT BRUSHTYPE   *pBrushType)
/*++

Routine Description:

    Return ID of cached Brush.

Arguments:

    pbo - BRUSHOBJ (in oak\inc\winddi.h)
    iHatch - Hatch brush ID
    dwColor - RGB color
    pso - SURFOBJ
    bStick - whether the information requires to be made non-overwriteable in the cache.
    pdwID - a pointer to ID in DWORD.
    pBrushType 

Return Value:

    S_OK if there is already a cached brush for the pbo.
    S_FALSE if there is no cached brush for the pbo.
    Otherwise return E_UNEXPECTED.

Note:

--*/
{
    LRESULT Ret;

    if ( NULL == pdwID || NULL == pBrushType)
    {
        ERR(("BrushCache.ReturnPatternID failed.\n"));
        return E_UNEXPECTED;
    }

    BRUSHTYPE   BT          = eBrushTypeNULL;
    DWORD       dwRGB       = 0;
    DWORD       dwCheckSum  = 0;
    DWORD       dwHatchType = 0;

    if (NULL == pbo)
    {
        BT = eBrushTypeSolid;
        dwRGB = dwColor & 0x00ffffff;
    }
    else
    {
        //
        // Get BRUSH info from pbo, iHatch, and pxlo
        //
        if (pbo->iSolidColor == 0xFFFFFFFF)
        {
            //
            // Hatch pattern case
            //
            if (iHatch < HS_DDI_MAX)
            {
                BT = eBrushTypeHatch;
                dwHatchType = iHatch;
                dwRGB = dwColor;
            }
            else
            {
                BT = eBrushTypePattern;
                if (pso)
                    dwCheckSum = DwGetBMPChecksum(pso);
                else
                    dwCheckSum = 0;
            }
        }
        else
        {
            BT = eBrushTypeSolid;
            dwRGB = dwColor;
        }
    }

    //
    // Initialize return values
    //
    Ret = E_UNEXPECTED;
    *pdwID = 0xFFFFFFFF;



    PHPGL2BRUSH pPattern = m_pPatternArray;
    //
    // Linearly search through the brush array to find out whether a brush corresponding
    // to dwRGB has already been downloaded.
    // Since the max number of brushes is small ( m_dwMaxPatternArray = MAX_PATTERNS = 8), 
    // a linear search is not too bad.
    // The number 8 is a hardware limitation : Theoretically PCL allows 2^n brushes
    // to be in printers memory, but practically 8 is a good number. Beyond that
    // printer memory overflows.
    //
    DWORD dwRGBGray64Scale = (DWORD)RgbToGray64Scale(dwRGB);
    DWORD dwLastEntry      = m_bCycleStarted ? m_dwMaxPatternArray: m_dwCurrentPatternNum;

    DWORD dwI;
    for (dwI = 0; dwI < dwLastEntry; dwI++, pPattern++)
    {
        if (pPattern->BType == BT && (pPattern->bDwnlded) )
        {
            switch (BT)
            {
            case eBrushTypeSolid:
            case eBrushTypeHatch:
                VERBOSE(("BrushCache.ReturnPatternID: Solid/Hatch Brush.\n"));
                //
                // If a pattern has already been downloaded for the current color,
                // then return that pattern ID. In 24bpp there are 2^24 colors.
                // But the gray scales are only 64. 
                //
                 
                if ( bIsPrinterColor && (pPattern->dwRGB == dwRGB) )
                {
                    Ret = S_OK;
                    *pdwID = dwI;
                    pPattern->dwHatchType = dwHatchType;
                }
                else if ( !bIsPrinterColor && 
                          (pPattern->dwRGBGray64Scale == dwRGBGray64Scale) )
                {
                    Ret = S_OK;
                    *pdwID = dwI;
                    pPattern->dwHatchType = dwHatchType;
                }
                break;
            case eBrushTypePattern:
                if (pPattern->dwCheckSum == dwCheckSum)
                {
                    VERBOSE(("BrushCache.ReturnPatternID: Pattern Brush.\n"));
                    Ret = S_OK;
                    *pdwID = dwI;
                }
                break;
            case eBrushTypeNULL:
                Ret = E_UNEXPECTED;
                *pdwID = 0xFFFFFFFF;
                VERBOSE(("BrushCache.ReturnPatternID: NULL Brush.\n"));
                break;
            }
        }

        if ( Ret == S_OK )
        {
            pPattern->bStick = bStick;
            break;
        }
    }

    //
    // If the above loops runs its full course, it means no brush has been 
    // downloaded that corresponds to the current brush. So we need to 
    // download the brush. The first step to download the brush is to
    // create an entry for that brush in the list of active brushes.
    // The actual task of creating and downloading brush is left to the calling module.
    // module.
    //
    if (dwI == dwLastEntry)
    {
        //
        // Create entry in BrushCache. On return pdwID will contain the
        // brush ID which is the place holder for the new brush.
        //

        if (S_OK == AddBrushEntry(pdwID, BT, dwRGB, dwCheckSum, dwHatchType))
        {
            Ret = S_FALSE;
        }
        else
        {
            ERR(("BrushCache.ReturnPatternID failed.\n"));
        }
    }


#if DBG
    else
    {
        if (Ret != S_OK && Ret != S_FALSE)
            ERR(("BrushCache.ReturnPatternID failed.\n"));
    }
#endif

    if (Ret == S_OK || Ret == S_FALSE)
    {
        //
        // Pattern ID starts from 1.
        //
        (*pdwID) += 1;
        VERBOSE(("BrushCache.ReturnPatternID: New ID=%d.\n", *pdwID));
    }
#if DBG
    else
    {
        ERR(("BrushCache.ReturnPatternID failed.\n"));
    }
#endif

    *pBrushType = BT;
    return Ret;
}

LRESULT
BrushCache::
Reset(
    VOID)
{
    m_dwCurrentPatternNum = 0;
    m_bCycleStarted       = FALSE;
    return S_OK;
}

LRESULT
BrushCache::
GetHPGL2BRUSH(
    DWORD dwID,
    PHPGL2BRUSH pBrush)
/*++

Routine Description:

    Return cached HPGL2BRUSH data structure for the specified ID.

Arguments:

    dwID - ID for cached brush.
    pBrush - a pointer to HPGL2BRUSH, passed by a caller.

Return Value:

    S_OK if there is a cached brush available for the specified ID.
    S_FALSE if there is no cached brush for specified ID.
    E_UNEXPECTED if invalid parameter[s] is passed in.

Note:

--*/

{
    if (NULL == pBrush ||
        NULL == m_pPatternArray ||
        0 == m_dwMaxPatternArray)
    {
        ERR(("BrushCache.GetHPGL2Brush failed.\n"));
        return E_UNEXPECTED;
    }

    //
    // Pattern ID starts from 1. But internally it is stored as 0-based.
    //
    dwID--;

    //
    // There should be no cause for problem, but just to be sure that the dwID is not bogus,
    // lets do some checks.
    // 1) dwID should be less than m_dwCurrentPatternNum. But if m_bCycleStarted is TRUE,
    //    then dwID has to be less than m_dwMaxPatternArray

    
    if (dwID >= (m_bCycleStarted ? m_dwMaxPatternArray: m_dwCurrentPatternNum) )
    {
        ERR(("BrushCache.GetHPGL2Brush failed. dwID=%d, m_dwCur=%d\n", dwID, m_dwCurrentPatternNum));
        return S_FALSE;
    }

    CopyMemory((PVOID)pBrush,
               (PVOID)(m_pPatternArray + dwID),
               sizeof(HPGL2BRUSH));
    return S_OK;
}

BOOL
BrushCache::
BIsValid(VOID)
{
    return (m_pPatternArray ? TRUE : FALSE);
}


BOOL    
BrushCache::BSetDownloadType( DWORD     dwPatternID,
                              ERenderLanguage  eDwnldType)
{

    PHPGL2BRUSH pPattern    = m_pPatternArray;
    DWORD       dwLastEntry = m_bCycleStarted ? m_dwMaxPatternArray: m_dwCurrentPatternNum;

    dwPatternID--; //because internal index is 0-7, external is 1-8 
    if ( (dwPatternID < dwLastEntry) &&
         (pPattern)                  
       )
    {
        pPattern[dwPatternID].eDwnldType = eDwnldType;
        return TRUE;
    }
    return FALSE;
}

BOOL
BrushCache::BGetDownloadType ( DWORD     dwPatternID,
                               ERenderLanguage  *peDwnldType)
{

    PHPGL2BRUSH pPattern    = m_pPatternArray;
    DWORD       dwLastEntry = m_bCycleStarted ? m_dwMaxPatternArray: m_dwCurrentPatternNum;

    dwPatternID--; //because internal index is 0-7, external is 1-8
    if ( (peDwnldType)                &&
         (dwPatternID < dwLastEntry)  &&
         (pPattern)                          
       )
    {
        *peDwnldType = pPattern[dwPatternID].eDwnldType; 
        return TRUE;
    }
    return FALSE;
}

BOOL
BrushCache::BSetDownloadedFlag ( DWORD     dwPatternID,
                                 BOOL      bDownloaded)
{

    PHPGL2BRUSH pPattern    = m_pPatternArray;
    DWORD       dwLastEntry = m_bCycleStarted ? m_dwMaxPatternArray: m_dwCurrentPatternNum;

    dwPatternID--; //because internal index is 0-7, external is 1-8
    if ( (dwPatternID < dwLastEntry)  &&
         (pPattern) 
       )
    {
        pPattern[dwPatternID].bDwnlded = bDownloaded;
        return TRUE;
    }
    return FALSE;
}

BOOL
BrushCache::BGetDownloadedFlag ( DWORD     dwPatternID,
                                 BOOL      *pbDownloaded)
{

    PHPGL2BRUSH pPattern    = m_pPatternArray;
    DWORD       dwLastEntry = m_bCycleStarted ? m_dwMaxPatternArray: m_dwCurrentPatternNum;

    dwPatternID--; //because internal index is 0-7, external is 1-8
    if ( (pbDownloaded)                &&
         (dwPatternID < dwLastEntry)   &&
         (pPattern)             
       )
    {
        *pbDownloaded = pPattern[dwPatternID].bDwnlded;
        return TRUE;
    }
    return FALSE;
}



/*++

Routine Description:
    There is a flag in HPGL2BRUSH called bStick. When this flag is set to TRUE,
    that entry for HPGL2BRUSH in the cache is not overwritten. This flag is used
    by HPGLStrokeAndFillPath to prevent one brush overwriting the other.
    Once HPGLStrokeAndFillPath is done with its work, it calls this function
    to set the flag to FALSE and allow the HPGL2BRUSH to be replaced.

Arguments:
Return Value:
    TRUE if the entry for the dwPatternID can be found in the brush cache. If found it will
         be changed to FALSE.
    FALSE otherwise. 

Author:

Revision History:

--*/
BOOL
BrushCache::BSetStickyFlag ( DWORD     dwPatternID,
                             BOOL      bStick)
{
    PHPGL2BRUSH pPattern    = m_pPatternArray;
    DWORD       dwLastEntry = m_bCycleStarted ? m_dwMaxPatternArray: m_dwCurrentPatternNum;

    dwPatternID--; //because internal index is 0-7, external is 1-8
    if ( (dwPatternID < dwLastEntry)   &&
         (pPattern)
       )
    {
        pPattern[dwPatternID].bStick = bStick;
        return TRUE;
    }
    return FALSE;
}

BOOL    
BrushCache::BGetWhetherRotated ( VOID )
{
    return m_bCycleStarted;
}


//
// Private functions
//

LRESULT
BrushCache::
AddBrushEntry(
    PDWORD pdwID,
    BRUSHTYPE BT,
    DWORD dwRGB,
    DWORD dwCheckSum,
    DWORD dwHatchType)
/*++

Routine Description:

   Add new entry in the brush cache.

Arguments:

    pdwID - a pointer to a cached brush in DWORD>
    BT - BrushType
    dwRGB - DWORD RGB value.
    dwCheckSum - a pattern bitmap checksum in DWORD.
    dwHatchType - a hatch type iD.

Return Value:

    S_OK if it succeeded in adding new entry.
    Otherwise returns E_UNEXPECTED;

Note:

--*/
{
    LRESULT Ret;

    if (NULL == pdwID)
    {
        ERR(("BrushCache.AddBrushEntry failed.\n"));
        return E_UNEXPECTED;
    }

    if (m_dwCurrentPatternNum < m_dwMaxPatternArray ||
        BIncreaseArray())
    {
        PHPGL2BRUSH pPatternArray;

        //
        // Pattern ID is 1 base.
        //
        *pdwID = m_dwCurrentPatternNum;
        pPatternArray                   = m_pPatternArray + m_dwCurrentPatternNum++;
        if ( pPatternArray->bStick )
        {
            //
            // bStick means this entry should not be overwritten.
            // So lets skip this entry and go to next one.
            //
            if ( m_dwCurrentPatternNum == m_dwMaxPatternArray )
            {
                //
                // If after adding the entry, the whole pattern arrays is
                // filled up, the next entry should be done at the begining of the array.
                //
                m_dwCurrentPatternNum = 0;
                m_bCycleStarted       = TRUE;
            }

            *pdwID = m_dwCurrentPatternNum;
            pPatternArray = m_pPatternArray + m_dwCurrentPatternNum++;
        }
        pPatternArray->BType            = BT;
        pPatternArray->dwPatternID      = *pdwID + 1;
        pPatternArray->dwRGB            = dwRGB;
        pPatternArray->dwRGBGray64Scale = (DWORD) RgbToGray64Scale(dwRGB);
        pPatternArray->dwCheckSum       = dwCheckSum;
        pPatternArray->dwHatchType      = dwHatchType;
        pPatternArray->bDwnlded         = FALSE;
        pPatternArray->eDwnldType       = eUNKNOWN;
        pPatternArray->bStick           = FALSE;

        //
        // If after adding the entry, the whole pattern arrays is
        // filled up, the next entry should be done at the begining of the array.
        //
        if ( m_dwCurrentPatternNum == m_dwMaxPatternArray )
        {
            m_dwCurrentPatternNum = 0;
            m_bCycleStarted       = TRUE;
        }

        Ret = S_OK;
    }
    else
    {
        Ret = E_UNEXPECTED;
        ERR(("BrushCache.AddBrushEntry failed.\n"));
    }

    return Ret;
}

//
// 32 bit ANSI X3.66 CRC checksum table - polynomial 0xedb88320
//
// Copyright (C) 1986 Gary S. Brown.  You may use this program, or
// code or tables extracted from it, as desired without restriction.
//

static const UINT32 Crc32Table[] =
{
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

DWORD
BrushCache::
DwGetBMPChecksum(
    SURFOBJ *pso)
/*++

Routine Description:

    Return the bitmap checksum for the bitmap in pso.

Arguments:

   pso - a pointer to SURFOBJ

Return Value:

   Checksum in DWORD.
   If it failed, it would return 0.

Note:

--*/
{
    DWORD dwChecksum, dwcbScanlineSize, dwI;
    LONG  lHeight, lWidth, lDelta;
    INT   iFormat = pso->iBitmapFormat;

    if (NULL == pso)
    {
        ERR(("BrushCache.DwGetBMPChecksum failed.\n"));
        return 0;
    }

    lWidth  = pso->sizlBitmap.cx;
    lHeight = pso->sizlBitmap.cy;
    lDelta  = pso->lDelta;

    const BYTE* pubData = (const BYTE*) pso->pvScan0;


    dwcbScanlineSize = (DwGetInputBPP(pso) * lWidth + 7) / 8;

    while (lHeight -- > 0)
    {
        for (dwI = 0; dwI < dwcbScanlineSize; dwI ++)
        {
            BYTE ubData = *(pubData + dwI);

            dwChecksum = Crc32Table[(dwChecksum ^ ubData) & 0xff] ^ (dwChecksum >> 8);
        }
        pubData += lDelta;
    }

    return dwChecksum;
}

DWORD
BrushCache::
DwGetInputBPP(
    SURFOBJ *pso)
/*++

Routine Description:

    Return Bits Per Pixel of pso.

Arguments:

    pso - a pointer to SURFOBJ

Return Value:

    Bits Per Pixel.

Note:

--*/
{
    DWORD dwRet;

    if (NULL == pso)
    {
        ERR(("BrushCache.DwGetInputBPP failed.\n"));
        return 0;
    }

    switch (pso->iBitmapFormat) {

    case BMF_1BPP:

        dwRet = 1;
        break;

    case BMF_4BPP:
    case BMF_4RLE:

        dwRet = 4;
        break;

    case BMF_8BPP:
    case BMF_8RLE:

        dwRet = 8;
        break;

    case BMF_16BPP:

        dwRet = 16;
        break;

    case BMF_24BPP:

        dwRet = 24;
        break;

    case BMF_32BPP:

        dwRet = 32;
        break;

    default:

        //
        // Unknown bitmap format
        //

        // WARNING(("Unknown input bmp format: %d\n", pso->iBitmapFormat));
        dwRet = 0;
        break;
    }

    return dwRet;

}

BOOL
BrushCache::
BIncreaseArray(
    VOID)
/*++

Routine Description:

    Increate buffer for brush caching.

Arguments:

    None

Return Value:

   TRUE, if succeeded, otherwise FALSE.

Note:

--*/
{
    BOOL bRet = FALSE;

    if( NULL != m_pPatternArray &&
        0 != m_dwMaxPatternArray &&
        m_dwMaxPatternArray + ADD_ARRAY_SIZE <= 32767)
    {
        PHPGL2BRUSH pBrush;
        if (pBrush = (PHPGL2BRUSH)MemAlloc(sizeof(HPGL2BRUSH) * (ADD_ARRAY_SIZE + m_dwMaxPatternArray)))
        {
            CopyMemory((PVOID)pBrush,
                       (PVOID)m_pPatternArray,
                       sizeof(HPGL2BRUSH) * m_dwMaxPatternArray);
            MemFree(m_pPatternArray);
            m_pPatternArray = pBrush;
            m_dwMaxPatternArray += ADD_ARRAY_SIZE;
            bRet = TRUE;
        }
    }

#if DBG
    if (!bRet)
        ERR(("BrushCache.BIncreaseArray failed.\n"));
#endif

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\clrsmart.h ===
/*******************************************************************************
 *
 *		clrsmart.h:
 *	
 *		Header file for clrsmart.c
 *
 *------------------------------------------------------------------------------
 *
 *		Allows acces to set ColorSmart settings through the function:
 *
 *					SetColorSmartSettings(<GraphicsMode>)
 *
// $History: clrsmart.h $
// 
// *****************  Version 9  *****************
// User: Sawhite      Date: 9/16/98    Time: 2:21p
// Updated in $/projects/Tsunami/Source/Render
// 
// *****************  Version 8  *****************
// User: Apacella     Date: 6/25/98    Time: 2:34p
// Updated in $/projects/Tsunami/Source/Render
// Jim's new source.
// 
// *****************  Version 7  *****************
// User: Jffordem     Date: 5/06/98    Time: 5:33p
// Updated in $/projects/Tsunami/Source/Render
// Fixing long filename problem.
// 
// *****************  Version 6  *****************
// User: Sandram      Date: 3/19/98    Time: 6:17p
// Updated in $/projects/Tsunami/Source/Render
// Modified function parameters.
// 
// *****************  Version 5  *****************
// User: Sandram      Date: 3/16/98    Time: 2:45p
// Updated in $/projects/Tsunami/Source/Render
// Documentation
// 
// *****************  Version 4  *****************
// User: Sandram      Date: 2/19/98    Time: 3:40p
// Updated in $/projects/Tsunami/Source/Render
// enhanced CID Palette management.
// 
// *****************  Version 3  *****************
// User: Sandram      Date: 2/10/98    Time: 4:03p
// Updated in $/projects/Tsunami/Source/Render
// added Text palette management commands.
// 
// *****************  Version 2  *****************
// User: Sandram      Date: 1/27/98    Time: 4:54p
// Updated in $/projects/Tsunami/Source/Render
// Added initial support for text CID commands.
 *******************************************************************************/

#ifndef _COLORSMART_H
#define _COLORSMART_H

#include "glpdev.h"

//
// function prototypes
//
void
VSendTextSettings(
    PDEVOBJ pDevObj
    );

void SendGraphicsSettings(
    PDEVOBJ pDevObj
    );

void
VSendPhotosSettings(
    PDEVOBJ pDevObj
    );

BOOL 
BSendCIDCommand (
    PDEVOBJ pDevObj,
    CIDSHORT CIDData,
    ECIDFormat CIDFormat
    );

VOID
VSetupCIDPaletteCommand (
    PDEVOBJ      pDevObj,
    ECIDPalette  eCID_PALETTE,
    EColorSpace  eColorSpace,
    ULONG        ulBmpFormat
    );

VOID
VSelectCIDPaletteCommand (
    PDEVOBJ pDevObj,
    ECIDPalette  eCID_PALETTE
    );

ECIDPalette
EGetCIDPrinterPalette (
    ULONG   iBitmapFormat
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\clrsmart.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation
All Rights Reserved.

Module Name:
    clrsmart.cpp

Abstract:
    This module contains functions for choosing the appropriate Halftone Algorithm
    and Color Control.

Author:

Revision History:


--*/

#include "hpgl2col.h" //Precompiled header file


#define CMD_STR  32
//
// Local function prototypes
//
VOID
VSetHalftone(
    PDEVOBJ pDevObj,
    EObjectType
    );

VOID
VSetColorControl(
    OEMCOLORCONTROL,
    PDEVOBJ pDevObj,
    OEMCOLORCONTROL *
    );

/////////////////////////////////////////////////////////////////////////////
// VSendTextSettings
//
// Routine Description:
//
//  -  Extracts the User and Kernel mode private devmode from pDevObj.
//  -  Uses this information to send ColorSmart Settings.
//  -  SetHalfone and SetColorControl functions are called to perform the
//     sending of the PCL strings.
//
// Arguments:
//
//   pDevObj - DEVMODE object
//
// Return Value:
//
//   none.
/////////////////////////////////////////////////////////////////////////////
VOID
VSendTextSettings(
    PDEVOBJ pDevObj
    )
{
    REQUIRE_VALID_DATA( pDevObj, return );

    //
    // For monochrome, this does nothing. so simply return.
    //
    if ( !BIsColorPrinter(pDevObj) )
    {
        return ;
    }

    POEMPDEV pOEMPDEV = (POEMPDEV) pDevObj->pdevOEM;

    REQUIRE_VALID_DATA( pOEMPDEV, return );

    VSetHalftone(pDevObj,
                eTEXTOBJECT);

}

/////////////////////////////////////////////////////////////////////////////
// VSendGraphicsSettings
//
// Routine Description:
//
//  -  Extracts the User and Kernel mode private devmode from pDevObj.
//  -  Uses this information to send ColorSmart Settings.
//  -  SetHalfone and SetColorControl functions are called to perform the
//     sending of the PCL strings.
//
// Arguments:
//
//   pDevObj - DEVMODE object
//
// Return Value:
//
//   none.
/////////////////////////////////////////////////////////////////////////////
VOID
SendGraphicsSettings(
    PDEVOBJ pDevObj
    )
{

    REQUIRE_VALID_DATA( pDevObj, return );

    POEMPDEV pOEMPDEV = (POEMPDEV) pDevObj->pdevOEM;

    REQUIRE_VALID_DATA( pOEMPDEV, return );

    VSetHalftone(
                pDevObj,
                eHPGLOBJECT);

}

/////////////////////////////////////////////////////////////////////////////
// VSendPhotosSettings
//
// Routine Description:
//
//  -  Extracts the User and Kernel mode private devmode from pDevObj.
//  -  Uses this information to send ColorSmart Settings.
//  -  SetHalfone and SetColorControl functions are called to perform the
//     sending of the PCL strings.
//
// Arguments:
//
//   pDevObj - DEVMODE object
//
// Return Value:
//
//   none.
/////////////////////////////////////////////////////////////////////////////
VOID
VSendPhotosSettings(
    PDEVOBJ pDevObj
    )
{

    REQUIRE_VALID_DATA( pDevObj, return );

    //
    // For monochrome, this does nothing. so simply return.
    //
    if ( !BIsColorPrinter(pDevObj) )
    {
        return ;
    }

    POEMPDEV pOEMPDEV = (POEMPDEV) pDevObj->pdevOEM;

    REQUIRE_VALID_DATA( pOEMPDEV, return );

    VSetHalftone(
                pDevObj,
                eRASTEROBJECT);

}

/////////////////////////////////////////////////////////////////////////////
//
//     SetHalftone(OEMHALFTONE, PDEVOBJ, OEMHALFTONE)
//
//     -  Checks whether or not the current halftone settings are the same as the
//        previous halftone settings.  If they are the same,  nothing is to be done.
//        If they are not the same,  the correct PCL string is sent to the printer
//        and the current halftone settings become the old halftone settings.
//
/////////////////////////////////////////////////////////////////////////////
void
VSetHalftone(
    PDEVOBJ pDevObj,
    EObjectType eObject
    )
{
    REQUIRE_VALID_DATA( pDevObj, return );


#ifdef PLUGIN
    POEMPDEV    poempdev;
    char        cmdStr[CMD_STR];
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return );

    if (Halftone == *pCurHalftone)
        return;
    else
    {
        switch (Halftone)
        {
        case TEXT_DETAIL:
        case CLJ5_DETAIL:
            strcpy(cmdStr, "\x1B*t0J");
            break;
        case GRAPHICS_DETAIL:
        case TEXT_SMOOTH:
        case CLJ5_SMOOTH:
            strcpy(cmdStr, "\x1B*t15J");
            break;
        case GRAPHICS_SMOOTH:
        case CLJ5_BASIC:
            strcpy(cmdStr, "\x1B*t18J");
            break;
        default:
            strcpy(cmdStr, "\x1B*t15J");
        }

        PCL_Output(pDevObj, cmdStr, strlen(cmdStr));
        *pCurHalftone = Halftone;
    }
#else

    PDEV        *pPDev = (PDEV *)pDevObj;
    COMMAND     *pCmd  = NULL;

    switch (eObject)
    {
    case eTEXTOBJECT:
    case eTEXTASRASTEROBJECT:
        if ( (pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SETTEXTHTALGO)) )
        {
            WriteChannel (pPDev, pCmd);
        }
        break;
    case eHPGLOBJECT:
        if  ( (pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SETGRAPHICSHTALGO)) )
        {
            WriteChannel (pPDev, pCmd);
        }
        break;
    case eRASTEROBJECT:
    case eRASTERPATTERNOBJECT:
        if ( (pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SETPHOTOHTALGO)) )
        {
            WriteChannel (pPDev, pCmd);
        }
        break;
    default:
        if ( (pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SETPHOTOHTALGO)) )
        {
            WriteChannel (pPDev, pCmd);
        }

    }
#endif
}

///////////////////////////////////////////////////////////////////////////////
//
//     SetColorControl(OEMHALFTONE, PDEVOBJ, OEMHALFTONE)
//
//     -  Checks whether or not the current Color Control settings are the same as the
//        previous Color Control settings.  If they are the same,  nothing is to be done.
//        If they are not the same,  the correct PCL string is sent to the printer
//        and the current Color Control settings become the old Color Control settings.
//
///////////////////////////////////////////////////////////////////////////////
void
VSetColorControl(
    OEMCOLORCONTROL ColorControl,
    PDEVOBJ pDevObj,
    OEMCOLORCONTROL *pCurColorControl
)
{
    REQUIRE_VALID_DATA( pDevObj, return );
    REQUIRE_VALID_DATA( pCurColorControl, return );

    BYTE cmdStr[CMD_STR];
    INT  icchWritten = 0;

    if (ColorControl == *pCurColorControl)
        return;
    else
    {
        switch (ColorControl)
        {
        case VIVID:
            icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033*o3W%c%c%c", 6,4,3);
            break;
        case SCRNMATCH:
            icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033*o3W%c%c%c", 6,4,6);
            break;
        case CLJ5_SCRNMATCH:
        case NOADJ:
            icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033*o3W%c%c%c", 6,4,0);
            break;
        default:
            icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033*o3W%c%c%c", 6,4,0);
            break;
        }

        if ( icchWritten > 0 )
        {
                PCL_Output(pDevObj, cmdStr, (ULONG)icchWritten);
                *pCurColorControl = ColorControl;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// SendCIDCommand
//
// Routine Description:
//
//    Creates a PCL Configure Image Command and sends to the port. Generally,
//    this is done once for each palette at the beginning of the job.
//
// Notes:
//
//    Don't need CIDFormat - assume always short for now.
//    If a long form is needed, write SendCIDCommandEx (?) or SendCIDCommandLong
//
// Arguments:
//
//   pDevObj - DEVMODE object
//   CIDData - configure image data - matches PCL format
//
// Return Value:
//
//   TRUE if the output succeeded, FALSE otherwise
/////////////////////////////////////////////////////////////////////////////
BOOL SendCIDCommand (
    PDEVOBJ pDevObj,
    CIDSHORT CIDData,
    ECIDFormat CIDFormat
    )
{
    REQUIRE_VALID_DATA( pDevObj, return FALSE );

    BYTE cmdStr[CMD_STR];
    INT icchWritten = 0;

    icchWritten =  iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033*v6W%c%c%c%c%c%c",
                   CIDData.ubColorSpace,
                   CIDData.ubPixelEncodingMode,
                   CIDData.ubBitsPerIndex,
                   CIDData.ubPrimary1,
                   CIDData.ubPrimary2,
                   CIDData.ubPrimary3 );

    if ( icchWritten > 0)
    {
        PCL_Output(pDevObj, cmdStr, (ULONG)icchWritten);
        return TRUE;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// SetupCIDPaletteCommand
//
// Routine Description:
//
//    Creates a PCL Configure Image Command and sends to the port. Generally,
//    this is done once for each palette at the beginning of the job.
//
// Arguments:
//
//   pDevObj - DEVMODE object
//   eCID_PALETTE -
//   eColorSpace -
//   ulBmpFormat - BMF_* defined in DDK.
//
// Return Value:
//
//   nothing.
/////////////////////////////////////////////////////////////////////////////
VOID
VSetupCIDPaletteCommand (
    PDEVOBJ      pDevObj,
    ECIDPalette  eCID_PALETTE,
    EColorSpace  eColorSpace,
    ULONG        ulBmpFormat
    )
{
    CIDSHORT CIDData;
    BYTE     cmdStr[CMD_STR];
    INT      icchWritten = 0;

    REQUIRE_VALID_DATA( pDevObj, return );

    //
    // For monochrome, this does nothing. so simply return.
    //
    if ( !BIsColorPrinter(pDevObj) )
    {
        return ;
    }

    //
    // first load the information into our internal CID data structure,
    // which is used to send the CID command to the printer
    //
    switch (ulBmpFormat)
    {
    case BMF_1BPP:
        CIDData.ubColorSpace = eColorSpace;
        CIDData.ubPixelEncodingMode = 1;
        CIDData.ubBitsPerIndex = 1;
        break;
    case BMF_4BPP:
        CIDData.ubColorSpace = eColorSpace;
        CIDData.ubPixelEncodingMode = 1;
        CIDData.ubBitsPerIndex = 4;
        break;
    case BMF_8BPP:
        CIDData.ubColorSpace = eColorSpace;
        CIDData.ubPixelEncodingMode = 1;
        CIDData.ubBitsPerIndex = 8;
        break;
    case BMF_16BPP:
    case BMF_24BPP:
    case BMF_32BPP:
        CIDData.ubColorSpace = eColorSpace;
        CIDData.ubPixelEncodingMode = 3;
        CIDData.ubBitsPerIndex = 8;
        break;
    default:
        break;
    }
    CIDData.ubPrimary1 = 8;
    CIDData.ubPrimary2 = 8;
    CIDData.ubPrimary3 = 8;

    //
    // send the command to select the appropriate palette to the printer
    // using the CIDData
    //
    switch (eCID_PALETTE)
    {
    case eTEXT_CID_PALETTE:

        CIDData.ubColorSpace = eColorSpace;
        CIDData.ubPixelEncodingMode = 1;
        CIDData.ubBitsPerIndex = 8;

        icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033&p%di6c%dS",
                       eTEXT_CID_PALETTE,
                       eTEXT_CID_PALETTE);
        break;

    case eRASTER_CID_24BIT_PALETTE:

        icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033&p%di6c%dS",
                       eRASTER_CID_24BIT_PALETTE,
                       eRASTER_CID_24BIT_PALETTE);
        break;

    case eRASTER_CID_8BIT_PALETTE:

        icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033&p%di6c%dS",
                       eRASTER_CID_8BIT_PALETTE,
                       eRASTER_CID_8BIT_PALETTE);
        break;

    case eRASTER_CID_4BIT_PALETTE:

        icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033&p%di6c%dS",
                       eRASTER_CID_4BIT_PALETTE,
                       eRASTER_CID_4BIT_PALETTE);
        break;

    case eRASTER_CID_1BIT_PALETTE:

        icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033&p%di6c%dS",
                       eRASTER_CID_1BIT_PALETTE,
                       eRASTER_CID_1BIT_PALETTE);
        break;

    default:
        icchWritten = 0;
        break;
    }

    if ( icchWritten > 0 )
    {
        PCL_Output(pDevObj, cmdStr, (ULONG)icchWritten);
        SendCIDCommand (pDevObj, CIDData, eSHORTFORM);
    }

}

/////////////////////////////////////////////////////////////////////////////
// VSelectCIDPaletteCommand
//
// Routine Description:
//
//   Selects the palette which corresponds with the given palette type.
//   This type is a little finer-grained than the object type since the
//   raster objects can have different palettes.
//
// Arguments:
//
//   pDevObj - DEVMODE object
//   eCID_PALETTE - the palette to select
//
// Return Value:
//
//   none.
/////////////////////////////////////////////////////////////////////////////
VOID
VSelectCIDPaletteCommand (
    PDEVOBJ pDevObj,
    ECIDPalette  eCID_PALETTE
    )
{
    POEMPDEV    poempdev;
    BYTE cmdStr[CMD_STR];
    INT     icchWritten = 0;
    EObjectType eNewObjectType;

    REQUIRE_VALID_DATA( pDevObj, return );


    //
    // For monochrome, this does nothing. so simply return.
    //
    if ( !BIsColorPrinter(pDevObj) )
    {
        return ;
    }

    ASSERT(VALID_PDEVOBJ(pDevObj));
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return );

    if (poempdev->eCurCIDPalette != eCID_PALETTE)
    {
        //
        // select the palette
        //

        icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "\033&p%dS", eCID_PALETTE );

        if ( icchWritten > 0 )
        {
            PCL_Output(pDevObj, cmdStr, (ULONG)icchWritten);
        }

        poempdev->eCurCIDPalette = eCID_PALETTE;
        switch (eCID_PALETTE)
        {
            case eHPGL_CID_PALETTE:
                eNewObjectType = eHPGLOBJECT;
                break;

            case eTEXT_CID_PALETTE:
                eNewObjectType = eTEXTOBJECT;
                break;

            case eRASTER_CID_24BIT_PALETTE:
            case eRASTER_CID_8BIT_PALETTE:
            case eRASTER_CID_4BIT_PALETTE:
            case eRASTER_CID_1BIT_PALETTE:
                eNewObjectType = eRASTEROBJECT;
                break;
            case eRASTER_PATTERN_CID_PALETTE:
                eNewObjectType = eRASTERPATTERNOBJECT;
                break;

            default:
                WARNING(("Unrecognized CID Palette\n"));
                eNewObjectType = poempdev->eCurObjectType;
        }

        //
        // Whenever you change objects invalidate the fg color so that it
        // gets reset. JFF
        //
        if (poempdev->eCurObjectType != eNewObjectType)
        {
            poempdev->uCurFgColor = HPGL_INVALID_COLOR;
            poempdev->eCurObjectType = eNewObjectType;
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\cmdcb.cpp ===
/*++

Copyright (c) 1999-2001 Microsoft

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "hpgl2col.h" //Precompiled header file

//
// command callback ID's for "test.gpd"
//
#define CMDCB_SELECTPORTRAIT    1
#define CMDCB_SELECTLANDSCAPE   2
#define CMDCB_SENDBLOCKDATA     3


/////////////////////////////////////////////////////////////////////////////
// iDwtoA
//
// Routine Description:
//
//  Converts a numeric string to a number.
//
// Arguments:
//
//   buf - string containing number
//   n - probably the radix
//
// Return Value:
//
//   int - the number
/////////////////////////////////////////////////////////////////////////////
static  int
iDwtoA( LPSTR buf, DWORD n )
{
    int     i, j;

    for( i = 0; n; i++ )
    {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ )
    {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}


/////////////////////////////////////////////////////////////////////////////
// HPGLCommandCallback
//
// Routine Description:
//
//  Handles the DrvCommandCallback function.
//
// Arguments:
//
//   pdevobj - the device
//   dwCmdCbID - the command
//   dwCount - probably the number of params in pdwParams
//   pdwParams - command params
//
// Return Value:
//
//   INT - 0 if successful?
/////////////////////////////////////////////////////////////////////////////
INT APIENTRY HPGLCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    TERSE(("HPGLCommandCallback() entry.\r\n"));
	
    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));
	
    //
    // fill in printer commands
    //
    switch (dwCmdCbID)
    {
    case CMDCB_SELECTPORTRAIT:
        OEMWriteSpoolBuf(pdevobj, "\x1B&l0O", 5);
        break;
		
    case CMDCB_SELECTLANDSCAPE:
        OEMWriteSpoolBuf(pdevobj, "\x1B&l1O", 5);
        break;
		
    case CMDCB_SENDBLOCKDATA:
		{
			//
			// this command requires one parameter. Compose the string first.
			//
			BYTE    abSBDCmd[16];
			INT     i = 0;
			
			if (dwCount < 1 || !pdwParams)
				return 0;       // cannot do anything
			
			abSBDCmd[i++] = '\x1B';
			abSBDCmd[i++] = '*';
			abSBDCmd[i++] = 'b';
			i += iDwtoA((LPSTR) (abSBDCmd + i), *pdwParams);
			abSBDCmd[i++] = 'W';
			
			OEMWriteSpoolBuf(pdevobj, abSBDCmd, i);
			
			break;
		}
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\compress.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.

Module Name:

    compress.c

Abstract:

    Implementation of compression formats for sending data to devices.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created

--*/

#include "hpgl2col.h" //Precompiled header file

//*************************************************************
int
iCompTIFF( 
    BYTE *pbOBuf,
    ULONG ulOutBufSize,
    const BYTE *pbIBuf, 
    int  iBCnt 
    )
/*++

Routine Description:
    
    This function is called to compress a scan line of data using
    TIFF v4 compression.

Arguments:

    pbOBuf      Pointer to output buffer  
    ulOutBufSize Size of output buffer pointed to by pbOBuf,
    pbIBuf      Pointer to data buffer to compress
    iBCnt       Number of bytes to compress

Return Value:

    Number of compressed bytes
    
Note:
    The output buffer is presumed large enough to hold the output.
    In the worst case (NO REPETITIONS IN DATA) there is an extra
    byte added every 128 bytes of input data.  So, you should make
    the output buffer at least 1% larger than the input buffer.

--*/
{
    BYTE   *pbOut;        /* Output byte location */
    const BYTE *pbStart = pbIBuf;      /* Start of current input stream */
    const BYTE *pb;           /* Miscellaneous usage */
    BYTE *pbEnd;        /* The last byte of input */
    BYTE    jLast;        /* Last byte,  for match purposes */
    BYTE   bLast;

    int     iSize;        /* Bytes in the current length */
    int     iSend;        /* Number to send in this command */
    

    //
    // According to the comment above, the output
    // buffer should be at least 1% larger than the input buffer.
    // But to put some margin, i'll make sure that it is 3% bigger.
    // iBCnt >> 5 = iBCnt/32 = 3.125%. And add 1 to make sure it is atleast 
    // 1 byte bigger (in case iBCnt is less than 32 bytes).
    // I could also have made validations within the algorithm below, 
    // but that might make it slow and may introduce regression.
    //
    if ( NULL == pbOBuf ||
         NULL == pbIBuf ||
         iBCnt < 0      ||
         ulOutBufSize < (ULONG)(iBCnt + 1 + (iBCnt >> 5))
       )
    {
        return -1;
    }

    pbOut = pbOBuf;
    //pbStart = pbIBuf;
    pbEnd = (BYTE*)pbIBuf + iBCnt;         /* The last byte */
    
#if (TIFF_MIN_RUN >= 4)
    // this is a faster algorithm for calculating TIFF compression
    // that assumes a minimum RUN of at least 4 bytes. If the 
    // third and fourth byte don't equal then the first/second bytes are
    // irrelevant. This means we can determine non-run data three times
    // as fast since we only check every third byte pair.
    
   if (iBCnt > TIFF_MIN_RUN)
   {
    // make sure the last two bytes aren't equal so we don't have to check
    // for the buffer end when looking for runs
    bLast = pbEnd[-1];
    pbEnd[-1] = ~pbEnd[-2];
    while( (pbIBuf += 3) < pbEnd )
    {
        if (*pbIBuf == pbIBuf[-1])
        {
            // save the run start pointer, pb, and check whether the first 
            // bytes are also part of the run
            // 
            pb = pbIBuf-1;
            if (*pbIBuf == pbIBuf[-2])
            {
                pb--;
                if (*pbIBuf == pbIBuf[-3])
                    pb--;
            }

            //  Find out how long this run is
            jLast = *pb;
            do {
                pbIBuf++;
            } while (*pbIBuf == jLast);
            
            // test whether last byte is also part of the run
            //
            if (jLast == bLast && pbIBuf == (pbEnd-1))
                pbIBuf++;            
                
            // Determine if the run is longer that the required
            // minimum run size.
            //
            if ((iSend = (int)(pbIBuf - pb)) >= (TIFF_MIN_RUN))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = (int)(pb - pbStart)) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        iSize -= TIFF_MAX_LITERAL;
                        *pbOut++ = TIFF_MAX_LITERAL-1;
                        CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                        pbStart += TIFF_MAX_LITERAL;
                        pbOut += TIFF_MAX_LITERAL;
                    }
                    *pbOut++ = iSize - 1;
                    CopyMemory(pbOut, pbStart, iSize);
                    pbOut += iSize;
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */
                iSize = iSend;
                while (iSize > TIFF_MAX_RUN)
                {
                    char *ptr = (char *)pbOut;
                    *ptr = 1 - TIFF_MAX_RUN;
                    pbOut++;

                    *pbOut++ = jLast;
                    iSize -= TIFF_MAX_RUN;
                }
                *pbOut++ = 1 - iSize;
                *pbOut++ = jLast;                

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
        }
    }
    pbEnd[-1] = bLast;
   }
#else
    jLast = *pbIBuf++;

    while( pbIBuf < pbEnd )
    {
        if( jLast == *pbIBuf )
        {
            /*  Find out how long this run is.  Then decide on using it */
            pb = pbIBuf;
            do {
                pbIBuf++;
            } while (pbIBuf < pbEnd && *pbIBuf == jLast);

            /*
             *  Note that pb points at the SECOND byte of the pattern!
             *  AND also that pbIBuf points at the first byte AFTER the run.
             */

            if ((iSend = pbIBuf - pb) >= (TIFF_MIN_RUN - 1))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = pb - pbStart - 1) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        iSize -= TIFF_MAX_LITERAL;
                        *pbOut++ = TIFF_MAX_LITERAL-1;
                        CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                        pbStart += TIFF_MAX_LITERAL;
                        pbOut += TIFF_MAX_LITERAL;
                    }
                    *pbOut++ = iSize - 1;
                    CopyMemory(pbOut, pbStart, iSize);
                    pbOut += iSize;
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */

                iSize = iSend + 1;
                while (iSize > TIFF_MAX_RUN)
                {
                    *((char *)pbOut)++ = 1 - TIFF_MAX_RUN;
                    *pbOut++ = jLast;
                    iSize -= TIFF_MAX_RUN;
                }
                *pbOut++ = 1 - iSize;
                *pbOut++ = jLast;                

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
            if (pbIBuf == pbEnd)
                break;
        }

        jLast = *pbIBuf++;                   /* Onto the next byte */
 
    }
#endif    

    if ((iSize = (int)(pbEnd - pbStart)) > 0)
    {
        /*  Left some dangling.  This can only be literal data.   */

        while( (iSend = min( iSize, TIFF_MAX_LITERAL )) > 0 )
        {
            *pbOut++ = iSend - 1;
            CopyMemory( pbOut, pbStart, iSend );
            pbOut += iSend;
            pbStart += iSend;
            iSize -= iSend;
        }
    }

    return  (int)(pbOut - pbOBuf);
}
//**********************************************************
int
iCompFERLE( 
    BYTE *pbOBuf, 
    BYTE *pbIBuf, 
    int  iBCnt,
    int  iMaxCnt
    )
/*++

Routine Description:
    
    This function is called to compress a scan line of data using
    Far East Run length encoding.

Arguments:

    pbOBuf      Pointer to output buffer  PRESUMED LARGE ENOUGH
    pbIBuf      Pointer to data buffer to compress
    iBCnt       Number of bytes to compress
    iMaxCnt     Maximum number of bytes to create on output

Return Value:

    Number of compressed bytes or -1 if too large for buffer
    
--*/
{
    BYTE *pbO;         /* Record output location */
    BYTE *pbI;          /* Scanning for runs */
    BYTE *pbIEnd;      /* First byte past end of input data */
    BYTE *pbStart;     /* Start of current data stream */
    BYTE *pbTmp;
    BYTE  jLast;       /* Previous byte */

    int     iSize;       /* Number of bytes in the run */

    if (iBCnt == 0)
        return 0;

    pbO = pbOBuf;                 /* Working copy */
    pbIEnd = pbIBuf + iBCnt;          /* Gone too far if we reach here */

    /*
     * Calculate the maximum amount of data we will generate
     */

    pbStart = pbIBuf;

    while (++pbIBuf < pbIEnd)
    {
        if (*pbIBuf == pbIBuf[-1])
        {
            // valid run but we will first output any literal data
            if ((iSize = (int)(pbIBuf - pbStart) - 1) > 0) 
            {
                if ((iMaxCnt -= iSize) < 0)  // test for output overflow
                    return -1;
                CopyMemory(pbO,pbStart,iSize);
                pbO += iSize;
            }
            
            // determine the run length
            jLast = *pbIBuf;
            pbI = pbIBuf;
            pbTmp = pbIBuf + FERLE_MAX_RUN - 1;
            if (pbTmp > pbIEnd)
                pbTmp = pbIEnd;
            do {
                pbIBuf++;
            } while (pbIBuf < pbTmp && *pbIBuf == jLast);
             
            iSize = (int)(pbIBuf - pbI) + 1; /* Number of times */

            // output the RLE strings
            if ((iMaxCnt -= 3) < 0)       // test for output overflow
                return -1;
            *pbO++ = jLast;             // copy data byte twice
            *pbO++ = jLast;
            *pbO++ = (BYTE)iSize;

            // test if we are done            
            if( pbIBuf == pbIEnd )
                return (int)(pbO - pbOBuf);
                
            // setup for continuation of loop
            pbStart = pbIBuf;
        }
    }

    /*
     *  Since the data did not end in a run we must output the last 
     *  literal data if we haven't overflowed the buffer. 
     */
    iSize = (int)(pbIBuf - pbStart);

    if (iMaxCnt < iSize)
        return -1;

    CopyMemory(pbO,pbStart,iSize);
    pbO += iSize;
    return (int)(pbO - pbOBuf);
}

//****************************************************
int
iCompDeltaRow(
    BYTE  *pbOBuf,
    const BYTE  *pbIBuf,
    const BYTE  *pbPBuf,
    int   iBCnt,
    int   iLimit
    )
/*++

Routine Description:
    
    This function is called to compress a scan line of data using
    delta row compression.

Arguments:

    pbOBuf      Pointer to output buffer
    pbIBuf      Pointer to data buffer to compress
    pbPBuf      Pointer to previous row data buffer
    iBCnt       Number of bytes in the above
    iLimit      Don't exceed this number of compressed bytes

Return Value:

    Number of compressed bytes or -1 if too large for buffer
    
Note:
    A return value of 0 is valid since it implies the two lines
    are identical.    

--*/

{
#ifdef _X86_
    BYTE   *pbO;         /* Record output location */
    BYTE   *pbOEnd;      /* As far as we will go in the output buffer */
    const BYTE   *pbIEnd;
    const BYTE   *pbStart;
    const BYTE   *pb;
    int    iDelta;
    int    iOffset;     // index of current data stream
    int    iSize;       /* Number of bytes in the run */

    //
    // The size of output buffer should be atleast 1/8th bigger than input buffer.
    // As stated in comment below. "This compression algorithm adds
    // 1 byte for every 8 bytes of data worst case"
    // Add 1 to make sure it is atleast 1 byte bigger (in case iBCnt < 8 ).
    //
    if ( iLimit < (iBCnt + (iBCnt >> 3) + 1) )
    {
        return -1;
    }

    //
    /*
     *   Limit the amount of data we will generate. For performance
     * reasons we will ignore the effects of an offset value
     * greater than 30 since it implies we were able to already skip
     * that many bytes. However, for safety sake we will reduce the
     * max allowable size by 2 bytes.
     */
    pbO = pbOBuf;                 /* Working copy */
    pbOEnd = pbOBuf + iLimit - 2;
    iDelta = pbPBuf - pbIBuf;    
    pbIEnd = pbIBuf + iBCnt;
    pbStart = pbIBuf;
    
    //
    // this is the main loop for compressing the data
    //
    while (pbIBuf < pbIEnd)
    {
        // fast skip for matching dwords
        //
        if (!((ULONG_PTR)pbIBuf & 3))
        {
            while (pbIBuf <= (pbIEnd-4) && *(DWORD *)pbIBuf == *(DWORD *)&pbIBuf[iDelta])
                pbIBuf += 4;
            if (pbIBuf >= pbIEnd)
                break;
        }
        // test for non-matching bytes and output the necessary compression string
        //
        if (*pbIBuf != pbIBuf[iDelta])
        {
            // determine the run length
            pb = pbIBuf;
            do {
                pb++;
            } while (pb < pbIEnd && *pb != pb[iDelta]);

            iSize = (int)(pb - pbIBuf);

            // Lets make sure we have room in the buffer before
            // we continue this, this compression algorithm adds
            // 1 byte for every 8 bytes of data worst case.
            //
            iOffset = (int)(pbIBuf - pbStart);
            if ((((iSize * 9 + 7) >> 3)+(iOffset >> 8)) > (pbOEnd - pbO))     // gives tighter code
            {
                return -1;
            }
            if (iOffset > 30)
            {
                if (iSize < 8)
                    *pbO++ = ((iSize-1) << 5) + 31;
                else
                    *pbO++ = (7 << 5) + 31;
                iOffset -= 31;
                while (iOffset >= 255)
                {
                    iOffset -= 255;
                    *pbO++ = 255;
                }
                *pbO++ = (BYTE)iOffset;
                if (iSize > 8)
                    goto FastEightByteRun;
            }
            else if (iSize > 8)
            {
                *pbO++ = (7 << 5) + iOffset;
FastEightByteRun:
                while (1)
                {
                    CopyMemory(pbO,pbIBuf,8);
                    pbIBuf += 8;
                    pbO += 8;
                    if ((iSize -= 8) <= 8)
                        break;
                    *pbO++ = (7 << 5);
                }
                *pbO++ = (iSize-1) << 5;
            }
            else
                *pbO++ = ((iSize-1) << 5) + iOffset;
                
            CopyMemory (pbO,pbIBuf,iSize);
            pbIBuf += iSize;
            pbO += iSize;
            pbStart = pbIBuf;
        }
        pbIBuf++;
    }
    return (int)(pbO - pbOBuf);
#else
    BYTE   *pbO;         /* Record output location */
    BYTE   *pbOEnd;      /* As far as we will go in the output buffer */
    const BYTE   *pbIEnd;
    const BYTE   *pbStart;
    const BYTE   *pb;
    int    iOffset;     // index of current data stream
    int    iSize;       /* Number of bytes in the run */

    //
    // The size of output buffer should be atleast 1/8th bigger than input buffer.
    // As stated in comment below. "This compression algorithm adds
    // 1 byte for every 8 bytes of data worst case"
    // Add 1 to make sure it is atleast 1 byte bigger (in case iBCnt < 8 ).
    //
    if ( iLimit < (iBCnt + (iBCnt >> 3) + 1) )
    {
        return -1;
    }

    /*
     *   Limit the amount of data we will generate. For performance
     * reasons we will ignore the effects of an offset value
     * greater than 30 since it implies we were able to already skip
     * that many bytes. However, for safety sake we will reduce the
     * max allowable size by 2 bytes.
     */
    pbO = pbOBuf;                 /* Working copy */
    pbOEnd = pbOBuf + iLimit - 2;
    pbIEnd = pbIBuf + iBCnt;
    pbStart = pbIBuf;
    
    //
    // this is the main loop for compressing the data
    //
    while (pbIBuf < pbIEnd)
    {
        // fast skip for matching dwords
        //
        if (!((ULONG_PTR)pbIBuf & 3))
        {
            while (pbIBuf <= (pbIEnd-4) && *(DWORD *)pbIBuf == *(DWORD *)pbPBuf)
            {
                pbIBuf += 4;
                pbPBuf += 4;
            }
            if (pbIBuf >= pbIEnd)
                break;
        }
        // test for non-matching bytes and output the necessary compression string
        //
        if (*pbIBuf != *pbPBuf)
        {
            // determine the run length
            pb = pbIBuf;
            do {
                pb++;
                pbPBuf++;
            } while (pb < pbIEnd && *pb != *pbPBuf);

            iSize = (int)(pb - pbIBuf);

            // Lets make sure we have room in the buffer before
            // we continue this, this compression algorithm adds
            // 1 byte for every 8 bytes of data worst case.
            //
            iOffset = (int)(pbIBuf - pbStart);

            if ((((iSize * 9 + 7) >> 3)+(iOffset >> 8)) > (int)(pbOEnd - pbO))
            {
                return -1;
            }
            
            // special case the initial offset value since it
            // occurs only once and may require extra bytes
            //
            if (iOffset)
            {
                int iSend = min (iSize,8);
                if (iOffset > 30) 
                {
                    *pbO++ = ((iSend-1) << 5) + 31;
                    iOffset -= 31;
                    while (iOffset >= 255)
                    {
                        *pbO++ = 255;
                        iOffset -= 255;
                    }
                    *pbO++ = (BYTE)iOffset;
                }
                else 
                {
                    *pbO++ = ((iSend-1) << 5) + iOffset;
                }
                // output the initial changed bytes
                CopyMemory(pbO,pbIBuf,iSend);
                pbIBuf += iSend;
                pbO += iSend;
                iSize -= iSend;
            }
            
            // now output any remaining changed data
            //
            while (iSize)
            {
                if (iSize >= 8)
                {
                    *pbO++ = (8 - 1) << 5;
                    CopyMemory(pbO,pbIBuf,8);
                    pbIBuf += 8;
                    pbO += 8;
                    iSize -= 8;
                }
                else
                {
                    *pbO++ = (iSize-1) << 5;
                    CopyMemory(pbO,pbIBuf,iSize);
                    pbIBuf += iSize;
                    pbO += iSize;
                    break;
                }
            }
            pbStart = pbIBuf;
        }
        pbIBuf++;
        pbPBuf++;
    }
    return (int)(pbO - pbOBuf);
#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\compress.h ===
/****************************** MODULE HEADER ******************************
 * compress.h
 *        Function prototypes and other curiosities associated with data
 *        compression code.
 *
 *   Copyright (C) 1997  Microsoft Corporation.
 *
 ****************************************************************************/

//
// this parameter controls how much better (in bytes) a new compression mode
// must do before it will be used instead of the current output mode
#define COMP_FUDGE_FACTOR 4

/*
 *   TIFF Compression function.
 */
int  iCompTIFF( BYTE *, ULONG, const BYTE *, int );

//
//  Delta Row Compression function
//
int iCompDeltaRow(BYTE *, const BYTE *, const BYTE *, int, int);


/*
 *   Some constants defining the limits of TIFF encoding.  The first
 * represent the minimum number of repeats for which it is worth using
 * a repeat operation.  The other two represent the maximum length
 * of data that can be encoded in one control byte.
 */

#define TIFF_MIN_RUN       4            /* Minimum repeats before use RLE */
#define TIFF_MAX_RUN     128            /* Maximum repeats */
#define TIFF_MAX_LITERAL 128            /* Maximum consecutive literal data */

/*
 *   RLE (Run Length Encoding) functions.
 */

int  iCompRLE( BYTE *, BYTE *, int );
int  iCompFERLE (BYTE *, BYTE *, int, int );
/*
 *   Some constants relating to RLE operations.  RLE is ony useful in
 *  data containing runs.  In purely random data, the data size will
 *  double.  Consequently,  we allow a certain expansion of the data
 *  size before calling it off.  A small expansion is OK,  since the
 *  there is a cost involved in switching compression on and off.
 */

#define    FERLE_MAX_RUN    255          /* max consecutive byte count */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\fonts.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    fonts.cpp

Abstract:
    This module contains functions for implementing the TextOut DDI.

Author:


[Environment:]
    Windows 2000/Whistler Unidrv driver

[Notes:]

Revision History:

--*/

#include "hpgl2col.h" //Precompiled header file

//
// Local defines 
//

//
// If the LEN_FONTNAME field isn't defined make it 16 characters.  This should
// be made to match the prn5\unidrv2\font\SFTTPCL.H file.
//
#ifndef LEN_FONTNAME
#define LEN_FONTNAME 16
#endif

//
//
//#define TEXT_SRCCOPY             (DWORD)0x000000B8 
#define TEXT_SRCCOPY (DWORD)252


//
// Function prototypes
//
BOOL BIsNullRect (
    RECTL *rect
    );

VOID VCreateNULLRect (
    RECTL *pRect,
    RECTL  *newRect
    );

BOOL 
BDrawExtraTextRects(
    PDEVOBJ   pdevobj, 
    RECTL    *prclExtra, 
    BRUSHOBJ *pboFore, 
    POINTL   *pptlOrg,
    CLIPOBJ  *pco,
	MIX       mix
    );

VOID
VSelectTextColor (
    PDEVOBJ   pDevObj,
    BRUSHOBJ *pboFore,
    POINTL *pptlBrushOrg
    );

#ifdef COMMENTEDOUT
VOID
VSelectPaletteIndex (
    PDEVOBJ   pDevObj,
    BYTE      paletteIndex
    );
#endif

VOID
VCopyBitmapAndAlign (
    BYTE   *pBits,
    BYTE   *aj,
    SIZEL   sizlBitmap
    );

/////////////////////////////////////////////////////////////////////////////
// HPGLTextOut
//
// Routine Description:
//   Entry point from GDI to render glyphs.
//
// Arguments:
//
//   pso - Points to surface.
//   pstro - String Object that defines the glyphs to be rendered and
//           the position of the glyphs.
//   pfo - points to the FONTOBJ.
//   pco - clipping region to be used when rendering glyphs
//   prclExtra - null - terminated array of rectangles to be drawn after
//               the text is drawn. These are usually underlines and
//               strikethroughs.
//   prclOpaque - single opaque rectangle.
//   pboFore - color of the text
//   pboOpaque - brush color of prclOpaque rectangle.
//   pptlOrg - a POINTL structure that defines the brush origin for both
//             brushes.
//   mix - foreground and background raster operations for pboFore.
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;
    RECTL       *prclNewOpaque;
    BYTE        bFlags = 0;
    BOOL        bRetVal = TRUE;

    TERSE(("HPGLTextOut() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA(poempdev, return FALSE);

    BChangeAndTrackObjectType ( pdevobj, eTEXTOBJECT );

    //
    // check for an Opaque rectangle - these are sent before the
    // text is drawn.
    //
    if (prclOpaque != NULL)
    {
        TERSE(("Opaque brush in HPGLTextOut!\r\n"));
        //
        // prclOpaque rectangles are not null - terminated unlike
        // prclExtra, so I must create a null - terminated rectangle
        // in order to use our drawing routines
        //
        if (!(prclNewOpaque = (PRECTL)MemAlloc(2 * sizeof(RECTL))))
        {
            return FALSE;
        }
        ZeroMemory (prclNewOpaque, 2 * sizeof (RECTL));
        VCreateNULLRect (prclOpaque, prclNewOpaque);
        BDrawExtraTextRects(pdevobj, prclNewOpaque, pboOpaque, pptlOrg, pco, mix);
        MemFree(prclNewOpaque);
    }

    //
    // Send Commands that set the environment for color printers. 
    // I may investigate later whether we can move it to VTrackAndChangeObjectType()
    //
    if (poempdev->wInitCIDPalettes & PF_INIT_TEXT_STARTDOC)
    {
        PCL_SelectTransparency(pdevobj, eTRANSPARENT, eOPAQUE, bFlags);
        VSetupCIDPaletteCommand (pdevobj, eTEXT_CID_PALETTE, eDEVICE_RGB, 1);
        poempdev->wInitCIDPalettes &= ~PF_INIT_TEXT_STARTDOC;
    }

    //
    // Force update of X and Y position. 
    //
    OEMResetXPos(pdevobj);
    OEMResetYPos(pdevobj);

    VSelectTextColor (pdevobj, pboFore, pptlOrg);
    SelectMix(pdevobj, mix); 

    bRetVal = OEMUnidriverTextOut (
                        pso,
                        pstro,
                        pfo,
                        pco,
                        prclExtra,
                        prclOpaque,
                        pboFore,
                        pboOpaque,
                        pptlOrg,
                        mix);

    // 
    // The underline and strikeout lines may be defined as prclExtra
    // rectangles.  If so draw them.
    //
    if (prclExtra != NULL)
    {
        BDrawExtraTextRects(pdevobj, prclExtra, pboFore, pptlOrg, pco, mix);
    }
    else
    {
        VERBOSE(("prclExtra is NULL\n"));
    }

    return bRetVal;
}

/////////////////////////////////////////////////////////////////////////////
// BDrawExtraTextRects
//
// Routine Description:
//
//    Draw any underlining and strike out if they exist.
//    Follow the array of rectangles in prclExtra until a
//    null rectangle is found. A null rectangle is defined
//    in the DDK as both coordinates of both points set to 0.
//
// Arguments:
//
//   pdevobj - The output device
//   prclExtra - the rectangles to be drawn--expressed as an array of 
//               rectangles terminated by a NULL rectangle.
//   pboFore - the color to fill the rectangles with
//   pptlOrg - The origin point if the brush is a pattern brush
//   pco - the clipping region
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL 
BDrawExtraTextRects(
    PDEVOBJ   pdevobj, 
    RECTL    *prclExtra, 
    BRUSHOBJ *pboFore, 
    POINTL   *pptlOrg,
    CLIPOBJ  *pco,
	MIX       mix
    )
{
    PHPGLSTATE  pState;    // For complex clipping 
    ENUMRECTS   clipRects; // Make this larger to reduce calls to CLIPOBJ_bEnum
    BOOL        bMore;
    ULONG       i;
    HPGLMARKER  Brush;
    BOOL        bRetVal = TRUE;
    POEMPDEV    poempdev;
    EObjectType eObjectTypeBackup;
    

    ASSERT_VALID_PDEVOBJ(pdevobj);
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA (poempdev, return FALSE);

    pState = GETHPGLSTATE(pdevobj);

    //
    // There is complex jugglery here. When we get this call, we should
    // be in Text mode (which is being in PCL mode). We want to select 
    // the mix in PCL mode, then move to HPGL mdoe to draw the rectangle.
    // After rectangle drawing is finished, we return to TextMode.
    //

	SelectMix(pdevobj, mix);

    //
	// Lets give it "Graphics" color treatment instead "Text".
    // Even though this is a part of TextOut call, but since rectangle
    // is a vector object, Graphics treatment is justified.
    // 
    eObjectTypeBackup = poempdev->eCurObjectType;

    BChangeAndTrackObjectType(pdevobj, eHPGLOBJECT);

    //
    // Global binding alerts: 
    // SelectClip modifies pState->pComplexClipObj
    //
    ZeroMemory ( &Brush, sizeof(HPGLMARKER) );
    if ( !CreateHPGLPenBrush(pdevobj, &Brush, pptlOrg, pboFore, 0, kBrush, FALSE) ||
         !FillWithBrush(pdevobj, &Brush))
    {
        bRetVal = FALSE;
        goto finish;
    }

    HPGL_SetLineWidth(pdevobj, 0, NORMAL_UPDATE);
    SelectClip(pdevobj, pco); 
    
    // 
    // If clipping is complex we will iterate over the regions
    //
    if (pState->pComplexClipObj)
    {
        CLIPOBJ_cEnumStart(pState->pComplexClipObj, TRUE, CT_RECTANGLES, 
                           CD_LEFTDOWN, 0);
        do
        {
            bMore = CLIPOBJ_bEnum(pState->pComplexClipObj, sizeof(clipRects), 
                                  &clipRects.c);

            if ( DDI_ERROR == bMore )
            {
                bRetVal = FALSE;
                break;
            }

            for (i = 0; i < clipRects.c; i++)
            {
                HPGL_SetClippingRegion(pdevobj, &(clipRects.arcl[i]), 
                                       NORMAL_UPDATE);
                
                while(!BIsNullRect(prclExtra))
                {
                    HPGL_DrawRectangle(pdevobj, prclExtra);
                    prclExtra++;
                }
            }
        } while (bMore);
    }
    else
    {
        while(!BIsNullRect(prclExtra))
        {
            HPGL_DrawRectangle(pdevobj, prclExtra);
            prclExtra++;
        }
    }
    
    //
    // After the rectangles are drawn, go to Text Drawing mode.
    //
  finish:
    BChangeAndTrackObjectType ( pdevobj, eObjectTypeBackup);
    return bRetVal;
}

/////////////////////////////////////////////////////////////////////////////
// BIsNullRect
//
// Routine Description:
//
//    Determines if the passed rectangle is a NULL rectangle
//    according to the DDK. 
//
// Arguments:
//
//   rect - The rectangle to check
//
// Return Value:
//
//   TRUE if rectangle is the NULL rectangle, FALSE otherwise
/////////////////////////////////////////////////////////////////////////////
BOOL
BIsNullRect (
    RECTL *rect
    )
{

    if  (rect)
    {
        //
        // per line 1300 of unidrv2\font\fmtxtout.c, Eng does not follow the
        // spec regarding null rectange. So instead of a null rectangle being 
        // defined as all coordinates zero, it is defined as either the two x coordinates
        // are same, or the two y coordinates are same.  The latter condition is a superset
        // of the former.
        // 
      /*** 
        if (rect->left == 0 &&
            rect->top == 0  &&
            rect->right == 0 &&
            rect->bottom == 0)
      **/
        if ( rect->left == rect->right || rect->top == rect->bottom )
            return TRUE;
        else
            return FALSE;
    }
    //else
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// VCreateNULLRect
//
// Routine Description:
//
//    Creates a rectangle array consisting of the given rectangle and a
//    terminating NULL rectangle.  Handy for calling DrawExtraTextRects which
//    requires a terminating NULL rectangle.
//
// Arguments:
//
//   pRect - the original rectangle
//   pNewRect - the destination for the copy of pRect and the NULL rectangle
//
// Return Value:
//
//   None.
/////////////////////////////////////////////////////////////////////////////
VOID
VCreateNULLRect (
    RECTL *pRect,
    RECTL  *pNewRect
)
{
    if (!pRect || !pNewRect)
        return;

    RECTL_CopyRect(pNewRect, pRect);
    pNewRect++;
    pNewRect->left = pNewRect->right = 0;
    pNewRect->top = pNewRect->bottom = 0;
}

/////////////////////////////////////////////////////////////////////////////
// VSelectTextColor
//
// Routine Description:
//
//    Selects the text color using the brush color passed in.
//
// Arguments:
//
//   pDevObj - the device to print on
//   pboFore - the color of the text.
//   
// Return Value:
//
//   nothing
/////////////////////////////////////////////////////////////////////////////
VOID
VSelectTextColor (
    PDEVOBJ   pDevObj,
    BRUSHOBJ *pboFore,
    POINTL *pptlBrushOrg
    )
{
    // BYTE        paletteIndex = 0;
    POEMPDEV    poempdev;
    BYTE        bFlags = 0;
    PCLPATTERN *pPCLPattern;

    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA(poempdev, return);

    pPCLPattern = &(poempdev->RasterState.PCLPattern);

    if (poempdev->eCurObjectType != eTEXTOBJECT && 
        poempdev->eCurObjectType != eTEXTASRASTEROBJECT)
    {
        // bFlags |= PF_FORCE_SOURCE_TRANSPARENCY;
        PCL_SelectTransparency(pDevObj, eTRANSPARENT, eOPAQUE, bFlags);
    }

    //
    // No need to seelct CID palette commands on monochrome printers.
    //
    if ( BIsColorPrinter(pDevObj) )
    { 
        VSelectCIDPaletteCommand (pDevObj, eTEXT_CID_PALETTE);
    }
    BSetForegroundColor(pDevObj, pboFore, pptlBrushOrg, pPCLPattern, BMF_1BPP);
}

#ifdef COMMENTEDOUT
/////////////////////////////////////////////////////////////////////////////
// VSelectPaletteIndex
//
// Routine Description:
//
//    Sends the PCL command to select a specific palette index.
//
// Arguments:
//
//   pDevObj - the device
//   paletteIndex - the palette entry
//   
// Return Value:
//
//   None.
/////////////////////////////////////////////////////////////////////////////
VOID 
VSelectPaletteIndex (
    PDEVOBJ   pDevObj,
    BYTE      paletteIndex
    )
{

    PCL_sprintf(pDevObj, "\x1B*v%dS", paletteIndex);
}
#endif

/////////////////////////////////////////////////////////////////////////////
// HPGLTextOutAsBitmap
//
// Routine Description:
//
//    Draw the string of glyphs as bitmaps.
//
//    currently send as bitmap data - a nice enhancement is  to download the 
//    bitmap data as characters (?)
//
// Arguments:
//
//   pso - the destination(?) surface
//   pstro - the source string
//   pfo - the source font
//   pco - the clipping region
//   prclExtra - extra rectangles (underlined or strikeout) to print
//   prclOpaque - opaque region
//   pboFore - the foreground color
//   pboOpaque - the background color
//   pptlOrg - the brush origin (if it is a pattern brush)--note: unused
//   
// Return Value:
//
//   True if successful, FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLTextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )
{
    PDEVOBJ      pDevObj;
    POEMPDEV     poempdev;
    DWORD        count;
    GLYPHPOS    *pGlyphPos;
    ULONG        cGlyphs;          
    GLYPHBITS   *pGlyphBits;
    GLYPHDATA   *pGlyphData;
    LONG         iWidth;
    HBITMAP      hbm;
    SURFOBJ     *psoGlyph;
    SIZEL        sizlBitmap;
    RECTL        rclDest;
    POINTL       ptlSrc;
    RECTL        clippedRect;
    BYTE         bFlags = 0;
    BOOL         bMore = FALSE;
    BOOL         bRetVal = TRUE;

    TERSE(("HPGLTextOutAsBitmap\n"));

    UNREFERENCED_PARAMETER(mix);
    UNREFERENCED_PARAMETER(pptlOrg);
    UNREFERENCED_PARAMETER(prclExtra);
    UNREFERENCED_PARAMETER(prclOpaque);
    UNREFERENCED_PARAMETER(pboOpaque);
    UNREFERENCED_PARAMETER(pco);

    pDevObj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pDevObj));
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA (poempdev, return FALSE);

    BChangeAndTrackObjectType ( pDevObj, eTEXTASRASTEROBJECT);
    poempdev->bTextTransparencyMode = TRUE;
    poempdev->bTextAsBitmapMode     = TRUE;

    cGlyphs = pstro->cGlyphs;

    if (cGlyphs == 0)
    {
        WARNING(("OEMTextOutAsBitmap cGlyphs = 0\n"));
        goto finish;
    }

    if (pstro->pgp == NULL)
        STROBJ_vEnumStart (pstro);

    do 
    {
        if (pstro->pgp != NULL)
        {
            cGlyphs = pstro->cGlyphs;
            bMore = FALSE;
            pGlyphPos = pstro->pgp;
        }
        else
        {
            bMore = STROBJ_bEnum (pstro, &cGlyphs, &pGlyphPos);

            if ( DDI_ERROR == bMore )
            {
                bRetVal = FALSE;
                break;
            }
        }

        for (count = 0; count < cGlyphs; count++)
        {
            //
            // get the bitmap of the glyph from the STROBJ
            //
            if (!FONTOBJ_cGetGlyphs (pfo, FO_GLYPHBITS, 1, &pGlyphPos->hg, 
                                 (PVOID *)&pGlyphData))
            {
                ERR(("OEMTextOutAsBitmap: cGetGlyphs failed\n"));
                bRetVal = FALSE;
                break;
            }
            pGlyphBits = pGlyphData->gdf.pgb;


            //
            // create a device bitmap to send to the printer
            //
            sizlBitmap = pGlyphBits->sizlBitmap;
            iWidth = pGlyphBits->sizlBitmap.cx + DWBITS -1;
            hbm = EngCreateBitmap (pGlyphBits->sizlBitmap,
                                   iWidth,
                                   BMF_1BPP,
                                   BMF_TOPDOWN,
                                   NULL);


            //
            // The 2 "breaks" below only break from the inner
            // for loop but not the outer do loop. i.e. We'll try to print as
            // much as we can.
            // But FALSE will be returned to indicate that everything could
            // not be printed.
            //
            if (!hbm)
            {
                bRetVal = FALSE;
                break;
            }

            psoGlyph = EngLockSurface ( (HSURF)hbm);

            if ( NULL == psoGlyph)
            {
                DELETE_SURFOBJ(NULL, &hbm);
                bRetVal = FALSE;
                break;
            }

            VCopyBitmapAndAlign( (BYTE *)psoGlyph->pvBits, pGlyphBits->aj,
                                  sizlBitmap);

            rclDest.left = pGlyphPos->ptl.x + pGlyphBits->ptlOrigin.x;
            rclDest.right = rclDest.left + pGlyphBits->sizlBitmap.cx;

            rclDest.top = pGlyphPos->ptl.y + pGlyphBits->ptlOrigin.y;
            rclDest.bottom = rclDest.top + pGlyphBits->sizlBitmap.cy;

            ptlSrc.x = 0;
            ptlSrc.y = 0;
            if (pco->iDComplexity == DC_RECT )
            {
                if ( rclDest.top < pco->rclBounds.top)
                {
                    ptlSrc.y = pco->rclBounds.top - rclDest.top;
                }
                if ( rclDest.left < pco->rclBounds.left)
                {
                    ptlSrc.x = pco->rclBounds.left - rclDest.left;
                }
            }

            if (BRectanglesIntersect (&rclDest, &(pco->rclBounds), &clippedRect))
            {

                //
                // send the bitmap to the printer
                //
        
                bRetVal = HPGLBitBlt( pso, 
                                     psoGlyph, 
                                     NULL,          //psoMask
                                     NULL,          //pco
                                     NULL,          //pxlo
                                     &clippedRect,
                                     &ptlSrc, 
                                     NULL,          //pptlMask
                                     pboFore, 
                                     NULL,          //pptlBrush
                                     TEXT_SRCCOPY);
                                     //mix);


            }

            DELETE_SURFOBJ (&psoGlyph, &hbm);

            //
            // get the next glyph to print
            //
            pGlyphPos++;
        }
    }
    while (bMore);
   
  finish:
    poempdev->bTextTransparencyMode = FALSE;
    poempdev->bTextAsBitmapMode = FALSE;

    return bRetVal;
}

/////////////////////////////////////////////////////////////////////////////
// VCopyBitmapAndAlign
//
// Routine Description:
//
//    This function copies the bytes of a bitmap of size sizlBitmap from the 
//    source to the destination.  Basically a trivial function.
//
// Arguments:
//
//   pDest - Destination bitmap
//   pjSrc - Source bitamp
//   sizlBitmap - Size of source and destination
//   
// Return Value:
//
//   None.
/////////////////////////////////////////////////////////////////////////////
VOID 
VCopyBitmapAndAlign (
    BYTE    *pDest,
    BYTE    *pjSrc,
    SIZEL    sizlBitmap
    )
{
    int    iX, iY;               // For looping through the bytes 
    int    cjFill;               // Extra bytes per output scan line 
    int    cjWidth;              // Number of bytes per input scan line 
    int    cx, cy;


    cx = sizlBitmap.cx;
    cy = sizlBitmap.cy;

    //
    // Input scan line bytes
    //
    cjWidth = (cx + BBITS - 1) / BBITS;
    cjFill = ((cjWidth + 3) & ~0x3) - cjWidth;

    //
    // Copy the scan line bytes, then fill in the trailing bits
    //
    for( iY = 0; iY < cy; ++iY )
    {
        for( iX = 0; iX < cjWidth; ++iX )
        {
            *pDest++ = *pjSrc++;
        }

        //
        // Output alignment
        //
        pDest += cjFill;
    }
}


#ifdef HOOK_DEVICE_FONTS
///////////////////////////////////////////////////////////////////////////////
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// OEMQueryFont()
//
// Routine Description:
// 
//   [TODO: Description]
// 
// Arguments:
// 
//   phpdev - [TODO: Arguments]
//   iFile - 
//   iFace - 
//   pid - 
// 
// Return Value:
// 
//   [TODO: Return Value]
///////////////////////////////////////////////////////////////////////////////
PIFIMETRICS APIENTRY
HPGLQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLQueryFont() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //
    return (((PFN_DrvQueryFont)(poempdev->pfnUnidrv[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));
}

///////////////////////////////////////////////////////////////////////////////
// HPGLQueryFontTree()
//
// Routine Description:
// 
//   [TODO: Description]
// 
// Arguments:
// 
//   phpdev - [TODO: Arguments]
//   iFile - 
//   iFace - 
//   iMode - 
//   pid - 
// 
// Return Value:
// 
//   [TODO: Return Value]
///////////////////////////////////////////////////////////////////////////////
PVOID APIENTRY
HPGLQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("OEMQueryFontTree() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv
    //
    return (((PFN_DrvQueryFontTree)(poempdev->pfnUnidrv[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));
}

///////////////////////////////////////////////////////////////////////////////
// HPGLQueryFontData()
//
// Routine Description:
// 
//   [TODO: Description]
// 
// Arguments:
// 
//   phpdev - [TODO: Arguments]
//   pfo - 
//   iMode - 
//   hg - 
//   pgd - 
//   pv - 
//   cjSize - 
// 
// Return Value:
// 
//   [TODO: Return Value]
///////////////////////////////////////////////////////////////////////////////
LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLQueryFontData() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //
    return (((PFN_DrvQueryFontData)(poempdev->pfnUnidrv[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));
}

///////////////////////////////////////////////////////////////////////////////
// HPGLQueryAdvanceWidths()
//
// Routine Description:
// 
//   [TODO: Description]
// 
// Arguments:
// 
//   phpdev - [TODO: Arguments]
//   pfo - 
//   iMode - 
//   phg - 
//   pvWidths - 
//   cGlyphs - 
// 
// Return Value:
// 
//   [TODO: Return Value]
///////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLQueryAdvanceWidths() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //
    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnUnidrv[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));
}

///////////////////////////////////////////////////////////////////////////////
// HPGLFontManagement()
//
// Routine Description:
// 
//   [TODO: Description]
// 
// Arguments:
// 
//   pso - [TODO: Arguments]
//   pfo - 
//   iMode - 
//   cjIn - 
//   pvIn - 
//   cjOut - 
//   pvOut - 
// 
// Return Value:
// 
//   [TODO: Return Value]
///////////////////////////////////////////////////////////////////////////////
ULONG APIENTRY
HPGLFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLFontManagement() entry.\r\n"));

    //
    // Note that Unidrv will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    //
    // This isn't needed if no PCL commands are sent during this call.
    //
    EndHPGLSession(pdevobj);

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //
    return (((PFN_DrvFontManagement)(poempdev->pfnUnidrv[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));
}

///////////////////////////////////////////////////////////////////////////////
// HPGLGetGlyphMode()
//
// Routine Description:
// 
//   [TODO: Description]
// 
// Arguments:
// 
//   dhpdev - [TODO: Arguments]
//   pfo - 
// 
// Return Value:
// 
//   [TODO: Return Value]
///////////////////////////////////////////////////////////////////////////////
ULONG APIENTRY
HPGLGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLGetGlyphMode() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));

    EndHPGLSession(pdevobj);

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //
    return (((PFN_DrvGetGlyphMode)(poempdev->pfnUnidrv[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));
}
#endif  // HOOK_DEVICE_FONTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\gloemkm.h ===
//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))
// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\glpalett.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
//
// Header File Name:
//
//    glpalett.h
//
// Abstract:
//
//    Declaration of palette handling functions.
//    
//
// Environment:
//
//    Windows 200 Unidrv driver
//
// Revision History:
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _GLPALETT_H
#define _GLPALETT_H

#include "glpdev.h"
#include "clrsmart.h"


BOOL 
BGetPalette(
    PDEVOBJ pdevobj, 
    XLATEOBJ *pxlo, 
    PPCLPATTERN pPattern, 
    ULONG srcBpp,
    BRUSHOBJ *pbo
    );

BOOL
BInitPalette(
    PDEVOBJ     pdevobj,
    ULONG       colorEntries,
    PULONG      pColorTable, 
	PPCLPATTERN pPattern,
    ULONG       srcBpp
);

VOID
VResetPaletteCache(PDEVOBJ pdevobj);

BOOL
bLoadPalette(PDEVOBJ pdevobj, PPCLPATTERN pPattern);

BOOL
BSetForegroundColor(PDEVOBJ pdevobj, BRUSHOBJ *pbo, POINTL *pptlBrushOrg,
				    PPCLPATTERN	pPattern, ULONG  bmpFormat);

BOOL
bSetBrushColorForMonoPrinters(PDEVOBJ  pdevobj, PPCLPATTERN  pPattern, BRUSHOBJ  *pbo,
			   POINTL  *pptlBrushOrg);

BOOL
bSetBrushColorForColorPrinters(PDEVOBJ  pdevobj, PPCLPATTERN  pPattern, BRUSHOBJ  *pbo,
			   POINTL  *pptlBrushOrg);

BOOL
bSetIndexedForegroundColor(PDEVOBJ pdevobj, PPCLPATTERN pPattern,
						   ULONG  uColor);

#ifdef CONFIGURE_IMAGE_DATA
BOOL
bConfigureImageData(PDEVOBJ  pdevobj, ULONG  bmpFormat);
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\glddihks.cpp ===
/*++
//
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
//
//    glddihks.cpp
//
// Abstract:
//
//    Implementation of OEM DDI hooks (all drawing DDI hooks)
//
// Environment:
//
//    Windows 2000/Whistler Unidrv driver
//
//
//--*/
// 

#include "hpgl2col.h" //Precompiled header file


//
// I liberated these from unidrv2\control\escape.c.  It MUST MATCH EXACTLY
// in order to work correctly. JFF
//
typedef struct _POINTS {
    short   x;
    short   y;
} POINTs;

typedef struct _SHORTDRAWPATRECT {      // use 16-bit POINT structure
    POINTs ptPosition;
    POINTs ptSize;
    WORD   wStyle;
    WORD   wPattern;
} SHORTDRAWPATRECT, *PSHORTDRAWPATRECT;

//
// Although this is undocumented there is a XFORMOBJ that is passed in
// along with the rectangle information.  This needs to be applied to
// the points before they can be drawn. JFF 9/17/99
//
#ifndef WINNT_40
typedef struct _DRAWPATRECTP {
    DRAWPATRECT DrawPatRect;
    XFORMOBJ *pXFormObj;
} DRAWPATRECTP, *PDRAWPATRECTP;
#endif

//
// Local Prototypes
//
ULONG
DrawPatternRect(
    PDEVOBJ      pDevObj,
    PDRAWPATRECT pPatRect,
    XFORMOBJ    *pxo
);

VOID
VSendStartPageCommands (
    PDEVOBJ pDevObj
);

VOID
VSendStartDocCommands (
    PDEVOBJ pDevObj
);

VOID
VGetStandardVariables (
    PDEVOBJ pDevObj
);


#ifndef WINNT_40
/////////////////////////////////////////////////////////////////////////////
// HPGLPlgBlt
//
// Routine Description:
//
//  Handles DrvPlgBlt.  However, we don't want to handle this function so we
//  return FALSE to the OS and it will be rendered by the unidrv.
//
// Arguments:
//
//   SURFOBJ psoDst - destination surface
//   SURFOBJ psoSrc - source surface
//   SURFOBJ psoMask - mask
//   CLIPOBJ pco - clipping region
//   XLATEOBJ pxlo - palette transation object
//   COLORADJUSTMENT pca - 
//   POINTL pptlBrushOrg - brush origin
//   POINTFIX pptfixDest - 
//   RECTL prclSrc - source rectangle
//   POINTL pptlMask - 
//   ULONG iMode - 
//
// Return Value:
//
//   BOOL: TRUE if sucessful else FALSE (note: this function alredy returns
//         FALSE).
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    )
{
    PDEVOBJ     pdevobj = NULL;
    
    TERSE(("HPGLPlgBlt() entry.\r\n"));

    REQUIRE_VALID_DATA (psoDst , return FALSE);

    pdevobj = (PDEVOBJ)psoDst->dhpdev;

    BOOL bRetVal = EngPlgBlt(
        psoDst,
        psoSrc,
        psoMask,
        pco,
        pxlo,
        pca,
        pptlBrushOrg,
        pptfixDest,
        prclSrc,
        pptlMask,
        iMode);
    //
    // PlgBlt can call some Drvxxx which can call into
    // some plugin module, which can overwrite our pdevOEM.
    // So we need to reset pdevOEM
    //
    BRevertToHPGLpdevOEM (pdevobj);

    return bRetVal;
}
    
#endif // if WINNT_40


/////////////////////////////////////////////////////////////////////////////
// HPGLStartPage
//
// Routine Description:
//
//  Handles DrvStartPage.  This function is called by the unidrv to indicate
//  that a new page is about to start.  We use this opportunity to reset 
//  variables that don't survive on a page boundary, or are overwritten by
//  by the unidrv.
//
// Arguments:
//
//   SURFOBJ pso - surface
//
// Return Value:
//
//   BOOL: TRUE if sucessful else FALSE.
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLStartPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;
    BOOL        bStartPage = FALSE;

    TERSE(("HPGLStartPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    if (poempdev->UIGraphicsMode == HPGL2)
    {
        if (poempdev->wJobSetup & PF_STARTDOC)
        {  
            // VSendStartDocCommands (pdevobj); 
            poempdev->wJobSetup &= ~PF_STARTDOC;
        }
        if (poempdev->wJobSetup & PF_STARTPAGE)
        {
            // VSendStartPageCommands (pdevobj);
            bStartPage = TRUE;
            HPGL_StartPage(pdevobj);
            poempdev->wJobSetup &= ~PF_STARTPAGE;
        }
        BOOL bRetVal = (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));

        //
        // After returning from unidrv, the pdevOEM in PDEVOBJ might be obliterated.
        // e.g. when there is a plugin driver who has its own pdev. 
        // So it needs to be reset. 
        //
        pdevobj->pdevOEM = poempdev;

        if ( bRetVal && bStartPage) 
        {
            VSendStartPageCommands(pdevobj);
        }
        return bRetVal;
    }
    else
    {
        //
        // turn around to call Unidrv
        //
        return (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));
    }

}


/////////////////////////////////////////////////////////////////////////////
// HPGLSendPage
//
// Routine Description:
//
//  Handles DrvSendPage.  This function is called by the unidrv to indicate
//  that a page is being sent.  We use this opportunity to reset variables.
//
// Arguments:
//
//   SURFOBJ pso - destination surface
//
// Return Value:
//
//   BOOL: TRUE if sucessful else FALSE.
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLSendPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLSendPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA(poempdev, return FALSE);

    //
    // Make sure to reinitialize palette modes after page break!
    // Do full palette initialization after each page (i.e. STARTDOC)
    // Because the unidriver can mess with our palette config now.  JFF
    //
    poempdev->wInitCIDPalettes |= PF_INIT_TEXT_STARTPAGE;
    poempdev->wInitCIDPalettes |= PF_INIT_TEXT_STARTDOC;
    poempdev->wInitCIDPalettes |= PF_INIT_RASTER_STARTPAGE;
    poempdev->wInitCIDPalettes |= PF_INIT_RASTER_STARTDOC;


    poempdev->CurrentROP3 = INVALID_ROP3;
    poempdev->uCurFgColor = HPGL_INVALID_COLOR;

    poempdev->eCurCIDPalette = eUnknownPalette;
    poempdev->eCurObjectType = eNULLOBJECT;

    poempdev->CurHalftone = HALFTONE_NOT_SET;
    poempdev->CurColorControl = COLORCONTROL_NOT_SET;
        
    poempdev->CurSourceTransparency = eOPAQUE;
    poempdev->CurPatternTransparency = eOPAQUE;

    EndHPGLSession(pdevobj);
    poempdev->wJobSetup |= PF_STARTPAGE;

    //
    // Reset BrushCache in brshcach.h.
    //
    // PCL printer can't carry over downloaded brushes to next page.
    //
    poempdev->pBrushCache->Reset();
    poempdev->pPCLBrushCache->Reset();

    
    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvSendPage)(poempdev->pfnUnidrv[UD_DrvSendPage]))(pso));

}


/////////////////////////////////////////////////////////////////////////////
// HPGLEscape
//
// Routine Description:
//
//  Handles DrvEscape.  This is a painful catch-all for elderly operations 
//  that can't have functions assigned because they were *already* escapes,
//  and new functions that don't seem to warrant a funciton.
//
//  The escape that we're interested in is DRAWPATTERNRECT which comes in 
//  two exciting flavors: the short version and long version.  In both cases
//  we use DrawPatternRect to fill out the rect.
//
// Arguments:
//
//   SURFOBJ pso - destination surface
//   ULONG iEsc - the escape
//   ULONG cjIn - size of input data
//   PVOID pvIn - input data
//   ULONG cjOut - output data
//   PVOID pvOut - size of output data
//
// Return Value:
//
//   ULONG: 0 - unsuccessful
//          1 - successful
/////////////////////////////////////////////////////////////////////////////
ULONG APIENTRY
HPGLEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLEscape() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA(poempdev, return FALSE);


    if (iEsc == DRAWPATTERNRECT)
    {
        //
        // I liberated this code from unidrv2\control\escape.c.  It MUST MATCH
        // functionally in order to work correctly. JFF
        //
        if (pvIn == NULL)
            return 1; // Hmmm. No data. Tell GDI to take no action

        if (cjIn == sizeof(DRAWPATRECT))
        {
            // Draw a normal pattern rect
            return DrawPatternRect(pdevobj, (PDRAWPATRECT)pvIn, NULL);
        }
#ifndef WINNT_40
        //
        // If the xformobj has been sent then use it to render.
        //
        else if (cjIn == sizeof(DRAWPATRECTP))
        {
            // use the xformobj to draw a pattern rect
            XFORMOBJ *pxo = ((PDRAWPATRECTP)pvIn)->pXFormObj;
            return DrawPatternRect(pdevobj, (PDRAWPATRECT)pvIn, pxo);
        }
#endif
        else if (cjIn == sizeof(SHORTDRAWPATRECT))
        {
            // Convert to a pattern rect and then draw
            DRAWPATRECT dpr;
            PSHORTDRAWPATRECT   psdpr = (PSHORTDRAWPATRECT)pvIn;
        
            //
            // Some apps (Access 2.0, AmiPro 3.1, etc.) do use the 16-bit
            // POINT version of DRAWPATRECT structure. Have to be compatible
            // with these apps.
            //
            dpr.ptPosition.x = (LONG)psdpr->ptPosition.x;
            dpr.ptPosition.y = (LONG)psdpr->ptPosition.y;
            dpr.ptSize.x = (LONG)psdpr->ptSize.x;
            dpr.ptSize.y = (LONG)psdpr->ptSize.y;
            dpr.wStyle  = psdpr->wStyle;
            dpr.wPattern = psdpr->wPattern;
        
            return DrawPatternRect(pdevobj, &dpr, NULL);
        }
        else
        {
            // invalid size
            return 1;
        }
    }
    else
    {
        EndHPGLSession(pdevobj);
        //
        // turn around to call Unidrv
        //
        return (((PFN_DrvEscape)(poempdev->pfnUnidrv[UD_DrvEscape])) (
                pso,
                iEsc,
                cjIn,
                pvIn,
                cjOut,
                pvOut));
    }
}

/////////////////////////////////////////////////////////////////////////////
// HPGLStartDoc
//
// Routine Description:
//
//  Handles DrvStartDoc.
//
// Arguments:
//
//   SURFOBJ pso - destination surface
//   PWSTR pwszDocName - document name
//   DWORD dwJobId - id of job
//
// Return Value:
//
//   BOOL: TRUE if successful, else FASLE.
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    )
{
    PDEVOBJ     pDevObj;
    POEMPDEV    poempdev;

    TERSE(("HPGLS tartDoc() entry.\r\n"));

    pDevObj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pDevObj));
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    //
    // set up the palettes for the CID command
    //
    poempdev->wInitCIDPalettes = 0;
    poempdev->wInitCIDPalettes |= PF_INIT_TEXT_STARTPAGE;
    poempdev->wInitCIDPalettes |= PF_INIT_TEXT_STARTDOC;
    poempdev->wInitCIDPalettes |= PF_INIT_RASTER_STARTPAGE;
    poempdev->wInitCIDPalettes |= PF_INIT_RASTER_STARTDOC;
    poempdev->CurrentROP3 = INVALID_ROP3;

    poempdev->bTextTransparencyMode = FALSE;
    poempdev->bTextAsBitmapMode = FALSE;


    HPGL_StartDoc(pDevObj);
    VGetStandardVariables (pDevObj);
    poempdev->wJobSetup |= PF_STARTDOC;
    poempdev->wJobSetup |= PF_STARTPAGE;
    return (((PFN_DrvStartDoc)(poempdev->pfnUnidrv[UD_DrvStartDoc])) (
                    pso,
                    pwszDocName,
                    dwJobId));
}


/////////////////////////////////////////////////////////////////////////////
// HPGLEndDoc
//
// Routine Description:
//
//  Handles DrvEndDoc.
//
// Arguments:
//
//   SURFOBJ pso - destination surface
//   FLONG fl - 
//
// Return Value:
//
//   BOOL: TRUE if successful, else FASLE.
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLEndDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    //
    // Change object type to RASTER
    //
    BChangeAndTrackObjectType(pdevobj, eRASTEROBJECT);

    //
    // Delete all downloaded patterns. 
    // 
    VDeleteAllPatterns(pdevobj);

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvEndDoc)(poempdev->pfnUnidrv[UD_DrvEndDoc])) (
            pso,
            fl));

}


/////////////////////////////////////////////////////////////////////////////
// HPGLNextBand
//
// Routine Description:
//
//  Handles DrvNextBand.  We ignore this since we aren't a banding driver.
//
// Arguments:
//
//   SURFOBJ pso - destination surface
//   POINTL pptl - 
//
// Return Value:
//
//   BOOL: TRUE if successful, else FASLE.
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLNextBand() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    //
    // Change object type to RASTER
    //
    BChangeAndTrackObjectType(pdevobj, eRASTEROBJECT);

    //
    // turn around to call Unidrv
    //
    return (((PFN_DrvNextBand)(poempdev->pfnUnidrv[UD_DrvNextBand])) (
            pso,
            pptl));

}


/////////////////////////////////////////////////////////////////////////////
// HPGLStartBanding
//
// Routine Description:
//
//  Handles DrvStartBanding.  We ignore this since we aren't a banding driver.
//
// Arguments:
//
//   SURFOBJ pso - destination surface
//   POINTL pptl - 
//
// Return Value:
//
//   BOOL: TRUE if successful, else FASLE.
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLStartBanding() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    //
    // Change object type to RASTER
    //
    BChangeAndTrackObjectType(pdevobj, eRASTEROBJECT);

    //
    // turn around to call Unidrv
    //
    return (((PFN_DrvStartBanding)(poempdev->pfnUnidrv[UD_DrvStartBanding])) (
            pso,
            pptl));


}


/////////////////////////////////////////////////////////////////////////////
// HPGLDitherColor
//
// Routine Description:
//
//  Handles DrvDitherColor.  But we don't.
//
// Arguments:
//
//   DHPDEV dhpdev - unknown
//   ULONG iMode - unknown
//   ULONG rgbColor - unknown
//   ULONG *pulDither - unknown
//
// Return Value:
//
//   ULONG: unknown.
/////////////////////////////////////////////////////////////////////////////
ULONG APIENTRY
HPGLDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    TERSE(("HPGLDitherColor() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    //
    // Change object type to RASTER
    //
    BChangeAndTrackObjectType(pdevobj, eRASTEROBJECT);

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvDitherColor)(poempdev->pfnUnidrv[UD_DrvDitherColor])) (
            dhpdev,
            iMode,
            rgbColor,
            pulDither));

}

#ifndef WINNT_40

/////////////////////////////////////////////////////////////////////////////
// HPGLTransparentBlt
//
// Routine Description:
//
//  Handles DrvTransparentBlt.  But we don't.
//
// Arguments:
//
//  SURFOBJ *psoDst - destination surface
//  SURFOBJ *psoSrc - source surface
//  CLIPOBJ *pco - clipping region
//  XLATEOBJ *pxlo - palette translation object
//  RECTL *prclDst - destination rectangle
//  RECTL *prclSrc - source rectangle
//  ULONG TransColor - unknown
//  ULONG ulReserved - unknown
//
// Return Value:
//
//   BOOL: TRUE for successful, else FALSE.
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      TransColor,
    ULONG      ulReserved
    )
{
    PDEVOBJ  pdevobj = NULL;
    BOOL     bRetVal = FALSE;
    TERSE(("HPGLTransparentBlt() entry.\r\n"));
    REQUIRE_VALID_DATA (psoDst , return FALSE);
    pdevobj = (PDEVOBJ)psoDst->dhpdev;


    bRetVal = EngTransparentBlt(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                prclSrc,
                TransColor,
                ulReserved
                );

    //
    // TransparentBlt can call some Drvxxx which can call into
    // some plugin module, which can overwrite our pdevOEM.
    // So we need to reset pdevOEM
    //
    BRevertToHPGLpdevOEM (pdevobj);

    return bRetVal;
    
}

#endif //ifndef WINNT_40


/////////////////////////////////////////////////////////////////////////////
// DrawPatternRect
//
// Routine Description:
//
//  Performs the DRAWPATTERNRECT escape.
//  Implementation of DRAWPATTERNECT escape. Note that it is PCL-specific.
//
//  I liberated this from unidrv2\control\escape.c
//  This version needs to be functionally equivalent. JFF
//
// Arguments:
//
//   pPDev    - the driver's PDEV
//   pPatRect - the DRAWPATRECT structure from the app
//   pxo      - the transform to apply to the points. Can be NULL.
//
// Return Value:
//
//   ULONG: 1 if successful, else 0
/////////////////////////////////////////////////////////////////////////////
ULONG
DrawPatternRect(
    PDEVOBJ      pDevObj,
    PDRAWPATRECT pPatRect,
    XFORMOBJ    *pxo
    )
{
    RECTL   rclDraw;
    ULONG   ulRes = 0;
    HPGLMARKER Brush;

    HPGL_LazyInit(pDevObj);

    // Convert the input points into a rectangle
    RECTL_SetRect(&rclDraw, pPatRect->ptPosition.x,
                            pPatRect->ptPosition.y,
                            pPatRect->ptPosition.x + pPatRect->ptSize.x,
                            pPatRect->ptPosition.y + pPatRect->ptSize.y);

    //
    // If the transform is present then apply it to the points. JFF 9/17/99
    //
    if (pxo)
    {
        POINTL PTOut[2], PTIn[2];
        PTIn[0].x = rclDraw.left;
        PTIn[0].y = rclDraw.top;
        PTIn[1].x = rclDraw.right;
        PTIn[1].y = rclDraw.bottom;
        if (!XFORMOBJ_bApplyXform(pxo,
                              XF_LTOL,
                              2,
                              PTIn,
                              PTOut))
        {
            ERR (("HPGLEscape(DRAWPATTERNRECT): XFORMOBJ_bApplyXform failed.\n"));
            return ulRes;
        }

        RECTL_SetRect(&rclDraw, PTOut[0].x, 
                                PTOut[0].y, 
                                PTOut[1].x, 
                                PTOut[1].y);

        // Make sure that rect is still well formed.
        if (rclDraw.left > rclDraw.right)
        {
            LONG temp = rclDraw.left;
            rclDraw.left = rclDraw.right;
            rclDraw.right = temp;
        }
        if (rclDraw.top > rclDraw.bottom)
        {
            LONG temp = rclDraw.top;
            rclDraw.top = rclDraw.bottom;
            rclDraw.bottom = temp;
        }
    }

    //BeginHPGLSession(pDevObj);

    // Make sure the clipping region is reset
    HPGL_ResetClippingRegion(pDevObj, NORMAL_UPDATE);

    // Reset line width to default.
    HPGL_SetLineWidth (pDevObj, 0, NORMAL_UPDATE);

    //
    // Draw the rectangle depending on the style.
    // First create the solid brush. Downloads the brush if needed - CreateSolidHPGLBrush ()
    // Then make that brush active. - FillWithBrush()
    // Then draw/fill rectangle using that brush. - HPGL_DrawRectangle ()
    //
    switch (pPatRect->wStyle)
    {
    case 0:
        //
        // Black fill
        //
        CreateSolidHPGLPenBrush(pDevObj, &Brush, RGB_BLACK);
        FillWithBrush(pDevObj, &Brush);
        HPGL_DrawRectangle(pDevObj, &rclDraw);
        ulRes = 1;
        break;

    case 1:
        //
        // White fill
        //
        CreateSolidHPGLPenBrush(pDevObj, &Brush, RGB_WHITE);
        FillWithBrush(pDevObj, &Brush);
        HPGL_DrawRectangle(pDevObj, &rclDraw);
        ulRes = 1;
        break;

    case 2:
        //
        // Percent black fill
        //
        CreatePercentFillHPGLPenBrush(pDevObj, &Brush, RGB_BLACK, pPatRect->wPattern);
        FillWithBrush(pDevObj, &Brush);
        HPGL_DrawRectangle(pDevObj, &rclDraw);
        ulRes = 1;
        break;

    default:
        // BUGBUG: Not supported. What should I do?
        ulRes = 1;
        break;
    }
    return ulRes;
}


/////////////////////////////////////////////////////////////////////////////
// VSendStartPageCommands
//
// Routine Description:
//
//  We used to send some start page commands.  Now the unidrv does it so we
//  keep this function around for fun.
//
// Arguments:
//
//   pDevObj - the DEVOBJ
//
// Return Value:
//
//   None.
/////////////////////////////////////////////////////////////////////////////
VOID
VSendStartPageCommands (
    PDEVOBJ pDevObj
)
{
    BYTE        bFlags = 0;
    REQUIRE_VALID_DATA( pDevObj, return );

    bFlags |= PF_FORCE_SOURCE_TRANSPARENCY;
    bFlags |= PF_FORCE_PATTERN_TRANSPARENCY;
    PCL_SelectTransparency(pDevObj, eOPAQUE, eOPAQUE, bFlags);
    PCL_SelectCurrentPattern(pDevObj, NULL, kSolidBlackFg, UNDEFINED_PATTERN_NUMBER, 0);

}


///////////////////////////////////////////////////////////////////////////////
// VSendStartDocCommands
//
// Routine Description:
// 
//   Sends the PCL to perform the job setup and initialize the printer.
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//
// Return Value:
// 
//   nothing.
///////////////////////////////////////////////////////////////////////////////
VOID
VSendStartDocCommands (
    PDEVOBJ pDevObj
)
{
    DWORD       dwRes;
    BYTE        bFlags = 0;
    PDEVMODE    pPublicDM;

    pPublicDM = pDevObj->pPublicDM;
    
#if 0 

    //
    // Get resolution
    //
    dwRes = HPGL_GetDeviceResolution (pDevObj);

    PCL_sprintf (pDevObj, "\033%%-12345X@PJL SET RESOLUTION=%d\012", dwRes);
    PCL_sprintf (pDevObj, "@PJL ENTER LANGUAGE=PCL\012");
    PCL_sprintf (pDevObj, "\033E");
    PCL_sprintf (pDevObj, "\033*t%dR", dwRes);
    PCL_sprintf (pDevObj, "\033&u%dD", dwRes);
    PCL_sprintf (pDevObj, "\033*r0F");

    //
    // Orientation
    //
    PCL_SelectOrientation (pDevObj, pPublicDM->dmOrientation);
    
    //
    // Paper source?? where do I get this field
    //
    PCL_SelectSource (pDevObj, pPublicDM);
    //PCL_sprintf (pDevObj, "\033&l1H");
    //
    // Page size, Line motion index, and top margin
    //  
    PCL_SelectPaperSize (pDevObj, pPublicDM->dmPaperSize);
    PCL_sprintf (pDevObj, "\033*p0x0Y");

    //
    // Picture frame anchor point, frame size in decipoints
    //
    PCL_SelectPictureFrame (pDevObj, pPublicDM->dmPaperSize, pPublicDM->dmOrientation);

    //
    // Copies
    //
    PCL_SelectCopies (pDevObj, pPublicDM->dmCopies);
 
    //
    // Mechanical print quality
    //
    PCL_sprintf (pDevObj, "\033*o0Q");

    //
    // Media type
    //
    PCL_sprintf (pDevObj, "\033&l0M");

    //
    // Compression method
    //
    //PCL_SelectCompressionMethod (pDevObj, 0);
    PCL_sprintf (pDevObj, "\033*b0M");

    bFlags |= PF_FORCE_SOURCE_TRANSPARENCY;
    bFlags |= PF_FORCE_PATTERN_TRANSPARENCY;
    PCL_SelectTransparency(pDevObj, eOPAQUE, eOPAQUE, bFlags);

#endif

}


///////////////////////////////////////////////////////////////////////////////
// VGetStandardVariables
//
// Routine Description:
// 
//   The unidrv uses a structure called the Standard Variables to store 
//   information that is used globally in the driver.  We use this function
//   to get information from the standard variables structure.
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//
// Return Value:
// 
//   nothing.
///////////////////////////////////////////////////////////////////////////////
VOID
VGetStandardVariables (
    PDEVOBJ pDevObj
)
{
    POEMPDEV   poempdev;
    DWORD      dwBuffer;
    DWORD      pcbNeeded;

    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA(poempdev, return);

    BOEMGetStandardVariable (pDevObj,
                             SVI_CURSORORIGINX,
                             &dwBuffer,
                             sizeof (dwBuffer),
                             &pcbNeeded);
    if (pcbNeeded > sizeof (dwBuffer))
    {
    }
    else
        poempdev->dwCursorOriginX = dwBuffer;


    BOEMGetStandardVariable (pDevObj,
                             SVI_CURSORORIGINY,
                             &dwBuffer,
                             sizeof (dwBuffer),
                             &pcbNeeded);
    if (pcbNeeded > sizeof (dwBuffer))
    {
    }
    else
        poempdev->dwCursorOriginY = dwBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\glenable.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.

Module Name:

    glenable.cpp

Abstract:

    Implementation of DDI exports.
        HPGLEnableDriver (optional)
        HPGLEnablePDEV (required)
        HPGLDisablePDEV (required)
        HPGLResetPDEV (optional)
        HPGLDisableDriver (optional)

Environment:

    Windows 2000/Whistler Unidrv driver

Revision History:

    04/12/2000 -hsingh-
        Created it.

--*/

#include "hpgl2col.h" //Precompiled header file

//
// If an OEM DLL hooks out any drawing DDI, it must export OEMEnableDriver which
// tells UNIDRV which functions it wants to hook. The following table is the
// maximum set of hooks. Note that an OEM DLL should not hook out OEMRealizeBrush
// unless it wants to draw graphics directly to the device surface.
//
// After integrating OEM dll into unidrv, all the OEMxxx functions have now changed
// to HPGLxxx. OEMEnableDriver does not need to be called, since this is no longer
// an extra plugin. But I am still maintaining this table cos it is used at a couple
// of places.
//
static DRVFN HPGLDrvHookFuncs[] = {
    { INDEX_DrvRealizeBrush,        (PFN) HPGLRealizeBrush        },
    { INDEX_DrvDitherColor,         (PFN) HPGLDitherColor         },
    { INDEX_DrvCopyBits,            (PFN) HPGLCopyBits            },
    { INDEX_DrvBitBlt,              (PFN) HPGLBitBlt              },
    { INDEX_DrvStretchBlt,          (PFN) HPGLStretchBlt          },
#ifndef WINNT_40
    { INDEX_DrvStretchBltROP,       (PFN) HPGLStretchBltROP       },
    { INDEX_DrvPlgBlt,              (PFN) HPGLPlgBlt              },
    { INDEX_DrvTransparentBlt,      (PFN) HPGLTransparentBlt      },
    { INDEX_DrvAlphaBlend,          (PFN) HPGLAlphaBlend          },
    { INDEX_DrvGradientFill,        (PFN) HPGLGradientFill        },
#endif
    { INDEX_DrvTextOut,             (PFN) HPGLTextOut             },
    { INDEX_DrvStrokePath,          (PFN) HPGLStrokePath          },
    { INDEX_DrvFillPath,            (PFN) HPGLFillPath            },
    { INDEX_DrvStrokeAndFillPath,   (PFN) HPGLStrokeAndFillPath   },
    { INDEX_DrvPaint,               (PFN) HPGLPaint               },
    { INDEX_DrvLineTo,              (PFN) HPGLLineTo              },
    { INDEX_DrvStartPage,           (PFN) HPGLStartPage           },
    { INDEX_DrvSendPage,            (PFN) HPGLSendPage            },
    { INDEX_DrvEscape,              (PFN) HPGLEscape              },
    { INDEX_DrvStartDoc,            (PFN) HPGLStartDoc            },
    { INDEX_DrvEndDoc,              (PFN) HPGLEndDoc              },
    { INDEX_DrvNextBand,            (PFN) HPGLNextBand            },
    { INDEX_DrvStartBanding,        (PFN) HPGLStartBanding        },
#ifdef HOOK_DEVICE_FONTS
    { INDEX_DrvQueryFont,           (PFN) HPGLQueryFont           },
    { INDEX_DrvQueryFontTree,       (PFN) HPGLQueryFontTree       },
    { INDEX_DrvQueryFontData,       (PFN) HPGLQueryFontData       },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) HPGLQueryAdvanceWidths  },
    { INDEX_DrvFontManagement,      (PFN) HPGLFontManagement      },
    { INDEX_DrvGetGlyphMode,        (PFN) HPGLGetGlyphMode        }
#endif

};


//
// Declaration of local functions.
//
BOOL bSetResolution(
                     PDEV    *pPDev,
                     OEMRESOLUTION *eOemResolution);

BOOL BFindWhetherColor(
            IN   PDEV  *pPDev
            );

///////////////////////////////////////////////////////////////////////////////
// HPGLEnablePDEV
//
// Routine Description:
//
//   This function handles the DrvEnablePDEV call.  We create our OEMPDEV and
//   return the pointer.
//
// Arguments:
//
//   pdevobj - the device
//   pPrinterName - the name of the printer model
//   cPatterns - number of elements in phsurfPatterns
//   phsurfPatterns - standard pattern-fill patterns UNUSED
//   cjGdiInfo - number of bytes in pGdiInfo
//   pGdiInfo - information passed back to GDI
//   cjDevInfo - number of bytes in pDevInfo
//   pDevInfo - information passed back to GDI
//   pded - enable data
//
// Return Value:
//
//   PDEVOEM: pointer to device-specific PDEV structure or NULL.
///////////////////////////////////////////////////////////////////////////////
PDEVOEM APIENTRY
HPGLEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    PFN         pfn;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;
    OEMRESOLUTION eOEMResolution;

    TERSE(("HPGLEnablePDEV() entry.\r\n"));

    if ( pdevobj == NULL )
    {
        return NULL;
    }
    //
    // Allocate the OEMDev
    //
    if (!(poempdev = (POEMPDEV) MemAlloc(sizeof(OEMPDEV))))
        return NULL;

    ZeroMemory ((PVOID)poempdev, sizeof (OEMPDEV));

    poempdev->dwSig = HPGLPDEV_SIG;
    //
    // Fill in OEMDEV
    //

    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        //
        // search through Unidrv's hooks and locate the function ptr
        //
        dwDDIIndex = HPGLDrvHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j >= 0; j--, pdrvfn++)  //dz added >=
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnUnidrv[i] = pdrvfn->pfn;
                break;
            }
        }
    }

    //
    // Set this to default. jff
    // May be I dont need to initialize all these fields for monochrome.
    // but i will have to spend some time checking it. So let me leave this for the
    // fine-tuning stage.
    //
    poempdev->eCurRenderLang = ePCL;
    poempdev->eCurObjectType = eNULLOBJECT;
    poempdev->CurrentROP3    = INVALID_ROP3;
    poempdev->eCurCIDPalette = eUnknownPalette;
    for (i = 0; i < PALETTE_MAX; i++)
    {
        poempdev->RasterState.PCLPattern.palData.ulPalCol[i] = HPGL_INVALID_COLOR;
    }
    poempdev->uCurFgColor = HPGL_INVALID_COLOR;

    //
    // The default transparency of the printer is
    // Source Transparent, Pattern Transparent
    // I initialize the source and pattern transparency to
    // OPAQUE because that is what the GPD sends down at
    // the beginning of the job.
    // Also initialize HPGL Transparency to 0
    //
    poempdev->CurSourceTransparency  = eOPAQUE;
    poempdev->CurPatternTransparency = eOPAQUE;
    poempdev->CurHPGLTransparency    = eOPAQUE;

    //
    // Make halftone and color control NOTSET so that they
    // will each be sent to the printer when first seen
    //
    poempdev->CurHalftone = HALFTONE_NOT_SET;
    poempdev->CurColorControl = COLORCONTROL_NOT_SET;

    //
    // By default use the unidrv brute-force functions.  If we're
    // actually being called by IHPCLJ5RenderCB::EnablePDEV it'll get
    // overrided later.
    //
    // poempdev->pUniProcs = new CDrvProcs(pdevobj->pDrvProcs);

    //
    // Set graphics capabilities. jff
    // We will OR in our settings with the UNIDRV ones.
    //

          pDevInfo->flGraphicsCaps =
                        GCAPS_SCREENPRECISION   |
                        GCAPS_FONT_RASTERIZER   |
                            GCAPS_BEZIERS       |
                            GCAPS_GEOMETRICWIDE |
                            GCAPS_ALTERNATEFILL |
                            GCAPS_WINDINGFILL   |
                            GCAPS_NUP           |
                            GCAPS_OPAQUERECT    |
                            GCAPS_COLOR_DITHER  |
                            GCAPS_HORIZSTRIKE   |
                            GCAPS_VERTSTRIKE    |
                            GCAPS_OPAQUERECT    |
                            GCAPS_HALFTONE;


    //
    // We don't want the engine to do any dithering for us. (JR)
    // Let the printer do the work instead.
    // Dimensions of dither brush are 0 x 0.
    //

    pDevInfo->cxDither      = pDevInfo->cyDither = 0;
    pDevInfo->iDitherFormat = BMF_24BPP;


    //
    // The very fact that this function is called indicates that the GraphicsMode has
    // been chosen as HP_GL/2 (either by the user, or just because it is the default).
    // Had user not chosen hp-gl/2, then HPGLInitVectorProcs would have returned NULL,
    // so this function would not have been called.
    // So we can set poempdev->UIGraphicsMode to HPGL2.
    // The printer Model is being hardcoded to HPC4500. At quite a few places within the code
    // that was written for the color driver, there are checks on whether the printer model is
    // HP CLJ 4500 or HPCLJ. We want the code path of HP CLJ 4500 to be executed, therefore
    // we are hardcoding it here. I dont want to change that check in other places in the
    // code, cos eventually the color part will be integrated, and that check will have to
    // be put back.
    //
    poempdev->UIGraphicsMode = HPGL2;
    poempdev->PrinterModel   = HPC4500;

    //
    // Create a palette--even for 24-bit color.  The colors sent back should
    // be represented as color values--not as indexes. jff
    //

    if ( poempdev->UIGraphicsMode == HPGL2)
    {
        poempdev->hOEMPalette = pDevInfo->hpalDefault = EngCreatePalette(PAL_RGB, 0, NULL, 0, 0, 0);
        poempdev->iPalType    = PAL_RGB;
    }
    else
    {
        poempdev->hOEMPalette = 0;
        poempdev->iPalType    = PAL_INDEXED;
    }


    //
    // Get the resolution from the GPD. If we cant get it, set it to
    // default of 600 dpi
    //
    if ( !bSetResolution ((PDEV*) pdevobj, &(poempdev->dmResolution) ) )
    {
        //
        // Set it to default one.
        //
        poempdev->dmResolution   = PDM_600DPI;
    }

    //
    // Find out whether the printer is a color printer.
    //
    poempdev->bColorPrinter = BFindWhetherColor( (PDEV*) pdevobj );


    //
    // Setting specific to whether the printer is a color printer.
    //
    if ( ! poempdev->bColorPrinter )
    {
        //
        // By setting this flag, GDI gives images that we can straightaway send to printer
        // without needing to invert. But the pattern brush that GDI gives us have to be inverted.
        // This creates an ambiguous situation cos it becomes difficult for driver to
        // determine when it needs to invert and when not. Therefore not setting
        // this flag.
        //    pGdiInfo->flHTFlags |= HT_FLAG_OUTPUT_CMY;  //b/w bits flipping.

        //
        // Also tell GDI that when we ask it to halftone an image, the resulting image
        // should be 1bpp.
        //
        pGdiInfo->ulHTOutputFormat = HT_FORMAT_1BPP;

    } //if printer is not color

    //
    // Set the nup value.
    //
    poempdev->ulNupCompr = 1; //Default
    if ( ((PDEV *)pdevobj)->pdmPrivate )
    {
        //
        // Lets initialize the ulNupCompr field according to what
        // n-up we are printing at.
        //
        switch ( ((PDEV *)pdevobj)->pdmPrivate->iLayout )
        {
            case TWO_UP :
            case FOUR_UP :
                poempdev->ulNupCompr = 2;
                break;
            case SIX_UP :
            case NINE_UP :
                poempdev->ulNupCompr = 3;
                break;
            case SIXTEEN_UP :
                poempdev->ulNupCompr = 4;
                break;
            default:
                poempdev->ulNupCompr = 1;
        }
    }


    //
    // Initialize BrushCache in brshcach.h.
    //
    poempdev->pBrushCache    = new BrushCache;
    poempdev->pPCLBrushCache = new BrushCache;

    if ( ! (poempdev->pBrushCache && poempdev->pPCLBrushCache )  ||
         ! (poempdev->pBrushCache->BIsValid() && poempdev->pPCLBrushCache->BIsValid() )
       )
    {
        //
        // It is possible that one of the above got allocated but not the other.
        //
        if ( poempdev->pBrushCache )
        {
            delete poempdev->pBrushCache;
            poempdev->pBrushCache = NULL;
        }
        if ( poempdev->pPCLBrushCache )
        {
            delete poempdev->pPCLBrushCache;
            poempdev->pPCLBrushCache = NULL;
        }

        if (poempdev->hOEMPalette)
        {
            EngDeletePalette(poempdev->hOEMPalette);
            poempdev->hOEMPalette = NULL;
        }

        MemFree(poempdev);
        poempdev = NULL;
        return NULL;
    }

    return (POEMPDEV) poempdev;
}


///////////////////////////////////////////////////////////////////////////////
// HPGLDisablePDEV
//
// Routine Description:
//
//   This function handles the DrvDisablePDEV call.  We destroy our OEMPDEV
//   and any memory that it may have been pointing to.
//
// Arguments:
//
//   pdevobj - the device
//
// Return Value:
//
//   None
///////////////////////////////////////////////////////////////////////////////
VOID APIENTRY HPGLDisablePDEV(
    PDEVOBJ pdevobj
    )
{

    ASSERT(VALID_PDEVOBJ(pdevobj));

    POEMPDEV poempdev = (POEMPDEV) pdevobj->pdevOEM;

    if ( !poempdev)
    {
        return;
    }

    //
    // Free the objects stored in poempdev
    //
    // delete poempdev->pUniProcs;

    if (poempdev->hOEMPalette)
    {
        EngDeletePalette(poempdev->hOEMPalette);
        poempdev->hOEMPalette = NULL;
    }
    //
    // Delete BrushCache
    //
    if ( poempdev->pBrushCache )
    {
        delete poempdev->pBrushCache;
        poempdev->pBrushCache = NULL;
    }
    if ( poempdev->pPCLBrushCache )
    {
        delete poempdev->pPCLBrushCache;
        poempdev->pPCLBrushCache = NULL;
    }


    //
    // free memory for OEMPDEV and any memory block it allocates.
    //
    MemFree(pdevobj->pdevOEM);

}

///////////////////////////////////////////////////////////////////////////////
// HPGLResetPDEV
//
// Routine Description:
//
//   This function handles the DrvResetPDEV call.  We are given an opportunity
//   to move information from the old PDEV to the new one.
//
// Arguments:
//
//   pdevobjOld - the old device
//   pdevobjNew - the new device
//
// Return Value:
//
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY HPGLResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{

    ASSERT(VALID_PDEVOBJ(pdevobjOld) && pdevobjOld->pdevOEM);
    ASSERT(VALID_PDEVOBJ(pdevobjNew) && pdevobjOld->pdevOEM);

    //
    // if you want to carry over anything from old pdev to new pdev, do it here.
    //
    /*
    POEMPDEV poempdevOld = (POEMPDEV) pdevobjOld->pdevOEM;
    POEMPDEV poempdevNew = (POEMPDEV) pdevobjNew->pdevOEM;

    if (poempdevNew->pUniProcs)
        delete poempdevNew->pUniProcs;

    poempdevNew->pUniProcs = poempdevOld->pUniProcs;
    poempdevOld->pUniProcs = NULL;
    */

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGLDisableDriver
//
// Routine Description:
//
//   This function handles the DrvDisableDriver call.
//
// Arguments:
//
//   None.
//
// Return Value:
//
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID APIENTRY HPGLDisableDriver(VOID)
{
//dz    DbgPrint(DLLTEXT("HPGLDisableDriver() entry.\r\n"));
}


/*++
Routine Name:
    bSetResolution

Routine Description:
    Finds whether 300 dpi or 600 dpi is being used. Accordingly sets the
    eOEMResolution.


Arguments:
     pPDev          : Pointer to Unidrv's PDEV
     eOEMResolution : At exit time, this is PDM_600DPI or PDM_300DPI
                      depending on the resolution.


Return Value:
    TRUE : If resolution could be found.
    FALSE: otherwise : eOEMResolution not changed.

Last Error:
    Not changed.

--*/

BOOL bSetResolution(
            IN   PDEV          *pPDev,
            OUT  OEMRESOLUTION *eOEMResolution
            )
{
    BOOL bRetValue = TRUE;

    ASSERT(pPDev);
    ASSERT(eOEMResolution);

    if (!pPDev->pResolutionEx)
    {
        return FALSE;
    }

    //
    // Lets find the resolution from the pResolutionEx structure in the pdev.
    // Unidrv has already done the work of looking at gpd and extracting the value.
    // So I dont need to repeat that work here.
    //
    // Assuming that the resolution in both x and y directions is same.
    //
    if ( (pPDev->pResolutionEx->ptGrxDPI).x == 1200 )
    {
        *eOEMResolution = PDM_1200DPI;
    }
    else if ( (pPDev->pResolutionEx->ptGrxDPI).x == 600 )
    {
        *eOEMResolution = PDM_600DPI;
    }
    else if ( (pPDev->pResolutionEx->ptGrxDPI).x == 300 )
    {
        *eOEMResolution = PDM_300DPI;
    }
    else
    {
        //
        // Any value other than 1200dpi, 600dpi or 300dpi is not supported. Return FALSE
        //
        bRetValue = FALSE;
    }
    return bRetValue;
}


/*++
Routine Name:
    BFindWhetherColor

Routine Description:
    Finds whether the printer is color based on the gpd.


Arguments:
     pPDev          : Pointer to Unidrv's PDEV


Return Value:
    TRUE : If the device's gpd indicates the printer is color.
    FALSE: otherwise :

Last Error:
    Not changed.

--*/

BOOL BFindWhetherColor(
            IN   PDEV    *pPDev
            )
{
    BOOL bRetValue = TRUE;
    PCOLORMODEEX pColorModeEx;

    ASSERT(pPDev);

    if ( (pColorModeEx = pPDev->pColorModeEx) && //single '=' is intentional
          TRUE == (pColorModeEx->bColor) ) 
    {
        //
        // Do we need to do any more tests ????
        // For now. NO
        //
    }
    else
    {
        bRetValue = FALSE;
    }

    return bRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\glraster.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999-2001 Microsoft Corporation
// All rights reserved.
//
// Module Name:
//  
//   glraster.cpp
//
// Abstract:
//
//    Implementation of OEM DDI hooks (all drawing DDI hooks)
//
// Environment:
//
//    Windows 2000 Unidrv driver
//
///////////////////////////////////////////////////////////////////////////////


#include "hpgl2col.h" //Precompiled header file


EColorSpace
EGetPrinterColorSpace (
    PDEVOBJ pDevObj
    );

BOOL ClipBitmapWithComplexClip(
        IN  PDEVOBJ    pdevobj,
        IN  SURFOBJ   *psoSrc,
        IN  BRUSHOBJ  *pbo,
        IN  POINTL    *pptlDst,
        IN  SIZEL     *psizlDst,
        IN  POINTL    *pptlSrc,
        IN  SIZEL     *psizlSrc,
        IN  CLIPOBJ   *pco,
        IN  XLATEOBJ  *pxlo,
        IN  POINTL    *pptlBrush);

BOOL ClipBitmapWithRectangularClip(
        IN  PDEVOBJ    pdevobj,
        IN  SURFOBJ   *psoSrc,
        IN  BRUSHOBJ  *pbo,
        IN  POINTL    *pptlDst,
        IN  SIZEL     *psizlDst,
        IN  POINTL    *pptlSrc,
        IN  SIZEL     *psizlSrc,
        IN  CLIPOBJ   *pco,
        IN  XLATEOBJ  *pxlo,
        IN  POINTL    *pptlBrush);

DWORD DWColorPrinterCommonRoutine (
           IN SURFOBJ    *psoDst,
           IN SURFOBJ    *psoSrc,
           IN SURFOBJ    *psoMask,
           IN CLIPOBJ    *pco,
           IN XLATEOBJ   *pxlo,
           IN COLORADJUSTMENT *pca,
           IN BRUSHOBJ   *pbo,
           IN RECTL      *prclSrc,
           IN RECTL      *prclDst,
           IN POINTL     *pptlMask,
           IN POINTL     *pptlBrush,
           IN ROP4        rop4,
           IN DWORD       dwSimplifiedRop);
 
VOID
VMakeWellOrdered(
        IN  PRECTL prectl
);

DWORD dwConvertRop3ToCMY(
            IN DWORD rop3);

DWORD
dwSimplifyROP(
        IN  SURFOBJ    *psoSrc,
        IN  ROP4        rop4,
        OUT PDWORD      pdwSimplifiedRop);

//
// Function Definitions.
//

/*++

Routine Name:
    BChangeAndTrackObjectType 

Routine Description:
    Three main object types are there HPGL Object, Text Object and
    Raster Object. These have different default settings (like  
    transparency modes) or different rendering language (HPGL for HPGL
    object, PCL or Text and Raster Object). This function keeps track
    for the current object type and send commands that shifts between
    the object types. It finishes the effect of the previous object type
    and sets environment according to new object type.

Arguments: 
    pdevobj         : The device's pdevobj. 
    eNewObjectType  :  The object type to which to change the printer
            environment to.


Return Value:
    TRUE  : if succesful.
    FALSE : otherwise.

Last Error:

--*/

BOOL BChangeAndTrackObjectType (
            IN  PDEVOBJ     pdevobj,
            IN  EObjectType eNewObjectType )
{
    BOOL     bRetVal  = TRUE;
    POEMPDEV poempdev = NULL;

    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA ( poempdev, return FALSE);

    //
    // If the new object is same as the one currently active
    // then no need to do anything.
    //
    if (poempdev->eCurObjectType == eNewObjectType )
    {
        return TRUE;
    }

    //
    // An object change invalidates the fg color. So lets 
    // reset it.
    //
    poempdev->uCurFgColor = INVALID_COLOR;

    //
    // Now send settings according to the new object.
    //
    if ( eNewObjectType == eHPGLOBJECT)
    {
        //
        // SendGraphicsSettings sets halftone algorithm and sends
        // color control commands in PCL mode. Therefore calling this
        // function before going to HP-GL/2 mode. 
        //
        SendGraphicsSettings(pdevobj);
        if ( (bRetVal = BeginHPGLSession(pdevobj)) )
        {
            poempdev->eCurObjectType = eHPGLOBJECT;
        }
    }

    else if ( eNewObjectType == eTEXTOBJECT || eNewObjectType == eTEXTASRASTEROBJECT )
    {

        if ( (bRetVal = EndHPGLSession (pdevobj)))
        {
            if (  poempdev->eCurObjectType == eTEXTOBJECT ||
                  poempdev->eCurObjectType == eTEXTASRASTEROBJECT )
            {
                VERBOSE ( ("Nothing to change because previous object is text object too\n"));
            }
            else
            {
                PCL_SelectTransparency(pdevobj, eTRANSPARENT, eOPAQUE, 0);
                VSendTextSettings(pdevobj);
            }
            poempdev->eCurObjectType = eNewObjectType;
        }
    }

    else if ( eNewObjectType == eRASTEROBJECT )
    {
        if ( (bRetVal = EndHPGLSession (pdevobj)))
        {
            //
            // For images to print, the Source & Pattern Transparency modes both
            // should be opaque. But in cases when DrvBitBlt is called for 
            // TextOutAsBitmap, then the source transparency mode should be Transparent
            // and not Opaque. The correct value in this case is set in HPGLTextOutAsBitmap.
            // So here, we only update if we are printing true images.
            // While printing text as graphics, we print text in transparency mode.
            //
            if (poempdev->bTextTransparencyMode == FALSE)
            {
                PCL_SelectTransparency(pdevobj,eOPAQUE, eOPAQUE, 0);
                poempdev->eCurObjectType = eRASTEROBJECT;
            }
            else
            {
                VERBOSE ( ("Not changing to eRASTEROBJECT because printing text as graphics\n"));
            }
            VSendPhotosSettings(pdevobj);
        }
    }

    //else if ( eNewObjectType == eRASTERPATTERNOBJECT )  // Not used as of now.

    return bRetVal;
}




/////////////////////////////////////////////////////////////////////////////
// HPGLBitBlt
//
// Routine Description:
//   Entry point from GDI to draw bitmaps.
//
// Arguments:
//
//   psoDst - points to target surface.
//   psoSrc - points to the source surface
//   psoMask - surface to be used as a mask for the rop4
//   pco - clip region
//   pxlo - specifies how color indices should be translated between
//          the source and target
//   prclDst - RECTL structure that defines area to be modified
//   pptlSrc - upper left of source 
//   pptlMask - which pixel in the mask corresponds to the upper left
//              corner of the source rectangle
//   pbo - brush object that defines the pattern
//   pptlBrush - origin of brush in destination
//   rop4 - raster operation
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLBitBlt(
    SURFOBJ        *psoDst,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDst,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    )
{
    RECTL       rclSrc;
    DWORD       dwRasterOpReturn = RASTER_OP_FAILED;
    BOOL        bRetVal = TRUE;
    PDEVOBJ     pdevobj = NULL;
    
    
    TERSE(("HPGLBitBlt() entry.\r\n"));

    REQUIRE_VALID_DATA ((psoDst && prclDst), return FALSE);
    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    ASSERT_VALID_PDEVOBJ(pdevobj);
    

    //
    // Initialize the source rectangle.
    //
    if (pptlSrc) {

        rclSrc.left = pptlSrc->x;
        rclSrc.top  = pptlSrc->y;

    } else {

        rclSrc.left =
        rclSrc.top  = 0;
    }

    //
    // Since this is a bitblt and not a stretchBlt, the source and destination
    // rectangle size are same.
    //
    rclSrc.right  = rclSrc.left + (prclDst->right - prclDst->left);
    rclSrc.bottom = rclSrc.top  + (prclDst->bottom - prclDst->top);

    dwRasterOpReturn = dwCommonROPBlt (
                                         psoDst,
                                         psoSrc,
                                         psoMask,
                                         pco,
                                         pxlo,
                                         NULL,       // pca,
                                         pbo,
                                         &rclSrc,
                                         prclDst,
                                         pptlMask,
                                         pptlBrush,
                                         rop4);

    bRetVal = (dwRasterOpReturn == RASTER_OP_SUCCESS) ? TRUE : FALSE;

    if (dwRasterOpReturn == RASTER_OP_CALL_GDI)
    {
        WARNING(("HPGLBitBlt: Calling EngBitBlt()\n"));
        bRetVal = EngBitBlt(psoDst,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         prclDst,
                         pptlSrc,
                         pptlMask,
                         pbo,
                         pptlBrush,
                         rop4);
    }

    //
    // EngBitBlt can call some Drvxxx which can call into 
    // some plugin module, which can overwrite our pdevOEM.
    // So we need to reset pdevOEM
    //
    BRevertToHPGLpdevOEM (pdevobj);

    if (bRetVal == FALSE )
    {
        ERR(("HPGLBitBlt: Returning Failure\n"));
    }
    return bRetVal;

}

/////////////////////////////////////////////////////////////////////////////
// HPGLStretchBlt
//
// Routine Description:
//   Entry point from GDI to scale and draw bitmaps.
//
// Arguments:
//
//   psoDst - Target surface
//   psoSrc - Source surface
//   psoMask - mask
//   pco - Clipping region
//   pxlo - Color translation obj
//   pca - Color adjustment (I think we ignore this)
//   pptlHTOrg - unknown (ignored?)
//   prclDst - Dest rect
//   prclSrc - source rect
//   pptlMask - mask starting point
//   iMode - unknown (ignored?)
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    PDEVOBJ     pdevobj;
    DWORD       dwRasterOpReturn;
    BOOL        bRetVal = TRUE;
    
    TERSE(("HPGLStretchBlt() entry.\r\n"));
    
    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    ASSERT_VALID_PDEVOBJ(pdevobj);

    dwRasterOpReturn = dwCommonROPBlt (
                                            psoDst,
                                            psoSrc,
                                            psoMask,
                                            pco,
                                            pxlo,
                                            pca,
                                            NULL,         // pbo
                                            prclSrc,
                                            prclDst,
                                            pptlMask,
                                            NULL,         // pptlBrush,
                                            ROP4_SRC_COPY // rop4; 0xCC = SRC_COPY
                                           );

    bRetVal = (dwRasterOpReturn == RASTER_OP_SUCCESS) ? TRUE : FALSE;

    if (dwRasterOpReturn == RASTER_OP_CALL_GDI)
    {
        WARNING(("HPGLStretchBlt: Calling EngStretchBlt()\n"));
        bRetVal = EngStretchBlt(psoDst,
                             psoSrc,
                             psoMask,
                             pco,
                             pxlo,
                             pca,
                             pptlHTOrg,
                             prclDst,
                             prclSrc,
                             pptlMask,
                             BIsColorPrinter(pdevobj) ? iMode : HALFTONE
                             ); 
    }

    //
    // EngStretchBlt can call some Drvxxx which can call into
    // some plugin module, which can overwrite our pdevOEM.
    // So we need to reset pdevOEM
    //
    BRevertToHPGLpdevOEM (pdevobj);

    if (bRetVal == FALSE )
    {
        ERR(("HPGLStretchBlt: Returning Failure\n"));
    }
    return bRetVal;
}

#ifndef WINNT_40

/////////////////////////////////////////////////////////////////////////////
// HPGLStretchBltROP
//
// Routine Description:
//   Entry point from GDI to scale and draw bitmaps.
//
// Arguments:
//
//   psoDst - Destination surface
//   psoSrc - source surface
//   psoMask - mask
//   pco - clipping region
//   pxlo - color translation obj
//   pca - color adjustment (ignored?)
//   pptlHTOrg - unknown (ignored?)
//   prclDst - destination rectangle
//   prclSrc - source rectangle
//   pptlMask - mask offset point
//   iMode - unknown (ignored?)
//   pbo - brush object (for color or palette)
//   rop4 - ROP codes
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    )
{
    PDEVOBJ     pdevobj;
    DWORD       dwRasterOpReturn ;
    BOOL        bRetVal = TRUE;
    
    
    TERSE(("HPGLStretchBltROP() entry.\r\n"));
    
    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    
    dwRasterOpReturn = dwCommonROPBlt (
                                        psoDst,
                                        psoSrc,
                                        psoMask,
                                        pco,
                                        pxlo,
                                        pca,
                                        pbo,
                                        prclSrc,
                                        prclDst,
                                        pptlMask,
                                        NULL,   
                                        rop4
                                        );

    bRetVal = (dwRasterOpReturn == RASTER_OP_SUCCESS) ? TRUE : FALSE;

    if (dwRasterOpReturn == RASTER_OP_CALL_GDI)
    {
        WARNING(("HPGLStretchBltROP: Calling EngStretchBltROP()\n"));
        bRetVal = EngStretchBltROP(psoDst,
                                psoSrc,
                                psoMask,
                                pco,
                                pxlo,
                                pca,
                                pptlHTOrg,
                                prclDst,
                                prclSrc,
                                pptlMask,
                                BIsColorPrinter(pdevobj) ? iMode : HALFTONE,   
                                pbo,
                                rop4        
                                );
    }

    //
    // EngStretchBltROP can call some Drvxxx which can call into
    // some plugin module, which can overwrite our pdevOEM.
    // So we need to reset pdevOEM
    //
    BRevertToHPGLpdevOEM (pdevobj);

    if (bRetVal == FALSE )
    {
        ERR(("HPGLStretchBltROP: Returning Failure\n"));
    }
    return bRetVal;
}
#endif // ifndef WINNT_40

/////////////////////////////////////////////////////////////////////////////
// HPGLCopyBits
//
// Routine Description:
//   Entry point from GDI to draw bitmaps.
//
// Arguments:
//
//   psoDst - target surface
//   psoSrc - source surface
//   pco - clipping region
//   pxlo - color transation object
//   prclDst - destination rect
//   pptlSrc - source rect
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLCopyBits(
    SURFOBJ        *psoDst,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDst,
    POINTL         *pptlSrc
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev = NULL;
    BOOL        bRetVal = TRUE;
    PDEV       *pPDev   = NULL;
    
    TERSE(("HPGLCopyBits() entry.\r\n"));
    
    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    REQUIRE_VALID_DATA( (pdevobj && prclDst), return FALSE);
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );
    pPDev = (PDEV *)pdevobj;

    
    if ( BIsColorPrinter(pdevobj) )
    {
        //
        // Set the source rectangle size. The top left corners are either (pptlSrc->x, pptlSrc->y)
        // or (0,0). The length and width is same as that of destination rectangle.
        //
        RECTL rclSrc;
        if (pptlSrc) {

            rclSrc.left = pptlSrc->x;
            rclSrc.top  = pptlSrc->y;

        } else {

            rclSrc.left =
            rclSrc.top  = 0;
        }
        //
        // Since this is CopyBit and not a stretchBlt, the source and destination
        // rectangle size is same.
        //
        rclSrc.right  = rclSrc.left + (prclDst->right - prclDst->left);
        rclSrc.bottom = rclSrc.top  + (prclDst->bottom - prclDst->top);

        DWORD dwRasterOpReturn = dwCommonROPBlt (
                                        psoDst,
                                        psoSrc,
                                        NULL,
                                        pco,
                                        pxlo,
                                        NULL,         // pca,
                                        NULL,         // pbo,
                                        &rclSrc,
                                        prclDst,
                                        NULL,         // pptlMask
                                        NULL,         // pptlBrush,
                                        ROP4_SRC_COPY // rop4 0xCCCC = SRC_COPY
                                        );

        bRetVal = (dwRasterOpReturn == RASTER_OP_SUCCESS) ? TRUE : FALSE;
    }
    else
    {
        //
        // There are quite a few things to be done here. So let me just
        // call HTCopyBits instead of cluttering up this function.
        // 
        BChangeAndTrackObjectType (pdevobj, eRASTEROBJECT);

        //
        // HPGLCopy Bits can be called directly by GDI. 
        // We can also make GDI call it indirectly. e.g. When
        // we get a color bitmap (like in a DrvStretchBlt call), 
        // we call GDI to halftone it to monochrome. Then GDI calls 
        // CopyBits and gives us the halftoned bitmap. (recognized 
        // by PDEVF_RENDER_IN_COPYBITS flag). In this indirect method, 
        // we dont want to send a new ROP. The ROP sent during the 
        // previous DDI should be used.  
        // Similarly when we get a color brush and we have to halftone it, 
        // GDI calls DrvCopyBits. (recognized by the presence of 
        // poempdev->psoHTBlt)
        //

        if ( !( (poempdev->dwFlags & PDEVF_RENDER_IN_COPYBITS)  || 
                (poempdev->psoHTBlt)  )
           )
        {
            SelectROP4(pdevobj, ROP4_SRC_COPY);
        }

        //
        // If unidrv has whitened the surface, then we should render it
        // transparently.
        //
        if (pPDev->fMode2     & PF2_SURFACE_WHITENED &&
            poempdev->dwFlags & PDEVF_RENDER_TRANSPARENT)
        {
            PCL_SelectTransparency(pdevobj, eTRANSPARENT, eOPAQUE, PF_NOCHANGE_PATTERN_TRANSPARENCY);
        }

        bRetVal = HTCopyBits(psoDst,
                            psoSrc,
                            pco,
                            pxlo,
                            prclDst,
                            pptlSrc);
    }

    if (bRetVal == FALSE )
    {
        ERR(("HPGLCopyBits: Returning Failure\n"));
    }
    return bRetVal;
}



/*++

Routine Name:
    dwCommonROPBlt

Routine Description:
    This function has the functionality that is superset of the functionality of
    HPGLStretchBlt, StretchBltROP and BitBlt and CopyBits. Therefore, all these functions
    call it do their work. 
    Note: This function works for color printer. This makes it different from 
          dwCommonROPBlt which works for Monochrome printers.

Arguments:
    psoDst:
    psoSrc:
    psoMask:
    pco:
    pxlo:
    pca:
    pbo:
    prclSrc:
    prclDst: ... Note that the coordinates may not be well-ordered. i.e. it is possible
                 that top > bottom, and/or left > right.
    pptlBrush:
    rop4


Return Value:
    RASTER_OP_SUCCESS   : if OK
    RASTER_OP_CALL_GDI  : if rop not supported ->call corresponding Engxxx-function
    RASTER_OP_FAILED    : if error

Last Error:

--*/
DWORD dwCommonROPBlt (
            IN SURFOBJ    *psoDst,
            IN SURFOBJ    *psoSrc,
            IN SURFOBJ    *psoMask,
            IN CLIPOBJ    *pco,
            IN XLATEOBJ   *pxlo,
            IN COLORADJUSTMENT *pca,
            IN BRUSHOBJ   *pbo,
            IN RECTL      *prclSrc,
            IN RECTL      *prclDst,
            IN POINTL     *pptlMask,
            IN POINTL     *pptlBrush,
            IN ROP4        rop4)
{
    PDEVOBJ     pdevobj  = NULL;
    POEMPDEV    poempdev = NULL;
    PDEV       *pPDev    = NULL;
    DWORD       dwRasterOpReturn = RASTER_OP_SUCCESS;
    DWORD       dwSimplifiedRop = 0;
    DWORD       dwfgRop3, dwbkRop3;


    TERSE(("dwCommonROPBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    REQUIRE_VALID_DATA(pdevobj, return FALSE);
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( (poempdev && prclDst), return RASTER_OP_FAILED );
    pPDev = (PDEV *)pdevobj;

    //
    // Check for recursion. We do it only for monochrome printers.
    // For color printers, unidrv makes sure we dont recurse.
    // But for monochrome, we fudge the unidrv mechanism to allow CopyBits to
    // be called recursively. (For reasons, read the comment in HTCopyBits)
    // So we check for recursion here
    //
    if ( !BIsColorPrinter(pdevobj) )
    {
        if ( poempdev->lRecursionLevel >= 2 )
        {
        //        ASSERT (FALSE);
            return RASTER_OP_FAILED;
        }

        (poempdev->lRecursionLevel)++;
    }

    //
    // Since the coordinates in the prclDst may/may not be well-ordered, lets
    // do the check here.
    //
    VMakeWellOrdered(prclDst);


    //
    // dwSimplifyROP makes a best effort attempt to simplify the complex rop4 that we receive.
    // RASTER_OP_SUCCESS   : if rop could be simplified or we can use a simple rop as a close
    //                       approximation of the complex rop.
    //                       Simplified ROP put in dwSimplifiedRop
    // RASTER_OP_CALL_GDI  : if rop not supported (indicates call corresponding Engxxx-function)
    // RASTER_OP_FAILED    : if error
    //

    if ( RASTER_OP_SUCCESS !=
                (dwRasterOpReturn = dwSimplifyROP(psoSrc, rop4, &dwSimplifiedRop)) )
    {
        goto finish;
    }

    //
    // If we reach here, it means there was a ROP that we can handle.
    //

    if (dwSimplifiedRop == BMPFLAG_NOOP)      // Nothing to do.
    {
        goto finish;
    }
    
    dwfgRop3 = GET_FOREGROUND_ROP3(rop4);
    dwbkRop3 = GET_BACKGROUND_ROP3(rop4);

    //
    // HOW WE TRACK THE CURRENT OBJECT TYPE AND HOW WE HANDLE VARIOUS ROP TYPES:
    // ----------------------------------------------------------------------------
    // CommonROPBlt is the common drawing function. Depending on the type of ROP
    // and certain other factors, there are a few options here.
    //  1) ROP says fill destination with black or white: Call BPatternFill to do it.
    //  2) ROP says Pattern Copy : some pattern (in pbo) has to be transferred to destination
    //      For this we call BPatternFill.
    //  For 1,2 : BPatternFill tracks the current object type, so we wont do it here.
    //  3) ROP indicates Pattern And Source Interaction.
    //      poempdev->eCurObjectType = eRASTEROBJECT
    //      I could have also set it to eRASTERPATTERNOBJECT, but at this time, I cannot think
    //      of anything different to be done in the two cases. So just set to eRASTEROBJECT.
    //  4) ROP says source copy (psoSrc) : Generally means image has to be printed.
    //      a) When BitBlt is called from TextOutAsBitmap. : Dont change the current object type.
    //         in HPGLTextOutAsBitmap, the correct environment (transaprencies etc..) have
    //         been set, so no need to change it here. When text is printed as graphics,
    //         we want both source and pattern transparency modes to be transparent.
    //      b) When image has to be printed. : Set poempdev->eCurObjectType = eRASTEROBJECT.
    //         Change the environment settings as appropriate.
    //         For true images, select the Source Transparency mode to Opaque. It means that
    //         the white pixels of the source image (the one that we will print now) will
    //         whiten out the corresponding pixles in the destination.
    //         CRUDELY, this can be interpreted as - the source image will overwrite whatever is
    //         there on the destination. ROPs can change this behavior though.
    //


    //
    // Now comes the actual printing part....

    if ( (dwSimplifiedRop & BMPFLAG_BW)         ||
         (dwSimplifiedRop & BMPFLAG_NOT_DEST)   ||
         ( (dwSimplifiedRop & BMPFLAG_PAT_COPY) &&
          !(dwSimplifiedRop & BMPFLAG_SRC_COPY) 
         )
       )
    {  
        BRUSHOBJ SolidBrush;
        BRUSHOBJ *pBrushObj = NULL;

        if  (dwSimplifiedRop & BMPFLAG_BW || pbo == NULL) 
        {
            //
            // Fill the destination surface with either black or white color.
            // Create a fake BRUSHOBJ whose iSolidColor is black or white and pass it
            // to BPatternFill
            //
  
            ZeroMemory(&SolidBrush, sizeof(BRUSHOBJ));
            if (dwfgRop3 == 0xFF) // White fill.
            {
                SolidBrush.iSolidColor = RGB_WHITE; //0x00FFFFFF
            }
            else
            {
                SolidBrush.iSolidColor = RGB_BLACK; //0x0
            }
            
            pBrushObj = &SolidBrush;
           
        }
        else
        {
            pBrushObj = pbo;
        } 

        //
        // This is to be drawn as HPGL Object.
        // BPatternFill initializes HPGL mode and selects the appropriate ROP.
        //
        dwRasterOpReturn = BPatternFill (
                                pdevobj,
                                prclDst,
                                pco,
                                rop4,         
                                pBrushObj,
                                NULL        
                            ) ? RASTER_OP_SUCCESS : RASTER_OP_FAILED;

        goto finish;

    }

    //
    // In some cases, GDI passes us prclDst with one or more coordinates
    // that are negative. At this time the driver cannot handle it,
    // So we'll ask GDI to handle it for us. In the future, we should modify
    // the driver to handle such cases.
    //
    if ( (prclDst->top    < 0) ||
         (prclDst->left   < 0) ||
         (prclDst->bottom < 0) ||
         (prclDst->right  < 0) 
       )
    {
        dwRasterOpReturn = RASTER_OP_CALL_GDI;
        goto finish;
    }
    

    //
    // If we reach here, it means source is definitely required. 
    // Either a mixture of Src and Pattern or just Src.
    //    
    ASSERT(psoSrc);
    if ( psoSrc == NULL )
    {
        dwRasterOpReturn = RASTER_OP_FAILED;
        goto finish;
    }

    BChangeAndTrackObjectType (pdevobj, eRASTEROBJECT);

    //
    // If unidrv has whitened the surface, then we should render it 
    // transparently. 
    //

    if (pPDev->fMode2     & PF2_SURFACE_WHITENED &&
        poempdev->dwFlags & PDEVF_RENDER_TRANSPARENT)
    {
        PCL_SelectTransparency(pdevobj, eTRANSPARENT, eOPAQUE, PF_NOCHANGE_PATTERN_TRANSPARENCY);
    }

    //
    // Now we will have to go different ways for color and monochrome printers.
    // We can receive color images here (>1bpp). For monochrome printers, they 
    // have to be halftoned before sending to printer, but color printers can
    // handle these images by themselves. 
    //
    if ( BIsColorPrinter(pdevobj) )
    {
        VSendRasterPaletteConfigurations (pdevobj, psoSrc->iBitmapFormat);
        dwRasterOpReturn = DWColorPrinterCommonRoutine (
                                            psoDst,
                                            psoSrc,
                                            psoMask,
                                            pco,
                                            pxlo,
                                            pca,
                                            pbo,
                                            prclSrc,
                                            prclDst,
                                            pptlMask,
                                            pptlBrush,        
                                            rop4,
                                            dwSimplifiedRop);
    }
    else
    {
        dwRasterOpReturn = DWMonochromePrinterCommonRoutine (
                                            psoDst,
                                            psoSrc,
                                            psoMask,
                                            pco,
                                            pxlo,
                                            pca,
                                            pbo,
                                            prclSrc,
                                            prclDst,
                                            pptlMask,
                                            pptlBrush,        
                                            rop4,
                                            dwSimplifiedRop);
    }

finish:
    //
    // Reduce the recursion level (if it is greater than 0).
    // Note to Self: Dont put a return statement between the line where we
    // set the value of poempdev->lRecursionLevel and this line.
    //
    if ( !BIsColorPrinter(pdevobj) && (poempdev->lRecursionLevel > 0) )
    {
        (poempdev->lRecursionLevel)--;
    }
    return dwRasterOpReturn;

}

DWORD DWColorPrinterCommonRoutine (
           IN SURFOBJ    *psoDst,
           IN SURFOBJ    *psoSrc,
           IN SURFOBJ    *psoMask,
           IN CLIPOBJ    *pco,
           IN XLATEOBJ   *pxlo,
           IN COLORADJUSTMENT *pca,
           IN BRUSHOBJ   *pbo,
           IN RECTL      *prclSrc,
           IN RECTL      *prclDst,
           IN POINTL     *pptlMask,
           IN POINTL     *pptlBrush,
           IN ROP4        rop4,
           IN DWORD       dwSimplifiedRop)
{
    PDEVOBJ     pdevobj  = NULL;
    POEMPDEV    poempdev = NULL;
    DWORD       dwRasterOpReturn = RASTER_OP_SUCCESS;
    DWORD       dwfgRop3, dwbkRop3;
    SIZEL       sizlDst, sizlSrc;
    POINTL      ptlDst,  ptlSrc;


    TERSE(("DWColorPrinterCommonRoutine() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    REQUIRE_VALID_DATA( pdevobj, return RASTER_OP_FAILED );
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( (poempdev && prclDst), return RASTER_OP_FAILED );


    if ( ! BCheckValidParams(psoSrc, psoDst, psoMask, pco))
    {
        return RASTER_OP_FAILED;
    }

    VGetOSBParams(psoDst, psoSrc, prclDst, prclSrc, &sizlDst, &sizlSrc, &ptlDst, &ptlSrc);

    //
    // If psoMask is valid, then a little bit of trickery has to be done.
    // In psoMask, a bit set to 1 means source pixel at that point is visible,
    //               bit set to 0 means source pixel at that point is invisble.
    // First invert the Mask and send it. It means the visible portion of
    // of the image falls in the destination where there are 0's (since we 
    // inverted the mask) and the invisible portion falls in that area of
    // destination where the bits are 1. So if we send the image rop as S|D,
    // the desired effect will be achieved.
    // Drawback is that the original destination (the one that was there even
    // before psoMask is sent) will be erased. I think this is better than 
    // totally not printing images with Mask.
    //

    if ( psoMask )
    {
    #ifdef MASK_IMPLEMENTED
        poempdev->dwFlags ^= PDEVF_INVERT_BITMAP;
        
        //
        // Lets ignore the return value. Even if it fails, lets go
        // ahead and print the actual bitmap.
        //
        BGenerateBitmapPCL(
                       pdevobj,
                       psoMask,
                       NULL,       // pbo
                       &ptlDst,
                       &sizlDst,
                       &ptlSrc,
                       &sizlSrc,
                       NULL,       // pco
                       NULL,       // pxlo
                       NULL        // pptlBrushOrg
           );
             
        poempdev->dwFlags &= ~PDEVF_INVERT_BITMAP;

        rop4 = 0xEE; // = S | D = 238.
    #else
        dwRasterOpReturn = RASTER_OP_CALL_GDI;
        goto finish;
    #endif
    }

    SelectROP4(pdevobj, rop4);


    if ( BIsComplexClipPath (pco) )
    {
        //
        // There are atleast 2 cases that I am seeing here.
        // 1) Image does not need to be stretched (e.g. PCT6_LET.PM6). Most likely
        //    this call came through HPGLCopyBits. 
        // 2) Image needs to be stretched. e.g. in gr4_let.qxd. Most likely the call
        //    came through StretchBlt 
        // ClipBitmapWithComplexClip is written to handle complex clipping but
        // it is not working properly for case 1. Lines are appearing in images,
        // Therefore  I'll call BGenerateBitmapPCL for that case. This mirrors
        // what the plugin driver does. 
        // 
        if ((sizlSrc.cx != sizlDst.cx) ||
            (sizlSrc.cy != sizlDst.cy) 
           )
        {
        
            //
            // Image needs to be stretched.
            //
            dwRasterOpReturn = ClipBitmapWithComplexClip ( 
                                                pdevobj,
                                                psoSrc,
                                                pbo,
                                                &ptlDst,
                                                &sizlDst,
                                                &ptlSrc,
                                                &sizlSrc,
                                                pco,
                                                pxlo,
                                                pptlBrush 
                                ) ? RASTER_OP_SUCCESS : RASTER_OP_FAILED;
        }
        else
        {
            //
            // Image does not need to be stretched.
            //
            dwRasterOpReturn = BGenerateBitmapPCL(
                                           pdevobj,
                                           psoSrc,
                                           pbo,
                                           &ptlDst,
                                           &sizlDst,
                                           &ptlSrc,
                                           &sizlSrc,
                                           pco,
                                           pxlo,
                                           pptlBrush
                               ) ? RASTER_OP_SUCCESS : RASTER_OP_FAILED;
        }


    }
    else if ( BIsRectClipPath(pco) )
    {
        //
        // A rectangular clip path where stretching is required,
        // cannot be handled at this time. So we'll let GDI handle it.
        //
        if ((sizlSrc.cx != sizlDst.cx) ||
            (sizlSrc.cy != sizlDst.cy))
        {
            //
            // We should ideally be able to handle this function
            // by calling BGenerateBitmapPCL with ptlDst = topleft(pco), 
            // and sizlDst = size of pco. But I'll need
            // a test case to make sure. Till then punting to GDI.
            //
            dwRasterOpReturn = RASTER_OP_CALL_GDI;
            #if 0
             VGetOSBParams(psoDst, psoSrc, &rClip, prclSrc, &sizlDst, &sizlSrc, &ptlDst, &ptlSrc);
             dwRasterOpReturn = BGenerateBitmapPCL(
                                               pdevobj,
                                               psoSrc,
                                               pbo,
                                               &ptlDst,
                                               &sizlDst,
                                               &ptlSrc,
                                               &sizlSrc,
                                               NULL,//pco.Let ptlDst,sizlDst act as pco
                                               pxlo,
                                               pptlBrush
                                   ) ? RASTER_OP_SUCCESS : RASTER_OP_FAILED;
            #endif
        }
        else
        {

            dwRasterOpReturn = ClipBitmapWithRectangularClip(
                                            pdevobj,
                                            psoSrc,
                                            pbo,
                                            &ptlDst,
                                            &sizlDst,
                                            &ptlSrc,
                                            &sizlSrc,
                                            pco,
                                            pxlo,
                                            pptlBrush
                                    ) ? RASTER_OP_SUCCESS : RASTER_OP_FAILED;


        }
    }

    else
    {
        dwRasterOpReturn = BGenerateBitmapPCL(
                                            pdevobj,
                                            psoSrc,
                                            pbo,
                                            &ptlDst,
                                            &sizlDst,
                                            &ptlSrc,
                                            &sizlSrc,
                                            pco,
                                            pxlo,
                                            pptlBrush
                                ) ? RASTER_OP_SUCCESS : RASTER_OP_FAILED;
    }

  finish:
    return dwRasterOpReturn;
}


/////////////////////////////////////////////////////////////////////////////
// BPatternFill
//
// Routine Description:
// 
//   This function fills the given rectangular region with the given brush.
//   Sometimes BitBlt functions will ask us to fill simple rectangles with
//   a solid color or pattern.  In this case the vector calls are much more
//   efficient.  We will send vector codes to fill the region.
//
//   Recently I added complex clipping to this routine using ROPing instead
//   of individual tiny rectangles.  This fixed a "raster healing" bug on the
//   CLJ5 and improved performance in other cases.
//
// Arguments:
//
//   pDevObj - DEVMODE object
//   prclDst - destination rectangle to be used in clipping
//   pco - clip region
//   rop4 - the rop
//   pbo - brush to use for filling the rectangle
//   pptlBrush - origin of brush in destination
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL
BPatternFill (
    PDEVOBJ   pDevObj, 
    RECTL    *prclDst, 
    CLIPOBJ  *pco,
    ROP4      rop4,
    BRUSHOBJ *pbo, 
    POINTL   *pptlBrush
)
{
    HPGLMARKER Brush;
    POEMPDEV   poempdev;

    VERBOSE(("BPatternFill\n"));
    ASSERT_VALID_PDEVOBJ(pDevObj);

    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    HPGL_LazyInit(pDevObj);
    BChangeAndTrackObjectType (pDevObj, eHPGLOBJECT);

    SelectROP4(pDevObj, rop4);

    ZeroMemory(&Brush, sizeof(HPGLMARKER) );
    //
    // Download the brush. 
    // This function creates the brush if it has not already been created.
    // else it just makes the previously downloaded brush active.
    // Note: We are specifying that an HPGL brush should be created and not
    // PCL. Reason : this function is generally called for simple rectangualar
    // fills. or fills of vector objects. Those are drawn using HPGL, so 
    // an HPGL fill pattern is fine. But had we been drawing text or some raster 
    // object, then we would have needed a PCL Brush.
    // Also note that since this is a fill, kBrush is being passed in instead of 
    // kPen.
    // 
    if (!CreateHPGLPenBrush(pDevObj, &Brush, pptlBrush, pbo, 0, kBrush, FALSE))
    {
        WARNING(("Could not create brush!\n"));
        return FALSE;
    }
    
    //
    // Select the brush as the one to be used to fill the object.
    // The actual filling does not occur till the object is actually drawn.
    //
    FillWithBrush(pDevObj, &Brush);
    
    HPGL_SetLineWidth (pDevObj, 0, NORMAL_UPDATE);
    
    SelectClipEx (pDevObj, pco, FP_WINDINGMODE);
    
    if (pco != NULL)
    {
        switch (pco->iDComplexity)
        {
            //
            // if the clipobj is a rectangle and does not 
            // need to be enumerated then we just draw the
            // whole rectangle and fill it.
            //
        case DC_TRIVIAL:
            HPGL_DrawRectangle (pDevObj, prclDst);
            break;
            
        case DC_RECT:
            HPGL_SetClippingRegion(pDevObj, &(pco->rclBounds), NORMAL_UPDATE);
            HPGL_DrawRectangle (pDevObj, prclDst);
            // HPGL_DrawRectangle (pDevObj, &(pco->rclBounds));
            break;
            
        case DC_COMPLEX: 
            //
            // have to enumerate the clipping object into
            // a series of rectangles and draw each one
            //
            // Possible OPTMIZATION : Call BClipRectangleWithVectorMask instead 
            // of BEnumerateClipPathAndDraw. But requires testing.
            //
            BEnumerateClipPathAndDraw (pDevObj, pco, prclDst);
            break;
            
        default:
            WARNING(("Unknown ClipObj\n"));
        }
    }
    else
        HPGL_DrawRectangle (pDevObj, prclDst);
    
    return TRUE;
}


/*++
  Routine Name
    ClipBitmapWithComplexClip

 Routine Description:
 
   This function uses the 3-pass ROP to draw a bitmap which is clipped by
   a vector region. i.e. complex clip.

 Arguments:
    pdevobj,
    psoSrc,
    pbo,
    pptlDst,
    psizlDst,
    pptlSrc,
    psizlSrc,
    pco,
    pxlo,
    pptlBrush

 Return Value:
   TRUE if successful, FALSE if there is an error

 Last Error:
--*/

BOOL ClipBitmapWithComplexClip(
        IN  PDEVOBJ    pdevobj, 
        IN  SURFOBJ   *psoSrc, 
        IN  BRUSHOBJ  *pbo, 
        IN  POINTL    *pptlDst,
        IN  SIZEL     *psizlDst,
        IN  POINTL    *pptlSrc,
        IN  SIZEL     *psizlSrc,
        IN  CLIPOBJ   *pco,
        IN  XLATEOBJ  *pxlo,
        IN  POINTL    *pptlBrush
)
{
    HPGLMARKER     HPGLMarker;
    RECTL          rctlClip;
    const   DWORD  dwROP      = 102; // = DSx = 0x66
    PHPGLSTATE     pState     = GETHPGLSTATE(pdevobj);

    REQUIRE_VALID_DATA( (pdevobj && pptlDst && psizlDst && pptlSrc && psizlSrc && pco), return FALSE);

    //
    // The destination rectangle.
    // TOP LEFT = ptlDest
    // BOTTOM RIGHT = coordinates of topleft + size in x,y direction.
    //
    rctlClip.left   = pptlDst->x;
    rctlClip.top    = pptlDst->y;
    rctlClip.right  = rctlClip.left + psizlDst->cx;
    rctlClip.bottom = rctlClip.top  + psizlDst->cy;


    // 
    // 1) Send the bitmap with XOR (rop = DSx), 
    // 2) Then send the clip region and fill the inside of that region with 
    //    black.(rop = 0). Black in RGB means all zeros. 'a xor 0 = a'. 
    //    i.e. if we were to put an image on top of this area and have it XOR
    //    with whats in the destination (i.e. zeros), it will be like
    //    copying the image 
    //    2.a)  Create a black brush = selecting a black pen.
    //    2.b) Set the clip region to the rectangular area that encompasses
    //         the whole image.
    //    2.c) Draw a path in the shape of the complex clip of image.
    //    2.d) Fill the path with black.
    //    2.e) Reset the clip region to the whole page so that previous clip
    //         region does not affect future objects.
    //
    // 3) Send the bitmap again with (rop = DSx).  
    //    Outside the clip region the XOR-on-XOR will cancel out.  However, where
    //    the black clip region was drawn (i.e. inside the clip region) the 
    //    XOR-on-black will cause the desired image pixels to appear.

    //
    // Send the image the first time. Step 1.
    //
    BChangeAndTrackObjectType (pdevobj, eRASTEROBJECT);
    VSendRasterPaletteConfigurations (pdevobj, psoSrc->iBitmapFormat);
    VSendPhotosSettings(pdevobj);  
    PCL_SelectTransparency(pdevobj, eOPAQUE, eOPAQUE, 0);

    //
    // Select ROP as DSx and then send the bitmap with no clipping.
    //
    SelectROP4(pdevobj, dwROP);
    if ( !BGenerateBitmapPCL(pdevobj,
                             psoSrc,
                             pbo,
                             pptlDst,
                             psizlDst,
                             pptlSrc,
                             psizlSrc,
                             NULL,
                             pxlo,
                             pptlBrush)
        )
    {
        return FALSE;
    }

    BChangeAndTrackObjectType (pdevobj, eHPGLOBJECT);

    //
    // Now Fill the Clip Region with Black. Step 2.
    //

    SelectROP4(pdevobj, 0);
    CreateSolidHPGLPenBrush(pdevobj, &HPGLMarker, RGB_BLACK); //Step 2.a
    HPGLMarker.eFillMode = FILL_eODD_EVEN;
    PATHOBJ *ppo = CLIPOBJ_ppoGetPath(pco);
    //
    // MarkPath requires the current pco in the 
    // state.
    //
    pState->pComplexClipObj = NULL;

    //
    // In some cases the region exceeds the bitmap 
    // We must set the IW such that the mask doesn't
    // overwrite the previous image.
    //
    HPGL_SetClippingRegion(pdevobj, &rctlClip, NORMAL_UPDATE); //Step 2.b
    MarkPath(pdevobj, ppo, NULL, &HPGLMarker); //Step 2.c, 2.d
    HPGL_ResetClippingRegion(pdevobj, 0);      //Step 2.e

    
    //
    // Now Send the Image Again. Step 3
    //
    BChangeAndTrackObjectType (pdevobj, eRASTEROBJECT);
    VSendRasterPaletteConfigurations (pdevobj, psoSrc->iBitmapFormat);
    VSendPhotosSettings(pdevobj);  
    PCL_SelectTransparency(pdevobj, eOPAQUE, eOPAQUE, 0);
    SelectROP4(pdevobj, dwROP);

    return BGenerateBitmapPCL(pdevobj,
        psoSrc,
        pbo,
        pptlDst,
        psizlDst,
        pptlSrc,
        psizlSrc,
        NULL,
        pxlo,
        pptlBrush);
}


/*++
  Routine Name
    ClipBitmapWithRectangularClip

 Routine Description:
    Handles a bitmap that needs a rectangular clip.
    NOTE: This works only on bitmaps that DO NOT HAVE TO BE STRETCHED.
 
 Arguments:
    pdevobj,
    psoSrc,
    pbo,
    pptlDst,
    psizlDst,
    pptlSrc,
    psizlSrc,
    pco,
    pxlo,
    pptlBrush

 Return Value:
   TRUE if successful, FALSE if there is an error

 Last Error:
--*/

BOOL ClipBitmapWithRectangularClip(
        IN  PDEVOBJ    pdevobj, 
        IN  SURFOBJ   *psoSrc, 
        IN  BRUSHOBJ  *pbo, 
        IN  POINTL    *pptlDst,
        IN  SIZEL     *psizlDst,
        IN  POINTL    *pptlSrc,
        IN  SIZEL     *psizlSrc,
        IN  CLIPOBJ   *pco,
        IN  XLATEOBJ  *pxlo,
        IN  POINTL    *pptlBrush
)
{
    
    RECTL       rclDst, rTemp, rClip, rSel;
    RASTER_DATA srcImage;
    PCLPATTERN *pPCLPattern;
    ULONG       ulSrcBpp;
    ULONG       ulDestBpp;
    BOOL        bRetVal = TRUE;
    POEMPDEV    poempdev;

    REQUIRE_VALID_DATA ( (pdevobj && pptlDst && psizlDst && pptlSrc && psizlSrc && pco), return FALSE);
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA ( poempdev, return FALSE);

    rclDst.left   = pptlDst->x;
    rclDst.top    = pptlDst->y;
    rclDst.right  = rclDst.left + psizlDst->cx;
    rclDst.bottom = rclDst.top + psizlDst->cy;

    //
    // Get the clipping rectangle, compare it with the destination
    // and download the right bits.  Note that the clipping rectangle
    // is not documented to be bottom-right exclusive.  Use the temp
    // rectangle to simulate this.
    //
    RECTL_CopyRect(&rTemp, &(pco->rclBounds));
    rTemp.bottom++;
    rTemp.right++;
    if (BRectanglesIntersect (&rclDst, &rTemp, &rClip))
    {

        InitRasterDataFromSURFOBJ(&srcImage, psoSrc, TRUE);

        //
        // Get enough info about the bitmap to set the foreground
        // color.  The RASTER_DATA actually holds the info we want.
        //
        pPCLPattern = &(poempdev->RasterState.PCLPattern);
        BGetBitmapInfo(&(psoSrc->sizlBitmap), psoSrc->iBitmapFormat,
                        pPCLPattern, &ulSrcBpp, &ulDestBpp);
        BGetPalette(pdevobj, pxlo, pPCLPattern, ulSrcBpp, pbo);
        BSetForegroundColor(pdevobj, pbo, pptlBrush, pPCLPattern, ulSrcBpp);


        RECTL_SetRect(&rSel, rClip.left   - rclDst.left + pptlSrc->x,
                             rClip.top    - rclDst.top  + pptlSrc->y,
                             rClip.right  - rclDst.left + pptlSrc->x,
                             rClip.bottom - rclDst.top  + pptlSrc->y);

        bRetVal = DownloadImageAsPCL(pdevobj,
                                  &rClip,
                                  &srcImage,
                                  &rSel,
                                  pxlo
                            );
    }
    return bRetVal;

}

/////////////////////////////////////////////////////////////////////////////
// BEnumerateClipPathAndDraw
//
// Routine Description:
// 
//   This function walks through the rectangles of a clipping region and 
//   sends the region of the graphic that fall within the region.  This is
//   the alternative when ROP clipping can't be used (i.e. the given ROP code
//   is not a simple transfer ROP).
//
// Arguments:
//
//   pDevObj - DEVMODE object
//   pco - clip region
//   prclDst - rectangle coordinates of destination
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL BEnumerateClipPathAndDraw (
    PDEVOBJ pDevObj, 
    CLIPOBJ *pco,
    RECTL   *prclDst
    )
{
    //
    // Make clipRects larger to reduce calls to CLIPOBJ_bEnum
    //
    ENUMRECTS   clipRects;
    BOOL        bMore;
    ULONG       i, numOfRects;
    RECTL       clippedRect;
    INT         iRes;
    BOOL        bRetVal = TRUE;


    ASSERT_VALID_PDEVOBJ(pDevObj);
    iRes = HPGL_GetDeviceResolution(pDevObj);

    if (pco)
    {
        numOfRects = CLIPOBJ_cEnumStart(pco, TRUE, CT_RECTANGLES, CD_RIGHTDOWN, 256);
        do
        {
            bMore = CLIPOBJ_bEnum(pco, sizeof(clipRects), &clipRects.c);

            if ( DDI_ERROR == bMore )
            {
                bRetVal = FALSE;
                break;
            }

            for (i = 0; i < clipRects.c; i++)
            {
                //
                // Draw the intersection of the destination rectangle, 
                // prclDst, and the enumerated rectangle
                //
                if (iRes > 300)
                {
                    // Use this for 4500
                    if (BRectanglesIntersect (prclDst, &(clipRects.arcl[i]), &clippedRect))
                        HPGL_DrawRectangle (pDevObj, &clippedRect);
                }
                else
                {
                    // Use this for 5/5M

                    //
                    // BUGBUG: The optimization above should work, but it breaks JF97_LET.XLS
                    // on the CLJ5 for some reason.  My workaround is to remove the
                    // optimization and send down HPGL for all of the clipping regions even
                    // when we don't think anything will be printed.  Go figure.  JFF
                    //
                    HPGL_SetClippingRegion(pDevObj, &(clipRects.arcl[i]), NORMAL_UPDATE);
                    HPGL_DrawRectangle (pDevObj, prclDst);
                }
            }
        } while (bMore);
    }

    return bRetVal;
}


/////////////////////////////////////////////////////////////////////////////
// BRectanglesIntersect
//
// Routine Description:
//
//   Calculates the intersection of the given rectangles and returns whether
//   the intersection has any area.
//
//   Note: assumes a well ordered rectangle from DDI. top < bottom and
//   left < right. The DDK doc states this is the case.
//   
// Arguments:
//
//   prclDst - rectangle of destination
//   pclipRect - clipping rectangle
//   presultRect - rectangle that is the result of the intersection
//                 of the destination rectangle and the clip rectangle
//
// Return Value:
//
//   TRUE if presultRect contains the intersection, FALSE if 
//   prclDst and pclipRect do not intersect.
/////////////////////////////////////////////////////////////////////////////
BOOL BRectanglesIntersect (
    RECTL  *prclDst,
    RECTL  *pclipRect,
    RECTL  *presultRect
    )
{
    //
    // if the clipRect is completely outside of the 
    // Destination, then just return.
    //
    if (pclipRect->right < prclDst->left ||
        pclipRect->bottom < prclDst->top ||
        pclipRect->left > prclDst->right ||
        pclipRect->top > prclDst->bottom)
    {
        return FALSE;
    }
    
    //
    // return the coordinates of the clipped rectangle
    //
    presultRect->left   = max(prclDst->left,   pclipRect->left);
    presultRect->right  = min(prclDst->right,  pclipRect->right);
    presultRect->top    = max(prclDst->top,    pclipRect->top);
    presultRect->bottom = min(prclDst->bottom, pclipRect->bottom);

    /*
    if (pclipRect->left < prclDst->left)
        presultRect->left = prclDst->left;
    else
        presultRect->left = pclipRect->left;

    if (pclipRect->right < prclDst->right)
        presultRect->right = pclipRect->right;
    else
        presultRect->right = prclDst->right;

    if (pclipRect->top < prclDst->top)
        presultRect->top = prclDst->top;
    else
        presultRect->top = pclipRect->top;

    if (pclipRect->bottom < prclDst->bottom)
        presultRect->bottom = pclipRect->bottom;
    else
        presultRect->bottom = prclDst->bottom;
    */

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// VSendRasterPaletteConfigurations
//
// Routine Description:
//
//   Downloads the predefined raster palettes for 1, 4, 8 and 24 bit modes.
//   It keeps track of whether the palette definition has already been sent
//   to the printer and avoids redundant calls.
//
// Arguments:
//
//   pDevObj - DEVMODE object
//   iBitmapFormat - defined in Windows DDK
//
// Return Value:
//
//   nothing.
/////////////////////////////////////////////////////////////////////////////
VOID VSendRasterPaletteConfigurations (
    PDEVOBJ pDevObj,
    ULONG   iBitmapFormat
)
{
    POEMPDEV    poempdev;
    EColorSpace eColorSpace;
    ECIDPalette eCIDPalette;

    ASSERT(VALID_PDEVOBJ(pDevObj));
    poempdev = (POEMPDEV)pDevObj->pdevOEM;

    if (!poempdev)
        return;

    eCIDPalette = EGetCIDPrinterPalette (iBitmapFormat);
    if (poempdev->wInitCIDPalettes & PF_INIT_RASTER_STARTDOC)
    {
        eColorSpace = EGetPrinterColorSpace (pDevObj);
        VSetupCIDPaletteCommand (pDevObj, 
                                eRASTER_CID_1BIT_PALETTE, 
                                eColorSpace, BMF_1BPP);
        VSetupCIDPaletteCommand (pDevObj, 
                                eRASTER_CID_4BIT_PALETTE, 
                                eColorSpace, BMF_4BPP);
        VSetupCIDPaletteCommand (pDevObj, 
                                eRASTER_CID_8BIT_PALETTE, 
                                eColorSpace, BMF_8BPP);
        VSetupCIDPaletteCommand (pDevObj, 
                                eRASTER_CID_24BIT_PALETTE, 
                                eColorSpace, BMF_24BPP);

        VSelectCIDPaletteCommand (pDevObj, eCIDPalette);
        VSendPhotosSettings(pDevObj);
        poempdev->wInitCIDPalettes &= ~PF_INIT_RASTER_STARTDOC;
        VResetPaletteCache(pDevObj);
    }
    else
         VSelectCIDPaletteCommand (pDevObj, eCIDPalette);

    //
    // Note that the color space may change: raster objects
    // may be RGB or COLORIMETRIC_RGB, other objects are all RGB.
    // Thus, a color space change invalidates the foreground color.
    //
    if (poempdev->eCurObjectType != eRASTEROBJECT)
    {
        poempdev->eCurObjectType = eRASTEROBJECT;
        poempdev->uCurFgColor = HPGL_INVALID_COLOR;
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////
// EGetCIDPrinterPalette
//
// Routine Description:
//
//   Retrieves the palette associated with the bitmap.
//   
//
// Arguments:
//
//   pDevObj - DEVMODE object
//   iBitmapFormat - defined in Windows DDK
//
//
// Return Value:
//
//   ECIDPalette: the palette type which is associated with the given bitmap.
/////////////////////////////////////////////////////////////////////////////
ECIDPalette EGetCIDPrinterPalette (
    ULONG   iBitmapFormat
)
{
    switch (iBitmapFormat)
    {
    case BMF_1BPP:
        return eRASTER_CID_1BIT_PALETTE;
        
    case BMF_4BPP: 
        return eRASTER_CID_4BIT_PALETTE;

    case BMF_8BPP:
        return eRASTER_CID_8BIT_PALETTE;

    case BMF_16BPP:
    case BMF_24BPP:
    case BMF_32BPP:
        return eRASTER_CID_24BIT_PALETTE;

    default:
        return eUnknownPalette;
    }
}

/////////////////////////////////////////////////////////////////////////////
// EGetPrinterColorSpace
//
// Routine Description:
//   Retrieves the color control settings from the UI. This is
//   used to determine which color space to use when printing 
//   bitmaps. If the user selects Screen Match, the colorimetric
//   RGB is used. Otherwise, device RGB is used when drawing bitmaps.
//
//
// Arguments:
//
//   pDevObj - DEVMODE object
//
//
// Return Value:
//
//   the color space associated with the print job. 
/////////////////////////////////////////////////////////////////////////////
EColorSpace EGetPrinterColorSpace (
    PDEVOBJ pDevObj
)
{
    POEMPDEV poempdev;

    ASSERT(VALID_PDEVOBJ(pDevObj));
    poempdev = (POEMPDEV)pDevObj->pdevOEM;

    switch (poempdev->PrinterModel)
    {
    case HPCLJ5:
        //
        // Purposely putting this ASSERT to test what to do for HPCLJ5
        //
        ASSERT( poempdev->PrinterModel == HPCLJ5 );
        /*****
        if (pOEMDM->Photos.ColorControl == SCRNMATCH)
        {
            return eCOLORIMETRIC_RGB;
        }
        else
        {
            return eDEVICE_RGB;
        }
        *****/
        break;

    case HPC4500:
        return eDEVICE_RGB;
        
    // default:
        // return eDEVICE_RGB;
    }
    return eDEVICE_RGB;
}

/*++
Routine Name:
    VMakeWellOrdered

Routine Description:
    The coordinates of destination rectangle received in StretchBlt/BitBlt etc functions
    may not necessarily be well ordered. This functions checks for the same, and if they
    are not well-ordered, it makes them that way.

    -quoting from MSDN for DrvStretchBlt-
    prclDest
        Points to a RECTL structure that defines the area to be modified in the
        coordinate system of the destination surface. This rectangle is defined
        by two points that are not necessarily well ordered, meaning the coordinates
        of the second point are not necessarily larger than those of the first point.
        The rectangle they describe does not include the lower and right edges. This
        function is never called with an empty destination rectangle.
       DrvStretchBlt can do inversions of x and y when the destination rectangle is
        not well ordered.

Arguments:
    prectl : The pointer to the rectangle

Return Value:
    VOID :

Last Error:
    Not changed.
--*/

VOID
VMakeWellOrdered(
        IN  PRECTL prectl
)
{
    LONG lTmp;
    if ( prectl->right < prectl->left )
    {
        lTmp        = prectl->right;
        prectl->right = prectl->left;
        prectl->left  = lTmp;
    }
    if ( prectl->bottom < prectl->top )
    {
        lTmp         = prectl->bottom;
        prectl->bottom = prectl->top;
        prectl->top    = lTmp;
    }
}



/*++

Routine Name:
    dwSimplifyROP

Routine Description:

    SimplifyROP changes the complex ROPs received by the DDI into some 
    simple ROPs whenever it is possible. If it determines that a ROP is
    unsupported, SimplifyROP indicates to calling function to call GDI to 
    handle the case.

Arguments:

    psoSrc - Defines the source for blt operation
    rop4   - raster operation
    pdwSimplifiedRop - The simplified Rop. Assume space has been allocated. 
        If rop can be simplified, then at return time, this variable will have one
        of the following value.

        BMPFLAG_NOOP             0x00000000
        BMPFLAG_BW               0x00000001
        BMPFLAG_PAT_COPY         0x00000002
        BMPFLAG_SRC_COPY         0x00000004
        BMPFLAG_NOT_SRC_COPY     0x00000008
        BMPFLAG_IMAGEMASK        0x00000010

Return Value:

    RASTER_OP_SUCCESS   : if OK
    RASTER_OP_CALL_GDI  : if rop not supported ->call corresponding Engxxx-function
    RASTER_OP_FAILED    : if error

--*/

DWORD
dwSimplifyROP(
        IN  SURFOBJ    *psoSrc,
        IN  ROP4        rop4,
        OUT PDWORD      pdwSimplifiedRop)
{
    DWORD        dwfgRop3, dwbkRop3;
    DWORD        dwRetVal = RASTER_OP_SUCCESS;

    ASSERT(pdwSimplifiedRop);

    *pdwSimplifiedRop = BMPFLAG_NOOP;

    #ifndef WINNT_40

    //
    // Driver doesn't support JPEG image 
    //

    if (psoSrc && psoSrc->iBitmapFormat == BMF_JPEG )
    {
        SetLastError(ERROR_NOT_SUPPORTED);
        ASSERT(psoSrc->iBitmapFormat != BMF_JPEG);
        return RASTER_OP_FAILED;
    }

    #endif // !WINNT_40

    //
    // Extract the foreground and background ROP3
    //

    dwfgRop3 = GET_FOREGROUND_ROP3(rop4);
    dwbkRop3 = GET_BACKGROUND_ROP3(rop4);


    //
    // 1. ROP conversion
    //
    // (1) Fill Dstination
    //     0x00 BLACKNESS
    //     0xFF WHITENESS
    //
    // (2) Pattern copy     -> P
    //     0xA0 PATAND     ( D & P)
    //     0xF0 PATCOPY     P
    //
    // (3) SRC/NOTSRCOPY    -> S or ~S
    //     0x11           ~( S | D)
    //     0x33             ~S
    //     0x44            ( S & ~D)
    //     0x66            ( D ^ S)
    //     0x77           ~( D & S)
    //     0x99           ~( S ^ D)
    //     0xCC              S
    //     0xDD            ( S | ~D)
    //
    // (4) SRC/NOTSRCOPY(imagemask)
    //     0x22 NOTSRCCOPY (~S & D)
    //     0x88 SRCAND     ( D & S)
    //     0xBB MERGEPAINT (~S | D)
    //     0xEE            ( S | D)
    //
    // (5) nothing
    //     0x55 DSTINVERT  ~ D
    //
    // (6) Do nothing
    //     0xAA Dst         D
    //
    // (7) Misc ROP support
    //     0x5A PATINVERT  ( D ^ P)
    //     0x0A            ( D & ~P)-> Pn
    //     0x0F PATNOT     ~P
    //
    //     0x50            (P & ~D) ->  P
    //     0x5F            (D ^ P ) ->  P
    //
    //     0xA5            ~(P ^ D) ->  Pn
    //     0xAF            (D | ~P) ->  Pn
    //
    //
    // (6) Other ROPS go into SRCCPY
    //
    //

    //
    // It is interesting that these ROPs are based on RGB color space where 0 is black
    // and 0xffffff is white. But when using it for monochrome printers (where 1 is black)
    // the rops totally reverse. For e.g. S | D (0xEE) in RGB space is to be considered as
    // S & D (0x88) in monochrome printers. A good way of conversion is to invert all the bits
    // in the rop and reverse their order (This was written in PCL Implementor's guide. 16-5)
    // e.g. S | D = 0xEE = 1110 1110 
    // inverting the bits, it becomes 0001 0001
    // reversing the order of bits, it becomes 1000 1000
    // which is 0x88 = S & D.
    //

//    dwfgRop3 = dwConvertRop3ToCMY(dwfgRop3);


    switch (dwfgRop3)
    {

    case 0x00:       // BLACKNESS
    case 0xFF:       // WHITENESS

        VERBOSE(("%2X: Black/White.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_BW;
        break;

    case 0xA0:       // (P & D)
    case 0xF0:       // P

        VERBOSE(("%2X: Pattern copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_PAT_COPY;
        break;

    case 0x44:       // (S & ~D)
    case 0x66:       // (D ^ S)
    case 0xCC:       // S
    case 0xDD:       // (S | ~D)

        VERBOSE(("%2X: Source copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_SRC_COPY;
        break;

    case 0x11:       // ~(S | D)
    case 0x33:       // ~S
    case 0x99:       // ~(S ^ D)
    case 0x77:       // ~(D & S)

        VERBOSE(("%2X: Not source copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_NOT_SRC_COPY;
        break;

    case 0xEE:       // (S | D)

        TERSE(("%2X: Source copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_SRC_COPY; 

        if (bMonochromeSrcImage(psoSrc) )
        {
            TERSE(("NOT_IMAGEMASK.\n"));
            *pdwSimplifiedRop |= BMPFLAG_NOT_IMAGEMASK;
        }
        break;

    case 0x88:       // (D & S)

        TERSE(("%2X: Source copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_SRC_COPY;

    /** To be used only if ROPs are not used.
        if (psoSrc && bMonochromeSrcImage(psoSrc) )
        {
            TERSE(("IMAGEMASK.\n"));
            *pdwSimplifiedRop |= BMPFLAG_IMAGEMASK;
        }
    **/
        break;

    case 0xBB:       // (~S | D)

        TERSE(("%2X: Not source copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_NOT_SRC_COPY;
        break;

    case 0x22:       // (~S & D)

        TERSE(("%2X: Not source copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_NOT_SRC_COPY;

    /** To be used only if ROPs are not used.
        if (bMonochromeSrcImage(psoSrc) )
        {
            TERSE(("imagemask.\n"));
            *pdwSimplifiedRop |= BMPFLAG_IMAGEMASK;
        }
    **/
        break;



    case 0x55:       // ~D
        VERBOSE(("%2X: Not Destination copy.\n", dwfgRop3));
        *pdwSimplifiedRop |= BMPFLAG_NOT_DEST;
        break;

    case 0xAA:       // D

        TERSE(("%2X: Do nothing.\n", dwfgRop3));
        break;

    //
    // Misc ROP support
    //

    case 0x5A:       // (D ^ P)
    case 0x0A:       // (D & ~P)
    case 0x0F:       // ~P

        VERBOSE(("%2X: Not pattern copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_PAT_COPY;
        break;

    case 0x50:
    case 0x5F:

        VERBOSE(("%2X: Pattern copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_PAT_COPY;
        break;

    case 0xA5:
    case 0xAF:

        VERBOSE(("%2X: Not pattern copy.\n", dwfgRop3));

        *pdwSimplifiedRop |= BMPFLAG_PAT_COPY;
        break;

    case 0xB8:
    case 0xE2:
        //
        // This ROP calls for interaction of Src and Pattern. Atleast two documents
        // in WinPARTy use this ROP.
        // a) WRD4_LET.PDF 
        // b) CHT8_LET.SHW : Corel Presentation File: On second page there is a green
        // and white pattern like a chess board. That pattern is rendered
        // using this ROP.
        //
        VERBOSE(("%2X: Special case ROP. Interaction of source and pattern.\n", dwfgRop3));
        *pdwSimplifiedRop |= BMPFLAG_SRC_COPY | BMPFLAG_PAT_COPY;
        break;

    default:

        TERSE(("%2X: Unsupported rop.\n", dwfgRop3 ));

        if (ROP3_NEED_SOURCE(dwfgRop3))
        {
            *pdwSimplifiedRop |= BMPFLAG_SRC_COPY;
        }
        if (ROP3_NEED_PATTERN(dwfgRop3))
        {
            *pdwSimplifiedRop |= BMPFLAG_PAT_COPY;
        }

        break;
    }

    return dwRetVal ;
}



/*++

Routine Name:
    dwConvertRop3ToCMY

Routine Description:
    The ROPs received by the DDI's are based on RGB color space where 0 is black
    and 0xffffff is white. But when using it for monochrome printers (where 1 is black),
    the rops totally reverse. For e.g. S | D (0xEE) in RGB space is to be considered as
    S & D (0x88) in monochrome printers. A good way of conversion is to invert all the bits
    in the rop and reverse their order (This was written in some manual).
    e.g. S | D = 0xEE = 1110 1110
    inverting the bits, it becomes 0001 0001
    reversing the order of bits, it becomes 1000 1000
    which is 0x88 = S & D.
  
Arguments:
    rop3 : The rop3 value in RGB color space

Return Value:
    the rop3 value in CMY color space.

Last Error:
    Not changed.

--*/

DWORD dwConvertRop3ToCMY(
            IN DWORD rop3)
{
    BYTE brop3 = ~(BYTE(rop3 & 0xff)); //Invert the bits.
    DWORD seed = 0x1;
    DWORD outRop3 = 0;

    //
    // Reverse the order of bits. : 
    // Take brop3 and see its last bit, if it is 1 (i.e. (brop3 & 0x01) )
    // copy it to destination (outRop3). i.e. outRop3 |= outRop3 | (brop3 & 0x01);
    // SHL the destination  and SHR the source (brop3)
    // Since ORing is occuring before shifting, it means that after the last bit is 
    // set, we dont shift. Thats why outRop3 <<= 1 is coming before the OR statement.
    //
    for ( int i = 0; i < 8; i++)
    {
        outRop3 <<= 1;
        outRop3 |= outRop3 | (brop3 & 0x01);
        brop3 >>= 1;
    }

    return outRop3;
}

/*++

Routine Name:
    BRevertToHPGLpdevOEM

Routine Description:
    Copies the HPGL's vector modules pdevOEM stored in pdev->pVectorPDEV to
    pdevobj->pdevOEM. 

Arguments:
    pdevobj : 

Return Value:
    TRUE is sucess
    FALSE otherwise.

Last Error:
    Not changed.

--*/
BOOL BRevertToHPGLpdevOEM (
        IN  PDEVOBJ pdevobj )
{
    PDEV       *pPDev  = (PDEV *)pdevobj;

    pdevobj->pdevOEM = pPDev->pVectorPDEV;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\glraster.h ===
#ifndef _GLRASTER_H
#define _GLRASTER_H

/*++

 

Copyright (C) 2000  Microsoft Corporation

All rights reserved.
 

Module Name:

   glraster.h

Abstract:
    Declarations of functions defined in glraster.h that need to be publicly available.

Author:

   hsingh  14-April-2000 : Created It.

History:
 

--*/



#include "glpdev.h"

BOOL
BPatternFill (
    PDEVOBJ   pDevObj,
    RECTL    *prclDst,
    CLIPOBJ  *pco,
    ROP4      rop4,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush
    );


inline VOID DELETE_SURFOBJ(SURFOBJ **ppso, 
                           HBITMAP  *phBmp)                                      
{                                                                       
    if ( ppso && *ppso)    { EngUnlockSurface(*ppso);         *ppso=NULL;  } 
    if (phBmp && *phBmp)   { EngDeleteSurface((HSURF)*phBmp); *phBmp=NULL; } 
}

inline BOOL BIsColorPrinter (
        IN  PDEVOBJ pDevObj)
{
    //
    // Assuming pDevObj is always valid, which should be the case.
    //
    return ((POEMPDEV) (pDevObj->pdevOEM))->bColorPrinter;
}

inline BOOL BRevertToHPGLpdevOEM (
        IN  PDEVOBJ pDevObj);

VOID
VSendRasterPaletteConfigurations (
    PDEVOBJ pdevobj,
    ULONG   iBitmapFormat
    );

DWORD
dwSimplifyROP(
        IN  SURFOBJ    *psoSrc,
        IN  ROP4        rop4,
        OUT PDWORD      pdwSimplifiedRop);

BOOL BChangeAndTrackObjectType (
            IN  PDEVOBJ     pdevobj,
            IN  EObjectType eNewObjectType );

DWORD dwCommonROPBlt (
            IN SURFOBJ    *psoDst,
            IN SURFOBJ    *psoSrc,
            IN SURFOBJ    *psoMask,
            IN CLIPOBJ    *pco,
            IN XLATEOBJ   *pxlo,
            IN COLORADJUSTMENT *pca,
            IN BRUSHOBJ   *pbo,
            IN RECTL      *prclSrc,
            IN RECTL      *prclDst,
            IN POINTL     *pptlMask,
            IN POINTL     *pptlBrush,
            IN ROP4        rop4);

#endif  //_GLRASTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpgl.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft
// 
// Module Name:
// 
//   hpgl.cpp
// 
// Abstract:
// 
//   [Abstract]
//
//   Note that all functions in this module begin with HPGL_ which indicates
//   that they are responsible for outputing HPGL codes.
//
// 
// Environment:
// 
//   Windows 2000 Unidrv driver 
//
// Revision History:
// 
//   07/02/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

//
// I will set aside two patterns for markers: one for pen and one for brush.
//
#define HPGL_PATTERN_FILL_PEN_ID   3
#define HPGL_PATTERN_FILL_BRUSH_ID 4

void
VInvertBits (
    DWORD  *pBits,
    INT    cDW);

BOOL BCreatePCLDownloadablePattern(
            IN  PDEVOBJ      pDevObj,
            IN  PRASTER_DATA pImage,
            OUT PULONG       pulBufLength,
            OUT PBYTE       *ppByte);


///////////////////////////////////////////////////////////////////////////////
// vSendpatternDownloadCommand()
//
// Routine Description:
// 
//   Send PCL pattern download command
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   iPatternNumber - Pattern ID
//   ulBytesOfPatternData - The size of pattern data in byte.
// 
// Return Value:
// 
//	 None
///////////////////////////////////////////////////////////////////////////////
static VOID vSendPatternDownloadCommand(
    IN  PDEVOBJ     pDevObj,
    IN  PATID       iPatternNumber,
    IN  ULONG       ulBytesOfPatternData)
{

    //
    // Send PCL command
    //
    PCL_sprintf(pDevObj, "\033*c%dG\033*c%dW", iPatternNumber, ulBytesOfPatternData);

}

VOID VSendPatternDeleteCommand(
    IN  PDEVOBJ     pDevObj,
    IN  PATID       iPatternNumber)
{

    //
    // Send PCL command
    //
    PCL_sprintf(pDevObj, "\033*c%dG\033*c2Q", iPatternNumber);

}

VOID VDeleteAllPatterns(
    IN  PDEVOBJ     pDevObj)
{

    //
    // Send PCL command. Esc*0Q will delete all patterns (temporary
    // and permanent)
    //
    PCL_sprintf(pDevObj, "\033*c0Q");

}

///////////////////////////////////////////////////////////////////////////////
// HPGL_SelectROP3()
//
// Routine Description:
// 
//   Sends the HPGL or PCL ROP command
//	 Sends MC1,# if we are currently working on an HPGL object
//	 Sends Esc&l#O we are currently workin on a RASTER or text object
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//	 Rop3:   - The ROP that is to be selected
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SelectROP3(PDEVOBJ pDevObj, ROP4 Rop3)
{
    CMDSTR szCmdStr;
    int    iCmdLen;
    POEMPDEV poempdev = GETOEMPDEV(pDevObj);
    
    if (poempdev->eCurObjectType == eHPGLOBJECT)
    {
        iCmdLen = iDrvPrintfSafeA((PCHAR)szCmdStr, CCHOF(szCmdStr), "MC1,%d;", Rop3);
        return HPGL_Output(pDevObj, szCmdStr, iCmdLen);
    }
    else
    {
        iCmdLen = iDrvPrintfSafeA((PCHAR)szCmdStr, CCHOF(szCmdStr), "\x1B*l%dO", Rop3);
        return PCL_Output(pDevObj, szCmdStr, iCmdLen);
    }
}


//
// There are two SelectTransparency functions here. One for
// HPGL and another for PCL. The behavior is different
// in both cases. PCL defines
// 0 as transparent and 1 as opaque. (Esc*v#0, Esc*v#N).
// HPGL says TR0 is transparency off i.e. Opaque
// while TR1 is Transparent.
// So if eTransparent is passed in and we are in HP-GL mode
// then TR1 should be passed instead of TR0
//

///////////////////////////////////////////////////////////////////////////////
// PCL_SelectTransparency()
//
// Routine Description:
// 
//   Sends the PCL transparency command(s) for source and pattern
//	 Sends Esc*v#N and Esc*v#O 
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//	 SourceTransparency - either OPAQUE or TRANSPARENT
//   PatternTransparency - either OPAQUE or TRANSPARENT
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL PCL_SelectTransparency(
    PDEVOBJ pDevObj, 
    ETransparency SourceTransparency,
    ETransparency PatternTransparency,
    BYTE bFlags
    )
{
    CMDSTR szCmdStr;
    int    iCmdLen, bRet = TRUE;
    POEMPDEV poempdev = GETOEMPDEV(pDevObj);

    if ( (!(bFlags & PF_NOCHANGE_SOURCE_TRANSPARENCY ) ) &&
         ( (poempdev->CurSourceTransparency != SourceTransparency) ||
           (bFlags & PF_FORCE_SOURCE_TRANSPARENCY)
         ) 
       )
    {
        iCmdLen = iDrvPrintfSafeA((PCHAR)szCmdStr, CCHOF(szCmdStr), "\x1B*v%dN", SourceTransparency);
        bRet = PCL_Output(pDevObj, szCmdStr, iCmdLen);
        poempdev->CurSourceTransparency = SourceTransparency;
    }

    if ( (!(bFlags & PF_NOCHANGE_PATTERN_TRANSPARENCY ) ) && 
         ( (poempdev->CurPatternTransparency != PatternTransparency) ||
           (bFlags & PF_FORCE_PATTERN_TRANSPARENCY)
         )
       )
    {
        iCmdLen = iDrvPrintfSafeA((PCHAR)szCmdStr, CCHOF(szCmdStr), "\x1B*v%dO", PatternTransparency);
        bRet = PCL_Output(pDevObj, szCmdStr, iCmdLen);
        poempdev->CurPatternTransparency = PatternTransparency;
    }
    return bRet;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_SelectTransparency()
//
// Routine Description:
//
//   Sends TR0 if Transparency is eOPAQUE
//   Sends TR1 if Transparency is eTRANSPARENT
//
// Arguments:
//
//   pDevObj - Points to our PDEVOBJ structure
//   Transparency - either OPAQUE or TRANSPARENT
//   bFlags
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SelectTransparency(
    PDEVOBJ       pDevObj,
    ETransparency Transparency,
    BYTE          bFlags
    )
{
    POEMPDEV poempdev = GETOEMPDEV(pDevObj);
    REQUIRE_VALID_DATA (poempdev, return FALSE);

    if ( (poempdev->eCurRenderLang == eHPGL) &&
         ( (poempdev->CurHPGLTransparency != Transparency) ||
           bFlags 
         )
         
       )
    {
        if ( Transparency == eOPAQUE ) //equiv to OFF
        {
            CHAR szCmdStr[] = "TR0";
            HPGL_Output(pDevObj, szCmdStr, strlen(szCmdStr));
        }
        else
        {
            CHAR szCmdStr[] = "TR1";
            HPGL_Output(pDevObj, szCmdStr, strlen(szCmdStr));
        }

        poempdev->CurHPGLTransparency = Transparency;
        
    }

    return TRUE;
}

#ifdef COMMENTEDOUT
///////////////////////////////////////////////////////////////////////////////
// PCL_SelectPaletteByID
//
// Routine Description:
// 
//   Sends Esc&p#S to selelct the hpgl or text palette 
//	 Makes the hpgl or text palette current
//
//   Note: This function now conflicts with VSelectCIDPaletteCommand.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//	 eObject - palette 0 for (eTEXTOBJECT), palette 1 for (eHPGLOBJECT)
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL PCL_SelectPaletteByID(PDEVOBJ pDevObj, EObjectType eObject)
{
    CMDSTR szCmdStr;
    int    iCmdLen;
    
    iCmdLen = iDrvPrintfSafeA((PCHAR)szCmdStr, CCHOF(szCmdStr), "\x1B&p%dS", eObject);
    return PCL_Output(pDevObj, szCmdStr, iCmdLen);
}
#endif


///////////////////////////////////////////////////////////////////////////////
// HPGL_BeginHPGLMode()
//
// Routine Description:
// 
//   Sends Esc%1B to printer which switches to HPGL mode from PCL mode.
//
//   [ISSUE] Should I provide a parameter for %1B or %0B? JFF
// 
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_BeginHPGLMode(PDEVOBJ pDevObj, UINT uFlags)
{
    POEMPDEV poempdev = GETOEMPDEV(pDevObj);
    
    if ((uFlags & FORCE_UPDATE) || (poempdev->eCurRenderLang != eHPGL))
    {
        poempdev->eCurRenderLang = eHPGL;
        
        // Output: "Esc%1B"
        CHAR szCmdStr[] = "\x1B%1B";
        return HPGL_Output(pDevObj, szCmdStr, strlen(szCmdStr));
    }
    else
        return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_EndHPGLMode()
//
// Routine Description:
// 
//   Sends Esc%0A to printer which switches to PCL mode from HPGL mode.
//
//   [ISSUE] Should I provide a parameter for %1A or %0A? JFF
// 
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_EndHPGLMode(PDEVOBJ pDevObj, UINT uFlags)
{
    POEMPDEV poempdev = GETOEMPDEV(pDevObj);
    
    if ((uFlags & FORCE_UPDATE) || (poempdev->eCurRenderLang == eHPGL))
    {
        poempdev->eCurRenderLang = ePCL;
        // Output: "SV0" // Needs to reset brush before drawing text.
        // Output: "Esc%0A"
        CHAR szCmdStr[] = "SV0;\x1B%0A";
        return PCL_Output(pDevObj, szCmdStr, strlen(szCmdStr));
    }
    else
    {
        return TRUE;
    }
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SetupPalette()
//
// Routine Description:
// 
//   Setups up the HPGL palette as palette #1. 
//   Makes palette #1 the current palette
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetupPalette(PDEVOBJ pDevObj)
{
    CHAR szCmdStr[] = "\x1B&p1i6C";
    return PCL_Output(pDevObj, szCmdStr, strlen(szCmdStr));
}


///////////////////////////////////////////////////////////////////////////////
// PCL_SetupRasterPalette()
//
// Routine Description:
// 
//   Setups up the Raster palette as palette #2. 
//   Makes palette #2 the current palette
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL PCL_SetupRasterPalette(PDEVOBJ pDevObj)
{
    CHAR szCmdStr[] = "\x1B&p2i6c2S";
    return PCL_Output(pDevObj, szCmdStr, strlen(szCmdStr) );
}


///////////////////////////////////////////////////////////////////////////////
// PCL_SetupRasterPatternPalette()
//
// Routine Description:
// 
//   Setups up the Raster palette as palette #3. 
//   Makes palette #3 the current palette
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL PCL_SetupRasterPatternPalette(PDEVOBJ pDevObj)
{
    CHAR szCmdStr[] = "\x1B&p3i6c3S";
    return PCL_Output(pDevObj, szCmdStr, strlen(szCmdStr) );
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_Init()
//
// Routine Description:
// 
//   Sends IN; to printer which initializes HPGL to default values.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_Init(PDEVOBJ pDevObj)
{
    CMDSTR szCmdStr;
    int    iCmdLen;
    
    return HPGL_Command(pDevObj, 0, "IN");
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_Command()
//
// Routine Description:
// 
//   Generic routine for outputting any common HPGL command of the form:
//   XX[nn[,nn...]];
//
//   [ISSUE] The current version of this routine assumes that ALL ARGUMENTS
//   ARE INTEGERS and evaluates each as int (signed 32-bit integer).  Anything
//   else will cause great grief (read: crash).
//
//   Note that this function uses a variant-length argument list.  Please 
//   double-check your arg lists to avoid additional grief (read: more 
//   crashing).
//
//   [ISSUE] I'm assuming--for the moment--that all HPGL commands are 2 
//   characters.  If you send a string with strlen(szCmd) != 2 bad things
//   will happen.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   nArgs - The number of arguments in the list AFTER the command string
//   szCmd - The HPGL command string (e.g. "PD")
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_Command(PDEVOBJ pDevObj, int nArgs, char *szCmd, ...)
{
    va_list args;
    int i;
    
    va_start(args, szCmd);
    
    HPGL_Output(pDevObj, szCmd, 2); // ISSUE Assume that all HPGL commands are 2 characters
    
    for (i = 0; i < nArgs; i++)
    {
        // ISSUE Assume--by default--all args are ints
        CMDSTR szArgStr;
        int arg;
        int iArgLen;
        
        arg = va_arg(args, int);
        if (i < (nArgs - 1))
        {
            iArgLen = iDrvPrintfSafeA((PCHAR)szArgStr, CCHOF(szArgStr), "%d,", arg);
        }
        else
        {
            iArgLen = iDrvPrintfSafeA((PCHAR)szArgStr, CCHOF(szArgStr), "%d", arg);
        }
        
        HPGL_Output(pDevObj, szArgStr, iArgLen);
    }
    
    HPGL_Output(pDevObj, ";", 1);
    
    va_end(args);
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_FormatCommand()
//
// Routine Description:
// 
//   Sends a formatted HPGL command string to the printer.  You'll probably call
//   this will the command and its arguments: 
//   e.g. HPGL_FormatCommand(pDevObj, "IW%d,%d,%d,%d;", left, top, right, bottom);
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   szFormat - command to send--like an sprintf format string
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_FormatCommand(PDEVOBJ pDevObj, const PCHAR szFormat, ...)
{
    va_list args;
    CHAR szCmdStr[STRLEN];
    int iLen;
    
    va_start(args, szFormat);
    
    iLen = iDrvVPrintfSafeA(szCmdStr, CCHOF(szCmdStr), szFormat, args);

    if ( iLen <= 0 )
    {
        WARNING(("iDrvVPrintfSafeA returned error. Can't send %s to printer\n", szFormat)); 
        return FALSE;
    }
    
    HPGL_Output(pDevObj, szCmdStr, iLen);
    
    va_end(args);
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_Output()
//
// Routine Description:
// 
//   Sends the given string to the printer.  This single-point-of-entry provides
//   control over output strings.  Filtering, debug viewing and logging of all
//   HPGL codes can be done from here.
//
//   TODO: Enforce HPGL mode here.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   szCmdStr - command to send
//   iCmdLen - length of command string
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_Output(PDEVOBJ pDevObj, char *szCmdStr, int iCmdLen)
{
    POEMPDEV poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    if (szCmdStr[0] == '\033')
    {
        TERSE(("Possible PCL string sent through HPGL_Output!\n"));
    }

    if (poempdev->eCurRenderLang != eHPGL)
        BeginHPGLSession(pDevObj);

    VERBOSE(("HPGL_Output: \"%s\"\n", szCmdStr));
    
    OEMWriteSpoolBuf(pDevObj, szCmdStr, iCmdLen);
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SetPixelPlacement()
//
// Routine Description:
// 
//   Adjusts the pixel placement in HPGL to the given enumerated value.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   place - the desired pixel placement
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetPixelPlacement(PDEVOBJ pDevObj, EPixelPlacement place, UINT uFlags)
{
    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);

    if ((uFlags & FORCE_UPDATE) || (pState->ePixelPlacement != place))
    {
        pState->ePixelPlacement = place;
        HPGL_Command(pDevObj, 1, "PP", place);
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_ResetClippingRegion()
//
// Routine Description:
// 
//   Resets the soft clipping region in HPGL.  This makes the soft clip region
//   the same as the hard clip limits.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_ResetClippingRegion(PDEVOBJ pDevObj, UINT uFlags)
{
    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);
    RECTL rReset;

    RECTL_SetRect(&rReset, CLIP_RECT_RESET, CLIP_RECT_RESET, CLIP_RECT_RESET, CLIP_RECT_RESET);

    if ((uFlags & FORCE_UPDATE) || !RECTL_EqualRect(&rReset, &pState->rClipRect))
    {
        RECTL_CopyRect(&pState->rClipRect, &rReset);
        HPGL_Command(pDevObj, 0, "IW");
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// PreventOverlappingClipRects()
//
// Routine Description:
// 
//   Checks to see if the current clipping rectangle meets the edges of the
//   previous clipping rectangle and adjusts it to prevent overlap.
//
// Arguments:
// 
//   pClipRect - the desired clip region
//   clipDist - the clip threshhold.
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
static VOID PreventOverlappingClipRects(const PHPGLSTATE pState, LPRECTL pClipRect, INT clipDist)
{
    if (RECTL_IsEmpty(&pState->rClipRect))
        return;
    
    // Check for vertical alignment
    if ((pClipRect->left  == pState->rClipRect.left ) &&
        (pClipRect->right == pState->rClipRect.right) )
    {
        // Check top edge
        if (abs(pState->rClipRect.top - pClipRect->bottom) <= clipDist)
        {
            pClipRect->bottom = pState->rClipRect.top;
        }
        // Check bottom edge
        else if (abs(pState->rClipRect.bottom - pClipRect->top) <= clipDist)
        {
            pClipRect->top = pState->rClipRect.bottom;
        }
    }
    // Check for horizontal alignment
    else if ((pClipRect->top    == pState->rClipRect.top   ) &&
             (pClipRect->bottom == pState->rClipRect.bottom) )
    {
        // Check right edge
        if (abs(pState->rClipRect.right - pClipRect->left) <= clipDist)
        {
            pClipRect->left = pState->rClipRect.right;
        }
        
        // Check left edge
        else if (abs(pState->rClipRect.left - pClipRect->right) <= clipDist)
        {
            pClipRect->right = pState->rClipRect.left;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_SetClippingRegion()
//
// Routine Description:
// 
//   Adjusts the soft clipping region in HPGL.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   pClipRect - the desired clip region
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetClippingRegion(PDEVOBJ pDevObj, LPRECTL pClipRect, UINT uFlags)
{
    POEMPDEV poempdev = GETOEMPDEV(pDevObj);
    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);

    if ((pDevObj == NULL) || (pClipRect == NULL))
        return FALSE;

    //
    // I expanded the clipping rectangle and it seems to have 
    // fixed several "missing line" bugs.  
    //
    RECTL rTemp;
    RECTL_CopyRect(&rTemp, pClipRect);
    
    //
    // Special case: when using a vector clip mask we can't expand the rectangle
    // because if two clipping regions are contiguous and we cause their clipping
    // rectangles to overlap you get black lines drawn where they overlap.
    // Note that you must choose the ZERO rop *before* setting your clipping 
    // region for this to work correctly!
    //
    INT clipDist = HPGL_GetDeviceResolution(pDevObj) < 600 ? 2 : 4;
    if (poempdev->CurrentROP3 == 0)
    {
        PreventOverlappingClipRects(pState, &rTemp, clipDist);
    }
    else
    {
        rTemp.left--;
        rTemp.top--;
        rTemp.right++;
        rTemp.bottom++;
    }
    
    if ((uFlags & FORCE_UPDATE) || !RECTL_EqualRect(&rTemp, &pState->rClipRect))
    {
        RECTL_CopyRect(&pState->rClipRect, &rTemp);
        HPGL_Command(pDevObj, 4, "IW", rTemp.left, rTemp.bottom, rTemp.right, rTemp.top);
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// CreatePCLPalette()
//
// Routine Description:
// 
//   Uses PCL to download a user-defined pattern to the printer.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//	 colorEntries - the number of colors 
//   pColorTable - the color table in RGB format
//   pPattern - holds all of the information for the PCL pattern
//   pbo - the source brush
// 
// Return Value:
// 
//	 None
///////////////////////////////////////////////////////////////////////////////
VOID CreatePCLPalette(PDEVOBJ pDevObj, ULONG colorEntries, PULONG pColorTable,
                      PPCLPATTERN pPattern, BRUSHOBJ *pbo)
{
    PULONG   pRgb;
    ULONG    i;
    
    pRgb = pColorTable;
    for ( i = 0; i < colorEntries; ++i)
    {
        pPattern->palData.ulPalCol[i] = pRgb[i];
        pPattern->palData.ulDirty[i] = TRUE;
    }
    
    pPattern->palData.pEntries = i;
}


///////////////////////////////////////////////////////////////////////////////
// DownloadPatternFill()
//
// Routine Description:
// 
//   Sends down a pattern fill specifically for brushes.
//
// Arguments:
// 
//   pDevObj      - Points to our PDEVOBJ structure.
//   pBrush       - The marker object which will track the downloaded pen/Brush information.
//   pptlBrushOrg - the origin of the brush.
//   pBrushInfo   - The PBRUSHINFO that holds the pattern.
//   eStylusType  - Whether Patterns is used for a pen or brushfill
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL DownloadPatternFill(PDEVOBJ pDevObj, PHPGLMARKER pBrush,
                              POINTL *pptlBrushOrg, PBRUSHINFO pBrushInfo, ESTYLUSTYPE eStylusType)
{
    BOOL             bRetVal    = TRUE;
    POEMPDEV         poempdev   = NULL;
    LONG             lPatternID = 0;
    ERenderLanguage  eDwnldType = eUNKNOWN;

    REQUIRE_VALID_DATA ( (pDevObj && pBrush && pBrushInfo), return FALSE);
    poempdev = GETOEMPDEV(pDevObj);
    REQUIRE_VALID_DATA (poempdev, return FALSE);

    lPatternID = pBrush->lPatternID;
    
    if ( lPatternID < 0 || lPatternID > MAX_PATTERNS)
    {
        //
        // Pattern ID has to be positive with value <= MAX_PATTERNS 
        //
        ERR(("DownloadPatternFill : Negative PatternID\n"));
        return FALSE;
    } 
    
    //
    // Initialize convenience variables
    //
    PPATTERN_DATA pPattern = (PPATTERN_DATA)(((PBYTE)pBrushInfo) + sizeof(BRUSHINFO));
    PRASTER_DATA  pImage   = &(pPattern->image);

    //
    // if (pBrushInfo->bNeedToDownload == FALSE), then we have to set
    // pBrush->eFillType to  FT_eHPGL_BRUSH or FT_ePCL_BRUSH depending
    // on how it was previously downloaded.
    //
    if (pBrushInfo->bNeedToDownload == FALSE)
    {
        BOOL bIsDownloaded        = FALSE;
        ERenderLanguage eRendLang = eUNKNOWN;
        bRetVal = FALSE; //pessimist.........

        //
        // First verify whether it actually is downloaded by looking into 
        // the brush cache. Then verify the downloaded type.
        //

        if ( poempdev->pBrushCache->BGetDownloadedFlag(lPatternID, &bIsDownloaded) )
        {
            if ( bIsDownloaded ==  TRUE && 
                 poempdev->pBrushCache->BGetDownloadType ( lPatternID, &eRendLang) )
            {
                if ( eRendLang == eHPGL || eRendLang == ePCL)
                {
                    pBrush->eFillType = (eRendLang == ePCL ? FT_ePCL_BRUSH : FT_eHPGL_BRUSH);
                    bRetVal = TRUE;
                }
            }
        }
        goto finish;
    }

    //
    // 4*2 cases : 1. color printer brush fill
    //             2. color printer pen fill
    //             3. mono printer brush fill
    //             4. mono printer pen fill
    //             a. HPGL
    //             b. PCL
    //

    if ( pPattern->eRendLang == ePCL || pPattern->eRendLang == eUNKNOWN)
    {
        //
        // Case 1,2,3,4 case b
        // Downloading as PCL pattern reduces the output file size.
        // Therefore in case we are not told to specifically download as
        // HPGL we will download as PCL.
        // Note: HPGL patterns have to magnified to size double of PCL
        // pattern, so if we are told to download as HPGL and we download
        // as PCL, the output will be wrong (because the pattern has been
        // created depending on the expected rendering language).
        // Max saving in file size is made if the brush is 1bpp.
        // For 8bpp, we do achieve reduced size but not lots.
        // Brush downloading cannot be done for 4bpp because
        // the Esc*c#W does not support it (Page 16-18 PCL Implementor's guide v6.0 )
        //
        // QUESTION : Why is that in the else case,  pPen->eFillType is set 
        // according to eStylusType but not here.
        // ANSWER : If pattern is downloaded as raster, it does not matter here whether 
        // we are using a pen or a brush. Both have to use same fill type number i.e.  
        // both FT_ePCL_PEN and FT_ePCL_BRUSH have same value = 22
        // But in the else part, FT_eHPGL_PEN and FT_eHPGL_BRUSH and different values.
        // 
        pBrush->eFillType = FT_ePCL_BRUSH; // 22
        VSendRasterPaletteConfigurations(pDevObj, BMF_24BPP);
        bRetVal    = SendPatternBrush(pDevObj, pBrush, pptlBrushOrg, pBrushInfo, ePCL);
        eDwnldType = ePCL;
    }
    else
    {
        if ( BIsColorPrinter(pDevObj) && eStylusType == kPen )
        {
            //
            // Case 2 a 
            // In monochrome, pen is converted to a pattern, so it more like 
            // brush than a pen.
            //
            pBrush->eFillType   = FT_eHPGL_PEN ; // 2
        }
        else    
        {
            // Case 1,3,4 a, 
            pBrush->eFillType = FT_eHPGL_BRUSH; // 11
        }

        bRetVal     = SendPatternBrush(pDevObj, pBrush, pptlBrushOrg, pBrushInfo, eHPGL);
        eDwnldType  = eHPGL;
    }
    
    if (bRetVal )
    {
        poempdev->pBrushCache->BSetDownloadType((DWORD)lPatternID, eDwnldType);
        poempdev->pBrushCache->BSetDownloadedFlag((DWORD)lPatternID, TRUE);
    }
    
  finish :
    return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// DownloadPatternAsPCL()
//
// Routine Description:
// 
//   This function actually sends the PCL commands for the pattern brush
//   definition.  Since the CLJ5 doesn't support PCL pattern brushes we will
//   use a different function to sent its bits.  This one is for the 4500.
//
// Arguments:
// 
//   pDevObj    - Points to our PDEVOBJ structure
//	 pImage     - 
//	 pPalette   - the origin of the brush
//   lPatternID - The PBRUSHINFO that holds the pattern.
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL DownloadPatternAsPCL(
    IN  PDEVOBJ         pDevObj,
    IN  PRASTER_DATA    pImage,
    IN  PPALETTE        pPalette,
    IN  EIMTYPE         ePatType,
    IN  LONG            lPatternID)
{
    BYTE aubPatternHeader[sizeof(PATTERNHEADER)];
    LONG ulPatternHeaderSize;

    ULONG ulColor;
    ULONG ulPaletteEntry;
    
    ULONG    ulNumBytes         = 0;
    PBYTE    pByte              = NULL;
    BOOL     bRetVal            = TRUE;
    BOOL     bProxyDataUsed     = FALSE; // whether mem as been allocated.
    POEMPDEV poempdev           = NULL;

    REQUIRE_VALID_DATA ( pDevObj, return FALSE);
    poempdev = GETOEMPDEV(pDevObj);
    REQUIRE_VALID_DATA (poempdev, return FALSE);


    // 
    // The pattern is written out in the following manner:
    // 1) PCL download pattern code (Esc*c#g#W)
    // 2) Pattern Header
    // 3) Pattern Data
    // The pattern header indicates the size of the image to be downloaded.
    // This size may or may not be same as the size of the image that is 
    // passed in (because of padding). If the size is same, it means there 
    // is no padding, so this image can be directly flushed to the printer.
    // But if size is different, BCreatePCLDownloadablePattern will be used to create
    // a compact bit pattern (remove padding etc...). 
    //

    if ( pImage->cBytes == ( (pImage->size.cx * pImage->size.cy * (ULONG)pImage->colorDepth) >> 3) )
    {
        pByte      = pImage->pBits;
        ulNumBytes = pImage->cBytes;
    }
    else
    {
        bRetVal = BCreatePCLDownloadablePattern(pDevObj, pImage, &ulNumBytes, &pByte); 
        if ( bRetVal    == FALSE  ||
             ulNumBytes == 0      || 
             pByte      == NULL )
        {
            ERR(("DownloadPatternAsPCL: BCreatePCLDownloadablePattern failed\n"));
            goto finish;
        }

        bProxyDataUsed = TRUE;
    }

    //
    // Before we download the new pattern, lets see if a pattern with
    // the same number has already been downloaded. If so, delete the
    // pattern. Ideally this should not be required, since the new
    // pattern should automatically overwrite the old one. But I have
    // seen cases where it does not. Not sure if that is by design
    // of firmware bug.
    //
    if (poempdev &&
        poempdev->pBrushCache &&
        poempdev->pBrushCache->BGetWhetherRotated() )
    {
        VSendPatternDeleteCommand(pDevObj, lPatternID);
    }

    // 
    // 1 and 2) Fill the pattern header, 
    // and download the pattern. The (Esc*c#g#W) is sent
    // within the DownloadPatternHeader command.
    //
    if (!bCreatePatternHeader(pDevObj, pImage, sizeof(PATTERNHEADER), ePatType, aubPatternHeader) || 
        !BDownloadPatternHeader(pDevObj, sizeof(PATTERNHEADER), aubPatternHeader, 
                                        lPatternID,            ulNumBytes) )
    {
        ERR(("DownloadPatternAsPCL: bCreatepatternHeader or DownloadPatternHeader failed.\n"));
        bRetVal = FALSE;
        goto finish;
    }

    //
    // Finally: (3) output the bytes of Pattern.
    //
    PCL_Output(pDevObj, pByte, ulNumBytes);
    
  finish : 
    if ( bProxyDataUsed && pByte && ulNumBytes )
    {
        MemFree (pByte);
        pByte = NULL;
    }
    return bRetVal;
}


///////////////////////////////////////////////////////////////////////////////
// SendPatternBrush()
//
// Routine Description:
// 
//   This function actually sends the HPGL commands for the pattern brush
//   definition.  Since the CLJ5 doesn't support PCL pattern brushes we will
//   use a different function to sent its bits.  This one is for the CLJ5.
//
// Arguments:
// 
//   pDevObj      - Points to our PDEVOBJ structure
//   pMarker      - The marker object which will track the downloaded pen information
//   pptlBrushOrg - the origin of the brush
//   pBrushInfo   - The PBRUSHINFO that holds the pattern.
//   eRenderLang  - Send as HPGL or PCL
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SendPatternBrush(
        IN  PDEVOBJ     pDevObj,
        IN  PHPGLMARKER pMarker,
        IN  POINTL      *pptlBrushOrg,
        IN  PBRUSHINFO  pBrushInfo,
        IN  ERenderLanguage eRenderLang )
{
    // Convenience Variables
    POEMPDEV      poempdev ; 
    PPATTERN_DATA pPattern;
    PRASTER_DATA  pImage;
    PPALETTE      pPalette;
    BOOL          bRetVal = TRUE;

    REQUIRE_VALID_DATA ((pDevObj && pMarker && pBrushInfo), return FALSE);
    poempdev = GETOEMPDEV(pDevObj);
    REQUIRE_VALID_DATA (poempdev, return FALSE);

    if ( pBrushInfo->bNeedToDownload == FALSE)
    {
        return TRUE;
    }

    //
    // Initialize convenience variables
    //
    pPattern = (PPATTERN_DATA)(((PBYTE)pBrushInfo) + sizeof(BRUSHINFO));
    pImage = &pPattern->image;
    pPalette = &pPattern->palette;
    
    if (!pptlBrushOrg)
    {
        pMarker->origin.x = 0;
        pMarker->origin.y = 0;

        if (pBrushInfo)
        {
            pBrushInfo->origin.x = 0;
            pBrushInfo->origin.y = 0;
        }
    }
    else
    {
        if (pBrushInfo)
        {
            pBrushInfo->origin.x = pptlBrushOrg->x;
            pBrushInfo->origin.y = pptlBrushOrg->y;
        }
        pMarker->origin.x = pptlBrushOrg->x;
        pMarker->origin.y = pptlBrushOrg->y;
    }

    //
    // We can make our lives easier by making sure we aren't trying to use a
    // bit-depth that we can't support.
    //
    switch (pImage->colorDepth)
    {
    case 1:
    case 8:
        // 
        // We can support these.  Allow this routine to continue.
        //
        break;

    case 4:
        //
        // Supported only if printing desired is in HPGL Mode.
        //
        if ( eRenderLang == eHPGL )
        {
            break;
        }
    default:
        //
        // If we got 16,24,32bpp brush in RealizeBrush call, then it should
        // have been converted to an indexed 8bpp image in some previous 
        // function (CreateIndexedPaletteFromImage, CreateIndexedImageFromDirect)
        //

        // Caller should create a NULL pen if I return FALSE.
        bRetVal = FALSE;
    }

    //
    // if VALID_PALETTE flag is set, 
    // Palette points to a valid palette which needs to be downloaded.
    //
    if (   bRetVal && BIsColorPrinter(pDevObj) && 
         ( pBrushInfo->ulFlags & VALID_PALETTE ) )
    {
    
        //
        // Luckily we can use the HPGL palette even if the pattern is 
        // downloaded as PCL. So we dont have to special case here.
        // i.e. we DONT have to do the following
        //
        //      if ( eRenderLang == eHPGL ) {Download palette in HPGL}
        //  else if ( eRenderLang == eCPL ) { Download palette in PCL}
        //

        //
        // Send down the palette as a series of Pen Color (PC) commands.
        // Well : We could also cache palette so that we dont have to download
        // it if it has been downloaded earlier. But I wont implement that caching
        // code now. Maybe later if i have time.
        //
        bRetVal = HPGL_DownloadPenPalette(pDevObj, pPalette);
    }
    
    //
    // The following part needs to be done only if 
    // VALID_PATTERN flag is set.
    // If the printer is color, the pImage points to a color image, and therefore
    // the PALETTE has to be valid. For monochrome, there is the default palette of 
    // black and white.
    //
    if (bRetVal && (pBrushInfo->ulFlags & VALID_PATTERN) )  
    {
        if ( BIsColorPrinter (pDevObj) && !(pBrushInfo->ulFlags & VALID_PALETTE) )
        {
            bRetVal = FALSE;
        }
        else
        {
            //
            // Output the pattern in terms of the RF command. (Note: valid range 
            // for HPGL pattern id is 1-8).
            // Traverse the rows from right to left.
            //
            if ( eRenderLang == eHPGL )
            {
                bRetVal = DownloadPatternAsHPGL(
                                    pDevObj, 
                                    pImage, 
                                    pPalette, 
                                    pPattern->ePatType,
                                    pMarker->lPatternID);
            }
            else
            {
                bRetVal = DownloadPatternAsPCL(
                                    pDevObj, 
                                    pImage, 
                                    pPalette, 
                                    pPattern->ePatType,
                                    pMarker->lPatternID);
            }
        }
    }

    return bRetVal;
}


///////////////////////////////////////////////////////////////////////////////
// ClipToPowerOf2()
//
// Routine Description:
// 
//   This is a quick-n-dirty function to clip a number to the next lowest power
//   of 2.  I accomplish this by shifting right until the value is 1 (counting
//	 the number of shifts) and returning 0x01 << num-shifts.
//
// Arguments:
// 
//   n - the value to be clipped
// 
// Return Value:
// 
//   The value clipped to a power of 2.
///////////////////////////////////////////////////////////////////////////////
int ClipToPowerOf2(int n)
{
    int count;
    
    //
    // If the number is zero or negative just return it.
    //
    if (n <= 0)
        return n;
    
    //
    // Count the number of shifts
    //
    count = 0;
    while (n > 1)
    {
        n = n >> 1;
        count++;
    }
    
    //
    // Return 2^n
    //
    return 0x01 << count;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_BeginPatternFillDef()
//
// Routine Description:
// 
//   Begins a pattern fill definition using the HPGL commands for RasterFill.
//   The brush id is hardcoded to avoid unexpected behaviors.  Since we don't
//	 cache them it won't matter.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   width -  width of pattern
//	 height - heigth of pattern
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_BeginPatternFillDef(PDEVOBJ pDevObj, PATID iPatternNumber, UINT width, UINT height)
{
    HPGL_FormatCommand(pDevObj, "RF%d,%d,%d", iPatternNumber, width, height);
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_AddPatternFillField()
//
// Routine Description:
// 
//   To define the elements of a pattern field using the HPGL RF command.
//   This function should be called width * height times after 
//	 HPGL_BeginPatternFillDef and before HPGL_EndPatternFillDef.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   data - the pen number (i.e. palette index) for this field.
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_AddPatternFillField(PDEVOBJ pDevObj, UINT data)
{
    HPGL_FormatCommand(pDevObj, ",%d", data);

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_EndPatternFillDef()
//
// Routine Description:
// 
//   Terminates an HPGL pattern fill definition.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_EndPatternFillDef(PDEVOBJ pDevObj)
{
    HPGL_FormatCommand(pDevObj, ";");

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SetFillType()
//
// Routine Description:
//
//   Selects the fill type (PCL, HPGL or none).  This should match the way that
//   you defined the pattern.
//
// Arguments:
//
//   pDevObj - Points to our PDEVOBJ structure
//   fillType - use HPGL_ePATTERN_PCL (22) when the pattern has  been downloaded
//              with PCL commands, or HPGL_ePATTERN_HPGL if the pattern has been
//              downloaded with the HPGL_BeginPatternFillDef... functions.
//   lPatternID : this is pattern id, or percentfill or whatever number that goes
//                with eFillType.
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetFillType(PDEVOBJ pDevObj, EFillType eFillType, LONG lPatternID, UINT uFlags)
{

    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);

    if ((uFlags & FORCE_UPDATE) ||
        (pState->Pattern.eFillType != eFillType) ||
        (pState->Pattern.lPatternID != lPatternID))
    {
        pState->Pattern.eFillType  = eFillType;
        pState->Pattern.lPatternID = lPatternID;

        //
        // for FT1, FT2, there is no second parameter.
        //
        if ( eFillType == FT_eSOLID ||
             eFillType == FT_eHPGL_PEN )
        {
            HPGL_FormatCommand(pDevObj, "FT%d;", eFillType);
        }
        else
        {
            HPGL_FormatCommand(pDevObj, "FT%d,%d;",
                                        eFillType,
                                        lPatternID);
        }
    }

    return TRUE;


}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SetPercentFill()
//
// Routine Description:
// 
//   Selects the fill type (PCL, HPGL or none).  This should match the way that
//   you defined the pattern.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   fillType - This version takes a Percent fill structure.  We will take 
//				advantage of the fact that a Pattern fill is so similar to a 
//				percent fill and use the HPGLSTATE::Pattern to keep track of
//				the current percent fill.
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetPercentFill(PDEVOBJ pDevObj, ULONG iPercent, UINT uFlags)
{
    
    return HPGL_SetFillType(pDevObj, FT_ePERCENT_FILL, (LONG)iPercent, uFlags);

}

///////////////////////////////////////////////////////////////////////////////
// HPGL_SetSolidFillType()
//
// Routine Description:
//
//   Sets the fill type to solid fill.  
//
// Arguments:
//
//   pDevObj - Points to our PDEVOBJ structure
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetSolidFillType(PDEVOBJ pDevObj, UINT uFlags)
{
    return HPGL_SetFillType(pDevObj, FT_eSOLID, 0, uFlags);
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_ResetFillType()
//
// Routine Description:
// 
//   Sets the fill type back to default (solid fill).  You could also get this
//	 effect from calling HPGL_SetFillType(pDevObj, 1).
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_ResetFillType(PDEVOBJ pDevObj, UINT uFlags)
{

    return HPGL_SetSolidFillType(pDevObj, uFlags) ;

}


///////////////////////////////////////////////////////////////////////////////
// HPGL_StartDoc()
//
// Routine Description:
// 
//   Sets up state information for start of doc.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   None
///////////////////////////////////////////////////////////////////////////////
VOID HPGL_StartDoc(PDEVOBJ pDevObj)
{
    POEMPDEV poempdev = GETOEMPDEV(pDevObj);
    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);

    poempdev->bInitHPGL = 0;                    // = TRUE
    poempdev->bInitHPGL |= INIT_HPGL_STARTPAGE; // Force page-related initialization
    poempdev->bInitHPGL |= INIT_HPGL_STARTDOC;  // Force document-related initialization

    HPGL_InitPenPool(&pState->PenPool,   HPGL_PEN_POOL);
    HPGL_InitPenPool(&pState->BrushPool, HPGL_BRUSH_POOL);

    EndHPGLSession(pDevObj);
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_StartPage()
//
// Routine Description:
// 
//   Sets up state information for start of page.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   None
///////////////////////////////////////////////////////////////////////////////
VOID HPGL_StartPage(PDEVOBJ pDevObj)
{
    POEMPDEV poempdev = GETOEMPDEV(pDevObj);
    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);

    poempdev->bInitHPGL |= INIT_HPGL_STARTPAGE;

    HPGL_InitPenPool(&pState->PenPool,   HPGL_PEN_POOL);
    HPGL_InitPenPool(&pState->BrushPool, HPGL_BRUSH_POOL);

    EndHPGLSession(pDevObj);
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_SetNumPens()
//
// Routine Description:
// 
//   Outputs the HPGL command to request a minimum number of pens.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   iNumPens - desired number of pens
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, else FALSE
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetNumPens(PDEVOBJ pDevObj, INT iNumPens, UINT uFlags)
{
    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);

    // We only increase the number of pens.  There's no point in 
    // decreasing it since FW will keep the larger palette anyway.
    if ((uFlags & FORCE_UPDATE) || (pState->iNumPens < iNumPens))
    {
        pState->iNumPens = iNumPens;
        HPGL_FormatCommand(pDevObj, "NP%d;", pState->iNumPens);
    }
    
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// bCreatePatternHeader()
//
// Routine Description:
// 
//   Create PATTERNHEADER.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   pImage - Points to RASTER_DATA structure
//   cBytes - number of bytes in pubPatternHeader
//   pPatternHeader - Points to PATTERNHEADER structure
// 
// Return Value:
// 
//   TRUE if successful, else FALSE
///////////////////////////////////////////////////////////////////////////////
BOOL bCreatePatternHeader(
        IN   PDEVOBJ        pDevObj, 
        IN   PRASTER_DATA   pImage,
        IN   ULONG          cBytes,
        IN   EIMTYPE        ePatType,
        OUT  PBYTE          pubPatternHeader)
{

    if ( pDevObj == NULL || pImage == NULL || pubPatternHeader == NULL ||
         cBytes != sizeof(PATTERNHEADER) )
    {
        ERR(("bCreatePatternHeader: invalid parameters.\n"));
        return FALSE;
    }

    ZeroMemory (pubPatternHeader, cBytes);

    //
    // Format         : 0x1 (i.e. 1 or 8 bits per pixel) for color printers.
    //                  0x14 for monochrome printers.
    // Reserved       : Should be 0
    // Pixel encoding : ColorDepth
    // Reserved       : Should be 0
    //
    pubPatternHeader[0] = BIsColorPrinter(pDevObj) ? 0x1 : 0x14;
    pubPatternHeader[1] = 0x00;
    pubPatternHeader[2] = (BYTE) pImage->colorDepth;
    pubPatternHeader[3] = 0x00;

    //
    // Image size
    // pubPatternHeader[4, 5] Height in pixels
    // pubPatternHeader[6, 7] Width in pixels
    // brush14.emf has pattern whose height and width are
    // not same.
    //
    pubPatternHeader[4] = HIBYTE((WORD)pImage->size.cy);
    pubPatternHeader[5] = LOBYTE((WORD)pImage->size.cy);
    pubPatternHeader[6] = HIBYTE((WORD)pImage->size.cx);
    pubPatternHeader[7] = LOBYTE((WORD)pImage->size.cx);

    //
    // X and Y resolution
    // For Color printers these last 4 bytes in header are not to be sent.
    // since a certain resolution is assumed ( See manual Esc*c#W command)
    //
    if ( pubPatternHeader[0] == 0x14 )
    {
        ULONG ulDeviceRes = 300; //cos we expand pcl pattern to only 300dpi
        if (  ePatType == kCOLORDITHERPATTERN ) 
        { 
            //
            // The dither pattern does not need expansion.
            // atleast thats what i have seen on 600 dpi printer for
            // which this driver is initially targetted at.
            //
            ulDeviceRes = HPGL_GetDeviceResolution(pDevObj);
        }
        
        pubPatternHeader[8]  = HIBYTE((WORD)ulDeviceRes);
        pubPatternHeader[9]  = LOBYTE((WORD)ulDeviceRes);
        pubPatternHeader[10] = HIBYTE((WORD)ulDeviceRes);
        pubPatternHeader[11] = LOBYTE((WORD)ulDeviceRes);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// BDownloadPatternHeader()
//
// Routine Description:
// 
//   Downloads the pattern Header
//
// Arguments:
// 
//   pDevObj          - Points to our PDEVOBJ structure
//   cBytes           - number of bytes in pubPatternHeader
//   pubPatternHeader - Points to the stream of bytes that form a PATTERNHEADER structure
//   lPatternID       - PatternID. If negative, then dont send the patterndownload command.
//   cBytesInPattern  - Count of bytes in the pattern for which the header is to be sent. 
//                      If lPatternID is negative, then ignore this parameter.
// 
// Return Value:
// 
//   TRUE if successful, else FALSE
///////////////////////////////////////////////////////////////////////////////
BOOL BDownloadPatternHeader(
        IN   PDEVOBJ        pDevObj, 
        IN   ULONG          cBytesInHeader,
        IN   PBYTE          pubPatternHeader,
        IN   LONG           lPatternID,
        IN   ULONG          cBytesInPattern)
{

    POEMPDEV poempdev;
    ULONG    ulPatternHeaderSize;

    if ( pDevObj == NULL || pubPatternHeader == NULL ||
         cBytesInHeader != sizeof(PATTERNHEADER) )
    {
        ERR(("BDownloadPatternHeader: invalid parameters.\n"));
        return FALSE;
    }

    poempdev = GETOEMPDEV(pDevObj);


    //
    // size of header for color printers is 8, for monochrome is 12
    //
    ulPatternHeaderSize = BIsColorPrinter(pDevObj) ? 8 : 12;


    if ( lPatternID >= 0)
    {
        //
        // Total bytes to be sent = size of header + size of pattern
        //
        vSendPatternDownloadCommand(pDevObj, lPatternID, (ulPatternHeaderSize + cBytesInPattern) );
    }

    // 
    // Now output the actual pattern header. For HPC4500 the header is 12 bytes,
    // while for hpclj is it 8 bytes. The last 4 bytes in pattern header are not sent 
    // for HPCLJ
    //
    PCL_Output(pDevObj, pubPatternHeader, ulPatternHeaderSize);

    return TRUE;
}

/*++

Routine Name:
    BCreatePCLDownloadablePattern

Routine Description:
    This function accepts a raster image (pImage) and converts it to 
    a downloadable pattern. i.e. brush download. 
    This only works for 1bpp and 8bpp. 
    4bpp brushes will be downloaded as HPGL so this function should not 
    be called. 
    Patterns > 8bpp are converted to 8bpp before calling this function.

Arguments:
    pDevObj
    pImage       - The source image.

    pulBufLength - The memory where this function will write the length of
                   the pattern it created.
    ppByte       - The pattern. This is just a stream of bytes in the form 
                   the PCL data. The calling function should remember to free
                   this memory after using it.

Return Value:
    TRUE if the the conversion succeeds OR if the image is empty. 
    FALSE : otherwise.

Author:
    -hsingh-    9/26/2000

Revision History:

--*/

BOOL BCreatePCLDownloadablePattern( 
            IN  PDEVOBJ      pDevObj, 
            IN  PRASTER_DATA pImage,
            OUT PULONG       pulBufLength,
            OUT PBYTE       *ppByte)
{
    RASTER_ITERATOR it;
    PIXEL           pel;
    ULONG           ulNumRows      = 0;   // Num of rows in pattern.
    ULONG           ulNumCols      = 0;   // Num of cols in pattern.
    ULONG           ulrow          = 0;   // row iterator
    ULONG           ulcol          = 0;   // column iterator
    ULONG           ulColorDepth   = 0;   // Color depth of image. 
    PBYTE           pByte          = NULL;// The pattern which is created.
    ULONG           ulBufLength    = 0;   // Size of pattern (in bytes).
    ULONG           ulPixelNumber  = 0;   // The pixel number in the pattern.
    BOOL            bRetVal        = TRUE;// Return value
    ULONG           ulNumBytesPerRow;
    

    if (pDevObj == NULL || pImage == NULL || pulBufLength == NULL || ppByte == NULL)
    {
        ERR(("BCreatePCLDownloadablePattern : Invalid Parameter\n"));
        return FALSE;
    }

    RI_Init(&it, pImage, NULL, 0);

    ulNumCols      = (ULONG)RI_NumCols(&it);
    ulColorDepth  = pImage->colorDepth;
    ulNumRows      = (ULONG)RI_NumRows(&it);
    *pulBufLength = (ULONG)0;
    *ppByte       = NULL;

    //
    // Check if it makes sense to go ahead.
    // if MSB of ulNumCols,ulNumRows is 1, it means RI_NumCols returned
    // a negative number (NOTE: we typecasted LONG to ULONG)
    //
    if ( ulNumCols & ( 0x1 << ( sizeof(ULONG)*8 -1) )||  
         ulNumRows & ( 0x1 << ( sizeof(ULONG)*8 -1) )|| 
         !(ulColorDepth == 1 || ulColorDepth == 8) 
       )
    {
        return FALSE; 
    }

    //
    // Is there anything to print.
    //
    if ( ulNumCols == 0 || ulNumRows == 0 )
    {
        return TRUE; 
    }
    

    //
    // Find out how much memory the pattern will take.
    // Note that the image is DWORD padded, so simply using 
    // pImage->cBytes will give us a bigger buffer.
    // So the number of columns = number of pixels going left to right
    // must be looked at. The number of bits that make up each row can be 
    // any number, it does not necessarily have to be a multiple of 8.
    // But PCL expects that information about a row should only end at
    // the end of byte i.e. We cant have a part of byte used for row n
    // and the remaining part for row n+1. So if numBits per row is not a multiple
    // of 8, the buffer that we make should make a provision for the padded
    // bits to fill up the byte.
    //
    // Instead of doing a complex calculation here, lets make it simple.
    // This function will get called only for 1bpp or 8bpp (because PCL patterns
    // support 1bpp and 8bpp only). For 8bpp every byte denotes a single pixel
    // so the above problem wont arise. Only thing we need to worry about is
    // for 1bpp. In 1bpp, number of columns = number of pixels and each byte
    // denotes 8 pixel.s
    //
    if ( ulColorDepth == 1 && ulNumCols%8 != 0 )
    {
        ulNumBytesPerRow = (ulNumCols +  (8 - ( ulNumCols%8) )) >> 3;
    }
    else
    {
        ulNumBytesPerRow = ( ulNumCols * ulColorDepth ) >> 3;
    }

    ulBufLength = ulNumRows *  ulNumBytesPerRow;

    //
    // If the ulBufLength increases pImage->cBytes then that is 
    // an error. If we ignore, it will cause buffer overrun AV.
    //
    if ( ulBufLength > pImage->cBytes )
    {
        ASSERT ( ulBufLength <= pImage->cBytes )
        ERR(("BCreatePCLDownloadablePattern : ulBufLength > pImage->cBytes failed\n"));
        return FALSE;
    }

    pByte = (PBYTE) MemAllocZ( ulBufLength );
    if ( !pByte )
    {
        ERR(("BCreatePCLDownloadablePattern : MemAlloc failure\n"));
        return FALSE;
    }

    //
    // 
    //
    PBYTE pByteMain = pByte; //Store the begining of pByte
    ULONG bitOffset = 0;     // offset within a byte where the pixel 
                             // value is to be put. 
                             // For 1bpp it can be 0-7.
                             // For 4bpp, it can be 0 or 4
                             // For 8bpp, not used.
    *ppByte         = pByte;
    *pulBufLength   = ulBufLength;

    for (ulrow = 0; ulrow < ulNumRows; ulrow++)
    {
        RI_SelectRow(&it, ulrow);

        //
        // If ulPixelNumber is not a multiple of 8
        // then make it a multiple of 8 by increasing its value
        // e.g if ulPixelNumber is 62, make it 64
        // This is required for byte padding (i.e. start 
        // a new row with a new byte).
        // For 8bpp, no byte padding is required.
        // since each pixel is a byte.
        //
        if ( ulColorDepth == 1 && ulPixelNumber%8 != 0 )
        {
            ulPixelNumber +=  (8 - ( ulPixelNumber%8) );
        }

        for (ulcol = 0; ulcol < ulNumCols; ulcol++)
        {
            RI_GetPixel(&it, ulcol, &pel);
            if ( pel.color.dw )
            {
                switch (ulColorDepth)
                {
                  case 1:
                    pByte     = pByteMain + (ulPixelNumber >> 3);
                    bitOffset = ( ulPixelNumber % 8);
                    *(pByte) |= (0x1 << (7-bitOffset));
                    break;
                  case 8:
                    pByte     = pByteMain + ulPixelNumber; 
                    *(pByte)  = (BYTE)pel.color.dw;
                    break;
                } //switch
            } //if

            ulPixelNumber++;

        } //for ulcol
    } //for ulrow

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpgl2col.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    hpgl2col.h

Abstract:

    HPGL2 modules main header file. All other header files should
    be included in this for precompiled headers to work.

Environment:

        Windows NT Unidrv driver

Revision History:

    2/21/2002 -hsingh-
        Created

        dd-mm-yy -author-
                description

--*/

#ifndef _HPGL2COL_H_
#define _HPGL2COL_H_

#include "unidrv.h"        //Unidr's unidrv.h file that includes all standard windows header files
#include "clip.h"
#include "clrsmart.h"
#include "comnfile.h"
#include "compress.h"
#include "gloemkm.h"
#include "glpalett.h"
#include "glpdev.h"
#include "brshcach.h"
#include "glraster.h"
#include "hpcljcom.h"
#include "hpgl.h"
#include "hpgl_pen.h"
#include "hpgl_pri.h"
#include "hpglctrl.h"
#include "hpglpoly.h"
#include "htblt.h"
#include "gldebug.h"
#include "glvminit.h"
#include "line.h"
#include "mix.h"
#include "names.h"
#include "oem.h"
#include "oemdev.h"
#include "oemud.h"
#include "path.h"
#include "pcl.h"
#include "penbrush.h"
#include "ras_proc.h"
#include "rasdata.h"
#include "realize.h"
#include "resource.h"
#include "udprocs.h"
#include "utility.h"
#include "vector.h"

#endif //!_HPGL2COL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpgl.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1996-2002  Microsoft Corporation
// 
// Module Name:
// 
//   hpgl.h
// 
// Abstract:
// 
//   Header for vector module.  Forward decls for vector functions and types.
// 
// Environment:
// 
//   Windows 2000/Windows XP/Windows Server 2003 Unidrv driver 
//
// Revision History:
// 
//
///////////////////////////////////////////////////////////////////////////////

#ifndef HPGL_H
#define HPGL_H

#include "hpglpoly.h"

#include "hpgl_pen.h"


#define CONVERT_FLOATOBJ_TO_LONG_RADIX(fObj,lInt) \
        FLOATOBJ f; \
        FLOATOBJ_Assign(&f, &fObj); \
        FLOATOBJ_MulFloat(&f, 1000000); \
        if (FLOATOBJ_LessThanLong(&f, 0)) \
        { \
            FLOATOBJ_SubFloat(&f, 0.5); \
        } \
        else \
        { \
            FLOATOBJ_AddFloat(&f, 0.5); \
        } \
        LONG lInt = FLOATOBJ_GetLong(&f);

#define GETOEMPDEV(pdev) ((POEMPDEV)pdev->pdevOEM)

#define GETHPGLSTATE(pdev) (&(GETOEMPDEV(pdev)->HPGLState))

// HPGL command flags
#define NORMAL_UPDATE   0x0000
#define FORCE_UPDATE    0x0001

typedef struct _PATTERNHEADER{
        BYTE bFormat;
        BYTE bReserved0;
        BYTE bPixelEncoding;
        BYTE bReserved1;
        WORD wHeight;
        WORD wWidth; // (Note: 8 bytes to this point)
        WORD wXRes; // Format 20 only
        WORD wYRes; // Format 20 only (Note: 12 bytes to this point)
    } PATTERNHEADER, *PPATTERNHEADER;

#define DITHERPATTERNSIZE 0x08 //Number of bytes in dither pattern.

VOID HPGL_StartDoc(PDEVOBJ pDevObj);
VOID HPGL_StartPage(PDEVOBJ pDevObj);

BOOL PCL_SelectTransparency(PDEVOBJ pDevObj, 
    ETransparency SourceTransparency,
    ETransparency PatternTransparency,
    BYTE bFlags
);

BOOL HPGL_SelectROP3(PDEVOBJ pDevObj, ROP4 Rop3);

BOOL HPGL_BeginHPGLMode(PDEVOBJ pdev, UINT uFlags);
BOOL HPGL_EndHPGLMode(PDEVOBJ pdev, UINT uFlags);
BOOL HPGL_Init(PDEVOBJ pdev);
BOOL HPGL_SelectTransparency(PDEVOBJ pdev, ETransparency Transparency, BYTE bFlags);
BOOL HPGL_SetupPalette(PDEVOBJ pdev);
BOOL PCL_SetupRasterPalette(PDEVOBJ pdev);
BOOL PCL_SetupRasterPatternPalette(PDEVOBJ pdev);
BOOL HPGL_Command(PDEVOBJ pdev, int nArgs, char *szCmd, ...);
BOOL HPGL_FormatCommand(PDEVOBJ pdev, const PCHAR szFormat, ...);
BOOL HPGL_SetPixelPlacement(PDEVOBJ pdev, EPixelPlacement place, UINT uFlags);
BOOL HPGL_ResetClippingRegion(PDEVOBJ pdev, UINT uFlags);
BOOL HPGL_SetClippingRegion(PDEVOBJ pdev, LPRECTL pClipRect, UINT uFlags);

BOOL DownloadPatternFill(PDEVOBJ pDevObj, PHPGLMARKER pBrush,
                         POINTL *pptlBrushOrg, PBRUSHINFO pHPBrush, ESTYLUSTYPE eStylusType);
BOOL bCreatePatternHeader(
        IN   PDEVOBJ        pDevObj,
        IN   PRASTER_DATA   pImage,
        IN   ULONG          cBytes,
        IN   EIMTYPE        ePatType,
        OUT  PBYTE          pubPatternHeader);

BOOL BDownloadPatternHeader(
        IN   PDEVOBJ        pDevObj,
        IN   ULONG          cBytesInHeader,
        IN   PBYTE          pubPatternHeader,
        IN   LONG           lPatternID,
        IN   ULONG          cBytesInPattern);

BOOL bSendSolidColorAsDitherData(
        IN  PDEVOBJ     pDevObj,
        IN  LONG        iPatternNumber,
        IN  COLORREF    color);

BOOL SendPatternBrush(
        IN  PDEVOBJ     pDevObj,
        IN  PHPGLMARKER pMarker,
        IN  POINTL      *pptlBrushOrg,
        IN  PBRUSHINFO  pHPBrush,
        IN  ERenderLanguage eRenderLang);

BOOL DownloadPatternAsPCL(
    IN  PDEVOBJ         pDevObj,
    IN  PRASTER_DATA    pImage,
    IN  PPALETTE        pPalette,
    IN  EIMTYPE         ePatType,
    IN  LONG            lPatternID);

#ifdef COMMENTEDOUT
BOOL PCL_SelectPaletteByID(PDEVOBJ pDevObj, EObjectType eObject);
#endif

// Pattern fill functions.  Use Begin/Add/End to create an HPGL pattern.
// Use Set and Reset to select the desired pattern type (HPGL, PCL or none).
// The SendPatternBrush function will download either an HPGL or PCL pattern.
// The SelectAndFill function selects the pattern and fills with it.
// The ::SelectBrush function will reset the fill type for solid colors.
BOOL HPGL_BeginPatternFillDef(PDEVOBJ pDevObj, PATID iPatternNumber, UINT width, UINT height);
BOOL HPGL_AddPatternFillField(PDEVOBJ pdevobj, UINT data);
BOOL HPGL_EndPatternFillDef(PDEVOBJ pdevobj);
BOOL HPGL_SetFillType(PDEVOBJ pDevObj,  EFillType eFillType, LONG lPatternID, UINT uFlags);
BOOL HPGL_SetPercentFill(PDEVOBJ pDevObj, ULONG  iPercent, UINT uFlags);
BOOL HPGL_SetSolidFillType(PDEVOBJ pDevObj, UINT uFlags);
BOOL HPGL_ResetFillType(PDEVOBJ pdevobj, UINT uFlags);
BOOL HPGL_SetNumPens(PDEVOBJ pDevObj, INT iNumPens, UINT uFlags);
VOID VDeleteAllPatterns( IN  PDEVOBJ     pDevObj);

#endif // HPGL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpglctrl.h ===
///////////////////////////////////////////////////////////////////////////////
// 
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
// 
//   hpglctrl.h
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   08/06/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#ifndef HPGLCTRL_H
#define HPGLCTRL_H

BOOL InitializeHPGLMode(PDEVOBJ pdevobj);

BOOL BeginHPGLSession(PDEVOBJ pdevobj);

BOOL EndHPGLSession(PDEVOBJ pdevobj);

BOOL ValidDevData(PDEVOBJ pDevObj);

BOOL HPGL_LazyInit(PDEVOBJ pDevObj);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpglctrl.cpp ===
/*++
Copyright (c) 1999-2001  Microsoft
 
Module Name:
   hpglctrl.cpp
 
Abstract:
    Contains HPGL control functions
 
Author
 
Revision History:
  07/02/97 -v-jford-
       Created it.


--*/

#include "hpgl2col.h" //Precompiled header file

///////////////////////////////////////////////////////////////////////////////
// Local Macros.

///////////////////////////////////////////////////////////////////////////////
// InitializeHPGLMode()
//
// Routine Description:
// 
//   This function should be called at the beginning of the print session.  It
//   initializes the printer's HPGL state to our desired settings.  Note that we
//   briefly enter HPGL mode to accomplish this.
//
//   TODO: Add code to track the graphics state here.  Determine desired defaults
//   and implement them.
//
//   TODO: Add IsInHPGLMode (or something of that sort) and avoid going in and
//   out of HPGL mode all the time.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
#define PU_PER_INCH  1016

BOOL InitializeHPGLMode(PDEVOBJ pdevobj)
{
    ULONG xRes, yRes;

    #if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
    FLOATOBJ XScale;
    FLOATOBJ YScale;
    #else
    float XScale;
    float YScale;
    #endif

    BOOL       bRet = TRUE;
    POEMPDEV   poempdev;
    BOOL       bInitHPGL;
    char       cmdStr[64];
    INT        icchWritten = 0;
   
    VERBOSE(("Entering InitializeHPGLMode...\n"));
    
    PRECONDITION(pdevobj != NULL);
    
    ASSERT_VALID_PDEVOBJ(pdevobj);
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    /*/
    ASSERT(poempdev);
    /*/
    REQUIRE_VALID_DATA( poempdev, return FALSE );
    //*/
    
    
    ZeroMemory ( cmdStr, sizeof(cmdStr) );
    //
    // Immediately set this to OFF so that no other calls caused by this 
    // initialization function will cause itself to be called! JFF
    //
    bInitHPGL = poempdev->bInitHPGL;
    poempdev->bInitHPGL = 0;

    TRY
    {
        //
        // Setup hpgl palette
        //
        if (!HPGL_SetupPalette(pdevobj))
            TOSS(WriteError);
        
        VSelectCIDPaletteCommand (pdevobj, eHPGL_CID_PALETTE);
        
        //
        // Perform this only on starting the document itself.
        //
        if (bInitHPGL & INIT_HPGL_STARTDOC)
        {
            //
            // Possible OPTIMIZATION : If we can better track positions, we may not 
            // need to move to 0,0 
            //
            HPGL_EndHPGLMode(pdevobj, NORMAL_UPDATE);

            OEMXMoveTo(pdevobj, 0, MV_GRAPHICS | MV_SENDXMOVECMD);
            OEMYMoveTo(pdevobj, 0, MV_GRAPHICS | MV_SENDYMOVECMD);

            //
            // Picture frame anchor command
            //
            PCL_sprintf(pdevobj, "\x1B*c0T");
        }

        //
        // Send Esc%0B to begin HPGL mode
        //
        if (!HPGL_BeginHPGLMode(pdevobj, FORCE_UPDATE))
            TOSS(WriteError);
        
        //
        // Send IN to initialize HPGL state
        //
        if (!HPGL_Init(pdevobj))
            TOSS(WriteError);
        
        //
        // TR0: Transparency mode
        //
        if (!HPGL_SelectTransparency(pdevobj, eOPAQUE,1))
            TOSS(WriteError);
        
        //
        // LO21: Label origin
        // Since we are not using labels, so no need to set the label origin?
        //
        
        //
        // Get resolution
        //
        xRes = yRes = HPGL_GetDeviceResolution(pdevobj);
        TERSE(("xRes = %d\n", xRes));

        //
        // #390371. Initially the SC string was being created dynamically.
        // by calculating the numbers and using sprintf. But that created
        // issues with certain languages (like German) where the . (period) 
        // in the decimal number was formatted to a , (comma) in the 
        // string. To prevent that, we'll hardcord the strings for the most
        // common resolutions. For any other resolution, I'll do the calculation
        // like before.
        //
        switch (xRes) //Note x,y resolutions are same.
        {
            case 150:
                icchWritten = iDrvPrintfSafeA ( PCHAR (cmdStr), CCHOF(cmdStr), "SC0,6.773333,0,-6.773333,2;");
                break;
            case 300:
                icchWritten = iDrvPrintfSafeA ( PCHAR (cmdStr), CCHOF(cmdStr), "SC0,3.386667,0,-3.386667,2;");
                break;
            case 600: 
                icchWritten = iDrvPrintfSafeA ( PCHAR (cmdStr), CCHOF(cmdStr), "SC0,1.693333,0,-1.693333,2;");
                break;
            case 1200:
                icchWritten = iDrvPrintfSafeA ( PCHAR (cmdStr), CCHOF(cmdStr), "SC0,0.846667,0,-0.846667,2;");
                break;
            default:

                //
                // Calculate scaling factor.  Scale to 1016/<dpi> x -1016/<dpi> to get to
                // device units.
                // Note that y axis is negative (i.e. reversed)!  This is because PCL 
                // thinks top-down and HPGL thinks bottom-up.
                //
                #if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
                FLOATOBJ_SetLong(&XScale, PU_PER_INCH);
                FLOATOBJ_DivLong(&XScale, xRes);

                FLOATOBJ_SetLong(&YScale, -PU_PER_INCH);
                FLOATOBJ_DivLong(&YScale, yRes);
                #else
                XScale = PU_PER_INCH / (float)xRes;
                YScale = -PU_PER_INCH / (float)yRes;
                #endif

                icchWritten = iDrvPrintfSafeA((PCHAR)cmdStr, CCHOF(cmdStr), "SC0,%f,0,%f,2;", XScale, YScale);

                /*****  Commented because dangerous. Locale change is per process, not per thread.
                        But if at some time it becomes essential to do it, then do the following
                        instead of the above sprintf
                        You may have to include <locale.h> for this to work.

                    
                //
                // To prevent the localization problem stated above.
                //  1) Retrieve the current numeric locale using  setlocale(LC_NUMERIC, NULL), 
                //  2) Set the numeric locale to the minimal ANSI conforming 
                //      environment - setlocale(LC_NUMERIC, "C")
                //  3) Restore the locale settings.
                //

                TCHAR * szLocaleString = _wsetlocale(LC_NUMERIC, NULL);
                if ( szLocaleString && _wsetlocale(LC_NUMERIC, TEXT("C")) )
                {
                    sprintf(cmdStr,"SC0,%f,0,%f,2;", XScale, YScale);
                    _wsetlocale(LC_NUMERIC, szLocaleString);
                }
                else
                {
                    //
                    // If all else fails, set the default for 600dpi.
                    //
                    strcpy(cmdStr, "SC0,1.693333,0,-1.693333,2;");
                }
                ********/
                break;
            
        } //switch.

        if ( icchWritten > 0 )
        {
            HPGL_Output (pdevobj, cmdStr, (ULONG)icchWritten);
        }


        //
        // Set Rotate Coordinate System value. #540237
        //
        HPGL_FormatCommand(pdevobj, "RO0");

        //
        // IR: Input P1, P2, relative.
        // Set P1 to upper left of hard-clip and P2 to lower right of hard-clip
        //
        HPGL_FormatCommand(pdevobj, "IR0,100,100,0;");

        //
        // Set line width to single pixel by default.  Note that any real 
        // vector command will include a line definition, but this primes
        // the pump.
        //
        if (!HPGL_SetLineWidth(pdevobj, 0, FORCE_UPDATE))
            TOSS(WriteError);
        
        //
        // Initialize line type
        //
        if (!HPGL_SelectDefaultLineType(pdevobj, FORCE_UPDATE))
            TOSS(WriteError);

        //
        // Set line attributes
        //
        if (!HPGL_SetLineJoin(pdevobj, eLINE_JOIN_MITERED, FORCE_UPDATE) ||
            !HPGL_SetLineEnd(pdevobj, eLINE_END_BUTT, FORCE_UPDATE) ||
            !HPGL_SetMiterLimit(pdevobj, MITER_LIMIT_DEFAULT, FORCE_UPDATE))
        {
            TOSS(WriteError);
        }

        //
        // Make sure that the palette in the printer matches our preconceptions.
        //
        if ( BIsColorPrinter(pdevobj) )
        {
            if (!HPGL_DownloadDefaultPenPalette(pdevobj))
            {
                TOSS(WriteError);
            }

            if (!HPGL_SetPixelPlacement(pdevobj, ePIX_PLACE_CENTER, FORCE_UPDATE))
                TOSS(WriteError);

        }
        else
        {
            HPGL_FormatCommand(pdevobj, "SP1");
        }

        if (!HPGL_ResetFillType(pdevobj, FORCE_UPDATE))
            TOSS(WriteError);
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    ENDTRY;

    VERBOSE(("Exiting InitializeHPGLMode...\n"));

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////
// BeginHPGLSession()
//
// Routine Description:
// 
//   Sends the PCL command to begin the HPGL session (i.e. enter HPGL mode).
//   This function provides a clear interface to the calling layer.  Although 
//   this routine is trivial there may be additional functionality to add later 
//   on.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL BeginHPGLSession(PDEVOBJ pdevobj)
{
    BOOL       bRet;
    POEMPDEV   poempdev;

    VERBOSE(("Entering BeginHPGLSession...\n"));

    PRECONDITION(pdevobj != NULL);

    ASSERT_VALID_PDEVOBJ(pdevobj);
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    /*/
    ASSERT(poempdev);
    /*/
    REQUIRE_VALID_DATA( poempdev, return FALSE );
    //*/

    //
    // Lazy init of HPGL mode
    //
    if (poempdev->bInitHPGL)
    {
        bRet = InitializeHPGLMode(pdevobj);
        poempdev->bInitHPGL = 0;
    }
    else
    {
        //
        // if we were previously printing text or vectors,
        // then we switch to the hpgl print environment
        //
        if (poempdev->eCurObjectType != eHPGLOBJECT)
        {
            VSelectCIDPaletteCommand (pdevobj, eHPGL_CID_PALETTE);
            bRet = HPGL_BeginHPGLMode(pdevobj, NORMAL_UPDATE);
            poempdev->eCurObjectType = eHPGLOBJECT;
            poempdev->uCurFgColor = HPGL_INVALID_COLOR;
        }
        else
        {
            //
            // we are still printing vectors, however check to see
            // if we need to switch to HPGL/2.
            //
            bRet = HPGL_BeginHPGLMode(pdevobj, NORMAL_UPDATE);
        }    
    }
    
    VERBOSE(("Exiting BeginHPGLSession...\n"));
    
    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// EndHPGLSession()
//
// Routine Description:
// 
//   Sends the PCL command to end the HPGL session (i.e. returns to PCL mode).
//   This function provides a clear interface to the calling layer.  Although 
//   this routine is trivial there may be additional functionality to add later 
//   on.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL EndHPGLSession(PDEVOBJ pdevobj)
{
    BOOL bRet;

    VERBOSE(("Entering EndHPGLSession...\n"));

    bRet = HPGL_EndHPGLMode(pdevobj, NORMAL_UPDATE);

    VERBOSE(("Exiting EndHPGLSession...\n"));

	return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// ValidDevData()
//
// Routine Description:
// 
//   Examines the pDevObj and its fields to determine if it contains valid
//   values for each field.  The return value indicates whether the object
//   is valid.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if given devobj has valid values, FALSE otherwise.
///////////////////////////////////////////////////////////////////////////////
BOOL ValidDevData(PDEVOBJ pDevObj)
{
    VERBOSE(("Entering ValidDevData...\n"));

    ASSERT_VALID_PDEVOBJ(pDevObj);

    VERBOSE(("Exiting ValidDevData...\n"));

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_LazyInit()
//
// Routine Description:
// 
//   This function initializes the HPGL state if it has become invalid.  Having
//   this function called explicitly can avoid certain "race" conditions (i.e.
//   initialization problems).
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_LazyInit(PDEVOBJ pDevObj)
{
    BOOL     bRet = TRUE;
    POEMPDEV poempdev;

    ASSERT_VALID_PDEVOBJ(pDevObj);
    poempdev = (POEMPDEV)pDevObj->pdevOEM;

    if (poempdev->bInitHPGL)
    {
        bRet = InitializeHPGLMode(pDevObj);
        poempdev->bInitHPGL = 0;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpcljcom.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.

Module Name:

     hpcljcom.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IHPCLJ5RenderCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IHPCLJ5RenderCF(): m_cRef(1) { };
    ~IHPCLJ5RenderCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//

class IHPCLJ5RenderCB : public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded /*,
                                    OUT INT     *piResult */);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IHPCLJ5RenderCB();
    ~IHPCLJ5RenderCB();

protected:
    IPrintOemDriverUni* m_pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpglpoly.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// 
// Module Name:
// 
//   hpglpoly.c
// 
// Abstract:
// 
//   [Abstract]
//
//   Note that all functions in this module begin with HPGL_ which indicates
//   that they are responsible for outputing HPGL codes.
//
//   [ISSUE] Should a provide Hungarian notation for the return value? JFF
//
//   [TODO] Add ENTERING, EXITING, PRE- and POSTCONDITION macros. JFF
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   07/02/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

///////////////////////////////////////////////////////////////////////////////
// Local Macros

// The linetypes -8 thru 8 are defined by hpgl.
// We will use 8 because we CAN'T create our own line indexes.
#define HPGL_CUSTOM_LINE_TYPE 8

// Set pattern length to 5mm by default.
#define HPGL_DEFAULT_PATTERN_LENGTH 5

///////////////////////////////////////////////////////////////////////////////
// Local functions

///////////////////////////////////////////////////////////////////////////////
// HPGL_BeginPolyline()
//
// Routine Description:
// 
//   Starts a polyline segment by moving to the first point in the sequence.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   pt - First point in polyline
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_BeginPolyline(PDEVOBJ pdev, POINT pt)
{
    // A little hack to combat the printable area problem.
    // I'm tweaking the coordinates a bit.
    // BEGIN HACK ALERT
    if (pt.y == 0)
        pt.y = 1;
    if (pt.x == 0)
        pt.x = 1;
    // END HACK ALERT
    
    // Output: "PU%d,%d;", pt
    return HPGL_Command(pdev, 2, "PU", pt.x, pt.y);
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_AddPolyPt()
//
// Routine Description:
// 
//   Prints the n-th point in a polygon or polyline sequence.  The flags 
//   indicate if this is the first or last point.
//
//   Note that this function works for both polygons and polylines.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   pt - The point to plot
//   uFlags - indicates if point is first or last (or both) in sequence
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_AddPolyPt(PDEVOBJ pdev, POINT pt, USHORT uFlags)
{
    if (uFlags & HPGL_eFirstPoint)
    {
        // Output: "PD"
        HPGL_FormatCommand(pdev, "PD");
    }
    
    // A little hack to combat the printable area problem. 
    // I'm tweaking the coordinates a bit.
    // BEGIN HACK ALERT
    if (pt.y == 0)
        pt.y = 1;
    if (pt.x == 0)
        pt.x = 1;
    // END HACK ALERT

    // Output: "%d,%d", pt
    HPGL_FormatCommand(pdev, "%d,%d", pt.x, pt.y);
    
    if (uFlags & HPGL_eLastPoint)
    {
        // Output: ";"
        HPGL_FormatCommand(pdev, ";");
    }
    else
    {
        // Output: ","
        HPGL_FormatCommand(pdev, ",");
    }
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_BeginPolygonMode()
//
// Routine Description:
// 
//   Starts a polygon sequence by moving the pen to the first point and 
//   initializes polygon mode.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   ptBegin - First point in polygon
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_BeginPolygonMode(PDEVOBJ pdev, POINT ptBegin)
{
    // Output: "PA;"
    // Output: "PU%d,%d;", ptBegin
    // Output: "PM0;"
    HPGL_FormatCommand(pdev, "PA;PU%d,%d;PM0;", ptBegin.x, ptBegin.y);
    
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_BeginSubPolygon()
//
// Routine Description:
// 
//   During polygon mode a subpolygon is drawn whenever more than one polygon
//   is in the path.  Each additional polygon (from 2 to N) must be wrapped by
//   BeginSubPolygon/EndSubPolygon.
//
//   Note that there is an inconsistency: the first polygon is not wrapped by
//   the BeginSubPolygon/EndSubPolygon.  I may change this later to add flags
//   so that all subpolygons are wrapped. JFF
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   ptBegin - First point in subpolygon
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_BeginSubPolygon(PDEVOBJ pdev, POINT ptBegin)
{
    // Output: "PM1;"
    // Output: PU%d,%d;", ptBegin
    HPGL_FormatCommand(pdev, "PM1;PU%d,%d;", ptBegin.x, ptBegin.y);
    
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_EndSubPolygon()
//
// Routine Description:
// 
//   Finishes a subpolygon.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_EndSubPolygon(PDEVOBJ pdev)
{
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_EndPolygonMode()
//
// Routine Description:
// 
//   Finishes a series (1 or more) polygons (and subpolygons).  Closes polygon
//   mode.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_EndPolygonMode(PDEVOBJ pdev)
{
    HPGL_Command(pdev, 1, "PM", 2);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_AddBezierPt()
//
// Routine Description:
// 
//   Plots the n-th point of a bezier curve.  The flags indicate whether this 
//   is the first or last point in the curve.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   pt - The point to plot
//   uFlags - indicates if first or last in the series
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_AddBezierPt(PDEVOBJ pdev, POINT pt, USHORT uFlags)
{
    if (uFlags & HPGL_eFirstPoint)
    {
        // Output: "PD;BZ"
        HPGL_FormatCommand(pdev, "PD;BZ");
    }
    
    // Output "%d,%d", pt
    HPGL_FormatCommand(pdev, "%d,%d", pt.x, pt.y);
    
    if (uFlags & HPGL_eLastPoint)
    {
        // Output: ";"
        HPGL_FormatCommand(pdev, ";");
    }
    else
    {
        // Output: ","
        HPGL_FormatCommand(pdev, ",");
    }
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SetLineWidth()
//
// Routine Description:
// 
//   Adjusts the line width in HPGL.  Note that the units of the line are
//   determined by another HPGL command.  ISSUE: How should this be handled?
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   lineWidth - new line width in device coordinates
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetLineWidth(PDEVOBJ pdev, LONG pixelWidth, UINT uFlags)
{
    PHPGLSTATE pState = GETHPGLSTATE(pdev);
    FLOATOBJ fNewLineWidth;

    DeviceToMM(pdev, &fNewLineWidth, pixelWidth);

    if ((uFlags & FORCE_UPDATE) || !FLOATOBJ_Equal(&pState->fLineWidth, &fNewLineWidth))
    {
        FLOATOBJ_Assign(&pState->fLineWidth, &fNewLineWidth);

        CONVERT_FLOATOBJ_TO_LONG_RADIX(fNewLineWidth, lInt);

        HPGL_FormatCommand(pdev, "WU%d;PW%f;", HPGL_WIDTH_METRIC, (FLOAT)( ((FLOAT)lInt)/1000000)) ;
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SetLineJoin()
//
// Routine Description:
// 
//   Adjusts the line join attribute
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   join - new line join
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetLineJoin(PDEVOBJ pdev, ELineJoin join, UINT uFlags)
{
    PHPGLSTATE pState = GETHPGLSTATE(pdev);

    if ((uFlags & FORCE_UPDATE) || (pState->eLineJoin != join))
    {
        pState->eLineJoin = join;
        HPGL_Command(pdev, 2, "LA", 2, (INT)join);
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SetLineEnd()
//
// Routine Description:
// 
//   Adjusts the line end attribute.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   end - end type
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetLineEnd(PDEVOBJ pdev, ELineEnd end, UINT uFlags)
{
    PHPGLSTATE pState = GETHPGLSTATE(pdev);

    if ((uFlags & FORCE_UPDATE) || (pState->eLineEnd != end))
    {
        pState->eLineEnd = end;
        HPGL_Command(pdev, 2, "LA", 1, (INT)end);
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SetMiterLimit()
//
// Routine Description:
// 
//   Adjusts the miter limit.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   miterLimit - new miter limit
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SetMiterLimit(PDEVOBJ pdev, FLOATL miterLimit, UINT uFlags)
{
    PHPGLSTATE pState = GETHPGLSTATE(pdev);
    FLOATOBJ   fNewMiterLimit;

    FLOATOBJ_SetFloat(&fNewMiterLimit, miterLimit);

    if ((uFlags & FORCE_UPDATE) || !FLOATOBJ_Equal(&pState->fMiterLimit, &fNewMiterLimit))
    {
        FLOATOBJ_Assign(&pState->fMiterLimit, &fNewMiterLimit);

        CONVERT_FLOATOBJ_TO_LONG_RADIX(fNewMiterLimit, lInt);

        HPGL_FormatCommand(pdev, "LA%d,%f;", 3, (FLOAT)( ((FLOAT)lInt)/1000000));
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// DeviceToMM()
//
// Routine Description:
// 
//   Converts device units (pixels) to millimeters (which is what HPGL wants).
//
// Arguments:
// 
//   IN pdev - Points to our PDEVOBJ structure
//   OUT pfLineWidth - the resulting width in millimeters
//   IN lineWidth - the original width in pixels
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
void DeviceToMM(PDEVOBJ pdev, FLOATOBJ *pfLineWidth, LONG lineWidth)
{
    int res;

    FLOATOBJ_SetLong(pfLineWidth, lineWidth);

    FLOATOBJ_MulLong(pfLineWidth, 254); // Multiply by 25.4 mm/in
    FLOATOBJ_DivLong(pfLineWidth, 10);

    res = HPGL_GetDeviceResolution(pdev);
    FLOATOBJ_DivLong(pfLineWidth, res); // Divide by pixels/in
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_GetDeviceResolution()
//
// Routine Description:
// 
//   returns the device resolution in pixels.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   Device resolution in pixels.  Note: This routine MAY NOT return ZERO!!!
///////////////////////////////////////////////////////////////////////////////
ULONG HPGL_GetDeviceResolution(PDEVOBJ pdevobj)
{
    ULONG res;
    POEMPDEV    poempdev;

    //
    // 150 dpi not included
    //
    ASSERT_VALID_PDEVOBJ(pdevobj);
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return DPI_300 );

    switch (poempdev->dmResolution)
    {
    case PDM_1200DPI:
        res = DPI_1200;
        break;

    case PDM_600DPI:
        res = DPI_600;
        break;

    case PDM_300DPI:
        res = DPI_300;
        break;

    case PDM_150DPI:
        res = DPI_150;
        break;

    default:
        res = DPI_300;
    }

    //
    // If this returns zero we will get a divide by zero error!
    //
    ASSERT(res != 0); 

    return res;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SelectDefaultLineType()
//
// Routine Description:
// 
//   Selects a default (solid) line style.
//
// Arguments:
// 
//   IN pdev - Points to our PDEVOBJ structure
//   uFlags - update flags
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SelectDefaultLineType(PDEVOBJ pdev, UINT uFlags)
{
    PHPGLSTATE pState = GETHPGLSTATE(pdev);

    if ((uFlags & FORCE_UPDATE) || (pState->LineType.eType != eSolidLine))
    {
        pState->LineType.eType = eSolidLine;
        FLOATOBJ_SetLong(&pState->LineType.foPatternLength, HPGL_DEFAULT_PATTERN_LENGTH);
        HPGL_FormatCommand(pdev, "LT;");
    }
    return TRUE;
}


// BUGBUG: Hardcoded values: Specifying a pattern length of 5mm.
// What should this be??? JFF
///////////////////////////////////////////////////////////////////////////////
// HPGL_SelectCustomLine()
//
// Routine Description:
// 
//   Selects a custom line style.  This gets a little tricky because two differnt
//   custom line types can be very different, and the line style itself is not 
//   stored in the state.
//
// Arguments:
// 
//   IN pdev - Points to our PDEVOBJ structure
//   IN lPatternLength - the desired pattern length in device units.
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SelectCustomLine(PDEVOBJ pdev, LONG lPatternLength, UINT uFlags)
{
    PHPGLSTATE pState = GETHPGLSTATE(pdev);
    FLOATOBJ fNewPatternLength;

    DeviceToMM(pdev, &fNewPatternLength, lPatternLength);

    if ((uFlags & FORCE_UPDATE) || (pState->LineType.eType != eCustomLine) ||
        (!FLOATOBJ_Equal(&pState->LineType.foPatternLength, &fNewPatternLength)))
    {
        pState->LineType.eType = eCustomLine;
        FLOATOBJ_Assign(&pState->LineType.foPatternLength, &fNewPatternLength);

        CONVERT_FLOATOBJ_TO_LONG_RADIX(fNewPatternLength, lInt);

        HPGL_FormatCommand(pdev, "LT%d,%f,1;", HPGL_CUSTOM_LINE_TYPE, (FLOAT)( ((FLOAT)lInt)/1000000));
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_BeginCustomLineType()
//
// Routine Description:
// 
//   Sends the HPGL command to begin a custom line definition.  This should be
//   followed with one or more calls to HPGL_AddLineTypeField and capped off 
//   with a call to HPGL_EndCustomLineType.
//
// Arguments:
// 
//   IN pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_BeginCustomLineType(PDEVOBJ pdev)
{
    return HPGL_FormatCommand(pdev, "UL%d", HPGL_CUSTOM_LINE_TYPE);
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_AddLineTypeField()
//
// Routine Description:
// 
//   Adds a dash or gap segment to the current custom line style.
//
// Arguments:
// 
//   IN pdev - Points to our PDEVOBJ structure
//   IN value - the length of the segment as a fraction of its overall length
//   uFlags - flag indicating whether this is the first, middle or last element
// 
// Return Value:
// 
//   TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_AddLineTypeField(PDEVOBJ pdev, LONG value, UINT uFlags)
{
    if (uFlags & HPGL_eFirstPoint)
    {
        // Output: ","
        HPGL_FormatCommand(pdev, ",");
    }
    
    // Output: "%d", value
    HPGL_FormatCommand(pdev, "%d", value);
    
    if (uFlags & HPGL_eLastPoint)
    {
        // Output: ";"
        HPGL_FormatCommand(pdev, ";");
    }
    else
    {
        // Output: ","
        HPGL_FormatCommand(pdev, ",");
    }
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_EndCustomLineType()
//
// Routine Description:
// 
//   Finishes the definition of a custom line type.  Currently the routine 
//   is here only for the interface, but implementation might follow.
//
// Arguments:
// 
//   IN pdev - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_EndCustomLineType(PDEVOBJ pdev)
{
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_DrawRectangle()
//
// Routine Description:
// 
//   Draws the given rectangle.  Note that you must select your pen and brush
//   colors beforehand!
//
 // Arguments:
// 
//   IN pDevObj - Points to our PDEVOBJ structure
//	 RECTL *prcl - Points to the rectangle to be drawn
// 
// Return Value:
// 
//   TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_DrawRectangle (PDEVOBJ pDevObj, RECTL *prcl)
{
    VERBOSE(("HPGL_DrawRectangle\n"));

    //
    // set the Miterlimits and joints so that rectangle corners will
    // look right
    // 
    HPGL_SetMiterLimit (pDevObj, MITER_LIMIT_DEFAULT, NORMAL_UPDATE);
    HPGL_SetLineJoin (pDevObj, eLINE_JOIN_MITERED, NORMAL_UPDATE);
    
    //
    // Draw the polygon using the rectangle passed in.
    //
    //
    // In HPGL the rectangles are right-bottom exclusive which leaves a gap
    // between adjacent rectangles.  Add one to right and bottom to get a 
    // full-sized rectangle on the page.
    //
    LONG cx, cy;
    cx = prcl->right + 1 - prcl->left;
    cy = prcl->bottom + 1 - prcl->top;

    HPGL_FormatCommand(pDevObj, "PU%d,%d", prcl->left, prcl->top);
    HPGL_FormatCommand(pDevObj, "RR%d,%d", cx, cy);
    HPGL_FormatCommand(pDevObj, "ER");
    
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_DrawRectangleAsPolygon()
//
// Routine Description:
// 
//   Draws the given rectangle.  Note that you must select your pen and brush
//   colors beforehand!  This version uses the polygon commands, but doesn't
//   seem to have any advantage over the PU/RR version--in fact it sends down 
//   a lot more data.
//
 // Arguments:
// 
//   IN pDevObj - Points to our PDEVOBJ structure
//	 RECTL *prcl - Points to the rectangle to be drawn
// 
// Return Value:
// 
//   TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_DrawRectangleAsPolygon (PDEVOBJ pDevObj, RECTL *prcl)
{
    POINT pt;

    HPGL_SetLineWidth(pDevObj, 0, NORMAL_UPDATE);
    HPGL_SetMiterLimit (pDevObj, MITER_LIMIT_DEFAULT, NORMAL_UPDATE);
    HPGL_SetLineJoin (pDevObj, eLINE_JOIN_MITERED, NORMAL_UPDATE);

    pt.x = prcl->left;
    pt.y = prcl->top;
    HPGL_BeginPolygonMode(pDevObj, pt);

    pt.x = prcl->right;
    HPGL_AddPolyPt(pDevObj, pt, HPGL_eFirstPoint);

    pt.y = prcl->bottom;
    HPGL_AddPolyPt(pDevObj, pt, 0);

    pt.x = prcl->left;
    HPGL_AddPolyPt(pDevObj, pt, HPGL_eLastPoint);

    HPGL_EndPolygonMode(pDevObj);

    HPGL_FormatCommand(pDevObj, "FP;");
    HPGL_FormatCommand(pDevObj, "EP;");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpglpoly.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
// 
// Module Name:
// 
//   hpglpoly.h
// 
// Abstract:
// 
//   Header for vector module.  Forward decls for vector functions and types.
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   07/02/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#ifndef HPGLPOLY_H
#define HPGLPOLY_H


#define HPGL_WIDTH_METRIC   0
#define HPGL_WIDTH_RELATIVE 1
#define MITER_LIMIT_DEFAULT ((FLOATL) 0)

// The First and Last point flags are bitfield flags.  The next in the sequence
// should be 0x0004 (not 0x0003).
#define HPGL_eFirstPoint 0x0001
#define HPGL_eLastPoint  0x0002

BOOL HPGL_BeginPolyline(PDEVOBJ pdev, POINT pt);

BOOL HPGL_BeginPolygonMode(PDEVOBJ pdev, POINT ptBegin);

BOOL HPGL_BeginSubPolygon(PDEVOBJ pdev, POINT ptBegin);

BOOL HPGL_AddPolyPt(PDEVOBJ pdev, POINT pt, USHORT uFlags);

BOOL HPGL_EndSubPolygon(PDEVOBJ pdev);

BOOL HPGL_EndPolygonMode(PDEVOBJ pdev);

BOOL HPGL_AddBezierPt(PDEVOBJ pdev, POINT pt, USHORT uFlags);

BOOL HPGL_SetLineWidth(PDEVOBJ pdev, LONG lineWidth, UINT uFlags);

BOOL HPGL_SetLineJoin(PDEVOBJ pdev, ELineJoin join, UINT uFlags);

BOOL HPGL_SetLineEnd(PDEVOBJ pdev, ELineEnd end, UINT uFlags);

BOOL HPGL_SetMiterLimit(PDEVOBJ pdev, FLOATL miterLimit, UINT uFlags);

void DeviceToMM(PDEVOBJ pdev, FLOATOBJ *pfLineWidth, LONG lineWidth);

BOOL HPGL_SelectDefaultLineType(PDEVOBJ pdev, UINT uFlags);

BOOL HPGL_SelectCustomLine(PDEVOBJ pdev, LONG lPatternLength, UINT uFlags);

BOOL HPGL_BeginCustomLineType(PDEVOBJ pdev);

BOOL HPGL_AddLineTypeField(PDEVOBJ pdev, LONG value, UINT uFlags);

BOOL HPGL_EndCustomLineType(PDEVOBJ pdev);

ULONG HPGL_GetDeviceResolution(PDEVOBJ pdev);

BOOL HPGL_DrawRectangle (PDEVOBJ pDevObj, RECTL *prcl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpgl_pen.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// 
// Module Name:
// 
//   hpgl_pen.c
// 
// Abstract:
// 
//   [Abstract]
//
//   Note that all functions in this module begin with HPGL_ which indicates
//   that they are responsible for outputing HPGL codes.
//
//   [ISSUE] Should a provide Hungarian notation for the return value? JFF
//
//   [TODO] Add ENTERING, EXITING, PRE- and POSTCONDITION macros. JFF
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   07/02/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file


// I'm finding it too difficult to track the HPGL pen colors.  Additionally
// there are too many ways to change the colors anyway!  Leave this undefined
// until a way is found, or it is decided not to track them at all (and the 
// offending code can simply be removed). JFF
// #define TRACK_HPGL_PEN_COLORS 1

static PENID HPGL_FindPen(PPENPOOL pPool, COLORREF color);
static PENID HPGL_MakePen(PDEVOBJ pDevObj, PPENPOOL pPool, COLORREF color);
static BOOL HPGL_SetPenColor(PDEVOBJ pDevObj, PENID pen, COLORREF color);


///////////////////////////////////////////////////////////////////////////////
// HPGL_SelectPen()
//
// Routine Description:
// 
//   Selects a stock pen.  
//
//   For B/W printers there are two stock pens: 
//      0: White
//      1: Black
//
//   For color printers there are 8 stock pens.
//      0: White
//      1: Black
//      2: ???
//      ...
//      7: ???
//
//   [ISSUE] How are color pens defined?  I'll bet they are white, black, cyan, 
//   magenta, yellow, red, green, and blue in some order.  They can also be
//   redefined by the language to anything.
//
//   [ISSUE] If this is selecting stock pens shouldn't there be a command which
//   re-initializes the pens to their default values?
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   pen - The pen number (see above)
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_SelectPen(PDEVOBJ pDevObj, PENID pen)
{
    if ( BIsColorPrinter(pDevObj) )
    {
        //
        //
        // Output: "SP%d", pen
        return HPGL_Command(pDevObj, 1, "SP", pen);
    }
    else
    {
        //
        // FT_ePCL_BRUSH = 22
        // CHECK : Not sure whether we really need this command. 
        //
        return HPGL_FormatCommand(pDevObj, "SV%d,%d;", FT_eHPGL_PEN, pen);
    }
}


///////////////////////////////////////////////////////////////////////////////
// HPGL_SetPenColor()
//
// Routine Description:
// 
//   Adjusts the color for the given pen in HPGL.  Note that we should really
//   reserve our color changes for HPGL_CUSTOM_PEN and HPGL_CUSTOM_BRUSH.  
//   Although we can change any pen it is probably a good idea to leave the 
//   default ones as they are.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   pen - the number of the pen to be updated
//   color - the desired color
//   uFlags - update flags
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
static BOOL HPGL_SetPenColor(PDEVOBJ pDevObj, PENID pen, COLORREF color)
{
    int red   = GetRValue(color);
    int green = GetGValue(color);
    int blue  = GetBValue(color);

    HPGL_FormatCommand(pDevObj, "PC%d,%d,%d,%d;", pen, red, green, blue);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_DownloadPaletteEntry()
//
// Routine Description:
// 
//   This function outputs a palette entry which--in HPGL--maps to a pen color.
// 
// Arguments:
// 
//   pDevObj - the device
//   entry - palette entry (i.e. pen number)
//   color - pen color
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_DownloadPaletteEntry(PDEVOBJ pDevObj, LONG entry, COLORREF color)
{
    return HPGL_SetPenColor(pDevObj, (PENID) entry, color);
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_DownloadDefaultPenPalette()
//
// Routine Description:
// 
//   Set up a group of default pens similar to what is default in the printer.
// 
// Arguments:
// 
//   pDevObj - the device
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_DownloadDefaultPenPalette(PDEVOBJ pDevObj)
{
    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);
    BOOL bRet = FALSE;

    HPGL_SetNumPens(pDevObj, HPGL_TOTAL_PENS, FORCE_UPDATE);

    if (!HPGL_SetPenColor(pDevObj, HPGL_WHITE_PEN,    RGB_WHITE)   ||
        !HPGL_SetPenColor(pDevObj, HPGL_BLACK_PEN,    RGB_BLACK) /*  ||
        !HPGL_SetPenColor(pDevObj, HPGL_RED_PEN,      RGB_RED)     ||
        !HPGL_SetPenColor(pDevObj, HPGL_GREEN_PEN,    RGB_GREEN)   ||
        !HPGL_SetPenColor(pDevObj, HPGL_YELLOW_PEN,   RGB_YELLOW)  ||
        !HPGL_SetPenColor(pDevObj, HPGL_BLUE_PEN,     RGB_BLUE)    ||
        !HPGL_SetPenColor(pDevObj, HPGL_MAGENTA_PEN,  RGB_MAGENTA) ||
        !HPGL_SetPenColor(pDevObj, HPGL_CYAN_PEN,     RGB_CYAN) */ )
    {
        bRet = FALSE;
    }
    else
    {
        bRet = TRUE;
    }

    HPGL_InitPenPool(&pState->PenPool,   HPGL_PEN_POOL);
    HPGL_InitPenPool(&pState->BrushPool, HPGL_BRUSH_POOL);

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_DownloadPenPalette()
//
// Routine Description:
// 
//   This function downloads a palette as a series of pen colors.  This is
//   used when an HPGL pattern brush is used.  Also, the pen and brush pools
//   must be reset.
// 
// Arguments:
// 
//   pDevObj - the device
//   pPalette - palette
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_DownloadPenPalette(PDEVOBJ pDevObj, PPALETTE pPalette)
{
    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);
    ULONG ulColor;
    ULONG ulPaletteEntry;

    DownloadPaletteAsHPGL(pDevObj, pPalette);

    HPGL_InitPenPool(&pState->PenPool,   HPGL_PEN_POOL);
    HPGL_InitPenPool(&pState->BrushPool, HPGL_BRUSH_POOL);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_InitPenPool()
//
// Routine Description:
// 
//   Initializes a range of pen ids to use as a pool.
// 
// Arguments:
// 
//   pPool - the pen pool
//   firstPenID - first pen id in this pool
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE
///////////////////////////////////////////////////////////////////////////////
BOOL HPGL_InitPenPool(PPENPOOL pPool, PENID firstPenID)
{
    LONG i;

    if (pPool == NULL)
        return FALSE;

    pPool->firstPenID = firstPenID;
    pPool->lastPenID = pPool->firstPenID + PENPOOLSIZE - 1;

    for (i = 0; i < PENPOOLSIZE; i++)
    {
        pPool->aPens[i].useCount = -1;
        pPool->aPens[i].color = RGB_INVALID;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// FunctionName()
//
// Routine Description:
// 
//   Descrip
// 
// Arguments:
// 
//   arg - descrip
// 
// Return Value:
// 
//   retval descrip
///////////////////////////////////////////////////////////////////////////////
static PENID HPGL_FindPen(PPENPOOL pPool, COLORREF color)
{
    LONG i;

    if (pPool == NULL)
        return HPGL_INVALID_PEN;

    for (i = 0; i < PENPOOLSIZE; i++)
    {
        if ((pPool->aPens[i].useCount >= 0) && (pPool->aPens[i].color == color))
        {
            pPool->aPens[i].useCount++;
            return i + pPool->firstPenID;
        }
    }

    return HPGL_INVALID_PEN; // Not found!
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_MakePen()
//
// Routine Description:
// 
//   This function constructs a new pen and places it in the pen pool 
//   overwriting the pen which has been least used in the past.
// 
// Arguments:
// 
//   pDevObj - the device
//   pPool - the pool
//   color - desired color for the pen
// 
// Return Value:
// 
//   retval descrip
///////////////////////////////////////////////////////////////////////////////
static PENID HPGL_MakePen(PDEVOBJ pDevObj, PPENPOOL pPool, COLORREF color)
{
    LONG i;
    LONG minIndex; // Use this to find the pool entry with the smallest useCount
    PENID pen;

    if (pPool == NULL)
        return HPGL_INVALID_PEN;

    //
    // Locate the entry with the smallest use count now.
    //
    minIndex = 0;
    for (i = 0; i < PENPOOLSIZE; i++)
    {
        if (pPool->aPens[i].useCount < pPool->aPens[minIndex].useCount)
            minIndex = i;
    }

    //
    // Use this entry for our target pen
    //
    pPool->aPens[minIndex].useCount = 1;
    pPool->aPens[minIndex].color = color;
    pen = minIndex + pPool->firstPenID;

    HPGL_SetPenColor(pDevObj, pen, color);

    return pen;
}

///////////////////////////////////////////////////////////////////////////////
// HPGL_ChoosePenByColor()
//
// Routine Description:
// 
//   This function searches the pool for a matching pen and returns the one
//   that matches.  If no matching color pen is found a new one is created.
// 
// Arguments:
// 
//   pDevObj - the device
//   pPool - the pool
//   color - the desired pen color
// 
// Return Value:
// 
//   The ID of the selected pen
///////////////////////////////////////////////////////////////////////////////
PENID HPGL_ChoosePenByColor(PDEVOBJ pDevObj, PPENPOOL pPool, COLORREF color)
{
    PENID pen;

    pen = HPGL_FindPen(pPool, color);
    if (pen == HPGL_INVALID_PEN)
    {
        pen = HPGL_MakePen(pDevObj, pPool, color);
    }
    return pen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\htblt.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    htblt.h


Abstract:

    This module contains declarations for functions in htblt.cpp

Author:
    16-March-2000 created  -by-  hsingh


[Environment:]

    Windows 2000/Whistler HPGL plugin driver.


[Notes:]


Revision History:

--*/


#ifndef _HTBLT_
#define _HTBLT_

//
// Flags to indicate the simplified ROPs. ROPs coming in through the DDI
// sometimes specify a complex operation 
// between source,destination, pattern etc. Since the driver (at this time) is not
// able to handle all of the ROPs, we try to simplify those ROPs to a few values
// that the driver can handle.
//
// 
// BMPFLAG_NOOP         : Dont do anything.
// BMPFLAG_BW           : Fill the destination surface with either black or white color.
//                        (depending on the Rop)
// BMPFLAG_PAT_COPY     : Use the brush (pbo) as a pattern to fill the destination region. 
// BMPFLAG_SRC_COPY     : Copy the Source image to the destination.       
// BMPFLAG_NOT_SRC_COPY : Invert the Source image before copying to the destination. 
// BMPFLAG_IMAGEMASK    :  
//

#define BMPFLAG_NOOP             0x00000000
#define BMPFLAG_BW               0x00000001
#define BMPFLAG_PAT_COPY         (0x00000001 << 1)
#define BMPFLAG_SRC_COPY         (0x00000001 << 2)
#define BMPFLAG_NOT_SRC_COPY     (0x00000001 << 3)
#define BMPFLAG_IMAGEMASK        (0x00000001 << 4)
#define BMPFLAG_NOT_IMAGEMASK    (0x00000001 << 5)
#define BMPFLAG_NOT_DEST         (0x00000001 << 6)

//
// return values for dwCommonROPBlt
//

#define RASTER_OP_SUCCESS      0
#define RASTER_OP_CALL_GDI     (0x1)      // means call corresponding Engxxx-function
#define RASTER_OP_FAILED       (0x1 << 1)


BOOL
OutputHTBitmap(
    PDEVOBJ  pdevobj,
    SURFOBJ *psoHT,
    CLIPOBJ *pco,
    PRECTL   prclDest,
    POINTL  *pptlSrc,
    XLATEOBJ *pxlo
    );

LONG
GetBmpDelta(
    DWORD   SurfaceFormat,
    DWORD   cx
    );


inline BOOL bMonochromeSrcImage(SURFOBJ * pso) 
{
    return (pso->iBitmapFormat == BMF_1BPP);
}


SURFOBJ *
CreateBitmapSURFOBJ(
    PDEVOBJ   pPDev,
    HBITMAP *phBmp,
    LONG    cxSize,
    LONG    cySize,
    DWORD   Format,
    LPVOID  pvBits
    );


BOOL
IntersectRECTL(
    PRECTL  prclDest,
    PRECTL  prclSrc
    );

BOOL HTCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

BOOL
BImageNeedsInversion(
    IN  PDEVOBJ   pdevobj,
    IN  ULONG     iBitmapFormat,
    IN  XLATEOBJ *pxlo);


BOOL  bCreateHTImage(
    OUT    PRASTER_DATA SrcImage,
    IN     SURFOBJ      *psoDst,        // psoDst,
    IN     SURFOBJ      *psoPattern,    // psoSrc,
    OUT    SURFOBJ     **ppsoHT,        // ORPHAN
    OUT    HBITMAP      *pBmpHT,        // ORPHAN
    IN     XLATEOBJ     *pxlo ,
    IN     ULONG        iHatch);

BOOL bHandleSrcCopy (
            IN SURFOBJ    *psoDst,
            IN SURFOBJ    *psoSrc,
            IN SURFOBJ    *psoMask,
            IN CLIPOBJ    *pco,
            IN XLATEOBJ   *pxlo,
            IN COLORADJUSTMENT *pca,
            IN BRUSHOBJ   *pbo,
            IN RECTL      *prclSrc,
            IN RECTL      *prclDst,
            IN POINTL     *pptlMask,
            IN POINTL     *pptlBrush,
            IN ROP4        rop4,
            IN DWORD       dwSimplifiedRop);

DWORD DWMonochromePrinterCommonRoutine (
            IN SURFOBJ    *psoDst,
            IN SURFOBJ    *psoSrc,
            IN SURFOBJ    *psoMask,
            IN CLIPOBJ    *pco,
            IN XLATEOBJ   *pxlo,
            IN COLORADJUSTMENT *pca,
            IN BRUSHOBJ   *pbo,
            IN RECTL      *prclSrc,
            IN RECTL      *prclDst,
            IN POINTL     *pptlMask,
            IN POINTL     *pptlBrush,
            IN ROP4        rop4,
            IN DWORD       dwSimplifiedRop);
                                              
#endif  // _HTBLT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\line.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved. 
//
// Module Name:
// 
//   line.h
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   08/06/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#ifndef LINE_H
#define LINE_H


BOOL SelectLineAttrs(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpgl_pen.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
// 
// Module Name:
// 
//   hpgl_pen.h
// 
// Abstract:
// 
//   Header for vector module.  Forward decls for vector functions and types.
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   07/02/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#ifndef HPGL_PEN_H
#define HPGL_PEN_H

#include "rasdata.h"

#include "hpgl.h"

// HPGL defined pen values.
#define HPGL_INVALID_PEN       -1
#define HPGL_WHITE_PEN          0
#define HPGL_BLACK_PEN          1
// #define HPGL_RED_PEN             2
// #define HPGL_GREEN_PEN           3
// #define HPGL_YELLOW_PEN          4
// #define HPGL_BLUE_PEN            5
// #define HPGL_MAGENTA_PEN         6
// #define HPGL_CYAN_PEN            7
// #define HPGL_LAST_DEFAULT_PEN    7
#define HPGL_LAST_DEFAULT_PEN   1
#define HPGL_PEN_POOL           (HPGL_LAST_DEFAULT_PEN + 1)
#define HPGL_BRUSH_POOL         (HPGL_PEN_POOL + PENPOOLSIZE)
#define HPGL_TOTAL_PENS         (HPGL_BRUSH_POOL + PENPOOLSIZE)

// HPGL defined pen colors
#define RGB_WHITE    RGB(0xFF,0xFF,0xFF)
#define RGB_BLACK    RGB(0x00,0x00,0x00)
#define RGB_RED      RGB(0xFF,0x00,0x00)
#define RGB_GREEN    RGB(0x00,0xFF,0x00)
#define RGB_YELLOW   RGB(0xFF,0xFF,0x00)
#define RGB_BLUE     RGB(0x00,0x00,0xFF)
#define RGB_MAGENTA  RGB(0xFF,0x00,0xFF)
#define RGB_CYAN     RGB(0x00,0xFF,0xFF)
#define RGB_INVALID  0xFFFFFFFF


//
// Use models: The download functions are for initializing a range of pens to 
// match some internally understood palette.  In the 'default' case we try to
// mimic the predefined HPGL palette (but it really doesn't matter).  The 
// important thing is that we flush the pen and brush pools to avoid clashes
// over pen ids.
//
BOOL HPGL_DownloadDefaultPenPalette(PDEVOBJ pDevObj);
BOOL HPGL_DownloadPenPalette(PDEVOBJ pDevObj, PPALETTE pPalette);

//
// Use these pool commands to get the pen you want given that you know what
// color that pen should be.  Note that this replaces the HPGL_SetPenColor
// command, which is now restricted for use inside this module.
//
BOOL  HPGL_InitPenPool(PPENPOOL pPool, PENID firstPenID);
PENID HPGL_ChoosePenByColor(PDEVOBJ pDevObj, PPENPOOL pPool, COLORREF color);

//
// After you've gotten the pen you wanted with ChoosePenByColor you can select
// this pen as the 'active hpgl pen' with the select pen command.
//
BOOL HPGL_SelectPen(PDEVOBJ pdev, PENID pen);

//
// This is a little odd.  When you're downloading an HPGL palette, use this
// instead of SetPenColor to set a pen...er I mean palette entry.
//
BOOL HPGL_DownloadPaletteEntry(PDEVOBJ pDevObj, LONG entry, COLORREF color);

#endif // HPGL_PEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\hpgl_pri.h ===
///////////////////////////////////////////////////////////////////////////////
// 
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
// 
//   hpgl_pri.h
// 
// Abstract:
// 
//   Private header for vector module.  Forward decls for vector functions and types.
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   07/02/97 -v-jford-
//       Created it.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef HPGL_PRI_H
#define HPGL_PRI_H

///////////////////////////////////////////////////////////////////////////////
// Macros.

#define CLIP_RECT_RESET (-1)

///////////////////////////////////////////////////////////////////////////////
// The command str (CMDSTR) is used for printing PCL and HPGL strings.
#define CMD_STR_LEN 80
typedef char CMDSTR[CMD_STR_LEN+1];


///////////////////////////////////////////////////////////////////////////////
// Local function prototypes
BOOL HPGL_Output(PDEVOBJ pdev, char *szCmdStr, int iCmdLen);

// BUGBUG JFF TODO: Move these to utility.h or something.
// LO/HIBYTE are defined in windef.h!
// #define HIBYTE(w) (((w) & 0xFF00) >> 8)
// #define LOBYTE(w) ((w) & 0x00FF)
#define SWAB(w) { (w) = (LOBYTE(w) << 8) | HIBYTE(w); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\line.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation.
// 
// Module Name:
// 
//   line.c
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   08/06/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

///////////////////////////////////////////////////////////////////////////////
// Local Macros.

#define IsGeometric(pLineAttrs) ((pLineAttrs)->fl & LA_GEOMETRIC)

#define GetDeviceCoord(floatLong, pxo, bGeometric) \
    ((bGeometric) ? WorldToDevice((floatLong).e, (pxo)) : (floatLong).l)

//
// This is a little different for dots: treat pstyle->e as a real value, but
// convert pstyle->l by multiplying by res/25 (Why? Because We Like You.)
//
#define GetDeviceCoordDot(floatLong, pxo, bGeometric, lResolution) \
    ((bGeometric) ? WorldToDevice((floatLong).e, (pxo)) : \
        (floatLong).l * (lResolution / 25))

#define GetLineWidth(pLineAttrs, pxo) \
    GetDeviceCoord((pLineAttrs)->elWidth, (pxo), IsGeometric(pLineAttrs))

///////////////////////////////////////////////////////////////////////////////
// Local Functions.

BOOL SelectLineJoin(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo);

BOOL SelectLineEnd(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo);

BOOL SelectLineWidth(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo);

BOOL SelectMiterLimit(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo);

BOOL SelectLineType(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo);

LONG WorldToDevice(FLOATL world, XFORMOBJ *pxo);

///////////////////////////////////////////////////////////////////////////////
// SelectLineAttrs()
//
// Routine Description:
// 
//   [Description]
// 
// Arguments:
// 
//   pdev - Points to our DEVDATA structure
//   pLineAttrs - the specified line attributes
//   pxo - transform from world to device coordinates
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectLineAttrs(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo)
{
    BOOL bRet;

    VERBOSE(("Entering SelectLineAttrs...\n"));

    ASSERT_VALID_PDEVOBJ(pDevObj);
    REQUIRE_VALID_DATA (pDevObj, return FALSE);

    bRet = (SelectLineJoin  (pDevObj, pLineAttrs, pxo) &&
            SelectLineEnd   (pDevObj, pLineAttrs, pxo) &&
            SelectLineWidth (pDevObj, pLineAttrs, pxo) &&
            SelectMiterLimit(pDevObj, pLineAttrs, pxo) &&
            SelectLineType  (pDevObj, pLineAttrs, pxo));

    VERBOSE(("Exiting SelectLineAttrs...\n"));

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// SelectLineJoin()
//
// Routine Description:
// 
//   Translates the line attributes into HPGL-specific commands for selecting
//   the desired join.
// 
// Arguments:
// 
//   pdev - Points to our DEVDATA structure
//   pLineAttrs - the specified line attributes
//   pxo - transform from world to device coordinates
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectLineJoin(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo)
{
    ELineJoin lineJoin;
    BOOL bRet = FALSE;

    if (IsGeometric(pLineAttrs))
    {
        ///////////////////////////////
        // Geometric lines

        switch (pLineAttrs->iJoin)
        {
        case JOIN_ROUND:
            lineJoin = eLINE_JOIN_ROUND;
            break;
        case JOIN_BEVEL:
            lineJoin = eLINE_JOIN_BEVELED;
            break;
        case JOIN_MITER:
            lineJoin = eLINE_JOIN_MITERED;
            break;
        default:
            lineJoin = eLINE_JOIN_MITERED;
            break;
        }
        bRet = HPGL_SetLineJoin(pDevObj, lineJoin, NORMAL_UPDATE);
    }
    else
    {
        ///////////////////////////////
        // Cosmetic lines

        // Do nothing.
        bRet = TRUE;
    }

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// SelectLineEnd()
//
// Routine Description:
// 
//   Translates the line attributes into HPGL-specific commands for selecting
//   the desired end.
// 
// Arguments:
// 
//   pdev - Points to our DEVDATA structure
//   pLineAttrs - the specified line attributes
//   pxo - transform from world to device coordinates
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectLineEnd(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo)
{
    ELineEnd  lineEnd;
    BOOL      bRet = FALSE;

    if (IsGeometric(pLineAttrs))
    {
        ///////////////////////////////
        // Geometric lines

        switch (pLineAttrs->iEndCap)
        {
        case ENDCAP_ROUND:
            lineEnd = eLINE_END_ROUND;
            break;
        case ENDCAP_SQUARE:
            lineEnd = eLINE_END_SQUARE;
            break;
        case ENDCAP_BUTT:
            lineEnd = eLINE_END_BUTT;
            break;
        default:
            lineEnd = eLINE_END_BUTT;
            break;
        }
        bRet = HPGL_SetLineEnd(pDevObj, lineEnd, NORMAL_UPDATE);
    }
    else
    {
        ///////////////////////////////
        // Cosmetic lines

        // Do nothing.
        bRet = TRUE;
    }

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// SelectLineWidth()
//
// Routine Description:
// 
//   Translates the line attributes into HPGL-specific commands for selecting
//   the desired width.
// 
// Arguments:
// 
//   pdev - Points to our DEVDATA structure
//   pLineAttrs - the specified line attributes
//   pxo - transform from world to device coordinates
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectLineWidth(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo)
{
    LONG lWidth;
    BOOL bRet = FALSE;

    //
    // The GetLineWidth macro handles cosmetic or geometric lines.
    //

    lWidth = GetLineWidth(pLineAttrs, pxo);

    bRet = HPGL_SetLineWidth(pDevObj, lWidth, NORMAL_UPDATE);

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// SelectMiterLimit()
//
// Routine Description:
// 
//   Translates the line attributes into HPGL-specific commands for selecting
//   the desired miter limit.
// 
// Arguments:
// 
//   pdev - Points to our DEVDATA structure
//   pLineAttrs - the specified line attributes
//   pxo - transform from world to device coordinates
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectMiterLimit(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo)
{
    BOOL bRet = FALSE;

    if (IsGeometric(pLineAttrs))
    {
        ///////////////////////////////
        // Geometric lines

        bRet = HPGL_SetMiterLimit(pDevObj, pLineAttrs->eMiterLimit, NORMAL_UPDATE);
    }
    else
    {
        ///////////////////////////////
        // Cosmetic lines

        // Do nothing.
        // BUGBUG: Can the miter limit be set for cosmetic lines?  Since the
        // join setting has no meaning and miter limits affect the joins does
        // this mean that the miter limit isn't useful for cosmetic lines?

        // Perhaps I should set it to a default value???
        bRet = TRUE;
    }

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// SelectLineType()
//
// Routine Description:
// 
//   Translates the line attributes into HPGL-specific commands for selecting
//   the desired line type (dashes or solid).
//
// Issues--BUGBUG:
// 
//   What about rounding errors? do we have to have exactly 100%?
//   Should we cache the line type info for the next line(s)?
//   Is HPGL_CUSTOM_LINE_TYPE >0 or <0 (adaptive)?
//
// Arguments:
// 
//   pdev - Points to our DEVDATA structure
//   pLineAttrs - the specified line attributes
//   pxo - transform from world to device coordinates
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectLineType(PDEVOBJ pDevObj, LINEATTRS *pLineAttrs, XFORMOBJ *pxo)
{
    PFLOAT_LONG pStyle;
    ULONG       i;
    UINT        uFlags;
    BOOL        bIsGeometric;
    BOOL        bStartGap;
    BOOL        bRet = FALSE;

    REQUIRE_VALID_DATA (pDevObj, return FALSE);

    bIsGeometric = IsGeometric(pLineAttrs);
    bStartGap = pLineAttrs->fl & LA_STARTGAP;

    TRY
    {
        // determine what kind of line this is: SOLID or DASH
        if (pLineAttrs->cstyle == 0)
        {
            ///////////////////////////////
            // Default (solid) line style

            if (!HPGL_SelectDefaultLineType(pDevObj, NORMAL_UPDATE))
                TOSS(WriteError);
        }
        else if (pLineAttrs->fl & LA_ALTERNATE)
        {
            ///////////////////////////////
            // Alternate dashed line style
        
            //
            // A special cosmetic line style, where every other pel is on.
            // However, to simulate this we will print 'pixels' which are
            // as long as the line is wide.
            //

            ULONG len = 1;   // The length of a single segment (on or off)
            ULONG count = 2; // The number of segments to print
            ULONG run;       // The total lenght of the run (all segments)

            if (len < 1) len = 1;
            if (count < 1) count = 1;

            run = count * len * (HPGL_GetDeviceResolution(pDevObj) / 25);

            if (!HPGL_BeginCustomLineType(pDevObj))
                TOSS(WriteError);

            // 
            // Check startgap.
            //
            if (bStartGap)
            {
                if (!HPGL_AddLineTypeField(pDevObj, 0, HPGL_eFirstPoint))
                    TOSS(WriteError);
            }

            //
            // Add the segments
            //
            for (i = 0; i < count; i++)
            {
                uFlags = 0;
                uFlags |= ((i == 0) && (!bStartGap) ? HPGL_eFirstPoint : 0);
                uFlags |= (i == (count - 1) ? HPGL_eLastPoint : 0);

                if (!HPGL_AddLineTypeField(pDevObj, len, uFlags))
                    TOSS(WriteError);
            }

            if (!HPGL_EndCustomLineType(pDevObj) || 
                !HPGL_SelectCustomLine(pDevObj, 
                                       run /* * GetLineWidth(pLineAttrs, pxo) */, 
                                       NORMAL_UPDATE))
            {
                TOSS(WriteError);
            }
        }
        else
        {
            ///////////////////////////////
            // Custom dashed line style

            //
            // The dash lenghts are defined by the values in pstyle and cstyle.
            // The cstyle fields defines how many length elements are in pstyle.
            //
            LONG lTotal;
        
            if (!HPGL_BeginCustomLineType(pDevObj))
                TOSS(WriteError);

            //
            // The line starts with a gap.  Send a zero-length line
            // and the first field will be interpreted as a gap.
            //
            if (bStartGap)
            {
                if (!HPGL_AddLineTypeField(pDevObj, 0, HPGL_eFirstPoint))
                    TOSS(WriteError);
            }

            //
            // output the dashes and gaps
            //
            lTotal = 0;
            pStyle = pLineAttrs->pstyle;
            for (i = 0; i < pLineAttrs->cstyle; i++)
            {
                LONG lSegSize;

                lSegSize = GetDeviceCoordDot(*pStyle, pxo, bIsGeometric,
                                             HPGL_GetDeviceResolution(pDevObj));

                uFlags = 0;
                uFlags |= ((i == 0) && (!bStartGap) ? HPGL_eFirstPoint : 0);
                uFlags |= (i == (pLineAttrs->cstyle - 1) ? HPGL_eLastPoint : 0);

                if (!HPGL_AddLineTypeField(pDevObj, lSegSize, uFlags))
                    TOSS(WriteError);
                lTotal += lSegSize;

                pStyle++;
            }

            //
            // Total can't be zero. HPGL will be mad.
            //
            if (lTotal == 0)
            {
                WARNING(("Zero-unit line style detected.\n"));
            }

            if (!HPGL_EndCustomLineType(pDevObj) ||
                !HPGL_SelectCustomLine(pDevObj, 
                                       lTotal /* * GetLineWidth(pLineAttrs, pxo) */, 
                                       NORMAL_UPDATE))
            {
                TOSS(WriteError);
            }
        }
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// WorldToDevice()
//
// Routine Description:
// 
//   Converts the given world coordinates to device coordinates.
//   The answer turned out to be surprisingly simple: device = world * eM11.
//   However, I couldn't use the XFORMOBJ_ transform function because I
//   needed to retain the significant digits of world and eM11.
//
// Arguments:
// 
//   world - the value in world coordinates
//   pxo - transform from world to device coordinates
// 
// Return Value:
// 
//   The value in device coordinates.
///////////////////////////////////////////////////////////////////////////////
LONG WorldToDevice(FLOATL world, XFORMOBJ *pxo)
{
    FLOATOBJ fo;
    LONG lRet;
    FLOATOBJ_XFORM foXForm;


    if (XFORMOBJ_iGetFloatObjXform(pxo, &foXForm) == DDI_ERROR)
    {
        // If there was a problem with the pxo then just return world as a LONG
        FLOATOBJ_SetLong(&fo, 1);
    }
    else
    {
        FLOATOBJ_Assign(&fo, &(foXForm.eM11));
        // fo = foXForm.eM11;
    }

    FLOATOBJ_MulFloat(&fo, world);
    lRet = FLOATOBJ_GetLong(&fo);

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\mix.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// 
// Module Name:
// 
//   mix.c
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   08/06/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

///////////////////////////////////////////////////////////////////////////////
// FILETRACE macro turns on ENTERING and EXITING.  Comment out to disable.
//dz #define FILETRACE 1

#include "utility.h"

///////////////////////////////////////////////////////////////////////////////
// Local Macros.

///////////////////////////////////////////////////////////////////////////////
// SelectMix()
//
// Routine Description:
// 
//   Select the specified mix mode into current graphics state
//
//   [TODO] Add ENTERING, EXITING, PRE- and POSTCONDITION macros as necessary.
// 
// Arguments:
// 
//   pdev - Points to our DEVDATA structure
//   mix - Brush mix mode
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectMix(PDEVOBJ pDevObj, MIX mix)
{
    // Table to map a ROP2 to a ROP3
    //
    static BYTE Rop2ToRop3[] = {
             0xff,      // 0x10 = R2_WHITE           1
             0x00,      // 0x01 = R2_BLACK           0
             0x05,      // 0x02 = R2_NOTMERGEPEN     DPon
             0x0a,      // 0x03 = R2_MASKNOTPEN      DPna
             0x0f,      // 0x04 = R2_NOTCOPYPEN      PN
             0x50,      // 0x05 = R2_MASKPENNOT      PDna
             0x55,      // 0x06 = R2_NOT             Dn
             0x5a,      // 0x07 = R2_XORPEN          DPx
             0x5f,      // 0x08 = R2_NOTMASKPEN      DPan
             0xa0,      // 0x09 = R2_MASKPEN         DPa
             0xa5,      // 0x0A = R2_NOTXORPEN       DPxn
             0xaa,      // 0x0B = R2_NOP             D
             0xaf,      // 0x0C = R2_MERGENOTPEN     DPno
             0xf0,      // 0x0D = R2_COPYPEN         P
             0xf5,      // 0x0E = R2_MERGEPENNOT     PDno
             0xfa,      // 0x0F = R2_MERGEPEN        DPo
    };

    ROP4    foreground, background;
    BOOL    bRet;

    ENTERING(SelectMix);

    ASSERT_VALID_PDEVOBJ(pDevObj);

    // Bit 7-0 defines the foreground ROP2
    // Bit 15-8 defines the foreground ROP2
    //
    foreground = Rop2ToRop3[mix & 0xf];
    background = Rop2ToRop3[(mix >> 8) & 0xf];

    if (background == 0xAA) // 0xAA ==> background is Opaque
    {   
        //
        // ROP 0xAA is D = Destination. When background ROP is 0xAA it means
        // the white pixels of the brush should not overwrite whats already
        // on the surface. This can be achieved by setting transparency mode
        // to 1 = Transparent.
        //
        HPGL_SelectTransparency(pDevObj, eTRANSPARENT, 0);
    }

    bRet = SelectRop3(pDevObj, foreground);

    EXITING(SelectMix);

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////
// SelectROP4()
//
// Routine Description:
// 
//   Select the specified ROP4 into current graphics state
//
// Arguments:
// 
//   pdev - Points to our DEVDATA structure
//   Rop4 - ROP4
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectROP4(PDEVOBJ pDevObj, ROP4 Rop4)
{
    ROP4    foreground, background;
    BOOL    bRet;

    ENTERING(SelectROP4);

    ASSERT_VALID_PDEVOBJ(pDevObj);

    // Bit 7-0 defines the foreground ROP2
    // Bit 15-8 defines the foreground ROP2
    //
    foreground = Rop4 & 0xff;
    background = (Rop4 >> 8) & 0xff;

    if (background == 0xAA) // 0xAA ==> background is Opaque
    {
//dz        VERBOSE(("SelectROP4: background ROP is 0xAA\n"));
		//dz why would you do this??
        // foreground = ( background << 8 ) | foreground; // combine foreground and background
    }

    bRet = SelectRop3(pDevObj, foreground);

    EXITING(SelectROP4);

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////
// SelectRop3()
//
// Routine Description:
// 
//   Select the specified raster operation code (ROP3) into current graphics 
//   state
//
//   [ISSUE] This routine has been commented out.  I haven't looked at it yet.
//   JFF
// 
//   [TODO] Add ENTERING, EXITING, PRE- and POSTCONDITION macros as necessary.
// 
// Arguments:
// 
//   pdev - Points to our DEVDATA structure
//   rop3 - Specifies the raster operation code to be used
//
//   Note: In winddi.h ROP4 is defined as ULONG
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL SelectRop3(PDEVOBJ pDevObj, ROP4 rop3)
{
    POEMPDEV    poempdev;
    
    ENTERING(SelectRop3);

    ASSERT(VALID_PDEVOBJ(pDevObj));
    poempdev = (POEMPDEV)pDevObj->pdevOEM;

    if (poempdev->CurrentROP3 == rop3)
	  return TRUE;
	else
	{
	  poempdev->CurrentROP3 = rop3;
	  return HPGL_SelectROP3(pDevObj, rop3);
	}

#ifdef COMMENTEDOUT
    if ( ( rop3 & 0xFF00 ) == 0xAA00 ) // 0xAA ==> D, bit 7 - bit 15 is the background ROP
    {
        // 0xAA ==> Background is transparent
        // It can be set by Win32 API SetBkMode(TRANSPARENT) or OPAQUE
        // The method of painting for gapping area of pattern ( brush ) is determined by background mode
        // If the mode is tranparent, Window will ignore the background color and will
        // not fill in the gapping area.

        // run metaview program with binrop01.emf to make code run into here
        // run CreateBrushIndirect case of Genoa to get here

//dz        Verbose1(("SelectRop3: ROP4 = %4X\n", rop3));
        if ( pDev->cgs.PaintTxMode != HP_eTransparent )
        {
            // HP_SetPaintTxMode_1(pDev, HP_eTransparent); 
            pDev->cgs.PaintTxMode = HP_eTransparent;
        }

        // HP_SetSourceTxMode_1(pDev, HP_eTransparent); // REVISIT
        // pDev->cgs.SourceTxMode HP_eTransparent;

    }
    else
    {
        if ( pDev->cgs.PaintTxMode != HP_eOpaque )
        {
            // HP_SetPaintTxMode_1(pDev, HP_eOpaque); 
            pDev->cgs.PaintTxMode = HP_eOpaque;

            // HP_SetSourceTxMode_1(pDev, HP_eOpaque); // REVISIT
            // pDev->cgs.SourceTxMode = HP_eOpaque;
        }
    }

    // Check the value to set against the state variable giving the present
    // ROP setting in the printer.  If there's a change, then send down the
    // new value, and update the state variable.
    //
    if ( (BYTE) rop3 != pDev->cgs.rop3) // rop3 is ULONG, cast it down to BYTE
    {
        pDev->cgs.rop3 = (BYTE) rop3;

        // Cheetah API call to send the rop3 to the printer
        //
        // HP_SetROP_1(pDev,(BYTE) rop3);
    }
#endif

    EXITING(SelectRop3);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\htblt.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:
    htblt.cpp


Abstract:
    This module contains all halftone bitblt functions.
    This is dedicated to handle functions for monochrome printers
    i.e. It is assumed at most places that functions in this file
    will be called only for monochrome printers.


Author:


[Environment:]
    Windows 2000 Unidrv driver


[Notes:]

Revision History:


--*/

#include "hpgl2col.h" //Precompiled header file

//
// Globals
//
const POINTL ptlZeroOrigin = {0,0};

//
// Declaration of Local functions.
//

BOOL 
bIsRectSizeSame (
        IN PRECTL prclSrc,
        IN PRECTL prclDst);

//
// See if we can use some intersect rectl function that is already in the hpgl driver
// instead of using this one from the plotter.
//
BOOL
IntersectRECTL(
    PRECTL  prclDest,
    PRECTL  prclSrc
    )

/*++

Routine Description:
    This function intersect two RECTL data structures which specified imageable
    areas.

Arguments:
    prclDest    - pointer to the destination RECTL data structure, the result
                  is written back to here
    prclSrc     - pointer to the source RECTL data structure to be intersect
                  with the destination RECTL
Return Value:
    TRUE if destination is not empty, FALSE if final destination is empty

Author:

Revision History:

--*/

{
    BOOL    IsNULL = FALSE;

    if (prclSrc != prclDest) {

        //
        // For left/top we will set to whichever is larger.
        //
        if (prclDest->left < prclSrc->left) {
            prclDest->left = prclSrc->left;
        }

        if (prclDest->top < prclSrc->top) {
            prclDest->top = prclSrc->top;
        }

        //
        // For right/bottom we will set to whichever is smaller
        //
        if (prclDest->right > prclSrc->right) {
            prclDest->right = prclSrc->right;
        }

        if (prclDest->bottom > prclSrc->bottom) {
            prclDest->bottom = prclSrc->bottom;
        }
    }

    return((prclDest->right > prclDest->left) &&
           (prclDest->bottom > prclDest->top));
}



/*++

Routine Name:
    HTCopyBits (= HalfToneCopyBits)

Routine Description:
    This is a version of HPGLCopyBits which is totally devoted to handling
    monochrome printers. 

Arguments: (Same as DrvCopyBits)
    psoDst  :
    psoSrc  :
    pco     :
    pxlo    :
    prclDst :
    pptlSrc :
    

 

Return Value:
    TRUE  : if succesful.
    FALSE : otherwise.

Last Error:

Explanation of Working:
    DrvCopyBits is called to copy bits from source surface to destination, without doing
    processing like stretching, rop etc.. So it is a very simple copy. The source
    and destination bitmap size should be same. 
    HTCopyBits is a specialized version of DrvCopyBits. It only handles cases where the 
    printer is monochrome, but the device surface is declared as color. Therefore the
    GDI can give us ColorImages to work on as part of DDI calls. But sometimes, we trick
    GDI to halftone the images for us, In that case, the src surface has the halftoned
    1bpp image (point 3 below). 
    Consider the cases below.
    1) psoSrc is 1bpp. 
        a) If poempdev->psoHTBlt is set : It means we need to copy the psoSrc into the 
           poempdev->psoHTBlt. This usually happens when we receive a color brush and we
           need to use GDI to halftone it and convert it into monochrome.
        b) If (poempdev->dwFlags & PDEVF_RENDER_IN_COPYBITS) : It means we simply need
           to send this image to the printer. This usually happens when we got a color
           image in DrvBitBlt/StretchBlt/StretchBltROP and we used GDI to halftone
           it.
        c) If none of the above is true, it means we directly got a 1bpp image in 
           CopyBits. We need to output it directly to the printer, 

    2) If the psoSrc is greater that 1bpp, then we cannot handle it, so we pass
    it on to GDI (we call dwCommonROPBlt which eventually calls GDI's EngStretchBlt).
    
--*/

BOOL HTCopyBits(    
    SURFOBJ        *psoDst,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDst,
    POINTL         *pptlSrc
    )

{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;
    SURFOBJ    *psoHTBlt = NULL;  //convenience local variable
    PDEV       *pPDev;            // Unidrv's PDEV. 
    BOOL        bRetVal = TRUE;

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    pPDev = (PDEV *) pdevobj;

    if ( bMonochromeSrcImage(psoSrc) )
    {
        //
        // Case 1a.
        //
        if ( psoHTBlt = poempdev->psoHTBlt ) //Or could also have used PDEVF_USE_HTSURF flag.
        {
            if (!EngCopyBits(psoHTBlt,              // psoDst
                             psoSrc,                // psoSrc
                             pco,                   // pco
                             NULL,                  // pxlo
                             &(poempdev->rclHTBlt),    // prclDst
                             pptlSrc))             // pptlSrc
            {
                WARNING(("DrvCopyBits: EngCopyBits(psoHTBlt, psoSrc) Failed"));
                bRetVal = FALSE;
            }

            //
            // EngCopyBits can call some Drvxxx which can call into
            // some plugin module, which can overwrite our pdevOEM.
            // So we need to reset pdevOEM
            //
            BRevertToHPGLpdevOEM (pdevobj);
        }
    
        //
        // Case 1b.
        //
        else if ( poempdev->dwFlags & PDEVF_RENDER_IN_COPYBITS )
        {

            //
            // If the source surface is 1bpp, we can straight away send the image to 
            // to printer. If not, then thats an error which we cannot handle for 
            // the time being. 
            //
            bRetVal = OutputHTBitmap(pdevobj, psoSrc, pco, prclDst, pptlSrc, pxlo);
        }
    
        else 
        { 
            //
            // Case 1c.
            //
            bRetVal = OutputHTBitmap(pdevobj, psoSrc, pco, prclDst, pptlSrc, pxlo);
        }
    
    return bRetVal;
    }

    //
    // Case 2 mentioned above.
    // 
    
    //
    // Set the source rectangle size. The top left corners are either (pptlSrc->x, pptlSrc->y)
    // or (0,0). The length and width is same as that of destination rectangle.
    //
    RECTL rclSrc;
    if (pptlSrc) {

        rclSrc.left = pptlSrc->x;
        rclSrc.top  = pptlSrc->y;

    } else {

        rclSrc.left =
        rclSrc.top  = 0;
    }
    //
    // Since this is CopyBit and not a stretchBlt, the source and destination
    // rectangle size is same. 
    //
    rclSrc.right  = rclSrc.left + (prclDst->right - prclDst->left);
    rclSrc.bottom = rclSrc.top  + (prclDst->bottom - prclDst->top);

    //
    // WARNING: dwCommonROPBlt calls EngStretchBlt which calls DrvCopyBits and here we
    // are calling dwCommonROPBlt all over again. This could lead to recursion. 
    // Therefore I have put a check for flag (PDEVF_IN_COMMONROPBLT) in dwCommonROPBlt 
    // that returns failure if recursion detected.
    // This flag has been replaced by lRecursionLevel. 
    //

    //
    // Another issue to consider is that DrvCopyBits can be called directly by GDI
    // (point 1c, 2 above) or called by the driver indirectly through GDI (point 
    // 1a,b explained above).
    // Point 1b,c is simple as the image is directly sent to printer.
    // But point 2 is complex because the source and destination surfaces both
    // are color, but we cannot handle color images. So now we can do two things.
    // 1) Create a 1bpp shadow bitmap and call GDI's EngCopyBits to halftone the image on it.
    // 2) Create a 1bpp shadow bitmap and call GDI's EngStretchBlt to halftone the image on it.
    // 3) Do the halftoning ourselves.
    // Since we can use GDI to halftone, there is no use wasting our time to write that code.
    // The plotter driver uses option 2 so I will use it here. (Option 1 i have not tried and 
    // I am not even sure it will work)
    // The problem with Option 2 is that dwCommonRopBlt calls EngStretchBlt which again calls
    // DrvCopyBits. So DrvCopyBits is on stack twice. When DrvCopyBits calls HPGLCopyBits
    // it uses the macro HANDLE_VECTORHOOKS. That macro checks whether HPGLCopyBits is 
    // already on stack ((pdev)->dwVMCallingFuncID != ep). 
    // If so, it thinks there is a recursion happening, so it returns
    // FALSE without processing the call. This will cause the bitmap to not be printed.
    // Workaround is to change (pdev)->dwVMCallingFuncID to a value other than EP_OEMCopyBits
    // before we call dwCommonROPBlt and to put the value back after returning 
    // from dwCommonROPBlt.
    //

    BOOL bValueChanged = FALSE;
    if ( pPDev->dwVMCallingFuncID == EP_OEMCopyBits )
    {
        pPDev->dwVMCallingFuncID = MAX_OEMHOOKS;
        bValueChanged = TRUE;
    } 
    DWORD dwRetVal =  dwCommonROPBlt (
                            psoDst,
                            psoSrc,
                            NULL,
                            pco,
                            pxlo,
                            NULL,               // pca,
                            NULL,               // pbo,
                            &rclSrc,
                            prclDst,
                            NULL,               // pptlMask
                            NULL,               // pptlBrush,
                            ROP4_SRC_COPY       // rop4 0xCCCC = SRC_COPY
                            ) ; 

    if ( bValueChanged )
    {
        pPDev->dwVMCallingFuncID = EP_OEMCopyBits;
    }

    return (dwRetVal == RASTER_OP_SUCCESS ? TRUE: FALSE);
}

/*++

Routine Name:
    dwCommonROPBlt

Routine Description:
    This function has the functionality that is superset of the functionality of 
    HPGLStretchBlt, StretchBltROP and BitBlt. Therefore, all the three functions
    call it do their work. Sometimes even CopyBits needs to call it.
    
Arguments:
    psoDst:
    psoSrc:
    psoMask:
    pco:
    pxlo:
    pca:
    pbo:
    prclSrc:
    prclDst: ... Note that the coordinates may not be well-ordered. i.e. it is possible
                 that top > bottom, and/or left > right.
    pptlBrush:
    rop4
 

Return Value:
    RASTER_OP_SUCCESS   : if OK
    RASTER_OP_CALL_GDI  : if rop not supported ->call corresponding Engxxx-function
    RASTER_OP_FAILED    : if error

Last Error:

--*/


DWORD DWMonochromePrinterCommonRoutine (
            IN SURFOBJ    *psoDst,
            IN SURFOBJ    *psoSrc,
            IN SURFOBJ    *psoMask,
            IN CLIPOBJ    *pco,
            IN XLATEOBJ   *pxlo,
            IN COLORADJUSTMENT *pca,
            IN BRUSHOBJ   *pbo,
            IN RECTL      *prclSrc,
            IN RECTL      *prclDst,
            IN POINTL     *pptlMask,
            IN POINTL     *pptlBrush,
            IN ROP4        rop4,
            IN DWORD       dwSimplifiedRop)
{
    PDEVOBJ     pdevobj  = NULL;
    POEMPDEV    poempdev = NULL;
    DWORD       dwRasterOpReturn = RASTER_OP_SUCCESS;
    DWORD       dwfgRop3, dwbkRop3;
    POINTL      ptlHTOrigin;
    RECTL       rclHTBlt = {0,0,0,0};

    TERSE(("DWMonochromePrinterCommonRoutine() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return RASTER_OP_FAILED );

    dwfgRop3 = GET_FOREGROUND_ROP3(rop4);
    dwbkRop3 = GET_BACKGROUND_ROP3(rop4);

    SelectROP4(pdevobj, rop4); // Select the rop.

    //
    // Case 3.
    //
    if ( (dwSimplifiedRop & BMPFLAG_PAT_COPY) && 
              (dwSimplifiedRop & BMPFLAG_SRC_COPY) 
            )
    {
        PCLPATTERN *pPCLPattern = NULL;
        pPCLPattern = &(poempdev->RasterState.PCLPattern);


        //
        // This should download the PCL pattern related to the brush.
        //
        BSetForegroundColor(pdevobj, pbo, pptlBrush, pPCLPattern, BMF_1BPP);

        //
        // Now download the image.
        //
        dwRasterOpReturn = bHandleSrcCopy  (
                                         psoDst,
                                         psoSrc,
                                         psoMask,
                                         pco,
                                         pxlo,
                                         NULL,       // pca,
                                         pbo,
                                         prclSrc,
                                         prclDst,
                                         pptlMask,
                                         pptlBrush,
                                         rop4,
                                         dwSimplifiedRop
                                 ) ? RASTER_OP_SUCCESS : RASTER_OP_FAILED;

    }

    else if ( (dwSimplifiedRop & BMPFLAG_SRC_COPY) || 
                        // Copy the psoSrc image to the destination.
              (dwSimplifiedRop & BMPFLAG_NOT_SRC_COPY) 
                        // Invert the psoSrc image before copying to the destination.
            )
    {

        dwRasterOpReturn = bHandleSrcCopy  (
                                         psoDst,
                                         psoSrc,
                                         psoMask,
                                         pco,
                                         pxlo,
                                         NULL,       // pca,
                                         pbo,
                                         prclSrc,
                                         prclDst,
                                         pptlMask,
                                         pptlBrush,
                                         rop4,
                                         dwSimplifiedRop
                                 ) ? RASTER_OP_SUCCESS : RASTER_OP_FAILED;


    }
    else 
    {
        WARNING(("Invalid ROP\n"));
        dwRasterOpReturn = RASTER_OP_FAILED;
    }

    return dwRasterOpReturn; 
}



/*++

Routine Name:
    OutputHTBitmap

Routine Description:
    Dumps to the printer, the image defined in psoHT.
    This function only works with monochrome images in psoHT.

Arguments:
    pdevobj,
    psoHT,
    pco,
    prclDest,
    pptlSrc,
    pxlo

Return Value:
    TRUE : If bitmap succesfully sent to printer.
    FALSE: Otherwise.
 

Last Error:

--*/

BOOL
OutputHTBitmap(
    PDEVOBJ  pdevobj,
    SURFOBJ  *psoHT,
    CLIPOBJ  *pco,
    PRECTL    prclDest,
    POINTL   *pptlSrc,
    XLATEOBJ *pxlo
    )
{
    POINTL      ptlDest;
    SIZEL       sizlDest;
    POEMPDEV    poempdev;
    BOOL        bRetVal = TRUE;


    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );


    //
    // This function should be called only for printing 1bpp source bitmaps.
    //

    ASSERT(psoHT->iBitmapFormat == BMF_1BPP);

    //
    // Find out if image needs to be inverted.
    //
    if ( BImageNeedsInversion(pdevobj, psoHT->iBitmapFormat, pxlo ) )
    {
        poempdev->dwFlags ^= PDEVF_INVERT_BITMAP;
    }

    //
    // Populate sizlDest, ptlDest from prclDest.
    //
    VGetparams(prclDest, &sizlDest, &ptlDest);

    //
    // Dump the halftone image in psoHT to the printer. 
    //
    bRetVal =  BGenerateBitmapPCL ( 
                    pdevobj,
                    psoHT,
                    NULL,       // NULL pbo
                    &ptlDest,
                    &sizlDest,
                    pptlSrc,
                    &sizlDest,
                    pco,
                    pxlo,
                    NULL);      // NULL pptlBrush

    //
    // Reset the flag (even if it was not set earlier).
    // Note to Self: Dont put a return statement between the line where we
    // set the flag and this line.
    //
    poempdev->dwFlags &= ~PDEVF_INVERT_BITMAP;

    return bRetVal;
}

/*++

Routine Name:
    BImageNeedsInversion

Routine Description:
    Determines whether an image needs inversion by looking at
    pxlo. 
    Monochrome printers think pixel set to 0 is white and 1 is black.
    If pxlo indicates the image is formatted in a manner opposite to 
    what the printer accepts, then we have to invert it.
    NOTE : If pxlo is NULL or its parameters make it difficult to
           determine whether image needs to be inverted, then we wont
           the image.
           
    Inversion is done only if SrcBpp = 1, i.e.
    only for monochrome images 
   
Arguments:
    pdevobj       - Pointer to our PDEV
    iBitmapFormat - Format of image to be inverted. It should be 1.
               because we only supprt inverting 1bpp image.
    pxlo          - The XLATEOBJ that will be used to determine
                    whether image needs to be inverted.

Return Value:
    TRUE if image needs to be inverted.
    FALSE otherwise or if there is an error.

Last Error:

--*/

BOOL
BImageNeedsInversion(
    IN  PDEVOBJ   pdevobj,
    IN  ULONG     iBitmapFormat,
    IN  XLATEOBJ *pxlo)
{
    PULONG pulTx = NULL; //pointer to translate table from pxlo 

    if (iBitmapFormat != BMF_1BPP)
    {
        //
        // Do not attempt to invert non 1bpp images.
        //
        return FALSE;
    }

    //
    // pxlo 
    //
    if  ( (pxlo == NULL )                ||
          (pxlo->pulXlate == NULL )     
        )
    {
        //
        // Indecipherable pxlo, return FALSE. 
        //
        return FALSE;
    }

    //
    // PXLO is valid. Since this is a 1bpp image there should be only
    // 2 entries in pxlo. (i.e. pxlo->cEntries  = 2). 
    // The first entry  i.e. pxlo->pulXlate[0] gives the color of 0 pixel
    // The second entry i.e. pxlo->pulXlate[1] gives the color of 1 pixel
    // If the color of first entry is white (0x00FFFFFF) and that of 
    // second entry is black, then the image does not need to be inverted. 
    // (Because Monochrome printers think pixel set to 0 is white and 1 
    // is black).
    // 
    
    pulTx = GET_COLOR_TABLE(pxlo);

    if (  pulTx                   &&
         (pulTx[0]  == RGB_WHITE) &&
         (pulTx[1]  == RGB_BLACK) )
    {
        return FALSE;
    }
    return TRUE;
}

/*++

Routine Name:
    CreateBitmapSURFOBJ

Routine Description:
    Creates a bitmap and associates (locks) that bitmap with a new surface.
    The size of the bitmap created can handle an image whose BPP is 'Format' 
    and whose size is 'cxSize' * 'cySize'
    
Arguments:
   pPDev   - Pointer to our PDEV
   phBmp   - Pointer the HBITMAP location to be returned for the bitmap
   cxSize  - CX size of bitmap to be created
   cySize  - CY size of bitmap to be created
   Format  - one of BMF_xxx bitmap format to be created
   pvBits  - the buffer to be used

Return Value:
    SURFOBJ if sucessful, NULL if failed


Last Error:

--*/

SURFOBJ *
CreateBitmapSURFOBJ(
    PDEVOBJ  pPDev,
    HBITMAP *phBmp,
    LONG    cxSize,
    LONG    cySize,
    DWORD   Format,
    LPVOID  pvBits
    )

{
    SURFOBJ *pso = NULL;
    SIZEL   szlBmp;


    szlBmp.cx = cxSize;
    szlBmp.cy = cySize;


    if (*phBmp = EngCreateBitmap(szlBmp,
                                 GetBmpDelta(Format, cxSize),
                                 Format,
                                 BMF_TOPDOWN | BMF_NOZEROINIT,
                                 pvBits)) {

        if (EngAssociateSurface((HSURF)*phBmp, (HDEV)pPDev->hEngine, 0)) {

            if (pso = EngLockSurface((HSURF)*phBmp)) {

                //
                // Sucessful lock down, return it
                //

                return(pso);

            } else {

                WARNING(("CreateBmpSurfObj: EngLockSruface(hBmp) failed!"));
            }

        } else {

            WARNING(("CreateBmpSurfObj: EngAssociateSurface() failed!"));
        }

    } else {

        WARNING(("CreateBMPSurfObj: FAILED to create Bitmap Format=%ld, %ld x %ld",
                                        Format, cxSize, cySize));
    }

    DELETE_SURFOBJ(&pso, phBmp);

    return(NULL);
}


/*++

Routine Description:


    This function calculates the total bytes needed in order to advance a
    scan line based on the bitmap format and alignment.

Arguments:

    SurfaceFormat   - Surface format of the bitmap, this must be one of the
                      standard formats which are defined as BMF_xxx

    cx              - Total Pels per scan line in the bitmap.

Return Value:

    The return value is the total bytes in one scan line if it is greater than
    zero

Last Error: 

--*/

LONG
GetBmpDelta(
    DWORD   SurfaceFormat,
    DWORD   cx
    )
{
    DWORD   Delta = cx;

    switch (SurfaceFormat) {

    case BMF_32BPP:

        Delta <<= 5;
        break;

    case BMF_24BPP:

        Delta *= 24;
        break;

    case BMF_16BPP:

        Delta <<= 4;
        break;

    case BMF_8BPP:

        Delta <<= 3;
        break;

    case BMF_4BPP:

        Delta <<= 2;
        break;

    case BMF_1BPP:

        break;

    default:

        ERR(("GetBmpDelta: Invalid BMF_xxx format = %ld", SurfaceFormat));
        break;
    }

    Delta = (DWORD)DW_ALIGN((Delta + 7) >> 3);

    VERBOSE(("Format=%ld, cx=%ld, Delta=%ld", SurfaceFormat, cx, Delta));

    return((LONG)Delta);
}




BOOL
HalftoneBlt(
    PDEVOBJ     pdevobj,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoHTBlt,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PPOINTL     pptlHTOrigin,
    BOOL        DoStretchBlt
    )

/*++

Routine Description:


Arguments:

    pdevobj           - Pointer to driver's private PDEV

    psoDst          - destination surfobj

    psoHTBlt        - the final halftoned result will be stored, must be a
                      4/1 halftoned bitmap format

    psoSrc          - source surfobj must be BITMAP

    pxlo            - xlate object from source to the plotter device

    prclDest        - rectangle area for the destination

    prclSrc         - rectangle area to be halftoned from the source, if NULL
                      then full source size is used

    pptlHTOrigin    - the halftone origin, if NULL then (0,0) is assumed

    StretchBlt      - if TRUE then a stretch from rclSrc to rclDst otherwise
                      a tiling is done


Return Value:

    BOOL to indicate operation status


Author:

    19-Jan-1994 Wed 15:44:57 created  -by-  DC


Revision History:


--*/

{
    SIZEL   szlSrc;
    RECTL   rclSrc;
    RECTL   rclDst;
    RECTL   rclCur;
    RECTL   rclHTBlt;
    POEMPDEV    poempdev = NULL;


    VERBOSE(("HalftoneBlt: psoSrc type [%ld] is not a bitmap",
                        psoSrc->iType == STYPE_BITMAP, (LONG)psoSrc->iType));
    VERBOSE(("HalftoneBlt: psoHTBlt type [%ld] is not a bitmap",
                       psoHTBlt->iType == STYPE_BITMAP, (LONG)psoHTBlt->iType));

    if ( !pdevobj ||
         !(poempdev = (POEMPDEV)pdevobj->pdevOEM) )
    {
        ERR(("Invalid Parameter"));
        return FALSE;
    }

    if ( poempdev->psoHTBlt)
    {
        ERR(("HalftoneBlt: EngStretchBlt(HALFTONE) RECURSIVE CALLS NOT ALLOWED!"));
        return(FALSE);
    } 

    poempdev->psoHTBlt = psoHTBlt;

    if (prclSrc) {

        rclSrc = *prclSrc;

    } else {

        rclSrc.left   =
        rclSrc.top    = 0;
        rclSrc.right  = psoSrc->sizlBitmap.cx;
        rclSrc.bottom = psoSrc->sizlBitmap.cy;
    }

    if (prclDst) {

        rclDst = *prclDst;

    } else {

        rclDst.left   =
        rclDst.top    = 0;
        rclDst.right  = psoHTBlt->sizlBitmap.cx;
        rclDst.bottom = psoHTBlt->sizlBitmap.cy;
    }

    if (!pptlHTOrigin) {

        pptlHTOrigin = (PPOINTL)&ptlZeroOrigin;
    }

    if (DoStretchBlt) {

        szlSrc.cx = rclDst.right - rclDst.left;
        szlSrc.cy = rclDst.bottom - rclDst.top;

    } else {

        szlSrc.cx = rclSrc.right - rclSrc.left;
        szlSrc.cy = rclSrc.bottom - rclSrc.top;
    }

    VERBOSE(("HalftoneBlt: %hs BLT, (%ld,%ld)-(%ld,%ld), SRC=%ldx%ld",
                    (DoStretchBlt) ? "STRETCH" : "TILE",
                    rclDst.left, rclDst.top, rclDst.right,rclDst.bottom,
                    szlSrc.cx, szlSrc.cy));

    //
    // Start to tile it, rclCur is current RECTL on the destination
    //

    rclHTBlt.top  = 0;
    rclCur.top    =
    rclCur.bottom = rclDst.top;

    while (rclCur.top < rclDst.bottom) {

        //
        // Check the Current Bottom, clip it if necessary
        //

        if ((rclCur.bottom += szlSrc.cy) > rclDst.bottom) {

            rclCur.bottom = rclDst.bottom;
        }

        rclHTBlt.bottom = rclHTBlt.top + (rclCur.bottom - rclCur.top);

        rclHTBlt.left   = 0;
        rclCur.left     =
        rclCur.right    = rclDst.left;

        while (rclCur.left < rclDst.right) {

            //
            // Check the Current right, clip it if necessary
            //

            if ((rclCur.right += szlSrc.cx) > rclDst.right) {

                rclCur.right = rclDst.right;
            }

            //
            // Set it for the tiling rectangle in psoHTBlt
            //

            rclHTBlt.right = rclHTBlt.left + (rclCur.right - rclCur.left);

            VERBOSE(("HalftoneBlt: TILE (%ld,%ld)-(%ld,%ld)->(%ld,%ld)-(%ld,%ld)=%ld x %ld",
                            rclCur.left, rclCur.top, rclCur.right, rclCur.bottom,
                            rclHTBlt.left, rclHTBlt.top,
                            rclHTBlt.right, rclHTBlt.bottom,
                            rclCur.right - rclCur.left,
                            rclCur.bottom - rclCur.top));

            //
            // Set it before the call for the DrvCopyBits()
            //

            //
            // Setting dwFlags to PDEVF_USE_HTSURF. When EngStretchBlt
            // calls HPGLCopyBits, we will look for this flag. If flag
            // is set we copy the image in psoSrc (psoSrc that is received by
            // HPGLCopyBits ) to pompdev->psoHTBlt
            //
            poempdev->rclHTBlt = rclHTBlt;
            poempdev->dwFlags |= PDEVF_USE_HTSURF;

            if (!EngStretchBlt(psoDst,              // Dest
                               psoSrc,              // SRC
                               NULL,                // MASK
                               NULL,                // CLIPOBJ
                               pxlo,                // XLATEOBJ
                               NULL,                // COLORADJUSTMENT
                               pptlHTOrigin,        // BRUSH ORG
                               &rclCur,             // DEST RECT
                               &rclSrc,             // SRC RECT
                               NULL,                // MASK POINT
                               HALFTONE)) {         // HALFTONE MODE

                //
                // EngStretchBlt can call some Drvxxx which can call into
                // some plugin module, which can overwrite our pdevOEM.
                // So we need to reset pdevOEM
                //
                BRevertToHPGLpdevOEM (pdevobj);


                ERR(("HalftoneeBlt: EngStretchBits(DST=(%ld,%ld)-(%ld,%ld), SRC=(%ld,%ld) FAIELD!",
                                    rclCur.left, rclCur.top,
                                    rclCur.right, rclCur.bottom,
                                    rclSrc.left, rclSrc.top));

                poempdev->psoHTBlt = NULL;
                poempdev->dwFlags &= ~PDEVF_USE_HTSURF;
                return(FALSE);
            }

            //
            // EngStretchBlt can call some Drvxxx which can call into
            // some plugin module, which can overwrite our pdevOEM.
            // So we need to reset pdevOEM
            //
            BRevertToHPGLpdevOEM (pdevobj);

            rclHTBlt.left = rclHTBlt.right;
            rclCur.left   = rclCur.right;
        }

        rclHTBlt.top = rclHTBlt.bottom;
        rclCur.top   = rclCur.bottom;
    }

    poempdev->psoHTBlt = NULL;
    poempdev->dwFlags &= ~PDEVF_USE_HTSURF;

    return(TRUE);
}





SURFOBJ *
CloneSURFOBJToHT(
    PDEVOBJ       pPDev,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    XLATEOBJ    *pxlo,
    HBITMAP     *phBmp,
    PRECTL      prclDst,
    PRECTL      prclSrc
    )
/*++

Routine Description:

    This function clones the surface object passed in


Arguments:

    pPDev           - Pointer to our PPDEV

    psoDst          - the surface object for the plotter, if psoDst is NULL
                      then only the bitmapp will be created

    psoSrc          - The surface object to be cloned

    pxlo            - XLATE object to be used from source to plotter surfobj

    phBmp           - Pointer to stored hBbitmap created for the cloned surface

    prclDst         - rectangle rectangle size/location to be cloned

    prclSrc         - source rectangle size/location to be cloned

Return Value:

    pointer to the cloned surface object, NULL if failed.

    if this function is sucessful it will MODIFY the prclSrc to reflect cloned
    surface object


Author:

    04-Jan-1994 Tue 12:11:23 created  -by-  DC


Revision History:


--*/

{
    SURFOBJ *psoHT;
    RECTL   rclDst;
    RECTL   rclSrc;
    POINTL  ptlHTOrigin;


    rclSrc.left   =
    rclSrc.top    = 0;
    rclSrc.right  = psoSrc->sizlBitmap.cx;
    rclSrc.bottom = psoSrc->sizlBitmap.cy;

    if (prclSrc) {

        if (!IntersectRECTL(&rclSrc, prclSrc)) {
            return(NULL);
        }
    }

    rclDst.left   =
    rclDst.top    = 0;
    rclDst.right  = psoDst->sizlBitmap.cx;
    rclDst.bottom = psoDst->sizlBitmap.cy;

    if (prclDst) {

        if (!IntersectRECTL(&rclDst, prclDst)) {
            return(NULL);
        }
    }

    if (psoHT = CreateBitmapSURFOBJ(pPDev,
                                    phBmp, 
                                    rclDst.right -= rclDst.left,
                                    rclDst.bottom -= rclDst.top,
                                    BMF_1BPP,                    
                                    NULL)) {

        //
        // Halftone and tile the source to the destination
        //

        ptlHTOrigin.x = rclDst.left;
        ptlHTOrigin.y = rclDst.top;

        if (prclSrc) {

            if ((rclDst.left = prclSrc->left) > 0) {

                rclDst.left = 0;
            }

            if ((rclDst.top = prclSrc->top) > 0) {

                rclDst.top = 0;
            }

            //
            // Modify the source to reflect the cloned source
            //

            *prclSrc = rclDst;
        }


        if (psoDst) {

            if (!HalftoneBlt(pPDev,
                             psoDst,
                             psoHT,
                             psoSrc,
                             pxlo,
                             &rclDst,
                             &rclSrc,
                             &ptlHTOrigin,
                             FALSE)) {

                ERR(("CloneSURFOBJToHT: HalftoneBlt(TILE) Failed"));

                DELETE_SURFOBJ(&psoHT, phBmp);
            }
        }

    } else {

        ERR(("CreateSolidColorSURFOBJ: Create Halftone SURFOBJ failed"));
    }

    return(psoHT);
}


/*++
Routine Name:
    bCreateHTImage

Routine Description:

Arguments:

Return Value:
    BOOL :

Last Error:
--*/

BOOL bCreateHTImage( 
          OUT   PRASTER_DATA pSrcImage,      // 
                SURFOBJ      *psoDst,        // psoDst,
                SURFOBJ      *psoPattern,    // psoSrc,
                SURFOBJ     **ppsoHT,        // Note: This is address of pointer to SURFOBJ
                HBITMAP      *phBmpHT,
                XLATEOBJ     *pxlo,
                ULONG        iHatch)
{

    SURFOBJ    *psoHT   = NULL;
    SIZEL       szlHT;
    RECTL       rclHT;
    PDEVOBJ     pdevobj = NULL;
    BOOL        bRetVal = TRUE;



    if( !psoDst                             || 
        !pxlo                               || 
        !ppsoHT                             ||
        !phBmpHT                            ||
        !pSrcImage                          ||
        !psoPattern                         || 
        (psoPattern->iType != STYPE_BITMAP) || 
        (!(pdevobj = (PDEVOBJ)psoDst->dhpdev)) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // If src image itself is 1 bpp, and the two colors in the image
    // are black and white, then no need to halftone.
    //
    if ( psoPattern-> iBitmapFormat == BMF_1BPP )
    {
        //
        // Now find the colors in the image.
        //
        PDWORD pdwColorTable = GET_COLOR_TABLE(pxlo);

        if (pdwColorTable)
        {
            DWORD dwFirstColor  = pdwColorTable[0];
            DWORD dwSecondColor = pdwColorTable[1];

            if ( (dwFirstColor == RGB_BLACK && dwSecondColor == RGB_WHITE) || 
                 (dwFirstColor == RGB_WHITE && dwSecondColor == RGB_BLACK) ) 
            {
                psoHT = psoPattern;
            }
        }

    }

    if ( psoHT == NULL) //i.e. the image in psoPattern is not 1bpp b&w
    {
    
        szlHT        = psoPattern->sizlBitmap;

        rclHT.left   =
        rclHT.top    = 0;
        rclHT.right  = szlHT.cx;
        rclHT.bottom = szlHT.cy;


        //
        // Go generate the bits for the pattern.
        //

        psoHT = CloneSURFOBJToHT(pdevobj,       // pPDev,
                                 psoDst,        // psoDst,
                                 psoPattern,    // psoSrc,
                                 pxlo,          // pxlo,
                                 phBmpHT,       // hBmp,
                                 &rclHT,        // prclDst,
                                 NULL);         // prclSrc,
    }

    //
    // If psoHT is still not initialized, then something is wrong and 
    // we cannot continue
    //
    if ( psoHT)
    {
        //
        // If we reach here, it means we have successfully created a surface
        // with the halftoned brush on it. OR the surface already had 1bpp image on it.
        // Get the source image data from the surface object
        //
        bRetVal = InitRasterDataFromSURFOBJ(pSrcImage, psoHT, FALSE);
        
    } else {

        WARNING(("bCreateHTImage: Clone PATTERN FAILED"));
        bRetVal = FALSE;
    }


    *ppsoHT = psoHT;
    return bRetVal; 
}

/*++
Routine Name:
    bIsRectSizeSame

Routine Description:
    Simply checks whether the two rectangles are the same size.
    NOTE: This function assumes that the rectangle coordinates are well-ordered.

Arguments:
    The two rectangles to be compared. prclSrc, prclDst

Return Value:
    TRUE : If rectangle size is same.
    FALSE: otherwise.
 
Last Error:
    Not changed.
--*/


BOOL 
bIsRectSizeSame (
        IN PRECTL prclSrc, 
        IN PRECTL prclDst )
{
    //
    // Assuming rectangle coordinates are well ordered 
    // i.e. right >= left, bottom >= top
    //
    if ( (prclSrc->right  - prclSrc->left) == (prclDst->right  - prclDst->left)  &&
         (prclSrc->bottom - prclSrc->top)  == (prclDst->bottom - prclDst->top) )
    {
        return TRUE;
    }
    return FALSE;
}


/*++
Routine Name:
    bHandleSrcCopy

Routine Description:

Arguments:

Return Value:
    BOOL :

Last Error:
--*/

BOOL bHandleSrcCopy (
            IN SURFOBJ    *psoDst,
            IN SURFOBJ    *psoSrc,
            IN SURFOBJ    *psoMask,
            IN CLIPOBJ    *pco,
            IN XLATEOBJ   *pxlo,
            IN COLORADJUSTMENT *pca,
            IN BRUSHOBJ   *pbo,
            IN RECTL      *prclSrc,
            IN RECTL      *prclDst,
            IN POINTL     *pptlMask,
            IN POINTL     *pptlBrush,
            IN ROP4        rop4,
            IN DWORD       dwSimplifiedRop)
{
    PDEVOBJ     pdevobj     = NULL;
    POEMPDEV    poempdev    = NULL;
    POINTL      ptlHTOrigin = {0, 0};
    RECTL       rclHTBlt    = {0,0,0,0};
    BOOL        bRetVal     = TRUE;

    pdevobj   = (PDEVOBJ)psoDst->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev  = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return RASTER_OP_FAILED );



    //
    // This function is written to handle images that are either 
    // SRC_COPY or NOT_SRC_COPY 
    //
    if ( ! ( (dwSimplifiedRop & BMPFLAG_SRC_COPY) ||
             (dwSimplifiedRop & BMPFLAG_NOT_SRC_COPY) )
       )
    {
        return FALSE;
    }

    //
    // Prepare variables for future use.
    //

    //
    // Initialize the rectangle on which the halftoned result has to be placed.
    // This is same size as prclDst except that the left, top should be at 0,0.
    // rclHTBlt.left and rclHTBlt.top have already been initialized to 0 when rclHTBlt was
    // declared. So now, only rclHTBlt.right, rclHTBlt.bottom need to initialized.
    //
    rclHTBlt.right = prclDst->right - prclDst->left;
    rclHTBlt.bottom = prclDst->bottom - prclDst->top;

    //
    // Case 1: If the src image is 1bpp and the source recangle size is same as destination
    //   rectangle size (i.e. no stretching has to be done), we can 
    //   simply spit the image out to the printer. 
    //   NOTE that if GDI gives us a 1bpp image, it is probably an RGB image and not CMY.
    //   Therefore it has to inverted before being sent to printer.
    // Case 2: If image is >1bpp, image has to be halftoned (i.e. converted to 1bpp)
    //   If the src and dest image(rectangle) size are different, the image has to 
    //   appropriately stretched/compressed. This monochrome driver cannot do either. 
    //   So GDI has to be called. 
    // 

    //
    // Case 1
    //
    if ( bMonochromeSrcImage(psoSrc) && bIsRectSizeSame (prclSrc, prclDst) )
    {
        bRetVal  =  OutputHTBitmap(
                                 pdevobj,
                                 psoSrc,
                                 pco,
                                 prclDst,
                                 (POINTL *)prclSrc,
                                 pxlo
                             ); 
    }

    else 
    {

#ifdef USE_SHADOW_SURFACE
        //
        // Case 2. The driver is too dumb to convert the color image to monochrome,
        // therefore we have to make use of GDI. Here we call EngStretchBlt with 
        // iMode = HALFTONE which in turn calls DrvCopyBits. In EnablePDEV we have set  
        //  pGdiInfo->ulHTOutputFormat = HT_FORMAT_1BPP;
        // Therefore, the psoSrc of DrvCopyBits will be a 1bpp image. But the psoDst
        // is still 24bpp. How do we copy the 1bpp source image to 24bpp destination image???
        // We do this by creating a 1bpp shadow bitmap (or lets say a temporary surface) 
        // and store that surface in poempdev->psoHTBlt. Then DrvCopyBits is called.
        // In DrvCopyBits (or lets say HPGLCopyBits) 
        // we check whether poempdev->psoHTBlt = NULL or it has some valid value.
        // A valid value means, we simply need to copy the 1bpp psoSrc image into the 
        // 1bpp poempdev->psoHTBlt surface. This is done by using EngCopyBits. 
        //
        HBITMAP hNewBmp;
        SURFOBJ * psoHTBlt =  CreateBitmapSURFOBJ( 
                                        pdevobj,   
                                        &hNewBmp,
                                        prclDst->right - prclDst->left,
                                        prclDst->bottom - prclDst->top ,
                                        BMF_1BPP,   // Create 1bpp surface.
                                        NULL        // Allocate new buffer.
                                      );

        if ( psoHTBlt == NULL)
        {
            WARNING(("CreateBitmapSURFOBJ failed\n"));
            bRetVal = FALSE;
            goto finish;
        }
    

        poempdev->psoHTBlt = psoHTBlt;
#endif
        poempdev->rclHTBlt = rclHTBlt;

        poempdev->dwFlags |= PDEVF_RENDER_IN_COPYBITS;

        if ( EngStretchBlt(
                            psoDst,              // Dest
                            psoSrc,              // SRC
                            psoMask,             // MASK
                            pco,                 // CLIPOBJ
                            pxlo,                // XLATEOBJ
                            pca,                 // COLORADJUSTMENT ??? NULL or pca ???
                            &ptlHTOrigin,        // BRUSH ORG
                            prclDst,             // DEST RECT
                            prclSrc,             // SRC RECT
                            pptlMask,            // MASK POINT
                            HALFTONE)            // HALFTONE MODE 
                  &&

            BRevertToHPGLpdevOEM (pdevobj)

#ifdef USE_SHADOW_SURFACE
                  &&
            OutputHTBitmap(pdevobj,
                           psoHTBlt,
                           pco,
                           prclDst,
                           (POINTL *)prclSrc,
                           NULL    // pxlo already taken care of earlier.
                           )
#endif
           )
        {
            // Awesome, things are perfect.
        }
        else
        {
            //
            // EngStretchBlt can call some Drvxxx which can call into
            // some plugin module, which can overwrite our pdevOEM.
            // So we need to reset pdevOEM
            //
            BRevertToHPGLpdevOEM (pdevobj);

            bRetVal = FALSE;
            WARNING(("dwCommonROPBlt: EngStretchBlt or OutpuHTBitmap FAILED"));
        }
 
        //
        // Unlock psoHTBlt and delete the hNewBmp. Set both these to NULL.
        //
#ifdef USE_SHADOW_SURFACE
        DELETE_SURFOBJ (&psoHTBlt, &hNewBmp);
        poempdev->psoHTBlt = NULL;
#endif
        poempdev->dwFlags &= ~PDEVF_RENDER_IN_COPYBITS;


        //
        // Do I need to reset poempdev->rclHTBlt ???????
        // Lets be conservative and just do it.
        // poempdev->rclHTBlt = {0,0,0,0}; 
        //
        ZeroMemory(&(poempdev->rclHTBlt), sizeof(RECTL));

    }
#ifdef USE_SHADOW_SURFACE
finish:
#endif
    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\mix.h ===
///////////////////////////////////////////////////////////////////////////////
// 
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
// 
//   mix.h
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   08/06/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#ifndef MIX_H
#define MIX_H


BOOL SelectMix(PDEVOBJ pDevObj, MIX mix);
BOOL SelectROP4(PDEVOBJ pDevObj, ROP4 Rop4);

BOOL SelectRop3(PDEVOBJ pDevObj, ROP4 rop3);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\palette.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
//
//    palette.cpp
//
// Abstract:
//
//    Implementation of indexed palettes
//	  and routines assoocited with such palettes                
//	
//
// Environment:
//
//    Windows 2000/Whistler Unidrv driver
//
//
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

#define   BLACK  0x00000000

///////////////////////////////////////////////////////////////////////////////
// VResetPaletteCache()
//
// Routine Description:
// ====================
//
//  This function resets all of the color entries in the palette to INVALID and
//  marks them all as dirty.  This is useful when the system has reset the 
//  printer's palettes and our state data becomes invalid.
//
// Arguments:
// ==========
//
// pdevobj   - default devobj
//
// Return Value:
// none
///////////////////////////////////////////////////////////////////////////////
VOID
VResetPaletteCache(
    PDEVOBJ pdevobj
)
{
    ULONG    uIndex;
    POEMPDEV poempdev;
    PPCLPATTERN pPattern;

    VERBOSE(("VResetPalette() entry. \r\n"));

    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    if (poempdev == NULL)
        return;
    pPattern = &(poempdev->RasterState.PCLPattern);
    if (pPattern == NULL)
        return;

    for (uIndex = 0; uIndex < PALETTE_MAX; uIndex++)
    {
        pPattern->palData.ulPalCol[uIndex] = HPGL_INVALID_COLOR;
        pPattern->palData.ulDirty[uIndex] = TRUE;
    }

    pPattern->palData.pEntries = 0;
}


///////////////////////////////////////////////////////////////////////////////
// BGetPalette()
//
// Routine Description:
// ====================
//
//  Function determines type of palette provided 
//  by XlateObj.
//  Calls loadPlette to send palette to printer
//  
//
// Arguments:
// ==========
//
// pdevobj   - default devobj
// pxlo      - pointer to translation object
// bmpFormat - bits per pixel
//
// Return Value:
// True if palette exists, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL 
BGetPalette(
    PDEVOBJ pdevobj,
    XLATEOBJ *pxlo,
    PPCLPATTERN pPattern,
    ULONG srcBpp,
    BRUSHOBJ *pbo
)
{
    
    POEMPDEV  poempdev;
    PULONG   pulVector;
    ULONG    ulPalette[2];

    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    VERBOSE(("BGetPalette() entry. \r\n"));
    REQUIRE_VALID_DATA( pPattern, return FALSE );

    if(pPattern->colorMappingEnum == HP_eDirectPixel)
    {
        return FALSE;
    }

    if (pxlo != NULL)
    {
        if ((srcBpp == 1) ||
            (srcBpp == 4) ||
            (srcBpp == 8))
        {
            VERBOSE(("GetPalette:srcBpp==%d\r\n", srcBpp));
            if (!(pulVector = XLATEOBJ_piVector(pxlo))) //color vector
            {
                ERR(("INDEXED PALETTE REQUIRED. \r\n"));
                return FALSE;
            }
            return (BInitPalette(pdevobj,pxlo->cEntries, pulVector, pPattern, srcBpp)); 	   
        }
        else
        {
            return FALSE;  //Direct -->palette not required
            
        }
    }
    else
    {
        //
        // sandram - this is hardcoded for monochrome text
        // has to be enhanced for all color modes
        // text color is pbo->iSolidColor
        //

        //
        // Don't do this when printing text as raster--it'll get set in 
        // bSetIndexedForegroundColor. JFF
        //
        if (poempdev->bTextAsBitmapMode == FALSE)
        {
            if (pbo)
                ulPalette[1] = pbo->iSolidColor;
            else
                ulPalette[1] = RGB_BLACK;
        
            ulPalette[0] = RGB_WHITE;
            return (BInitPalette (pdevobj,
                                  2,
                                  ulPalette,
                                  pPattern,
                                  1));
        }
        //else
            //return TRUE;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// BInitPalette()
//
// Routine Description:
// ====================
//
//  Funct sends palette contained 
//  in pColorTable to printer using 
//  appropriate PCL commands
//  
//
// Arguments:
// ==========
//
// pdevobj      - default devobj
// bmpFormat    - bits per pixel
// colorEntries - # of entries in the palette
// pColorTable  - pointer to palette enries
//
// Return Value:
// True if palette is loaded, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
BInitPalette(
    PDEVOBJ pdevobj,
    ULONG colorEntries,
    PULONG pColorTable,
    PPCLPATTERN	 pPattern,
    ULONG        srcBpp
)
{
    PULONG   pRgb;
    ULONG    uIndex;
    
    VERBOSE(("bInitPalette() entry. \r\n"));
    VERBOSE(("palette entries=%ld \r\n", colorEntries));
    
    //
    // We create palette only for 1,4 or 8bpp images.
    //
    if ( !(srcBpp == 1 || srcBpp == 4 || srcBpp == 8) )
    {
        WARNING(("BInitPalette: srcBpp=%d is not a valid value-1,4,8.\r\n", srcBpp));
        return FALSE;
    }

    pRgb = pColorTable;
    for ( uIndex = 0; uIndex < colorEntries; uIndex++)
    {
        if (pPattern->palData.ulPalCol[uIndex]       != pRgb[uIndex]       ||
            pPattern->palData.ulPalCol[uIndex]       == HPGL_INVALID_COLOR || 
            !(pPattern->palData.ulValidPalID[uIndex] &  srcBpp) )
        {
            if ( pPattern->palData.ulPalCol[uIndex]  != pRgb[uIndex] )
            {
                //
                // If the color for a certain index has changed
                // then invalidate it for all bpps except this one.
                //
                pPattern->palData.ulValidPalID[uIndex] = srcBpp;
                pPattern->palData.ulPalCol[uIndex]     = pRgb[uIndex];
            }
            else
            {
                pPattern->palData.ulValidPalID[uIndex] |= srcBpp;
            }
            pPattern->palData.ulDirty[uIndex] = TRUE;
            VERBOSE(("PATTERN COLOR =%ld  \r\n", pPattern->palData.ulPalCol[uIndex]));
        }
        else
        {
            pPattern->palData.ulDirty[uIndex] = FALSE;
        }
    }
    pPattern->palData.pEntries = uIndex;
    
    return bLoadPalette(pdevobj, pPattern);
}

///////////////////////////////////////////////////////////////////////////////
// LoadPalette()
//
// Routine Description:
// ====================
//
//  Funct sends palette contained 
//  in pColorTable to printer using 
//  appropriate PCL commands
//  
//
// Arguments:
// ==========
//
// pdevobj      - default devobj
// bmpFormat    - bits per pixel
// colorEntries - # of entries in the palette
// pColorTable  - pointer to palette enries
//
// Return Value:
// True if palette is loaded, false otherwise
///////////////////////////////////////////////////////////////////////////////

BOOL
bLoadPalette(
    PDEVOBJ pDevObj,
    PPCLPATTERN pPattern
)
{
    ULONG     colorEntries = 0;
    ULONG     uIndex;
    POEMPDEV  poempdev;
    ECIDPalette eCIDPalette;
    
    colorEntries = pPattern->palData.pEntries;
    ASSERT(VALID_PDEVOBJ(pDevObj));
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    eCIDPalette = EGetCIDPrinterPalette (pPattern->iBitmapFormat);

    VERBOSE(("SENDING PALETTE DOWN ->#ENTRIES =%d. \n\r", colorEntries));
    
    if (poempdev && (poempdev->eCurCIDPalette == eCIDPalette))
    {
        //
        // this is the same palette as the previous palette so we
        // just send down the palette entries that have changed.
        //
        for ( uIndex = 0; uIndex < colorEntries; uIndex++)
        {
            if (pPattern->palData.ulDirty[uIndex] == TRUE)
                PCL_IndexedPalette(pDevObj,
                                   pPattern->palData.ulPalCol[uIndex],
                                   uIndex);
        }
    }
    else
    {
        //
        // this palette is a different format than the last palette
        // so send the entire palette to the printer.
        //
        for ( uIndex = 0; uIndex < colorEntries; uIndex++)
        {
            PCL_IndexedPalette(pDevObj, pPattern->palData.ulPalCol[uIndex], uIndex);
        }
    }
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// SetForegroundColor()
//
// Routine Description:
// 
// Routines takes a color as input,
//  sets entry #0 of indexed palette with input color,
//  sets foreground color based on palette entry #0,
//  replaces overwritten entry with previous color
//
//  
//
// Arguments:
// ==========
//
// pdevobj    - default devobj
// pPattern	- pointer to palette enries
// uColor		- specifies foreground color
//
// Return Value:
// Not Required
///////////////////////////////////////////////////////////////////////////////

BOOL
BSetForegroundColor(PDEVOBJ pdevobj, BRUSHOBJ *pbo, POINTL *pptlBrushOrg,
                    PPCLPATTERN pPattern, ULONG bmpFormat)
{
    POEMPDEV    poempdev;
    BOOL bRet = FALSE;

    VERBOSE(("bSetForegroundColor(). \r\n"));

    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    if (pbo && (poempdev->bTextTransparencyMode == FALSE || poempdev->bTextAsBitmapMode == TRUE))
    {
        if ( BIsColorPrinter(pdevobj) )
        {
            bRet = bSetBrushColorForColorPrinters(pdevobj, pPattern, pbo, pptlBrushOrg);
        }
        else
        {
            bRet = bSetBrushColorForMonoPrinters(pdevobj, pPattern, pbo, pptlBrushOrg);
        }
    }
    else
    { 
        switch(bmpFormat)
        {
        case 1:
        case 4:
        case 8:
        case 16:
        case 24:
        case 32:
            bRet = bSetIndexedForegroundColor(pdevobj, pPattern, RGB_BLACK);
            break;

        default:
            WARNING(("Foreground color may not be correct\n"));
            // bRet = PCL_ForegroundColor(pdevobj, 0);
            //
            // Note: I didn't like being able to call PCL_ForegroundColor
            // directly from here.  Work through the bSetIndexedForegroundColor
            // function instead. JFF
            //
            bRet = bSetIndexedForegroundColor(pdevobj, pPattern, RGB_BLACK);
        }
    }

    return bRet;
}

///////////////////////////////////////////////////////////////////////////////
// CreatePCLBrush()
//
// Routine Description:
// 
// Download PCL halftone pattern for solid color.
// Assuming that text will have only solid color. Neither bitmap pattern nor
// hatch
//
// Arguments:
// ==========
//
// pDevObj    - default devobj
// pMarker    - Points to Marker
// pptlBrushOrg - an origin of brush
// pbo          - Points to BRUSHOBJ
//
// Return Value:
//   TRUE if successful, otherwise returns FALSE
///////////////////////////////////////////////////////////////////////////////
BOOL CreatePCLSolidColorBrush(
    IN  PDEVOBJ pDevObj,
    IN  PHPGLMARKER pMarker,
    IN  POINTL *pptlBrushOrg,
    IN  BRUSHOBJ *pbo,
    IN  FLONG flOptions)
{

    BOOL       bRetVal    = TRUE;
    DWORD      dwRGBColor = 0x00ffffff & BRUSHOBJ_ulGetBrushColor(pbo);

    VERBOSE(("CreatePCLSolidColorBrush Entry.\n"));
    REQUIRE_VALID_DATA (pMarker, return FALSE);

    // 
    // PCL has commands that can specify white or black fill.
    // Therefore, For Black or White color, lets not download a 
    // pattern but instead use those commands.
    // Note: Lets leave it to calling function to send those commands.
    //
    if (dwRGBColor == 0x00FFFFFF ||
        dwRGBColor == 0x00000000  )
    {
        pMarker->eType              = MARK_eSOLID_COLOR;
        pMarker->eFillMode          = FILL_eWINDING; // What about floptions ????
        pMarker->lPatternID = 0;
        pMarker->dwRGBColor = dwRGBColor;
    }
    else
    {
        bRetVal = CreateAndDwnldSolidBrushForMono( pDevObj, pMarker, pbo, ePCL, FALSE);
    }
    
    return bRetVal;
}


///////////////////////////////////////////////////////////////////////////////
// CreatePatternPCLBrush()
//
// Routine Description:
//
//   Creates a pattern HPGL brush and downloads the pattern data
//
// Arguments:
//
//   pDevObj - Points to our DEVDATA structure
//   pMarker - the HPGL marker object
//   pptlBrushOrg - the brush pattern origin
//   pBrushInfo - the pattern data
//   pHPGL2Brush - Cached pattern data
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CreatePatternPCLBrush(
    IN  PDEVOBJ         pDevObj,
    OUT PHPGLMARKER     pMarker,
    IN  POINTL         *pptlBrushOrg,
    IN  PBRUSHINFO      pBrushInfo,
    IN  HPGL2BRUSH     *pHPGL2Brush)
{
    if (!pBrushInfo || !pMarker)
    {
        WARNING(("CreatePatternPCLBrush: pBrushInfo or pMarker is NULL\n"));
        return FALSE;
    }


    if ( !BDwnldAndOrActivatePattern(
                            pDevObj,
                            pMarker,
                            pBrushInfo,
                            pHPGL2Brush,
                            ePCL) )
    {
        return FALSE;
    }
        


    pMarker->eFillType = FT_ePCL_BRUSH; // 22
    if (pptlBrushOrg)
    {
        pMarker->origin.x = pBrushInfo->origin.x = pptlBrushOrg->x;
        pMarker->origin.y = pBrushInfo->origin.y = pptlBrushOrg->y;
    }
    else
    {
        pMarker->origin.x = pBrushInfo->origin.x = 0;
        pMarker->origin.y = pBrushInfo->origin.y = 0;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// bSetBrushColorForMonoPrinters()
// NOTE : This routine is very similar to CreateHPGLPenBrush. 
//        CreateHPGLPenBrush dowloads data in HPGL while this does in PCL.
// Routine Description:
//  
// 
// 
// 
// 
//
//  
//
// Arguments:
// ==========
//
// pDevObj      - default devobj
// pPattern	    - pointer to palette enries
// pbo		    - The Brush that holds the required color. 
// pptlBrushOrg - 
//
// Return Value:
//   TRUE if successful, otherwise returns FALSE
///////////////////////////////////////////////////////////////////////////////

BOOL
bSetBrushColorForMonoPrinters(
    PDEVOBJ       pDevObj,
    PPCLPATTERN   pPattern,
    BRUSHOBJ     *pbo,
    POINTL       *pptlBrushOrg
)
{
    PBRUSHINFO    pBrushInfo;
    HPGLMARKER    Marker;
    POEMPDEV      poempdev;
    BOOL          bRetVal = TRUE;
    BRUSHOBJ      BrushObj;
    BRUSHOBJ     *pBrushObj = pbo;
    BYTE          bFlags    = 0;
    
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA(poempdev, return FALSE);


    if (pbo == NULL)
    {
        PCL_SelectCurrentPattern (pDevObj, pPattern, kSolidWhite, UNDEFINED_PATTERN_NUMBER, 0);
    //    PCL_sprintf(pDevObj, "\033*v1T");
        goto finish;
    }

    VERBOSE(("bSetBrushColorForMonoPrinters==pbo->iSolidColor = %ld \r\n",pbo->iSolidColor));

    //
    // The brush can be one of the following types.
    // 1 : Solid Color
    //        1a) White.
    //        1b) Black.
    //        1c) Some other.
    // 2. Non Solid Brush. 
    //      2a) Predefine hatch patterns.
    //      2b) Some other 
    //

    if ( pbo->iSolidColor == NOT_SOLID_COLOR )
    {
        poempdev->bStick = FALSE; //no need to make this pattern stick in the cache.
        pBrushInfo = (PBRUSHINFO) BRUSHOBJ_pvGetRbrush(pbo);

        if (pBrushInfo != NULL)
        {
            HPGL2BRUSH HPGL2Brush;

            if (S_OK == poempdev->pBrushCache->GetHPGL2BRUSH(pBrushInfo->dwPatternID, &HPGL2Brush))
            {
                switch(HPGL2Brush.BType)
                {
                case eBrushTypePattern:
                    //
                    // Case 2b.
                    //
                    CreatePatternPCLBrush(pDevObj, &Marker, pptlBrushOrg, pBrushInfo, &HPGL2Brush);
                    // PCL_sprintf(pDevObj, "\033*c%dG", Marker.lPatternID);
                    // PCL_sprintf(pDevObj, "\033*v4T");
                    PCL_SelectCurrentPattern (pDevObj, pPattern, kUserDefined, 
                                              Marker.lPatternID, 0);
                    break;

                case eBrushTypeHatch:
                    //
                    // Case 2a.
                    //
                    Marker.eType = MARK_eHATCH_FILL;
                    Marker.iHatch = HPGL2Brush.dwHatchType;
                    // PCL_sprintf(pDevObj, "\033*v3T");
                    // PCL_sprintf(pDevObj, "\033*c%dG", Marker.iHatch);
                    PCL_SelectCurrentPattern (pDevObj, pPattern, kHPHatch, 
                                              Marker.iHatch, 0);
                    break;

                default:
                    ERR(("bSetBrushColorForMonoPrinters: Unrecognized Brush Type\n"));
                    bRetVal = FALSE;
                }
            }
            else
            {
                ERR(("bSetBrushColorForMonoPrinters: Unrecognized Brush Type got from Brshcach\n"));
                bRetVal = FALSE;
            }
            goto finish;
        }
        else
        {
            WARNING(("bSetBrushColorForMonoPrinters() Unable to realize pattern brush.\n")); 

            //
            // For some reason pattern brush could not be realized. So we can
            // either fail or substitute that brush with Black Brush.
            // GDI recommends we fail...

            /////////////---Substituting with Black---//////
            // BrushObj.iSolidColor = RGB_BLACK;
            // pBrushObj = &BrushObj;
            ////////////////////////////////////////////////
            bRetVal = FALSE;
            goto finish;
        }

    }

    VERBOSE(("bSetBrushColorForMonoPrinters: not NOT_SOLID_COLOR case. iSolid = %d\n.", pBrushObj->iSolidColor));
            
//  BYTE bFlags = PF_NOCHANGE_SOURCE_TRANSPARENCY | PF_FORCE_PATTERN_TRANSPARENCY;
    bFlags = PF_NOCHANGE_SOURCE_TRANSPARENCY; 
    CreatePCLSolidColorBrush(pDevObj, &Marker, pptlBrushOrg, pBrushObj, 0);
        
    //
    // 
    //
    if (Marker.dwRGBColor == RGB_WHITE) //0xffffff
    {
        //
        // Case 1a.
        //
        PCL_SelectTransparency(pDevObj, eOPAQUE, eOPAQUE, bFlags);
        PCL_SelectCurrentPattern (pDevObj, pPattern, kSolidWhite, UNDEFINED_PATTERN_NUMBER, 0);
        //  PCL_sprintf(pDevObj, "\033*v1T");
        //  PCL_sprintf(pDevObj, "\033*v1o1T");
    }
    else if (Marker.dwRGBColor == RGB_BLACK) //0x0
    {
        //
        // Case 1b.
        //
        PCL_SelectTransparency(pDevObj, eTRANSPARENT, eTRANSPARENT, bFlags);
        PCL_SelectCurrentPattern (pDevObj, pPattern, kSolidBlackFg, UNDEFINED_PATTERN_NUMBER, 0);
        // PCL_sprintf(pDevObj, "\033*v0T");
        // PCL_sprintf(pDevObj, "\033*v0o0T");
    }
    else
    {
        //
        // Case 1c.
        //

        //
        // The Pattern Transparency eTRANSPARENT is not working for 
        // CG20_LET.doc. When the background is black, the pattern
        // printed on it is not visible. 
        //
        PCL_SelectTransparency(pDevObj, eOPAQUE, eOPAQUE, bFlags);
        // PCL_sprintf(pDevObj, "\033*c%dG", Marker.lPatternID);
        // PCL_sprintf(pDevObj, "\033*v4T");
        PCL_SelectCurrentPattern (pDevObj, pPattern, kUserDefined, 
                                  Marker.lPatternID, 0);

    }
  finish:
    VERBOSE(("bSetBrushColorForMonoPrinters: Exiting with BOOL value = %d\n.", bRetVal));
    return bRetVal;
}


///////////////////////////////////////////////////////////////////////////////
// PCL_ConfigureImageData()
//
// Routine Description:
// 
//	Routines takes color as input,
//  sets entry #0 of indexed palette with input color,
//  sets foreground to color in palette entry #0,
//  replaces overwritten entry with previous
//
// Arguments:
// ==========
//
// pdevobj    - default devobj
// pPattern	- pointer to palette enries
// uColor		- specifies foreground color
//
// Return Value:
// Not Required
///////////////////////////////////////////////////////////////////////////////

BOOL
bSetIndexedForegroundColor(PDEVOBJ pdevobj, PPCLPATTERN	pPattern, ULONG	uColor)
{
    POEMPDEV  poempdev;

    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    if (uColor == poempdev->uCurFgColor)
    {
        return TRUE;
    }

    if ((poempdev->bTextAsBitmapMode == TRUE) || 
        (pPattern->colorMappingEnum == HP_eDirectPixel))
    {
        //
        // I talked to Stefan K. and he suggested this way of setting
        // up the palette: 1) Create monochrome palette of [0]=WHITE, [1]=BLACK.
        // 2) Put your color into [1]. 3) Make [1] the FG color. 4) Change [1]
        // back to black.  This allows for the contrast needed to do white text.
        //

        //
        // Step 1
        //
        pPattern->palData.ulPalCol[0] = RGB_WHITE;
        pPattern->palData.ulPalCol[1] = RGB_BLACK;

        PCL_IndexedPalette(pdevobj, pPattern->palData.ulPalCol[0], 0);
        PCL_IndexedPalette(pdevobj, pPattern->palData.ulPalCol[1], 1);

        //
        // Step 2
        //
        pPattern->palData.ulPalCol[1] = uColor;
        PCL_IndexedPalette(pdevobj, pPattern->palData.ulPalCol[1], 1);

        //
        // Step 3
        //
        PCL_ForegroundColor(pdevobj, 1);

        //
        // Step 4
        //
        pPattern->palData.ulPalCol[1] = RGB_BLACK;
        PCL_IndexedPalette(pdevobj, pPattern->palData.ulPalCol[1], 1);

        //
        // Coda: mark palette items as clean since they've just been downloaded.
        //
        pPattern->palData.ulDirty[0] = FALSE;
        pPattern->palData.ulDirty[1] = FALSE;
    }
    else
    {
        //
        //overwrite palette entry #0 with current brush color 
        //
        VERBOSE(("bSetIndexedForegroundColor() \r\n"));
        VERBOSE(("Foreground Color = %ld \r\n",uColor));
        PCL_IndexedPalette(pdevobj,uColor,0);
        //
        //set foreground color based on entry #0
        //
        PCL_ForegroundColor(pdevobj,0);
        //
        //Replace overwritten palette entry
        //
        VERBOSE(("Replacing palette entry \r\n"));
        PCL_IndexedPalette(pdevobj,pPattern->palData.ulPalCol[0],0);
    }

    poempdev->uCurFgColor = uColor;

    return TRUE;
}




///////////////////////////////////////////////////////////////////////////////
// PCL_ConfigureImageData()
//
// Routine Description:
// 
//   Sets appropriated CID -- Configure Image Databased on printer Model 
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//	 bmpFormat - bits per pixel
// 
// Return Value:
// 
//   TRUE if successful, FALSE  otherwise
///////////////////////////////////////////////////////////////////////////////
#ifdef CONFIGURE_IMAGE_DATA
BOOL
bConfigureImageData(PDEVOBJ  pdevobj, ULONG  bmpFormat)
{
    POEMDEVMODE pOEMDM;
    BOOL        bRet = FALSE;
    POEMPDEV    poempdev;
    
    pOEMDM = (POEMDEVMODE)pdevobj->pOEMDM;
    VERBOSE(("bConfigureImageData.\r\n"));

    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    if ( BIsColorPrinter (pdevobj) ) 
    {
        switch (poempdev->PrinterModel)
        {
        case HPCLJ5:
            if (pOEMDM->Photos.ColorControl == SCRNMATCH)
            {
                bRet = PCL_HPCLJ5ScreenMatch(pdevobj, bmpFormat);
            }
            else
            {
                bRet = PCL_ShortFormCID(pdevobj, bmpFormat);
            }
        break;

        case HPC4500:
            bRet = PCL_ShortFormCID(pdevobj, bmpFormat);
            break;

        default:
            ERR(("PRINTER MODEL NOT SUPPORTED \r\n"));
            bRet = FALSE;
        }
    }

    return bRet;
}

#endif


BOOL
bSetBrushColorForColorPrinters(
    IN  PDEVOBJ         pDevObj,
    IN  PPCLPATTERN     pPattern,
    IN  BRUSHOBJ        *pbo,
    IN  POINTL          *pptlBrushOrg
)
{
    PBRUSHINFO  pBrushInfo;
    HPGLMARKER  Brush;
    POEMPDEV    poempdev;
    ECIDPalette eCIDPalette;
    BOOL        bRet = FALSE;

    REQUIRE_VALID_DATA ( (pDevObj && pbo), return FALSE);
    VERBOSE(("bSetBrushColorForColorPrinters==pbo->iSolidColor = %ld \r\n",pbo->iSolidColor));
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA (poempdev, return FALSE);


    eCIDPalette = poempdev->eCurCIDPalette;
    ZeroMemory(&Brush, sizeof(HPGLMARKER) );

    //
    // set foreground color based on BRUSHOBJ .. indexed palette
    // The foreground color must be sent before the palette because the
    // brush may have its own palette.
    //
    switch (pbo->iSolidColor)
    {
    case NOT_SOLID_COLOR:
        //
        // select raster pattern palette
        //
        VSelectCIDPaletteCommand (pDevObj, eRASTER_PATTERN_CID_PALETTE);

        //
        // send raster palette
        // NOTE: We are sending this as HPGL Brush. But a possible 
        // optmization could be that for large brushes, we send as PCL.
        //
        if ( CreateHPGLPenBrush(pDevObj, &Brush, pptlBrushOrg, pbo, 0, kBrush, FALSE) )
        {
            PCL_ForegroundColor(pDevObj, 4);
            bRet = TRUE;
        }
        else
        {
            bRet = FALSE;
        }

        //
        // reselect raster palette
        //
        VSelectCIDPaletteCommand (pDevObj, eCIDPalette);
        break;

    default:
        bRet = bSetIndexedForegroundColor(pDevObj, pPattern, pbo->iSolidColor);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\pcl.h ===
#ifndef _PCL_H
#define _PCL_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Header File Name:
//
//    pcl.h
//
// Abstract:
//
//
// Environment:
//
//    Windows NT Unidrv driver
//
//
///////////////////////////////////////////////////////////////////////////////

#include "glpdev.h"


#define  STRLEN 256

////
// New PCL Files
//

BOOL
PCL_Output(PDEVOBJ pdevobj, PVOID szCmdStr, ULONG iCmdLen);

int 
PCL_sprintf(PDEVOBJ pdev, char *szFormat, ...);

BOOL 
PCL_SetCAP(PDEVOBJ pdevobj, BRUSHOBJ *pbo, POINTL *pptlBrushOrg, POINTL *ptlDest);

BOOL
PCL_RasterYOffset(PDEVOBJ pdevobj, ULONG uScanlines);

BOOL  
PCL_HPCLJ5ScreenMatch(PDEVOBJ pdevobj, ULONG bmpFormat);


VOID
PCL_LongFormCID(PDEVOBJ pdevobj);

BOOL
PCL_ShortFormCID(PDEVOBJ pdevobj, ULONG bmpFormat);

BOOL
PCL_ForegroundColor(PDEVOBJ pdevobj, ULONG uIndex);

BOOL
PCL_IndexedPalette(PDEVOBJ pdevobj, ULONG uColor, ULONG uIndex);

BOOL
PCL_SourceWidthHeight(PDEVOBJ pdevobj, SIZEL *sizlSrc);

BOOL
PCL_DestWidthHeight(PDEVOBJ pdevobj, ULONG uDestX, ULONG uDestY);

BOOL
PCL_StartRaster(
    PDEVOBJ pDevObj,
    BYTE    ubMode
    );

BOOL
PCL_CompressionMode(PDEVOBJ pdevobj, ULONG compressionMode);


BOOL
PCL_SendBytesPerRow(PDEVOBJ pdevobj, ULONG uRow);

BOOL
PCL_EndRaster(PDEVOBJ pdevobj);

BOOL
PCL_SelectOrientation(
    PDEVOBJ  pDevObj,
    short    dmOrientation
    );

BOOL
PCL_SelectPaperSize(
    PDEVOBJ  pDevObj,
    short    dmPaperSize
    );

BOOL
PCL_SelectCopies(
    PDEVOBJ  pDevObj,
    short    dmCopies
    );

BOOL
PCL_SelectPictureFrame(
    PDEVOBJ  pDevObj,
    short    dmPaperSize,
    short    dmOrientation
    );

BOOL
PCL_SelectSource(
    PDEVOBJ  pDevObj,
    PDEVMODE pPublicDM
);

BOOL PCL_SelectCurrentPattern(
    IN PDEVOBJ             pDevObj,
    IN PPCLPATTERN         pPCLPattern,
    IN ECURRENTPATTERNTYPE eCurPatType,
    IN LONG                lPatternNumber, 
    IN BYTE                bFlags
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\names.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.

Module Name:

    names.h

Abstract:

    Contains the definitions for the hook function names and IDs.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#ifndef NAMES_H
#define NAMES_H

#ifdef __cplusplus
extern "C" {
#endif

////////////////////////////////////////////////////////////////////////////////
// OEM COM function interface

CONST CHAR pstrGetInfo[]                = "GetInfo";
CONST CHAR pstrDevMode[]                = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[]   = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[]           = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[]   = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[]        = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[]     = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[]         = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[]           = "PrinterEvent";
CONST CHAR pstrDriverEvent[]            = "DriverEvent";
CONST CHAR pstrQueryColorProfile[]      = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[]        = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[]   = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[]       = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[]        = "UpdateUISetting";
CONST CHAR pstrEnableDriver[]           = "EnableDriver";
CONST CHAR pstrDisableDriver[]          = "DiableDriver";
CONST CHAR pstrEnablePDEV[]             = "EnablePDEV";
CONST CHAR pstrDisablePDEV[]            = "DisablePDEV";
CONST CHAR pstrResetPDEV[]              = "ResetPDEV";
CONST CHAR pstrDrvGetDriverSetting[]    = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[]       = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[]              = "DriverDMS";
CONST CHAR pstrCommandCallback[]        = "CommandCallback";
CONST CHAR pstrImageProcessing[]        = "ImageProcessing";
CONST CHAR pstrFilterGraphics[]         = "FilterGraphics";
CONST CHAR pstrCompression[]            = "Compression";
CONST CHAR pstrHalftonePattern[]        = "HalftonePattern";
CONST CHAR pstrMemoryUsage[]            = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[]     = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[]      = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[]       = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[]          = "OutputCharStr";
CONST CHAR pstrSendFontCmd[]            = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[]        = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[]            = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[]             = "TTYGetInfo";

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\oemud.h ===
////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
//  FILE:       OEMUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//                              for OEMUD Test Module.
//
//  PLATFORMS:
//    Windows NT 5.0
//
//
////////////////////////////////////////////////////////
#ifndef _OEMUD_H
#define _OEMUD_H


#include "comnfile.h"

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;


////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC extern
#endif

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

EXTERNC VOID DbgPrint(PCSTR, ...);
#define DbgBreakPoint EngDebugBreak

#else

EXTERNC ULONG _cdecl DbgPrint(PCSTR, ...);
EXTERNC VOID DbgBreakPoint(VOID);

#endif // defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

#ifdef __cplusplus
#undef EXTERNC
#endif


#endif //  _OEMUD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\path.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1996-2002  Microsoft Corporation
// 
// Module Name:
// 
//   path.h
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows 2000/Windows XP/Windows Server 2003 Unidrv driver 
//
// Revision History:
// 
//   
///////////////////////////////////////////////////////////////////////////////

#ifndef PATH_H
#define PATH_H

#include "glpdev.h"

#define IsNULLMarker(pMarker) (((pMarker) == NULL) || ((pMarker)->eType == MARK_eNULL_PEN))
BOOL MarkPath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\penbrush.cpp ===
////////////////////////////////////////////////
// 
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
// 
//   penbrush.c
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   08/06/97 -v-jford-
//       Created it.
//
//   04/12/00
//       Modified for monochrome.
//
//   07/12/00
//       Pen and Brush handling functions were 90% same. So merged the two. 
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

///////////////////////////////////////////////////////////////////////////////
// Local Functions.

COLORREF GetPenColor(PDEVOBJ pDevObj, BRUSHOBJ *pbo);
EMarkerFill GetFillType(FLONG flOptions);

static BOOL CreatePatternHPGLPenBrush(
    IN  PDEVOBJ      pDevObj,
    OUT PHPGLMARKER  pMarker,
    IN  POINTL      *pptlBrushOrg,
    IN  PBRUSHINFO   pBrushInfo,
    IN  HPGL2BRUSH  *pHPGL2Brush,
    IN  ESTYLUSTYPE  eStylusType);


BOOL CreateHatchHPGLPenBrush(
    IN  PDEVOBJ       pDevObj,
    OUT PHPGLMARKER   pMarker,
    IN  BRUSHINFO    *pBrushInfo,
    IN  HPGL2BRUSH   *pHPGL2Brush);

BOOL BHandleSolidPenBrushCase (
        IN  PDEVOBJ       pDevObj,
        IN  PHPGLMARKER   pMarker,
        IN  BRUSHOBJ     *pbo,
        IN  ERenderLanguage eRenderLang,
        IN  BOOL            bStick);

BOOL
bCreateDitherPattern(
        OUT  PBYTE pDitherData,
        IN   size_t cBytes,
        IN   COLORREF color);


///////////////////////////////////////////////////////////////////////////////
// CreateNULLHPGLPenBrush()
//
// Routine Description:
// 
//   Creates a NULL pen.
// 
// Arguments:
// 
//   pDevObj - Points to our DEVDATA structure
//   pMarker - the HPGL marker object
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CreateNULLHPGLPenBrush(
    IN  PDEVOBJ      pDevObj,
    OUT PHPGLMARKER  pMarker)
{
    REQUIRE_VALID_DATA (pMarker, return FALSE);
    REQUIRE_VALID_DATA (pDevObj, return FALSE);
    
    pMarker->eType = MARK_eNULL_PEN;
    
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CreateSolidHPGLPenBrush()
//
// Routine Description:
// 
//   Creates a solid pen with the given color
// 
// Arguments:
// 
//   pDevObj - Points to our DEVDATA structure
//   pMarker - the HPGL marker object
//	 color - the desired color
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CreateSolidHPGLPenBrush(
    IN  PDEVOBJ      pDevObj,
    OUT PHPGLMARKER  pMarker,
    IN  COLORREF     color)
{
    BOOL       bRetVal = TRUE;
    PHPGLSTATE pState;

    REQUIRE_VALID_DATA (pMarker, return FALSE);
    REQUIRE_VALID_DATA (pDevObj, return FALSE);
    pState  = GETHPGLSTATE(pDevObj);
    
    pMarker->eType = MARK_eSOLID_COLOR;
    pMarker->dwRGBColor = color;

    //
    // For color printers, creating a color is as simple as creating a pen
    // of that certain color. But for monochrome, we have to create a
    // gray-shade pattern approximating the color.
    //
    if ( BIsColorPrinter(pDevObj ) )
    {
        pMarker->iPenNumber = HPGL_ChoosePenByColor(
                                                pDevObj,
                                                &pState->BrushPool,
                                                color);
        bRetVal = (pMarker->iPenNumber != HPGL_INVALID_PEN);
    }
    else
    {
        //
        // Set the pattern ID to zero, and have some other module deal with
        // actual creation and downloading of pattern.
        //
        pMarker->lPatternID = 0;
    }

    return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// CreatePatternHPGLPenBrush()
//
// Routine Description:
// 
//   Creates a pattern HPGL pen and downloads the given realized brush data
// 
// Arguments:
// 
//   pDevObj - Points to our DEVDATA structure
//   pMarker - the HPGL marker object
//	 pptlBrushOrg - The brush origin
//	 pBrushInfo - The realized brush data (i.e. the pattern data)
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CreatePatternHPGLPenBrush(
    IN  PDEVOBJ      pDevObj,
    OUT PHPGLMARKER  pMarker,
    IN  POINTL      *pptlBrushOrg,
    IN  PBRUSHINFO   pBrushInfo,
    IN  HPGL2BRUSH  *pHPGL2Brush,
    IN  ESTYLUSTYPE  eStylusType)
{
    BOOL bRetVal = FALSE;
    REQUIRE_VALID_DATA ( (pDevObj && pMarker && pBrushInfo && pHPGL2Brush), return FALSE);

    //
    // Initialize to some value, but the DownloadPattern*Fill
    // may change these values
    //
    if ( eStylusType == kPen)
    {
        pMarker->eFillType = FT_eHPGL_PEN; // 2
    }
    else if (eStylusType == kBrush)
    {
        pMarker->eFillType = FT_eHPGL_BRUSH; // 11
    }

    pMarker->eType = MARK_eRASTER_FILL;
    pMarker->lPatternID = pHPGL2Brush->dwPatternID;

    bRetVal = DownloadPatternFill(pDevObj, pMarker, pptlBrushOrg, pBrushInfo, eStylusType);

        
    if (!bRetVal)
    {
        WARNING(("CreatePatternHPGLPenBrush() Unable to download pattern pen.\n"));
        bRetVal = CreateNULLHPGLPenBrush(pDevObj, pMarker);
    }

    return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// BDwnldAndOrActivatePattern()
//
// Routine Description:
// 
//  Creates a pattern HPGL solid pen and downloads the given realized brush data
// 
// Arguments:
// 
//   pDevObj - Points to our DEVDATA structure
//   pMarker - the HPGL marker object
//   pptlBrushOrg - The brush origin
//   pBrushInfo - The realized brush data (i.e. the pattern data)
//              If NULL, it means brush does not have to be downloaded.
//   pHP2Brush - The cached brush data
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL
BDwnldAndOrActivatePattern(
        IN  PDEVOBJ       pDevObj,
        OUT PHPGLMARKER   pMarker,
        IN  BRUSHINFO    *pBrushInfo,
        IN  HPGL2BRUSH   *pHPGL2Brush,
        IN  ERenderLanguage eRenderLang )
{
    BOOL bRetVal         = TRUE;
    REQUIRE_VALID_DATA ( (pDevObj && pHPGL2Brush), return FALSE);

    //
    // Download pattern
    //
    if (pBrushInfo && pBrushInfo->bNeedToDownload)
    {
        if ( eRenderLang == ePCL)
        {
            bRetVal = DownloadPatternAsPCL(pDevObj, 
                                   &(pBrushInfo->Brush.pPattern->image), 
                                   &(pBrushInfo->Brush.pPattern->palette), 
                                   pBrushInfo->Brush.pPattern->ePatType, 
                                   pHPGL2Brush->dwPatternID);
        }
        else
        {
            bRetVal = DownloadPatternAsHPGL(pDevObj, 
                                   &(pBrushInfo->Brush.pPattern->image), 
                                   &(pBrushInfo->Brush.pPattern->palette), 
                                   pBrushInfo->Brush.pPattern->ePatType, 
                                   pHPGL2Brush->dwPatternID);
        }

        if ( !bRetVal )
           
        {
            ERR(("BDwnldAndOrActivatePattern: DownloadPatternAsHPGL/PCL failed.\n"));
        }

        pBrushInfo->bNeedToDownload = FALSE;
    }

    //
    // Set up marker.
    //

    if ( bRetVal && pMarker)
    {
        if ( pHPGL2Brush->BType == eBrushTypePattern )
        {
            pMarker->lPatternID = pHPGL2Brush->dwPatternID;
            pMarker->eType      = MARK_eRASTER_FILL;
            //NOTE: marked as RASTER_FILL even though eRenderLang may be eHPGL
        }
        else // if ( pHPGL2Brush->BType == <solid> )
        {
            pMarker->dwRGBColor = pHPGL2Brush->dwRGB;
            pMarker->lPatternID = pHPGL2Brush->dwPatternID;
            pMarker->eType      = MARK_eSOLID_COLOR;
        }
    }

    return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// CreatePercentFillHPGLPenBrush()
//
// Routine Description:
// 
//   Creates a percent-fill pen
// 
// Arguments:
// 
//   pDevObj - Points to our DEVDATA structure
//   pMarker - the HPGL marker object
//	 color - the desired color
//	 wPercent - the fill percentage
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CreatePercentFillHPGLPenBrush(
    IN  PDEVOBJ       pDevObj,
    OUT PHPGLMARKER   pMarker,
    IN  COLORREF      color,
    IN  WORD          wPercent)
{
    REQUIRE_VALID_DATA ( (pDevObj && pMarker), return FALSE);
    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);

    pMarker->eType    = MARK_ePERCENT_FILL;
    pMarker->iPercent = (ULONG)wPercent;

    //
    // For monochrome printers, the color to be filled in is always black.
    // But thats not true for color.
    //
    if (BIsColorPrinter(pDevObj) )
    {
        pMarker->iPenNumber = 
                    HPGL_ChoosePenByColor(pDevObj, &pState->PenPool, color);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CreateHatchHPGLPenBrush()
//
// Routine Description:
// 
//   Creates a Hatch HPGL pen
// 
// Arguments:
// 
//   pDevObj - Points to our DEVDATA structure
//   pMarker - the HPGL marker object
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CreateHatchHPGLPenBrush(
    IN  PDEVOBJ       pDevObj,
    OUT PHPGLMARKER   pMarker,
    IN  BRUSHINFO    *pBrushInfo,
    IN  HPGL2BRUSH   *pHPGL2Brush)
{
    BOOL       bRetVal = TRUE;
    PHPGLSTATE pState;

    REQUIRE_VALID_DATA( (pDevObj && pMarker && pBrushInfo && pHPGL2Brush), return FALSE);

    pState  = GETHPGLSTATE(pDevObj);
    REQUIRE_VALID_DATA(pState, return FALSE);

    pMarker->eType  = MARK_eHATCH_FILL;
    pMarker->iHatch = pBrushInfo->Brush.iHatch;

    //
    // Not all the values below need to be correct.
    // Some of them can be random. It depends on which
    // context the pMarker is being used.
    //
    pMarker->dwRGBColor = pHPGL2Brush->dwRGB;
    pMarker->lPatternID = pHPGL2Brush->dwPatternID;

    if ( BIsColorPrinter(pDevObj) )
    {
        pMarker->iPenNumber = HPGL_ChoosePenByColor(
                                               pDevObj,
                                               &pState->BrushPool,
                                               (pBrushInfo->Brush).dwRGBColor);
       bRetVal = (pMarker->iPenNumber != HPGL_INVALID_PEN);
    }
    else
    {
        //
        // If it is a monochrome printer, a b&w pattern that closely matches
        // the color of the hatch brush has been created in HPGLRealizeBrush and 
        // put in pBrushInfo. So lets download that pattern.
        // WHY IS THIS PART OF ELSE EMPTY ?
        //   How do I make a fill type choose a hatch brush and choose
        // a downloaded pattern. Unless I dont know how to do it, lets not
        // download this pattern. The Hatch pattern will be printed as dark black
        // lines, and that is a limitation that we will have to live with.
        // In general, if we do have to download the pattern we should call
        // HandleSolidColorForMono
        //
    }

    return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// CreateHPGLPenBrush()
//
// Routine Description:
// 
//   Creates an HPGL brush from the given brush object using the brush functions
//   above.
// 
// Arguments:
// 
//   pDevObj        - Points to our DEVDATA structure
//   pMarker        - the HPGL marker object
//	 pptlBrushOrg   - brush pattern origin
//	 pbo            - the GDI brush object
//   flOptions      - the fill options (winding or odd-even)
//   eStylusType    - can have 2 values kPen or kBrush.
//   bStick         - If TRUE, the entry for this pattern in the cache is marked 
//                    non-overwriteable.
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CreateHPGLPenBrush(
    IN  PDEVOBJ       pDevObj,
    IN  PHPGLMARKER   pMarker,
    IN  POINTL       *pptlBrushOrg,
    IN  BRUSHOBJ     *pbo,
    IN  FLONG         flOptions,
    IN  ESTYLUSTYPE   eStylusType, 
    IN  BOOL          bStick)
{
    BOOL bRetVal = TRUE;
    POEMPDEV    poempdev;
    
    ENTERING(SelectBrush);
    
    REQUIRE_VALID_DATA( (pDevObj && pMarker), return FALSE );
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );
    
    pMarker->eFillMode = GetFillType(flOptions);
    
    HPGL_LazyInit(pDevObj);
    
    if (pbo == NULL)
    {
        VERBOSE(("CreateHPGLBrush: create NULL HPGL Brush"));
        bRetVal = CreateNULLHPGLPenBrush(pDevObj, pMarker);
        goto finish;
    }

    if (pbo->iSolidColor == NOT_SOLID_COLOR)
    {
        VERBOSE(("CreateHPGLBrush: NOT_SOLID_COLOR case"));
        
        //
        // Ask GDI to give us the Brush. If the GDI has the brush in its cache
        // it gives it directly.
        // If the brush did not exist before, GDI will call DrvRealizeBrush.
        // DrvRealizeBrush will create the Brush and pass it to GDI. GDI will
        // cache that brush before giving it to us here. When next time we 
        // call GDI to get the same brush, it can straightaway give from 
        // cache, without needing to call DrvRealizeBrush.
        //
    
        //
        // for bStick expanation read the BrushCache::BSetStickyFlag 
        // explanation in brshcach.cpp
        // We need to set it here because HPGLRealizeBrush calls 
        // poempdev->pBrushCache->ReturnPatternID which needs this flag.
        // 
        poempdev->bStick      = bStick;
        PBRUSHINFO pBrushInfo = (PBRUSHINFO) BRUSHOBJ_pvGetRbrush(pbo);
        poempdev->bStick      = FALSE;

        //
        // BRUSHOBJ_pvGetRbrush() calls DrvRealizeBrush which can call
        // some plugin module, which can overwrite our pdevOEM.
        // #605370
        //
        BRevertToHPGLpdevOEM (pDevObj);

        
        //
        // If GDI gave us the brush, download it to printer.
        // If pBrushInfo is NULL, it means that for somereason we did not get the brush.
        // So instead of failing printing, we will use Black color i.e. Create a Black Brush.
        //
        if (pBrushInfo != NULL)
        {
            HPGL2BRUSH HPGL2Brush;
            if (S_OK == poempdev->pBrushCache->GetHPGL2BRUSH(pBrushInfo->dwPatternID, &HPGL2Brush))
            {
                if (HPGL2Brush.BType == eBrushTypePattern)
                {
                    bRetVal = CreatePatternHPGLPenBrush(pDevObj, 
                                                        pMarker, 
                                                        pptlBrushOrg, 
                                                        pBrushInfo, 
                                                        &HPGL2Brush,
                                                        eStylusType);
                }
                else if(HPGL2Brush.BType == eBrushTypeSolid)
                {
                    //
                    // This case should only happen for monochrome printers.
                    //
                    BRUSHOBJ BrushObj;
                    ZeroMemory(&BrushObj, sizeof(BRUSHOBJ) );
                    BrushObj.iSolidColor = (ULONG)HPGL2Brush.dwRGB;
                    bRetVal = BHandleSolidPenBrushCase (pDevObj, pMarker, &BrushObj, eHPGL, bStick);
                }
                else if (HPGL2Brush.BType == eBrushTypeHatch)
                {
                    bRetVal = CreateHatchHPGLPenBrush(pDevObj, pMarker, pBrushInfo, &HPGL2Brush);
                }
            }
            else
            {
                bRetVal = FALSE;
            }
        }
        else
        {
            WARNING(("CreateHPGLBrush() Unable to realize pattern brush.\n"));

            //
            // Now we have 2 options. Either we can 
            // 1) create a brush of predefined color (like black)  OR
            // 2) we can simply fail the call, and have the calling 
            //    function handle the failure. 
            // Earlier I had done 1, but that gave rise to 281315. So now I am
            // failing the call. But the code for 1 is commented out, in case
            // it has to be reinstated for any reason.
            // 

            ///////////////////////////////////////
            // BRUSHOBJ BrushObj;
            // ZeroMemory(&BrushObj, sizeof(BRUSHOBJ) );
            // BrushObj.iSolidColor = RGB_BLACK;
            // bRetVal = BHandleSolidPenBrushCase (pDevObj, pMarker, &BrushObj, eHPGL, bStick);
            /////////////////////////////////////

            bRetVal = FALSE;
        }
    } 
    else
    {
        VERBOSE(("CreateHPGLBrush: not NOT_SOLID_COLOR case. iSolid = %d\n.", pbo->iSolidColor));
        bRetVal = BHandleSolidPenBrushCase (pDevObj, pMarker, pbo, eHPGL, bStick);
    }
finish:
    EXITING(SelectBrush);
    
    return bRetVal;
}

BOOL BHandleSolidPenBrushCase ( 
        IN  PDEVOBJ       pDevObj,
        IN  PHPGLMARKER   pMarker, 
        IN  BRUSHOBJ     *pbo,
        IN  ERenderLanguage eRenderLang,
        IN  BOOL            bStick)
{
        
    BOOL bRetVal;
    if ( BIsColorPrinter(pDevObj) )
    {
        //
        // For Color Printers, choosing a solid color is very simple.
        // Just create a pen of that color (using PC command) and then 
        // select that pen (using SP command)
        //
        bRetVal = CreateSolidHPGLPenBrush(pDevObj, pMarker, GetPenColor(pDevObj, pbo));
    }
    else
    {
        bRetVal = CreateAndDwnldSolidBrushForMono ( pDevObj, pMarker, pbo, eRenderLang, bStick);
    }
    
    return bRetVal;
}


/*++
Routine Name:
     CreateAndDwnldSolidBrushForMono

Routine Description:
    Monochrome printers for which this driver is targetted at 
    cannot gray scale colors (i.e. if we tell the printer to print 
    yellow, it wont automatically know to convert that yellow to 
    appropriate shade of gray). Therefore the driver has to do that 
    conversion, and then send the pattern that approximates that 
    color to the printer.

Arguments: 
    pDevObj  :
    pMarker  :
    pbo      : pbo->iSolidColor is the color whose dither pattern has to 
               be created and downloaded.
    eRenderLang : Whether the patterns should be downloaded as 
                  a PCL patten or as HPGL Pattern.
    bStick  : If this isTRUE, then if the cache for this pattern is marked so that
              it is not overwritten.

Return Value:
    TRUE  : if succesful.
    FALSE : otherwise.

Last Error:

Explanation of Working:
--*/

BOOL CreateAndDwnldSolidBrushForMono(
        IN  PDEVOBJ       pDevObj,
        IN  PHPGLMARKER   pMarker,
        IN  BRUSHOBJ     *pbo,
        IN  ERenderLanguage eRenderLang,
        IN  BOOL            bStick)
{

    DWORD       dwPatternID = 0;
    DWORD       bRetVal     = TRUE;
    PBRUSHINFO  pBrush      = NULL;
    BRUSHTYPE   BType       = eBrushTypeNULL;
    LRESULT     LResult     = S_OK;
    HPGL2BRUSH  HPGL2Brush;
    POEMPDEV    poempdev;
    DWORD       dwRGBColor  = RGB_BLACK;
    BOOL        bDwnldPattern = TRUE;

    VERBOSE(("CreateAndDwnldSolidBrushForMono Entry.\n"));

    REQUIRE_VALID_DATA( (pDevObj && pMarker && pbo), return FALSE );
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    if ( pbo->iSolidColor == NOT_SOLID_COLOR )
    {
        WARNING (("CreateAndDwnldSolidBrushForMono: Solid Color not provided. Substituting with BLACK"));
    }
    else
    {
        dwRGBColor = pbo->iSolidColor;
    }



    //
    // For monochrome printers, things are little tough. Monochrome printers
    // cannot gray scale. So they need to be passed monochrome pattern that
    // looks like the gray scale of the color. e.g. if the color is yellow
    // the pattern will have black dots separated widely as compared to 
    // lets say blue (which is a darker color).
    //

    //
    // For sake of optimization, we dont want to create & download the pattern every
    // time a color has to be used. So we download once and give that pattern
    // an ID. (this information is stored in brushcache) and reuse that pattern
    // for that color.  The following function
    // looks in the brush cache and tries to get the id of the previously
    // downloaded pattern for color pbo->iSolidColor.
    // (The association color-patternID is maintained in brush cache)
    // If the pattern has been downloaded before,
    // S_OK is returned. dwPatternID holds the number of the pattern that was
    // downloaded.
    // If the pattern was not downloaded previously, then S_FALSE is returned. 
    // The pattern now has to be created and downloaded. dwPatternID holds 
    // the number that should be given to that pattern.
    //
    LResult = poempdev->pBrushCache->ReturnPatternID(
                                                     pbo,
                                                     HS_DDI_MAX,
	                                                 dwRGBColor,
		                                             NULL,
                                                     BIsColorPrinter(pDevObj),
                                                     bStick,
		                                             &dwPatternID,
                                                     &BType);

    //
    // Since this function is called for brushes with solid color,
    // so we do an extra check here that the BrushCache also thinks likewise
    // Also, the above funcion should return S_OK or S_FALSE. Any other
    // value is an error.
    // 

    if ( BType != eBrushTypeSolid )
    {
        ASSERT (BType != eBrushTypeSolid);
        bRetVal =  FALSE;
        goto finish;
    }
    if ( !((LResult == S_OK) || (LResult == S_FALSE) ) )
    {
        //
        // Case 3. (read below).
        //
        ERR(("BrushCach.ReturnPatternID failed.\n"));
        bRetVal =  FALSE;
        goto finish;

    }

    //
    // Lets determine if the pattern needs to be downloaded.
    // ReturnPatternID can return 
    // 1) S_FALSE: i.e. no pattern was downloaded for this color. So we will
    //       have to create and download a pattern now.
    // 2) S_OK : A pattern whose number is dwPatternID has already been downloaded.
    //      There are 4 cases. EP = Earlier Pattern NP = New Pattern.
    //              i.   EP = PCL    NP = PCL  -> No download req'd
    //              ii.  EP = PCL    NP = HPGL -> No download req'd
    //              iii. EP = HPGL   NP = PCL  -> download req'd
    //              iv.  EP = HPGL   NP = HPGL -> No download req'd
    //
    //      2a) The pattern was downloaded as PCL.
    //          Action : No need to download pattern. Use the existing one.
    //          Both HPGL and PCL can use a PCL pattern. (i, ii)
    //      2b) The pattern was downloaded as HPGL pattern. PCL cannot use 
    //          HPGL pattern.  
    //          Action : iv) if eRenderLang == HPGL and pattern also downloaded as 
    //                      HPGL then simply re-use the HPGL pattern. No need to dwnld.
    //                  iii) else, download as PCL.
    //      2c) Indeterminate : Dont know whether pattern was downloaded
    //          as PCL or HPGL. 
    //          Action : Downloaded the pattern as PCL.
    // 3) Something other than S_FALSE, S_OK: Irrecoverable error. Quit.
    //


    if (S_OK != poempdev->pBrushCache->GetHPGL2BRUSH(dwPatternID, &HPGL2Brush))
    {
        bRetVal = FALSE;
        goto finish;
    }

    if ( S_FALSE == LResult) 
    {
        // 
        // Case 1
        // bDwnldPattern = TRUE --- Already initialized.
        //
    }
    else if ( S_OK == LResult) 
    {
        //
        // Case 2.
        //
        if (HPGL2Brush.eDwnldType == ePCL ||
            HPGL2Brush.eDwnldType == eRenderLang)
        {
            //
            // Case 2 i, ii, iv
            //
            bDwnldPattern = FALSE;
        }
        // else bDwnldPattern = TRUE --- Already initialized.
    }

    if (bDwnldPattern)
    {
        //
        // Allocate memory to hold the pattern that has to be created.
        //
        LONG lTotalBrushSize;
        lTotalBrushSize = sizeof(BRUSHINFO) +
                          sizeof(PATTERN_DATA) +
	                      ((DITHERPATTERNSIZE * DITHERPATTERNSIZE) >> 3);

        if (NULL == (pBrush = (PBRUSHINFO)MemAllocZ(lTotalBrushSize)))
        {
            ERR(("MemAlloc failed.\n"));
            bRetVal = FALSE;
        }
        else
        {
            //
            // Puts the pattern in pBrush. The pattern is the raster
            // equivalent of the pbo->iSolidColor 
            // = BRUSHOBJ_ulGetBrushColor(pbo) = dwRGBColor
            // NOTE: This does not download the pattern. It just puts it in
            // pBrush. 
            //
            if (BSetupBRUSHINFOForSolidBrush(pDevObj, 
                                              HS_DDI_MAX, 
                                              dwPatternID, 
                                              dwRGBColor,
                                              pBrush, 
                                              lTotalBrushSize))
            {
                pBrush->bNeedToDownload = TRUE;
            }
            else 
            {
                ERR(("BSetupBRUSHINFOForSolidBrush failed.\n"));
                bRetVal =  FALSE;
            }
        }
    }

    //
    // Pattern has been created above (if bDwnldPattern was TRUE).
    // So now we have to download the pattern and make it active.
    // If  bDwnldPattern was FALSE, then we just have to make
    // the previousoly downloaded pattern active.
    //
    if ( bRetVal )
    {  
        //
        // a) if (pBrush && pBrush->bNeedToDownload == TRUE) downlaod 
        //    the pattern that is in pBrush. Give it the pattern ID in HPGL2Brush.
        // b) update the pMarker structure with the pattern number, type etc..
        //    If pattern already downloaded, a wont be done.
        //
        bRetVal = BDwnldAndOrActivatePattern(pDevObj, pMarker, pBrush, &HPGL2Brush, eRenderLang);
        if ( !bRetVal )
        {
            ERR(("BDwnldAndOrActivatePattern has failed\n"));
            goto finish;
        }
        //
        // Pattern download/Activation has succeeded.
        //
        if ( bDwnldPattern )
        {
            poempdev->pBrushCache->BSetDownloadType(dwPatternID, eRenderLang);
            poempdev->pBrushCache->BSetDownloadedFlag(dwPatternID, TRUE);
            pMarker->eDwnldType = eRenderLang;
            pMarker->eFillType  = (eRenderLang == ePCL? FT_ePCL_BRUSH : FT_eHPGL_BRUSH);
        }
        else 
        {
            //
            // Pattern was not required to be downloaded since it was 
            // downloaded earlier. So now we have 4 cases.
            // EP = Earlier Pattern NP = New Pattern.
            // 1. EP = PCL    NP = PCL
            // 2. EP = PCL    NP = HPGL
            // 3. EP = HPGL   NP = PCL 
            // 4. EP = HPGL   NP = HPGL
            //
            // for 1,4 there is no problem, old pattern is same as new
            // for 2, it is ok, since HPGL can use PCL pattern.
            // for 3, this should have been handled earlier 
            // (i.e. the bDwnldPattern should have been true).
            //
            if ( eRenderLang == eHPGL &&  HPGL2Brush.eDwnldType == eHPGL)
            {
                pMarker->eDwnldType = eHPGL;
                pMarker->eFillType = FT_eHPGL_BRUSH;
            }
            else
            {
                pMarker->eDwnldType = ePCL;
                pMarker->eFillType = FT_ePCL_BRUSH;
            }
        }

    } // if (bRetVal)

finish:
    if (pBrush)
    {
        MemFree(pBrush);
        pBrush = NULL;
    }

    VERBOSE(("CreateAndDwnldSolidBrushForMono Exit with BOOL value %d.\n", ((DWORD)bRetVal)));
    return bRetVal;
} 
    

/////////////////////////////////////////////////////////////////////////////
// BSetupBRUSHINFOForSolidBrush
//
// Routine Description:
//   Set up BRUSHINFO data structure for monochrome solid brush.
//
// Arguments:
//
//   pdevobj -  points to DEVOBJ
//   iHatch - iHatch, parameter os DrvRealizeBrush
//   dwPatternID - pattern ID
//   dwColor -  RGB color
//   pBrush -  points to BRUSHINFO data structure
//   lBrushSize -  size of BRUSHINFO + alpha
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL
BSetupBRUSHINFOForSolidBrush(
    IN  PDEVOBJ     pdevobj,
    IN  LONG        iHatch,
    IN  DWORD       dwPatternID,
    IN  DWORD       dwColor,
    IN  PBRUSHINFO  pBrush,
    IN  LONG        lBrushSize)

{

    //
    // Parameter check
    // dwPatterID starts from 1. If dwPattern were zero, there was an error
    // somewhere.
    // Assuming that lBrushsize has at least 8 x 8 pattern bitmap buffer.
    //
    if (NULL == pBrush   ||
        dwPatternID == 0 ||
        lBrushSize < sizeof(BRUSHINFO) +
                     sizeof(PATTERN_DATA) + 
                     ((DITHERPATTERNSIZE * DITHERPATTERNSIZE) >> 3))
    {
        ERR(("BSetupBRUSHINFOForSolidBrush: invalid parameter.\n"));
        return FALSE;
    }

    //
    // Fill BRUSHINFO
    //
    pBrush->Brush.dwRGBColor = dwColor;

    pBrush->Brush.pPattern               = (PPATTERN_DATA)((PBYTE)pBrush + sizeof(BRUSHINFO));
    pBrush->Brush.pPattern->iPatIndex    = iHatch;
    pBrush->Brush.pPattern->eRendLang    = eUNKNOWN; // dont force downloading as HPGL/PCL
    pBrush->Brush.pPattern->ePatType     = kCOLORDITHERPATTERN; // this pattern represents color
    pBrush->Brush.pPattern->image.cBytes = (DITHERPATTERNSIZE * DITHERPATTERNSIZE) >> 3;
    pBrush->Brush.pPattern->image.lDelta = DITHERPATTERNSIZE >> 3;
    pBrush->Brush.pPattern->image.colorDepth = 1;
    pBrush->Brush.pPattern->image.eColorMap  = HP_eDirectPixel;
    pBrush->Brush.pPattern->image.bExclusive = FALSE;
    pBrush->Brush.pPattern->image.size.cx    = DITHERPATTERNSIZE;
    pBrush->Brush.pPattern->image.size.cy    = DITHERPATTERNSIZE;
    pBrush->Brush.pPattern->image.bExclusive = FALSE;
    pBrush->Brush.pPattern->image.pScan0     =
    pBrush->Brush.pPattern->image.pBits = (PBYTE)pBrush + sizeof(BRUSHINFO) + sizeof(PATTERN_DATA);

    //
    // Create solid dither image for monochrome printers.
    //
    if (!bCreateDitherPattern((PBYTE)pBrush->Brush.pPattern->image.pScan0,
                               pBrush->Brush.pPattern->image.cBytes,
                               dwColor))
    {
        ERR(("bCreateDitherPattern failed.\n"));
        return FALSE;
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// FillWithBrush()
//
// Routine Description:
// 
//   Selects the brush (i.e. the marker object) into the current surface
//   to be the current brush for filling solid shapes.
// 
// Arguments:
// 
//   pDevObj - Points to our DEVDATA structure
//   pMarker - the HPGL marker object
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL FillWithBrush(
    IN  PDEVOBJ pDevObj,
    IN  PHPGLMARKER pMarker)
{
    if (pMarker == NULL)
        return FALSE;
    
    switch(pMarker->eType)
    {
    case MARK_eNULL_PEN:
        HPGL_ResetFillType(pDevObj, NORMAL_UPDATE);
        break;
        
    case MARK_eSOLID_COLOR:
        //
        // Different treatment for color and monochrome printers.
        // For color, simply choose the correct pen number (the pen
        // created in CreateSolidHPGLBrush). 
        //
        if ( BIsColorPrinter (pDevObj) )
        {
            HPGL_ResetFillType(pDevObj, NORMAL_UPDATE);
            HPGL_SelectPen(pDevObj, (USHORT)pMarker->iPenNumber);
        }
        else
        {
            //
            // Three options. Color is Black, Color is White OR
            // Color is something other than the above two.
            // 
            if (pMarker->lPatternID == 0)
            {
                if (pMarker->dwRGBColor == RGB_BLACK)
                {
                    //
                    // Solid black color
                    // Select Black Pen : Send SP1
                    // Reset Fill Type to Solid Fill : FT1
                    //
                    HPGL_FormatCommand(pDevObj, "SP1");
                    HPGL_SetSolidFillType(pDevObj, NORMAL_UPDATE);
                }
                else if (pMarker->dwRGBColor == RGB_WHITE)
                {
                    //
                    // Solid white color
                    // SelectWhite Pen : Send SP0.
                    // Reset Fill Type to Solid Fill : FT1
                    //
                    HPGL_FormatCommand(pDevObj, "SP0");
                    HPGL_SetSolidFillType(pDevObj, NORMAL_UPDATE);
                }
            }
            else
            //
            // Solid pattern indicating the color to be used is something other
            // than black or white. So a pattern was created corresponding to that
            // color. 
            //
            {
                HPGL_SetFillType (pDevObj, 
                                 pMarker->eFillType, // Was FT_eHPGL_BRUSH, 
                                 pMarker->lPatternID, 
                                 NORMAL_UPDATE);
            }
        } //if monochrome printer.
        break;
        
    case MARK_eRASTER_FILL:
        //
        // Raster pattern fill
        //
        HPGL_FormatCommand(pDevObj, "AC%d,%d;", pMarker->origin.x, 
                                                pMarker->origin.y);
        HPGL_SetFillType(pDevObj, 
                        pMarker->eFillType, 
                        pMarker->lPatternID, 
                        NORMAL_UPDATE);
        break;

    case MARK_ePERCENT_FILL:
        //
        // Percent shading fill
        //
        HPGL_SetPercentFill(pDevObj, pMarker->iPercent, NORMAL_UPDATE);

        if ( BIsColorPrinter (pDevObj) )
        {
            HPGL_SelectPen(pDevObj, (USHORT)pMarker->iPenNumber);            
        }
        else
        {
            // Dont we have to select a pen here, or is it by default Black.
            // CHECK.......
        }
        break;
        
    case MARK_eHATCH_FILL:
        //
        // Hatch pattern fill
        //
        HPGL_SetFillType(pDevObj,
                         FT_eHATCH_FILL,
                         pMarker->iHatch+1,
                         NORMAL_UPDATE);

        //
        // For monochrome printers, lets ignore the color of hatch brush for now.
        //
        if ( BIsColorPrinter (pDevObj) )
        {
            HPGL_SelectPen(pDevObj, (USHORT)pMarker->iPenNumber);
        }
        break;

    default:
        break;
    }
    
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// PolyFillWithBrush()
//
// Routine Description:
// 
//   This is a special case of fill-with-brush when we are completing a polygon
//   and need select the brush and invoke the fill polygon command.
// 
// Arguments:
// 
//   pDevObj - Points to our DEVDATA structure
//   pMarker - the HPGL marker object
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL PolyFillWithBrush(PDEVOBJ pDevObj, PHPGLMARKER pMarker)
{
    if (pMarker == NULL)
        return FALSE;
    
    if (FillWithBrush(pDevObj, pMarker))
    {
        switch(pMarker->eType)
        {
        case MARK_eNULL_PEN:
            break;
            
        case MARK_eSOLID_COLOR:
        case MARK_eRASTER_FILL:
        case MARK_ePERCENT_FILL:
        case MARK_eHATCH_FILL:
            HPGL_FormatCommand(pDevObj, "FP%d;", pMarker->eFillMode);
            break;
            
        default:
            break;
        }
    }
    else
    {
        return FALSE;
    }
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// DrawWithPen()
//
// Routine Description:
// 
//   Selects the current pen into the drawing surface
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   pMarker - the HPGL marker object 
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL DrawWithPen(
    IN  PDEVOBJ pDevObj,
    IN  PHPGLMARKER pMarker)
{
    if (pMarker == NULL)
        return FALSE;
    
    switch (pMarker->eType)
    {
    case MARK_eSOLID_COLOR:
        if ( BIsColorPrinter(pDevObj) )
        {
            HPGL_ResetFillType(pDevObj, NORMAL_UPDATE);
            HPGL_SelectPen(pDevObj, (USHORT)pMarker->iPenNumber);
        }
        else
        {
            if (pMarker->lPatternID == 0)
            {
                if (pMarker->dwRGBColor == RGB_BLACK)
                {
                    //
                    // Solid black color
                    //
                    HPGL_FormatCommand(pDevObj, "SV1,100");
                }
                else if (pMarker->dwRGBColor == RGB_WHITE)
                {
                    //
                    // Solid white color
                    //
                HPGL_FormatCommand(pDevObj, "SV1,0");
                }
            }
            else
            {
                //
                // Solid color is downloaded as pattern for monochrome printers.
                //
                HPGL_ResetFillType(pDevObj, NORMAL_UPDATE);
                if ( pMarker->eDwnldType == eHPGL)
                {
                    HPGL_FormatCommand(pDevObj, "SV%d,%d", FT_eHPGL_PEN, pMarker->lPatternID);
                }
                else if ( pMarker->eDwnldType == ePCL)
                {
                    HPGL_FormatCommand(pDevObj, "SV%d,%d", FT_ePCL_BRUSH, pMarker->lPatternID);
                }
            }
        }
        break;
        
    case MARK_eRASTER_FILL:
        //
        // Raster pattern fill
        //
        HPGL_FormatCommand(pDevObj, "AC%d,%d;", pMarker->origin.x,
                                                pMarker->origin.y);
        HPGL_FormatCommand(pDevObj, "SV%d,%d;", pMarker->eFillType,
                                                pMarker->lPatternID);
        break;
        
    case MARK_eNULL_PEN:
        HPGL_ResetFillType(pDevObj, NORMAL_UPDATE);
        break;

    case MARK_ePERCENT_FILL:
        if ( BIsColorPrinter(pDevObj) )
        {
            HPGL_SetFillType(pDevObj,
                         FT_ePERCENT_FILL, // pMarker->eFillType
                         pMarker->iPercent,
                         NORMAL_UPDATE);
            HPGL_SelectPen(pDevObj, (USHORT)pMarker->iPenNumber);
        }
        else
        {
            HPGL_FormatCommand(pDevObj, "SV1,%d;", pMarker->iPercent);
        }
        break;
        
    case MARK_eHATCH_FILL:
        //
        // HPGL2 hatch pattern starts from 1.
        // Windows iHatch starts from 0.
        //
        HPGL_FormatCommand(pDevObj, "SV21,%d", pMarker->iHatch + 1);

        //
        // For now, lets consider color of hatch brush only for color printers.
        // For mono, the brush will print as solid black.
        //
        if ( BIsColorPrinter (pDevObj) )
        {
            HPGL_SelectPen(pDevObj, (USHORT)pMarker->iPenNumber);
        }
        break;

    default:
        WARNING(("DrawWithPen: Unknown eType.\n"));
        break;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// EdgeWithPen()
//
// Routine Description:
// 
//   This special case of draw-with-pen where the specific polygon edge commands
//   need to be sent.
//
// Arguments:
// 
//   pDevObj - Points to our PDEVOBJ structure
//   pMarker - the HPGL marker object 
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL EdgeWithPen(
    IN  PDEVOBJ pDevObj,
    IN  PHPGLMARKER pMarker)
{
    if (pMarker == NULL)
        return FALSE;
    
    if (!DrawWithPen(pDevObj, pMarker))
    {
        return FALSE;
    }

    switch (pMarker->eType)
    {
    case MARK_eSOLID_COLOR:
    case MARK_ePERCENT_FILL:
    case MARK_eHATCH_FILL:
        HPGL_FormatCommand(pDevObj, "EP;");
        break;

    case MARK_eRASTER_FILL:
    case MARK_eNULL_PEN:
        break;

    default:
        break;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// GetFillType()
//
// Routine Description:
//
//   Specify whether to use zero-winding or odd-even rule for filling
//
// Arguments:
//
//   lOptions - FP_WINDINGMODE or FP_ALTERNATEMODE
//
// Return Value:
//
//   FILL_eWINDING if flOptions&FP_WINDINGMODE, else FILL_eODD_EVEN
///////////////////////////////////////////////////////////////////////////////
EMarkerFill GetFillType(
    IN FLONG flOptions)
{
    return (flOptions & FP_WINDINGMODE ? FILL_eWINDING : FILL_eODD_EVEN);
}

///////////////////////////////////////////////////////////////////////////////
// GetPenColor()
//
// Routine Description:
// 
//   Returns the pen color for the given pen.
//
//   Note that the XL driver defined its own palette entry structure
//   and the colors were reversed (BGR) in the definition.
//
//   We are only supporting PAL_RGB and PAL_BGR palette types.  If the type is
//   PAL_INDEXED or PAL_BITFIELD then black is returned.
// 
// Arguments:
// 
//   pDevObj - Points to our DEVDATA structure
//   pbo - Brush object
// 
// Return Value:
// 
//   Pen color as a COLORREF.
///////////////////////////////////////////////////////////////////////////////
static COLORREF GetPenColor(PDEVOBJ pDevObj, BRUSHOBJ *pbo)
{
    POEMPDEV poempdev;
    PPALETTEENTRY pPalEntry;
    COLORREF penColor;

    poempdev = GETOEMPDEV(pDevObj);

    switch (poempdev->iPalType)
    {
    case PAL_RGB:
        pPalEntry = (PPALETTEENTRY) &pbo->iSolidColor;
        penColor = RGB(pPalEntry->peRed, pPalEntry->peGreen, pPalEntry->peBlue);
        break;

    case PAL_BGR:
        pPalEntry = (PPALETTEENTRY) &pbo->iSolidColor;
        penColor = RGB(pPalEntry->peBlue, pPalEntry->peGreen, pPalEntry->peRed);
        break;

    case PAL_INDEXED:
        // Not supported?
        // pPalEntry = (PPALETTEENTRY) myPalette[pbo->iSolidColor];
        // penColor = RGB(pPalEntry->peRed, pPalEntry->peGreen, pPalEntry->peBlue);
        penColor = RGB_BLACK;
        break;

    case PAL_BITFIELDS:
        // Not supported.
        penColor = RGB_BLACK;
        break;
    }

    return penColor;
}



BYTE RgbToGray64Scale ( 
        IN   COLORREF color)
{
    WORD Red    = WORD ( color & 0x000000ff);
    WORD Green  = WORD ( (color & 0x0000ff00) >> 8 );
    WORD Blue   = WORD ( (color & 0x00ff0000) >> 16 );

    //
    // 30+59+11 = 100. Therefore the max value of r*30 + g*59 + b*11 = 255 * 100
    // (255 is max value of byte).
    // Dividing 255 by 4 gives us a value between 0 * 63
    // The higher the number, the lighter the color.
    // But we want the other way, i.e. higher the number, darker the 
    // color. So we subtract from 63.
    //

    BYTE RGBGrayVal = BYTE(( Red*30 + Green*59 + Blue*11)/100 );
    RGBGrayVal = RGBGrayVal >> 2;

    //
    // If for some reason, RGBGrayVal becomes greater than
    // 63, we set its value to a shade somewhere between black and white.
    //
    if ( RGBGrayVal > 63 )
    {
        ASSERT( RGBGrayVal <= 63);
        RGBGrayVal = 32;
    }
    return BYTE( (BYTE)63 - RGBGrayVal);
}


//
// The following table represents a 8pixel*8pixel square. Each
// entry in the table specified whether that pixel should be
// turned on or off. The grayscale value ranges from 0-63.
// with 63 being black and 0 being white. A grayscale value
// of 10 means, the pixels whose value is less than 10 will
// be turned on. 
// Note: Looking below, it looks a bit wierd to have a macro
// defined as S(x) = x-1. But there may be cases where we want to
// have a different formula.  
// e.g. because the pixel is thicker on paper, we may
// want to reduce the number of active pixels for certain shades
// of gray. To do such change, it is best to have a formula.
// That way we'll need to change just the formula, instead of
// changing each entry in the table.
//
 
#define S(x)    (BYTE)((x)-1)

BYTE gCoarse8x8[64] = {
    S(27),  S(23),  S(25),  S(31),  S(38),  S(42),  S(40),  S(34),
    S(9),   S(7),   S(5),   S(19),  S(56),  S(58),  S(60),  S(46),
    S(11),  S(1)+1, S(3),   S(21),  S(54),  S(64),  S(62),  S(44),
    S(17),  S(13),  S(15),  S(29),  S(48),  S(52),  S(50),  S(36),
    S(37),  S(41),  S(39),  S(33),  S(28),  S(24),  S(26),  S(32),
    S(55),  S(57),  S(59),  S(45),  S(10),  S(8),   S(6),   S(20),
    S(53),  S(63),  S(61),  S(43),  S(12),  S(2),   S(4),   S(22),
    S(47),  S(51),  S(49),  S(35),  S(18),  S(14),  S(16),  S(30)
};


/*++
Routine Name: bCreateDitherPattern

Routine Description:
    Some monochrome HPGL printers, dont accept color data at all.
    This function creates a gray-scale pattern equivalent to the color.
    e.g. For darker color, the pattern will indicate that black dots
    have to be placed more closely together.

Arguments:
    pDitherData: A block of memory that will be populated with 
                 dither data.
    cBytes     : Size of the pDitherData memory block.
           NOTE: In first incarnation, cBytes has to be 8. 
                 This means that the dither data expected to
                 be returned from this function is in a 8*8 pixel block.
                 1 bit/pixel mode i.e. 64bits = 8 bytes.
    color      : Color for which the dither pattern is required.

Return Value:
    TRUE: If pattern was created and pDitherData populated.
    FALSE: Otherwise.

Last Error:
    Not changed.

--*/

BOOL 
bCreateDitherPattern(
        OUT  PBYTE pDitherData, 
        IN   size_t cBytes, 
        IN   COLORREF color)
{

    BOOL bReturnValue = TRUE;

    //
    // Check whether parameters are as expected.
    // pDitherData has to be valid.
    //
    // NOTE: might want to check here if cBytes is 8
    if (pDitherData == NULL )
    {
        return FALSE;
    }


    /* Somehow this macro is not working. So I haver replaced it with
       an inline function.
    BYTE bGrayPercentage64 = (RgbToGray64Scale(RED_VALUE(color), GREEN_VALUE(color),
                                      BLUE_VALUE(color) ) );
    */

    BYTE bGrayPercentage64 = RgbToGray64Scale(color);

    //
    // Assumption : for monochrome HP-GL/2 printers, 0 is white, 1 is black. 
    // If there's a case where this is not true, this algo will have to be changed.
    //

    //
    // Initialize the pattern to all zeros. This means white
    //
    ZeroMemory(pDitherData, cBytes);

    //
    // As of now, let this method work for 8*8 pixel block only. Will see later
    // whether it needs to be extended for 16*16 pixel block.
    //
    if (cBytes == 8)
    {

        for (INT y = 0; y < 8; y++)
        {
            for (INT x = 0; x < 8; x++)
            {
                if ( bGrayPercentage64 >= gCoarse8x8[8*y + x] )
                {
                    *(pDitherData + y) |= (0x1 << (7-x));
                }
            }

        }
    } //if (cBytes == 8)
    else 
    {
        bReturnValue = FALSE;
    }
    return bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\path.cpp ===
///////////////////////////////////////////////////////////////////////////////
// 
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
// 
//   path.cpp
// 
// Abstract:
// 
//   This module implements path enumeration for polylines, polygons and 
//   bezier curves as expressed by the PATHOBJ.
//
//   TODO: Add error reporting to the iterator path functions by setting the
//         pIt->bError member.
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   07/02/97 -v-jford-
//       Created it.
// $History: path.cpp $
// 
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

///////////////////////////////////////////////////////////////////////////////
// Local Macros.

#define PT_EQUAL(pt1, pt2) (((pt1).x == (pt2).x) && ((pt1).y == (pt2).y))

///////////////////////////////////////////////////////////////////////////////
// Local structures & classes.

///////////////////////////////////////////////////////////////////////////////
// CPathIterator
//
// Class Description:
// 
//   This is a virtual base class for the various kinds of path iterator 
//   (currently: simple and caching).  In a more interesting world the CPath
//   object would dynamically create an iterator based on some strategy.
//   However, for now we are going to decide this at compile time.
//
///////////////////////////////////////////////////////////////////////////////
class CPathIterator
{
public:
    CPathIterator() { }
    virtual VOID vEnumStart() = 0;
    virtual BOOL bEnum(PATHDATA *pPathData) = 0;
};

///////////////////////////////////////////////////////////////////////////////
// CSimplePathIterator
//
// Class Description:
// 
//   This class is a simple pass-through to the PATHOBJ enumeration functions.
//   It is useful because it shares an iterface with the CCachingPathIterator
//   and allows simple substitution of the iteration strategy.  (For example, 
//   if a defect were found in the caching version--or it were no longer needed
//   you could change back to simple with one line of code.)
//
///////////////////////////////////////////////////////////////////////////////
class CSimplePathIterator : public CPathIterator
{
    PATHOBJ    *m_ppo;

public:
    CSimplePathIterator() : m_ppo(NULL) { }
    VOID Init(PATHOBJ *ppo) { m_ppo = ppo; }
    VOID vEnumStart() { if (m_ppo) PATHOBJ_vEnumStart(m_ppo); }
    BOOL bEnum(PATHDATA *pPathData) { return (m_ppo ? PATHOBJ_bEnum(m_ppo, pPathData) : FALSE); }
    VOID Done() { }
};

///////////////////////////////////////////////////////////////////////////////
// CPathCache
//
// Class Description:
// 
//   This class caches an arbitrary set of paths by building a linked list of
//   PATHDATA structures.  The cache knows whether or not caching is being used
//   and can be instructed to cache the path at will.  This allows the iterator
//   who owns it to decide exactly when to start caching, but not worry about
//   cleaning up.
//
///////////////////////////////////////////////////////////////////////////////
class CPathCache
{
    struct CSubPath
    {
        PATHDATA  data;
        CSubPath *pNext;
    };
    CSubPath *m_pSubPaths;
    CSubPath *m_pCurrent;
    BOOL      m_bIsCached;

public:
    CPathCache();
    VOID Init();
    VOID Done();

    BOOL CreateCache(PATHOBJ *ppo);
    BOOL DeleteCache();

    VOID vEnumStart();
    BOOL bEnum(PATHDATA *pPathData);

    BOOL IsCached() const;

private:
    CSubPath *CreateSubPath(PATHDATA *pPathData);
    POINTFIX *CreateSubPathPoints(PATHDATA *pPathData);
    VOID DeleteSubPath(CSubPath *pSubPath);
    VOID CopyCurrent(PATHDATA *pPathData);
};

///////////////////////////////////////////////////////////////////////////////
// CCachingPathIterator
//
// Class Description:
// 
//   This is the more interesting of the two path iterator classes.  This one
//   uses a threshhold value (currently 3) to decide when to start caching the
//   subpaths from the path object.  The reason this is useful is that currently
//   there is a defect in GDI that causes path information to be lost after 
//   several hundred iterations through a clippath.  The GDI team claim that this
//   has been fixed, but I have determined that it is still broken.  Thus, my
//   workaround is to copy the PATHDATA structures myself when the path is being
//   iterated more than just a few times.
//
//   In theory you could also handle a memory-out situation by aborting the caching
//   and relying on GDI.  I haven't tested the memory out conditions, though.
//
///////////////////////////////////////////////////////////////////////////////
class CCachingPathIterator : public CPathIterator
{
    enum { eCacheMinimum = 3 };

    PATHOBJ    *m_ppo;
    LONG        m_iEnumCount;
    CPathCache  m_cache;

public:
    CCachingPathIterator();
    VOID Init(PATHOBJ *ppo);
    VOID vEnumStart();
    BOOL bEnum(PATHDATA *pPathData);
    VOID Done();
};

///////////////////////////////////////////////////////////////////////////////
// MDrawable
//
// Class Description:
// 
//   This class represents a mixin for any drawable components.  It provides
//   the virtual interface for drawing and drawing a rectangular section of
//   a graphic.
//
//   Although this was created as a Mixin, I'm not suggesting multiple 
//   inheritance.  I recommend using this as an ABC instead, but do what you 
//   want.
//
///////////////////////////////////////////////////////////////////////////////
class MDrawable
{
public:
    virtual BOOL Draw() = 0;
    virtual BOOL DrawRect(LPRECTL prclClip) = 0;
};

///////////////////////////////////////////////////////////////////////////////
// CClippingRegion
//
// Class Description:
// 
//   This class isolates the functions of a clipping object.  If the m_pco
//   member is NULL then no clipping occurs, but if the m_pco points to a 
//   CLIPOBJ then the clipping region will be traversed and the drawable
//   client-object given will be called via its DrawRect interface.
//
///////////////////////////////////////////////////////////////////////////////
class CClippingRegion
{
    CLIPOBJ *m_pco;

public:
    CClippingRegion(CLIPOBJ *pco);

    BOOL EnumerateClipAndDraw(MDrawable *pDrawable);
};

///////////////////////////////////////////////////////////////////////////////
// CPath
//
// Structure Description:
// 
//   This structure holds function pointers for marking the various segments of
//   a path.  For example the path could be a polyline, polygon, or even a clip
//   path (not yet implemented).
//
///////////////////////////////////////////////////////////////////////////////
class CPath : public MDrawable
{
protected:
    PDEVOBJ     m_pDevObj;
    PATHOBJ    *m_ppo;

    POINT       m_ptFigureBegin;  // This point represents the starting point of a closed figure (can be one or more subpaths)
    POINT       m_ptPathBegin;    // This point represents the first point of the overall path
    POINT       m_ptSubPathBegin; // This point is the first point in the current sub-path
    POINT       m_ptCurrent;      // This is the current point in the current sub-path
    USHORT      m_curPtFlags;

    PHPGLMARKER m_pPen;
    PHPGLMARKER m_pBrush;

    // These flags are a gross waste of space, but oh well.
    BOOL        m_fFirstSubPath;
    BOOL        m_fSubPathsRemain;
    BOOL        m_fSubPathWasClosed;
    BOOL        m_fFigureWasClosed;
    BOOL        m_fError;
    DWORD       m_pathFlags;

    // CSimplePathIterator m_pathIterator;
    CCachingPathIterator m_pathIterator;

public:
    CPath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush);
    BOOL Draw();
    BOOL DrawRect(PRECTL prclClip);

protected:
    virtual VOID BeginMarking() = 0;
    virtual VOID BeginPath() = 0;
    virtual VOID BeginSubPath() = 0;
    virtual VOID AddPolyPt() = 0;
    virtual VOID AddBezierPt() = 0;
    virtual VOID EndSubPath() = 0;
    virtual VOID EndPath() = 0;
    virtual VOID EndMarking() = 0;

private:
    BOOL OutputLines(POINTFIX *pptPoints, ULONG dwNumPoints);
    BOOL OutputBeziers(POINTFIX *pptPoints, ULONG dwNumPoints);

    VOID Init(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush);
    VOID Done();

    friend class CStaticPathFactory;
};

///////////////////////////////////////////////////////////////////////////////
// CPolygonPath
//
// Structure Description:
// 
//   This implements a polygon path using the CPath as a base (for maintaining
//   the state of the polygon).
//
///////////////////////////////////////////////////////////////////////////////
class CPolygonPath : public CPath
{
public:
    CPolygonPath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush);

protected:
    virtual VOID BeginMarking();
    virtual VOID BeginPath();
    virtual VOID BeginSubPath();
    virtual VOID AddPolyPt();
    virtual VOID AddBezierPt();
    virtual VOID EndSubPath();
    virtual VOID EndPath();
    virtual VOID EndMarking();
};

///////////////////////////////////////////////////////////////////////////////
// CPolylinePath
//
// Structure Description:
// 
//   This implements a polyline path using the CPath as a base (for maintaining
//   the state of the polyline).
//
///////////////////////////////////////////////////////////////////////////////
class CPolylinePath : public CPath
{
public:
    CPolylinePath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen);

protected:
    virtual VOID BeginMarking();
    virtual VOID BeginPath();
    virtual VOID BeginSubPath();
    virtual VOID AddPolyPt();
    virtual VOID AddBezierPt();
    virtual VOID EndSubPath();
    virtual VOID EndPath();
    virtual VOID EndMarking();
};

///////////////////////////////////////////////////////////////////////////////
// CDynamicPathFactory
//
// Structure Description:
// 
//   This provides a mechanism for creating a path which matches the given 
//   arguments.  The Dynamic factory uses new and delete to instantiate the
//   desired object.
//
///////////////////////////////////////////////////////////////////////////////
class CDynamicPathFactory
{
public:
    CDynamicPathFactory();
    CPath *CreatePath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush);
    VOID DeletePath(CPath *pPath);
};

///////////////////////////////////////////////////////////////////////////////
// CDynamicPathFactory
//
// Structure Description:
// 
//   This provides a mechanism for creating a path which matches the given 
//   arguments.  The Static factory uses member objects to instantiate the
//   desired object.
//
//   In the interest of avoiding unwanted memory allocation/deallocation we will 
//   hide a polyline and a polygon inside the factory such that instead of 
//   allocating a new instance (on the heap) it simply initializes the correct
//   instance and returns a pointer to it.  Therefore you cannot use delete on
//   the resulting pointer.  Use the DeletePath operator instead.
//
//   Note: NOT YET IMPLEMENTED.
//   To implement this class you need to add new methods to CPolygonPath and 
//   CPolylinePath to allow creation without the constructor arguments.
///////////////////////////////////////////////////////////////////////////////
class CStaticPathFactory
{
    CPolygonPath m_polygonPath;
    CPolylinePath m_polylinePath;

public:
    CStaticPathFactory();
    CPath *CreatePath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush);
    VOID DeletePath(CPath *pPath);
};


///////////////////////////////////////////////////////////////////////////////
// MarkPath()
//
// Routine Description:
// 
//   Handles an open or closed path (polygon, polyline, and/or polybezier).
//   A path factory is used to instantiate the desired path object and a 
//   clipping region isolates the necessary clipping calls.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   ppo - Defines the path to be sent to the printer
//   pPen - The pen to draw with
//   pBrush - The brush to stroke with
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL MarkPath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush)
{
    VERBOSE(("Entering SelectPath...\n"));

    ASSERT_VALID_PDEVOBJ(pDevObj);

    PHPGLSTATE pState = GETHPGLSTATE(pDevObj);

    //
    // Determine what kind of poly and iterator will be needed and initialize
    // them to the correct values.
    //
    // CDynamicPathFactory pathFactory;
    CStaticPathFactory pathFactory;
    CPath *pPath = pathFactory.CreatePath(pDevObj, ppo, pPen, pBrush);
    if (pPath == NULL)
        return FALSE;

    CClippingRegion clip(pState->pComplexClipObj);
    clip.EnumerateClipAndDraw(pPath);

    pathFactory.DeletePath(pPath);

    VERBOSE(("Exiting SelectPath...\n"));

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// CClippingRegion functions.

///////////////////////////////////////////////////////////////////////////////
// CClippingRegion::CClippingRegion()
//
// Routine Description:
// 
//   Ctor: This sets the member to the given clipping region.  NULL is okay 
//   for a clipping region--it implies that no clipping should be performed.
//
// Arguments:
// 
//   pco - The clip region (NULL okay)
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
CClippingRegion::CClippingRegion(CLIPOBJ *pco) : m_pco(pco)
{
}


///////////////////////////////////////////////////////////////////////////////
// CClippingRegion::EnumerateClipAndDraw()
//
// Routine Description:
// 
//   This function uses the m_pco member to enumerate the clipping region 
//   into bite-sized rectangles which can be drawn.  If the clipping region
//   is NULL then no clipping is performed.
//
// Arguments:
// 
//   pDrawable - the object to be clipped
// 
// Return Value:
// 
//   BOOL - TRUE for success, FALSE for failure.
///////////////////////////////////////////////////////////////////////////////
BOOL CClippingRegion::EnumerateClipAndDraw(MDrawable *pDrawable)
{
    ENUMRECTS   clipRects; // Make this larger to reduce calls to CLIPOBJ_bEnum
    BOOL        bMore;
    BOOL        bRetVal = TRUE;

    if (pDrawable == NULL)
        return FALSE;

    if (m_pco)
    {
        CLIPOBJ_cEnumStart(m_pco, TRUE, CT_RECTANGLES, CD_LEFTDOWN, 0);
        do
        {
            bMore = CLIPOBJ_bEnum(m_pco, sizeof(clipRects), &clipRects.c);

            if ( DDI_ERROR == bMore )
            {
                bRetVal = FALSE;
                break;
            }

            for (ULONG i = 0; i < clipRects.c; i++)
            {
                pDrawable->DrawRect(&(clipRects.arcl[i]));
            }
        } while (bMore);
    }
    else
    {
        pDrawable->Draw();
    }

    return bRetVal;
}


///////////////////////////////////////////////////////////////////////////////
// CPath functions.

///////////////////////////////////////////////////////////////////////////////
// CPath::CPath()
//
// Routine Description:
// 
//   Ctor: init the fields of the path object.
//
// Arguments:
// 
//   pDevObj - the device
//   ppo - the path
//   pPen - the pen to edge/draw with
//   pBrush - the brush to fill with (polygon only) (NULL okay for polylines)
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
CPath::CPath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush)
{
    Init(pDevObj, ppo, pPen, pBrush);
}

///////////////////////////////////////////////////////////////////////////////
// CPath::Init()
//
// Routine Description:
// 
//   The init function initializes the fields.  It's kind of a hack, but 
//   needed to be here for the static class factory.
//
// Arguments:
// 
//   pDevObj - the device
//   ppo - the path
//   pPen - the pen to edge/draw with
//   pBrush - the brush to fill with (polygon only) (NULL okay for polylines)
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CPath::Init(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush)
{
    m_pDevObj = pDevObj;
    m_ppo     = ppo;
    m_pPen    = pPen;
    m_pBrush  = pBrush;

    m_ptFigureBegin.x   = m_ptPathBegin.x = m_ptSubPathBegin.x = m_ptCurrent.x = 0;
    m_ptFigureBegin.y   = m_ptPathBegin.y = m_ptSubPathBegin.y = m_ptCurrent.y = 0;
    m_fError            = FALSE;
    m_fFirstSubPath     = FALSE;
    m_fSubPathsRemain   = FALSE;
    m_fSubPathWasClosed = FALSE;
    m_fFigureWasClosed  = FALSE;

    m_pathIterator.Init(ppo);
}


///////////////////////////////////////////////////////////////////////////////
// CPath::Done()
//
// Routine Description:
// 
//   This function performs any cleanup required for the path.
//
// Arguments:
// 
//   None.
//
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CPath::Done()
{
    m_pathIterator.Done();
}


///////////////////////////////////////////////////////////////////////////////
// CPath::DrawRect()
//
// Routine Description:
// 
//   Draws the given area inside the clipping rectangle.  Note that we must
//   invoke the HPGL code to set the clipping rect ourselves--it won't know
//   what language to use for us.
//
// Arguments:
// 
//   prclClip - the clipping rectangle
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CPath::DrawRect(LPRECTL prclClip)
{
    HPGL_SetClippingRegion(m_pDevObj, prclClip, NORMAL_UPDATE);
    return Draw();
}


///////////////////////////////////////////////////////////////////////////////
// CPath::Draw()
//
// Routine Description:
// 
//   Enumerates the points of a path and sends them to the printer as HPGL.
//
// Arguments:
// 
//   none
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CPath::Draw()
{
    PATHDATA    pathData;
    POINTFIX*   pPoints;
    ULONG       dwPoints;

    VERBOSE(("Entering EvaluateOpenPath...\n"));


    ASSERT_VALID_PDEVOBJ(m_pDevObj);
    PRECONDITION(m_ppo != NULL);

    //
    // Tell the path to get started.  For polylines this selects a pen for 
    // drawing, but polygons will just ignore it.
    //
    BeginMarking();

    //
    // The path can set an error if there was a problem with the pens, or 
    // there were no non-NULL markers to use.
    //
    if (!m_fError)
    {
        //
        // Have the engine start enumerating the path object.
        //
        // PATHOBJ_vEnumStart(m_ppo);
        m_pathIterator.vEnumStart();

        //
        // Mark that we are currently on the first subpath of the path, and that
        // there is at least one subpath left to process...
        //
        m_fFirstSubPath = TRUE;
        m_fSubPathsRemain = TRUE;

        //
        // Process the path as long as there are components of the path remaining.
        //
        while (m_fSubPathsRemain && !m_fError)
        {
            //
            // Retrieve the next subpath from the engine
            //
            // m_fSubPathsRemain = PATHOBJ_bEnum(m_ppo, &pathData);
            m_fSubPathsRemain = m_pathIterator.bEnum(&pathData);
            m_pathFlags = pathData.flags;

            dwPoints = pathData.count;

            pPoints = pathData.pptfx;

            //
            // If GDI fails to provide meaningful path data we need to abort.  
            // Although this bypasses any possible cleanup, it also avoids 
            // accidental use of the cached point data expected in EndPath or
            // EndMarking
            //
            if ((dwPoints == 0) && (pPoints == NULL))
                return FALSE;

            //
            // Remember the start and end of the current segment.
            //
            m_ptSubPathBegin.x = FXTOLROUND(pPoints[0].x);
            m_ptSubPathBegin.y = FXTOLROUND(pPoints[0].y);

            //
            // If this is the first subpath then keep the VERY first point
            // around so that the shape can be properly closed if necessary.
            // 
            if (m_fFirstSubPath)
            {
                //
                // Start the first subpath
                //
                m_ptCurrent = m_ptFigureBegin = m_ptPathBegin = m_ptSubPathBegin;

                BeginPath();

                m_fSubPathWasClosed = FALSE;

                //
                // Increment past the point we've just used.
                //
                pPoints++;
                dwPoints--;
            }
            else if ((pathData.flags & PD_BEGINSUBPATH) || m_fSubPathWasClosed)
            {
                //
                // Starting a new subpath
                //
                m_ptCurrent = m_ptSubPathBegin;

                //
                // If the last subpath closed a figure then move the FigureBegin 
                // point to the beginning of this subpath.
                //
                if (m_fFigureWasClosed)
                {
                    m_ptFigureBegin = m_ptSubPathBegin;
                    m_fFigureWasClosed = FALSE;
                }

                BeginSubPath();

                //
                // We are now in an active polygon--hence the subpath is open
                //
                m_fSubPathWasClosed = FALSE;

                //
                // Increment past the point we've just used.
                //
                pPoints++;
                dwPoints--;
            }

            if (pathData.flags & PD_BEZIERS)
            {
                if (!OutputBeziers(pPoints, dwPoints))
                {
                    WARNING(("Bezier output failed!\n"));
                    m_fError = TRUE;
                }
            }
            else
            {
                if (!OutputLines(pPoints, dwPoints))
                {
                    WARNING(("Line output failed!\n"));
                    m_fError = TRUE;
                }
            }

            //
            // If this is flagged as the end of a subpath then invoke the 
            // necessary commands.
            //
            if (pathData.flags & PD_ENDSUBPATH)
            {
                EndSubPath();
                m_fSubPathWasClosed = TRUE;
            }

            //
            // We've now processed at least one subpath -- remember the fact.
            //
            m_fFirstSubPath = FALSE;

        } // end of while (fSubPathsRemain)

        EndPath();

        EndMarking();
    }

    VERBOSE(("Exiting CPath::Mark...\n"));

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// CPath::OutputLines()
//
// Routine Description:
// 
//   Sends a group of points--given as an array of POINTFIX--to the printer as
//   polyline or polygon segments.
// 
// Arguments:
// 
//   pptPoints - The points to be printed
//   dwNumPoints - The number of elements in pptPoints
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CPath::OutputLines(POINTFIX *pptPoints,
                        ULONG     dwNumPoints)
{
    ULONG dwCurPoint;

    VERBOSE(("Entering CPath::OutputLines...\n"));

    ASSERT_VALID_PDEVOBJ(m_pDevObj);
    PRECONDITION(pptPoints != NULL);

    for (dwCurPoint = 0; dwCurPoint < dwNumPoints; dwCurPoint++)
    {
        m_ptCurrent.x = FXTOLROUND(pptPoints[dwCurPoint].x);
        m_ptCurrent.y = FXTOLROUND(pptPoints[dwCurPoint].y);

        m_curPtFlags  = 0;
        m_curPtFlags |= (dwCurPoint == 0 ? HPGL_eFirstPoint : 0);
        m_curPtFlags |= (dwCurPoint == (dwNumPoints - 1) ? HPGL_eLastPoint : 0);

        AddPolyPt();
    }

    VERBOSE(("Exiting CPath::OutputLines...\n"));

    return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////
// CPath::OutputBeziers()
//
// Routine Description:
// 
//   Sends a group of points--given as an array of POINTFIX--to the printer as
//   a series of bezier curves.  Note that every three points defines a bezier
//   curve.  In DEBUG mode an assertion will be thrown if the number of points
//   is not a multiple of three.
// 
// Arguments:
// 
//   pptPoints - The points to be printed
//   dwNumPoints - The number of elements in pptPoints
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL CPath::OutputBeziers(POINTFIX *pptPoints,
                          ULONG     dwNumPoints)
{
    ULONG dwCurPoint;

    VERBOSE(("Entering CPath::OutputBeziers...\n"));

    ASSERT_VALID_PDEVOBJ(m_pDevObj);
    PRECONDITION(pptPoints != NULL);

    for (dwCurPoint = 0; dwCurPoint < dwNumPoints; )
    {
        int i;

        //
        // Make sure that there are really three more points
        //
        ASSERT((dwCurPoint + 3) <= dwNumPoints);

        //
        // The points array is really triples which define bezier curves.
        // Send out another bezier for each triple in the list.
        //
        for (i = 0; i < 3; i++)
        {
            m_ptCurrent.x = FXTOLROUND(pptPoints[dwCurPoint].x);
            m_ptCurrent.y = FXTOLROUND(pptPoints[dwCurPoint].y);

            m_curPtFlags  = 0;
            m_curPtFlags |= (i == 0 ? HPGL_eFirstPoint : 0);
            m_curPtFlags |= (i == 2 ? HPGL_eLastPoint : 0);

            AddBezierPt();

            dwCurPoint++;
        }
    }

    VERBOSE(("Exiting CPath::OutputBeziers...\n"));

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// CPolygonPath functions.

///////////////////////////////////////////////////////////////////////////////
// CPolygonPath::CPolygonPath()
//
// Routine Description:
// 
//   Ctor: Inits structure.  Note that most data members live in the base
//   class, and that's okay.
//
// Arguments:
// 
//   pDevObj - the device
//   ppo - the path
//   pPen - the pen to draw with
//   pBrush - the brush to edge with
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
CPolygonPath::CPolygonPath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush) :
CPath(pDevObj, ppo, pPen, pBrush)
{
}


///////////////////////////////////////////////////////////////////////////////
// CPolygonPath::BeginMarking()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   start marking.  The polygon will check the pen and brush to make sure that
//   there is a valid marker to use.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolygonPath::BeginMarking()
{
    if (IsNULLMarker(m_pPen) && IsNULLMarker(m_pBrush))
    {
        m_fError = TRUE;
    }
}


///////////////////////////////////////////////////////////////////////////////
// CPolygonPath::BeginPath()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   begin the path.  The polygon should start the HPGL polygon mode.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolygonPath::BeginPath()
{
    HPGL_BeginPolygonMode(m_pDevObj, m_ptSubPathBegin);
}


///////////////////////////////////////////////////////////////////////////////
// CPolygonPath::BeginSubPath()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   begin a sub path.  The polygon should start an HPGL subpolygon.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolygonPath::BeginSubPath()
{
    HPGL_BeginSubPolygon(m_pDevObj, m_ptSubPathBegin);
}


///////////////////////////////////////////////////////////////////////////////
// CPolygonPath::AddPolyPt()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   add a point.  The polygon should send the HPGL command at add a point.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolygonPath::AddPolyPt()
{
    HPGL_AddPolyPt(m_pDevObj, m_ptCurrent, m_curPtFlags);
}


///////////////////////////////////////////////////////////////////////////////
// CPolygonPath::AddBezierPt()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   add a bezier point.  The polygon should send the HPGL command at add a bezier
//   point.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolygonPath::AddBezierPt()
{
    HPGL_AddBezierPt(m_pDevObj, m_ptCurrent, m_curPtFlags);
}


///////////////////////////////////////////////////////////////////////////////
// CPolygonPath::EndSubPath()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   end a subpath.  The polygon should check the CLOSEFIGURE flag to determine
//   whether to send the HPGL end subpolygon command.
//   point.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolygonPath::EndSubPath()
{
    if (m_pathFlags & PD_CLOSEFIGURE)
    {
        HPGL_EndSubPolygon(m_pDevObj);
    }
    m_fFigureWasClosed = TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// CPolygonPath::EndPath()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   end the path.  The polygon should terminate polygon mode.
//   point.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolygonPath::EndPath()
{
    HPGL_EndPolygonMode(m_pDevObj);
}


///////////////////////////////////////////////////////////////////////////////
// CPolygonPath::EndMarking()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is finished
//   marking.  The polygon should fill with the given brush and edge with the
//   given pen.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolygonPath::EndMarking()
{
    if (!IsNULLMarker(m_pBrush))
        PolyFillWithBrush(m_pDevObj, m_pBrush);

    if (!IsNULLMarker(m_pPen))
        EdgeWithPen(m_pDevObj, m_pPen);
}


///////////////////////////////////////////////////////////////////////////////
// CPolylinePath functions.

///////////////////////////////////////////////////////////////////////////////
// CPolylinePath::CPolylinePath()
//
// Routine Description:
// 
//   Ctor: Inits the fields of the polyline.  Note that most of the fields
//   actually live in the base class, and that's okay.
//
// Arguments:
// 
//   pDevObj - the device
//   ppo - the path
//   pPen - the pen to draw with
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
CPolylinePath::CPolylinePath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen) :
CPath(pDevObj, ppo, pPen, NULL)
{
}


///////////////////////////////////////////////////////////////////////////////
// CPolylinePath::BeginMarking()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   start marking.  The appropriate action for a polyline is to select the pen
//   that will draw the polyline.
//
// Arguments:
// 
//   none
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolylinePath::BeginMarking()
{
    if (!IsNULLMarker(m_pPen))
    {
        DrawWithPen(m_pDevObj, m_pPen);
    }
    else
    {
        m_fError = TRUE;
    }
}


///////////////////////////////////////////////////////////////////////////////
// CPolylinePath::BeginPath()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   begin the path.  The appropriate action for a polyline is to send the HPGL
//   pen up command "PU" with the first coordinate.  (Note that ptPathBegin and
//   ptSubPathBegin are identical at this point.)
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolylinePath::BeginPath()
{
    HPGL_BeginPolyline(m_pDevObj, m_ptSubPathBegin);
}


///////////////////////////////////////////////////////////////////////////////
// CPolylinePath::BeginPath()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   begin a sub path.  The appropriate action for a polyline is to send the HPGL
//   pen up command "PU" with the first coordinate.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolylinePath::BeginSubPath()
{
    HPGL_BeginPolyline(m_pDevObj, m_ptSubPathBegin);
}


///////////////////////////////////////////////////////////////////////////////
// CPolylinePath::AddPolyPt()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   add a point.  The appropriate action for a polyline is to send the HPGL
//   pen down command "PD" with the given coordinate.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolylinePath::AddPolyPt()
{
    HPGL_AddPolyPt(m_pDevObj, m_ptCurrent, m_curPtFlags);
}


///////////////////////////////////////////////////////////////////////////////
// CPolylinePath::AddPolyPt()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   add a bezier point.  The appropriate action for a polyline is to send the HPGL
//   bezier command "BZ" with the given coordinate.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolylinePath::AddBezierPt()
{
    HPGL_AddBezierPt(m_pDevObj, m_ptCurrent, m_curPtFlags);
}


///////////////////////////////////////////////////////////////////////////////
// CPolylinePath::EndSubPath()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   end a subpath.  At this point we examine the CLOSEFIGURE flag to determine
//   if we should manually close the polyline.  If so then we draw a new line
//   segment to the beginning coordinate.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolylinePath::EndSubPath()
{
    //
    // An EndSubPath means the figure needs to be closed. 
    // If PD_CLOSEFIGURE is set, a line has to be drawn from the 
    // current (end) point of the figure to its begin point. 
    // If PD_CLOSEFIGURE is not set, then we only internally record
    // that figure has been closed. A figure-closing line is not drawn.
    //
    if (m_pathFlags & PD_CLOSEFIGURE)
    {
        if (!PT_EQUAL(m_ptCurrent, m_ptFigureBegin))
        {
            // m_curPtFlags = HPGL_eFirstPoint;
            // HPGL_AddPolyPt(m_pDevObj, m_ptCurrent, m_curPtFlags);

            HPGL_BeginPolyline(m_pDevObj, m_ptCurrent);

            m_curPtFlags = HPGL_eFirstPoint | HPGL_eLastPoint;
            HPGL_AddPolyPt(m_pDevObj, m_ptFigureBegin, m_curPtFlags);
        }
    }

    m_fFigureWasClosed = TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// CPolylinePath::EndPath()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is about to 
//   end the path.  At this point we check the state variable fSubPathWasClosed
//   to determine whether we need to manually close the shape..  If so then we 
//   draw a new line segment to the beginning coordinate.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolylinePath::EndPath()
{
    if (!m_fSubPathWasClosed)
    {
        m_curPtFlags = HPGL_eFirstPoint | HPGL_eLastPoint;
        HPGL_AddPolyPt(m_pDevObj, m_ptPathBegin, m_curPtFlags);
    }
}


///////////////////////////////////////////////////////////////////////////////
// CPolylinePath::EndMarking()
//
// Routine Description:
// 
//   This function is called by the path iterator when a poly-path is finished
//   marking.  For a polyline we do nothing--we'd selected the pen at the 
//   beginning.
//
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   None. (Errors are passed back through the iterator bError member.)
///////////////////////////////////////////////////////////////////////////////
VOID CPolylinePath::EndMarking()
{
}


///////////////////////////////////////////////////////////////////////////////
// CDynamicPathFactory functions.

///////////////////////////////////////////////////////////////////////////////
// CDynamicPathFactory::CDynamicPathFactory()
//
// Routine Description:
// 
//   Ctor: boring!
//
//   This class--and the related class, CStaticPathFactory--provide several
//   strategies for creating the appropriate path to fit your data.  The
//   interface of these two classes should be kept identical so that you can
//   use them interchangably (but I don't see any reason to create a common
//   base class--you shouldn't go passing these factories around!).
//
//   An important note: you can't assume how a factory has produced the 
//   client class, so don't go trying to delete the client.  Use the factory
//   deletion interface provided.
//
// Arguments:
// 
//   none
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
CDynamicPathFactory::CDynamicPathFactory()
{
}


///////////////////////////////////////////////////////////////////////////////
// CDynamicPathFactory::CreatePath()
//
// Routine Description:
// 
//   This function creates a path to match the given data.  If the brush is 
//   defined then this is going to be a polygon so one is created.  Otherwise
//   this will be a polyline so one is created.  Remember to use the DeletePath
//   member to destroy the client class.  DON'T USE delete ON THE CLIENT--YOU 
//   DON'T REALLY KNOW WHERE IT CAME FROM!!!
//
// Arguments:
// 
//   pDevObj - the device
//   ppo - the path
//   pPen - the pen to mark/draw with
//   pBrush - the brush to fill with (NULL indicates a polygon region).
// 
// Return Value:
// 
//   CPath* - a pointer to the desired Path object.
///////////////////////////////////////////////////////////////////////////////
CPath* CDynamicPathFactory::CreatePath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush)
{
    if (pBrush == NULL)
        return new CPolylinePath(pDevObj, ppo, pPen);
    else
        return new CPolygonPath(pDevObj, ppo, pPen, pBrush);
}


///////////////////////////////////////////////////////////////////////////////
// CDynamicPathFactory::DeletePath()
//
// Routine Description:
// 
//   This function destroys the path object after it has been used.
//
// Arguments:
// 
//   pPath - the path to be destroyed
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CDynamicPathFactory::DeletePath(CPath *pPath)
{
    delete pPath;
}










///////////////////////////////////////////////////////////////////////////////
// CStaticPathFactory functions.

///////////////////////////////////////////////////////////////////////////////
// CStaticPathFactory::CStaticPathFactory()
//
// Routine Description:
// 
//   Ctor: boring!
//
//   This class--and the related class, CDynamicPathFactory--provide several
//   strategies for creating the appropriate path to fit your data.  The
//   interface of these two classes should be kept identical so that you can
//   use them interchangably (but I don't see any reason to create a common
//   base class--you shouldn't go passing these factories around!).
//
//   An important note: you can't assume how a factory has produced the 
//   client class, so don't go trying to delete the client.  Use the factory
//   deletion interface provided.
//
// Arguments:
// 
//   none
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
CStaticPathFactory::CStaticPathFactory() :
m_polylinePath(NULL, NULL, NULL), m_polygonPath(NULL, NULL, NULL, NULL)
{
}


///////////////////////////////////////////////////////////////////////////////
// CStaticPathFactory::CreatePath()
//
// Routine Description:
// 
//   This function creates a path to match the given data.  If the brush is 
//   defined then this is going to be a polygon so one is created.  Otherwise
//   this will be a polyline so one is created.  Remember to use the DeletePath
//   member to destroy the client class.  DON'T USE delete ON THE CLIENT--YOU 
//   DON'T REALLY KNOW WHERE IT CAME FROM!!!
//
// Arguments:
// 
//   pDevObj - the device
//   ppo - the path
//   pPen - the pen to mark/draw with
//   pBrush - the brush to fill with (NULL indicates a polygon region).
// 
// Return Value:
// 
//   CPath* - a pointer to the desired Path object.
///////////////////////////////////////////////////////////////////////////////
CPath* CStaticPathFactory::CreatePath(PDEVOBJ pDevObj, PATHOBJ *ppo, PHPGLMARKER pPen, PHPGLMARKER pBrush)
{
    CPath *pPath;
    if (pBrush == NULL)
        pPath = &m_polylinePath;
    else
        pPath = &m_polygonPath;

    pPath->Init(pDevObj, ppo, pPen, pBrush);

    return pPath;
}


///////////////////////////////////////////////////////////////////////////////
// CStaticPathFactory::DeletePath()
//
// Routine Description:
// 
//   This function destroys the path object after it has been used.
//
// Arguments:
// 
//   pPath - the path to be destroyed
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CStaticPathFactory::DeletePath(CPath *pPath)
{
    pPath->Done();
}


///////////////////////////////////////////////////////////////////////////////
// CCachingPathIterator::CCachingPathIterator()
//
// Routine Description:
// 
//   ctor
//
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
CCachingPathIterator::CCachingPathIterator() : m_ppo(NULL), m_iEnumCount(0)
{
    Init(NULL);
}

///////////////////////////////////////////////////////////////////////////////
// CCachingPathIterator::Init()
//
// Routine Description:
// 
//   Initializes the object.  This is especially useful when a static instance
//   of an object is being used to mimic the implementation of different
//   instances.
//
// Arguments:
// 
//   ppo - the PATHOBJ
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CCachingPathIterator::Init(PATHOBJ *ppo)
{
    m_ppo = ppo;
    m_iEnumCount = 0;
    m_cache.Init();
}

///////////////////////////////////////////////////////////////////////////////
// CCachingPathIterator::vEnumStart()
//
// Routine Description:
// 
//   This is equivalent to PATHOBJ_vEnumStart.  It begins the path iteration
//   at the first record.
//
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CCachingPathIterator::vEnumStart()
{
    if (m_cache.IsCached())
    {
        m_cache.vEnumStart();
    }
    else
    {
        if (m_iEnumCount > eCacheMinimum)
        {
            m_cache.CreateCache(m_ppo);
            m_cache.vEnumStart();
        }
        else
        {
            PATHOBJ_vEnumStart(m_ppo);
        }
    }

    m_iEnumCount++;
}

///////////////////////////////////////////////////////////////////////////////
// CCachingPathIterator::bEnum()
//
// Routine Description:
// 
//   This funciton is equivalent to PATHOBJ_bEnum and returns the current
//   record in the path and advances the cursor to the next element.  If the
//   cursor has advanced past the end of the list FALSE is returned.
//
// Arguments:
// 
//   pPathData - [OUT] The structure that the current record is copied into
// 
// Return Value:
// 
//   TRUE if more records exists, else FALSE is this is the last one.
///////////////////////////////////////////////////////////////////////////////
BOOL CCachingPathIterator::bEnum(PATHDATA *pPathData)
{
    if (m_cache.IsCached())
    {
        return m_cache.bEnum(pPathData);
    }
    else
    {
        return PATHOBJ_bEnum(m_ppo, pPathData);
    }
}

///////////////////////////////////////////////////////////////////////////////
// CCachingPathIterator::Done()
//
// Routine Description:
// 
//   This function deletes the cache and resets the enum count.
//
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CCachingPathIterator::Done()
{
    m_cache.DeleteCache();
    m_cache.Done();
    m_iEnumCount = 0;
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::CPathCache()
//
// Routine Description:
// 
//   ctor
//
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
CPathCache::CPathCache() : m_pSubPaths(NULL), m_pCurrent(NULL), m_bIsCached(FALSE)
{
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::Init()
//
// Routine Description:
// 
//   Initializes the object.  This is especially useful when a static instance
//   of an object is being used to mimic the implementation of different
//   instances.
//
//   In this case it merely makes sure that any previously cached data is 
//   deleted.
//
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CPathCache::Init()
{
    if (m_bIsCached)
    {
        DeleteCache();
    }
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::Done()
//
// Routine Description:
// 
//   This function deletes the cache after the session is over.
//
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CPathCache::Done()
{
    if (m_bIsCached)
    {
        DeleteCache();
    }
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::CreateCache()
//
// Routine Description:
// 
//   This function enumerates the path object and constructs a deep copy of the
//   path data.
//
// Arguments:
// 
//   ppo - The path to be copied.
// 
// Return Value:
// 
//   TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL CPathCache::CreateCache(PATHOBJ *ppo)
{
    if (m_bIsCached)
    {
        DeleteCache();
    }

    m_pSubPaths = NULL;
    m_pCurrent = NULL;
    m_bIsCached = TRUE;

    PATHDATA pathData;
    BOOL bMore;
    PATHOBJ_vEnumStart(ppo);
    do
    {
        bMore = PATHOBJ_bEnum(ppo, &pathData);
        CSubPath *pSubPath = CreateSubPath(&pathData);
        if (pSubPath)
        {
            if (m_pSubPaths == NULL)
            {
                m_pSubPaths = m_pCurrent = pSubPath;
            }
            else
            {
                m_pCurrent->pNext = pSubPath;
                m_pCurrent = pSubPath;
            }
        }
        else
        {
            // I consider an empty path to be an error
            DeleteCache();
            return FALSE;
        }
    } while (bMore);

    m_pCurrent = NULL;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::CreateSubPath()
//
// Routine Description:
// 
//   During the deep-copy of a path this function continues the deep copy by
//   creating a clone of the given PATHDATA structure.
//
// Arguments:
// 
//   pPathData - data to be cloned.
// 
// Return Value:
// 
//   Pointer to cloned data.
///////////////////////////////////////////////////////////////////////////////
CPathCache::CSubPath *CPathCache::CreateSubPath(PATHDATA *pPathData)
{
    if (pPathData == NULL)
        return NULL;

    if (pPathData->count ==  0)
        return NULL;

    CSubPath *pSubPath = (CSubPath*) MemAllocZ(sizeof(CSubPath));
    if (pSubPath == NULL)
        return NULL;

    pSubPath->data.flags = pPathData->flags;
    pSubPath->data.count = pPathData->count;
    pSubPath->data.pptfx = CreateSubPathPoints(pPathData);

    pSubPath->pNext = NULL;

    if (pSubPath->data.pptfx == NULL)
    {
        MemFree(pSubPath);
        return NULL;
    }
    else
    {
        return pSubPath;
    }
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::CreateSubPathPoints()
//
// Routine Description:
// 
//   The deep copy continues with this function which clones the points in the
//   path data structure.
//
// Arguments:
// 
//   pPathData - Structure containing points to be cloned.
// 
// Return Value:
// 
//   Pointer to cloned points array.
///////////////////////////////////////////////////////////////////////////////
POINTFIX *CPathCache::CreateSubPathPoints(PATHDATA *pPathData)
{
    POINTFIX *pDstPoints = (POINTFIX*) MemAllocZ(pPathData->count * sizeof(POINTFIX));
    if (pDstPoints == NULL)
        return NULL;

    POINTFIX *pSrcPoints = (POINTFIX*) pPathData->pptfx;
    for (ULONG i = 0; i < pPathData->count; i++)
    {
        pDstPoints[i] = pSrcPoints[i];
    }

    return pDstPoints;
}


///////////////////////////////////////////////////////////////////////////////
// CPathCache::DeleteCache()
//
// Routine Description:
// 
//   This function deletes the cached point data.
//
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   TRUE if successful (even if there was no cache), else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL CPathCache::DeleteCache()
{
    if (m_bIsCached)
    {
        while (m_pSubPaths)
        {
            m_pCurrent = m_pSubPaths;
            m_pSubPaths = m_pSubPaths->pNext;
            DeleteSubPath(m_pCurrent);
        }
        m_pSubPaths = m_pCurrent = NULL;
        m_bIsCached = FALSE;
        return TRUE;
    }
    else
    {
        // Nothing to do, but that's okay.
        return TRUE;
    }
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::DeleteSubPath()
//
// Routine Description:
// 
//   This function deletes an individual subpath.
//
// Arguments:
// 
//   pSubPath - the path to be destroyed
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CPathCache::DeleteSubPath(CPathCache::CSubPath *pSubPath)
{
    if (pSubPath == NULL)
        return;

    if (pSubPath->data.pptfx)
    {
        MemFree(pSubPath->data.pptfx);
        pSubPath->data.pptfx = NULL;
    }

    MemFree(pSubPath);
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::vEnumStart()
//
// Routine Description:
// 
//   Mimics the PATHOBJ_vEnumStart functionality by moving the cursor to the
//   first record.
//
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CPathCache::vEnumStart()
{
    m_pCurrent = m_pSubPaths;
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::bEnum()
//
// Routine Description:
// 
//   This function mimics the PATHOBJ_bEnum functionality by copying out the
//   current record and advancing the cursor to the next record.
//
// Arguments:
// 
//   pPathData - [OUT] Record to be copied into.
// 
// Return Value:
// 
//   TRUE if more records exist, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL CPathCache::bEnum(PATHDATA *pPathData)
{
    if (m_bIsCached && (m_pCurrent != NULL))
    {
        CopyCurrent(pPathData);
        m_pCurrent = m_pCurrent->pNext;
        return (m_pCurrent != NULL);
    }
    else
    {
        return FALSE;
    }
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::CopyCurrent()
//
// Routine Description:
// 
//   This function copies the current record into the given structure.
//
// Arguments:
// 
//   pPathData - [OUT] Record to be copied into.
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID CPathCache::CopyCurrent(PATHDATA *pPathData)
{
    if (m_pCurrent == NULL)
    {
        pPathData->flags = 0;
        pPathData->count = 0;
        pPathData->pptfx = NULL;
    }
    else
    {
        pPathData->flags = m_pCurrent->data.flags;
        pPathData->count = m_pCurrent->data.count;
        pPathData->pptfx = m_pCurrent->data.pptfx;
    }
}

///////////////////////////////////////////////////////////////////////////////
// CPathCache::IsCached()
//
// Routine Description:
// 
//   Returns whether the object contains cached path data.
//
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   TRUE if cached path data exists, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL CPathCache::IsCached() const
{
    return m_bIsCached;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\pcl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
//
//    pcl.cpp
//
// Abstract:
//
//    Routines that generate pcl printer commands
//	
//
// Environment:
//
//    Windows NT Unidrv driver
//
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file


//
// Digit characters used for converting numbers to ASCII
//
const CHAR DigitString[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

#define HexDigitLocal(n)         DigitString[(n) & 0xf]
#define NUL                 0

///////////////////////////////////////////////////////////////////////////////
// PCL_Output()
//
// Routine Description:
// 
//   Sends the HPGL or PCL ROP command
//	 Sends MC1,# if we are currently working on an HPGL object
//	 Sends Esc&l#O we are currently workin on a RASTER or text object
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//	 szCmdStr - PCL Command 
//   iCmdLen  - Size of szCmdStr
// 
// Return Value:
// 
//   TRUE if successful, FALSE  otherwise
///////////////////////////////////////////////////////////////////////////////

BOOL
PCL_Output(PDEVOBJ pdevobj, PVOID cmdStr, ULONG dLen)
{
    POEMPDEV poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    if (poempdev->eCurRenderLang != ePCL)
        EndHPGLSession(pdevobj);

	OEMWriteSpoolBuf(pdevobj, cmdStr, dLen);
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// PCL_sprintf()
//
// Routine Description:
// 
//   Uses the sprintf function to format the string and sends it to the 
//   device using PCL_Output.
//
// Arguments:
// 
//   pdev - Points to our PDEVOBJ structure
//   szFormat - the sprintf format string
// 
// Return Value:
// 
//   The number of bytes sent.
///////////////////////////////////////////////////////////////////////////////
int PCL_sprintf(PDEVOBJ pdev, char *szFormat, ...)
{
    va_list args;
	CHAR	szCmdStr[STRLEN];
    int     iLen;
    
    va_start(args, szFormat);
    
    iLen = iDrvVPrintfSafeA ( szCmdStr, CCHOF(szCmdStr), szFormat, args );

    if ( iLen <= 0 )
    {
        WARNING(("iDrvVPrintfSafeA returned error. Can't send %s to printer\n", szFormat));
        return 0;
    }
    
    PCL_Output(pdev, szCmdStr, iLen);
    
    va_end(args);
    
    return iLen;
}


///////////////////////////////////////////////////////////////////////////////
// PCL_SetCAP()
//
// Routine Description:
//	
//   Explicitly sets current active position (CAP)
//   horizontally and vertically based on destination
//   rectangle (top,left) Esc*p#x#Y
//	 or
//	 Based on Brush Origin Esc*p0R 
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//	 pptlBrushOrg - brush origin
//   ptlDest - (top,left) of destination rectangle
// 
// Return Value:
// 
//   TRUE if successful, FALSE  otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL 
PCL_SetCAP(PDEVOBJ pdevobj, BRUSHOBJ *pbo, POINTL  *pptlBrushOrg, POINTL  *ptlDest)
{
    BOOL    bRet = FALSE;

	VERBOSE(("PCL_SetCAP. 	\r\n"));

    //
    // if pbo->iSolidColor is not a brush pattern, then we have
    // to ignore the pptlBrushOrg coordinates according to the DDK.
    // So, just zero them out.
    if ((pbo == NULL) || (pbo->iSolidColor != NOT_SOLID_COLOR))
    {
        pptlBrushOrg = NULL;
    }

    if (pptlBrushOrg != NULL)
    {
        if (pptlBrushOrg->x != 0 && pptlBrushOrg->y != 0)
	    {
            //
	        // Use current CAP as brush origin 
            //            
            bRet = PCL_sprintf(pdevobj, "\033*p0R"); 
        }
        else
        {
            //
            // Cursor position has an X and Y offset in the Unidriver, 
            // so we must call the Unidriver XMoveTo and YMoveTo
            // rather than the Esc*p commands directly.
            //
            OEMXMoveTo(pdevobj, ptlDest->x, MV_GRAPHICS | MV_SENDXMOVECMD);
            OEMYMoveTo(pdevobj, ptlDest->y, MV_GRAPHICS | MV_SENDYMOVECMD);
            bRet = TRUE;
        }
    }
    else
    {
        VERBOSE(("PCL_SetCAP...ptlDest->%dx,ptlDest->%dy.\r\n", 
                  ptlDest->x,ptlDest->y));

        OEMXMoveTo(pdevobj, ptlDest->x, MV_GRAPHICS | MV_SENDXMOVECMD);
        OEMYMoveTo(pdevobj, ptlDest->y, MV_GRAPHICS | MV_SENDYMOVECMD);
        bRet = TRUE;
    }

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
// PCL_RasterYOffset()
//
// Routine Description:
//	
//   Explicitly sets current active position (CAP)
//   horizontally and vertically based on destination
//   rectangle (top,left) Esc*b#Y
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//	 scalines - #of raster scanlies of verical movement
// 
// Return Value:
// 
//   TRUE if successful, FALSE  otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_RasterYOffset(PDEVOBJ pdevobj, ULONG uScanlines)
{
	VERBOSE(("PCL_RasterYOffset(). 	\r\n"));
    return PCL_sprintf(pdevobj, "\033*b%dY", uScanlines); // Use current CAP as brush origin 
}



///////////////////////////////////////////////////////////////////////////////
// PCL_HPCLJ5ScreenMatch()
//
// Routine Description:
// 
//   Sets appropriate CID -- Configure Image Data based on printer Model 
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//	 bmpFormat - bits per pixel
// 
// Return Value:
// 
//   TRUE if successful, FALSE  otherwise
/////////////////////////////////////////////////////////////////////////////// 
BOOL  
PCL_HPCLJ5ScreenMatch(PDEVOBJ pdevobj, ULONG  bmpFormat)
{
    VERBOSE(("PCL_HPCLJ5ScreenMatch. \r\n"));
    
    switch (bmpFormat)
    {
    case 1:
        PCL_sprintf(pdevobj, "\033*v6W%c%c%c%c%c%c",2,1,1,8,8,8);
        PCL_LongFormCID(pdevobj);
        return TRUE;
    case 4:
        PCL_sprintf(pdevobj, "\033*v6W%c%c%c%c%c%c",2,1,4,8,8,8);
        PCL_LongFormCID(pdevobj);
        return TRUE;
    case 8:
        PCL_sprintf(pdevobj, "\033*v6W%c%c%c%c%c%c",2,1,8,8,8,8);
        PCL_LongFormCID(pdevobj);
        return TRUE;
    case 16:
    case 24:
    case 32:
        PCL_sprintf(pdevobj, "\033*v6W%c%c%c%c%c%c",2,3,8,8,8,8 ); 
        PCL_LongFormCID(pdevobj);
        return TRUE;
    default:
        ERR(("UNSUPPORTED BITMAP FORMAT IS ENCOUNTERED\n"));
        return FALSE;
    }
    
}

///////////////////////////////////////////////////////////////////////////////
// PCL_ShortFormCID()
//
// Routine Description:
// 
//   Sets appropriate CID -- Configure Image Data based on bits per pixel 
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//	 bmpFormat - bits per pixel
// 
// Return Value:
// 
//   TRUE if successful, FALSE  otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_ShortFormCID(PDEVOBJ pdevobj, ULONG  bmpFormat)
{
    VERBOSE(("PCL_ShortFormCID. \r\n"));
    switch (bmpFormat)
    {
    case 1:
        PCL_sprintf(pdevobj, "\033*v6W%c%c%c%c%c%c",0,1,1,8,8,8 ); 
        return TRUE;
    case 4:
        PCL_sprintf(pdevobj, "\033*v6W%c%c%c%c%c%c",0,1,4,8,8,8 ); 
        return TRUE;
    case 8:
        PCL_sprintf(pdevobj, "\033*v6W%c%c%c%c%c%c",0,1,8,8,8,8 ); 
        return TRUE;
    case 16:
    case 24:
    case 32:
        PCL_sprintf(pdevobj, "\033*v6W%c%c%c%c%c%c",0,3,8,8,8,8 ); 
        return TRUE;
    default:
        ERR(("UNIDENTIFIED BITMAP FORMAT IS ENCOUNTERED\r\n"));
        return FALSE;
    }
} 

///////////////////////////////////////////////////////////////////////////////
// PCL_LongFormCID()
//
// Routine Description:
// 
//   Sets long form CID -- Configure Image Data
//   Specific for HPCLJ5 
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   NOT REQUIRED
///////////////////////////////////////////////////////////////////////////////
VOID
PCL_LongFormCID(PDEVOBJ pdevobj)
{
    VERBOSE(("PCL_ShortFormCID. \r\n"));
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",63,25,153,154,62,174,151,141); 
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",62,154,28,172,63,18,241,170);
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",62,20,122,225,61,190,118,201); 
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",62,160,26,55,62,168,114,176); 
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",63,230,102,102,63,128,0,0); 
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",63,230,102,102,63,128,0,0); 
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",63,230,102,102,63,128,0,0); 
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",0,0,0,0,67,127,0,0); 
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",0,0,0,0,67,127,0,0); 
    PCL_sprintf(pdevobj, "%c%c%c%c%c%c%c%c",0,0,0,0,67,127,0,0); 
} 

///////////////////////////////////////////////////////////////////////////////
// PCL_ForegroundColor()
//
// Routine Description:
// 
//   Sets Foreground color to first entry of current pallete
//   Command sent  Esc*v0t0S"
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
// 
// Return Value:
// 
//   NOT REQUIRED
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_ForegroundColor(PDEVOBJ pdevobj, ULONG   uIndex) 
{
	VERBOSE(("PCL_ForegroundColor(). \r\n"));
    PCL_SelectCurrentPattern (pdevobj, NULL, kSolidBlackFg, UNDEFINED_PATTERN_NUMBER, 0);
	return PCL_sprintf(pdevobj, "\033*v%dS", uIndex);
}

///////////////////////////////////////////////////////////////////////////////
// PCL_IndexedPalette()
//
// Routine Description:
// 
//   Sends each RGB component to corresponding index in palette
//   Command sent  Esc*v%da%db%dc%dI
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//   pPattern - contains palette entries
//   uIndex - palette entry
// 
// Return Value:
// 
//   NOT REQUIRED
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_IndexedPalette(PDEVOBJ  pdevobj, ULONG uColor, ULONG  uIndex)
{
	VERBOSE(("PCL_IndexedPaletteEntry(). \r\n"));

	return PCL_sprintf(pdevobj, "\033*v%da%db%dc%dI", 
                                RED_VALUE(uColor), 
                                GREEN_VALUE(uColor),
                                BLUE_VALUE(uColor),
                                uIndex);
}

///////////////////////////////////////////////////////////////////////////////
// PCL_SourceWidthHeight()
//
// Routine Description:
// 
//   Sets Raster source dimensions
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//   sizlSrc      - Source rectangle
// 
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_SourceWidthHeight(PDEVOBJ pdevobj, SIZEL *sizlSrc)
{
    VERBOSE(("PCL_SourceWidthHeight(). \r\n"));

    return PCL_sprintf(pdevobj, "\033*r%ds%dT", sizlSrc->cx, sizlSrc->cy);
}

///////////////////////////////////////////////////////////////////////////////
// PCL_DestWidthHeight()
//
// Routine Description:
// 
//   Sets source raster width and height
//   Command sent  Esc*t%dh%dV
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//   uDestX  - height of destination rectangle
//   uDestY  - width of destination rectangle
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_DestWidthHeight(PDEVOBJ pdevobj, ULONG uDestX, ULONG uDestY)
{
	VERBOSE(("PCL_DestWidthHeight(). \r\n"));

    return PCL_sprintf(pdevobj, "\033*t%dh%dV", uDestX,  uDestY);
}

///////////////////////////////////////////////////////////////////////////////
// PCL_StartRaster()
//
// Routine Description:
// 
//   Sets source raster width and height
//   Command sent  Esc*r3A
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//   ubMode - mode defined in PCL spec
//            0 start raster at logical page left boundary
//            1 start raster at CAP
//            2 turn on scale mode and start  at logical page left boundary
//            3 turn on scale mode and start at CAP
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_StartRaster(
    PDEVOBJ  pDevObj,
    BYTE     ubMode
    )
{
    return PCL_sprintf(pDevObj, "\033*r%dA", ubMode);
}

///////////////////////////////////////////////////////////////////////////////
// PCL_SendBytesPerRow()
//
// Routine Description:
// 
//   Sends scan line to printer
//   Command sent  Esc*rC
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_SendBytesPerRow(PDEVOBJ  pdevobj, ULONG uRow)
{
    return PCL_sprintf(pdevobj, "\033*b%dW", uRow);
}

///////////////////////////////////////////////////////////////////////////////
// PCL_CompressionMode()
//
// Routine Description:
// 
//   Sends scan line to printer
//   Command sent  Esc*b#M
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_CompressionMode(PDEVOBJ pdevobj, ULONG compressionMode)
{
    return PCL_sprintf(pdevobj, "\033*b%dM", compressionMode);
}


///////////////////////////////////////////////////////////////////////////////
// PCL_EndRaster()
//
// Routine Description:
// 
//   Sets source raster width and height
//   Command sent  Esc*rC
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_EndRaster(PDEVOBJ  pdevobj)
{
    return PCL_sprintf(pdevobj, "\033*rC");
}

///////////////////////////////////////////////////////////////////////////////
// PCL_SelectOrientation() OBSOLETE
//
// Routine Description:
// 
//   Sets orientation
//   Command sent  Esc&l%dO
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_SelectOrientation(
    PDEVOBJ  pdevobj,
    short    dmOrientation
)
{
    switch (dmOrientation)
    {
    case DMORIENT_PORTRAIT:
        return PCL_sprintf(pdevobj, "\033&l0O");
        break;
    
    case DMORIENT_LANDSCAPE:
        return PCL_sprintf(pdevobj, "\033&l1O");
        break;
    default:
        return PCL_sprintf(pdevobj, "\033&l0O");
        ERR(("Orientation may be incorrect\n"));
        return FALSE;
    }
    
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// PCL_SelectPaperSize() OBSOLETE
//
// Routine Description:
// 
//   Sets orientation
//   Command sent  Esc&l%dO
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_SelectPaperSize(
    PDEVOBJ  pDevObj,
    short    dmPaperSize
)
{
    switch (dmPaperSize)
    {
        case DMPAPER_LETTER:
            PCL_sprintf (pDevObj, "\033&l2a8c1E");    
            break;
        case DMPAPER_LEGAL:
            PCL_sprintf (pDevObj, "\033&l3a8c1E");    
            break;
        case DMPAPER_TABLOID:
            PCL_sprintf (pDevObj, "\033&l6a8c1E");    
            break;
        case DMPAPER_EXECUTIVE:
            PCL_sprintf (pDevObj, "\033&l1a8c1E");    
            break;
        case DMPAPER_A3:
            PCL_sprintf (pDevObj, "\033&l27a8c1E");    
            break;
        case DMPAPER_A4:
            PCL_sprintf (pDevObj, "\033&l26a8c1E");    
            break;
        default:
            ERR(("Paper Size not supported\n"));
            return FALSE;
    }            
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// PCL_SelectCopies() OBSOLETE
//
// Routine Description:
// 
//   Sets the number of copies for the job.
//   Command sent  Esc&l%dO
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_SelectCopies(
    PDEVOBJ  pDevObj,
    short    dmCopies
)
{
    PCL_sprintf (pDevObj, "\033&l%dX", dmCopies);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// PCL_SelectPictureFrame() OBSOLETE
//
// Routine Description:
// 
//   Selects the picture frame for the current paper size.  I believe that the
//   unidrv is sending these values from the GPD now.
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//   dmPaperSize - paper size
//   dmOrientation - orientation
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_SelectPictureFrame(
    PDEVOBJ  pDevObj,
    short    dmPaperSize,
    short    dmOrientation
)
{
    switch (dmPaperSize)
    {
        case DMPAPER_LETTER:
            switch (dmOrientation)
            {
                case DMORIENT_PORTRAIT:
                    PCL_sprintf (pDevObj, "\033*c0t5760x7604Y");
                    break;
                case DMORIENT_LANDSCAPE:
                    PCL_sprintf (pDevObj, "\033*c0t7632x5880Y");
                    break;
                default:
                    ERR(("Unknown Orientation\n"));
                    return FALSE;
            }
            break;
        case DMPAPER_LEGAL: 
            switch (dmOrientation)
            {
                case DMORIENT_PORTRAIT:
                    PCL_sprintf (pDevObj, "\033*c0t5760x9864Y");
                    break;
                case DMORIENT_LANDSCAPE:
                    PCL_sprintf (pDevObj, "\033*c0t9792x5880Y");
                    break;
                default:
                    ERR(("Unknown Orientation\n"));
                    return FALSE;
            }
            break;
        case DMPAPER_TABLOID: 
            switch (dmOrientation)
            {
                case DMORIENT_PORTRAIT:
                    PCL_sprintf (pDevObj, "\033*c0t7560x12000Y");
                    break;
                case DMORIENT_LANDSCAPE:
                    PCL_sprintf (pDevObj, "\033*c0t11880x7680Y");
                    break;
                default:
                    ERR(("Unknown Orientation\n"));
                    return FALSE;
            }
            break;
        case DMPAPER_EXECUTIVE: 
            switch (dmOrientation)
            {
                case DMORIENT_PORTRAIT:
                    PCL_sprintf (pDevObj, "\033*c0t4860x7344Y");
                    break;
                case DMORIENT_LANDSCAPE:
                    PCL_sprintf (pDevObj, "\033*c0t7272x4980Y");
                    break;
                default:
                    ERR(("Unknown Orientation\n"));
                    return FALSE;
            }
            break;
        case DMPAPER_A3: 
            switch (dmOrientation)
            {
                case DMORIENT_PORTRAIT:
                    PCL_sprintf (pDevObj, "\033*c0t8057x11693Y");
                    break;
                case DMORIENT_LANDSCAPE:
                    PCL_sprintf (pDevObj, "\033*c0t11621x8177Y");
                    break;
                default:
                    ERR(("Unknown Orientation\n"));
                    return FALSE;
            }
            break;
        case DMPAPER_A4: 
            switch (dmOrientation)
            {
                case DMORIENT_PORTRAIT:
                    PCL_sprintf (pDevObj, "\033*c0t5594x8201Y");
                    break;
                case DMORIENT_LANDSCAPE:
                    PCL_sprintf (pDevObj, "\033*c0t8129x5714Y");
                    break;
                default:
                    ERR(("Unknown Orientation\n"));
                    return FALSE;
            }
            break;
        default:
            ERR(("Unknown Paper Size\n"));
            return FALSE;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// PCL_SelectSource() OBSOLETE
//
// Routine Description:
// 
//   Selects the source tray.
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//   pPublicDM - public DEVMODE structure
//
// Return Value:
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
PCL_SelectSource(
    PDEVOBJ  pDevObj,
    PDEVMODE pPublicDM
)
{
   POEMPDEV    poempdev;

    ASSERT(VALID_PDEVOBJ(pDevObj));

    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    switch (poempdev->PrinterModel)
    {
        case HPCLJ5:
            switch (pPublicDM->dmDefaultSource)
            {
                case DMBIN_FORMSOURCE:
                    PCL_sprintf (pDevObj, "\033&l1H");
                    break;

                case DMBIN_MANUAL:
                    PCL_sprintf (pDevObj, "\033&l2H");
                    break;

                case DMBIN_HPFRONTTRAY:
                    PCL_sprintf (pDevObj, "\033&l1H");
                    break;

                case DMBIN_HPREARTRAY:
                    PCL_sprintf (pDevObj, "\033&l4H");
                    break;
            }
            break;

        case HPC4500:
            break;

    default:
        ERR(("Unknown Printer Model\n"));
        return FALSE;
    }

    return TRUE;
}


BOOL PCL_SelectCurrentPattern(
    IN PDEVOBJ             pdevobj,
    IN PPCLPATTERN         pPattern,
    IN ECURRENTPATTERNTYPE eCurPatType, 
    IN LONG                lPatternNumber,
    IN BYTE                bFlags
    )
{
    CMDSTR       szCmdStr;
    int          iCmdLen; 
    BOOL         bRet          = TRUE;
    POEMPDEV     poempdev      = NULL;
    PPCLPATTERN  pPCLPattern   = NULL;  
    BOOL         bNewPattern   = FALSE;

    UNREFERENCED_PARAMETER(bFlags);

    REQUIRE_VALID_DATA( pdevobj, return FALSE );
 
    //
    // If pPattern passed NULL, then use the one in poempdev
    //
    if ( ! (pPCLPattern = pPattern) )
    {
        poempdev = (POEMPDEV)pdevobj->pdevOEM;
        REQUIRE_VALID_DATA( poempdev, return FALSE );
        pPCLPattern = &((poempdev->RasterState).PCLPattern);
        REQUIRE_VALID_DATA( pPCLPattern, return FALSE );
    }

    //
    // 
    //
    if ( (lPatternNumber != UNDEFINED_PATTERN_NUMBER) &&
         (lPatternNumber != pPCLPattern->lPatIndex )
       )
    {
        bNewPattern            = TRUE;
        iCmdLen                = iDrvPrintfSafeA((PCHAR)szCmdStr, CCHOF(szCmdStr), "\x1B*c%dG", (DWORD)lPatternNumber);
        bRet                   = PCL_Output(pdevobj, szCmdStr, iCmdLen);
        pPCLPattern->lPatIndex = lPatternNumber;
    }

    //
    // If a pattrn with a new number is being sent OR 
    // the pattern is different from the one sent last, then ...
    //
    if (  bNewPattern                        ||
//         (eCurPatType == kUserDefined)       ||
         (pPCLPattern->eCurPatType != eCurPatType)  
       )
    {
        iCmdLen                  = iDrvPrintfSafeA((PCHAR)szCmdStr, CCHOF(szCmdStr), "\x1B*v%dT", eCurPatType);
        bRet                     = PCL_Output(pdevobj, szCmdStr, iCmdLen);
        pPCLPattern->eCurPatType = eCurPatType;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\ras_proc.h ===
#ifndef _RASTER_PROCESSOR_H
#define _RASTER_PROCESSOR_H

///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Header File Name:
//
//    ras_proc.h
//
// Abstract:
//
//    Function declarations
//
// Environment:
//
//   Windows NT Unidrv driver
//
///////////////////////////////////////////////////////////////////////////////


#include "glpdev.h"

#define NOSCALE_MODE      (BYTE) 1
#define SCALE_MODE        (BYTE) 3
typedef struct _COMPDATA
{
    PBYTE   pTIFFCompBuf;
    PBYTE   pDeltaRowCompBuf;
    PBYTE   pRLECompBuf;
    PBYTE   pSeedRowBuf;
    PBYTE   pBestCompBuf;
    ULONG   bestCompMethod;
    ULONG   lastCompMethod;
    ULONG   bestCompBytes;

}   COMPDATA,  *PCOMPDATA;

//
// Used to convert different pixles depths
//
typedef struct _XLATEINFO
{
    PBYTE     pSrcBuffer;
    PBYTE     pDestBuffer;
    ULONG     ulSrcBpp;
    ULONG     ulDestBpp;

} XLATEINFO, *PXLATEINFO;

BOOL
XLINFO_SetXLInfo (
    XLATEINFO *pxlInfo,
    PBYTE      pSrcBuffer,
    PBYTE      pDestBuffer,
    ULONG      ulSrcBpp,
    ULONG      ulDestBpp
    );

VOID
VGeneratePCL (
    PDEVOBJ pDevObj
    );

BOOL
BCheckValidParams(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMask,
    CLIPOBJ  *pco
    );


VOID
VGetOSBParams(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc,
    RECTL    *prclDest, 
    RECTL    *prclSrc,
    SIZEL    *sizlDest,
    SIZEL    *sizlSrc, 
    POINTL   *ptlDest,
    POINTL   *ptlSrc
    );

VOID
VGetparams(
    RECTL  *prclDest,
    SIZEL  *sizlDest,
    POINTL *ptlDest
    );

BOOL
BProcessScanLine(
    PDEVOBJ   pdevobj,
    SURFOBJ  *psoSrc,
    POINTL   *ptlSrc,
    SIZEL    *sizlSrc,
    XLATEOBJ *pxlo,
    ULONG     ulSrcBpp,
    ULONG     ulDestBpp
    );

ULONG
UPrinterDeviceUnits(
    ULONG uDev,
    ULONG uRes
    );

ULONG
UReverseDecipoint(
    ULONG uDest,
    ULONG uRes
    );

BOOL  
BGenerateBitmapPCL(
    PDEVOBJ   pdevobj,
    SURFOBJ  *psoSrc,
    BRUSHOBJ *pbo,
    POINTL   *ptlDest,
    SIZEL    *sizlDest,
    POINTL   *ptlSrc,
    SIZEL    *sizlSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    POINTL   *pptlBrushOrg
    );          

BOOL
BSelectClipRegion(
    PDEVOBJ  pdevobj,
    CLIPOBJ *pco,
    SIZEL   *sizlSrc
    );

BOOL
BSetDestinationWidthHeight(
    PDEVOBJ  pdevobj,
    ULONG    xDest,
    ULONG    yDest
    );

VOID 
VSendCompressedRow(
    PDEVOBJ   pdevobj,
    PCOMPDATA pcompdata
    );

BOOL 
BIsComplexClipPath (
    CLIPOBJ  *pco
    );

BOOL 
BIsRectClipPath (
    CLIPOBJ  *pco
    );

BOOL    
BProcessClippedScanLines (
    PDEVOBJ   pDevObj,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    POINTL   *ptlSrc,
    POINTL   *ptlDest,
    SIZEL    *sizlDest
    );

BOOL 
BEnumerateClipPathAndDraw (
    PDEVOBJ pDevObj,
    CLIPOBJ *pco,
    RECTL   *prclDest
    );

BOOL
BRectanglesIntersect (
    RECTL  *prclDest,
    RECTL  *pclipRect,
    RECTL  *presultRect
    );

VOID
VColorTranslate (
    XLATEINFO *pxlInfo,
    XLATEOBJ  *pxlo,
    ULONG      cx,
    ULONG      ulDestScanlineInByte
    );

ULONG
ULConvertPixelsToBytes (
    ULONG cx,
    ULONG ulSrcBpp,
    ULONG ulDestBpp
    );

VOID
DoCompression (
    BYTE     *pDestBuf, 
    COMPDATA *pCompdata,
    ULONG     cBytes,
    ULONG     cCompBytes
    );

VOID vInvertScanLine (
    IN OUT PBYTE pCurrScanline,
    IN     ULONG ulNumPixels);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\rasdata.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
// 
// Module Name:
// 
//   rasdata.h
// 
// Abstract:
// 
//   
// 
// Environment:
// 
//   Windows 2000/Whistler Unidrv driver 
//
// Revision History:
// 
//   07/02/97 -v-jford-
//       Created it.
// 
///////////////////////////////////////////////////////////////////////////////

#ifndef RASTER_DATA_H
#define RASTER_DATA_H

#ifndef _ERENDERLANGUAGE
#define _ERENDERLANGUAGE
typedef enum { ePCL,
               eHPGL,
               eUNKNOWN
               } ERenderLanguage;
#endif

typedef enum {
            kUNKNOWN,
            kIMAGE,              // Actual Image.
            kBRUSHPATTERN,       // A pattern obtained from a brush.
            kCOLORDITHERPATTERN, // special type of pattern (dither pattern representing a color)
            kHATCHBRUSHPATTERN   // special type of pattern (pattern that reprsents the hatch brush)
            } EIMTYPE;

//
// The MAX_PATTERNS stores the max number of patterns that can exist
// concurrently. It is initialized to 8 because the RF command
// guarantees that atleast 8 patterns can exist simultaneously.
// There may be some devices that have more, but lets just fix it
// to 8.
// Page 142 of "The HP-GL/2 and HP RTL Reference Guide. A
// Handbook for Program Developers" published by HP
//
#define MAX_PATTERNS        8

#define     VALID_PATTERN   (0x1)
#define     VALID_PALETTE   (0x1 << 1)

#define GET_COLOR_TABLE(pxlo) \
        (((pxlo)->flXlate & XO_TABLE) ? \
           ((pxlo)->pulXlate ? (pxlo)->pulXlate : XLATEOBJ_piVector(pxlo)) : \
           NULL)

typedef enum {
    eBrushTypeNULL,
    eBrushTypeSolid,
    eBrushTypeHatch,
    eBrushTypePattern
} BRUSHTYPE;


typedef struct _RASTER_DATA
{
    BYTE *pBits;        // Pointer to first byte of raster data
    BYTE *pScan0;       // Pointer to first ROW of raster data
    ULONG cBytes;       // Number of bytes of raster data and padding
    SIZEL size;         // The dimensions of the bitmap in pixels
    LONG  lDelta;       // The distance between a given row and the next (negative for bottom-up)
    LONG  colorDepth;   // Bits per pixel expressed as an integer, usually 1, 4, 8, 16, 24, or 32
    LONG  eColorMap;    // Palette mode: usually HP_eDirectPixel, or HP_eIndexedPixel.
    BOOL  bExclusive;   // Image is bottom-right exclusive
} RASTER_DATA, *PRASTER_DATA;


#define MAX_PALETTE_ENTRIES 256
typedef struct _PALETTE
{
    LONG  bitsPerEntry; // Bits per palette entry expressed as an integer, usually 8, 24, or 32
    ULONG cEntries;
    BYTE *pEntries;
#ifdef COMMENTEDOUT
    LONG  whiteIndex; // When set > 0 this is the palette index for white
#endif
} PALETTE, *PPALETTE;

typedef struct _PATTERN_DATA
{
    LONG        iPatIndex;   // Unique identifier for pattern (i.e. for caching)
    RASTER_DATA image;       // The raster image data
    DWORD       eColorSpace; // Expression color bits, usually HP_eRGB, or HP_eGray
    PALETTE     palette;
    ERenderLanguage  eRendLang; // Whether the pattern should be downloaded as HPGL or PCL ?
    EIMTYPE ePatType; // Whether this data represents brush pattern or dither pattern.
} PATTERN_DATA, *PPATTERN_DATA;

typedef struct {  
    PPATTERN_DATA pPattern;   // The Pattern Type to be used.
    DWORD         dwRGBColor; // RGB color values used to set a paint source. (0 - 255)
    LONG          iHatch;
    BYTE          GrayLevel;  // The level of gray for the paint source is
                              // expressed as an intensity leve, zero
                              // being lowest intensity. (0 - 255)
} UBRUSH, *PUBRUSH;

typedef struct _BRUSHINFO {
  DWORD      dwPatternID;
  ULONG      ulFlags;          // Which entities are valid. (IMAGE/PALETTE/both)
  BOOL       bNeedToDownload;
  POINTL     origin;           // This is the origin(location) where the brush is active.
  UBRUSH     Brush;            // This is the actual brush.
} BRUSHINFO, *PBRUSHINFO;

BOOL InitRasterDataFromSURFOBJ(
        PRASTER_DATA  pImage, 
        SURFOBJ      *psoPattern, 
        BOOL          bExclusive);

//
// -hsingh- Added parameter bInvert and defaulting it to TRUE. 
// GDI gives us inverted images for both pattern brushes and the actual images.
// So we have to invert it before rendering. There may be some cases when we dont
// have to invert. I have decided to put the parameter bInvert and default it to TRUE.
//
BOOL CopyRasterImage(
        PRASTER_DATA  pDst, 
        PRASTER_DATA  pSrc, 
        XLATEOBJ     *pxlo, 
        BOOL          bInvert);

BOOL CopyRasterImageRect(
        PRASTER_DATA pDst, 
        PRASTER_DATA pSrc, 
        PRECTL       rSelection, 
        XLATEOBJ    *pxlo, 
        BOOL         bInvert);

BOOL StretchCopyImage(
        PRASTER_DATA  pDstImage, 
        PRASTER_DATA  pSrcImage, 
        XLATEOBJ     *pxlo, 
        DWORD         dwBrushExpansionFactor,
        BOOL          bInvert);

BOOL DownloadImageAsHPGLPattern(
        PDEVOBJ       pDevObj, 
        PRASTER_DATA  pImage, 
        PPALETTE      pPal, 
        LONG          iPatternNumber);

BOOL DownloadImageAsPCL(
        PDEVOBJ       pDevObj, 
        PRECTL        prDst, 
        PRASTER_DATA  pImage, 
        PRECTL        prSel, 
        XLATEOBJ     *pxlo);

BOOL InitPaletteFromXLATEOBJ(
        PPALETTE      pPal, 
        XLATEOBJ     *pxlo);

BOOL CopyPalette(
        PPALETTE      pDst, 
        PPALETTE      pSrc);

VOID TranslatePalette(
        PPALETTE      pPal, 
        PRASTER_DATA  pImage, 
        XLATEOBJ     *pxlo);

// BOOL InitPalette(PPALETTE pPal, PBYTE pEntries, ULONG cEntries, LONG bitsPerEntry);
BOOL DownloadPaletteAsPCL(
        PDEVOBJ       pDevObj, 
        PPALETTE      pPalette);

BOOL DownloadPaletteAsHPGL(
        PDEVOBJ       pDevObj, 
        PPALETTE      pPalette);

BOOL DownloadPatternAsHPGL(
        PDEVOBJ         pDevObj, 
        PRASTER_DATA    pImage,
        PPALETTE        pPal, 
        EIMTYPE         ePatType,
        LONG            iPatternNumber);


PBRUSHINFO CreateCompatiblePatternBrush(
        BRUSHOBJ     *pbo, 
        PRASTER_DATA  pSrcImage, 
        PPALETTE      pSrcPal, 
        DWORD         dwBrushExpansionFactor,
        LONG          iUniq, 
        LONG          iHatch);

PPALETTE CreateIndexedPaletteFromImage(
        PRASTER_DATA   pSrcImage);

PRASTER_DATA CreateIndexedImageFromDirect(
        PRASTER_DATA   pSrcImage, 
        PPALETTE       pDstPalette);

///////////////////////////////////////////////////////////////////////////////
// Low level operations

typedef union _DW4B
{
    DWORD	dw;
    BYTE	b4[4];
} DW4B;

typedef struct _RASTER_ITERATOR
{
    PRASTER_DATA pImage;
    RECTL        rSelection;
    BYTE        *pCurRow;
    DWORD        fXlateFlags;
} RASTER_ITERATOR, *PRASTER_ITERATOR;

typedef struct _PIXEL
{
    LONG bitsPerPixel;
    DW4B color;
} PIXEL, *PPIXEL;

ULONG CalcBitmapSizeInBytes(SIZEL size, LONG colorDepth);
ULONG CalcBitmapDeltaInBytes(SIZEL size, LONG colorDepth);
ULONG CalcBitmapWidthInBytes(SIZEL size, LONG colorDepth);

DWORD CalcPaletteSize(ULONG cEntries, LONG bitsPerEntry);

VOID RI_Init(
    PRASTER_ITERATOR pIt, 
    PRASTER_DATA     pImage, 
    PRECTL           prSel, 
    DWORD            xlateFlags
    );
VOID RI_SelectRow(PRASTER_ITERATOR pIt, LONG row);
LONG RI_NumRows(PRASTER_ITERATOR pIt);
LONG RI_NumCols(PRASTER_ITERATOR pIt);
BOOL RI_OutputRow(PRASTER_ITERATOR pIt, PDEVOBJ pDevObj, BYTE *pAltRowBuf = 0, INT nAltRowSize = 0);
BOOL RI_GetPixel(PRASTER_ITERATOR pIt, LONG col, PPIXEL pPel);
BOOL RI_SetPixel(PRASTER_ITERATOR pIt, LONG col, PPIXEL pPel);
// BYTE *RI_CreateCompRowBuffer(PRASTER_ITERATOR pIt);
LONG RI_GetRowSize(PRASTER_ITERATOR pIt);
VOID RI_VInvertBits(PRASTER_ITERATOR pIt);

BOOL TranslatePixel(PPIXEL pPel, XLATEOBJ *pxlo, DWORD xlateFlags);

BOOL CopyRasterRow(
        PRASTER_ITERATOR pDstIt, 
        PRASTER_ITERATOR pSrcIt, 
        XLATEOBJ *pxlo, 
        BOOL bInvert = TRUE);

VOID PixelSwapRGB(PPIXEL pPel);
LONG OutputPixel(PDEVOBJ pDevObj, PPIXEL pPel);

BOOL SetPaletteEntry(PPALETTE pPal, ULONG index, PPIXEL pPel);
BOOL GetPaletteEntry(PPALETTE pPal, ULONG index, PPIXEL pPel);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\penbrush.h ===
///////////////////////////////////////////////////////////////////////////////
// 
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
// 
//   penbrush.h
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   08/06/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#ifndef PENBRUSH_H
#define PENBRUSH_H

enum { eFillEvenOdd, eFillWinding };


BOOL CreateHPGLPenBrush(
    IN  PDEVOBJ       pDevObj,
    IN  PHPGLMARKER   pMarker,
    IN  POINTL       *pptlBrushOrg,
    IN  BRUSHOBJ     *pbo,
    IN  FLONG         flOptions,
    IN  ESTYLUSTYPE   eStylusType,
    IN  BOOL          bStick);

BOOL CreateAndDwnldSolidBrushForMono(
        IN  PDEVOBJ         pDevObj,
        IN  PHPGLMARKER     pMarker,
        IN  BRUSHOBJ       *pbo,
        IN  ERenderLanguage eRenderLang,
        IN  BOOL            bStick);

BOOL
BSetupBRUSHINFOForSolidBrush(
        IN  PDEVOBJ     pdevobj,
        IN  LONG        iHatch,
        IN  DWORD       dwPatternID,
        IN  DWORD       dwColor,
        IN  PBRUSHINFO  pBrush,
        IN  LONG        lBrushSize);

BDwnldAndOrActivatePattern(
        IN  PDEVOBJ       pDevObj,
        OUT PHPGLMARKER   pMarker,
        IN  BRUSHINFO    *pBrushInfo,
        IN  HPGL2BRUSH   *pHPGL2Brush,
        IN  ERenderLanguage eRenderLang );

BYTE RgbToGray64Scale ( 
        IN   COLORREF color);

BOOL CreateNULLHPGLPenBrush(PDEVOBJ pDevObj, PHPGLMARKER pMarker);
BOOL CreateSolidHPGLPenBrush(PDEVOBJ pDevObj, PHPGLMARKER pMarker, COLORREF color);
BOOL CreatePercentFillHPGLPenBrush(PDEVOBJ pDevObj, PHPGLMARKER pMarker, COLORREF color, WORD wPercent);
BOOL DrawWithPen(PDEVOBJ pdevobj, PHPGLMARKER pMarker);
BOOL EdgeWithPen(PDEVOBJ pdevobj, PHPGLMARKER pMarker);

BOOL FillWithBrush(PDEVOBJ pdevobj, PHPGLMARKER pMarker);
BOOL PolyFillWithBrush(PDEVOBJ pdevobj, PHPGLMARKER pMarker);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\ras_proc.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved.

Module Name:
    ras_proc.cpp

Abstract:
    Implementation of support functions for glraster.cpp

Author:
  
Revision History: 

--*/


#include "hpgl2col.h" //Precompiled header file


//
// Pixel to byte/scanline conversion macros
//

#define BITS_TO_BYTES(bits) (((bits) + 7) >> 3)
#define PIX_TO_BYTES(pix, bpp) BITS_TO_BYTES((pix) * (bpp))
#define PIX_TO_BYTES_ALIGNED(pix, bpp) DW_ALIGN(PIX_TO_BYTES((pix), (bpp)))

//
// Defines for PCL5 compression methods
//
#define     NOCOMPRESSION   0
#define     RLE             1
#define     TIFF            2
#define     DELTAROW        3

//
// Similar to vInvertBits defined in unidrv2\render\render.c
//
void
VInvertBits (
    DWORD  *pBits,
    INT    cDW
    );

//
// Compression info
//

BOOL BAllocateCompBuffers(PBYTE &pDestBuf, COMPDATA &compdata, ULONG ulSize, ULONG &cCompBytes);
BOOL BCheckMemory(PBYTE lBuf, COMPDATA &compdata);
VOID VFreeCompBuffers(PBYTE &pDestBuf, COMPDATA &compdata);

#define BUF_SIZE 2048
////////////////////////////////////////////////////////////////////////////
//
// Routine Description:
// ====================
//
//  Function determines if 
//  arguments are valid
//  
//
// Arguments:
//
//   psoDest - Destination Surface
//   psoSrc  - Source Surface
//   psoMask - Mask surface
//   pco     - Clipobject
//
// Return Value:
//   True if valid, false otherwise
////////////////////////////////////////////////////////////////////////////
BOOL
BCheckValidParams(
    SURFOBJ  *psoDest,
    SURFOBJ  *psoSrc, 
    SURFOBJ  *psoMask, 
    CLIPOBJ  *pco
)
{

    BOOL bRetVal = TRUE;
    REQUIRE_VALID_DATA( psoSrc, return FALSE );
    REQUIRE_VALID_DATA( psoDest, return FALSE );
    
    VERBOSE(("ValidParams: Surface Type =%d&&Dest Type = %d \r\n", 
              psoSrc->iType,psoDest->iType ));

    //
    // Masks are implemented though the output may not be 
    // as expected. 
    //
    if (psoMask)
    {
        WARNING(("Mask partially supported.\r\n"));
    }

    if ((pco) && (pco->iDComplexity == DC_COMPLEX))
    {
        WARNING(("pco->iDComplexity == DC_COMPLEX \r\n"));
    }

    return bRetVal;

}


////////////////////////////////////////////////////////////////////////////
// VGetOSBParams()
//
// Routine Description:
// ====================
//
//  Function extracts parameters from
//  rectangle and stores information in respective fields
//  
//
// Arguments:
// ==========
//
// prclDest - destination rectangle
// prclSrc  - source rectangle
// sizlDest - stores width and length of destination
// sizlSrc  - stores width and length of source
// ptlDest  - stores (left,top) of destination
// ptlSrc       - stores (left,top) of source
//
// Return Value:
// =============
//
// None
////////////////////////////////////////////////////////////////////////////
VOID
VGetOSBParams(
    SURFOBJ   *psoDest,
    SURFOBJ   *psoSrc,
    RECTL     *prclDest,
    RECTL     *prclSrc,
    SIZEL     *sizlDest, 
    SIZEL     *sizlSrc,
    POINTL    *ptlDest, 
    POINTL    *ptlSrc
)

{
    REQUIRE_VALID_DATA( psoSrc, return );
    REQUIRE_VALID_DATA( psoDest, return );
    REQUIRE_VALID_DATA( prclSrc, return );
    REQUIRE_VALID_DATA( prclDest, return );

    //
    //check if destination is not well ordered
    //
    if(prclDest->right < prclDest->left)
    {
       VERBOSE(("OEMStretchBlt: destination not well ordered. \r\n"));
       ptlDest->x = prclDest->right;
       sizlDest->cx = prclDest->left - prclDest->right;
    }
    else
    {
       ptlDest->x = prclDest->left;
       sizlDest->cx = prclDest->right - prclDest->left;
    }

    //
    // check if destination is not well ordered
    //
    if(prclDest->bottom < prclDest->top)
    {
     
       VERBOSE(("OEMStretchBlt: destination not well ordered. \r\n"));
       ptlDest->y = prclDest->bottom;
       sizlDest->cy = prclDest->top - prclDest->bottom;
    }
    else
    {
      ptlDest->y = prclDest->top;
      sizlDest->cy = prclDest->bottom - prclDest->top;
    }

	ptlSrc->x = prclSrc->left;
	ptlSrc->y = prclSrc->top;

    sizlSrc->cx = prclSrc->right - prclSrc->left;
    sizlSrc->cy = prclSrc->bottom - prclSrc->top;
}

///////////////////////////////////////////////////////////////////////////////
//
// Getparams()
//
// Routine Description:
// ====================
//
//  Function extracts parameters from
//  rectangle and stores information in respective fields
//  
//
// Arguments:
// ==========
//
//   prclDest - destination rectangle
//   sizlDest - stores width and length of destination
//   ptlDest  - stores (left,top)
//
// Return Value:
//   None
//
///////////////////////////////////////////////////////////////////////////////
VOID
VGetparams(
    RECTL     *prclDest,
    SIZEL     *sizlDest,
    POINTL    *ptlDest
)
{


    ptlDest->x = prclDest->left;
    ptlDest->y  = prclDest->top;

    sizlDest->cx = prclDest->right - prclDest->left;
    sizlDest->cy = prclDest->bottom - prclDest->top;

}

///////////////////////////////////////////////////////////////////////////////
//
// BGenerateBitmapPCL()
//
// Routine Description:
//
//   This routine takes source and destination arguments 
//   that specify pcl generation
//
// Arguments:
//
//   pdevobj  - default devobj
//   psoDest  - destination object
//   psoSrc   - pointer to source object
//   pco      - pointer to clip object
//   pxlo     - pointer to translation object
//   prclDest - pointer to destination rectangle
//   prclSrc  - pointer to source rectangle
//
// Return Value:
//   True if succesful, false otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL  
BGenerateBitmapPCL(
    PDEVOBJ    pdevobj, 
    SURFOBJ    *psoSrc, 
    BRUSHOBJ   *pbo,
    POINTL     *ptlDest,
    SIZEL      *sizlDest, 
    POINTL     *ptlSrc, 
    SIZEL      *sizlSrc, 
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo, 
    POINTL     *pptlBrushOrg)             
{
    PCLPATTERN *pPCLPattern;
    ULONG       ulSrcBpp, ulDestBpp;
    POEMPDEV    poempdev;
    BOOL        bReturn = FALSE;
    
    //
    // check for valid parameters
    //
    ASSERT_VALID_PDEVOBJ(pdevobj);
    REQUIRE_VALID_DATA( psoSrc, return FALSE );
    REQUIRE_VALID_DATA( psoSrc->pvBits, return FALSE );
    ASSERT(psoSrc->iType == STYPE_BITMAP);
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    if (!poempdev)
        return FALSE;

    //
    // Bug# xxxxxx
    // Zero-area raster fill causing incorrect placement of raster glyphs
    //
    if ((sizlSrc->cx == 0) || (sizlSrc->cy == 0))
    {
        return TRUE;
    }

    //
    // Get bitmap information 
    //
    pPCLPattern = &(poempdev->RasterState.PCLPattern);
    if (!BGetBitmapInfo(sizlSrc, 
                        psoSrc->iBitmapFormat, 
                        pPCLPattern, 
                        &ulSrcBpp, 
                        &ulDestBpp))
        return FALSE;

    PCL_SetCAP(pdevobj, pbo, pptlBrushOrg, ptlDest);

    if ( BIsColorPrinter(pdevobj) )
    {
        if(BGetPalette(pdevobj, pxlo, pPCLPattern, ulSrcBpp, pbo))
        {
           ;
        }

        BSetForegroundColor(pdevobj, pbo, pptlBrushOrg, pPCLPattern, ulSrcBpp); 
    }

    if (BIsComplexClipPath (pco))
    {
        return BProcessClippedScanLines (pdevobj,
                                         psoSrc,
                                         pco,
                                         pxlo,
                                         ptlSrc,
                                         ptlDest,
                                         sizlDest);
    }

    //
    // The plugin was originally written for color HPGL printers, which supported
    // the destination raster height/width command (i.e. Esc*t#V, Esc*t#H).
    // This command allows the printer to do the scaling.
    // So if source/destination image size were different, (or if the clip region 
    // so dictated) we could start raster mode in SCALE_MODE and allow printer 
    // to do the scaling. 
    // But most monochrome HP printers do not support this command, so there is no
    // use of setting the Destination raster width/height. Also Raster mode should be
    // entered with NOSCALE_MODE.
    //

    // 
    // The best way to find out whether a printer supports scaling is by using
    // the gpd. But for now, lets just assume that if the printer is color, it supports
    // scaling. 
    //
    if ( BIsColorPrinter(pdevobj) ) 
    {
        //
        // Sets destination width/height
        //
        if (!BSelectClipRegion(pdevobj,pco, sizlDest))
        {
            WARNING(("bSelectClipRegion failed\n"));
            return FALSE;
        }

        PCL_SourceWidthHeight(pdevobj,sizlSrc);

        PCL_StartRaster(pdevobj, SCALE_MODE);
    }
    else    
    {
        //BUGBUG: What to do with clip rectangle.
        PCL_SourceWidthHeight(pdevobj,sizlSrc);
        PCL_StartRaster(pdevobj, NOSCALE_MODE);
    }

    bReturn = BProcessScanLine(pdevobj,
                               psoSrc,
                               ptlSrc,
                               sizlSrc,
                               pxlo,
                               ulSrcBpp, 
                               ulDestBpp);
    //
    // End raster
    //
    PCL_EndRaster(pdevobj);

    return bReturn;
}

///////////////////////////////////////////////////////////////////////////////
//
// BSelectClipRegion()
//
// Routine Description:
// 
//   Uses pco to set source raster width and height
//   
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//   pco - clip region
//   sizlDest - destination raster coordinates
//
// Return Value:
// 
//   True if successful, false otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL
BSelectClipRegion(
    PDEVOBJ    pdevobj, 
    CLIPOBJ    *pco, 
    SIZEL      *sizlDest
    )
{
    ULONG  xDest, yDest;


      if (pco == NULL)
    {
        xDest = sizlDest->cx;
        yDest = sizlDest->cy;
        return BSetDestinationWidthHeight(pdevobj, xDest, yDest);
    }
    else
    {
        switch (pco->iDComplexity)
        {
        case DC_TRIVIAL:
             VERBOSE(("pco->iDComplexity ==DC_TRIVIAL \r\n"));
             xDest = sizlDest->cx;
             yDest = sizlDest->cy;
             return BSetDestinationWidthHeight(pdevobj, xDest, yDest);

        case DC_RECT:
             VERBOSE(("pco->iDComplexity == DC_RECT \r\n"));
             xDest = pco->rclBounds.right - pco->rclBounds.left;
             yDest = pco->rclBounds.bottom - pco->rclBounds.top;
             return BSetDestinationWidthHeight(pdevobj, xDest, yDest);

        case DC_COMPLEX:
             WARNING(("pco->iDComplexity == DC_COMPLEX \r\n"));
             return BSetDestinationWidthHeight(pdevobj, sizlDest->cx, sizlDest->cy);

        default:
             ERR(("Invalid pco->iDComplexity.\n"));
             return FALSE;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// bSetDestinationWidthHeight()
//
// Routine Description:
// 
//   Sets destination width and height based
//   information contained in sizldest
//   
//
// Arguments:
// 
//   pdevobj - Points to our PDEVOBJ structure
//   xDest - width of raster bitmap
//   yDest - height of raster bitmap
//
// Return Value:
// 
//   True if successful, false otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL
BSetDestinationWidthHeight(
    PDEVOBJ  pdevobj, 
    ULONG    xDest, 
    ULONG    yDest
    )
{
  
  POEMPDEV    poempdev;
  ULONG  uDestX, uDestY;
  ULONG  uXRes, uYRes;


    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

  //
  // convert width and height to decipoints
  //
  VERBOSE(("Setting Destination Width and Height \r\n"));

  //
  // Get resolution
  //
    switch (poempdev->dmResolution)
    {
        case PDM_1200DPI:
            uXRes = uYRes = DPI_1200;
            break;
        
        case PDM_300DPI:
            uXRes = uYRes = DPI_300;
            break;
        
        case PDM_600DPI:
            uXRes = uYRes = DPI_600;
            break;

        case PDM_150DPI:
            uXRes = uYRes = DPI_150;
            break;

        default:
            WARNING(("Resolution not found\n"));
            uXRes = uYRes = DPI_300;
    }


    uDestX = UPrinterDeviceUnits(xDest, uXRes);
    uDestY = UPrinterDeviceUnits(yDest ,uYRes);

    if (uDestY == 0)
    {
        WARNING(("Destination Height is 0\n"));
    }
  //
  // firmware defect .. adjust destination in case of rounding of error
  //
  switch (poempdev->PrinterModel)
  {
   case HPCLJ5:
     if (UReverseDecipoint(uDestY, uYRes) < yDest)
     {
      //
      // remove  hairline between raster blocks
      //
      uDestY += 2;  
     }
     else if (UReverseDecipoint(uDestX, uXRes) < xDest) 
     {
      //
      // remove hairline between raster blocks
      //
      uDestX += 2;  
     } 
     
     //
     //set Destination Raster Width
     //
     return PCL_DestWidthHeight(pdevobj, uDestX, uDestY);
   default:
     return PCL_DestWidthHeight(pdevobj, uDestX, uDestY);
  }


}

///////////////////////////////////////////////////////////////////////////////
//
// UPrinterDeviceUnits
//
// Routine Description:
// 
//   
//
// Arguments:
// 
//   uDev - 
//   uRes - 
//
// Return Value:
// 
//   True if successful, false otherwise
//
///////////////////////////////////////////////////////////////////////////////
ULONG
UPrinterDeviceUnits(
    ULONG uDev,
    ULONG uRes
)
{
    ULONG uDeci;
    BOOL  bRet;
    FLOAT flDeci;
    FLOAT flCheck;
    FLOAT flNum;
    BYTE pBuffer[BUF_SIZE];
    
    //
    // Nolan's algo
    //
    flDeci = ((float)uDev * 720 + (uRes >> 1 )) / uRes;
    flNum = 0.5;
    flCheck = (ULONG)flDeci + flNum;        
    

    if (flDeci < flCheck)
        return (ULONG)flDeci; 
    else 
        return (ULONG)flDeci + 1;
    
}

///////////////////////////////////////////////////////////////////////////////
//
// uReverseDecipoint
//
// Routine Description:
// 
//   
//
// Arguments:
// 
//   uDest - 
//   uRes - 
//
// Return Value:
// 
//   True if successful, false otherwise
//
///////////////////////////////////////////////////////////////////////////////
ULONG
UReverseDecipoint(
    ULONG uDest,
    ULONG uRes
)
{
    ULONG uRevDeci;
    FLOAT flRevDeci;
    FLOAT flCheck;
    FLOAT flNum;
    BOOL  bRet;
    BYTE pBuffer[BUF_SIZE];
    

    flRevDeci = ((float)uDest * uRes)  / 720;
    flNum = 0.5;
    flCheck = (ULONG)flRevDeci + flNum;

    if (flRevDeci < flCheck)
        return (ULONG)flRevDeci; 
    else 
        return (ULONG)flRevDeci + 1;
}


///////////////////////////////////////////////////////////////////////////////
//
// BProcessScanLine
//
// Routine Description:
// ====================
//
//   This routine takes source and destination arguments 
//   that sends scanline at a time to printer
//
// Arguments:
// ==========
//
//   pdevobj  - default devobj
//   psoSrc   - pointer to source object
//   ptlSrc   - left, top position of source bitmap
//   sizlSrc  - width and height of source bitmap
//   pxlo     - pointer to translation object 
//   ulSrcBpp -  source bits per pixel
//   ulDestBpp - destination bits per pixel
//
// Return Value:
// True if succesful, false otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL
BProcessScanLine(
    PDEVOBJ   pDevObj, 
    SURFOBJ  *psoSrc, 
    POINTL   *ptlSrc, 
    SIZEL    *sizlSrc, 
    XLATEOBJ *pxlo, 
    ULONG     ulSrcBpp, 
    ULONG     ulDestBpp
)
{
    PBYTE      pDestBuf = NULL;
    LONG       delta;
    LONG       lOffset;
    PBYTE      pCurrScanline;
    LONG       curScanline;
    ULONG      ulDestScanlineInByte;
    POEMPDEV   poempdev = NULL;
    XLATEINFO  xlInfo;
    BOOL       bInvert = FALSE; //Whether a monochrome image needs to be inverted.

    COMPDATA         compdata;
    ULONG            cCompBytes = 0;

    ASSERT_VALID_PDEVOBJ(pDevObj);
    REQUIRE_VALID_DATA( psoSrc, return FALSE );
    REQUIRE_VALID_DATA( psoSrc->pvBits, return FALSE );
    ASSERT(psoSrc->iType == STYPE_BITMAP);

    poempdev = (POEMPDEV)pDevObj->pdevOEM;

    if (!poempdev)
        return FALSE;

    //
    // initialize delta which is the number of bytes to the
    // next scanline.
    //
    delta = psoSrc->lDelta; 

    //
    // Initialize scan line
    //
    lOffset = PIX_TO_BYTES(ptlSrc->x, ulSrcBpp);

    if (ptlSrc->y == 0) 
    {
       pCurrScanline = (unsigned char *) psoSrc->pvScan0 + lOffset;
    }
    //
    // if raster is sent in blocks of data, adjust offset of 1st 
    // scanline in next block.
    //
    else 
    {
        //
        // BUGBUG pCurrScanline does not take into account ptlSrc->x for
        // the offset. Pub file has a pptlSrc->x = 6 and pptlSrc->y =12
        // so pCurrScanline is off by 6 bytes
        //
        VERBOSE(("TOP IS NOT NULL--->ptlSrc->y=%d, sizlSrc->cy=%d\r\n", ptlSrc->y, sizlSrc->cy));
        pCurrScanline = (unsigned char *) psoSrc->pvScan0 + lOffset + (ptlSrc->y * delta);
    }

    //
    // Get the scanline size, but if there's a problem with the formats then retreat
    //
    ulDestScanlineInByte = ULConvertPixelsToBytes (sizlSrc->cx, ulSrcBpp, ulDestBpp);    
    if (ulDestScanlineInByte == 0)
    {
        //
        // Note to self: make sure that you free any memory that was allocated
        // up to this point.  Right now there's none.
        //
        return FALSE;
    }

    //
    // BAllocateCompBuffers allocates buffers that are double the size of ulDestScanlineInByte
    // The new size is stored in cCompBytes : Note cCompBytes is passed as reference
    //
    if (!BAllocateCompBuffers (pDestBuf, compdata, ulDestScanlineInByte, cCompBytes))
    {
        WARNING(("Cannot perform raster compression"));
    }

    if (!BCheckMemory(pDestBuf, compdata)) 
    {
        ERR(("Cannot access memory"));
		VFreeCompBuffers (pDestBuf, compdata);
        return FALSE;
    }

    //
    // Check if Image needs to be inverted 
    //
    if (ulSrcBpp == BMF_1BPP && 
        poempdev->dwFlags & PDEVF_INVERT_BITMAP) 
    {        
        bInvert = TRUE;
    }

    //
    // initialize data structure to defaults -- uncompressed data
    //
    compdata.lastCompMethod = NOCOMPRESSION;

    for(curScanline = 0; curScanline < sizlSrc->cy; curScanline++) 
    { 
        ZeroMemory(pDestBuf,ulDestScanlineInByte);

        if (!(XLINFO_SetXLInfo (&xlInfo,
                          pCurrScanline,
                          pDestBuf,
                          ulSrcBpp,
                          ulDestBpp)))
        {
            ERR(("SetXLInfo failed"));
            return FALSE;
        }

        VColorTranslate (&xlInfo, pxlo, sizlSrc->cx, ulDestScanlineInByte);

        if ( bInvert )
        {   
            vInvertScanLine( pDestBuf, ulDestScanlineInByte << 3);
        }

        DoCompression (pDestBuf, &compdata, ulDestScanlineInByte, cCompBytes);

        //
        // Send actual compressed/uncompressed data to 
        // printer based on best compression method
        //
        VSendCompressedRow (pDevObj,&compdata);

        //
        // Advance to next scan line
        //
        pCurrScanline += delta;
       
    } 

    //
    // free all allocated memory
    //
    VFreeCompBuffers (pDestBuf, compdata);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// BAllocateCompBuffers()
//
// Routine Description:
// ====================
// 
//   This function allocates the memory to perform the various kinds of
//   compression.
//
// Arguments:
// ==========
//
//   pDestBuf - working row buffer
//   compdata - compression comparison buffers
//   ulSize - number of bytes in an uncompressed row
//   [OUT] cCompBytes - number of bytes in each compression buffer
//
// Return Value:
// =============
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL BAllocateCompBuffers(PBYTE &pDestBuf, COMPDATA &compdata, ULONG ulSize, ULONG &cCompBytes)
{
    BOOL bRetVal = TRUE;
	//
	// Initialize buffers to NULL so we don't dealloc into darkness
	//
	compdata.pTIFFCompBuf     = NULL;
	compdata.pDeltaRowCompBuf = NULL;
	compdata.pRLECompBuf      = NULL;
	compdata.pSeedRowBuf      = NULL;
	compdata.pBestCompBuf     = NULL;

    //
    // For compression .. worst case data may double in size
    //
	cCompBytes = 2 * ulSize;

    if ( (pDestBuf                   = (PBYTE) MemAlloc(ulSize))     &&
         (compdata.pTIFFCompBuf      = (PBYTE) MemAlloc(cCompBytes)) &&
         (compdata.pDeltaRowCompBuf  = (PBYTE) MemAlloc(cCompBytes)) &&
         (compdata.pSeedRowBuf       = (PBYTE) MemAlloc(cCompBytes)) &&
         (compdata.pBestCompBuf      = (PBYTE) MemAlloc(cCompBytes))
       )
    {
        //
        // All allocations succeed. Now we can set the seed row to zero.
        //
        ZeroMemory(compdata.pSeedRowBuf, cCompBytes); 
    }
    else
    {
        //
        // Some allocation has failed, thought we dont know which.
        // It is not safe to assume that if the first malloc fails
        // all mallocs after that would have failed too. The OS
        // may have allocated more virtual memory for subsequent
        // malloc calls which may have succeeded.
        //
        if ( pDestBuf )
        {
            MemFree (pDestBuf);
            pDestBuf = NULL;
        }
        if ( compdata.pTIFFCompBuf )
        {
            MemFree (compdata.pTIFFCompBuf);
            compdata.pTIFFCompBuf = NULL;
        }
        if ( compdata.pDeltaRowCompBuf )
        {
            MemFree (compdata.pDeltaRowCompBuf);
            compdata.pDeltaRowCompBuf = NULL;
        }
        if ( compdata.pSeedRowBuf )
        {
            MemFree (compdata.pSeedRowBuf);
            compdata.pSeedRowBuf = NULL;
        }
        if ( compdata.pBestCompBuf )
        {
            MemFree (compdata.pBestCompBuf);
            compdata.pBestCompBuf = NULL;
        }
        bRetVal = FALSE;
    }

    return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// BCheckMemory()
//
// Routine Description:
// ====================
// 
//   Verifies that the desired compression buffers could be allocated.
//   The function returns false if any of the desired buffers are NULL.
//
// Arguments:
// ==========
//
//   pbBuf - input buffer
//   compdata - compression comparison buffer
//
// Return Value:
// =============
// 
//   True if successful, false otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL
BCheckMemory(
    PBYTE pbBuf,
	COMPDATA &compdata
)
{
    if ((pbBuf                      == NULL) ||
		(compdata.pTIFFCompBuf      == NULL) ||
		(compdata.pDeltaRowCompBuf  == NULL) ||
		(compdata.pSeedRowBuf       == NULL) ||
		(compdata.pBestCompBuf      == NULL))
    {
       ERR(("NOT ENOUGH MEMORY\r\n"));
       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
       return FALSE;
    }
    else
    {
        return TRUE;
    }
}

///////////////////////////////////////////////////////////////////////////////
// VFreeCompBuffers()
//
// Routine Description:
// ====================
// 
//   This function frees all of the buffers.  Make sure that any unused buffers
//   were initialized to NULL or you will free into darkness.
//
// Arguments:
// ==========
//
//   pDestBuf - working row buffer
//   compdata - compression comparison buffers
//
// Return Value:
// =============
// 
//   None
///////////////////////////////////////////////////////////////////////////////
VOID VFreeCompBuffers(PBYTE &pDestBuf, COMPDATA &compdata)
{
    if ( pDestBuf )
    {
	    MemFree(pDestBuf);
    }
    if (compdata.pTIFFCompBuf)
    {
	    MemFree(compdata.pTIFFCompBuf);
    }
    if (compdata.pDeltaRowCompBuf)
    {
	    MemFree(compdata.pDeltaRowCompBuf);
    }
    if (compdata.pRLECompBuf)
    {
	    MemFree(compdata.pRLECompBuf);
    }
    if (compdata.pSeedRowBuf)
    {
	    MemFree(compdata.pSeedRowBuf);
    }
    if (compdata.pBestCompBuf)
    {
	    MemFree(compdata.pBestCompBuf);
    }

	pDestBuf                  = NULL;
	compdata.pTIFFCompBuf     = NULL;
	compdata.pDeltaRowCompBuf = NULL;
	compdata.pRLECompBuf      = NULL;
	compdata.pSeedRowBuf      = NULL;
	compdata.pBestCompBuf     = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// VSendCompressedRow
//
// Routine Description:
//   Sends compressed scan line to spooler
//
// Arguments:
//   pdevobj - default devobj
//   pcompdata - used to store all the compression buffers
//               and related information.
//
// Return Value:
//   None
/////////////////////////////////////////////////////////////////////////////
VOID
VSendCompressedRow(
    PDEVOBJ pdevobj,
    PCOMPDATA pcompdata
)
{
    
    
//   VERBOSE(("SendCompressedRow\n"));
    
    if (pcompdata->bestCompMethod != pcompdata->lastCompMethod) 
    {
        pcompdata->lastCompMethod = pcompdata->bestCompMethod;
        //
        // set compression mode
        //
        PCL_CompressionMode(pdevobj, pcompdata->bestCompMethod); 

    }

    //
    // send the data to the printer
    //
    PCL_SendBytesPerRow(pdevobj, pcompdata->bestCompBytes);  
    PCL_Output(pdevobj,pcompdata->pBestCompBuf,pcompdata->bestCompBytes);   

}

/////////////////////////////////////////////////////////////////////////////
// BIsComplexClipPath
//
// Routine Description:
//
//   Checks for a complex clip region.    
//
// Arguments:
//
//   pco - the clipping region
//   
// Return Value:
//
//   True if the clip region is complex, FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL 
BIsComplexClipPath (
    CLIPOBJ  *pco
    )
{
    if ((pco) && (pco->iDComplexity == DC_COMPLEX))
        return TRUE;
    else
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// BIsRectClipPath
//
// Routine Description:
//
//   Checks for a rectangular clip region.    
//
// Arguments:
//
//   pco - the clipping region
//   
// Return Value:
//
//   True if the clip region is rectangular, FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL 
BIsRectClipPath (
    CLIPOBJ  *pco
    )
{
    if ((pco) && (pco->iDComplexity == DC_RECT))
        return TRUE;
    else
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// BProcessClippedScanLines
//
// Routine Description:
//
//   
//
// Arguments:
//
//   pDevObj - 
//   psoSrc - source bitmap
//   pco - clip region
//   pxlo - translate object
//   ptlSrc - left, top coordinates of source bitmap
//   ptlDest - left, top coordinates of destination bitmap
//   sizlDest - size of destination bitmap
//   
// Return Value:
//   TRUE if the image is clipped and sent to the printer. If an error
//   occurs along the way then FALSE.
//   
/////////////////////////////////////////////////////////////////////////////
BOOL 
BProcessClippedScanLines (
    PDEVOBJ   pDevObj,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo, 
    POINTL   *ptlSrc,
    POINTL   *ptlDest,
    SIZEL    *sizlDest
    )
{
    BOOL bReturn;
    BOOL bMore;
    RASTER_DATA srcImage;
    ENUMRECTS clipRects;
    ULONG i;
    RECTL rClip;
    RECTL rSel;
    RECTL rclDest;
    BOOL  bExclusive;
    
    TRY
    {
        if (pco->iDComplexity == DC_COMPLEX)
            bExclusive = FALSE;
        else
            bExclusive = TRUE;

        if (!InitRasterDataFromSURFOBJ(&srcImage, psoSrc, bExclusive))
        {
            TOSS(Error);
        }

        RECTL_SetRect(&rclDest, ptlDest->x, 
                                ptlDest->y, 
                                ptlDest->x + sizlDest->cx,
                                ptlDest->y + sizlDest->cy);
        
        if (pco)
        {
            CLIPOBJ_cEnumStart(pco, TRUE, CT_RECTANGLES, CD_RIGHTDOWN, 256);
            do
            {
                bMore = CLIPOBJ_bEnum(pco, sizeof(clipRects), &clipRects.c);

                if ( DDI_ERROR == bMore )
                {
                    TOSS(Error);
                }

                for (i = 0; i < clipRects.c; i++)
                {
                    if (BRectanglesIntersect (&rclDest, &(clipRects.arcl[i]), 
                                              &rClip))
                    {
                        //
                        // Clip rectangles are not bottom-right exclusive.
                        // They need to be inflated to make up for the exclusion
                        // of the bottom & right pixels.
                        //
                        //rClip.right++;
                        //rClip.bottom++;

                        RECTL_SetRect(&rSel, rClip.left   - rclDest.left + ptlSrc->x,
                                             rClip.top    - rclDest.top  + ptlSrc->y,
                                             rClip.right  - rclDest.left + ptlSrc->x,
                                             rClip.bottom - rclDest.top  + ptlSrc->y);

                        if (!DownloadImageAsPCL(pDevObj, 
                                                &rClip, 
                                                &srcImage, 
                                                &rSel, 
                                                pxlo))
                        {
                            TOSS(Error);
                        }
                    }
                }
            }  while (bMore);
        }
        else
        {
            //
            // This should only be called for complex clipping regions.
            //
            TOSS(Error);
        }
    }
    CATCH(Error)
    {
        bReturn = FALSE;
    }
    OTHERWISE
    {
        bReturn = TRUE;
    }
    ENDTRY;
    
    return bReturn;
}

/////////////////////////////////////////////////////////////////////////////
// VColorTranslate
//
// Routine Description:
//    translate source color to our device RGB color space by using 
//    pxlo with SCFlags.  
//
// Arguments:
//   pxlInfo - translate info 
//   pxlo - translate object which specifies how color indices 
//          are to be translated between the source and destination.
//   cx - width of source in pixels
//   ulDestScanlineInByte
//   
// Return Value:
//   none.
//   
/////////////////////////////////////////////////////////////////////////////
VOID
VColorTranslate (
    XLATEINFO *pxlInfo,
    XLATEOBJ  *pxlo,
    ULONG      cx,
    ULONG      ulDestScanlineInByte
    )
{
    DWORD  SCFlags = 0;
    ULONG  ulSrcBpp = pxlInfo->ulSrcBpp;
    ULONG  ulDestBpp = pxlInfo->ulDestBpp;
    PBYTE  pCurrScanline = pxlInfo->pSrcBuffer;
    PBYTE  pDestBuf = pxlInfo->pDestBuffer;

    REQUIRE_VALID_DATA( pDestBuf, ERR(("NULL pDestBuf\n")); return);
    
    //
    // Check translation object
    //
    if (pxlo != NULL)
    {
        SCFlags = CheckXlateObj(pxlo, ulSrcBpp);
    }
    
    //
    // Do the actual Color Translation.
    // only 16,24,32 BPP go through color Translation
    //
    if(SCFlags & SC_XLATE)
    {
        XlateColor(pCurrScanline, pDestBuf, pxlo, SCFlags, 
                   ulSrcBpp, ulDestBpp, cx);          
    }
    else 
    {
        //
        // 1, 4, 8 Bpp Cases
        //
        CopyMemory(pDestBuf, pCurrScanline, ulDestScanlineInByte);
    }
}

/////////////////////////////////////////////////////////////////////////////
// ULConvertPixelsToBytes
//
// Routine Description:
//   returns the number of bytes in the scan line
//   
//
// Arguments:
//
//   cx - width in pixels 
//   ulSrcBPP - source bitmap bits per pixel
//   ulDestBPP - destination bitmap bits per pixel
//   
// Return Value:
//
//   0 if there is an error, otherwise the number of bytes (DWORD aligned).   
/////////////////////////////////////////////////////////////////////////////
ULONG
ULConvertPixelsToBytes (
    ULONG cx,
    ULONG ulSrcBPP,
    ULONG ulDestBPP
    )
{
    //
    // Color conversion scenarios: 
    //   16bpp to 24bpp handled by XlateColor
    //   32bpp to 24bpp handled by XlateColor
    //   24bpp to 8bpp grayscale
    //
    BOOL bBppOk = ((ulSrcBPP == ulDestBPP) ||
                   ((ulSrcBPP == 16) && (ulDestBPP == 24)) ||
                   ((ulSrcBPP == 32) && (ulDestBPP == 24)) ||
                   ((ulSrcBPP == 24) && (ulDestBPP ==  8)));

    if (!bBppOk)
    {
        ERR(("Source bitmap and Destination bitmap are different formats\n"));
        return 0;
    }

    //
    // It turns out that the DWORD alignment isn't necessary.  However, changing
    // something like this should get more testing than we have right now.
    //
    switch (ulSrcBPP)
    {
        case 1:
        case 4:
        case 8:
        case 24:
            //return (DWORD)DW_ALIGN(((cx * ulSrcBPP) + 7) >> 3);
			return PIX_TO_BYTES_ALIGNED(cx, ulSrcBPP);
			//return PIX_TO_BYTES(cx, ulSrcBPP);
        case 16:
        case 32:
            // A 16bpp image will be converted to 24bpp later.
            // return (DWORD)DW_ALIGN(((cx * 24) + 7) >> 3);
 			return PIX_TO_BYTES_ALIGNED(cx, 24);
			// return PIX_TO_BYTES(cx, 24);
        default:
            ERR(("Bitmap format not supported\n"));
            return 0;
    }
}

/////////////////////////////////////////////////////////////////////////////
// XLINFO_SetXLInfo
//
// Routine Description:
//   Sets up a translate info structure to be used when
//   translating color indices.
//
// Arguments:
//
//   pxlinfo - translate info
//   pSrcBuffer - source bitmap buffer (one scan line only)
//   pDestBuffer - destination bitmap buffer (one scan line only)
//   ulSrcBPP - source bits per pixel
//   ulDestBPP - destination bits per pixel
//   
// Return Value:
//   TRUE if pxlinfo is a valid pointer, otherwise FALSE.
// 
/////////////////////////////////////////////////////////////////////////////
BOOL
XLINFO_SetXLInfo (
    XLATEINFO *pxlInfo,
    PBYTE      pSrcBuffer,
    PBYTE      pDestBuffer,
    ULONG      ulSrcBpp,
    ULONG      ulDestBpp
    )
{
    if (pxlInfo)
    {
        pxlInfo->pDestBuffer = pDestBuffer;
        pxlInfo->pSrcBuffer = pSrcBuffer;
        pxlInfo->ulSrcBpp = ulSrcBpp;
        pxlInfo->ulDestBpp = ulDestBpp;
        return TRUE;
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// DoCompression
//
// Routine Description:
//   Performs compression on the uncompressed buffer. Currently
//   only goes through two compression algorithms: TIFF and 
//   Delta Row. The uncompressed buffer is put through both
//   compression algorithms and the smallest of the three 
//   is sent to the printer. 
//   Enhancement: Use a table of compression functions and
//   loop through the table picking the best (smaller) 
//   compression buffer and then sending that buffer to
//   the printer.
//
// Arguments:
//
//   pDestBuf - uncompressed buffer containing data
//   pCompdata - used to store all the compression buffers
//               and related information.
//   cBytes -    number of bytes in source buffer that need to be compressed.
//   cCompBytes - size of compression buffer.
//   
// Return Value:
//   None.
// 
/////////////////////////////////////////////////////////////////////////////
VOID
DoCompression (
    BYTE     *pDestBuf, 
    COMPDATA *pCompdata,
    ULONG     cBytes,
    ULONG     cCompBytes
    )
{
    int    cTIFFBytesCompressed = 0,
           cDeltaRowBytesCompressed = 0;

    ZeroMemory(pCompdata->pBestCompBuf, cBytes);

    cTIFFBytesCompressed = iCompTIFF (
                               pCompdata->pTIFFCompBuf, 
                               cCompBytes,
                               pDestBuf, 
                               cBytes);

    cDeltaRowBytesCompressed = iCompDeltaRow (
                                   pCompdata->pDeltaRowCompBuf,
                                   pDestBuf,
                                   pCompdata->pSeedRowBuf,
                                   cBytes,
                                   cCompBytes);


    if (((ULONG)cDeltaRowBytesCompressed < cBytes) &&
        (cDeltaRowBytesCompressed < cTIFFBytesCompressed) &&
        (cDeltaRowBytesCompressed != -1))
    {
        pCompdata->bestCompMethod = DELTAROW;
        pCompdata->bestCompBytes = cDeltaRowBytesCompressed;
        CopyMemory (pCompdata->pBestCompBuf, 
                    pCompdata->pDeltaRowCompBuf, 
                    cDeltaRowBytesCompressed);
    }
    else if ((ULONG)cTIFFBytesCompressed < cBytes)
    {

        pCompdata->bestCompMethod = TIFF;
        pCompdata->bestCompBytes = cTIFFBytesCompressed;
        CopyMemory (pCompdata->pBestCompBuf, 
                    pCompdata->pTIFFCompBuf, 
                    cTIFFBytesCompressed);
    }
    else
    {
        pCompdata->bestCompMethod = NOCOMPRESSION;
        pCompdata->bestCompBytes = cBytes;
        CopyMemory (pCompdata->pBestCompBuf, 
                    pDestBuf, 
                    cBytes);
   }
   CopyMemory (pCompdata->pSeedRowBuf, pDestBuf, cBytes);
    return;
}



// To invert bits in a scanline. Copied from render\render.c


void
VInvertBits (
    DWORD  *pBits,
    INT    cDW
    )
/*++

Routine Description:

    This function inverts a group of bits. This is used to convert
    1 bit data from 0 = black and 1 = white to the opposite.

Arguments:

    pRD         Pointer to RENDER structure
    pBits       Pointer to data buffer to invert

Return Value:

    none

--*/
{
#ifndef _X86_
    INT cDWT = cDW >> 2;
    while( --cDWT >= 0 )
    {
        pBits[0] ^= ~((DWORD)0);
        pBits[1] ^= ~((DWORD)0);
        pBits[2] ^= ~((DWORD)0);
        pBits[3] ^= ~((DWORD)0);
        pBits += 4;
    }
    cDWT = cDW & 3;
    while (--cDWT >= 0)
        *pBits++ ^= ~((DWORD)0);

#else
//
// if intel processor, do it in assembly, for some reason
// the compiler always does the NOT in three vs one instruction
//
__asm
{
    mov ecx,cDW
    mov eax,pBits
    sar ecx,2
    jz  SHORT IB2
IB1:
    not DWORD PTR [eax]
    not DWORD PTR [eax+4]
    not DWORD PTR [eax+8]
    not DWORD PTR [eax+12]
    add eax,16
    dec ecx
    jnz IB1
IB2:
    mov ecx,cDW
    and ecx,3
    jz  SHORT IB4
IB3:
    not DWORD PTR [eax]
    add eax,4
    dec ecx
    jnz IB3
IB4:
}
#endif
}


/*++
Routine Name:
    vInvertScanLine

Routine Description:
    Inverts a ScanLine where each bit represents one pixel (i.e. 1bpp)

Arguments:
    pCurrScanline : The scan line to invert.
    ulNumPixels   : The number of pixels in that scan line. Scan lines generally are multiple of
                    DWORDS, therefore there may be some bits at the end that do not have image
                    data, but are there only for padding. ulNumPixels is the count of valid 
                    image bits.
Return Value:
    None.

Last Error:
    Not changed.
--*/



VOID vInvertScanLine ( 
    IN OUT PBYTE pCurrScanline,
    IN     ULONG ulNumPixels)
{

    //
    // The size of scan line is a multiple sizeof(DWORD). But the actual bitmap (i.e. the number of
    // of pixels in the x direction), may not be multiple of sizeof(DWORD). Therefore, 
    // GDI fills the last bytes/bits with 0's. When 0's are inverted, they become 1's which
    // is considered black in monochrome printers. So the printed image has a 
    // thin strip of black towards its right. 
    // To prevent this, we can do 2 things.
    //  1) Do not invert the padded bits.
    //  2) Make the padded bits as 1 before we call the inversion routine. That way,
    //     after inversion, they will go back to 0.
    //  Lets take the first approach. To invert the DWORDS that have no padding bits,
    // simply call VInvertBits. To invert the last DWORD that has the padding bits, 
    // we will need to do something complex.
    //

    //
    // Get the number of DWORDS that have full image data. No padding in these dwords.
    // divide number of pixels by 32 = 8*4 : 8 pixels per byte. 4 bytes per DWORD
    // These DWORDS can then be easily inverted by calling VInvertBits
    //
    ULONG ulNumFullDwords = (ulNumPixels >> 5); 
    VInvertBits( (PDWORD)pCurrScanline, ulNumFullDwords);


    //
    // Find out number of uninverted bits. This number has to be between 0 and 32 and should
    // be neither 0 nor 32 i.e. 0 < n < 32. cos if it is 0 or 32, it means one full DWORD 
    // which should have been handled earlier. Here we only handle the DWORD that has some
    // padding and some image data. 
    //
    ULONG ulNumUninvertedBits = ulNumPixels - (ulNumFullDwords << 5);

    if ( !ulNumUninvertedBits ) //If there is no padding.
    {
        return;
    }

    PDWORD pdwLastDword = (PDWORD)( pCurrScanline + (ulNumFullDwords << 2)); //Point to the first un-inverted bit

    //
    //
    //

    ULONG ulQuot = ulNumUninvertedBits >> 3; //num of bytes with only image information(no padding)
    ULONG ulRem  = ulNumUninvertedBits % 8;  //num of Padded bits in the byte that 
                                             //has both image info and padding.

    //
    // Invert the image data, while leaving the padding bits unchanged.
    // The first ulNumUninvertedBits bits will be the image data, while the remaining 
    // (sizeof(DWORD) - ulNumUninvertedBits) is the padding. So if the padding is
    // XORed with 0, it will remain unchanged, and if the image pixels are XORed with 1
    // they will invert. So we need to make a number whose first ulNumUninvertedBits are 1
    // and the remaining bits are 0.
    // To make it efficient, lets not consider the 4 bytes separately. Consider them
    // as one DWORD. 
    // We need to make up a DWORD whose bits are positioned in such a way, that
    // when we XOR with *pdwLastDword, the 1 bits of that number are aligned with the bits
    // of *pdwLastDword that are image data, and the 0 bits are aligned with the bits of 
    // *pdwLastDword that are padding. Reason: (x ^ 1) = ~x and (x ^ 0) = x. Therefore
    // the image bits reverse, while the padded bits remain unchanged.
    // Assumption: The padded bits are set to 0.
    //
    // Another point to note is that when we consider 4 bytes as DWORD, then we must
    // consider the byte ordering while forming the DWORD. Intel processors use the 
    // little endian format. i.e. the LSB is in the lowest memory address.
    //
    //    No. of ImageBits (n).           The number (DWORD) to XOR *pdwLastDword with
    //                                      MSB        LSB
    //                            Byte no.   1   2  3  4
    //       1                              0x00 00 00 80   (in memory stored as 80 00 00 00)
    //       2                              0x00 00 00 c0
    //       3                              0x00 00 00 e0
    //       4                              0x00 00 00 f0
    //       6                              0x00 00 00 fc
    //       8                              0x00 00 00 ff
    //       9                              0x00 00 80 ff
    //      12                              0x00 00 f0 ff
    //      16                              0x00 00 ff ff
    //      17                              0x00 80 ff ff
    //      24                              0x00 ff ff ff
    //      25                              0x80 ff ff ff 
    //      32                              0xff ff ff ff
    //
    // Formula (Logic) for arriving at the number.
    // Assume n is the no. of image bits (in the DWORD). 
    // ulQuot  = n/8  = the number of bytes that only have image data (i.e.no padded bits) 
    // and ulRem is (n % 8) i.e. i.e. the number of padded bits in the byte that has 
    // a mixture of padding bits and the image bits.
    // Consider # as a sign of "raise to the power"
    // Consider the above table for n = 1 to 8. The number on the right is 
    //      256-2#(8 - ulRem) -----------> Equation 1 (Q1)
    // This number is shifted 8 bits to left, whenever n increases by 8 
    // e.g. when n = 1 Number is  0x000080. 
    //      When n = 9, number is 0x0080ff. i.e. 0x80 shifted left 8 ( = 8 * 9/8) bits 
    //                                              (Ignore ff for the meantime)
    //      when n = 17 Number is 0x80ffff i.e. 0x80 shifted left 16 ( = 8 * 17/8) bits 
    // Since ulQuot = n / 8, the above shift can be represented as
    // Q1 << (8*ulQuot) ------------------> Equation 2 (Q2)
    // 
    // Now lets look at ff.
    // From n = 1-8, the last 8 bits (i.e. byte 4)are changing whenever n is increased.
    // From n = 9-16, the last 8 bits are constant at 0xff (=2#8-1), only byte 3 is changing.
    // From n = 17-24, the last 16 bits are constant at 0xffff(=2#16-1), only byte 2 is changing.
    // From n = 25-32, the last 24 bits are constant at 0xffffff(=2#24-1), only byte 1 is changing.
    //  So the formula for the rightmost bits becomes
    //      (2*(8*ulQuot) - 1)  ----------> Equation 3 (Q3)
    //
    //  Combining Q2 and Q3 we get the final number as
    //      Q2 | Q3 
    
    // So the formula is as follows
    // ((2#8 - 2#(8-ulRem)) << (8*ulQuot)) | (2#(8*ulQuot) - 1)
    //
    // 2#(ulRem) is same as 1 shifted left (8-ulRem) times.
    // 8 * ulQuot is same as ulQuot shifted left 3 times.
    //

    *pdwLastDword = (*pdwLastDword) ^ 
                        (( (256-(1<< (8 - ulRem))) << (ulQuot << 3)) | ( (1 << (ulQuot<<3)) - 1) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\realize.cpp ===
/////////////////////////////////////////////////////////// 
//
//
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
//
//    realize.cpp
//
// Abstract:
//
//    Implementation of Pen and Brush realization.
//    
// Environment:
//
//    Windows 2000 Unidrv driver
//
// Revision History:
//
/////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

#define NT_SCREEN_RES   96
#define ULONG_MSB1      (0x80000000) //ULONG with first bit 1

//
//Function Declaration
//
BOOL BGetNup(
    IN   PDEVOBJ  pdevobj,
    OUT  LAYOUT * pLayoutNup );

/////////////////////////////////////////////////////////////////////////////
// BGetBitmapInfo
//
// Routine Description:
//   This function is used by raster.c and RealizeBrush.  This is one of the
//   competing implementations to answer the question: what are the details
//   of the given bitmap?  We automatically map 16bpp and 32bpp to 24bpp since
//   the xlateobj will actually convert the pixels when we output them.
//
// Arguments:
//
//   sizlSrc - [in] dimensions of the bitmap
//   iBitmapFormat - the OS-defined bitmap format
//   pPCLPattern - [out] a structure which carries bitmap info to the caller
//   pulsrcBpp - [out] source bpp
//   puldestBpp - [out] destination bpp
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL
BGetBitmapInfo(
    SIZEL       *sizlSrc,
    ULONG        iBitmapFormat,   
    PCLPATTERN  *pPCLPattern,
    PULONG       pulsrcBpp,    
    PULONG       puldestBpp   
)
{
    ULONG  ulWidth;            // source width in pixels
    ULONG  ulHeight;           // source height in pixels
    
    ENTERING(BGetBitmapInfo);
    
    if(!pPCLPattern || !pulsrcBpp || !puldestBpp)
        return FALSE;
    

    ulWidth = sizlSrc->cx;
    ulHeight = sizlSrc->cy;

    pPCLPattern->iBitmapFormat = iBitmapFormat;

    switch ( iBitmapFormat )
    {
        
    case BMF_1BPP:
        pPCLPattern->colorMappingEnum = HP_eIndexedPixel;
        *pulsrcBpp  = 1;
        *puldestBpp = 1;
        break;

    case BMF_4BPP:
        pPCLPattern->colorMappingEnum = HP_eIndexedPixel;
        *pulsrcBpp  = 4;
        *puldestBpp = 4;
        break;
        
    case BMF_4RLE:
        ERR(("BMF_4RLE is not supported yet\n"));
        return FALSE;

    case BMF_8RLE:
    case BMF_8BPP:
        pPCLPattern->colorMappingEnum = HP_eIndexedPixel;
        *pulsrcBpp  = 8;
        *puldestBpp = 8;
        break;
        
    case BMF_16BPP:
        pPCLPattern->colorMappingEnum = HP_eDirectPixel;
        *pulsrcBpp =  16;
        *puldestBpp = 24;
        break;
        
    case BMF_24BPP:
        pPCLPattern->colorMappingEnum = HP_eDirectPixel;
        *pulsrcBpp  = 24;
        *puldestBpp = 24;
        break;
        
    case BMF_32BPP:
        pPCLPattern->colorMappingEnum = HP_eDirectPixel;
        *pulsrcBpp =  32;
        *puldestBpp = 24;
        break;
        
    default:
        ERR(("BGetBitmapInfo -- Unsupported Bitmap type\n"));
        return FALSE;
    }
    
    EXITING(BGetBitmapInfo);
    
    return TRUE;
}
  
/////////////////////////////////////////////////////////////////////////////
// CheckXlateObj
//
// Routine Description:
//   This function check the XLATEOBJ provided and determined the translate
//   method.
//
// Arguments:
//
//   pxlo     - XLATEOBJ provided by the engine
//   srcBpp   - Source bits per pixel
//
// Return Value:
//
//   SCFlags with SC_XXXX to identify the translation method and accel.
/////////////////////////////////////////////////////////////////////////////
DWORD
CheckXlateObj(
    XLATEOBJ    *pxlo,
    DWORD       srcBpp)
{
    DWORD   Ret;
    //
    // Only set the SC_XXX if has xlate object and source is 16bpp or greater
    //
    
    if ( (pxlo) && (srcBpp >= 16) ) 
    {
        DWORD   Dst[4];
        
        // the result of Ret is as follows:
        // for 1,4,8 BPP ==> always 0
        // for 16 BPP ==> always SC_XLATE
        // for 24, 32 BPP ==> 1. ( SC_XLATE | SC_IDENTITY ) if the translation result is the same
        //                    2. (SC_XLATE | SC_SWAP_RB) if translation result has swapped RGB value
        //                    3. SC_XLATE otherwise
        
        switch (srcBpp) 
        {
        case 24:
        case 32:
            
            Ret = SC_XLATE;
            
            //
            // Translate all 4 bytes from the DWORD
            //
            
            Dst[0] = XLATEOBJ_iXlate(pxlo, 0x000000FF);
            Dst[1] = XLATEOBJ_iXlate(pxlo, 0x0000FF00);
            Dst[2] = XLATEOBJ_iXlate(pxlo, 0x00FF0000);
            Dst[3] = XLATEOBJ_iXlate(pxlo, 0xFF000000);
            
            // Verbose(("XlateDst: %08lx:%08lx:%08lx:%08lx\n",
            //            Dst[0], Dst[1], Dst[2], Dst[3]));
            
            if ((Dst[0] == 0x000000FF) &&
                (Dst[1] == 0x0000FF00) &&
                (Dst[2] == 0x00FF0000) &&
                (Dst[3] == 0x00000000))
            {
                //
                // If translate result is same (4th byte will be zero) then
                // we done with it except if 32bpp then we have to skip one
                // source byte for every 3 bytes
                //
                
                Ret |= SC_IDENTITY;
                
            } 
            else if ((Dst[0] == 0x00FF0000) &&
                     (Dst[1] == 0x0000FF00) &&
                     (Dst[2] == 0x000000FF) &&
                     (Dst[3] == 0x00000000))
            {
                //
                // Simply swap the R and B component
                //
                Ret |= SC_SWAP_RB;
            }
            break;
            
        case 16:
            Ret = SC_XLATE;
            break;
                                       
        } // end of switch
    } // end of if ( (pxlo) && (srcBpp >= 16) ) 
    else
        Ret = 0;
    
    return(Ret);
}

/////////////////////////////////////////////////////////////////////////////
// XlateColor
//
// Routine Description:
//   This function will translate source color to our device RGB color space by
//   using pxlo with SCFlags.
//
//   This function is called from raster.c and RealizeBrush
//
// Arguments:
//
//   pbSrc   - Pointer to the source color must 16/24/32 bpp (include bitfields)
//   pbDst   - Translated device RGB buffer
//   pxlo    - XLATEOBJ provided by the engine
//   SCFlags - The SOURCE COLOR flags, the flags is returned by CheckXlateObj
//   srcBpp  - Bits per pixel of the source provided by the pbSrc
//   destBpp - Bits per pixel of the destination provided by the pbDst
//   cPels   - Total Source pixels to be translated
//
// Return Value:
//
//   None.
/////////////////////////////////////////////////////////////////////////////
VOID
XlateColor(
    LPBYTE      pbSrc,
    LPBYTE      pbDst,
    XLATEOBJ    *pxlo,
    DWORD       SCFlags,
    DWORD       srcBpp,
    DWORD       destBpp,
    DWORD       cPels
    )
{
    ULONG   srcColor;
    DW4B    dw4b; //JM
    //dz    DW4B    dw4b;
    UINT    SrcInc;
    LPBYTE  pbTmpSrc = pbSrc; // avoid address of pbSrc getting changing when this rouitin terminates
    LPBYTE  pbTmpDst = pbDst; // avoid address of pbDst getting changing when this rouitin terminates
    
    ASSERT( srcBpp == 16 || srcBpp == 24 || srcBpp == 32 );
    
    SrcInc = (UINT)(srcBpp >> 3);
    
    if (SCFlags & SC_SWAP_RB) // for 24, 32 bpp only
    {
        //
        // Just swap first byte with third byte, and skip the source by
        // the SrcBpp
        //
        while (cPels--) 
        {
            // dw4b.b4[0] = *(pbTmpSrc + 2);
            // dw4b.b4[1] = *(pbTmpSrc + 1);
            // dw4b.b4[2] = *(pbTmpSrc + 0);
            
            {
                *pbTmpDst++ = *(pbTmpSrc + 2);
                *pbTmpDst++ = *(pbTmpSrc + 1);
                *pbTmpDst++ = *pbTmpSrc;
            }
            pbTmpSrc    += SrcInc;
        }
        
    }
    else if (SCFlags & SC_IDENTITY) // for 24, 32BPP with no change of value after translation
    {
        //
        // If no color translate for 32bpp is needed then we need to
        // remove 4th byte from the source
        //
        while (cPels--)
        {
            {
                *pbTmpDst++ = *pbTmpSrc;
                *pbTmpDst++ = *(pbTmpSrc+1);
                *pbTmpDst++ = *(pbTmpSrc+2);
            }
            pbTmpSrc    += SrcInc;;
        }  
    }
    
    //JM   #if 0
    else
    {
        //
        // At here only engine know how to translate 16, 24, 32 bpp color from the
        // source to our RGB format. (may be bitfields)
        //
        
        while (cPels--)
        {
            switch ( srcBpp )
            {
            case 16:
                //
                // Translate every WORD (16 bits) to a 3 bytes RGB by calling engine
                //
                
                srcColor = *((PWORD)pbTmpSrc);
                break;
                
            case 24:
                
                srcColor = ((ULONG) pbTmpSrc[0]) |
                    ((ULONG) pbTmpSrc[1] <<  8) |
                    ((ULONG) pbTmpSrc[2] << 16);
                break;
                
            case 32:
                srcColor = *((PULONG)pbTmpSrc);
                break;
            }
            
            dw4b.dw    = XLATEOBJ_iXlate(pxlo, srcColor);
            
            pbTmpSrc    += SrcInc;
            
            if (destBpp == 8)
                *pbTmpDst++ = RgbToGray(dw4b.b4[0], dw4b.b4[1], dw4b.b4[2]);
            else  // 24 bits
            {
                *pbTmpDst++ = dw4b.b4[0];
                *pbTmpDst++ = dw4b.b4[1];
                *pbTmpDst++ = dw4b.b4[2];
            }
        } // end of while (cPels--)
    }
    //  JM  #endif
}

/////////////////////////////////////////////////////////////////////////////
// StretchPCLPattern
//
// Routine Description:
//   This function copies the given pattern and stretches it by a factor of
//   2.
//
// Arguments:
//
//   pPattern - [out] destination pattern
//   psoPattern - [in] source pattern
//
// Return Value:
//
//   BOOL: TRUE if successful, else FALSE.
/////////////////////////////////////////////////////////////////////////////
BOOL StretchPCLPattern(PPCLPATTERN pPattern, SURFOBJ *psoPattern)
{
    PBYTE pSrcRow;
    PBYTE pDstRow;
    int r, c;
    WORD w;
    BOOL bDupRow;
    int bit;

    if (!pPattern || !psoPattern)
        return FALSE;

    //
    // HACK ALERT!!! The bDupRow is a cheap toggle which allows me to write out
    // each row twice.  When it's true rewrite the same source row to the next
    // target row.  When it's false go on to the next row.  Be sure to toggle it
    // on each row!
    //
    bDupRow = TRUE; 
    pSrcRow = (PBYTE) psoPattern->pvScan0;
    pDstRow = pPattern->pBits;
    for (r = 0; r < psoPattern->sizlBitmap.cy; r++)
    {
        for (c = 0; c < psoPattern->sizlBitmap.cx; c++)
        {
            switch (psoPattern->iBitmapFormat)
            {
            case BMF_1BPP:
                w = 0;
                if (pSrcRow[0] != 0) // optimization: don't bother with 0
                {
                    for (bit = 7; bit >= 0; bit--)
                    {
                        w <<= 2;
                        if (pSrcRow[c] & (0x01 << bit))
                        {
                            w |= 0x0003;
                        }
                    }
                }
                pDstRow[(c * 2) + 0] = HIBYTE(w);
                pDstRow[(c * 2) + 1] = LOBYTE(w);
                break;

            case BMF_8BPP:
                pDstRow[(c * 2) + 0] = pSrcRow[c];
                pDstRow[(c * 2) + 1] = pSrcRow[c];
                break;

            default:
                // not supported!
                return FALSE;
            }

        }

        if (bDupRow)
        {
            r--; // don't count row--we want to dup it.
        }
        else
        {
            pSrcRow += psoPattern->lDelta; // only increment if we've already dup'ed
        }
        pDstRow += pPattern->lDelta;
        bDupRow = !bDupRow;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// HPGLRealizeBrush
//
// Routine Description:
//   Implementation of DDI entry point DrvRealizeBrush.
//   Please refer to DDK documentation for more details.
//
// Arguments:
//
//   pbo - BRUSHOBJ to be realized
//   psoTarget - Defines the surface for which the brush is to be realized
//   psoPattern - Defines the pattern for the brush
//   psoMask - Transparency mask for the brush
//   pxlo - Defines the interpretration of colors in the pattern
//   iHatch - Specifies whether psoPattern is one of the hatch brushes
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL
HPGLRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    )
{
    PBRUSHINFO    pBrush;
    POEMPDEV      poempdev;
    PDEVOBJ       pdevobj;
    BRUSHTYPE     BType     = eBrushTypeNULL;
    ULONG         ulFlags   = 0;
    LAYOUT        LayoutNup = ONE_UP; //default.
    
    BOOL          retVal;

    TERSE(("HPGLRealizeBrush() entry.\r\n"));

    UNREFERENCED_PARAMETER(psoMask);

    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    REQUIRE_VALID_DATA( (poempdev && pbo && psoTarget && psoPattern && pxlo), return FALSE );

    DWORD *pdwColorTable = NULL;
    DWORD dwForeColor, dwBackColor, dwPatternID;

    if (pxlo)
        pdwColorTable = GET_COLOR_TABLE(pxlo);

    if (pdwColorTable)
    {
    //    dwForeColor = pdwColorTable[0];
    //    dwBackColor = pdwColorTable[1];
        dwForeColor = pdwColorTable[1];
        dwBackColor = pdwColorTable[0];
    }
    else
    {
        dwForeColor     = BRUSHOBJ_ulGetBrushColor(pbo);
        dwBackColor     = 0xFFFFFF;
    }

    //
    // Sometimes RealizeBrush gets called
    // with both the members of pxlo having the same color. In that case, instead
    // of downloading the pattern that GDI gives us, we can create a gray scale pattern
    // associated with that color. 
    // (Used only for Monochrome Printers)
    // Q. Why is the new method better. Now we have to create a pattern too, 
    // instead of just using one that GDI gave us.
    // A. In HPGL (monochrome) we cannot download the palette for the pattern. Pen 1 
    // is hardcoded to be black while Pen 0 is white. There is no way we can change
    // it. So if the pattern consists of 1's and 0's but both 1 and 0 represent the 
    // the same color, monochrome printer will fail. 1's will appear as black and
    // 0's as white. In the new method, the color will be converted to a gray scale
    // pattern.
    //
    if ( !BIsColorPrinter(pdevobj) && 
         (dwForeColor == dwBackColor) )
    {
        pbo->iSolidColor = (ULONG)dwForeColor;
    }


    //
    // iHatch as received from GDI does not match the iHatch as expected
    // by PCL language. There are 2 major differences 
    // 1. GDI's hatch pattern numbers start from 0 while those of PCL
    //    start from 1. So we need to add 1 to GDI's iHatch. This is 
    //    done somewhere else in the code. 
    // 2.
    // IN GDI : iHatch = 2 (2+1=3 for PCL)indicates forward diagnol
    //          iHatch = 3 (3+1=4 for PCL)= backward diagnol
    // In PCL : iHatch = 3 = backward diagnol (lower left to top right)
    //          iHatch = 4 = forward diagnol. (lower right to top left)
    // As can be seen above, the iHatch numbers for iHatch=2 and 3 should
    // be interchanged.
    //
    // Another interesting thing is that for n-up, the hatch brushes are not
    // rotated. i.e. A vertical line in a normal page (parallel to long edge)
    // still appears as vertical line on 2-up. i.e. it remains parallel to
    // long edge of the page. But on 2-up, since the image is rototated 90 degree
    // the line should now be drawn parallel to the short edge of the plane.
    // So lets do this adjustment here.
    //
    if ( BGetNup(pdevobj, &LayoutNup) && 
         ( LayoutNup == TWO_UP ||
           LayoutNup == SIX_UP )
       )

    {
        //
        // There are 6 types of hatch brushes (lets say 3 pairs)
        //   a.     HS_HORIZONTAL, HS_VERTICAL, 
        //   b.     HS_FDIAGONAL, HS_BDIAGONAL        
        //   c.     HS_CROSS,   HS_DIAGCROSS
        // Only HS_HORIZONTAL, HS_VERTICAL needs to be interchanged.
        // HS_CROSS and HS_DIAGCROSS are same in any orientation.
        // HS_FDIAGONAL, HS_BDIAGONAL should be inverted but since GDI already
        // gives it inverted (in respect to PCL language, see point 2 above)
        // we dont need to invert it here.
        //
        if ( iHatch == HS_HORIZONTAL )
        {
            iHatch = HS_VERTICAL;
        }
        else if ( iHatch == HS_VERTICAL )
        {
            iHatch = HS_HORIZONTAL;
        }
    }
    else
    {
        if ( iHatch == HS_FDIAGONAL)  //iHatch == 2
        {
            iHatch = HS_BDIAGONAL;
        }
        else if ( iHatch == HS_BDIAGONAL)  //iHatch == 3
        {
            iHatch = HS_FDIAGONAL;
        }
    }

    //
    // Hack!!: If you do not want to support Hatch Brushes, simply set
    // iHatch a value greater than HS_DDI_MAX. 
    // Then instead of using iHatch, we will use pboPattern.
    // (for further details look at the documentation of DrvRealizeBrush).
    // We can also selectively ignore iHatch for color or monochrome
    // printers or for any other conditions.
    // 
    if (iHatch < HS_DDI_MAX) 
    {
        if ( (dwBackColor != RGB_WHITE) ||
             (!BIsColorPrinter(pdevobj) && dwForeColor != RGB_BLACK )
           )

        {
            //
            // Ignore iHatch if
            // a) If the background color is non-white. (Irrespective of whether 
            //    printer is color or monochrome.
            // b) If the printer is monochrome, then if the color of the HatchBrush
            //    is non-black. (Because the limitation of PCL/HPGL does not 
            //    allow a dither pattern to be associated with a Hatch Brush.
            // By making Most Significant bit 1, we give a special meaning to HatchBrush.
            // We say, "Ok, it is a Hatch Brush but the MSB 1 indicates it needs
            // some special processing. 
            // For functions that dont understand this special format, they think
            // the value of iHatch is greater than HS_DDI_MAX (HS_DDI_MAX = 6). 
            // So they think this is not a hatch brush. That is exactly what we
            // want them to think.
            // 
            iHatch  |= ULONG_MSB1; //Make the first bit 1. 
        }
    }
    else
    {
        //
        // Just so that iHatch does not have a random value.
        //
        iHatch = HS_DDI_MAX;
    }

    //
    // Check if there is the brush available.
    // If the return value is S_FALSE: means brush not available, so 
    // it needs to be created. The new brush that we download should 
    // get the value dwPatternID.
    // A value of S_OK means a brush that matches the pattern
    // has been created earlier, dwPatternID gives that pattern number.
    // For color printers, the brush consists of a pattern and a palette.
    // for mono, it is only the pattern since palette is understood to 
    // be black and white. 
    // So for color, the fact that pattern matches is half the job done,
    // a palette still needs to be created. We could have cached palettes
    // too, just like patterns, but that i will do in the next revision
    // of HP-GL/2. Now i dont have time.
    //
    LRESULT LResult = poempdev->pBrushCache->ReturnPatternID(pbo,
                                                             iHatch,
                                                             dwForeColor,
                                                             psoPattern,
                                                             BIsColorPrinter(pdevobj),
                                                             poempdev->bStick,
                                                             &dwPatternID,
                                                             &BType);
    //
    // If S_OK is returned and the brush type is pattern and
    // the printer is a color printer, then we dont have to download
    // the pattern but still have to download the palette (as explained above).
    //
    if ( (LResult == S_OK) &&
         (BType  == eBrushTypePattern) && //Probably I dont need to do this. 
                                          //hatch might also need palette.
          BIsColorPrinter(pdevobj)
       )
    {
        retVal = BCreateNewBrush (
                            pbo,
                            psoTarget,
                            psoPattern,
                            pxlo,
                            iHatch,
                            dwForeColor,
                            dwPatternID);
        if ( retVal) 
        {
            ((PBRUSHINFO)(pbo->pvRbrush))->ulFlags = VALID_PALETTE;
        }
        
                 
    }
    else if (S_FALSE ==  LResult)
    {
        retVal = BCreateNewBrush (  
                            pbo,
                            psoTarget,
                            psoPattern,
                            pxlo,
                            iHatch,
                            dwForeColor,
                            dwPatternID);
        if ( retVal && (BType  == eBrushTypePattern) )
        {
            if ( BIsColorPrinter(pdevobj) ) 
            {
                ((PBRUSHINFO)(pbo->pvRbrush))->ulFlags = VALID_PATTERN | VALID_PALETTE;
            }
            else
            {
                ((PBRUSHINFO)(pbo->pvRbrush))->ulFlags = VALID_PATTERN; 
            }
        }
    }
    else if (S_OK == LResult)
    {
        //
        // Do not need to download pattern.
        // Just pass ID or iHatch to the caller of BRUSHOBJ_pvGetRbrush;
        //
        if ( !(pBrush = (PBRUSHINFO)BRUSHOBJ_pvAllocRbrush(pbo, sizeof(BRUSHINFO)) ) )
        {
            retVal = FALSE;
        }
        else
        {
            pBrush->Brush.iHatch    = iHatch;
            pBrush->Brush.pPattern  = NULL;
            pBrush->dwPatternID     = dwPatternID;
            pBrush->bNeedToDownload = FALSE;
            pBrush->ulFlags         = 0;    //not to look at pattern or palette. Just ID is enough.
            retVal                  = TRUE;
        }
    }
    else
    {
        ERR(("BrushCach.ReturnPatternID failed.\n"));
        return FALSE;
    }

    return retVal;
}


/*++

Routine Description:
    Creates a New Brush. It allocates space using BRUSHOBJ_pvAllocBrush,
    populates it with appropriate values (depending on the type of brush).
    Note: The memory allocated here is released by GDI, so this function does
    not have to worry about releasing it.

Arguments:
    pbo         - The pointer to BRUSHOBJ
    psoTarget   - The destination surface.
    psoPattern  - The source surface. This has the brush.
    pxlo        - The color translation table. 
    iHatch      - This is iHatch. The meaning of this iHatch is slightly different
                  from the iHatch that we get in DrvRealizeBrush.
                  In DrvRealizeBrush, if iHatch is less than HS_DDI_MAX, then
                  this is one of the Hatch Brushes. In this function, 
                  it means the same. But in addition if iHatch's most 
                  significant bit is 1, then psoPattern should be used for      
                  realizing the brush, instead of iHatch.  If this is the case,
                  then this function does not scale the psoPattern as it 
                  does for normal non-iHatch brushes.
    dwForeColor - The foreground color of Hatch Brush.
    dwPatternId - The ID to be given to the brush when it is downloaded.
                  This is also the id with which the pattern's information
                  is stored in the brush cache.
  
Return Value:
    TRUE if function succeeds. FALSE otherwise.

Author:
        hsingh  
--*/
BOOL BCreateNewBrush (
    IN  BRUSHOBJ   *pbo,
    IN  SURFOBJ    *psoTarget,
    IN  SURFOBJ    *psoPattern,
    IN  XLATEOBJ   *pxlo,
    IN  LONG        iHatch,
    IN  DWORD       dwForeColor,
    IN  DWORD       dwPatternID)

{
    BOOL          bProxyDataUsed    = FALSE;
    BOOL          bReverseImage     = FALSE;
    BOOL          bRetVal           = TRUE;
    PDEVOBJ       pdevobj           = NULL;
    HPGL2BRUSH    HPGL2Brush;
    BOOL          bExpandImage;

    RASTER_DATA   srcImage;
    PALETTE       srcPalette;
    PRASTER_DATA  pSrcImage         = &srcImage;
    PPALETTE      pSrcPalette       = NULL;

    PPATTERN_DATA pDstPattern       = NULL;
    PRASTER_DATA  pDstImage         = NULL;
    PPALETTE      pDstPalette       = NULL;
    POEMPDEV      poempdev;
    PBRUSHINFO    pBrush            = NULL;
    BOOL          bDownloadAsHPGL   = FALSE; //i.e. by default download as PCL
    EIMTYPE       eImType           = kUNKNOWN;

    //
    // Valid input parameters
    //
    REQUIRE_VALID_DATA( (pbo && psoTarget && psoPattern && pxlo), return FALSE );
    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    REQUIRE_VALID_DATA( pdevobj, return FALSE );
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE );

    //
    // When ReturnPatternID was called, the metadata regarding the new brush was 
    // in the brush cache. i.e. the type of brush. The actual contents of brush were not
    // stored. Here, we get that metadata and depending on that, we procede. 
    //
    if (S_OK != poempdev->pBrushCache->GetHPGL2BRUSH(dwPatternID, &HPGL2Brush))
    {
        //
        // This failure is fatal, cos the cache has to have the metadata stored.
        //
        return FALSE;
    }

    //
    // Now the new brush has to be created. How it is created depends on
    // 1. Whether the printer is color or monochrome and
    // 2. What is the type of the brush i.e. Patter, Solid or Hatch.
    //

    if (HPGL2Brush.BType == eBrushTypePattern)
    {
        SURFOBJ *psoHT        = NULL;
        HBITMAP  hBmpHT       = NULL;
        ULONG    ulDeviceRes  = HPGL_GetDeviceResolution(pdevobj);
        DWORD    dwBrushExpansionFactor   = 1; //Initialize to 1 i.e. no expansion.
        DWORD    dwBrushCompressionFactor = 1; //Initialize to 1 i.e. dont compress

    
        VERBOSE(("RealizeBrush: eBrushTypePattern.\n"));

        //
        // In case we are doing n-up, we have to compress the brush
        // accordingly.
        //
        if ( (dwBrushCompressionFactor = poempdev->ulNupCompr) == 0)
        {
            WARNING(("N-up with value zero recieved. . Assuming nup to be 1 and continuing.\n"));
            dwBrushCompressionFactor = 1;
        }

        if ( ( iHatch & ULONG_MSB1 )  &&  
             ( (iHatch & (ULONG_MSB1-1)) < HS_DDI_MAX) )
        {
            //
            // If the MSB of iHatch is 1, 
            //
            eImType = kHATCHBRUSHPATTERN;
        }

        //
        // Logic behind dwBrushExpansionFactor.
        // GDI does not scale brushes in accordance with printer resolution.
        // So the driver has to do the job. Postscript assumes that GDI patterns 
        // are meant for 150 dpi printer (this assumption may fail if an app
        // scales patterns according to printer resolution but I dont know 
        // of any such app). So when printing to 600 dpi there are 2 ways of handling
        // this problem 1) Scale the pattern in the driver so that printer does not
        // have to do anything or 2) Have the printer do the scaling. 
        // When pattern is downloaded as HPGL, we have to go with option 1 since
        // there is no way to tell HPGL the pattern dpi. i.e. When printing to 
        // 600 dpi printer in HPGL mode the pattern has to be scaled 4 times.
        // When pattern is downloaded as PCL we are in a little bit better position.
        // PCL expects the pattern to be correct for 300 dpi. If we are printing
        // to 600 dpi printer, the printer automatically scales up the pattern.
        // 
        // NOTE : if eImType == kHATCHBRUSHPATTERN, we do not scale the brush.
        //
        if (ulDeviceRes >= DPI_600 && eImType != kHATCHBRUSHPATTERN) 
        {
            //
            // For 600 dpi, we need the atleast double the size of the
            // brush. We may need to quadruple it if we are printing as HPGL.
            // That will be checked a little down in the code.
            //
            dwBrushExpansionFactor = 2;
        }

        // 
        // Now the Brush type is pattern. We have to take out the information 
        // of the pattern that is stored in psoPattern and put it into 
        // pBrush->Brush.pPattern.  
        // Color printers can handle the color data from the image easily.
        // But monochrome printers need a 1bpp image. If the image is 
        // not 1bpp and we are printing to monochrome printers, the image
        // has to be halftoned to monochrome.
        // What happens if the image is 1bpp, but it is not black and white.
        // Do we still have to halftone? hmmm, Yes and No. 
        // Ideally, we should. If there are two patterns that are exactly
        // the same but the color is different, if we dont halftone them,
        // they will print exactly the same. This is not correct. But
        // when I tried to halftone, the output was horrible, so we
        // are better off without it.
        // But in one case, output of halftoning is acceptable.
        // Thats when the psoPattern represent a hatch brush. 
        // Note : in this case, the hatch brush is not scaled.
        // Whatever GDI gives us, we just print it.
        //
        if ( BIsColorPrinter (pdevobj) ||
             ( psoPattern->iBitmapFormat == BMF_1BPP &&
                eImType != kHATCHBRUSHPATTERN )
           )
        {
            //
            // Get the source image data from the surface object
            //
            if (!InitRasterDataFromSURFOBJ(&srcImage, psoPattern, FALSE))
            {
                bRetVal = FALSE;
            }
        }
        else
        {
            //
            // For monochrome, we need to halftone the brush.
            // The halftoned image is stored in psoHT.
            //
            if ( !bCreateHTImage(&srcImage,
	                         psoTarget,     // psoDst,
	                         psoPattern,    // psoSrc,
                             &psoHT,
                             &hBmpHT,
	                         pxlo,
	                         iHatch) )
            {
                bRetVal = FALSE;
            }
        }

        //
        // For color printers some special processing is required depending on
        // the pxlo.
        //

        //
        // Get the source palette data from the translate object
        // If a direct image is passed in we will create a proxy of that image which
        // is translated to an indexed palette.  Don't forget to clean up!
        //
        //
        ASSERT(pxlo->cEntries <= MAX_PALETTE_ENTRIES);

        if ( bRetVal && BIsColorPrinter (pdevobj) )
        {
            if ((!InitPaletteFromXLATEOBJ(&srcPalette, pxlo)) ||
                (srcPalette.cEntries == 0)                    ||
                (srcImage.eColorMap  == HP_eDirectPixel))
            {
                bProxyDataUsed = TRUE;
                pSrcPalette    = CreateIndexedPaletteFromImage(&srcImage);
                pSrcImage      = CreateIndexedImageFromDirect(&srcImage, pSrcPalette);
                TranslatePalette(pSrcPalette, pSrcImage, pxlo);
            }
            else
            {
                bProxyDataUsed = FALSE;
                pSrcImage      = &srcImage;
                pSrcPalette    = &srcPalette;
            }

            if (pSrcImage == NULL || pSrcPalette == NULL)
            {
                bRetVal = FALSE;
            }
        } 

        //
        // Now we have all the information we need (the image, the palette etc...)
        // Now 
        // 1. allocate space for the brush (=image) using BRUSHOBJ_pvAllocRbrush. 
        // 2. Initialize the header values (i.e. type of image, its size, its location
        //    in memory).
        // 3. Then copy the image from pSrcImage to the brush.
        //

        //
        // CreateCompatiblePatternBrush does 1 and 2 and returns the pointer to
        // the memory it allocated.
        //
        if ( bRetVal)
        {  
            // 
            // Lets decide here whether to download the pattern as HPGL or PCL.
            // PCL patterns are generally smaller, so the output file size is small.
            // But it may take a cost to switch the printer from HPGL to PCL mode
            // 
            // If the pattern represents a hatch brush, then we download
            // as HPGL and dont scale it. The way PCL downloading is implemented
            // now, patterns are scaled to 300dpi. The firmware is told that pattern is
            // is at 300dpi, so it expands it to 600dpi. But in this case, we dont
            // want hatch brush to be scaled. So we download as HPGL. 
            // I could also change the PCL downloading so that it does not scale.
            // but that will mean testing lots of stuff. I am afraid to do it at
            // this late stage.
            //
            ERenderLanguage eRendLang = eUNKNOWN;
            
            if ( eImType == kHATCHBRUSHPATTERN )
            {
                bDownloadAsHPGL = TRUE;
            } 
            else if (BWhichLangToDwnldBrush(pdevobj, pSrcImage, &eRendLang) )
            {
                if ( eRendLang == eHPGL )
                {
                    bDownloadAsHPGL = TRUE;
                    //
                    // The exact same pattern downloaded as HPGL appears smaller
                    // on paper than when it is downloaded as HPGL. So it has
                    // to be expanded
                    //
                    dwBrushExpansionFactor *= 2;
                }
            }
            // else if BWhichLangToDwnldBrush fails or eRendLang != HPGL, then we 
            // we download as PCL.


            //
            // Now lets do the calculation to find out how much to expand
            // the brush. Either the brush is expanded, or left just like it is.
            // It is not compressed.
            // 
            dwBrushExpansionFactor /= dwBrushCompressionFactor;
            if ( dwBrushExpansionFactor < 1 )
            {
                dwBrushExpansionFactor = 1;
            }

            if ( (pBrush = CreateCompatiblePatternBrush(pbo, pSrcImage, pSrcPalette, 
	                                dwBrushExpansionFactor,
	                                psoPattern->iUniq, iHatch)  ) )
            {
                
                //
                // Retrieve the interesting parts of the brush into convenience variables
                //
                pDstPattern = (PPATTERN_DATA)pBrush->Brush.pPattern;
                pDstImage   = &pDstPattern->image;
                pDstPalette = &pDstPattern->palette;
                pDstPattern->eRendLang = bDownloadAsHPGL ? eHPGL : ePCL;
            } 
            else
            {
                bRetVal = FALSE;
            }
        }
                
        //
        // The palette is associated only with color printers. 
        // Monochrome printers accept only 1bpp images, and the palette consists
        // only of white color. So we dont explicitly need to have a 
        // a palette for them. We could choose to have one to specify whether
        // a bit set to 1 is black or white and viceversa. In RGB format, 
        // GDI gives us image in which 1 is white and 0 is black. We know this
        // so no need for palette.
        // For color printers printing 1bpp images, we will still want to have 
        // a palette, because the 1bpp does not definitely mean black and white.
        // Could be red and white or any 2 colors.
        //
        if ( bRetVal && 
             BIsColorPrinter(pdevobj) && 
             !CopyPalette(pDstPalette, pSrcPalette))
        {
            bRetVal = FALSE;
        }

        if ( bRetVal )
        {
            //
            // Monochrome printers accept 1 as black and 0 white, which is the reverse
            // of the format GDI gives. So we might need to reverse the image before 
            // copying it into brush. Make sure by looking at pxlo.
            //
            if ( !BIsColorPrinter (pdevobj) )
            {
                //
                // First check if pxlo has any color information. If the image 
                // is monochrome && pxlo is empty, then the image
                // needs to be inverted (This was found by using DTH5_LET.XLS printing
                // through Excel 5). If pxlo has no color information,
                // BImageNeedsInversion returns FALSE (i.e. image should not be 
                // inverted). This is reverse of what we want. 
                // Note : BImageNeedsInversion() is used for some other code paths
                // in which empty pxlo means inversion not required. But in the case
                // of monochrome brush, empty pxlo means image needs inverted.
                //
                if  ( (pxlo == NULL )               ||
                      (pxlo->pulXlate == NULL )     ||
                       BImageNeedsInversion(pdevobj, (ULONG)pSrcImage->colorDepth , pxlo) 
                    )
                {
                    bReverseImage = TRUE;
                }
            }

            if (dwBrushExpansionFactor > 1)
            {
                if (!StretchCopyImage(pDstImage, pSrcImage, pxlo, dwBrushExpansionFactor, bReverseImage))
                {
                    bRetVal = FALSE;
                }
            }
            else
            {
                if (!CopyRasterImage(pDstImage, pSrcImage, pxlo, bReverseImage))
                {
                    bRetVal = FALSE;
                }
            }
        }


        //
        // Free the shadows surface created in call to bCreateHTImage.
        //
        if ( hBmpHT != NULL )
        {
            DELETE_SURFOBJ(&psoHT, &hBmpHT);
        }

    } 

    else
    if (HPGL2Brush.BType == eBrushTypeSolid || HPGL2Brush.BType == eBrushTypeHatch)
    {

        VERBOSE(("RealizeBrush: eBrushTypeSolid or eBrushTypeHatch.\n"));

        //
        // Hatch Brushes also have color. So Hatch Brushes are 
        // SolidBrushes + HatchInfo
        //

        if ( (pBrush = (PBRUSHINFO)BRUSHOBJ_pvAllocRbrush(pbo, sizeof(BRUSHINFO))) )
        {
            ZeroMemory(pBrush, sizeof(BRUSHINFO) );
            pbo->pvRbrush = pBrush;
        }
        else
        {
            bRetVal = FALSE;
        }

        //
        // Initially I was realizing brush here (for monochrome printers). 
        // But now all solid brush
        // realization takes place in CreateAndDwnldSolidBrushForMono()
        //

        if ( bRetVal &&  HPGL2Brush.BType == eBrushTypeHatch)
        {
            pBrush->Brush.iHatch = iHatch;
        }
    }

    else
    {
        ERR(("HPGLRealizeBrush : Unknown Brush Type: Cannot RealizeBrush\n"));
        bRetVal = FALSE;
    }
    
    if ( bRetVal )
    {
        pBrush->dwPatternID         = dwPatternID;
        pBrush->bNeedToDownload     = TRUE;
        (pBrush->Brush).dwRGBColor  = dwForeColor;
        bRetVal                     = TRUE;
    }

    if (bProxyDataUsed)
    {
        if ( pSrcImage )
        {
            MemFree(pSrcImage);
            pSrcImage = NULL;
        }
        if ( pSrcPalette )
        {
            MemFree(pSrcPalette);
            pSrcPalette = NULL;
        }
    }

    return bRetVal;
}

BOOL BWhichLangToDwnldBrush(
        IN  PDEVOBJ          pdevobj, 
        IN  PRASTER_DATA     pSrcImage,
        OUT ERenderLanguage *eRendLang)
{
    if ( !pdevobj || !pSrcImage || !eRendLang)
    {
        return FALSE;
    }
    //
    // Download as PCL only if 
    // 1) Image is 1bpp or 8bpp. 
    //      - PCL downloading can only handle 1 or 8bpp (see PCL manual)
    // 2) Its size is bigger than 8*8.
    //      - I have not done any tests to see which is the size where downloading
    //        as PCL becomes better than HPGL. But conventional wisdom states that
    //        the bigger the size, the more the benefit, so lets go for 8*8 now.
    //
    if ( (pSrcImage->colorDepth == 1 ||  pSrcImage->colorDepth == 8) &&
         pSrcImage->size.cx * pSrcImage->size.cy > 64 )
    {
        *eRendLang = ePCL;
    }
    else
    {
        *eRendLang = eHPGL;
    }

    return TRUE;
}


/*++
Routine Name
    ULGetNup

Routine Description:
    Gets the n=up value from the unidrv's devmode.

Arguments:
    pdevobj     - The pointer to this device's PDEVOBJ
    pLayout     - The buffer that will receive the n-up number.
                  LAYOUT is defined in usermode\inc\devmode.h as an enum.

Return Value:
    TRUE if function succeeds. FALSE otherwise.

Author:
        hsingh
--*/
BOOL BGetNup(
    IN   PDEVOBJ  pdevobj,
    OUT  LAYOUT * pLayoutNup )
{
    REQUIRE_VALID_DATA(pdevobj && pLayoutNup, return FALSE);

    if ( ((PDEV *)pdevobj)->pdmPrivate )
    {
        *pLayoutNup = ((PDEV *)pdevobj)->pdmPrivate->iLayout;
        return TRUE;
    } 
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\rasdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
// 
// Module Name:
// 
//   rasdata.cpp
// 
// Abstract:
// 
//   
// 
// Environment:
// 
//   Windows 2000/Whistler Unidrv driver 
//
// Revision History:
// 
//   07/02/97 -v-jford-
//       Created it.
// 
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file

///////////////////////////////////////////////////////////////////////////////
// Local Macros.

#define BYTES_PER_ENTRY(bitsPerEntry) (bitsPerEntry / 8)

///////////////////////////////////////////////////////////////////////////////
// Local structures.

#define USE_COMPRESSION 1

#include "compress.h"

#ifdef USE_COMPRESSION
// Note these need to match RAS_PROC.CPP's definitions!
#define     NOCOMPRESSION    0
#define     RLE              1
#define     TIFF             2
#define     DELTAROW         3
#define     MAX_COMP_METHODS 4

class CBuffer
{
    BYTE *m_pData; // Pointer to buffer data
    UINT  m_nCapacity; // Size of allocated memory chunk
    INT   m_nSize; // Number of bytes of useful data
    
public:
    CBuffer(BYTE *pData, UINT nCapacity, INT nSize = -1);
    virtual ~CBuffer();
    
    // operator BYTE * () { return m_pData; }
    BYTE *Data();
    INT &Size();
    UINT &Capacity();
    
    // operator const BYTE * () const { return m_pData; }
    const BYTE *Data() const;
    INT Size() const;
    BOOL IsValid() const;
    UINT Capacity() const;
    
    virtual CBuffer &operator = (const CBuffer &buf);
    
protected:
    PBYTE &_Data();
};

class CDynBuffer : public CBuffer
{
public:
    CDynBuffer(UINT nCapacity);
    virtual ~CDynBuffer();
    
    CBuffer &operator = (const CBuffer &buf);
    
private:
    BOOL Resize(UINT nSize);
};

class CRasterCompMethod
{
    BOOL bOperationSuccessful;
public:
    CRasterCompMethod();
    virtual ~CRasterCompMethod();
    
    virtual void CompressCurRow() = 0;
    virtual void SendRasterRow(PDEVOBJ pDevObj, BOOL bNewMode) = 0;
    
    virtual INT GetSize() const = 0;
    virtual BOOL BGetSucceeded() const {return bOperationSuccessful;}
    virtual VOID VSetSucceeded(BOOL b) {bOperationSuccessful = b;} 
};

class CNoCompression : public CRasterCompMethod
{
    PRASTER_ITERATOR m_pIt;
    
public:
    CNoCompression(PRASTER_ITERATOR pIt);
    
    virtual void CompressCurRow();
    virtual void SendRasterRow(PDEVOBJ pDevObj, BOOL bNewMode);
    // virtual INT EstimateImageSize();
    
    virtual int GetSize() const;
};

class CTIFFCompression : public CRasterCompMethod
{
    CDynBuffer m_buf;
    PRASTER_ITERATOR m_pIt;
    
public:
    CTIFFCompression(PRASTER_ITERATOR pIt);
    ~CTIFFCompression();
    
    virtual void CompressCurRow();
    virtual void SendRasterRow(PDEVOBJ pDevObj, BOOL bNewMode);
    
    virtual int GetSize() const;
};

class CDeltaRowCompression : public CRasterCompMethod
{
    CDynBuffer m_seedRow;
    CDynBuffer m_buf;
    PRASTER_ITERATOR m_pIt;
    
public:
    CDeltaRowCompression(PRASTER_ITERATOR pIt);
    ~CDeltaRowCompression();
    
    virtual void CompressCurRow();
    virtual void SendRasterRow(PDEVOBJ pDevObj, BOOL bNewMode);
    
    virtual int GetSize() const;
};

HRESULT TIFFCompress(CBuffer &dst, const CBuffer &src);
HRESULT DeltaRowCompress(CBuffer &dst, const CBuffer &src, const CBuffer &seed);
HRESULT OutputRowBuffer(PRASTER_ITERATOR pIt, PDEVOBJ pDevObj, const CBuffer &row);

#endif

///////////////////////////////////////////////////////////////////////////////
// Local function prototypes.

LONG FindPaletteEntry(PPALETTE pPal, PPIXEL pPel);
VOID PixelFromPaletteEntry(PPALETTE pPal, ULONG nEntry, PPIXEL pPel);
BOOL AddPaletteEntry(PPALETTE pPal, PPIXEL pPel);

///////////////////////////////////////////////////////////////////////////////
// Implementation

///////////////////////////////////////////////////////////////////////////////
// InitRasterDataFromSURFOBJ()
//
// Routine Description:
// 
//   When a surface contains a raster image this function creates a RASTER_DATA
//   structure which copies the image information from the surface.
// 
// Arguments:
// 
//   pImage - the image to initialize
//   psoPattern - surface containing the pattern
// 
// Return Value:
// 
//   TRUE if successful, FALSE if there is an error
///////////////////////////////////////////////////////////////////////////////
BOOL InitRasterDataFromSURFOBJ(PRASTER_DATA pImage, SURFOBJ *psoPattern, BOOL bExclusive)
{
    if (pImage == NULL || psoPattern == NULL)
        return FALSE;
    
    pImage->pBits  = (BYTE*) psoPattern->pvBits;
    pImage->pScan0 = (BYTE*) psoPattern->pvScan0;
    pImage->size   = psoPattern->sizlBitmap;
    pImage->lDelta = psoPattern->lDelta;
    pImage->bExclusive = bExclusive;
    
    switch (psoPattern->iBitmapFormat)
    {
    case BMF_1BPP:
        pImage->eColorMap  = HP_eIndexedPixel;
        pImage->colorDepth = 1;
        break;
        
    case BMF_4BPP:
        pImage->eColorMap  = HP_eIndexedPixel;
        pImage->colorDepth = 4;
        break;
        
    case BMF_4RLE:
        pImage->eColorMap  = HP_eDirectPixel;
        pImage->colorDepth = 8; // BUGBUG: Is this correct? JFF
        break;
        
    case BMF_8RLE:
    case BMF_8BPP:
        pImage->eColorMap = HP_eIndexedPixel;
        pImage->colorDepth = 8;
        break;
        
    case BMF_16BPP:
        pImage->eColorMap  = HP_eDirectPixel;
        pImage->colorDepth = 16;
        break;
        
    case BMF_24BPP:
        pImage->eColorMap  = HP_eDirectPixel;
        pImage->colorDepth = 24;
        break;
        
    case BMF_32BPP:
        pImage->eColorMap  = HP_eDirectPixel;
        pImage->colorDepth = 32;
        break;
        
    default:
        // Error: unsupported bitmap type.
        return FALSE;
        
    }
    
    pImage->cBytes = CalcBitmapSizeInBytes(pImage->size, pImage->colorDepth);
    
    //
    // Check for valid computation
    //
    ASSERT(pImage->cBytes == psoPattern->cjBits);
    ASSERT(abs(pImage->lDelta) == (LONG)CalcBitmapDeltaInBytes(pImage->size, 
        pImage->colorDepth));
    
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CreateCompatibleRasterImage()
//
// Routine Description:
// 
//   This function creates a new RASTER_DATA structure which is the same kind
//   as the source RASTER_DATA, but has the dimensions of the given rectangle.
//   This function allocates memory and it is the responsibility of the client
//   to deallocate the pointer when it's done.
// 
// Arguments:
// 
//   pSrcImage - the source image
//   prclDst - the desired dimensions
// 
// Return Value:
// 
//   PRASTER_DATA: the new image if successful, else NULL.
///////////////////////////////////////////////////////////////////////////////
PRASTER_DATA CreateCompatibleRasterImage(PRASTER_DATA pSrcImage, PRECTL prclDst)
{
    SIZEL        sizlDst;
    DWORD        cDstImageSize;
    DWORD        cAllocBytes;
    PRASTER_DATA pDstImage;

    if ((pSrcImage == NULL) || (prclDst == NULL))
    {
        WARNING(("CreateCompatibleRasterImage: Invalid arguments given.\n"));
        return NULL;
    }

    sizlDst.cx = RECTL_Width(prclDst);
    sizlDst.cy = RECTL_Height(prclDst);
    //dstRect = CbrRect(prclDst, TRUE);
    //dstSize = dstRect.GetSize();

    cDstImageSize = CalcBitmapSizeInBytes(sizlDst, pSrcImage->colorDepth);
    cAllocBytes = sizeof(RASTER_DATA) + cDstImageSize;
    pDstImage = (PRASTER_DATA) MemAlloc(cAllocBytes);
    if (pDstImage == NULL)
    {
        WARNING(("CreateCompatibleRasterImage: Unable to allocate new image memory.\n"));
        return NULL;
    }
    ZeroMemory(pDstImage, cAllocBytes);

    //
    // Initialize the fields of the newly created image
    //
    pDstImage->pBits      = ((BYTE*) pDstImage) + sizeof(RASTER_DATA);
    pDstImage->pScan0     = pDstImage->pBits;
    pDstImage->cBytes     = cDstImageSize;
    pDstImage->size       = sizlDst;
    pDstImage->colorDepth = pSrcImage->colorDepth;
    pDstImage->lDelta     = CalcBitmapDeltaInBytes(pDstImage->size, pDstImage->colorDepth);
    pDstImage->eColorMap  = pSrcImage->eColorMap;
    pDstImage->bExclusive = pSrcImage->bExclusive;

    return pDstImage;
}

///////////////////////////////////////////////////////////////////////////////
// InitPaletteFromXLATEOBJ()
//
// Routine Description:
// 
//   This function uses an XLATEOBJ to fill the given palette.
// 
// Arguments:
// 
//   pPal - the palette to fill
//   pxlo - the given palette
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL InitPaletteFromXLATEOBJ(PPALETTE pPal, XLATEOBJ *pxlo)
{
    if (pPal == NULL || pxlo == NULL)
        return FALSE;

    // pPal->whiteIndex = -1;
    pPal->bitsPerEntry = 32; // XLATEOBJ uses 32 bits per entry.

    pPal->cEntries = (pxlo->flXlate & XO_TABLE) ? min(pxlo->cEntries, PCL_RGB_ENTRIES) : 0;

    // Determine Indexed or Direct bitmap.
    if((pxlo->iSrcType == PAL_INDEXED) || (pPal->cEntries > 0))
    {
        if(pxlo->pulXlate == NULL)
        {
            pPal->pEntries = (BYTE*) XLATEOBJ_piVector(pxlo);
        }
        else
        {
            pPal->pEntries = (BYTE*) pxlo->pulXlate;
        }
    }

    if (pPal->pEntries == NULL)
        return FALSE;

    return TRUE;
}

#ifdef COMMENTEDOUT
///////////////////////////////////////////////////////////////////////////////
// InitPalette()
//
// Routine Description:
// 
//   It appears that this function already exists in RASTER.CPP.
// 
// Arguments:
// 
//   pPal - palette to initialize
//   pEntries - the palette entries
//   cEntries - number of entries
//   bitsPerEntry - bits per palette entry
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL InitPalette(PPALETTE pPal, BYTE *pEntries, ULONG cEntries, LONG bitsPerEntry)
{
    if (pPal == NULL || pEntries == NULL)
        return FALSE;

    pPal->pEntries = pEntries;
    pPal->cEntries = cEntries;
    pPal->bitsPerEntry = bitsPerEntry;
    // pPal->whiteIndex = -1;

    return TRUE;
}
#endif


///////////////////////////////////////////////////////////////////////////////
// GetPaletteEntry()
//
// Routine Description:
// 
//   This function retrieves the palette entry and copies it into a pixel.
//   i.e. pel = Palette[index]
// 
// Arguments:
// 
//   pPal - the source palette
//   index - the location to retrieve
//   pPel - the destination pixel
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL GetPaletteEntry(PPALETTE pPal, ULONG index, PPIXEL pPel)
{
    BYTE *pSrc;
    LONG  bytesPerEntry;
    LONG  i;

    if (pPal == NULL || pPel == NULL)
        return FALSE;

    if (index >= pPal->cEntries)
        return FALSE;

    bytesPerEntry = BYTES_PER_ENTRY(pPal->bitsPerEntry);
    pSrc = pPal->pEntries + (index * bytesPerEntry);

    pPel->bitsPerPixel = pPal->bitsPerEntry;
    pPel->color.dw = 0;
    for (i = 0; i < bytesPerEntry; i++)
    {
        pPel->color.b4[i] = pSrc[i];
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// SetPaletteEntry()
//
// Routine Description:
// 
//   This function sets the palette entry to the given pixel value.
//   i.e. Palette[index] = pel
// 
// Arguments:
// 
//   pPal - palette to modify
//   index - entry
//   pPel - the new value
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL SetPaletteEntry(PPALETTE pPal, ULONG index, PPIXEL pPel)
{
    BYTE *pDst;
    LONG  bytesPerEntry;
    LONG  i;

    if (pPal == NULL || pPel == NULL)
        return FALSE;

    if (index >= pPal->cEntries)
        return FALSE;

    bytesPerEntry = BYTES_PER_ENTRY(pPal->bitsPerEntry);
    pDst = pPal->pEntries + (index * bytesPerEntry);

    switch(pPel->bitsPerPixel)
    {
    case 16:
        //
        // The destination palette was created for 24bpp i.e. it 
        // uses 3 bytes for every color. 16 bpp uses only 2 bytes,
        // so setting third byte to zero.
        //
        pDst[0] = pPel->color.b4[0];
        pDst[1] = pPel->color.b4[1];
        pDst[2] = 0;
        break;
    case 24:
    case 32: //4th byte is ignored.
        pDst[0] = pPel->color.b4[0];
        pDst[1] = pPel->color.b4[1];
        pDst[2] = pPel->color.b4[2];
        break;
    default:
        for (i = 0; i < bytesPerEntry; i++)
        {
            pDst[i] = pPel->color.b4[i];
        }
        break;
    } // End of switch

    return TRUE;
}

    
///////////////////////////////////////////////////////////////////////////////
// CreateIndexedPaletteFromImage()
//
// Routine Description:
// 
//   This function is used when palettizing an image.  In this function we 
//   create a new palette and populate it with the unique pixel values.
//   Note that this function allocates memory and it is up to the client to
//   free it.
// 
// Arguments:
// 
//   pSrcImage - the source image
// 
// Return Value:
// 
//   PPALETTE: New palette if successful, else NULL.
///////////////////////////////////////////////////////////////////////////////
PPALETTE CreateIndexedPaletteFromImage(PRASTER_DATA pSrcImage)
{
    const ULONG kMaxPaletteEntries = (ULONG)MAX_PALETTE_ENTRIES;
    const LONG kEntrySize = 3;
    
    RASTER_ITERATOR srcIt;
    PPALETTE pDstPalette;
    PIXEL pel;
    LONG row;
    LONG col;
    

    if (pSrcImage == NULL)
    {
        WARNING(("CreateIndexedPaletteFromImage: Source image was NULL.\n"));
        return NULL;
    }

    //
    // This function is only desgned to work on direct pixels.  Indexed 
    // should be handled naturally from CreateCompatiblePatternBrush.
    //
    //ASSERT(pSrcImage->eColorMap == HP_eDirectPixel);
    //ASSERT(pSrcImage->colorDepth == 24);
    if (pSrcImage->eColorMap != HP_eDirectPixel) 
    {
        WARNING(("CreateIndexedPaletteFromImage: Image eColorMap is already Indexed.\n"));
        return NULL;
    }
    if ( ! (pSrcImage->colorDepth == 16 ||
            pSrcImage->colorDepth == 24 ||
            pSrcImage->colorDepth == 32) )
    {
        WARNING(("CreateIndexedPaletteFromImage: Invalid image colorDepth=%d.\n", 
            pSrcImage->colorDepth));
        return NULL;
    }

    
    // 
    // Allocate enough space for a 256 (=MAX_PALETTE_ENTRIES = kMaxPaletteEntries) 
    // entry by 24bpp palette.
    //
    pDstPalette = (PPALETTE) MemAlloc(sizeof(PALETTE) + (kEntrySize * kMaxPaletteEntries));
    if (pDstPalette == NULL)
    {
        ERR(("Unable to allocate temporary palette.\n"));
        return NULL;
    }
    
    pDstPalette->bitsPerEntry = kEntrySize * 8;
    pDstPalette->cEntries = 0;
    pDstPalette->pEntries = ((BYTE*) pDstPalette) + sizeof(PALETTE);
    // pDstPalette->whiteIndex = -1;

    //
    // Iterate through the source image and create palette entries for each 
    // unique color entry.
    // 
    RI_Init(&srcIt, pSrcImage, NULL, 0);
    
    for (row = 0; row < RI_NumRows(&srcIt); row++)
    {
        RI_SelectRow(&srcIt, row);
        
        for (col = 0; col < RI_NumCols(&srcIt); col++)
        {
            RI_GetPixel(&srcIt, col, &pel);
            
            if (FindPaletteEntry(pDstPalette, &pel) == -1)
            {
                if (!AddPaletteEntry(pDstPalette, &pel))
                {
                    //
                    // Too many unique colors.  Lets just quit. 
                    //
                    MemFree(pDstPalette);
                    return NULL;
                }
            }
        }
    }
    
    return pDstPalette;
}

///////////////////////////////////////////////////////////////////////////////
// CreateIndexedImageFromDirect()
//
// Routine Description:
// 
//   This function is used when palettizing an image.  In this function we 
//   use the palette and the source image to create a new image which uses
//   the palette instead of pixel values.  Note that this funtion allocates
//   memory and it is up to the client to release it.
// 
// Arguments:
// 
//   pSrcImage - the source image
//   pDstPalette - a palette of unique colors from the source image
// 
// Return Value:
// 
//   PRASTER_DATA: New image if successful, else NULL.
///////////////////////////////////////////////////////////////////////////////
PRASTER_DATA CreateIndexedImageFromDirect(PRASTER_DATA pSrcImage, 
                                          PPALETTE pDstPalette)
{
    const LONG kDstBitsPerPixel = 8;
    const ULONG kMaxPaletteEntries = (ULONG)MAX_PALETTE_ENTRIES;
    
    RASTER_ITERATOR srcIt;
    RASTER_ITERATOR dstIt;
    LONG row;
    LONG col;
    PIXEL pel;
    PRASTER_DATA pDstImage;
    LONG cDstImageSize;
    
    if ((pSrcImage == NULL) || (pDstPalette == NULL))
    {
        WARNING(("CreateIndexedImageFromDirect: Invalid arguments given.\n"));
        return NULL;
    }
    
    //
    // Calculate the size of the new indexed bitmap given that we're going to
    // use 8bpp for each index.
    //
    cDstImageSize = CalcBitmapSizeInBytes(pSrcImage->size, kDstBitsPerPixel);
    pDstImage = (PRASTER_DATA) MemAlloc(sizeof(RASTER_DATA) + cDstImageSize);
    if (pDstImage == NULL)
    {
        WARNING(("CreateIndexedImageFromDirect: Unable to allocate new image memory.\n"));
        return NULL;
    }
    
    //
    // Initialize the fields of the newly created image
    //
    pDstImage->pBits      = ((BYTE*) pDstImage) + sizeof(RASTER_DATA);
    pDstImage->pScan0     = pDstImage->pBits;
    pDstImage->cBytes     = cDstImageSize;
    pDstImage->size       = pSrcImage->size;
    pDstImage->colorDepth = kDstBitsPerPixel;
    pDstImage->lDelta     = CalcBitmapDeltaInBytes(pDstImage->size, pDstImage->colorDepth);
    pDstImage->eColorMap  = HP_eIndexedPixel;
    pDstImage->bExclusive = pSrcImage->bExclusive;
    
    //
    // Copy the source bitmap, using the index of each palette entry as 
    // the destination pixel.
    //
    RI_Init(&srcIt, pSrcImage, NULL, 0);
    RI_Init(&dstIt, pDstImage, NULL, 0);
    
    for (row = 0; row < RI_NumRows(&srcIt); row++)
    {
        RI_SelectRow(&srcIt, row);
        RI_SelectRow(&dstIt, row);
        
        for (col = 0; col < RI_NumCols(&srcIt); col++)
        {

            LONG lPalEntry = 0;
            //
            // FindPaletteEntry returns LONG. 
            // pel.color.dw is a DWORD which is 32 bit UNSIGNED integer. 
            // So we should not directly assign a LONG to DWORD.
            // This came to light when compiling with CLEAN_64BIT set to 1.
            // Note: FindPaletteEntry returns -1 if it fails.
            //
            RI_GetPixel(&srcIt, col, &pel);

            //
            // The destination palette was made for 24bpp (i.e. 3 valid bytes)
            // But if the pixel is of 32bpp (i.e. 4 valid bytes). The one
            // extra byte may cause FindPaletteEntry to fail. 
            // To convert 32bpp to 24bpp, just set the extra byte to 0;
            // 
            if ( pel.bitsPerPixel == 32 )
            {
                pel.color.dw &= 0x00FFFFFF; 
            }

            lPalEntry = FindPaletteEntry(pDstPalette, &pel);
            
            ASSERT(lPalEntry != -1);
            ASSERT(lPalEntry < kMaxPaletteEntries);
            
            if ( lPalEntry < 0 || lPalEntry > (kMaxPaletteEntries-1))
            {
                pel.color.dw = 0;
            }
            else
            {
                pel.color.dw = (DWORD)lPalEntry;
            }
            pel.bitsPerPixel = kDstBitsPerPixel;
            RI_SetPixel(&dstIt, col, &pel);
        }
    }
    
    return pDstImage;
}


///////////////////////////////////////////////////////////////////////////////
// CreateCompatiblePatternBrush()
//
// Routine Description:
// 
//   This function creates a pattern brush from the given bitmap pattern.
//   Normally I would admonish the reader to free the image data created
//   by this routine, however, the operating system owns this memory.
// 
// Arguments:
// 
//   pbo - Brush object
//   pSrcImage - the bitmap pattern
//   pSrcPal - palette for source image
//   bExpandImage - whether to stretch pattern (good for hi-res printers)
//   iUniq - ID for brush
//   iHatch - predefined hatching pattern (currently ignored)
// 
// Return Value:
// 
//   PBRUSHINFO: the newly created pattern brush if successful, else NULL.
///////////////////////////////////////////////////////////////////////////////
PBRUSHINFO CreateCompatiblePatternBrush(BRUSHOBJ *pbo, PRASTER_DATA pSrcImage, 
                                        PPALETTE pSrcPal, DWORD dwBrushExpansionFactor,
                                        LONG iUniq, LONG iHatch)
{
    PBRUSHINFO pNewBrush;
    SIZEL dstSize;
    LONG  dstColorDepth;
    LONG  cDstImageSize;
    LONG  cDstPalSize       = 0;
    LONG  cTotalBrushSize;
    PRASTER_DATA pDstImage;
    PPALETTE pDstPalette;
    PPATTERN_DATA pDstPattern;

    if (pbo == NULL || pSrcImage == NULL )
        return NULL;

    //
    // For high-resolution devices the pattern needs to be expanded.
    //
    dstSize.cx = pSrcImage->size.cx * dwBrushExpansionFactor;
    dstSize.cy = pSrcImage->size.cy * dwBrushExpansionFactor;

    //
    // The destination color depth may differ from source.
    //
    switch (pSrcImage->colorDepth)
    {
    case 16:
    case 32:
        // Map 16bpp or 32bpp onto 24bpp
        dstColorDepth = 24;
        break;

    default:
        // All others get identical color depth.
        dstColorDepth = pSrcImage->colorDepth;
        break;
    }

    //
    // Now we have enough information to calculate the destination image size
    //
    cDstImageSize = CalcBitmapSizeInBytes(dstSize, dstColorDepth);

    //
    // Determine how large the palette needs to be.  Use 24 bits per entry
    // No palette required if pSrcPal is NULL.
    //
    if ( pSrcPal )
    {
        cDstPalSize = (pSrcPal->cEntries * 3);  // I could've used '* 24 / 8'
    }

    //
    // Put all the parts together and calculate how large the brush needs to be
    //
    cTotalBrushSize = sizeof(BRUSHINFO) + sizeof(PATTERN_DATA) + cDstImageSize + cDstPalSize;

    pNewBrush = (PBRUSHINFO) BRUSHOBJ_pvAllocRbrush(pbo, cTotalBrushSize);

    if (pNewBrush == NULL)
    {
        return NULL;
    }

    //
    // Set up the memory pointers into this newly allocated region of memory
    //

    // Set brush members
    pNewBrush->Brush.pPattern = (PPATTERN_DATA) (((BYTE*) pNewBrush) + sizeof(BRUSHINFO));

    // Use convenience variable pPattern, and pImage, and pPalette
    pDstPattern = pNewBrush->Brush.pPattern;
    pDstImage   = &pDstPattern->image;
    pDstPalette = &pDstPattern->palette;

    // The pattern data is fairly simple
    pDstPattern->eColorSpace = HP_eRGB;
    pDstPattern->iPatIndex   = iHatch;
    pDstPattern->eRendLang   = eUNKNOWN;
    pDstPattern->ePatType    = kBRUSHPATTERN;

    // The raster data is located just after the pattern data
    pDstImage->pBits      = (BYTE*) (((BYTE*) pDstPattern) + sizeof(PATTERN_DATA));
    pDstImage->pScan0     = pDstImage->pBits;
    pDstImage->cBytes     = cDstImageSize;
    pDstImage->size       = dstSize;
    pDstImage->colorDepth = dstColorDepth;
    pDstImage->lDelta     = CalcBitmapDeltaInBytes(pDstImage->size, pDstImage->colorDepth);
//  pDstImage->eColorMap  = (pSrcPal->cEntries == 0) ? HP_eDirectPixel : HP_eIndexedPixel;
    pDstImage->bExclusive = FALSE;

    // Only allow pattern brushes with indexed palettes!
    // ASSERT(pDstImage->eColorMap == HP_eIndexedPixel);

    // The palette data is last--located after the image data
    pDstPalette->pEntries     = pDstImage->pBits + cDstImageSize;
    pDstPalette->bitsPerEntry = 24;
//  pDstPalette->cEntries     = pSrcPal->cEntries;
    // pDstPalette->whiteIndex   = -1;

    //
    // Monochrome printers will pass pSrcPal as NULL. In that case
    // do not initialize the pDstPalette.
    //
    if (pSrcPal)
    {
        pDstImage->eColorMap   = (pSrcPal->cEntries == 0) ? HP_eDirectPixel : HP_eIndexedPixel;
        pDstPalette->cEntries  = pSrcPal->cEntries;
    }

    //
    // Treat the brush object as read-only.  The current call will not get
    // this brush as pbo->pvRbrush, but rather as the return value to 
    // BRUSHOBJ_pvGetRbrush.  If this brush is used again in the future then 
    // you'll see this value in pbo->pvRbrush.  However, we aren't really 
    // supposed to set it ourselves.  I talked to DavidX about this and he'll 
    // look into it.
    //
    pbo->pvRbrush = pNewBrush;
    
    //
    // If we had to create our own versions of the source image and palette
    // make sure to remove them now (or leak memory!).
    //
    
    return pNewBrush;
}

///////////////////////////////////////////////////////////////////////////////
// CopyPalette()
//
// Routine Description:
// 
//   This function copies one palette to another using a deep copy and will
//   convert the pixels if the two palettes do not have the same bpp.
//   i.e. Dest = Src
// 
// Arguments:
// 
//   pDst - destination palette
//   pSrc - source palette
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL CopyPalette(PPALETTE pDst, PPALETTE pSrc)
{
    if (pDst == NULL || pSrc == NULL)
    {
        ERR(("Invalid parameters.\n"));
        return FALSE;
    }

    if (pDst->bitsPerEntry < 1 || pDst->bitsPerEntry > 32)
    {
        ERR(("Invalid palette entry size.\n"));
        return FALSE;
    }

    if (pSrc->bitsPerEntry < 1 || pDst->bitsPerEntry > 32)
    {
        ERR(("Invalid palette entry size.\n"));
        return FALSE;
    }

    if (pDst->cEntries != pSrc->cEntries)
    {
        ERR(("Mismatch palette entries.\n"));
        return FALSE;
    }

    if (pSrc->bitsPerEntry == pDst->bitsPerEntry)
    {
        // Simple case: the palettes are identical. Just copy the memory.
        memcpy(pDst->pEntries, pSrc->pEntries, CalcPaletteSize(pSrc->cEntries, pSrc->bitsPerEntry));
    }
    else
    {
        // We can handle certain cases.  Have a look-see.
        if (pSrc->bitsPerEntry == 32 && pDst->bitsPerEntry == 24)
        {
            // To convert 32 to 24 copy the first three bytes of each entry and
            // ignore the fourth source byte.
            BYTE* pSrcBits = (BYTE*) pSrc->pEntries;
            BYTE* pDstBits = (BYTE*) pDst->pEntries;
            ULONG i;

            for (i = 0; i < pSrc->cEntries; i++)
            {
                pDstBits[0] = pSrcBits[0];
                pDstBits[1] = pSrcBits[1];
                pDstBits[2] = pSrcBits[2];

                pDstBits += BYTES_PER_ENTRY(pDst->bitsPerEntry);
                pSrcBits += BYTES_PER_ENTRY(pSrc->bitsPerEntry);
            }
        }
        else if (pSrc->bitsPerEntry >= 24 && pDst->bitsPerEntry == 8)
        {
            ULONG i;
            BYTE* pRGB = (BYTE*) pSrc->pEntries;

            for (i = 0; i < pSrc->cEntries; i++)
            {
                pDst->pEntries[i] = RgbToGray(pRGB[0], pRGB[1], pRGB[2]);
                pRGB += BYTES_PER_ENTRY(pDst->bitsPerEntry);
            }
        }
        else
        {
            ERR(("Unable to convert palette.\n"));
            return FALSE;
        }
    }
    // pDst->whiteIndex = -1;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// TranslatePalette()
//
// Routine Description:
// 
//   This function translates all of the palette entries using the OS
//   supplied XLATEOBJ.
//   i.e. Pal = Pal * xlo
// 
// Arguments:
// 
//   pPal - Palette to be translated
//   pImage - source image (caches xlateFlags)
//   pxlo - xlate object
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID TranslatePalette(PPALETTE pPal, PRASTER_DATA pImage, XLATEOBJ *pxlo)
{
    DWORD  xlateFlags;
    PIXEL  pel;
    ULONG  i;

    if (pPal == NULL || pImage == NULL || pxlo == NULL)
    {
        WARNING(("TranslatePalette: NULL parameter given.\n"));
        return;
    }

    xlateFlags = CheckXlateObj(pxlo, pImage->colorDepth);

    for (i = 0; i < pPal->cEntries; i++)
    {
        GetPaletteEntry(pPal, i, &pel);
        TranslatePixel(&pel, pxlo, xlateFlags);
        SetPaletteEntry(pPal, i, &pel);
    }
}

///////////////////////////////////////////////////////////////////////////////
// FindPaletteEntry()
//
// Routine Description:
// 
//   This function locates the first palette entry which matches the given
//   pixel.
// 
// Arguments:
// 
//   pPal - Palette to search
//   pPel - pixel to find
// 
// Return Value:
// 
//   LONG: palette index if successful, else -1.
///////////////////////////////////////////////////////////////////////////////
LONG FindPaletteEntry(PPALETTE pPal, PPIXEL pPel)
{
    ULONG i;
    PIXEL palEntry;
    
    for (i = 0; i < pPal->cEntries; i++)
    {
        PixelFromPaletteEntry(pPal, i, &palEntry);
        if (pPel->color.dw == palEntry.color.dw)
            return (LONG)i;
    }
    
    return -1;
}

///////////////////////////////////////////////////////////////////////////////
// PixelFromPaletteEntry()
//
// Routine Description:
// 
//   This function appears to be a duplicate of GetPaletteEntry.
//   i.e. pel = Palette[nEntry]
// 
// Arguments:
// 
//   pPal - Palette 
//   nEntry - desired palette index 
//   pPel - destination pixel
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID PixelFromPaletteEntry(PPALETTE pPal, ULONG nEntry, PPIXEL pPel)
{
    BYTE* pPalEntry;
    LONG nBytesPerEntry;
    LONG i;
    
    if ((pPal == NULL) || (pPel == NULL))
        return;
    
    if (nEntry >= pPal->cEntries)
        return;
    
    nBytesPerEntry = BYTES_PER_ENTRY(pPal->bitsPerEntry);
    pPalEntry = pPal->pEntries + (nEntry * nBytesPerEntry);
    pPel->bitsPerPixel = pPal->bitsPerEntry;
    pPel->color.dw = 0;
    
    ASSERT(pPal->bitsPerEntry >= 8);
    ASSERT(nBytesPerEntry <= 4);
    
    for (i = 0; i < nBytesPerEntry; i++)
    {
        pPel->color.b4[i] = pPalEntry[i];
    }
}

///////////////////////////////////////////////////////////////////////////////
// AddPaletteEntry()
//
// Routine Description:
// 
//   This function adds the new color value to the given palette.
// 
// Arguments:
// 
//   pPal - destination Palette 
//   pPel - source pixel
// 
// Return Value:
// 
//   TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL AddPaletteEntry(PPALETTE pPal, PPIXEL pPel)
{
    const ULONG kMaxPaletteEntries = (ULONG)MAX_PALETTE_ENTRIES;
    
    if ((pPal == NULL) || (pPel == NULL))
        return FALSE;
    
    if (pPal->cEntries >= kMaxPaletteEntries) 
    {
        return FALSE;
    }
    
    //
    // Since SetPaletteEntry won't place entries higher than cEntries we'll
    // have to bump it up one.  Then, if it doesn't work, reduce it again.
    //
    pPal->cEntries++;
    if (SetPaletteEntry(pPal, (pPal->cEntries - 1), pPel))
    {
        return TRUE;
    }
    else
    {
        pPal->cEntries--;
        return FALSE;
    }
}

///////////////////////////////////////////////////////////////////////////////
// DownloadPaletteAsPCL()
//
// Routine Description:
// 
//   This function sends a palette as a series of PCL palette entry commands.
//   It is assumed that an appropriate RGB palette has already been selected.
// 
// Arguments:
// 
//   pDevObj - the device
//   pPalette - palette to download
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL DownloadPaletteAsPCL(PDEVOBJ pDevObj, PPALETTE pPalette)
{
    ULONG i;

    if (pDevObj == NULL || pPalette == NULL)
        return FALSE;
    
    if (pPalette->bitsPerEntry >= 24)
    {
        for (i = 0; i < pPalette->cEntries; i++)
        {
            ULONG offset = i * BYTES_PER_ENTRY(pPalette->bitsPerEntry);
            PCL_sprintf(pDevObj, "\033*v%da%db%dc%dI", 
                                 pPalette->pEntries[offset + 0],
                                 pPalette->pEntries[offset + 1],
                                 pPalette->pEntries[offset + 2],
                                 i);
        }
        
        return TRUE;
    }
    else
    {
        WARNING(("Cannot download this palette!"));
        return FALSE;
    }
}

///////////////////////////////////////////////////////////////////////////////
// DownloadPaletteAsHPGL()
//
// Routine Description:
// 
//   Output the color palette entries as pens.  Allocate enough pens for the 
//   palette.  Note that if the number is less than 10 I'm going to have 10 
//   pens anyway.
// 
// Arguments:
// 
//   pDevObj - devobj
//   pPalette - palette to download
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL DownloadPaletteAsHPGL(PDEVOBJ pDevObj, PPALETTE pPalette)
{
    ULONG i;

    if (pDevObj == NULL || pPalette == NULL)
        return FALSE;

    if (pPalette->bitsPerEntry >= 24)
    {
        // HPGL_FormatCommand(pDevObj, "NP%d;", max(HPGL_TOTAL_PENS, pPalette->cEntries));
        HPGL_SetNumPens(pDevObj, max(HPGL_TOTAL_PENS, pPalette->cEntries), NORMAL_UPDATE);

        for (i = 0; i < pPalette->cEntries; i++)
        {
            COLORREF color;
            ULONG offset = i * BYTES_PER_ENTRY(pPalette->bitsPerEntry);
            color = RGB(pPalette->pEntries[offset + 0],
                        pPalette->pEntries[offset + 1],
                        pPalette->pEntries[offset + 2]);

            /*
            // when the whiteIndex is specified swap the palette entries 0 and
            // whiteIndex.
            if (pPalette->whiteIndex > 0)
            {
                if (i == 0)
                {
                    HPGL_DownloadPaletteEntry(pDevObj, pPalette->whiteIndex, color);
                }
                else if (i == pPalette->whiteIndex)
                {
                    HPGL_DownloadPaletteEntry(pDevObj, 0, color);
                }
                else
                {
                    HPGL_DownloadPaletteEntry(pDevObj, i, color);
                }
            }
            else
            */
            {
                HPGL_DownloadPaletteEntry(pDevObj, i, color);
            }
        }

        return TRUE;
    }
    else
    {
        WARNING(("Cannot download this palette!"));
        return FALSE;
    }
}

///////////////////////////////////////////////////////////////////////////////
// StretchCopyImage()
//
// Routine Description:
// 
//   Copies the image from the source to destination structures inflating the
//   source image by a factor of 2.  Each pixel is translated by the xlateobj.
// 
// Arguments:
// 
//   pDstImage - desination image
//   pSrcImage - source image
//   pxlo - color translate obj
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL StretchCopyImage(
        PRASTER_DATA pDstImage, 
        PRASTER_DATA pSrcImage, 
        XLATEOBJ    *pxlo,
        DWORD        dwBrushExpansionFactor,
        BOOL        bInvert)
{
    RASTER_ITERATOR srcIt;
    RASTER_ITERATOR dstIt;
    LONG            srcRow, srcCol;
    LONG            dstRow, dstCol;
    DWORD           xlateFlags;

    if (!pDstImage || !pSrcImage || !pxlo)
        return FALSE;

    if ( dwBrushExpansionFactor == 0 )
    {
        //
        // Since later on we are doing (dstCol % dwBrushExpansionFactor)
        // so if dwBrushExpansionFactor == 0, this might cause divide by zero
        // exception.
        //
        return FALSE;
    }

    xlateFlags = CheckXlateObj(pxlo, pSrcImage->colorDepth);

    RI_Init(&srcIt, pSrcImage, NULL, xlateFlags);
    RI_Init(&dstIt, pDstImage, NULL, xlateFlags);

    srcRow = 0;
    for (dstRow = 0; dstRow < RI_NumRows(&dstIt); dstRow++)
    {
        RI_SelectRow(&srcIt, srcRow);
        RI_SelectRow(&dstIt, dstRow);

        srcCol = 0;
        for (dstCol = 0; dstCol < RI_NumCols(&dstIt); dstCol++)
        {
            PIXEL pel;

            RI_GetPixel(&srcIt, srcCol, &pel);
            TranslatePixel(&pel, pxlo, xlateFlags);
            RI_SetPixel(&dstIt, dstCol, &pel);

            if ( dstCol % dwBrushExpansionFactor == (dwBrushExpansionFactor-1) )
            {
                srcCol++;
            }
        }

        if ( bInvert)
        {
            RI_VInvertBits(&dstIt);
        }
        if ( dstRow % dwBrushExpansionFactor == (dwBrushExpansionFactor-1) )
        {
            srcRow++;
        }
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CopyRasterImage()
//
// Routine Description:
// 
//   Copy the raster image.
//   i.e. Dest = Src * xlo
// 
// Arguments:
// 
//   pDst - destination image
//   pSrc - source image
//   pxlo - translate object
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL CopyRasterImage(
    PRASTER_DATA pDst, 
    PRASTER_DATA pSrc, 
    XLATEOBJ *pxlo,
    BOOL      bInvert)
{
    return CopyRasterImageRect(pDst, pSrc, NULL, pxlo, bInvert);
}

///////////////////////////////////////////////////////////////////////////////
// CopyRasterImageRect()
//
// Routine Description:
// 
//   Copy a rectangle out of the source into the destination.  It is assumed
//   that the destination is the right size to receive the data.
// 
// Arguments:
// 
//   pDst - destination image
//   pSrc - source image
//   prSel - region to copy, if NULL copy entire image.
//   pxlo - color translation obj
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL CopyRasterImageRect(
        PRASTER_DATA pDst, 
        PRASTER_DATA pSrc, 
        PRECTL       prSel, 
        XLATEOBJ    *pxlo,
        BOOL         bInvert)
{
    RASTER_ITERATOR srcIt;
    RASTER_ITERATOR dstIt;
    DWORD           fXlateFlags;
    LONG            row;

    fXlateFlags = pxlo ? CheckXlateObj(pxlo, pSrc->colorDepth) : 0;

    RI_Init(&srcIt, pSrc, prSel, fXlateFlags);
    RI_Init(&dstIt, pDst, NULL, fXlateFlags);

    for (row = 0; row < RI_NumRows(&srcIt); row++)
    {
        RI_SelectRow(&srcIt, row);
        RI_SelectRow(&dstIt, row);

        CopyRasterRow(&dstIt, &srcIt, pxlo, bInvert);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// DownloadPatternAsHPGL()
//
// Routine Description:
// 
//   This function outputs an image as an HPGL pattern.
// 
// Arguments:
// 
//   pdevobj - the device
//   pImage - the image to download
//   iPatternNumber - the unique patter ID (if we cached them this'd be useful)
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL DownloadPatternAsHPGL(
        PDEVOBJ         pDevObj,
        PRASTER_DATA    pImage,
        PPALETTE        pPal,
        EIMTYPE         ePatType,
        LONG            iPatternNumber)
{
    RASTER_ITERATOR it;
    LONG            row;
    LONG            col;
    PIXEL           pel;

    if (pDevObj == NULL || pImage == NULL)
        return FALSE;

    RI_Init(&it, pImage, NULL, 0);

    HPGL_BeginPatternFillDef(pDevObj, 
                             iPatternNumber, 
                             RI_NumCols(&it),
                             RI_NumRows(&it));
                             // pImage->size.cx, 
                             // pImage->size.cy);

    for (row = 0; row < RI_NumRows(&it); row++)
    {
        RI_SelectRow(&it, row);

        for (col = 0; col < RI_NumCols(&it); col++)
        {
            RI_GetPixel(&it, col, &pel);

            /*
            //
            // If the whiteIndex is defined then swap 0 and whiteIndex fields
            //
            if (pPal->whiteIndex > 0)
            {
                if (pel.color.dw == 0)
                    HPGL_AddPatternFillField(pDevObj, pPal->whiteIndex);
                else if (pel.color.dw == pPal->whiteIndex)
                    HPGL_AddPatternFillField(pDevObj, 0);
                else
                    HPGL_AddPatternFillField(pDevObj, pel.color.dw);
            }
            else
            */
            {
                HPGL_AddPatternFillField(pDevObj, pel.color.dw);
            }
        }
    }

    HPGL_EndPatternFillDef(pDevObj);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// BeginRasterDownload()
//
// Routine Description:
// 
//   This function sends the Start Raster command along with the source and
//   (possibly) destination regions depending on whether the source and dest
//   regions are the same size.  Scaling is automatic although the source and
//   destinatiton coordinates should all be in device units. Gaposis is managed
//   by BSetDestinationWidthHeight.
// 
// Arguments:
// 
//   pDevObj - the device
//   psizlSrc - the size of the source region in device units
//   prDst - the destination region in device units
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
static BOOL BeginRasterDownload(PDEVOBJ pDevObj, SIZEL *psizlSrc, PRECTL prDst)
{
    REQUIRE_VALID_DATA(pDevObj, return FALSE);
    REQUIRE_VALID_DATA(psizlSrc, return FALSE);
    REQUIRE_VALID_DATA(prDst, return FALSE);

    POINTL ptlCAP;
    ptlCAP.x = prDst->left;
    ptlCAP.y = prDst->top;
    PCL_SetCAP(pDevObj, NULL, NULL, &ptlCAP);

    PCL_SourceWidthHeight(pDevObj, psizlSrc);

    SIZEL sizlDst;
    sizlDst.cx = RECTL_Width(prDst);
    sizlDst.cy = RECTL_Height(prDst);
    //
    // Compare the sizes of the source and destination rectangles.  If they are
    // different then turn on scaling.
    //
    if ((psizlSrc->cx == sizlDst.cx) &&
        (psizlSrc->cy == sizlDst.cy))
    {
        return PCL_StartRaster(pDevObj, NOSCALE_MODE);
    }
    else
    {
        //
        // The function BSetDestinationWidthHeight fixes the
        // "gaposis" problem caused by round-off error.
        //
        BSetDestinationWidthHeight(pDevObj, sizlDst.cx, sizlDst.cy);
        return PCL_StartRaster(pDevObj, SCALE_MODE);
    }

    // Unreachable code (for Alpha 64 compiler)
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// EndRasterDownload()
//
// Routine Description:
// 
//   This function provides a symmetric interface for Begin/EndRasterDownload
// 
// Arguments:
// 
//   pDevObj - the device
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
static BOOL EndRasterDownload(PDEVOBJ pDevObj)
{
    return PCL_EndRaster(pDevObj);
}

///////////////////////////////////////////////////////////////////////////////
// DownloadImageAsPCL()
//
// Routine Description:
// 
//   This function downloads the image as a PCL pattern.  Note that it doesn't
//   work right now and I'm just not using it.
// 
// Arguments:
// 
//   pDevObj - the device
//   prDst - destination rect
//   pSrcImage - image
//   prSel - source rect
//   pxlo - color translation obj
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL DownloadImageAsPCL(PDEVOBJ pDevObj, PRECTL prDst, PRASTER_DATA pSrcImage, 
                        PRECTL prSel, XLATEOBJ *pxlo)
{
    RASTER_ITERATOR srcIt;
    RASTER_ITERATOR rowIt;
    LONG            row;
    PRASTER_DATA    pDstRow;
    DWORD           dwXlateFlags;
    BOOL            bInvert = FALSE;
    POEMPDEV        poempdev;

    REQUIRE_VALID_DATA( (pDevObj && pSrcImage && prDst && prSel), return FALSE);
    poempdev = (POEMPDEV)pDevObj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE);
    

    //
    // For monochrome some images may have to be inverted because
    // GDI's black and white are opposite of what the printer
    // expects. If an image needs to be inverted, one of the 
    // calling functions will set the flag to PDEVF_INVERT_BITMAP.
    // We can only handle inverting 1bpp images.
    //
    if ( (poempdev->dwFlags & PDEVF_INVERT_BITMAP) && 
         (pSrcImage->colorDepth == 1))
    { 
        bInvert = TRUE;
    }

    //
    // Construct an image buffer of a single row that matches the 
    // source image attributes.
    //
    RECTL rRow;
    RECTL_SetRect(&rRow, 0, 0, RECTL_Width(prSel), 1);

    pDstRow = CreateCompatibleRasterImage(pSrcImage, &rRow);
    REQUIRE_VALID_ALLOC(pDstRow, return FALSE);

    //
    // Set up iterators for the source image and the row buffer.  Make sure
    // that the xlo information gets used.
    //
    dwXlateFlags = pxlo ? CheckXlateObj(pxlo, pSrcImage->colorDepth) : 0;

    RI_Init(&srcIt, pSrcImage, prSel, dwXlateFlags);
    RI_Init(&rowIt, pDstRow, NULL, dwXlateFlags);

    //
    // Begin the raster sequence.
    //
    SIZEL sizlSrc;
    sizlSrc.cx = RI_NumCols(&srcIt);
    sizlSrc.cy = RI_NumRows(&srcIt);

    //
    // Don't send anything if there are no pixels to output.
    //
    if (sizlSrc.cx * sizlSrc.cy == 0)
    {
        MemFree(pDstRow);
        return TRUE;
    }

    //
    // Paranoia
    //
    OEMResetXPos(pDevObj);
    OEMResetYPos(pDevObj);

    BeginRasterDownload(pDevObj, &sizlSrc, prDst);

#ifdef USE_COMPRESSION
    CRasterCompMethod *pCompMethods[MAX_COMP_METHODS];
    int nCompMethods = 0;
    BOOL bUseCompression = TRUE;
    CRasterCompMethod *pBestCompMethod = 0;
    CRasterCompMethod *pLastCompMethod = 0;
    
    pCompMethods[nCompMethods++] = new CNoCompression(&rowIt);
    pCompMethods[nCompMethods++] = new CTIFFCompression(&rowIt);
    pCompMethods[nCompMethods++] = new CDeltaRowCompression(&rowIt);

    //
    // Check whether allocation succeeded above. If not, dont
    // use compression.
    // 
    if ( !(pCompMethods[0] && (pCompMethods[0]->GetSize() > 0) &&
           pCompMethods[1] && (pCompMethods[1]->GetSize() > 0) &&
           pCompMethods[2] && (pCompMethods[2]->GetSize() > 0) ))
    {
        bUseCompression = FALSE;
    }
#endif
    
    RI_SelectRow(&rowIt, 0);
    for (row = 0; row < RI_NumRows(&srcIt); row++)
    {
        RI_SelectRow(&srcIt, row);

        CopyRasterRow(&rowIt, &srcIt, pxlo, bInvert);
        
#ifdef USE_COMPRESSION
        if ( !bUseCompression)
        {
            RI_OutputRow(&rowIt, pDevObj);
            continue;
        }
        

        //
        // Let each compression method have a whack at the row.  Keep track
        // of the best one in pBestCompMethod.
        //
        if (nCompMethods > 0)
            pBestCompMethod = pCompMethods[0];
        
        for (int i = 0; i < nCompMethods; i++)
        {
            pCompMethods[i]->CompressCurRow();
            if ((pCompMethods[i]->GetSize() >= 0) && 
                (pCompMethods[i]->BGetSucceeded()) && 
                (pCompMethods[i]->GetSize() < pBestCompMethod->GetSize()))
            {
                pBestCompMethod = pCompMethods[i];
            }
        }
        
        //
        // Print out the row, but if the compression method failed somehow then
        // just print out the uncompressed row.
        //
        if (pBestCompMethod && (pBestCompMethod->GetSize() >= 0))
        {
            pBestCompMethod->SendRasterRow(pDevObj, (pLastCompMethod != pBestCompMethod));
            pLastCompMethod = pBestCompMethod;
        }
        else
        {
            PCL_CompressionMode(pDevObj, NOCOMPRESSION);
            RI_OutputRow(&rowIt, pDevObj);
        }
#else
        RI_OutputRow(&rowIt, pDevObj);
#endif
    }
    
    EndRasterDownload(pDevObj);

#ifdef USE_COMPRESSION
    //
    // Free all compression method objects
    //
    for (int i = 0; i < nCompMethods; i++)
    {
        if ( pCompMethods[i] )
        {
            delete pCompMethods[i];
        }
    }
#endif
    
    MemFree(pDstRow);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Local helper functions.

///////////////////////////////////////////////////////////////////////////////
// CalcBitmapDeltaInBytes()
//
// Routine Description:
// 
//   Calculates the number of bytes in a line of bitmap data.  The delta is
//   the number of bytes in a row plus padding to be DWORD aligned.
// 
// Arguments:
// 
//   size - bitmap dimensions
//   colorDepth - bits per pixel
// 
// Return Value:
// 
//   ULONG: number of bytes per line
///////////////////////////////////////////////////////////////////////////////
ULONG CalcBitmapDeltaInBytes(SIZEL size, LONG colorDepth)
{
    ULONG cBytes = CalcBitmapWidthInBytes(size, colorDepth);
    cBytes = (cBytes + 3) & ~3; // the with in bytes including padding

    return cBytes;
}

///////////////////////////////////////////////////////////////////////////////
// CalcBitmapWidthInBytes()
//
// Routine Description:
// 
//   Calculates the number of bytes in a row of bitmap data.
// 
// Arguments:
// 
//   size - bitmap dimensions
//   colorDepth - bits per pixel
// 
// Return Value:
// 
//   ULONG: number of bytes per row
///////////////////////////////////////////////////////////////////////////////
ULONG CalcBitmapWidthInBytes(SIZEL size, LONG colorDepth)
{
    ULONG cBytes = size.cx;     // the width in pixels
    cBytes *= colorDepth;       // the width in bits
    cBytes = (cBytes + 7) / 8;  // the width in bytes

    return cBytes;
}

///////////////////////////////////////////////////////////////////////////////
// CalcBitmapSizeInBytes()
//
// Routine Description:
// 
//   Calculates the number of bytes needed to store a bitmap.
// 
// Arguments:
// 
//   size - bitmap dimensions
//   colorDepth - bits per pixel
// 
// Return Value:
// 
//   ULONG: number of bytes needed to store the bitmap
///////////////////////////////////////////////////////////////////////////////
ULONG CalcBitmapSizeInBytes(SIZEL size, LONG colorDepth)
{
    return CalcBitmapDeltaInBytes(size, colorDepth) * size.cy;
}

///////////////////////////////////////////////////////////////////////////////
// CalcPaletteSize()
//
// Routine Description:
// 
//   Calculates the number of bytes needed to store the palette.
// 
// Arguments:
// 
//   cEntries - number of palette entries
//   bitsPerEntry - bits per palette entry
// 
// Return Value:
// 
//   DWORD: number of bytes needed to store the palette
///////////////////////////////////////////////////////////////////////////////
DWORD CalcPaletteSize(ULONG cEntries, LONG bitsPerEntry)
{
    return cEntries * BYTES_PER_ENTRY(bitsPerEntry);
}

///////////////////////////////////////////////////////////////////////////////
// RI_Init()
//
// Routine Description:
// 
//   RasterIterator::Init().  This function gets the iterator ready to
//   work over the given image.
// 
// Arguments:
// 
//   pIt - the iterator
//   pImage - image to iterate over
//   prSel - selected rect or NULL
//   xlateFlags - keep track of the xlateflags
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID RI_Init(PRASTER_ITERATOR pIt, PRASTER_DATA pImage, PRECTL prSel, DWORD xlateFlags)
{
    if (pIt == NULL || pImage == NULL)
        return;

    pIt->pImage = pImage;
    if (prSel == NULL)
    {
        RECTL_SetRect(&pIt->rSelection, 0, 0, pImage->size.cx, pImage->size.cy);
    }
    else
    {
        RECTL_CopyRect(&pIt->rSelection, prSel);
    }
    pIt->pCurRow = NULL;
    pIt->fXlateFlags = xlateFlags;
}

///////////////////////////////////////////////////////////////////////////////
// RI_SelectRow()
//
// Routine Description:
// 
//   RasterIterator::SelectRow.  This function sets the current pos of the 
//   iterator to the first pixel in the given row.
// 
// Arguments:
// 
//   pIt - the iterator
//   row - row number relative to selected rectangle
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID RI_SelectRow(PRASTER_ITERATOR pIt, LONG row)
{
    if (pIt == NULL)
        return ;

    if ((row + pIt->rSelection.top) >= pIt->pImage->size.cy)
    {
        pIt->pCurRow = NULL;
    }
    else
    {
        pIt->pCurRow = pIt->pImage->pScan0 + 
                       (pIt->pImage->lDelta * (row + pIt->rSelection.top));
    }
}

VOID RI_VInvertBits(PRASTER_ITERATOR pIt)
{
    if (pIt == NULL)
        return ;

    if (pIt->pCurRow)
    {
        vInvertScanLine((PBYTE)pIt->pCurRow, (ULONG)RI_NumCols(pIt));
    }

    return ;
}


///////////////////////////////////////////////////////////////////////////////
// RI_NumRows()
//
// Routine Description:
// 
//   RasterIterator::NumRows().  This function returns the number of rows
//   to be iterated over.
// 
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   LONG: number of rows
///////////////////////////////////////////////////////////////////////////////
LONG RI_NumRows(PRASTER_ITERATOR pIt)
{
    if (pIt == NULL)
        return 0;

    // Handle bottom-right exclusive
    return RECTL_Height(&pIt->rSelection) - (pIt->pImage->bExclusive ? 1 : 0);
}

///////////////////////////////////////////////////////////////////////////////
// RI_NumCols()
//
// Routine Description:
// 
//   RasterIterator::NumCols.  Returns the number of columns in the image to
//   be iterated.
// 
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   LONG: number of columns
///////////////////////////////////////////////////////////////////////////////
LONG RI_NumCols(PRASTER_ITERATOR pIt)
{
    if (pIt == NULL)
        return 0;

    // Handle bottom-right exclusive
    return RECTL_Width(&pIt->rSelection) - (pIt->pImage->bExclusive ? 1 : 0);
}

///////////////////////////////////////////////////////////////////////////////
// RI_GetRowSize()
//
// Routine Description:
// 
//   RasterIterator::GetRowSize.  Returns the number of bytes of data per row.
// 
// Arguments:
// 
//   pIt - the iterator
// 
// Return Value:
// 
//   LONG: number of bytes of data per row
///////////////////////////////////////////////////////////////////////////////
LONG RI_GetRowSize(PRASTER_ITERATOR pIt)
{
    SIZEL size;
    size.cx = RI_NumCols(pIt);
    size.cy = 1;
    return CalcBitmapWidthInBytes(size, pIt->pImage->colorDepth);
}

///////////////////////////////////////////////////////////////////////////////
// RI_GetPixel()
//
// Routine Description:
// 
//   RasterIterator::GetPixel().  This  function retrieves the pixel at the
//   given row/col.  The row needs to be selected already by RI_SelectRow().
//   i.e. pel = it.image[row][col];
// 
// Arguments:
// 
//   pIt - the iterator
//   col - column index relative to selected rectangle
//   pPel - destination pixel
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL RI_GetPixel(PRASTER_ITERATOR pIt, LONG col, PPIXEL pPel)
{
    LONG bitOffset;
    LONG byteIndex;
    LONG bitIndex;
    BYTE* pCol;

    pPel->bitsPerPixel = pIt->pImage->colorDepth;
    pPel->color.dw = 0;

    //
    // Check to make sure you're still inside the bitmap
    //
    if ((pIt->pCurRow == NULL) || 
        ((col + pIt->rSelection.left) >= pIt->pImage->size.cx))
    {
        return FALSE;
    }

    bitOffset = (col + pIt->rSelection.left) * pIt->pImage->colorDepth;
    byteIndex = bitOffset / 8;
    bitIndex = bitOffset % 8;
    pCol = pIt->pCurRow + byteIndex;

    switch(pPel->bitsPerPixel)
    {
    case 1:
        bitIndex = 7 - bitIndex; // Start with MSBs
        pPel->color.b4[0] = ((*pCol & (0x01 << bitIndex)) >> bitIndex);
        break;
    case 4:
        bitIndex = (bitIndex + 4) % 8; // Start with MSBs
        pPel->color.b4[0] = ((*pCol & (0x0F << bitIndex)) >> bitIndex);
        break;
    case 8:
        pPel->color.b4[0] = *pCol;
        break;
    case 16:
        pPel->color.b4[0] = pCol[0];
        pPel->color.b4[1] = pCol[1];
        break;
    case 24:
        pPel->color.b4[0] = pCol[0];
        pPel->color.b4[1] = pCol[1];
        pPel->color.b4[2] = pCol[2];
        //PixelSwapRGB(pPel);
        break;
    case 32:
        pPel->color.b4[0] = pCol[0];
        pPel->color.b4[1] = pCol[1];
        pPel->color.b4[2] = pCol[2];
        pPel->color.b4[3] = pCol[3];
        //PixelSwapRGB(pPel);
        break;
    default:
        WARNING(("Unknown bit depth encountered.\n"));
        break;
    }
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// RI_SetPixel()
//
// Routine Description:
// 
//   RasterIterator::SetPixel().  This function sets the image data at the
//   given row/col (use SelectRow to set the row) to the given pixel.
//   i.e. it.image[row][col] = pel
// 
// Arguments:
// 
//   arg - descrip
// 
// Return Value:
// 
//   retval descrip
///////////////////////////////////////////////////////////////////////////////
BOOL RI_SetPixel(PRASTER_ITERATOR pIt, LONG col, PPIXEL pPel)
{
    LONG bitOffset;
    LONG byteIndex;
    LONG bitIndex;
    BYTE* pCol;

    //
    // Check to make sure you're still inside the bitmap
    //
    if ((pIt->pCurRow == NULL) || 
        ((col + pIt->rSelection.left) >= pIt->pImage->size.cx))
    {
        return FALSE;
    }

    bitOffset = (col + pIt->rSelection.left) * pIt->pImage->colorDepth;
    byteIndex = bitOffset / 8;
    bitIndex = bitOffset % 8;
    pCol = pIt->pCurRow + byteIndex;

    if (pPel->bitsPerPixel == pIt->pImage->colorDepth)
    {
        switch (pPel->bitsPerPixel)
        {
        case 1:
            bitIndex = 7 - bitIndex; // Start with MSBs
            *pCol &= ~(0x01 << bitIndex);   // First clear out the bit
            *pCol |= (pPel->color.b4[0] << bitIndex); // Now set it
            break;
        case 4:
            bitIndex = (bitIndex + 4) % 8; // Start with MSBs
            *pCol &= ~(0x0F << bitIndex);  // Clear out the nibble
            *pCol |= ((pPel->color.b4[0] & 0x0F) << bitIndex); // Set the value
            break;
        case 8:
            *pCol = pPel->color.b4[0];
            break;
        case 16:
            pCol[0] = pPel->color.b4[0];
            pCol[1] = pPel->color.b4[1];
            break;
        case 24:
            pCol[0] = pPel->color.b4[0];
            pCol[1] = pPel->color.b4[1];
            pCol[2] = pPel->color.b4[2];
            break;
        case 32:
            WARNING(("Suspicious bit depth found.\n"));
            pCol[0] = pPel->color.b4[0];
            pCol[1] = pPel->color.b4[1];
            pCol[2] = pPel->color.b4[2];
            pCol[3] = pPel->color.b4[3];
            break;
        default:
            WARNING(("Unknown bit depth encountered.\n"));
            break;
        }
    }
    else
    {
        // Special case: 24bpp to 8bpp
        if ((pIt->pImage->colorDepth == 8) && (pPel->bitsPerPixel >= 24))
        {
            *pCol = RgbToGray(pPel->color.b4[0], pPel->color.b4[1], pPel->color.b4[2]);
        }
        // Special case: 32bpp to 24bpp
        else if ((pIt->pImage->colorDepth == 24) && (pPel->bitsPerPixel >= 24))
        {
            pCol[0] = pPel->color.b4[0];
            pCol[1] = pPel->color.b4[1];
            pCol[2] = pPel->color.b4[2];
        }
        else
        {
            WARNING(("Unknown color conversion.\n"));
        }
    }
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// RI_OutputRow()
//
// Routine Description:
// 
//   Sends the current row to the output device.  Use RI_SelectRow to pick your
//   row.
//
//   This function has been expanded to handle compression by using two default
//   parameters pAltRowBuf and nAltRowSize which have default values of 0.  To
//   send uncompressed data call RI_OutputRow(&it, pDevObj), but if you've
//   compressed into a buffer you can send it by calling 
//   RI_OutputRow(&it, pDevObj, pMyBuf, nMySize).
// 
// Arguments:
// 
//   pIt - iterator
//   pdevobj - the device
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL RI_OutputRow(PRASTER_ITERATOR pIt, PDEVOBJ pDevObj, BYTE *pAltRowBuf, INT nAltRowSize)
{
    if (pDevObj == NULL || pIt == NULL)
        return FALSE;

    if (pIt->pCurRow == NULL)
        return FALSE;

    if (pAltRowBuf)
    {
        PCL_SendBytesPerRow(pDevObj, nAltRowSize);

        if (nAltRowSize)
            PCL_Output(pDevObj, pAltRowBuf, nAltRowSize);
    }
    else
    {
        PCL_SendBytesPerRow(pDevObj, pIt->pImage->lDelta);

        PCL_Output(pDevObj, pIt->pCurRow, pIt->pImage->lDelta);
    }

    return TRUE;
}

#ifdef COMMENTEDOUT
///////////////////////////////////////////////////////////////////////////////
// RI_CreateCompRowBuffer()
//
// Routine Description:
// 
//   This function allocates a buffer for a compressed row.  Since some 
//   compression algorithms can--at worst--inflate the data size by almost a 
//   factor of 2 we will allocate 2x the row size.
//   Note: This function allocates memory.  The client must free using MemFree.
// 
// Arguments:
// 
//   pIt - image iterator
// 
// Return Value:
// 
//   Pointer to newly allocated row buffer.
///////////////////////////////////////////////////////////////////////////////
BYTE* RI_CreateCompRowBuffer(PRASTER_ITERATOR pIt)
{
    return (BYTE*) MemAllocZ(RI_GetRowSize(pIt) * 2);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CopyRasterRow()
//
// Routine Description:
// 
//   This function copies a single raster row using iterators.  It is handy 
//   when working with selected regions of an image or when DWORD alignment
//   or bit alignment are a problem.
//   i.e. dst.image[row] = src.image[row] * xlo
// 
// Arguments:
// 
//   pDstIt - destination image
//   pSrcIt - source image
//   pxlo - color translation obj
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL CopyRasterRow(
        PRASTER_ITERATOR pDstIt, 
        PRASTER_ITERATOR pSrcIt, 
        XLATEOBJ        *pxlo, 
        BOOL             bInvert)
{
    PIXEL pel;
    LONG col;

    for (col = 0; col < RI_NumCols(pSrcIt); col++)
    {
        RI_GetPixel(pSrcIt, col, &pel);
        TranslatePixel(&pel, pxlo, pSrcIt->fXlateFlags);
        RI_SetPixel(pDstIt, col, &pel);
    }

    if (bInvert)
    {
        RI_VInvertBits(pDstIt);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// TranslatePixel()
//
// Routine Description:
// 
//   Applies the translation to the given pixel
// 
// Arguments:
// 
//   pPel - pixel to translate
//   pxlo - translation object
//   xlateFlags - flags to make life easier
// 
// Return Value:
// 
//   BOOL: TRUE if successful, else FALSE.
///////////////////////////////////////////////////////////////////////////////
BOOL TranslatePixel(PPIXEL pPel, XLATEOBJ *pxlo, DWORD xlateFlags)
{
    if (pPel == NULL)
        return FALSE;

    if (pxlo == NULL)
        return TRUE;

    if (xlateFlags & SC_SWAP_RB)
    {
        if ((pPel->bitsPerPixel == 24) ||
            (pPel->bitsPerPixel == 32))
        {
            PixelSwapRGB(pPel);
        }
    }
    else if (xlateFlags & SC_IDENTITY)
    {
        // No operation required
    }
    else if (pPel->bitsPerPixel >= 16)
    {
        pPel->color.dw = XLATEOBJ_iXlate(pxlo, pPel->color.dw);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// PixelSwapRGB()
//
// Routine Description:
// 
//   Swaps the R and B values of the given pixel.  Handy because this is one of
//   the stock xlate actions.
// 
// Arguments:
// 
//   pPel - pixel to translate
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID PixelSwapRGB(PPIXEL pPel)
{
    BYTE temp = pPel->color.b4[2];
    pPel->color.b4[2] = pPel->color.b4[0];
    pPel->color.b4[0] = temp;
}

///////////////////////////////////////////////////////////////////////////////
// OutputPixel() OBSOLETE
//
// Routine Description:
// 
//   Outputs a single pixel.  I don't this this function is used anymore.
// 
// Arguments:
// 
//   pDevObj - the device
//   pPel - pixel to translate
// 
// Return Value:
// 
//   LONG: the number of bytes sent.
///////////////////////////////////////////////////////////////////////////////
LONG OutputPixel(PDEVOBJ pDevObj, PPIXEL pPel)
{
    LONG nBytesToSend;

    switch (pPel->bitsPerPixel)
    {
    case 1:
    case 4:
    case 16:
    case 32:
        nBytesToSend = 0;
        break;

    case 8:
        nBytesToSend = 1;
        break;

    case 24:
        nBytesToSend = 3;
        break;
    }

    if (nBytesToSend > 0)
        PCL_Output(pDevObj, &(pPel->color.dw), nBytesToSend);

    return nBytesToSend;
}


#ifdef USE_COMPRESSION
///////////////////////////////////////////////////////////////////////////////
// Compression implementation

///////////////////////////////////////////////////////////////////////////////
// CBuffer::CBuffer() CTOR
//
// Routine Description:
// 
//   Initializes a buffer on a chunk of memory.  If nSize is not given or is
//   -1 then the number of data bytes is assumed to be the entire buffer.
// 
// Arguments:
// 
//   pData - pointer to memory
//   nCapacity - number of bytes controlled by pData
//   nSize - number of data bytes in pData
// 
// Return Value:
// 
//   None
///////////////////////////////////////////////////////////////////////////////
CBuffer::CBuffer(BYTE *pData, UINT nCapacity, INT nSize) 
{ 
    if ( (m_pData = pData) )
    {
        m_nCapacity = nCapacity; 
        if ( nSize  == -1)
        {
            m_nSize = nCapacity; 
        }
        else
        {
            m_nSize = nSize; 
        }
    } 
    else
    {
        m_nCapacity = 0;
        m_nSize     = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
// CBuffer::~CBuffer() DTOR
//
// Routine Description:
// 
//   Nothing.
// 
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   None
///////////////////////////////////////////////////////////////////////////////
CBuffer::~CBuffer() 
{ 
}

///////////////////////////////////////////////////////////////////////////////
// CBuffer::Data()
//
// Routine Description:
// 
//   Returns a r/w pointer to the data in the buffer.
// 
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   Pointer to data buffer
///////////////////////////////////////////////////////////////////////////////
BYTE *CBuffer::Data() 
{ 
    return m_pData; 
}

///////////////////////////////////////////////////////////////////////////////
// CBuffer::Size()
//
// Routine Description:
// 
//   Returns a r/w pointer to the data in the buffer.
// 
// Arguments:
// 
//   None.
// 
// Return Value:
// 
//   Pointer to data buffer
///////////////////////////////////////////////////////////////////////////////
INT &CBuffer::Size() 
{ 
    return m_nSize; 
}

UINT &CBuffer::Capacity() 
{ 
    return m_nCapacity; 
}

const BYTE *CBuffer::Data() const 
{ 
    return m_pData; 
}

INT CBuffer::Size() const 
{ 
    return m_nSize; 
}

BOOL CBuffer::IsValid() const 
{ 
    return (m_pData) && (m_nSize <= (INT) m_nCapacity); 
}

UINT CBuffer::Capacity() const 
{ 
    return m_nCapacity; 
}

CBuffer &CBuffer::operator = (const CBuffer &buf) 
{ 
    if (IsValid() && buf.IsValid())
    {
        memcpy(m_pData, buf.m_pData, min(buf.m_nSize, (INT) m_nCapacity)); 
    }
    
    return *this; 
}

PBYTE &CBuffer::_Data() 
{ 
    return m_pData; 
}

CDynBuffer::CDynBuffer(UINT nCapacity) : 
CBuffer((BYTE*)MemAllocZ(nCapacity), nCapacity) 
{ 
}

CDynBuffer::~CDynBuffer() 
{ 
    if ( Data () )
    {
        MemFree(Data()); 
    }
}

CBuffer &CDynBuffer::operator = (const CBuffer &buf) 
{ 
    if ( Resize(buf.Capacity()) )
    {
        return CBuffer::operator = (buf);
    }
    
    //
    // If Resize fails, set the number of valid bytes to -1 
    //
    Size() = -1;
    return *this;
}

BOOL CDynBuffer::Resize(UINT nNewCapacity) 
{ 
    BOOL bRetVal = TRUE;
    if (nNewCapacity > Capacity()) 
    { 
        BYTE* pNewData = (BYTE*) MemAllocZ(nNewCapacity); 
        if ( pNewData )
        {
            memcpy(pNewData, Data(), Size()); 
            MemFree(Data()); 
            _Data() = pNewData; 
            Capacity() = nNewCapacity; 
        }
        else
        {
            bRetVal = FALSE;
        }
    }
    return bRetVal;
}

CRasterCompMethod::CRasterCompMethod()
{
    //
    // Initalize to FALSE in this constructor
    //
    bOperationSuccessful = FALSE;
}

CRasterCompMethod::~CRasterCompMethod() 
{ 
}

CNoCompression::CNoCompression(PRASTER_ITERATOR pIt) : m_pIt(pIt) 
{ 
}

void CNoCompression::CompressCurRow() 
{ 
    VSetSucceeded(TRUE);
}

void CNoCompression::SendRasterRow(PDEVOBJ pDevObj, BOOL bNewMode)
{ 
    if (bNewMode)
        PCL_CompressionMode(pDevObj, NOCOMPRESSION); 
    RI_OutputRow(m_pIt, pDevObj); 
}

int CNoCompression::GetSize() const 
{ 
    return RI_GetRowSize(m_pIt); 
}

CTIFFCompression::CTIFFCompression(PRASTER_ITERATOR pIt) : m_pIt(pIt), m_buf(RI_GetRowSize(pIt) * 2)
{ 
}

CTIFFCompression::~CTIFFCompression() 
{ 
}

void CTIFFCompression::CompressCurRow()
{ 
    CBuffer row(m_pIt->pCurRow, RI_GetRowSize(m_pIt));
    
    if (row.IsValid() && TIFFCompress(m_buf, row) == S_OK )
    {
        VSetSucceeded(TRUE);
    }
    else
    {
        VSetSucceeded(FALSE);
        m_buf.Size() = -1;
    }
}

void CTIFFCompression::SendRasterRow(PDEVOBJ pDevObj, BOOL bNewMode)
{ 
    if (m_buf.IsValid())
    { 
        if (bNewMode)
            PCL_CompressionMode(pDevObj, TIFF); 
        OutputRowBuffer(m_pIt, pDevObj, m_buf);
    } 
}

int CTIFFCompression::GetSize() const 
{ 
    return m_buf.Size();
}

CDeltaRowCompression::CDeltaRowCompression(PRASTER_ITERATOR pIt) : 
m_pIt(pIt), m_buf(RI_GetRowSize(pIt) * 2), m_seedRow(RI_GetRowSize(pIt) * 2)
{ 
}

CDeltaRowCompression::~CDeltaRowCompression() 
{ 
}

void CDeltaRowCompression::CompressCurRow()
{
    int iLimit = (UINT) m_buf.Capacity();
    VSetSucceeded(FALSE);
    //
    // If the seed row has not been initialized properly,
    // then we cant proceed.
    //
    if ( m_seedRow.Size() == -1 )
    {
        m_buf.Size() = -1;
        return;
    }

    CBuffer row(m_pIt->pCurRow, RI_GetRowSize(m_pIt)); 
    if (row.IsValid())
    {
        if ( (DeltaRowCompress(m_buf, row, m_seedRow) == S_OK) &&
             (m_buf.Size() != -1) )
        {
            VSetSucceeded(TRUE);
        }
        
        // The previous row becomes the seed row regardless of which compression 
        // method is used on the current row.
        if (m_buf.Size() != 0)
        {
            //
            // This is an overloaded equalto operator.
            // A mem alloc is involved in the = function.
            // If memalloc fails, that function sets 
            // m_seedRow.Size() to -1 
            //
            m_seedRow = row;
        }

    }
    else
    {
        m_buf.Size() = -1;
    }
}

void CDeltaRowCompression::SendRasterRow(PDEVOBJ pDevObj, BOOL bNewMode)
{
    if (m_buf.IsValid() && m_buf.Size() >= 0)
    {
        if (bNewMode)
            PCL_CompressionMode(pDevObj, DELTAROW); 
        OutputRowBuffer(m_pIt, pDevObj, m_buf);
    }
}

int CDeltaRowCompression::GetSize() const 
{ 
    return m_buf.Size(); 
}

HRESULT TIFFCompress(CBuffer &dst, const CBuffer &src)
{
    if (dst.IsValid() && src.IsValid())
    {
        dst.Size() = iCompTIFF (dst.Data(), dst.Capacity(), src.Data(), src.Size());
        return S_OK;
    }
    
    return E_FAIL;
}

HRESULT DeltaRowCompress(CBuffer &dst, const CBuffer &src, const CBuffer &seed)
{

    if (dst.IsValid() && src.IsValid() && seed.IsValid() && seed.Size() != -1)
    {
        dst.Size() = iCompDeltaRow(dst.Data(), src.Data(), seed.Data(), src.Size(), dst.Capacity());
        return S_OK;
    }
    
    return E_FAIL;
}

HRESULT OutputRowBuffer(PRASTER_ITERATOR pIt, PDEVOBJ pDevObj, const CBuffer &row)
{
    BYTE *pData = (BYTE *)row.Data();
    
    if (row.IsValid())
    {
        RI_OutputRow(pIt, pDevObj, pData, row.Size());
        return S_OK;
    }
    
    return E_FAIL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\realize.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.

Module Name:

    realize.h

Abstract:

Environment:

    Windows NT Unidrv driver

Revision History:

	09/10/97 Denise Zimmerman        
		Created it.

--*/

#ifndef REALIZE_H
#define REALIZE_H

#include "comnfile.h"
#include "gloemkm.h"
#include "glpdev.h"
#include "vector.h"

#define PCL_RGB_ENTRIES  770 // 3 * 256 = 768 -- a little wary in NT km.
#define DW_ALIGN(x)             (((DWORD)(x) + 3) & ~(DWORD)3)


/* colorSpaceEnumeration **************************************************/
#define HP_eBiLevel                0  
#define HP_eGray                   1   
#define HP_eRGB                    2  
#define HP_eCMY                    3 


/* colorMappingEumeration *************************************************/
#define HP_eDirectPixel            0 
#define HP_eIndexedPixel           1 
#define PCL_BRUSH_PATTERN	   2
#define PCL_SOLID_PATTERN	   3
#define PCL_HATCH_PATTERN	   4

/* compressionEnumeration *************************************************/
#define HP_eNoCompression          0 
#define HP_eRLECompression         1

/* patternPersistenceEnumeration *****************************************/
#define HP_eTempPattern            0
#define HP_ePagePattern            1
#define HP_eSessionPattern         2

/* for color manipulation    */
#define RED_VALUE(c)   ((BYTE) c & 0xff)
#define GREEN_VALUE(c) ((BYTE) (c >> 8) & 0xff)
#define BLUE_VALUE(c)  ((BYTE) (c >> 16) & 0xff)

VOID XlateColor(
        LPBYTE      pbSrc,
        LPBYTE      pbDst,
        XLATEOBJ    *pxlo,
        DWORD       SCFlags,
        DWORD       Srcbpp,
        DWORD       DestBpp,
        DWORD       cPels
        )
    ;

BOOL
BGetBitmapInfo(
    SIZEL       *sizlSrc,
    ULONG        iBitmapFormat,      //bpp
    PCLPATTERN  *pclPattern,
    PULONG       pulsrcBpp,          //IN source bpp
    PULONG       puldestBpp         //IN destination bpp
//    PULONG       pulDelta            //IN
);

#define SC_LSHIFT       0x01
#define SC_XLATE        0x02
#define SC_SWAP_RB      0x04
#define SC_IDENTITY     0x08

// Vector data types.

typedef struct _LINEDASH { // LINEDASH

  PUINT array;
  UINT arrayLen;        // arrayLen of 0 means a solid line.

} LINEDASH, *PLINEDASH;

// Cached brush information

// Used for selecting pen and brush

#define SPB_PEN         0
#define SPB_BRUSH       1

#define NOT_SOLID_COLOR 0xffffffff

// COPYPEN mix mode - use R2_COPYPEN for both foreground and background

#define MIX_COPYPEN     (R2_COPYPEN | (R2_COPYPEN << 8))

// Convert RGB value to grayscale value using NTSC conversion:
//  Y = 0.289689R + 0.605634G + 0.104676B


#define RgbToGray(r,g,b) \
 (BYTE)(((WORD)((r)*30) + (WORD)((g)*59) + (WORD)((b)*11))/100)  // from Win95 driver intensity marco

//        (BYTE) (((r)*74L + (g)*155L + (b)*27L) >> 8  // PS driver marco
//        (BYTE) (((BYTE) (r) * 74L + (BYTE) (g) * 155L + (BYTE) (b) * 27L) >> 8)

// RGB values for solid black and white colors

VOID
SetCommonPattAttr(
                  PPCLPATTERN pPattern,
                  USHORT fjBitmap,
                  BYTE compressionEnum,
                  SIZEL size,
                  BYTE colorMappingEnum,
                  LONG  lDelta,
                  ULONG cBytes
                  )
;

DWORD CheckXlateObj(XLATEOBJ *pxlo,
            DWORD Srcbpp
            )
    ;

BOOL
    bXLATE_TO_HP_Palette(
                 PULONG pSrcPal,
                 ULONG ulSrcLen,
                 PBYTE pDestPal,
                 ULONG ulDestLen,
                 ULONG EntrySizeDest
                 )
    ;

BOOL BCreateNewBrush (
    IN  BRUSHOBJ   *pbo,
    IN  SURFOBJ    *psoTarget,
    IN  SURFOBJ    *psoPattern,
    IN  XLATEOBJ   *pxlo,
    IN  LONG        iHatch,
    IN  DWORD       dwForeColor,
    IN  DWORD       dwPatternID);

BOOL BWhichLangToDwnldBrush(
        IN  PDEVOBJ          pdevobj,
        IN  PRASTER_DATA     pSrcImage,
        OUT ERenderLanguage *eRendLang);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUD.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\udprocs.h ===
///////////////////////////////////////////////////////////////////////////////
// 
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
// 
//   udprocs.h
// 
// Abstract:
// 
//   [Abstract]
//
// Environment:
// 
//   Windows NT Unidrv driver add-on command-callback module
//
// Revision History:
// 
//   09/15/98 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#ifndef UDPROCS_H
#define UDPROCS_H

#ifdef COMMENTEDOUT
#define MV_OEM_FORCE_UPDATE 0x1000
#endif

BOOL BOEMGetStandardVariable(PDEVOBJ pDevObj,
                          DWORD   dwIndex,
                          PVOID   pBuffer,
                          DWORD   cbSize,
                          PDWORD  pcbNeeded);

DWORD OEMWriteSpoolBuf(PDEVOBJ pDevObj,
                       PVOID   pBuffer,
                       DWORD   cbSize);

BOOL OEMGetDriverSetting(PDEVOBJ pDevObj,
                         PVOID   pdriverobj,
                         PCSTR   Feature,
                         PVOID   pOutput,
                         DWORD   cbSize,
                         PDWORD  pcbNeeded,
                         PDWORD  pdwOptionsReturned);

BOOL OEMUnidriverTextOut(SURFOBJ    *pso,
                         STROBJ     *pstro,
                         FONTOBJ    *pfo,
                         CLIPOBJ    *pco,
                         RECTL      *prclExtra,
                         RECTL      *prclOpaque,
                         BRUSHOBJ   *pboFore,
                         BRUSHOBJ   *pboOpaque,
                         POINTL     *pptlBrushOrg,
                         MIX         mix);

INT OEMXMoveTo(PDEVOBJ pDevObj, INT x, DWORD dwFlags);

INT OEMYMoveTo(PDEVOBJ pDevObj, INT y, DWORD dwFlags);

#endif // UTILITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\utility.h ===
///////////////////////////////////////////////////////////////////////////////
// 
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
//
// Module Name:
// 
//   utility.h
// 
// Abstract:
// 
//   [Abstract]
//
//   
// Environment:
// 
//   Windows 2000/Whistler Unidrv driver 
//
// Revision History:
// 
///////////////////////////////////////////////////////////////////////////////


#ifndef UTILITY_H
#define UTILITY_H


#define STRING_LEN 80

typedef struct STRING_tag
{
    char data[STRING_LEN];
    int len;
} STRING, *PSTRING;


void STRING_Init(PSTRING pStr);
void STRING_FromFLOATOBJ(PSTRING pStr, PFLOATOBJ pFloat);
void STRING_FromFloat(PSTRING pStr, float f);


///////////////////////////////////////////////////////////////////////////////
// Pre- and Postcondition show assumptions for a given method.
#define PRECONDITION(cond) ASSERTMSG(cond, ("Precondition '" #cond "' failed."))

#define POSTCONDITION(cond) ASSERTMSG(cond, ("Postcondition '" #cond "' failed."))

///////////////////////////////////////////////////////////////////////////////
// Defining the FILETRACE macro will turn on tracing for a module.
// #ifdef FILETRACE
#ifdef COMMENTEDOUT

#define ENTERING(func) DbgPrint(DLLTEXT("\\\\ Entering " #func ".\n"))
#define EXITING(func)  DbgPrint(DLLTEXT("// Exiting " #func ".\n"))

#else

#define ENTERING(func) { }
#define EXITING(func)  { }

#endif

///////////////////////////////////////////////////////////////////////////////
// Short-range error-handling scheme
#define TRY             { BOOL __bError = FALSE; BOOL __bHandled = FALSE;
#define TOSS(label)     { __bError = TRUE; WARNING(("Tossing " #label "\n")); goto label; }
#define CATCH(label)    label: if (__bError && !__bHandled) { WARNING(("Catching " #label "\n")); } \
                               if (__bError && !__bHandled && (__bHandled = TRUE))
#define OTHERWISE       if (!__bError && !__bHandled && (__bHandled = TRUE))
#define ENDTRY          }


//
// Macros for manipulating ROP4s and ROP3s
//

#define GET_FOREGROUND_ROP3(rop4) ((rop4) & 0xFF)
#define GET_BACKGROUND_ROP3(rop4) (((rop4) >> 8) & 0xFF)
#define ROP3_NEED_PATTERN(rop3)   (((rop3 >> 4) & 0x0F) != (rop3 & 0x0F))
#define ROP3_NEED_SOURCE(rop3)    (((rop3 >> 2) & 0x33) != (rop3 & 0x33))
#define ROP3_NEED_DEST(rop3)      (((rop3 >> 1) & 0x55) != (rop3 & 0x55))


int iDwtoA( LPSTR buf, DWORD n );

int iLtoA( LPSTR buf, LONG l );

void FLOATOBJ_Assign(PFLOATOBJ pDst, PFLOATOBJ pSrc);

void RECTL_CopyRect(LPRECTL pDst, const LPRECTL pSrc);

void RECTL_FXTOLROUND (PRECTL prcl);

BOOL RECTL_EqualRect(const LPRECTL pRect1, const LPRECTL pRect2);

BOOL RECTL_IsEmpty(const LPRECTL pRect);

VOID RECTL_SetRect(LPRECTL pRect, int left, int top, int right, int bottom);

LONG RECTL_Width(const LPRECTL pRect);

LONG RECTL_Height(const LPRECTL pRect);

VOID POINT_MakePoint (POINT *pt, LONG x, LONG y);

VOID OEMResetXPos(PDEVOBJ pDevObj);

VOID OEMResetYPos(PDEVOBJ pDevObj);

#endif // UTILITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\utility.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved. 
//
// Module Name:
// 
//   utility.cpp
// 
// Abstract:
// 
//   [Abstract]
//
// 
// Environment:
// 
//   Windows 2000/Whistler
//
// Revision History:
// 
///////////////////////////////////////////////////////////////////////////////

#include "hpgl2col.h" //Precompiled header file


///////////////////////////////////////////////////////////////////////////////
// iDwtoA()
//
// Routine Description:
// 
//   Converts a DWORD to a string.  This was borrowed from the MS sample code.
//   No promises. JFF
// 
// Arguments:
// 
//   buf - destination buffer
//   n - number to be converted
// 
// Return Value:
// 
//   The number of characters in the destination string.
///////////////////////////////////////////////////////////////////////////////
int iDwtoA( LPSTR buf, DWORD n )
{
    int     i, j;

    for( i = 0; n; i++ )
    {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    for( j = 0; j < i / 2; j++ )
    {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}

///////////////////////////////////////////////////////////////////////////////
// iLtoA()
//
// Routine Description:
// 
//   Converts a LONG to a string.  I know the implementation is kind of hokey,
//   but I needed something quick.
// 
// Arguments:
// 
//   buf - destination buffer
//   l - number to be converted
// 
// Return Value:
// 
//   The number of characters in the destination string.
///////////////////////////////////////////////////////////////////////////////
int iLtoA(LPSTR buf, LONG l)
{
    if (l < 0)
    {
        buf[0] = '-';
        l = -l;
        return iDwtoA(buf+1, l) + 1;
    }
    else
    {
        return iDwtoA(buf, l);
    }
}

///////////////////////////////////////////////////////////////////////////////
// FLOATOBJ_Assign()
//
// Routine Description:
// 
//   Copies a floatobj.  i.e. *pDst = *pSrc;
// 
// Arguments:
// 
//   pDst - destination float
//   pSrc - source float
// 
// Return Value:
// 
//   none
///////////////////////////////////////////////////////////////////////////////
void FLOATOBJ_Assign(PFLOATOBJ pDst, PFLOATOBJ pSrc)
{
    if (pDst == NULL || pSrc == NULL)
        return;

/*
    // FLOATOBJ_MulLong(pDst, 0);
    FLOATOBJ_SetLong(pDst, (LONG)0);
    FLOATOBJ_Add(pDst, pSrc);
*/
    *pDst = *pSrc; // Compiler will copy bits by default.
}

///////////////////////////////////////////////////////////////////////////////
// RECTL_CopyRect()
//
// Routine Description:
// 
//   Copies a rect.  i.e. *pDst = *pSrc;
// 
// Arguments:
// 
//   pDst - destination rect
//   pSrc - source rect
// 
// Return Value:
// 
//   none
///////////////////////////////////////////////////////////////////////////////
void RECTL_CopyRect(LPRECTL pDst, const LPRECTL pSrc)
{
    pDst->top    = pSrc->top;
    pDst->left   = pSrc->left;
    pDst->bottom = pSrc->bottom;
    pDst->right  = pSrc->right;
}

void RECTL_FXTOLROUND (PRECTL rclDraw)
{

}

///////////////////////////////////////////////////////////////////////////////
// RECTL_EqualRect()
//
// Routine Description:
// 
//   Compares to rectangles
// 
// Arguments:
// 
//   pRect1 - first rect
//   pRect2 - second rect
// 
// Return Value:
// 
//   TRUE if the rectangles are identical, otherwise FALSE
///////////////////////////////////////////////////////////////////////////////
BOOL RECTL_EqualRect(const LPRECTL pRect1, const LPRECTL pRect2)
{
    return ((pRect1->top    == pRect2->top    ) &&
            (pRect1->left   == pRect2->left   ) &&
            (pRect1->bottom == pRect2->bottom ) &&
            (pRect1->right  == pRect2->right  ));
}


///////////////////////////////////////////////////////////////////////////////
// RECTL_IsEmpty()
//
// Routine Description:
// 
//   Returns TRUE if the area of the rectangle is zero
// 
// Arguments:
// 
//   pRect - the rect
// 
// Return Value:
// 
//   TRUE if the area inside the rect is zero
///////////////////////////////////////////////////////////////////////////////
BOOL RECTL_IsEmpty(const LPRECTL pRect)
{
    return ((pRect->right - pRect->left) * (pRect->bottom - pRect->top)) == 0;
}


///////////////////////////////////////////////////////////////////////////////
// RECTL_SetRect()
//
// Routine Description:
// 
//   Sets the values of a rect
// 
// Arguments:
// 
//   pRect - the rect to set
//   left, top, right, bottom - the sides of the rect
// 
// Return Value:
// 
//   none
///////////////////////////////////////////////////////////////////////////////
VOID RECTL_SetRect(LPRECTL pRect, int left, int top, int right, int bottom)
{
    pRect->top    = top;
    pRect->left   = left;
    pRect->bottom = bottom;
    pRect->right  = right;
}

///////////////////////////////////////////////////////////////////////////////
// RECTL_Width()
//
// Routine Description:
// 
//   Calculates the width of a bottom-right exclusive rectangle
// 
// Arguments:
// 
//   pRect - the rect 
// 
// Return Value:
// 
//   LONG: The width of the rectangle or 0 if pRect is NULL
///////////////////////////////////////////////////////////////////////////////
LONG RECTL_Width(const LPRECTL pRect)
{
	if (pRect)
	{
		return pRect->right - pRect->left;
	}

	// else
	return 0;
}

///////////////////////////////////////////////////////////////////////////////
// RECTL_Height()
//
// Routine Description:
// 
//   Calculates the height of a bottom-right exclusive rectangle
// 
// Arguments:
// 
//   pRect - the rect 
// 
// Return Value:
// 
//   LONG: The height of the rectangle or 0 if pRect is NULL
///////////////////////////////////////////////////////////////////////////////
LONG RECTL_Height(const LPRECTL pRect)
{
	if (pRect)
	{
		return pRect->bottom - pRect->top;
	}

	// else
	return 0;
}

///////////////////////////////////////////////////////////////////////////////
// POINT_MakePoint()
//
// Routine Description:
// 
//   [descrip]
// 
// Arguments:
// 
//   [args]
// 
// Return Value:
// 
//   none
///////////////////////////////////////////////////////////////////////////////
VOID POINT_MakePoint (POINT *pt, LONG x, LONG y)
{
    if (pt == NULL)
        return;

    pt->x = x;
    pt->y = y;
}

///////////////////////////////////////////////////////////////////////////////
// OEMResetXPos()
//
// Routine Description:
// 
//   Resets the x position to 0.
//
// Arguments:
// 
//   pDevObj - the print device
// 
// Return Value:
// 
//   None.
///////////////////////////////////////////////////////////////////////////////
VOID OEMResetXPos(PDEVOBJ pDevObj)
{
    if (pDevObj == NULL)
        return;

    OEMXMoveTo(pDevObj, 0, MV_GRAPHICS);
}

///////////////////////////////////////////////////////////////////////////////
// OEMResetYPos()
//
// Routine Description:
// 
//   Resets the y position to 0.
//
// Arguments:
// 
//   pDevObj - the printer device object
// 
// Return Value:
// 
//   none
///////////////////////////////////////////////////////////////////////////////
VOID OEMResetYPos(PDEVOBJ pDevObj)
{
    if (pDevObj == NULL)
        return;

    OEMYMoveTo(pDevObj, 0, MV_GRAPHICS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\vector.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999-2001  Microsoft Corporation
// All rights reserved.
// 
// Module Name:
// 
//   vector.h
// 
// Abstract:
// 
//   [Abstract]
// 
// Environment:
// 
//   Windows 2000 Unidrv driver 
//
// Revision History:
// 
//   09/05/97 -v-jford-
//       Created it.
///////////////////////////////////////////////////////////////////////////////

#ifndef VECTOR_H
#define VECTOR_H

#include "hpglctrl.h"
#include "path.h"
#include "clip.h"
#include "penbrush.h"
#include "line.h"
#include "mix.h"
#include "hpgl.h"
#include "utility.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\inc\vectorc.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    vectorc.h

Abstract:

    Vector module main header file.

Environment:

    Windows 2000/Whistler Unidrv driver

Revision History:

    02/29/00 -hsingh-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _VECTORC_H_
#define _VECTORC_H_


#include "lib.h"
#include "unilib.h"
#include "gpd.h"
#include "mini.h"
#include "winres.h"
#include "pdev.h"
#include "palette.h"
#include "common.h"
#include "vectorif.h"
#include "printoem.h"
#include "oemutil.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// Every vector "pseudo-plugin" should have an XXXXInitVectorProcTable function. This
// function will be called by VMInit to initialize the pVectorProcs in PDEV.
// VMInit is called by unidrv's EnablePDEV.
//

PVMPROCS HPGLInitVectorProcTable(
                            PDEV    *pPDev,
                            DEVINFO *pDevInfo,
                            GDIINFO *pGDIInfo );

PVMPROCS PCLXLInitVectorProcTable(
                            PDEV    *pPDev,
                            DEVINFO *pDevInfo,
                            GDIINFO *pGDIInfo );


#ifdef __cplusplus
}
#endif


#endif  // !_VECTORC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\vector.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.
														
Module Name:

    vector.cpp

Abstract:

    Implementation of DDI vector drawing hooks specific to HP-GL/2

Environment:

    Windows 2000 Unidrv driver

Revision History:

    04/07/97 -sandram-
        Created it.

--*/

#include "hpgl2col.h" //Precompiled header file

#ifndef WINNT_40

/////////////////////////////////////////////////////////////////////////////
// HPGLAlphaBlend
//
// Routine Description:
//
//   Handles DrvAlphaBlend.  Actually we don't handle it.  We don't do alpha
//   blending in this driver.  What we do here is punt back to the OS.
//
// Arguments:
//
//   psoDest - points to target surface.
//   psoSrc - points to the source surface
//   pco - clip region
//   pxloSrcDCto32 - specifies how color indices should be translated between
//          the source and target
//   prclDest - RECTL structure that defines area to be modified
//   prclSrc - source rectangle
//   pBlendObj - how blend should happen
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLAlphaBlend(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxloSrcDCto32,
    RECTL          *prclDest,
    RECTL          *prclSrc,
    BLENDOBJ       *pBlendObj
    )
{
    
    TERSE(("HPGLAlphaBlend() entry.\r\n"));

    PDEVOBJ     pdevobj = (PDEVOBJ)psoDest->dhpdev;
    REQUIRE_VALID_DATA(pdevobj, return FALSE);
    POEMPDEV    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE);
    PDEV        *pPDev = (PDEV *)pdevobj;

    //
    // To see the explanation of PF2_WHITEN_SURFACE, PDEVF_RENDER_TRANSPARENT
    // read the HPGLGradientFill.
    // In AlphaBlend too, GDI calls DrvCopyBits with psoSrc=STYPE_BITMAP and
    // psoDst=STYPE_DEVICE. 
    // 
    BOOL bRetVal = FALSE;
    pPDev->fMode2     |= PF2_WHITEN_SURFACE;
    poempdev->dwFlags |= PDEVF_RENDER_TRANSPARENT;

    bRetVal = EngAlphaBlend(
            psoDest,
            psoSrc,
            pco,
            pxloSrcDCto32,
            prclDest,
            prclSrc,
            pBlendObj);

    //
    // EngAlphaBlend can call some Drvxxx which can call into
    // some plugin module, which can overwrite our pdevOEM.
    // So we need to reset pdevOEM
    //
    BRevertToHPGLpdevOEM (pdevobj);

    pPDev->fMode2     &= ~PF2_WHITEN_SURFACE;
    poempdev->dwFlags &= ~PDEVF_RENDER_TRANSPARENT;
    pPDev->fMode2     &= ~PF2_SURFACE_WHITENED;
    return bRetVal;

}


/////////////////////////////////////////////////////////////////////////////
// HPGLGradientFill
//
// Routine Description:
//
//   Handles DrvGradientFill.  Actually we don't handle it.  What we do here 
//   is punt back to the OS.
//
// Arguments:
//
//   psoDest - points to target surface.
//   pco - clip region
//   pxlo - specifies how color indices should be translated between
//          the source and target
//   pVertex - array of vertices
//   nVertex - number of vertices in pVertex
//   pMest - unknown
//   nMesh - unknown
//   prclExtents - unknown
//   pptlDitherOrg - unknown
//   ulMode - unknown
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLGradientFill(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    )
{
    TERSE(("HPGLGradientFill() entry.\r\n"));

    
    PDEVOBJ     pdevobj = (PDEVOBJ)psoDest->dhpdev;
    REQUIRE_VALID_DATA(pdevobj, return FALSE);
    POEMPDEV    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE);
    PDEV        *pPDev = (PDEV *)pdevobj;

    BOOL bRetVal = FALSE;

    //
    // If the GradientFill is a TRIANGLE_FILL and
    // EngGradientFill is called, GDI calls DrvCopyBits with psoSrc=STYPE_BITMAP and
    // psoDst=STYPE_DEVICE because it wants the driver to copy whats on the device to
    // the bitmap surface. The driver does not keep track of whats on the device. So it
    // cannot honestly fill out the surface. So the driver decides to simply whiten the 
    // Bitmap Surface assuming that nothing was drawn on the paper earlier. 
    // Note that by doing so, the whole rectangular area is 
    // whitened, even though the actual image is only in a triangle. If this image is 
    // downloaded, the white part will overwrite whatever is present on the destination.
    // To prevent this, the image should be downloaded with Source Tranpsarency set
    // as TRANSPARENT (Esc*v0n), so that white does not overwrite the destination.
    // Whatever is already underneath the image will still peep through.
    // So now we need to do 2 things
    // 1. Set a flag so that DrvCopyBits will whiten the surface
    // 2. Set a flag so that when we(HPGL Driver)get an image to download, we set the transparency 
    //    mode to TRANSPARENT.
    // NOTE : GDI is planning to change the behavior for Windows XP, but if you want to see 
    // this happening, run this driver on Windows2000 machine.
    //
    if ( ulMode == GRADIENT_FILL_TRIANGLE )
    {
        //
        // For this special case, We'll render the bitmap transparent.
        //
        poempdev->dwFlags |= PDEVF_RENDER_TRANSPARENT;
        pPDev->fMode2     |= PF2_WHITEN_SURFACE;
    }

     bRetVal = EngGradientFill(
            psoDest,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode);

    //
    // EngGradientBlt can call some Drvxxx which can call into
    // some plugin module, which can overwrite our pdevOEM.
    // So we need to reset pdevOEM
    //
    BRevertToHPGLpdevOEM (pdevobj);

    //
    // When DrvCopyBits whitens the surface it sets the PF2_RENDER_TRANSPARENT flag in
    // pPDev->fMode2. So we have to reset that flag too. 
    //
    poempdev->dwFlags &= ~PDEVF_RENDER_TRANSPARENT;
    pPDev->fMode2     &= ~PF2_WHITEN_SURFACE;
    pPDev->fMode2     &= ~PF2_SURFACE_WHITENED;
    return bRetVal;

}

#endif //ifndef WINNT_40

/////////////////////////////////////////////////////////////////////////////
// OEMFillPath
//
// Routine Description:
//
//   Handles DrvFillPath.
//
// Arguments:
//
//   pso - points to target surface.
//   ppo - path to fill
//   pco - clip region
//   pbo - brush to fill with
//   pptBrushOrg - pattern brush offset
//   mix - contains ROP codes
//   flOptions - fill options such as winding or alternate
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;
    BOOL        bRetVal = TRUE;
    HPGLMARKER  Brush;

    TERSE(("HPGLFillPath() entry.\r\n"));

    //
    // Validate input parameters
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( (pso && poempdev), return FALSE );
							   
    ZeroMemory(&Brush, sizeof (HPGLMARKER));

    TRY
    {

        //
        // If the clipping region is complex, we cannot handle
        // it. The output file size gets too big. So ask GDI to do it.
        //

        if ( pco && (pco->iDComplexity == DC_COMPLEX) )
        {
            bRetVal = FALSE;
            goto finish;
        }

        BChangeAndTrackObjectType (pdevobj, eHPGLOBJECT);

        // Set up current graphics state
        //  clipping path
        //  foreground/background mix mode
        //  Pen
        //  line attributes
        //
        // Send the path object to the printer and stroke it
        //
        if (! SelectMix(pdevobj, mix) ||
            ! SelectClipEx(pdevobj, pco, flOptions) ||
            ! CreateHPGLPenBrush(pdevobj, &Brush, pptlBrushOrg, pbo, flOptions, kBrush, FALSE) ||
            ! MarkPath(pdevobj, ppo, NULL, &Brush) ||
            ! HPGL_SelectTransparency(pdevobj, eOPAQUE, 0) )
        {
            WARNING(("Cannot fill path\n"));
            TOSS(DDIError);
        }


        bRetVal = TRUE;
    }
    CATCH(DDIError)
    {
        bRetVal = FALSE;
    }
    ENDTRY;

  finish:

    return bRetVal;
}

/////////////////////////////////////////////////////////////////////////////
// HPGLStrokePath
//
// Routine Description:
//
//   Handles DrvStrokePath.
//
// Arguments:
//
//   pso - points to target surface.
//   ppo - path to edge
//   pco - clip region
//   pxo - transform obj
//   pbo - brush to edge with
//   pptBrushOrg - pattern brush offset
//   plineattrs - line attributes such as dot/dash, width and caps & joins
//   mix - contains ROP codes
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;
    BOOL        bRetVal;
    HPGLMARKER  Pen;

    TERSE(("HPGLStrokePath() entry.\r\n"));

    //
    // Validate input parameters
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( (poempdev && pso), return FALSE );

    ZeroMemory(&Pen, sizeof (HPGLMARKER));

    TRY
    {

        BChangeAndTrackObjectType (pdevobj, eHPGLOBJECT);
        
        // Set up current graphics state
        //  clipping path
        //  foreground/background mix mode
        //  Pen
        //  line attributes
        //
        // Send the path object to the printer and stroke it
        //
        if (! SelectMix(pdevobj, mix) ||
            ! SelectClip(pdevobj, pco) ||
            ! CreateHPGLPenBrush(pdevobj, &Pen, pptlBrushOrg, pbo, 0, kPen, FALSE) ||
            ! SelectLineAttrs(pdevobj, plineattrs, pxo) ||
            ! MarkPath(pdevobj, ppo, &Pen, NULL) ||
            ! HPGL_SelectTransparency(pdevobj, eOPAQUE, 0) )
        {
            WARNING(("Cannot stroke path\n"));
            TOSS(DDIError);
        }

        bRetVal = TRUE;
    }
    CATCH(DDIError)
    {
        bRetVal = FALSE;
    }
    ENDTRY;

    return bRetVal;
}

/////////////////////////////////////////////////////////////////////////////
// HPGLStrokeAndFillPath
//
// Routine Description:
//
//   Handles DrvStrokeAndFillPath
//
// Arguments:
//
//   pso - points to target surface.
//   ppo - path to stroke & fill
//   pco - clip region
//   pxo - transform obj
//   pboStroke - brush to edge with
//   plineattrs - line attributes such as dot/dash, width and caps & joins
//   pboFill - brush to fill with
//   pptBrushOrg - pattern brush offset
//   mix - contains ROP codes
//   flOptions - fill mode
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;
    BOOL        bRetVal;
    HPGLMARKER  Pen;
    HPGLMARKER  Brush;

    TERSE(("HPGLStrokeAndFillPath() entry.\r\n"));

    // 
    // Validate input parameters
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj) && (poempdev = (POEMPDEV)pdevobj->pdevOEM));
    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( (poempdev && pso), return FALSE );


    ZeroMemory(&Pen,   sizeof (HPGLMARKER));
    ZeroMemory(&Brush, sizeof (HPGLMARKER));

    TRY
    {

        BChangeAndTrackObjectType (pdevobj, eHPGLOBJECT);

        // Set up current graphics state
        //  clipping path
        //  foreground/background mix mode
        //  Pen
        //  line attributes
        //
        // Send the path object to the printer and stroke it
        //
        if (! SelectMix(pdevobj, mixFill) ||
            ! SelectClipEx(pdevobj, pco, flOptions) ||
            ! CreateHPGLPenBrush(pdevobj, &Pen, pptlBrushOrg, pboStroke, 0, kPen, TRUE) ||
            ! CreateHPGLPenBrush(pdevobj, &Brush, pptlBrushOrg, pboFill, flOptions, kBrush, FALSE) ||
            ! SelectLineAttrs(pdevobj, plineattrs, pxo) ||
            ! MarkPath(pdevobj, ppo, &Pen, &Brush) ||
            ! HPGL_SelectTransparency(pdevobj, eOPAQUE, 0) )
        {
            WARNING(("Cannot stroke & fill path\n"));
            TOSS(DDIError);
        }

        bRetVal = TRUE;
    }
    CATCH(DDIError)
    {
        bRetVal = FALSE;
    }
    ENDTRY;

    // 
    // Look above. There are 2 calls to CreateHPGLPenBrush, one for pboStroke
    // and other from pboFill. Both the calls can cause an entry in brush cache.
    // We do not want pboFill to overwrite pboStroke entry in the brush cache
    // so we marked pboStroke's entry as non-overwriteable or sticky.
    //  (The parameter TRUE in CreateHPGLPenBrush).
    // Now that we are done with this function, we can safely 
    // make it overwriteable i.e. set sticky attribute to FALSE
    //
    if (Pen.lPatternID) 
    {
        poempdev->pBrushCache->BSetStickyFlag(Pen.lPatternID, FALSE);
    }

    return bRetVal;
}

/////////////////////////////////////////////////////////////////////////////
// OEMStrokeAndFillPath
//
// Routine Description:
//
//   Handles DrvStrokeAndFillPath
//
// Arguments:
//
//   pso - points to target surface.
//   ppo - path to stroke & fill
//   pco - clip region
//   pxo - transform obj
//   pboStroke - brush to edge with
//   plineattrs - line attributes such as dot/dash, width and caps & joins
//   pboFill - brush to fill with
//   pptBrushOrg - pattern brush offset
//   mix - contains ROP codes
//   flOptions - fill mode
//
// Return Value:
//
//   TRUE if successful, FALSE if there is an error
/////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY
HPGLPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    )
{
    TERSE(("HPGLPaint() entry.\r\n"));
    
    PDEVOBJ     pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    POEMPDEV    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE);


    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvPaint)(poempdev->pfnUnidrv[UD_DrvPaint])) (
            pso,
            pco,
            pbo,
            pptlBrushOrg,
            mix));

    
}

BOOL APIENTRY
HPGLLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    )
{
    
    TERSE(("HPGLLineTo() entry.\r\n"));

    
    PDEVOBJ     pdevobj = (PDEVOBJ)pso->dhpdev;
    ASSERT(VALID_PDEVOBJ(pdevobj));
    POEMPDEV    poempdev = (POEMPDEV)pdevobj->pdevOEM;
    REQUIRE_VALID_DATA( poempdev, return FALSE);

    //
    // turn around to call Unidrv
    //
    
    return (((PFN_DrvLineTo)(poempdev->pfnUnidrv[UD_DrvLineTo])) (
            pso,
            pco,
            pbo,
            x1,
            y1,
            x2,
            y2,
            prclBounds,
            mix));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\hpgl2col\render\udprocs.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation
All rights reserved.

Module Name:
    udprocs.cpp

Abstract:
    Intermediate functions between the HPGL driver and unidrv.
    HPGL calls these functions who eventually call core unidrv.

Author:

Revision History:


--*/

#include "hpgl2col.h" //Precompiled header file

#include <prcomoem.h>

///////////////////////////////////////////////////////////
//
// Local Function Declarations.
//


INT OEMXMoveToImpl(PDEVOBJ pDevObj, INT x, DWORD dwFlags);

INT OEMYMoveToImpl(PDEVOBJ pDevObj, INT y, DWORD dwFlags);

///////////////////////////////////////////////////////////
//
// Export functions
//

///////////////////////////////////////////////////////////////////////////////
// BOEMGetStandardVariable()
//
// Routine Description:
// 
//   Callthrough to unidrv::BGetStandardVariable
//
// Arguments:
// 
// 
// Return Value:
// 
///////////////////////////////////////////////////////////////////////////////
BOOL BOEMGetStandardVariable(PDEVOBJ pDevObj,
                          DWORD   dwIndex,
                          PVOID   pBuffer,
                          DWORD   cbSize,
                          PDWORD  pcbNeeded)
{
    POEMPDEV poempdev = (POEMPDEV)pDevObj->pdevOEM;

    if (poempdev->pOEMHelp)
    {
        HRESULT hr = poempdev->pOEMHelp->DrvGetStandardVariable(
            pDevObj,
            dwIndex,
            pBuffer,
            cbSize,
            pcbNeeded);

        return SUCCEEDED(hr);
    }
    else
    {
        return pDevObj->pDrvProcs->BGetStandardVariable(
            pDevObj,
            dwIndex,
            pBuffer,
            cbSize,
            pcbNeeded);
    }
}

///////////////////////////////////////////////////////////////////////////////
// OEMWriteSpoolBuf()
//
// Routine Description:
// 
//   Callthrough to unidrv::BGetStandardVariable
//
// Arguments:
// 
// 
// Return Value:
// 
///////////////////////////////////////////////////////////////////////////////
#ifndef COMMENTEDOUT
DWORD OEMWriteSpoolBuf(PDEVOBJ pDevObj,
                       PVOID   pBuffer,
                       DWORD   cbSize)
{
    POEMPDEV poempdev = (POEMPDEV)pDevObj->pdevOEM;

    if (poempdev->pOEMHelp)
    {
        DWORD dwRes = 0;
        HRESULT hr = poempdev->pOEMHelp->DrvWriteSpoolBuf(
            pDevObj, 
            pBuffer, 
            cbSize,
            &dwRes);

        return (SUCCEEDED(hr) ? dwRes : 0);
    }
    else
    {
        return pDevObj->pDrvProcs->DrvWriteSpoolBuf(
            pDevObj,
            pBuffer,
            cbSize);
    }
}
#else
class COutputPort
{
    PDEVOBJ m_pDevObj;

public:
    COutputPort(PDEVOBJ pDevObj) : m_pDevObj(pDevObj) { }
    virtual ~COutputPort() { }

    virtual DWORD Output(BYTE *pbBuf, DWORD iCount);
};

class CBufferedOutputPort : public COutputPort
{
public:
    CBufferedOutputPort(PDEVOBJ pDevObj) : COutputPort(pDevObj) { }
    virtual ~CBufferedOutputPort() { }

    virtual DWORD Output(BYTE *pbBuf, DWORD iCount);
};

DWORD COutputPort::Output(BYTE *pBuffer, DWORD cbSize)
{
    POEMPDEV poempdev = (POEMPDEV)m_pDevObj->pdevOEM;

    if (poempdev->pOEMHelp)
    {
        DWORD dwRes = 0;
        HRESULT hr = poempdev->pOEMHelp->DrvWriteSpoolBuf(
            m_pDevObj, 
            pBuffer, 
            cbSize,
            &dwRes);

        return (SUCCEEDED(hr) ? dwRes : 0);
    }
    else
    {
        return m_pDevObj->pDrvProcs->DrvWriteSpoolBuf(
            m_pDevObj,
            pBuffer,
            cbSize);
    }
}

DWORD CBufferedOutputPort::Output(BYTE *pbBuf, DWORD iCount)
{
    const DWORD kMaxSpoolBytes = 2048;
    DWORD iTotalBytesWritten = 0;

    while (iCount)
    {
        DWORD iBytesToWrite = min(iCount, kMaxSpoolBytes);
        DWORD iBytesWritten = COutputPort::Output(pbBuf, iBytesToWrite);
        if (iBytesToWrite != iBytesWritten)
            break;

        iTotalBytesWritten += iBytesWritten;
        pbBuf += iBytesWritten;
        iCount -= iBytesWritten;
    }
    return iTotalBytesWritten;
}

DWORD OEMWriteSpoolBuf(PDEVOBJ pDevObj,
                       PVOID   pBuffer,
                       DWORD   cbSize)
{
    // COutputPort port(pDevObj);
    CBufferedOutputPort port(pDevObj);

    return port.Output((BYTE*)pBuffer, cbSize);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// OEMGetDriverSetting()
//
// Routine Description:
// 
//   Callthrough to unidrv::BGetStandardVariable
//
// Arguments:
// 
// 
// Return Value:
// 
///////////////////////////////////////////////////////////////////////////////
BOOL OEMGetDriverSetting(PDEVOBJ pDevObj,
                         PVOID   pdriverobj,
                         PCSTR   Feature,
                         PVOID   pOutput,
                         DWORD   cbSize,
                         PDWORD  pcbNeeded,
                         PDWORD  pdwOptionsReturned)
{
    POEMPDEV poempdev = (POEMPDEV)pDevObj->pdevOEM;

    if (poempdev->pOEMHelp)
    {
        HRESULT hr = poempdev->pOEMHelp->DrvGetDriverSetting(
            pdriverobj,
            Feature,
            pOutput,
            cbSize,
            pcbNeeded,
            pdwOptionsReturned);

        return SUCCEEDED(hr);
    }
    else
    {
        return pDevObj->pDrvProcs->DrvGetDriverSetting(
            pdriverobj,
            Feature,
            pOutput,
            cbSize,
            pcbNeeded,
            pdwOptionsReturned);
    }
}

///////////////////////////////////////////////////////////////////////////////
// OEMUnidriverTextOut()
//
// Routine Description:
// 
//   Callthrough to unidrv::BGetStandardVariable
//
// Arguments:
// 
// 
// Return Value:
// 
///////////////////////////////////////////////////////////////////////////////
BOOL OEMUnidriverTextOut(SURFOBJ    *pso,
                         STROBJ     *pstro,
                         FONTOBJ    *pfo,
                         CLIPOBJ    *pco,
                         RECTL      *prclExtra,
                         RECTL      *prclOpaque,
                         BRUSHOBJ   *pboFore,
                         BRUSHOBJ   *pboOpaque,
                         POINTL     *pptlBrushOrg,
                         MIX         mix)
{
    PDEVOBJ pDevObj = (PDEVOBJ)pso->dhpdev;
    POEMPDEV poempdev = (POEMPDEV)pDevObj->pdevOEM;

    EndHPGLSession(pDevObj);

    if (poempdev->pOEMHelp)
    {
        HRESULT hr = poempdev->pOEMHelp->DrvUniTextOut(
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlBrushOrg,
            mix);

        return SUCCEEDED(hr);
    }
    else
    {
        return pDevObj->pDrvProcs->DrvUnidriverTextOut(
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlBrushOrg,
            mix);
    }
}

///////////////////////////////////////////////////////////////////////////////
// OEMXMoveTo()
//
// Routine Description:
// 
//   Our very own version of XMoveTo
//
// Arguments:
// 
//   pDevObj - the print device
//   x - new cap x position
//   dwFlags - moveto flags (see unidriver DrvXMoveTo)
// 
// Return Value:
// 
//   A residual value caused by the difference between the driver pixel 
//   addressing and the device pixel addressing schemes.
///////////////////////////////////////////////////////////////////////////////
INT OEMXMoveTo(PDEVOBJ pDevObj, INT x, DWORD dwFlags)
{
    EndHPGLSession(pDevObj);

    return OEMXMoveToImpl(pDevObj, x, dwFlags);
}

///////////////////////////////////////////////////////////////////////////////
// OEMYMoveTo()
//
// Routine Description:
// 
//   Our very own version of YMoveTo
//
// Arguments:
// 
//   pDevObj - the print device
//   y - new cap Y position
//   dwFlags - moveto flags (see unidriver DrvYMoveTo)
// 
// Return Value:
// 
//   A residual value caused by the difference between the driver pixel 
//   addressing and the device pixel addressing schemes.
///////////////////////////////////////////////////////////////////////////////
INT OEMYMoveTo(PDEVOBJ pDevObj, INT y, DWORD dwFlags)
{
    EndHPGLSession(pDevObj);

    return OEMYMoveToImpl(pDevObj, y, dwFlags);
}

///////////////////////////////////////////////////////////////////////////////
// OEMXMoveToImpl()
//
// Routine Description:
// 
//   Finally calls through to the implementation of XMoveTo.  Sorry for the
//   indirection--we needed to to get the OEM_FORCE flag to work.
//
// Arguments:
// 
//   pDevObj - the print device
//   x - new cap x position
//   dwFlags - moveto flags (see unidriver DrvXMoveTo)
// 
// Return Value:
// 
//   A residual value caused by the difference between the driver pixel 
//   addressing and the device pixel addressing schemes.
///////////////////////////////////////////////////////////////////////////////
INT OEMXMoveToImpl(PDEVOBJ pDevObj, INT x, DWORD dwFlags)
{
    POEMPDEV poempdev = (POEMPDEV)pDevObj->pdevOEM;

    if (poempdev->pOEMHelp)
    {
        INT iRes = 0;

        HRESULT hr = poempdev->pOEMHelp->DrvXMoveTo(pDevObj, x, dwFlags, &iRes);

        if (SUCCEEDED(hr))
            return iRes;
        else
            return 0;
    }
    else
    {
        return pDevObj->pDrvProcs->DrvXMoveTo(pDevObj, x, dwFlags);
    }
}

///////////////////////////////////////////////////////////////////////////////
// OEMYMoveToImpl()
//
// Routine Description:
// 
//   Finally calls through to the implementation of XMoveTo.  Sorry for the
//   indirection--we needed to to get the OEM_FORCE flag to work.
//
// Arguments:
// 
//   pDevObj - the print device
//   y - new cap Y position
//   dwFlags - moveto flags (see unidriver DrvYMoveTo)
// 
// Return Value:
// 
//   A residual value caused by the difference between the driver pixel 
//   addressing and the device pixel addressing schemes.
///////////////////////////////////////////////////////////////////////////////
INT OEMYMoveToImpl(PDEVOBJ pDevObj, INT y, DWORD dwFlags)
{
    POEMPDEV poempdev = (POEMPDEV)pDevObj->pdevOEM;

    if (poempdev->pOEMHelp)
    {
        INT iRes = 0;

        HRESULT hr = poempdev->pOEMHelp->DrvYMoveTo(pDevObj, y, dwFlags, &iRes);

        if (SUCCEEDED(hr))
            return iRes;
        else
            return 0;
    }
    else
    {
        return pDevObj->pDrvProcs->DrvYMoveTo(pDevObj, y, dwFlags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\bmpcvt.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bmpcvt.cpp

Abstract:

    Bitmap conversion object

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "pclxle.h"
#include "xlbmpcvt.h"

BPP
NumToBPP(
    ULONG ulBPP)
/*++

Routine Description:

    Converts Bits per pixel to BPP enum.

Arguments:

    Bits per pixel.

Return Value:

    BPP enum

Note:

    BPP enum is defined in xlbmpcvt.h.

--*/
{
    BPP Bpp;

    switch (ulBPP)
    {
    case 1:
        Bpp = e1bpp;
        break;
    case 4:
        Bpp = e4bpp;
        break;
    case 8:
        Bpp = e8bpp;
        break;
    case 16:
        Bpp = e16bpp;
        break;
    case 24:
        Bpp = e24bpp;
        break;
    case 32:
        Bpp = e32bpp;
        break;
    }

    return Bpp;
}

ULONG
UlBPPtoNum(
    BPP Bpp)
/*++

Routine Description:

    Converts BPP enum to bits per pixel.

Arguments:

    BPP enum

Return Value:

    Bits per pixel.

Note:

    BPP enum is defined in xlbmpcvt.h.

--*/
{
    ULONG ulRet;

    switch (Bpp)
    {
    case e1bpp:
        ulRet = 1;
        break;
    case e4bpp:
        ulRet = 4;
        break;
    case e8bpp:
        ulRet = 8;
        break;
    case e16bpp:
        ulRet = 16;
        break;
    case e24bpp:
        ulRet = 24;
        break;
    case e32bpp:
        ulRet = 32;
        break;
    }

    return ulRet;
}


//
// Constructor/Destructor
//

BMPConv::
BMPConv( VOID ):
/*++

Routine Description:

   BMPConv constructor

Arguments:

Return Value:

Note:

    Initializes values. There is no memory allocation.

--*/
    m_flags(0),
    m_dwOutputBuffSize(0),
    m_dwRLEOutputBuffSize(0),
    m_dwDRCOutputBuffSize(0),
    m_OddPixelStart(eOddPixelZero),
    m_FirstBit(eBitZero),
    m_pxlo(NULL),
    m_pubOutputBuff(NULL),
    m_pubRLEOutputBuff(NULL),
    m_pubDRCOutputBuff(NULL),
    m_pubDRCPrevOutputBuff(NULL),
    m_CMode(eNoCompression)
{
#if DBG
    SetDbgLevel(DBG_WARNING);
#endif

    XL_VERBOSE(("BMPConv: Ctor\n"));
}

BMPConv::
~BMPConv( VOID )
/*++

Routine Description:

    BMPConv destructor

Arguments:

Return Value:

Note:

    m_pubOutputBuff and m_pubRLEOutputBuff are allocaed ConvertBMP.
    ConvertBMP is scaline base bitmap conversion function.

--*/
{
    XL_VERBOSE(("BMPConv: Dtor\n"));

    //
    // DRCPrevOutputBuff and OutputBuff are contiguous.
    if (m_pubOutputBuff)
        MemFree(m_pubOutputBuff);

    if  (m_pubRLEOutputBuff)
        MemFree(m_pubRLEOutputBuff);

    if  (m_pubDRCOutputBuff)
        MemFree(m_pubDRCOutputBuff);
}

//
// Public functions
//

#if DBG
VOID
BMPConv::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

BOOL
BMPConv::
BSetInputBPP(
    BPP InputBPP)
/*++

Routine Description:

    Sets source bitmap BPP in BMPConv.

Arguments:

    Source bitmap BPP enum (bits per pixel)

Return Value:

    TRUE if succeeded.

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetInputBPP\n"));

    m_flags |= BMPCONV_SET_INPUTBPP;
    m_InputBPP = InputBPP;
    return TRUE;
}

BOOL
BMPConv::
BSetOutputBPP(
    BPP OutputBPP)
/*++

Routine Description:

    Sets destination bimtap BPP in BMPConv.

Arguments:

    Destination bitmap BPP enum

Return Value:

    TRUE if succeeded.

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetOutputBPP\n"));

    m_OutputBPP = OutputBPP;
    return TRUE;
}

BOOL
BMPConv::
BSetOutputBMPFormat(
    OutputFormat BitmapFormat)
/*++

Routine Description:

    Sets output bitmap format (GrayScale/Palette/RGB/CMYK).

Arguments:

    OutputFormat enum.

Return Value:

    TRUE if succeeded.

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetOutputBMPFormat\n"));

    m_OutputFormat = BitmapFormat;
    return TRUE;
}

BOOL
BMPConv::
BSetCompressionType(
    CompressMode CMode)
/*++

Routine Description:

    Set compression type.

Arguments:

    CompressMode {eNoCompression, eRLECompression, eDeltaRowCompression}

Return Value:

    TRUE if it succeeded.

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetCompressionType.\n"));

    m_CMode = CMode;

    return TRUE;
}

CompressMode
BMPConv::
GetCompressionType(VOID)
/*++

Routine Description:

    CompressMode

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BGetRLEStatus\n"));

    return m_CMode;
}

BOOL
BMPConv::
BSetXLATEOBJ(
    XLATEOBJ *pxlo)
/*++

Routine Description:

    Sets XLATEOBJ in BMPConv.

Arguments:

    A pointer to XLATEOBJ.

Return Value:

Note:

--*/
{
    XL_VERBOSE(("BMPConv: BSetXLATEOBJ\n"));

    //
    // XL_ERRor check
    //
    if (NULL == pxlo)
    {
        XL_ERR(("BMPConv::BSetXLATEOBJ: an invalid parameter.\n"));
        return FALSE;
    }

    m_pxlo = pxlo;

    m_flags |= DwCheckXlateObj(pxlo,  m_InputBPP);
    return TRUE;
}

PBYTE
BMPConv::
PubConvertBMP(
    PBYTE pubSrc,
    DWORD dwcbSrcSize)
/*++

Routine Description:

    Scaline base bitmap conversion function.

Arguments:

    pubSrc - a pointer to the source bitmap.
    dwcbSrcSize - the size of the source bitmap.

Return Value:

    A pointer to the destination bitmap.

Note:

    The pointer to the destination bitmap is stored in BMPConv.
    It is going to be freed in the BMPConv destructor.

--*/
{
    DWORD dwcbDstSize, dwInputBPP;
    LONG lWidth, lHeight;
    PBYTE pubRet = NULL;
    
    XL_VERBOSE(("BMPConv: BConvertBMP\n"));

    //
    // Calculate the number of pixels and the size of dest buffer
    // Output data has to be DWORD aligned on PCL-XL.
    //
    dwInputBPP = UlBPPtoNum(m_InputBPP);
    m_dwWidth = ((dwcbSrcSize << 3 ) + dwInputBPP - 1) / dwInputBPP;
    dwcbDstSize = ((UlBPPtoNum(m_OutputBPP) * m_dwWidth + 31 ) >> 5 ) << 2;

    //
    // Allocate destination buffer
    //
    if (NULL == m_pubOutputBuff || NULL == m_pubDRCPrevOutputBuff)
    {
        //
        // Allocate main and previous output buffer for DRC.
        //
        m_pubOutputBuff = (PBYTE)MemAlloc(dwcbDstSize * 2);
        if (NULL == m_pubOutputBuff)
        {
            XL_ERR(("BMPConv::PubConvertBMP: m_pubOutputBuff[0x%x] allocation failed..\n", dwcbDstSize));
            return NULL;
        }
        m_dwOutputBuffSize = dwcbDstSize;

        //
        // Zero init seed row.
        // PCL XL exception about DRC.
        // 1) the seed row is initialized to zeroes and contains the number
        // of bytes defined by SourceWidth in the BeginImage operator.
        //
        m_pubDRCPrevOutputBuff = m_pubOutputBuff + dwcbDstSize;
        m_dwDRCPrevOutputBuffSize = dwcbDstSize;
        memset(m_pubDRCPrevOutputBuff, 0, m_dwDRCPrevOutputBuffSize);

    }

    //
    // Allocate RLE destination buffer if RLE is on.
    //
    if (m_CMode == eRLECompression && NULL == m_pubRLEOutputBuff)
    {
        m_pubRLEOutputBuff = (PBYTE)MemAlloc(dwcbDstSize * 3);
        m_dwRLEOutputBuffSize = dwcbDstSize * 3;

        if (NULL == m_pubRLEOutputBuff)
        {
            XL_ERR(("BMPConv::PubConvertBMP: m_pubOutputBuff[0x%x] allocation failed..\n", dwcbDstSize));
            MemFree(m_pubOutputBuff);

            m_pubOutputBuff = NULL;
            m_dwOutputBuffSize = 0;

            m_pubDRCPrevOutputBuff = NULL;
            m_dwDRCPrevOutputBuffSize = 0;
            return NULL;
        }

    }

    //
    // Allocate DRC destination buffer if DRC is on.
    //
    if (m_CMode == eDeltaRowCompression && NULL == m_pubDRCOutputBuff)
    {
        m_pubDRCOutputBuff = (PBYTE)MemAlloc(dwcbDstSize * 3);
        m_dwDRCOutputBuffSize = dwcbDstSize * 3;

        if (NULL == m_pubDRCOutputBuff)
        {
            XL_ERR(("BMPConv::PubConvertBMP: m_pubOutputBuff[0x%x] allocation failed..\n", dwcbDstSize));
            MemFree(m_pubOutputBuff);
            m_pubOutputBuff = NULL;
            m_pubDRCPrevOutputBuff = NULL;
            MemFree(m_pubRLEOutputBuff);
            m_pubRLEOutputBuff = NULL;
            return NULL;
        }

    }

    //
    // Converrt source bitmap to destination.
    // Source and Destination format is set by SetXXX functions.
    //
    if (BConversionProc(pubSrc, (dwcbSrcSize * 8 + dwInputBPP - 1) / dwInputBPP))
    {
        if (m_CMode == eRLECompression)
        {
            if (BCompressRLE())
                pubRet = m_pubRLEOutputBuff;
            else
                pubRet = NULL;
        }
        else
        if (m_CMode == eDeltaRowCompression)
        {
            if (BCompressDRC())
                pubRet = m_pubDRCOutputBuff;
            else
                pubRet = NULL;

            //
            // Update seed row for DRC.
            //
            CopyMemory(m_pubDRCPrevOutputBuff, m_pubOutputBuff, m_dwDRCPrevOutputBuffSize);

        }
        else
            pubRet = m_pubOutputBuff;
    }
    else
        pubRet =  NULL;

    return pubRet;
}

BOOL
BMPConv::
BCompressRLE(
    VOID)
/*++

Routine Description:

    RLE compression function

Arguments:

Return Value:

   TRUE if it succeeded.

Note:

--*/
{
    DWORD dwSrcSize, dwDstSize, dwCount, dwErr, dwInputBPP, dwWidth;
    PBYTE pubSrcBuff, pubDstBuff, pubLiteralNum;
    BYTE  ubCurrentData;
    BOOL  bLiteral;

    XL_VERBOSE(("BMPConv: BCompressRLE\n"));

    if ( NULL == m_pubRLEOutputBuff ||
         NULL == m_pubOutputBuff     )
        return FALSE;

    //
    //
    // PCL XL Run Length Encoding Compression Method (eRLECompression)
    // The PCL XL RLE compression method employs control bytes followed by data 
    // bytes. Each
    // control byte in the compressed data sequence is a signed, two's 
    // complement byte.
    // If bit 7 of the control byte is zero (0 <= control byte <= 127) the bytes
    // following are literal.
    // Literal bytes are simply uncompressed data bytes. The number of literal
    // bytes following a control
    // byte is one plus the value of the control byte. Thus, a control byte of 0
    // means 1 literal byte
    // follows; a control byte of 6 means 7 literal bytes follow; and so on.
    // If bit 7 of the control byte is 1 (-127 <= control byte <= -1), the byte 
    // following the control byte
    // will occur two or more times as decompressed data. A byte following a
    // control byte in this range
    // is called a repeat byte. The control byte39s absolute value plus one is
    // the number of times the byte
    // following will occur in the decompressed sequence of bytes. For example, 
    // a control byte of -5
    // means the subsequent byte will occur 6 times as decompressed data.
    // A control byte of -128 is ignored and is not included in the decompressed
    // data. The byte
    // following a control byte of 128 is treated as the next control byte.
    // It is more efficient to code two consecutive identical bytes as a
    // repeated byte, unless these bytes
    // are preceded and followed by literal bytes. Three-byte repeats should
    // always be encoded using a
    // repeat control byte.
    //
    // Literal byte <= 127
    // Repeated byte <= 128
    //

    bLiteral = FALSE;
    dwCount = 1;

    dwSrcSize = m_dwOutputBuffSize;

    pubSrcBuff = m_pubOutputBuff;
    pubDstBuff = m_pubRLEOutputBuff;
    m_dwRLEOutputDataSize = 0;

    while (dwSrcSize > 0 && m_dwRLEOutputDataSize + 2 < m_dwRLEOutputBuffSize)
    {
        ubCurrentData = *pubSrcBuff++;
        while (dwSrcSize > dwCount          &&
               ubCurrentData == *pubSrcBuff &&
               dwCount < 128                 )
        {
            dwCount++;
            pubSrcBuff++;
        }

        if (dwCount > 1)
        {
            bLiteral = FALSE;
            *pubDstBuff++ = 1-(char)dwCount;
            *pubDstBuff++ = ubCurrentData;
            m_dwRLEOutputDataSize += 2;
        }
        else
        {
            if (bLiteral)
            {
                (*pubLiteralNum) ++;
                *pubDstBuff++ = ubCurrentData;
                m_dwRLEOutputDataSize ++;
                if (*pubLiteralNum == 127)
                {
                    bLiteral = FALSE;
                }
            }
            else
            {
                bLiteral = TRUE;
                pubLiteralNum = pubDstBuff;
                *pubDstBuff++ = 0;
                *pubDstBuff++ = ubCurrentData;
                m_dwRLEOutputDataSize += 2;
            }
        }

        dwSrcSize -= dwCount;
        dwCount = 1;
    }

    if (dwSrcSize == 0)
        return TRUE;
    else
        return FALSE;
}



BOOL
BMPConv::
BCompressDRC(
    VOID)
/*++

Routine Description:

    This function is called to compress a scan line of data using
    delta row compression.

Arguments:

Return Value:

    Number of compressed bytes or -1 if too large for buffer

Note:
    A return value of 0 is valid since it implies the two lines
    are identical.

--*/

{
    BYTE   *pbI;
    BYTE   *pbO;         /* Record output location */
    BYTE   *pbOEnd;      /* As far as we will go in the output buffer */
    BYTE   *pbIEnd;
    BYTE   *pbStart;
    BYTE   *pb;
    int    iDelta;
    int    iOffset;     // index of current data stream
    int    iSize;       /* Number of bytes in the run */
    int    iSrcSize;

    //
    // The control byte has the following format:
    // Number of delta bytes:  Bits 5-7 indicate the number of consecutive
    // replacement bytes that follow the commands byte.  The actual number
    // of of replacement bytes is always one more than the value
    // (000 = 1, 111 = 8).  If more than 8 delta bytes are needed,
    // additional command byte/delta bytes are added.
    // [ (Command Byte) (1-8 Delta Bytes) ]
    // [ (Command Byte) (1-8 Delta Bytes) ] . . .
    // Offset: Bits 0-4 show where to position the replacement byte string.
    // This is the offset: it specifies a byte placement, counting from left 
    // to right from the current byte position.  The current byte is the
    // first unaltered byte that follows the last replacement bytes; at the
    // beginning of a row, the current byte immediately follows the left
    // raster margin.  Bits 0-4 allow a maximum value of 31, but larger
    // offsets are possible.   A value of 0 to 30 indicates the delta bytes
    // are offset from the 1st to the 31st bytes. 
    // A value of 31 indicates that an additional offset byte follows the
    // command byte.
    //
    // To summarize, bits 0-4 have the following meaning:
    // 0 to 30: the offset is 0 to 30.
    // 31: the offset is 31 or greater.  If the offset is 31, an additional
    // offset byte follows the command byte.  The offset in the command bytes
    // is added to the offset bytes.  If the offset byte is 0, the offset is 
    // 31; if the offset byte is 255 additional offset bytes follow.
    // The last offset byte will have a value less than 255.  All the offset 
    // bytes are added to the offset in the command byte to get the offset
    // value.  For example, if there are two offset bytes, and the last
    // byte contains 175, the total offset would be: 31+255+175=461.
    //

    /*
     *   Limit the amount of data we will generate. For performance
     * reasons we will ignore the effects of an offset value
     * greater than 30 since it implies we were able to already skip
     * that many bytes. However, for safety sake we will reduce the
     * max allowable size by 2 bytes.
     */

    XL_VERBOSE(("BMPConv: BCompressDRC\n"));

    m_dwDRCOutputDataSize = 0;

    if ( NULL == m_pubDRCOutputBuff ||
         NULL == m_pubDRCPrevOutputBuff ||
         NULL == m_pubOutputBuff     )
        return FALSE;

    pbI    = m_pubOutputBuff;                 /* Working copy */
    iSrcSize = (UlBPPtoNum(m_OutputBPP) * m_dwWidth + 7) >> 3;
    pbIEnd = m_pubOutputBuff + iSrcSize;

    pbO    = m_pubDRCOutputBuff;                 /* Working copy */
    pbOEnd = m_pubDRCOutputBuff + m_dwDRCOutputBuffSize - 2;

    //
    // m_pubDRCPrevOutputBuff is continuously followed by m_putOutputBuff.
    // Both has m_dwOutputBuffSize size of memory.
    //
    iDelta = (int)(m_pubDRCPrevOutputBuff - m_pubOutputBuff);
    pbStart = m_pubOutputBuff;

    //
    // PCL XL exception.
    // 2) the delta row is preceded by a 2-byte byte count which
    // indicates the number of bytes to follow for the delta row.
    // The byte count is expected to be in LSB MSB order.
    //
    *((PWORD)pbO) = 0x0000;
    pbO += 2;

    //
    // this is the main loop for compressing the data
    //
    while (pbI < pbIEnd)
    {
        // fast skip for matching dwords
        //
        if (!((ULONG_PTR)pbI & 3))
        {
            while (pbI <= (pbIEnd-4) && *(DWORD *)pbI == *(DWORD *)&pbI[iDelta])
                pbI += 4;
            if (pbI >= pbIEnd)
                break;
        }
        // test for non-matching bytes and output the necessary compression string
        //
        if (*pbI != pbI[iDelta])
        {
            // determine the run length
            pb = pbI;
            do {
                pb++;
            } while (pb < pbIEnd && *pb != pb[iDelta]);

            iSize = (int)(pb - pbI);

            // Lets make sure we have room in the buffer before
            // we continue this, this compression algorithm adds
            // 1 byte for every 8 bytes of data worst case.
            //
            if (((iSize * 9 + 7) >> 3) > (pbOEnd - pbO))     // gives tighter code
                return FALSE;

            iOffset = (int)(pbI - pbStart);
            if (iOffset > 30)
            {
                if (iSize < 8)
                    *pbO++ = ((iSize-1) << 5) + 31;
                else
                    *pbO++ = (7 << 5) + 31;
                iOffset -= 31;
                while (iOffset >= 255)
                {
                    iOffset -= 255;
                    *pbO++ = 255;
                }
                *pbO++ = (BYTE)iOffset;
                if (iSize > 8)
                    goto FastEightByteRun;
            }
            else if (iSize > 8)
            {
                *pbO++ = (7 << 5) + iOffset;
FastEightByteRun:
                while (1)
                {
                    CopyMemory(pbO,pbI,8);
                    pbI += 8;
                    pbO += 8;
                    if ((iSize -= 8) <= 8)
                        break;
                    *pbO++ = (7 << 5);
                }
                *pbO++ = (iSize-1) << 5;
            }
            else
                *pbO++ = ((iSize-1) << 5) + iOffset;

            CopyMemory (pbO,pbI,iSize);
            pbI += iSize;
            pbO += iSize;
            pbStart = pbI;
        }
        pbI++;
    }

    //
    // PCL XL exception.
    // 2) the delta row is preceded by a 2-byte byte count which
    // indicates the number of bytes to follow for the delta row.
    // The byte count is expected to be in LSB MSB order.
    //
    m_dwDRCOutputDataSize = (DWORD)(pbO - m_pubDRCOutputBuff);
    (*(PWORD)m_pubDRCOutputBuff) = (WORD)m_dwDRCOutputDataSize - 2;

    return TRUE;
}

DWORD
BMPConv::
DwGetDstSize(VOID)
/*++

Routine Description:

    Returns the size of destination bitmap.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("BMPConv: DwGetDstSize\n"));

    if (m_CMode == eDeltaRowCompression)
        return m_dwDRCOutputDataSize;
    else
    if (m_CMode == eRLECompression)
        return m_dwRLEOutputDataSize;
    else
        return m_dwOutputBuffSize;
}

//
// Scanline basis DIB conversion functions
//


BOOL
BMPConv::
BCopy(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. Simple copy for 1BPP, 4,8BPP palette image.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    DWORD  dwByteIndex, dwBitIndex, dwSrcBytes, dwSrcRemainderBits;

    XL_VERBOSE(("BMPConv: BCopy\n"));


    if (m_InputBPP == e8bpp || m_FirstBit == eBitZero)
    {
        dwSrcBytes = (dwSrcPixelNum * (DWORD)UlBPPtoNum(m_InputBPP) + 7) >> 3;

        CopyMemory(m_pubOutputBuff, pubSrc, dwSrcBytes);
    }
    else
    {
        //
        // m_InputBPP is either 1 or 4, m_FirstBit is in [1,7].
        //

        ASSERT((m_InputBPP == e1bpp) || (m_InputBPP == e4bpp));
        ASSERT(m_FirstBit != eBitZero);

        dwSrcBytes = (dwSrcPixelNum * (DWORD)UlBPPtoNum(m_InputBPP)) >> 3;
        dwSrcRemainderBits = (dwSrcPixelNum * (DWORD)UlBPPtoNum(m_InputBPP)) % 8;

        //
        // Now dwSrcBytes is the number of full bytes we need to copy from the source,
        // dwSrcRemainderBits is the number of remaining bits after dwSrcBytes number
        // of bytes in the source we need to copy.
        //
        // We first copy the full bytes from source.
        //

        for (dwByteIndex = 0; dwByteIndex < dwSrcBytes; dwByteIndex++)
        {
            //
            // Compose the destination byte from two adjacent source bytes.
            //

            m_pubOutputBuff[dwByteIndex] = (BYTE)(pubSrc[dwByteIndex]   << ((DWORD)m_FirstBit)) |
                                  (BYTE)(pubSrc[dwByteIndex+1] >> (8 - (DWORD)m_FirstBit));
        }

        if (dwSrcRemainderBits)
        {
            //
            // Now copy the remaining source bits. There are 2 cases:
            //
            // (1) the remaining source bits are in 1 byte;
            // (2) the remaining source bits run across 2 bytes;
            //

            if (((DWORD)m_FirstBit + dwSrcRemainderBits - 1) < 8)
                m_pubOutputBuff[dwByteIndex] = (BYTE)(pubSrc[dwByteIndex] << ((DWORD)m_FirstBit));
            else
                m_pubOutputBuff[dwByteIndex] = (BYTE)(pubSrc[dwByteIndex]   << ((DWORD)m_FirstBit)) |
                                      (BYTE)(pubSrc[dwByteIndex+1] >> (8 - (DWORD)m_FirstBit));
        }
    }

    return TRUE;
}

BOOL
BMPConv::
B4BPPtoCMYK(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 4BPP to CMYK.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    PDWORD pdwColorTable;
    PBYTE  pubDst;
    DWORD  dwConvSize;
    ULONG  ulIndex;

    XL_VERBOSE(("BMPConv: B4BPPtoCMYK\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    dwConvSize = (DWORD)m_OddPixelStart;
    dwSrcPixelNum += dwConvSize;
    pubDst = m_pubOutputBuff;

    while (dwConvSize < dwSrcPixelNum)
    {
        ulIndex = (dwConvSize++ & 1) ?
                        pdwColorTable[*pubSrc++ & 0x0F] :
                        pdwColorTable[*pubSrc >> 4];

        pubDst[0] = CYAN(ulIndex);
        pubDst[1] = MAGENTA(ulIndex);
        pubDst[2] = YELLOW(ulIndex);
        pubDst[3] = BLACK(ulIndex);
        pubDst += 4;
    }

    return TRUE;
}

BOOL
BMPConv::
B4BPPtoRGB(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 4BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    PDWORD pdwColorTable;
    DWORD  dwConvSize;
    ULONG  ulIndex;
    PBYTE  pubDst;

    XL_VERBOSE(("BMPConv: B4BPPtoRGB\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    dwConvSize = m_OddPixelStart;
    dwSrcPixelNum += dwConvSize;
    pubDst = m_pubOutputBuff;

    while (dwConvSize < dwSrcPixelNum)
    {
        ulIndex = (dwConvSize++ & 1) ?
                        pdwColorTable[*pubSrc++ & 0x0F] :
                        pdwColorTable[*pubSrc >> 4];

        pubDst[0] = RED(ulIndex);
        pubDst[1] = GREEN(ulIndex);
        pubDst[2] = BLUE(ulIndex);
        pubDst += 3;
    }

    return TRUE;
}

BOOL
BMPConv::
B4BPPtoGray(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 4BPP to Gray.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    PDWORD pdwColorTable;
    ULONG ulIndex;
    DWORD dwConvSize;
    PBYTE pubDst;

    XL_VERBOSE(("BMPConv: B4BPPtoGray\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    dwConvSize = m_OddPixelStart;
    dwSrcPixelNum += dwConvSize;
    pubDst = m_pubOutputBuff;

    while (dwConvSize < dwSrcPixelNum)
    {
        ulIndex = (dwConvSize++ & 1) ?
                        pdwColorTable[*pubSrc++ & 0x0F] :
                        pdwColorTable[*pubSrc >> 4];

        *pubDst++ = DWORD2GRAY(ulIndex);
    }

    return TRUE;
}


BOOL
BMPConv::
B8BPPtoGray(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum
    )

/*++

Routine Description:

    DIB conversion function - 8BPP to grayscale.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    PDWORD  pdwColorTable;
    DWORD   dwColor;
    PBYTE   pubDst;

    XL_VERBOSE(("BMPConv: B8BPPtoGray\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    pubDst = m_pubOutputBuff;

    while (dwSrcPixelNum--)
    {
        dwColor = pdwColorTable[*pubSrc++];
        *pubDst++ = DWORD2GRAY(dwColor);
    }

    return TRUE;
}

BOOL
BMPConv::
B8BPPtoRGB(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 8BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return the size of translated destination bitmap

--*/
{
    PDWORD pdwColorTable;
    ULONG ulIndex;
    PBYTE pubDst;

    XL_VERBOSE(("BMPConv: B8BPPtoRGB\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    pubDst = m_pubOutputBuff;

    while (dwSrcPixelNum--)
    {
        ulIndex = pdwColorTable[*pubSrc++];

        pubDst[0] = RED(ulIndex);
        pubDst[1] = GREEN(ulIndex);
        pubDst[2] = BLUE(ulIndex);
        pubDst += 3;
    }

    return TRUE;
}

BOOL
BMPConv::
B8BPPtoCMYK(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 8BPP to CMYK.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return the size of translated destination bitmap

--*/
{
    PDWORD pdwColorTable;
    ULONG ulIndex;
    PBYTE pubDst;

    XL_VERBOSE(("BMPConv: B8BPPtoCMYK\n"));

    pdwColorTable = GET_COLOR_TABLE(m_pxlo);

    if (pdwColorTable == NULL)
        return FALSE;

    pubDst = m_pubOutputBuff;

    while (dwSrcPixelNum--)
    {
        ulIndex = pdwColorTable[*pubSrc++];

        pubDst[0] = CYAN(ulIndex);
        pubDst[1] = MAGENTA(ulIndex);
        pubDst[2] = YELLOW(ulIndex);
        pubDst[3] = BLACK(ulIndex);
        pubDst += 4;
    }

    return TRUE;
}

BOOL
BMPConv::
B16BPPtoGray(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 16BPP to 8 bits gray.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B16BPPtoGray\n"));

    while (dwSrcPixelNum--)
    {
        dwColor = XLATEOBJ_iXlate(m_pxlo, *((PWORD) pubSrc));
        pubSrc += 2;

        *pubDst++ = DWORD2GRAY(dwColor);
    }

    return TRUE;
}

BOOL
BMPConv::
B16BPPtoRGB(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 16BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B16BPPtoRGB\n"));

    while (dwSrcPixelNum--)
    {
        dwColor = XLATEOBJ_iXlate(m_pxlo, *((PWORD) pubSrc));
        pubSrc += 2;

        pubDst[0] = RED(dwColor);
        pubDst[1] = GREEN(dwColor);
        pubDst[2] = BLUE(dwColor);
        pubDst += 3;
    }

    return TRUE;
}

BOOL
BMPConv::
B24BPPtoGray(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 24BPP to 8 bits gray.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B24BPPtoGray\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Pure 24BPP RGB image.
        //

        while (dwSrcPixelNum--)
        {
            *pubDst++ = RGB2GRAY(pubSrc[0], pubSrc[1], pubSrc[2]);
            pubSrc += 3;
        }
    }
    else if (m_flags & BMPCONV_BGR)
    {
        while (dwSrcPixelNum--)
        {
            *pubDst++ = RGB2GRAY(pubSrc[2], pubSrc[1], pubSrc[0]);
            pubSrc += 3;
        }
    }
    else
    {
        ASSERT(m_flags & BMPCONV_XLATE);

        while (dwSrcPixelNum--)
        {
            dwColor = ((DWORD) pubSrc[0]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[2] << 16);

            pubSrc += 3;
            dwColor = XLATEOBJ_iXlate(m_pxlo, dwColor);
            *pubDst++ = DWORD2GRAY(dwColor);
        }
    }

    return TRUE;
}

BOOL
BMPConv::
B24BPPtoRGB(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 24BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B24BPPtoRGB\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Pure 24BPP RGB image.
        //

        CopyMemory(m_pubOutputBuff, pubSrc, dwSrcPixelNum * 3);
    }
    else if (m_flags & BMPCONV_BGR)
    {
        while (dwSrcPixelNum--)
        {
            pubDst[0] = pubSrc[2];
            pubDst[1] = pubSrc[1];
            pubDst[2] = pubSrc[0];
            pubSrc += 3;
            pubDst += 3;
        }
    }
    else if (m_flags & BMPCONV_XLATE)
    {
        while (dwSrcPixelNum--)
        {
            dwColor = ((DWORD) pubSrc[0]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[2] << 16);

            pubSrc += 3;
            dwColor = XLATEOBJ_iXlate(m_pxlo, dwColor);
            pubDst[0] = RED(dwColor);
            pubDst[1] = GREEN(dwColor);
            pubDst[2] = BLUE(dwColor);
            pubDst += 3;
        }
    }

    return TRUE;
}


BOOL
BMPConv::
B32BPPtoGray(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 32BPP to 8 bits Gray.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    DWORD dwColor;
    BYTE  ubCyan, ubMagenta, ubYellow, ubBlack;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B24BPPtoGray\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Source bitmap is a pure 32BPP CMYK image.
        //

        while (dwSrcPixelNum--)
        {
            ubCyan    = *pubSrc++;
            ubMagenta = *pubSrc++;
            ubYellow  = *pubSrc++;
            ubBlack   = *pubSrc++;

            *pubDst++ = RGB2GRAY(255 - min(255, (ubCyan    + ubBlack)),
                                 255 - min(255, (ubMagenta + ubBlack)),
                                 255 - min(255, (ubYellow  + ubBlack)));
        }
    }
    else if (m_flags & BMPCONV_32BPP_RGB)
    {
        while (dwSrcPixelNum--)
        {
            *pubDst++ = RGB2GRAY(pubSrc[0], pubSrc[1], pubSrc[2]);
            pubSrc += 4;
        }
    }
    else if (m_flags & BMPCONV_32BPP_BGR)
    {
        while (dwSrcPixelNum--)
        {
            *pubDst++ = RGB2GRAY(pubSrc[0], pubSrc[1], pubSrc[2]);
            pubSrc += 4;
        }

    }
    else
    {
        ASSERT(m_flags & BMPCONV_XLATE);

        while (dwSrcPixelNum--)
        {
            dwColor = XLATEOBJ_iXlate(m_pxlo, *((PDWORD) pubSrc));
            pubSrc += 4;
            *pubDst++ = DWORD2GRAY(dwColor);
        }
    }

    return TRUE;
}


BOOL
BMPConv::
B32BPPtoRGB(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 32BPP to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/

{
    DWORD dwColor;
    BYTE  ubCyan, ubMagenta, ubYellow, ubBlack;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B32BPPtoRGB\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Source bitmap is a pure 32BPP CMYK image.
        //

        while (dwSrcPixelNum--)
        {
            ubCyan    = pubSrc[0];
            ubMagenta = pubSrc[1];
            ubYellow  = pubSrc[2];
            ubBlack   = pubSrc[3];
            pubSrc += 4;

            ubCyan    += ubBlack;
            ubMagenta += ubBlack;
            ubYellow  += ubBlack;

            pubDst[0] =  255 - min(255, ubCyan);
            pubDst[1] =  255 - min(255, ubMagenta);
            pubDst[2] =  255 - min(255, ubYellow);
            pubDst += 3;
        }
    }
    else if (m_flags & BMPCONV_32BPP_RGB)
    {
        while (dwSrcPixelNum--)
        {
            pubDst[0] = pubSrc[0];
            pubDst[1] = pubSrc[1];
            pubDst[2] = pubSrc[2];
            pubSrc += 4;
            pubDst += 3;
        }
    }
    else if (m_flags & BMPCONV_32BPP_BGR)
    {
        while (dwSrcPixelNum--)
        {
            pubDst[0] = pubSrc[2];
            pubDst[1] = pubSrc[1];
            pubDst[2] = pubSrc[0];
            pubSrc += 4;
            pubDst += 3;
        }
    }
    else
    {
        ASSERT(m_flags & BMPCONV_XLATE);

        while (dwSrcPixelNum--)
        {
            dwColor = XLATEOBJ_iXlate(m_pxlo, *((PDWORD) pubSrc));
            pubSrc += 4;
            pubDst[0] =  RED(dwColor);
            pubDst[1] =  GREEN(dwColor);
            pubDst[2] =  BLUE(dwColor);
            pubDst += 3;
        }
    }

    return TRUE;
}


BOOL
BMPConv::
B32BPPtoCMYK(
    IN     PBYTE       pubSrc,
    IN     DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 32BPP to CMYK.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD dwColor;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B32BPPtoCMYK\n"));

    if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
    {
        //
        // No special conversion is necessary.
        // Source bitmap is a pure 32BPP CMYK image.
        //

        CopyMemory(m_pubOutputBuff, pubSrc, dwSrcPixelNum * 4);
    }
    else
    {
        ASSERT(m_flags & BMPCONV_XLATE);

        while (dwSrcPixelNum--)
        {
            dwColor = XLATEOBJ_iXlate(m_pxlo, *((PDWORD) pubSrc));
            pubSrc += 4;

            pubDst[0] = 255 - RED(dwColor);
            pubDst[1] = 255 - GREEN(dwColor);
            pubDst[2] = 255 - BLUE(dwColor);
            pubDst[3] = 0;
            pubDst += 4;
        }
    }

    return TRUE;
}

BOOL
BMPConv::
BArbtoGray(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. Arbitray bitmap to 8 bits Gray scale.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD   dwColor;
    PDWORD  pdwSrc;
    PBYTE   pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: BArbtoGray\n"));

    pdwSrc = (PDWORD) pubSrc;

    while (dwSrcPixelNum--)
    {
        dwColor = XLATEOBJ_iXlate(m_pxlo, *pdwSrc++);
        *pubDst++ = DWORD2GRAY(dwColor);
    }

    return TRUE;
}

BOOL
BMPConv::
BArbtoRGB(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. Arbitraty bitmap to RGB.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD   dwColor;
    PDWORD  pdwSrc;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: BArbtoRGB\n"));

    pdwSrc = (PDWORD) pubSrc;

    while (dwSrcPixelNum--)
    {
        dwColor = XLATEOBJ_iXlate(m_pxlo, *pdwSrc++);

        pubDst[0] = RED(dwColor);
        pubDst[1] = GREEN(dwColor);
        pubDst[2] = BLUE(dwColor);
        pubDst += 3;
    }

    return TRUE;
}

#ifdef WINNT_40
BOOL
BMPConv::
B24BPPToImageMask(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)
/*++

Routine Description:

    DIB conversion function. 24 bpp bitmaps with only one non-white color to image mask.
    Can happen on NT4, where GDI does not optimize for that case.

Arguments:

    pubSrc - Source DIB buffer
    dwSrcPixelNum - the number of source pixel

Return Value:

    Return TRUE if succeeded, otherwise FALSE.

--*/
{
    DWORD   dwColor;
    PDWORD  pdwSrc;
    BYTE    ubDest = 0;
    DWORD   dwIndex = 0;
    DWORD   dwTransp = (m_flags & BMPCONV_SRC_COPY) ? RGB_WHITE : RGB_BLACK;
    PBYTE pubDst = m_pubOutputBuff;

    XL_VERBOSE(("BMPConv: B24BPPToImageMask\n"));

    while (dwSrcPixelNum--)
    {
        if (! (m_flags & BMPCONV_CHECKXLATEOBJ))
        {
            //
            // No special conversion is necessary, 24BPP RGB image.
            //
            dwColor = ((DWORD) pubSrc[0]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[2] << 16);
        }
        else if (m_flags & BMPCONV_BGR)
        {
            //
            // convert 24BPP BGR to RGB.
            //
            dwColor = ((DWORD) pubSrc[2]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[0] << 16);
        }
        else if (m_flags & BMPCONV_XLATE)
        {
            dwColor = ((DWORD) pubSrc[0]      ) |
                      ((DWORD) pubSrc[1] <<  8) |
                      ((DWORD) pubSrc[2] << 16);

            dwColor = XLATEOBJ_iXlate(m_pxlo, dwColor);
        }

        ubDest = ubDest << 1;
        dwIndex++;
        pubSrc += 3;

        if (dwColor != dwTransp)
            ubDest |= 0x01;

        if (dwIndex == 8) // one byte completed ?
        {
            *pubDst++ = ubDest;
            dwIndex = 0;
            ubDest = 0;
        }
    }

    if (dwIndex != 0) // flush leftover bits
        *pubDst = ubDest;

    return TRUE;
}
#endif

BOOL
BMPConv::
BConversionProc(
    PBYTE       pubSrc,
    DWORD       dwSrcPixelNum)

/*++

Routine Description:

    Return a pointer to the appropriate DIB conversion function

Arguments:

    pBMPAttrrib - Points to a BMPATTRUTE structure

Return Value:

    Pointer to a DIB conversion function

--*/

{
    //PVOID pfnDibConv[7][4] = {
    // Gray Scale, Palette,   RGB,          CMYK
    //-----------------------------------------------------------------------
    //{BCopy,        BCopy,     NULL,        NULL},        // 1bpp
    //{B4BPPtoGray,  BCopy,     B4BPPtoRGB,  B4BPPtoCMYK}, // 4bpp
    //{B8BPPtoGray,  BCopy,     B8BPPtoRGB,  B8BPPtoCMYK}, // 8bpp
    //{B16BPPtoGray, NULL,      B16BPPtoRGB, NULL},        // 16bpp
    //{B24BPPtoGray, NULL,      B24BPPtoRGB, NULL},        // 24bpp
    //{B32BPPtoGray, NULL,      B32BPPtoRGB, B32BPPtoCMYK},// 32bpp
    //{BArbtoGray,   NULL,      BArbtoRGB,   NULL}         // Arbitrary
    //};


    XL_VERBOSE(("BMPConv: BConversionProc\n"));

    //
    // special case for NT4: GDI passes all bitmaps as 24 bpp, even 1 bpp bitmaps
    // that can be better treated through image masks
    //

#if 0 // #ifdef WINNT_40
    if (m_flags & BMPCONV_2COLOR_24BPP)
    {
        return B24BPPToImageMask;
    }
#endif

    BOOL bRet = FALSE;

    //
    // Zero init for DWORD alignment
    //
    ZeroMemory(m_pubOutputBuff, m_dwOutputBuffSize);

    switch (m_InputBPP)
    {
    case e1bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
        case eOutputPal:
            BCopy(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputRGB:
        case eOutputCMYK:
            break;
        }
        break;

    case e4bpp:
        switch(m_OutputFormat)
        {
        case eOutputGray:
            B4BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            BCopy(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputRGB:
            B4BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            B4BPPtoCMYK(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        }

        break;

    case e8bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            B8BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            BCopy(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputRGB:
            B8BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            B8BPPtoCMYK(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        }
        break;

    case e16bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            B16BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            BCopy(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
            break;
        case eOutputRGB:
            B16BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            XL_ERR(("BMPConv::BConversionProc: 16 to CMYK is not supported yet.\n"));
            break;
        }
        break;

    case e24bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            B24BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            break;
        case eOutputRGB:
            B24BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            break;
        }
        break;

    case e32bpp:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            B32BPPtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            break;
        case eOutputRGB:
            B32BPPtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            B32BPPtoCMYK(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        }
        break;

    default:

        switch(m_OutputFormat)
        {
        case eOutputGray:
            BArbtoGray(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputPal:
            break;
        case eOutputRGB:
            BArbtoRGB(pubSrc, dwSrcPixelNum);
            bRet = TRUE;
            break;
        case eOutputCMYK:
            XL_ERR(("BMPConv::BConversionProc: Arb to CMYK is not supported yet.\n"));
            break;
        }
    }  
    return bRet;
}

DWORD
BMPConv::
DwCheckXlateObj(
    IN XLATEOBJ *pxlo,
    IN BPP InputBPP)
/*++

Routine Description:

    Determines the type of converison.
        *Palette
        *RGB
        *BGR
        *CMYK
        *Call XLATEOBJ_XXX function.

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwRet;
    DWORD Dst[4];

    XL_VERBOSE(("BMPConv: DwCheckXlateObj\n"));

    //
    // Init dwRet
    //
    dwRet = 0;

    switch (InputBPP)
    {
    case e16bpp:
        dwRet = BMPCONV_XLATE;
        break;

    case e24bpp:
        if (pxlo->iSrcType == PAL_RGB)
            dwRet = 0;
        else
        if (pxlo->iSrcType == PAL_BGR)
            dwRet = BMPCONV_BGR;
        {
            Dst[0] = XLATEOBJ_iXlate(pxlo, 0x000000FF);
            Dst[1] = XLATEOBJ_iXlate(pxlo, 0x0000FF00);
            Dst[2] = XLATEOBJ_iXlate(pxlo, 0x00FF0000);

            if ((Dst[0] == 0x000000FF) &&
                (Dst[1] == 0x0000FF00) &&
                (Dst[2] == 0x00FF0000)  )
            {
                dwRet = 0;
            }
            else if ((Dst[0] == 0x00FF0000) &&
                     (Dst[1] == 0x0000FF00) &&
                     (Dst[2] == 0x000000FF)  )
            {
                dwRet = BMPCONV_BGR;
            }
        }
        break;

    case e32bpp:
        if (pxlo->flXlate & XO_FROM_CMYK)
            dwRet = 0;
        else
        {
            //
            // Translate all 4 bytes from the DWORD
            //

            Dst[0] = XLATEOBJ_iXlate(pxlo, 0x000000FF);
            Dst[1] = XLATEOBJ_iXlate(pxlo, 0x0000FF00);
            Dst[2] = XLATEOBJ_iXlate(pxlo, 0x00FF0000);
            Dst[3] = XLATEOBJ_iXlate(pxlo, 0xFF000000);

            if ((Dst[0] == 0x000000FF) &&
                (Dst[1] == 0x0000FF00) &&
                (Dst[2] == 0x00FF0000) &&
                (Dst[3] == 0x00000000))
            {
                //
                // If translate result is same (4th byte will be zero) then
                // we done with it except if 32bpp then we have to skip one
                // source byte for every 3 bytes
                //

                dwRet = BMPCONV_32BPP_RGB;

            }
            else if ((Dst[0] == 0x00FF0000) &&
                     (Dst[1] == 0x0000FF00) &&
                     (Dst[2] == 0x000000FF) &&
                     (Dst[3] == 0x00000000))
            {
                //
                // Simply swap the R and B component
                //

                dwRet = BMPCONV_32BPP_BGR;
            }
        }
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxl.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pclxl.cpp

Abstract:

    PCL-XL command output high level function implementation

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created initial framework.

--*/

#include "xlpdev.h"
#include "pclxlcmd.h"
#include "pclxle.h"
#include "xldebug.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "xlbmpcvt.h"

//
// Hatch brush raster pattern
//
const BYTE   gubSizeOfHatchBrush = 32 * 32 / 8;
const USHORT gusWidthOfHatchBrush = 32;
const USHORT gusHeightOfHatchBrush = 32;
const BYTE gubHatchBrush[6][gubSizeOfHatchBrush] = 
{ {0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00,
   0xff, 0xff, 0xff, 0xff},
  {0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01},
  {0x80, 0x00, 0x00, 0x00,
   0x40, 0x00, 0x00, 0x00,
   0x20, 0x00, 0x00, 0x00,
   0x10, 0x00, 0x00, 0x00,
   0x08, 0x00, 0x00, 0x00,
   0x04, 0x00, 0x00, 0x00,
   0x02, 0x00, 0x00, 0x00,
   0x01, 0x00, 0x00, 0x00,
   0x00, 0x80, 0x00, 0x00,
   0x00, 0x40, 0x00, 0x00,
   0x00, 0x20, 0x00, 0x00,
   0x00, 0x10, 0x00, 0x00,
   0x00, 0x08, 0x00, 0x00,
   0x00, 0x04, 0x00, 0x00,
   0x00, 0x02, 0x00, 0x00,
   0x00, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x80, 0x00,
   0x00, 0x00, 0x40, 0x00,
   0x00, 0x00, 0x20, 0x00,
   0x00, 0x00, 0x10, 0x00,
   0x00, 0x00, 0x08, 0x00,
   0x00, 0x00, 0x04, 0x00,
   0x00, 0x00, 0x02, 0x00,
   0x00, 0x00, 0x01, 0x00,
   0x00, 0x00, 0x00, 0x80,
   0x00, 0x00, 0x00, 0x40,
   0x00, 0x00, 0x00, 0x20,
   0x00, 0x00, 0x00, 0x10,
   0x00, 0x00, 0x00, 0x08,
   0x00, 0x00, 0x00, 0x04,
   0x00, 0x00, 0x00, 0x02,
   0x00, 0x00, 0x00, 0x01},
  {
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x02,
   0x00, 0x00, 0x00, 0x04,
   0x00, 0x00, 0x00, 0x08,
   0x00, 0x00, 0x00, 0x10,
   0x00, 0x00, 0x00, 0x20,
   0x00, 0x00, 0x00, 0x40,
   0x00, 0x00, 0x00, 0x80,
   0x00, 0x00, 0x01, 0x00,
   0x00, 0x00, 0x02, 0x00,
   0x00, 0x00, 0x04, 0x00,
   0x00, 0x00, 0x08, 0x00,
   0x00, 0x00, 0x10, 0x00,
   0x00, 0x00, 0x20, 0x00,
   0x00, 0x00, 0x40, 0x00,
   0x00, 0x00, 0x80, 0x00,
   0x00, 0x01, 0x00, 0x00,
   0x00, 0x02, 0x00, 0x00,
   0x00, 0x04, 0x00, 0x00,
   0x00, 0x08, 0x00, 0x00,
   0x00, 0x10, 0x00, 0x00,
   0x00, 0x20, 0x00, 0x00,
   0x00, 0x40, 0x00, 0x00,
   0x00, 0x80, 0x00, 0x00,
   0x01, 0x00, 0x00, 0x00,
   0x02, 0x00, 0x00, 0x00,
   0x04, 0x00, 0x00, 0x00,
   0x08, 0x00, 0x00, 0x00,
   0x10, 0x00, 0x00, 0x00,
   0x20, 0x00, 0x00, 0x00,
   0x40, 0x00, 0x00, 0x00,
   0x80, 0x00, 0x00, 0x00},
  {0xff, 0xff, 0xff, 0xff,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01,
   0x00, 0x00, 0x00, 0x01},
  {0x80, 0x00, 0x00, 0x01,
   0x40, 0x00, 0x00, 0x02,
   0x20, 0x00, 0x00, 0x04,
   0x10, 0x00, 0x00, 0x08,
   0x08, 0x00, 0x00, 0x10,
   0x04, 0x00, 0x00, 0x20,
   0x02, 0x00, 0x00, 0x40,
   0x01, 0x00, 0x00, 0x80,
   0x00, 0x80, 0x01, 0x00,
   0x00, 0x40, 0x02, 0x00,
   0x00, 0x20, 0x04, 0x00,
   0x00, 0x10, 0x08, 0x00,
   0x00, 0x08, 0x10, 0x00,
   0x00, 0x04, 0x20, 0x00,
   0x00, 0x02, 0x40, 0x00,
   0x00, 0x01, 0x80, 0x00,
   0x00, 0x01, 0x80, 0x00,
   0x00, 0x02, 0x40, 0x00,
   0x00, 0x04, 0x20, 0x00,
   0x00, 0x08, 0x10, 0x00,
   0x00, 0x10, 0x08, 0x00,
   0x00, 0x20, 0x04, 0x00,
   0x00, 0x40, 0x02, 0x00,
   0x00, 0x80, 0x01, 0x00,
   0x01, 0x00, 0x00, 0x80,
   0x02, 0x00, 0x00, 0x40,
   0x04, 0x00, 0x00, 0x20,
   0x08, 0x00, 0x00, 0x10,
   0x10, 0x00, 0x00, 0x08,
   0x20, 0x00, 0x00, 0x04,
   0x40, 0x00, 0x00, 0x02,
   0x80, 0x00, 0x00, 0x01}
};

//
// High level output functions
//
HRESULT
XLOutput::
BeginImage(
    ColorMapping CMapping,
    ULONG   ulOutputBPP,
    ULONG   ulSrcWidth,
    ULONG   ulSrcHeight,
    ULONG   ulDestWidth,
    ULONG   ulDestHeight)
/*++

Routine Description:

     Sends BeginImage operator.

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwI = 0;

    XL_VERBOSE(("XLOutput::BeginImage:SrcW=%d, SrcH=%d, DstH=%d, DstW=%d\n",
              ulSrcWidth, ulSrcHeight, ulDestHeight, ulDestWidth));


    SetOutputBPP(CMapping, ulOutputBPP);
    SetSourceWidth((uint16)ulSrcWidth);
    SetSourceHeight((uint16)ulSrcHeight);
    SetDestinationSize((uint16)ulDestWidth, (uint16)ulDestHeight);
    Send_cmd(eBeginImage);

    return S_OK;
}
  
HRESULT
XLOutput::
SetOutputBPP(
    ColorMapping CMapping,
    ULONG   ulOutputBPP)
/*++

Routine Description:

    Sends Color mapping and output depth.

Arguments:

Return Value:

Note:

--*/
{
    switch (CMapping)
    {
    case eDirectPixel:
        SetColorMapping(eDirectPixel);
        break;
    case eIndexedPixel:
        SetColorMapping(eIndexedPixel);
        break;
    default:
        SetColorMapping(eDirectPixel);
    }

    switch (ulOutputBPP)
    {
    case 1:
        SetColorDepth(e1Bit);
        break;
    case 4:
        SetColorDepth(e4Bit);
        break;
    case 8:
    case 24:
        SetColorDepth(e8Bit);
        break;
    default:
        XL_ERR(("ulOutputBPP = %d is not supported\n", ulOutputBPP));
        //
        // Send color depth anyway to avoid XL error.
        //
        SetColorDepth(e8Bit);
    }

    return S_OK;
}

HRESULT
XLOutput::
SetPalette(
    ULONG ulOutputBPP,
    DWORD dwCEntries,
    DWORD *pdwColor)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    HRESULT hResult;

    if (dwCEntries != 0 && pdwColor != NULL)
    {
        SetPaletteDepth(e8Bit);
        SetPaletteData(m_DeviceColorDepth, dwCEntries, pdwColor);
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLOutput::SetPalette pxlo = NULL\n"));
        hResult = S_FALSE;
    }

    return hResult;
}

HRESULT
XLOutput::
SetClip(
    CLIPOBJ *pco)
/*++

Routine Description:

    Sends clip object.

Arguments:

Return Value:

Note:

--*/
{
    PATHOBJ *ppo;
    XLGState *pGState = this;
    HRESULT hResult;

    if (S_OK == pGState->CheckClip(pco))
        return S_OK;

    if ( NULL == pco )
    {
        XL_VERBOSE(("XLOutput::SetClip pco = NULL.\n"));
        Send_cmd(eSetClipToPage);
        pGState->ClearClip();
        return S_OK;
    }

    XL_VERBOSE(("XLOutput::SetClip: pco->iDComplexity=%d\n", pco->iDComplexity));

    switch(pco->iDComplexity)
    {
    case DC_RECT:
        SetClipMode(eClipEvenOdd);

        Send_cmd(eNewPath);
        RectanglePath(&(pco->rclBounds));

        SetClipRegion(eInterior);
        Send_cmd(eSetClipReplace);
        pGState->SetClip(pco);
        hResult = S_OK;
        break;

    case DC_COMPLEX:
        ppo = CLIPOBJ_ppoGetPath(pco);

        if (NULL == ppo)
        {
            XL_ERR(("XLOutput::SetClip ppo = NULL.\n"));
            Send_cmd(eSetClipToPage);
            pGState->ClearClip();
            hResult = S_FALSE;
            break;
        }

        SetClipMode(eClipEvenOdd);
        Path(ppo);
        SetClipRegion(eInterior);
        Send_cmd(eSetClipReplace);
        pGState->SetClip(pco);
        hResult = S_OK;
        break;

    case DC_TRIVIAL:
    default:
        Send_cmd(eSetClipToPage);
        pGState->ClearClip();
        hResult = S_OK;
        break;
    }

    return hResult;
}

HRESULT
XLOutput::
RoundRectanglePath(
    RECTL  *prclBounds)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    RECTL Rectl;

    if ( NULL == prclBounds )
    {
        XL_ERR(("XLOutput::RoundRectangle prclBounds = NULL.\n"));
        return E_UNEXPECTED;
    }

    XL_VERBOSE(("XLOutput::RoundRectanglePath:left=%d, top=%d, right=%d, bottom=%d\n",
             prclBounds->left,
             prclBounds->top,
             prclBounds->right,
             prclBounds->bottom));

    //
    // BoundingBox can handle only positive numbers.
    //
    Rectl = *prclBounds;

    if (Rectl.left < 0)
    {
        Rectl.left = 0;
    }
    if (Rectl.top < 0)
    {
        Rectl.top = 0;
    }
    if (Rectl.right < 0)
    {
        Rectl.right = 0;
    }
    if (Rectl.bottom < 0)
    {
        Rectl.bottom = 0;
    }


    //
    // DCR: Round value needs to be sent!
    //
    if (S_OK == SetBoundingBox((uint16)Rectl.left,
                               (uint16)Rectl.top,
                               (uint16)Rectl.right,
                               (uint16)Rectl.bottom) &&
        S_OK == Send_uint16_xy(0, 0) &&
        S_OK == Send_attr_ubyte(eEllipseDimension) &&
        S_OK == Send_cmd(eRoundRectanglePath))
        return S_OK;
    else
        return S_FALSE;

}

HRESULT
XLOutput::
SetCursor(
    LONG   lX,
    LONG   lY)
/*++

Routine Description:

    Set cursor.

Arguments:

Return Value:

Note:

--*/
{

    XL_VERBOSE(("XLOutput::SetCursor:X=%d, Y=%d\n", lX, lY));

    Send_sint16_xy((sint16)lX, (sint16)lY);
    Send_attr_ubyte(ePoint);
    Send_cmd(eSetCursor);

    m_lX = lX;
    m_lY = lY;

    return S_OK;
}

HRESULT
XLOutput::
GetCursorPos(
    PLONG plX,
    PLONG plY)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{

    XL_VERBOSE(("XLOutput::GetCursor:X=%d, Y=%d\n", *plX, *plY));

    if (plX == NULL || plY == NULL)
        return E_UNEXPECTED;

    *plX = m_lX;
    *plY = m_lY;

    return S_OK;
}

HRESULT
XLOutput::
ReadImage(
    DWORD  dwBlockHeight,
    CompressMode CMode)
/*++

Routine Description:

    Sends ReadImage operator

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::ReadImage:dwBlockHeight=%d\n", dwBlockHeight));

    Send_uint16((uint16)0);
    Send_attr_ubyte(eStartLine);

    Send_uint16((uint16)dwBlockHeight);
    Send_attr_ubyte(eBlockHeight);

    //
    // DCR: Need to support JPEG
    //
    SetCompressMode(CMode);
    Send_cmd(eReadImage);

    return S_OK;
}

HRESULT
XLOutput::
ReadImage(
    DWORD  dwStart,
    DWORD  dwBlockHeight,
    CompressMode CMode)
/*++

Routine Description:

    Sends ReadImage operator

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::ReadImage:dwBlockHeight=%d\n", dwBlockHeight));

    Send_uint16((uint16)dwStart);
    Send_attr_ubyte(eStartLine);

    Send_uint16((uint16)dwBlockHeight);
    Send_attr_ubyte(eBlockHeight);

    //
    // DCR: Need to support JPEG
    //
    SetCompressMode(CMode);
    Send_cmd(eReadImage);

    return S_OK;
}

HRESULT
XLOutput::
ReadRasterPattern(
    DWORD  dwBlockHeight,
    CompressMode CMode)
/*++

Routine Description:

    Sends ReadRasterPattern operator.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::ReadRasterPattern:dwBlockHeight=%d\n", dwBlockHeight));

    Send_uint16((uint16)0);
    Send_attr_ubyte(eStartLine);
    Send_uint16((uint16)dwBlockHeight);
    Send_attr_ubyte(eBlockHeight);

    //
    // DCR: Need to support JPEG
    //
    SetCompressMode(CMode);
    Send_cmd(eReadRastPattern);

    return S_OK;
}

HRESULT
XLOutput::
SetRGBColor(
    uint32 uint32_RGB)
/*++

Routine Description:

    Sends SetGrayLevel attribute.

Arguments:

Return Value:

Note:

--*/
{

    //
    // RGB color 3 bytes
    //
    Send_ubyte_array_header(3);
    WriteByte(RED(uint32_RGB));
    WriteByte(GREEN(uint32_RGB));
    WriteByte(BLUE(uint32_RGB));
    Send_attr_ubyte(eRGBColor);

    return S_OK;
}

HRESULT
XLOutput::
SetGrayLevel(
    ubyte ubyte_gray)
/*++

Routine Description:

    Sends SetGrayLevel attribute.

Arguments:

Return Value:

Note:

--*/
{
    Send_ubyte(ubyte_gray);
    Send_attr_ubyte(eGrayLevel);

    return S_OK;
}

HRESULT
XLOutput::
RectanglePath(
    RECTL  *prclRect)
/*++

Routine Description:

    Sends Rectangle Path

Arguments:

Return Value:

Note:

--*/
{
    RECTL Rectl;

    if (NULL == prclRect)
    {
        XL_ERR(("XLOutput::RectanglePath: prclRect == NULL\n"));
        return E_UNEXPECTED;
    }

    XL_VERBOSE(("XLOutput::RectanglePath:left=%d, top=%d, right=%d, bottom=%d\n",
             prclRect->left,
             prclRect->top,
             prclRect->right,
             prclRect->bottom));

    Rectl = *prclRect;

    if (prclRect->left < 0)
    {
        Rectl.left = 0;
    }
    if (prclRect->top < 0)
    {
        Rectl.top = 0;
    }
    if (prclRect->right < 0)
    {
        Rectl.right = 0;
    }
    if (prclRect->bottom < 0)
    {
        Rectl.bottom = 0;
    }


    if (S_OK == SetBoundingBox((uint16)Rectl.left,
                               (uint16)Rectl.top,
                               (uint16)Rectl.right,
                               (uint16)Rectl.bottom) &&
        S_OK == Send_cmd(eRectanglePath) )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
Path(
    PATHOBJ *ppo)
/*++

Routine Description:

    Sends path.

Arguments:

Return Value:

Note:

--*/
{
    POINTFIX* pptfx;
    PATHDATA  PathData;
    LONG      lPoints;
    HRESULT   hResult;
    BOOL      bMore;

    XL_VERBOSE(("XLOutput::Path\n"));

    if (ppo == NULL)
    {
        XL_ERR(("XLOutput::Path ppo = NULL.\n"));
        return E_UNEXPECTED;
    }


    //
    // Emit newpath operator
    // Don't do it if we're between path escapes
    //
    hResult = Send_cmd(eNewPath);

    //
    // Path object case
    //

    PATHOBJ_vEnumStart(ppo);

    do
    {
        bMore   = PATHOBJ_bEnum(ppo, &PathData);

        pptfx   = PathData.pptfx;
        if ( 0 == (lPoints = PathData.count))
        {
            XL_VERBOSE(("XLOutput::Path PathData.Count == 0\n"));
            hResult = S_FALSE;
            continue;
        }

        //
        // Begin new sub path
        //

        if (PathData.flags & PD_BEGINSUBPATH)
        {
            //
            // start new path
            //

            if (hResult == S_OK)
                hResult = SetCursor(FXTOL(pptfx->x), FXTOL(pptfx->y));;
            pptfx++;
            lPoints--;
        }


        if (lPoints > 0)
        {
            if (PathData.flags & PD_BEZIERS)
            {
                //
                // Output a Bezier curve segment
                //

                ASSERTMSG((lPoints % 3) == 0,
                          ("Incorrect number of points for a Bezier curve: %d\n", lPoints));

                if (hResult == S_OK)
                    hResult = BezierPath(pptfx, lPoints);
            }
            else
            {
                //
                // Draw straight line segment
                //

                if (hResult == S_OK)
                    hResult = LinePath(pptfx, lPoints);
            }
        }

        //
        // Close subpath
        //

        if (PathData.flags & PD_CLOSEFIGURE)
        {
            if (hResult == S_OK)
                hResult = Send_cmd(eCloseSubPath);
        }

    }
    while (bMore);

    return hResult;
}


HRESULT
XLOutput::
BezierPath(
    POINTFIX* pptfx,
    LONG      lPoints)
/*++

Routine Description:

    Sends bezier path

Arguments:

Return Value:

Note:

--*/
{
    LONG lValue, lI;
    DWORD dwDataLength;

    if (NULL == pptfx)
    {
         XL_ERR(("XLOutput::BezierPath: pptfx == NULL\n"));
         return E_UNEXPECTED;
    }

    XL_VERBOSE(("XLOutput::BezierPath(lPoints=%d)\n",lPoints));

    Send_uint16((uint16)lPoints);
    Send_attr_ubyte(eNumberOfPoints);
    Send_ubyte(eSint16);
    Send_attr_ubyte(ePointType);
    Send_cmd(eBezierPath);

    dwDataLength = lPoints * 2 * sizeof(sint16);

    if (dwDataLength > 0xff)
    {
        WriteByte(PCLXL_dataLength);
        Write((PBYTE)&dwDataLength, sizeof(DWORD));
    }
    else
    {
        WriteByte(PCLXL_dataLengthByte);
        WriteByte((ubyte)dwDataLength);
    }

    for (lI = 0; lI < lPoints; lI++)
    {
        lValue = FXTOL(pptfx->x);
        Write((PBYTE)&lValue, sizeof(sint16));
        lValue = FXTOL(pptfx->y);
        Write((PBYTE)&lValue, sizeof(sint16));
        pptfx++;
    }

    //
    // Update the last coordinate.
    // Make sure that there are some points.
    if (lPoints > 0)
    {
        pptfx--;
        m_lX = FXTOL(pptfx->x);
        m_lY = FXTOL(pptfx->y);
    }
    else
    {
        m_lX = 0;
        m_lY = 0;
    }


    return S_OK;
}
    
HRESULT
XLOutput::
LinePath(
    POINTFIX* pptfx,
    LONG      lPoints)
/*++

Routine Description:

   Sends line path.

Arguments:

Return Value:

Note:

--*/
{
    LONG lValueX, lValueY, lI, lJ;
    LONG lx, ly;
    DWORD dwDataLength;

    if (NULL == pptfx)
    {
         XL_ERR(("XLOutput::LinePath: pptfx == NULL\n"));
         return E_UNEXPECTED;
    }

    XL_VERBOSE(("XLOutput::LinePath(lPoints=%d)\n", lPoints));

    //
    // Optimization. Use byte relpath to minimize the output size
    // First, check if the difference from the previous position is in a byte.
    //
    BOOL bModeChange;
    enum { eMode_SByte, eMode_SInt, eMode_None} Mode;
    LONG lStart, lEnd, lNumOfSByte;
    LONG lStartX, lStartY;
    POINTFIX *pptfx_tmp = pptfx;

    //
    // Get current cursor position
    //
    lStartX = lx = m_lX;
    lStartY = ly = m_lY;

    //
    // Reset
    //
    lStart = 0;
    Mode = eMode_None;
    bModeChange = FALSE;
    lNumOfSByte = 0;

    for (lI = 0; lI < lPoints; )
    {
        XL_VERBOSE(("XLOutput::LinePath: (%d)=(%d,%d)\n",lI, lx, ly));
        lValueX = FXTOL(pptfx_tmp->x) - (LONG)lx;
        lValueY = FXTOL(pptfx_tmp->y) - (LONG)ly;

        //
        // Mode needs to be in SByte or SInt?
        //
        if ( -128 <= lValueX && lValueX <= 127
        &&   -128 <= lValueY && lValueY <= 127 )
        {
            if (Mode == eMode_SInt)
            {
                //
                // Optimization
                //
                // To switch mode between SInt and SByte, it needs 7 bytes.
                //
                // uint16 XX NumberOfPoints
                // ubyte eSByte PointType
                // LineRelPath
                //
                // 4 points with SInt consumes 2 x 4 = 8 bytes extra data.
                // 3 points with SInt consumes 2 x 3 = 6 bytes extra data.
                //
                // 4 points is the threshold to swith mode to SInt.
                //
                // Number of points: lEnd - lStart + 1
                // if (lI - 1 - lStartSByte + 1 >= 4)
                //
                // If SByte continues more than 4 points, switch mode from
                // SByte to SInt.
                //
                if (lNumOfSByte >= 4)
                {
                    bModeChange = TRUE;
                    lI -= lNumOfSByte;
                    pptfx_tmp -= lNumOfSByte;
                    lEnd = (lI - 1);
                    lNumOfSByte = 0;
                }
            
                //
                // Reset starting point of SByte
                //
                lNumOfSByte ++;
            }
            else
            {
                Mode = eMode_SByte;
            }

            XL_VERBOSE(("XLOutput::LinePath: (SByte) lx1=%d, lx2=%d\n", lx, FXTOL(pptfx_tmp->x)));
        }
        else
        {
            if (Mode == eMode_SByte)
            {
                bModeChange = TRUE;
                lEnd = lI - 1;
            }
            else
            {
                Mode = eMode_SInt;
                lNumOfSByte = 0;
            }
            XL_VERBOSE(("XLOutput::LinePath: (SInt) lx1=%d, lx2=%d\n", lx, FXTOL(pptfx_tmp->x)));
        }

        if (!bModeChange && lI + 1 == lPoints)
        {
            bModeChange = TRUE;
            lEnd = lI;
            lI ++;
        }

        if (bModeChange)
        {
            XL_VERBOSE(("XLOutput::LinePath: Draw\n"));

            //
            // Get start cursor position
            //
            lx = lStartX;
            ly = lStartY;

            if (Mode == eMode_SByte)
            {
                //
                // SByte
                //
                Send_uint16((uint16)(lEnd - lStart + 1));
                Send_attr_ubyte(eNumberOfPoints);
                Send_ubyte(eSByte);
                Send_attr_ubyte(ePointType);
                Send_cmd(eLineRelPath);

                dwDataLength = (lEnd - lStart + 1) * 2 * sizeof(ubyte);

                if (dwDataLength <= 0xFF)
                {
                    WriteByte(PCLXL_dataLengthByte);
                    WriteByte((ubyte)dwDataLength);
                }
                else
                {
                    WriteByte(PCLXL_dataLength);
                    Write((PBYTE)&dwDataLength, sizeof(DWORD));
                }

                for (lJ = 0; lJ <= (lEnd - lStart); lJ++)
                {
                    lValueX = FXTOL(pptfx->x) - (LONG)lx;
                    lValueY = FXTOL(pptfx->y) - (LONG)ly;
                    Write((PBYTE)&lValueX, sizeof(ubyte));
                    Write((PBYTE)&lValueY, sizeof(ubyte));
                    lx = FXTOL(pptfx->x);
                    ly = FXTOL(pptfx->y);
                    pptfx++;
                }

                Mode = eMode_SInt;
            }
            else if (Mode == eMode_SInt)
            {
                //
                // SInt16
                //
                Send_uint16((uint16)(lEnd - lStart + 1));
                Send_attr_ubyte(eNumberOfPoints);
                Send_ubyte(eSint16);
                Send_attr_ubyte(ePointType);
                Send_cmd(eLineRelPath);
                dwDataLength = (lEnd - lStart + 1) * 2 * sizeof(uint16);

                if (dwDataLength <= 0xFF)
                {
                    WriteByte(PCLXL_dataLengthByte);
                    WriteByte((ubyte)dwDataLength);
                }
                else
                {
                    WriteByte(PCLXL_dataLength);
                    Write((PBYTE)&dwDataLength, sizeof(DWORD));
                }

                for (lJ = 0; lJ <= (lEnd - lStart); lJ++)
                {
                    lValueX = FXTOL(pptfx->x) - (LONG)lx;
                    lValueY = FXTOL(pptfx->y) - (LONG)ly;
                    Write((PBYTE)&lValueX, sizeof(sint16));
                    Write((PBYTE)&lValueY, sizeof(sint16));
                    lx = FXTOL(pptfx->x);
                    ly = FXTOL(pptfx->y);
                    pptfx++;
                }

                Mode = eMode_SByte;
            }

            bModeChange = FALSE;

            lStartX = lx = FXTOL((pptfx_tmp-1)->x);
            lStartY = ly = FXTOL((pptfx_tmp-1)->y);
            lStart = lI;
        }
        else
        {
            lx = FXTOL((pptfx_tmp)->x);
            ly = FXTOL((pptfx_tmp)->y);
            pptfx_tmp ++;
            lI ++;
        }
    }

    //
    // Update cursor position
    //
    m_lX = FXTOL((pptfx_tmp)->x);
    m_lY = FXTOL((pptfx_tmp)->y);

    return S_OK;
}

inline
VOID
XLOutput::
SetupBrush(
    BRUSHOBJ *pbo,
    POINTL *pptlBrushOrg,
    CMNBRUSH *pcmnbrush)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwHatchID;
    XLBRUSH *pBrush;

    if (NULL == pcmnbrush)
    {
        //
        // Make sure that pcmnbrush is valid.
        //
        XL_ERR(("SetupBrush:pcmnbrush is invalid.\n"));
        return;
    }

    //
    // Initialize CMNBRUSH
    //
    pcmnbrush->dwSig            = BRUSH_SIGNATURE;
    pcmnbrush->BrushType        = kNoBrush;
    pcmnbrush->ulHatch          = 0XFFFFFFFF;
    pcmnbrush->dwColor          = 0x00FFFFFF;
    pcmnbrush->dwCEntries       = 0;
    pcmnbrush->dwPatternBrushID = 0xFFFFFFFF;

    XL_VERBOSE(("XLOutput::SetupBrush\n"));

    if (NULL == pbo)
    {
        XL_VERBOSE(("XLOutput::SetupBrush: pbo == NULL, set NULL brush\n"));
    }
    else
    {

        #ifndef WINNT_40
        if ( !(pbo->flColorType & BR_CMYKCOLOR)     &&
              (pbo->iSolidColor == NOT_SOLID_COLOR)  )
        #else
        if (pbo->iSolidColor == NOT_SOLID_COLOR)
        #endif
        {
            pcmnbrush->ulSolidColor     = BRUSHOBJ_ulGetBrushColor(pbo);
            pBrush = (XLBRUSH*)BRUSHOBJ_pvGetRbrush(pbo);
            if (NULL == pBrush)
            {
                XL_ERR(("SetupBrush:BRUSHOBJ_pvGetRbrush failed.\n"));
                dwHatchID = HS_DDI_MAX;
            }
            else
            {
                dwHatchID = pBrush->dwHatch;
            }
        }
        else
        {
            dwHatchID = HS_DDI_MAX;
            pcmnbrush->ulSolidColor     = pbo->iSolidColor;
            pBrush = NULL;
        }

        pcmnbrush->ulHatch          = dwHatchID;

        switch (dwHatchID)
        {
        case HS_HORIZONTAL:
        case HS_VERTICAL:
        case HS_BDIAGONAL:
        case HS_FDIAGONAL:
        case HS_CROSS:
        case HS_DIAGCROSS:
            XL_VERBOSE(("XLOutput::SetupBrush(uiSolidColor=%d,dwHatchID=%d)\n",
                        pbo->iSolidColor,
                        dwHatchID));

            pcmnbrush->BrushType = kBrushTypeHatch;
            pcmnbrush->dwPatternBrushID = dwHatchID;

            if (pBrush)
            {
                pcmnbrush->dwColor = pBrush->dwColor;
            }
            if (GetDeviceColorDepth() == e24Bit)
            {
                SetColorSpace(eRGB);
            }
            else
            {
                SetColorSpace(eGray);
            }
            SetPaletteDepth(e8Bit);
            if (pBrush->dwCEntries)
            {
                SetPaletteData(m_DeviceColorDepth, pBrush->dwCEntries, pBrush->adwColor);
            }
            else
            {
                DWORD dwColorTableTmp[2] = {0x00ffffff, 0x00ffffff};
                dwColorTableTmp[1] = pBrush->dwColor;
                SetPaletteData(m_DeviceColorDepth, 2, dwColorTableTmp);
            }
            Send_cmd(eSetColorSpace);

            if (!(m_dwHatchBrushAvailability & (HORIZONTAL_AVAILABLE << dwHatchID)))
            {

                SetColorMapping(eIndexedPixel);
                SetColorDepth(e1Bit);
                SetSourceWidth((uint16)gusWidthOfHatchBrush);
                SetSourceHeight((uint16)gusHeightOfHatchBrush);

                //
                // Pattern scaling factor
                // 160 is an experimentally introduced number.
                //
                WORD wScale = (WORD)(160 * m_dwResolution / 1200);

                SetDestinationSize((uint16)wScale, (uint16)wScale);
                SetPatternPersistence(eSessionPattern);
                SetPatternDefineID((sint16)dwHatchID);
                Send_cmd(eBeginRastPattern);

                Send_uint16((uint16)0);
                Send_attr_ubyte(eStartLine);
                Send_uint16((uint16)gusHeightOfHatchBrush);
                Send_attr_ubyte(eBlockHeight);
                SetCompressMode(eNoCompression);
                Send_cmd(eReadRastPattern);

                WriteByte(PCLXL_dataLengthByte);
                WriteByte(gubSizeOfHatchBrush);
                Write((PBYTE)gubHatchBrush[dwHatchID], gubSizeOfHatchBrush);
                Send_cmd(eEndRastPattern);

                m_dwHatchBrushAvailability |= HORIZONTAL_AVAILABLE << dwHatchID;
            }

            //
            //SendPatternSelectID();
            //
            Send_sint16((sint16)dwHatchID);
            Send_attr_ubyte(ePatternSelectID);

            break;
        case HS_DDI_MAX:
            pcmnbrush->BrushType = kBrushTypeSolid;
            //pcmnbrush->dwColor = BRUSHOBJ_ulGetBrushColor(pbo); 
            pcmnbrush->dwColor = pcmnbrush->ulSolidColor;

            XL_VERBOSE(("XLOutput::SetupBrush(RGB=0x%x)\n", pcmnbrush->dwColor));
            if (e24Bit == GetDeviceColorDepth())
            {
                SetRGBColor(pcmnbrush->dwColor);
            }
            else
            {
                ubyte ubyte_gray = (ubyte) DWORD2GRAY(pcmnbrush->dwColor);
                SetGrayLevel(ubyte_gray);
            }
            break;

        default:
            if (NULL == pBrush)
            {
                XL_ERR(("XLOutput:SetupBrush: invalid pBrush\n"));
                return;
            }

            XL_VERBOSE(("XLOutput::SetupBrush(PatternID=%d)\n", pBrush->dwPatternID));

            pcmnbrush->dwColor = pBrush->dwColor;
            pcmnbrush->dwPatternBrushID = pBrush->dwPatternID;
            pcmnbrush->BrushType = kBrushTypePattern;

            if (e24Bit == GetDeviceColorDepth())
            {
                SetColorSpace(eRGB);
            }
            else
            {
                SetColorSpace(eGray);
            }
            if (pBrush->dwCEntries)
            {
                SetPaletteDepth(e8Bit);
                SetPaletteData(m_DeviceColorDepth, pBrush->dwCEntries, pBrush->adwColor);
            }
            Send_cmd(eSetColorSpace);

            //SendPatternSelectID();
            Send_sint16((sint16)pBrush->dwPatternID);
            Send_attr_ubyte(ePatternSelectID);

        }
    }

    return;
}

HRESULT
XLOutput::
SetPenColor(
    BRUSHOBJ *pbo,
    POINTL     *pptlBrushOrg)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::SetPenColor\n"));
    XLPen *pPen = this;
    CMNBRUSH cmnbrush;

    if (S_OK == pPen->CheckCurrentBrush(pbo))
        return S_OK;

    if (NULL == pbo)
    {
        Send_ubyte(0);
        Send_attr_ubyte(eNullPen);
    }
    SetupBrush(pbo, pptlBrushOrg, &cmnbrush);
    Send_cmd(eSetPenSource);

    pPen->SetBrush(&cmnbrush);

    return S_OK;
}

HRESULT
XLOutput::
SetPen(
    LINEATTRS *plineattrs,
    XFORMOBJ   *pxo)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    LineCap linecap;
    XLLineEndCap xllinecap;
    LineJoin linejoin;
    XLLineJoin xllinejoin;
    FLOATOBJ fLineWidth;
    uint16 uint16_linewidth;

    XL_VERBOSE(("XLOutput::SetPen\n"));

    if (NULL == plineattrs)
    {
        XL_ERR(("XLOutput:SetPen: invalid parameters\n"));
        return E_UNEXPECTED;
    }

    XLGState *pGState = this;

    DWORD dwLine = pGState->GetDifferentAttribute(plineattrs);

    //
    // DCR: need to check each attribute.
    //
    if (XLLINE_NONE ==  dwLine)
        return S_OK;

    if (plineattrs->fl & LA_GEOMETRIC)
    {
        //
        // Line joint
        //
        switch(plineattrs->iJoin)
        {
            case JOIN_ROUND:
                linejoin = eRoundJoin;
                xllinejoin = kXLLineJoin_Round;
                break;
            case JOIN_BEVEL:
                linejoin = eBevelJoin;
                xllinejoin = kXLLineJoin_Bevel;
                break;
            case JOIN_MITER:
                linejoin = eMiterJoin;
                xllinejoin = kXLLineJoin_Miter;
                break;
            default:
                linejoin = eRoundJoin;
                xllinejoin = kXLLineJoin_Round;
                break;
        }

        //
        // Line endcap
        //
        switch(plineattrs->iEndCap)
        {
            case ENDCAP_ROUND:
                linecap = eRoundCap;
                xllinecap = kXLLineEndCapRound;
                break;
            case ENDCAP_SQUARE:
                linecap = eSquareCap;
                xllinecap = kXLLineEndCapSquare;
                break;
            case ENDCAP_BUTT:
                linecap = eButtCap;
                xllinecap = kXLLineEndCapButt;
                break;
            default:
                linecap = eRoundCap;
                xllinecap = kXLLineEndCapRound;
                break;
        }
        
        //
        // Line width
        //

        fLineWidth = plineattrs->elWidth.e;

    }
    else
    {
        linejoin = eRoundJoin;
        linecap = eRoundCap;
        FLOATOBJ_SetLong(&fLineWidth, plineattrs->elWidth.l);
    }

    if (dwLine & XLLINE_WIDTH)
    {
        uint16_linewidth = (uint16)FLOATOBJ_GetLong(&fLineWidth);
        SetPenWidth(uint16_linewidth);
        pGState->SetLineWidth(plineattrs->elWidth);
    }
    if (dwLine & XLLINE_ENDCAP)
    {
        SetLineCap(linecap);
        pGState->SetLineEndCap(xllinecap);
    }
    if (dwLine & XLLINE_JOIN)
    {
        SetLineJoin(linejoin);
        pGState->SetLineJoin(xllinejoin);
    }


    //
    // Line style
    //
    if (dwLine & XLLINE_STYLE)
    {
        if (plineattrs->cstyle == 0)
        {
            Send_ubyte((ubyte)0);
            Send_attr_ubyte(eSolidLine);
            Send_cmd(eSetLineDash);
        }
        else
        {
            DWORD dwI, dwSegCount;
            PFLOAT_LONG plSize;
            FLOAT_LONG lSize[2];
            FLOATOBJ fSize;
            uint16 uint16_linesize;

            if (plineattrs->fl & LA_ALTERNATE)
            {
                if (plineattrs->fl & LA_GEOMETRIC)
                {
                    FLOATOBJ_SetLong(&lSize[0].e, 1);
                    FLOATOBJ_SetLong(&lSize[1].e, 1);
                }
                else
                {
                    lSize[0].l = 1;
                    lSize[1].l = 1;
                }

                dwSegCount = 2;
                plSize     = lSize;
            }
            else
            {
                dwSegCount = plineattrs->cstyle;
                plSize = plineattrs->pstyle;
            }
            if (plSize)
            {
                Send_uint16_array_header(dwSegCount);
                for (dwI = 0; dwI < dwSegCount; dwI ++, plSize ++)
                {
                    if (plineattrs->fl & LA_GEOMETRIC)
                    {
                        fSize = plSize->e;
                    }
                    else
                    {
                        FLOATOBJ_SetLong(&fSize, plSize->l);

                        //
                        // It is necessary to scale the line pattern. The number
                        // 24 on 1200 dpi was introduced experimentally.
                        // Here is an assumption. Resolution could be 300, 600,
                        // or 1200.
                        //
                        if (m_dwResolution > 50)
                        {
                            FLOATOBJ_MulLong(&fSize, m_dwResolution / 50);
                        }
                    }
                    uint16_linesize = (uint16)FLOATOBJ_GetLong(&fSize);
                    Write((PBYTE)&uint16_linesize, sizeof(uint16_linesize));
                }
                Send_attr_ubyte(eLineDashStyle);
                Send_cmd(eSetLineDash);
            }
        }

        pGState->SetLineStyle(plineattrs->cstyle,
                              plineattrs->pstyle,
                              plineattrs->elStyleState);
    }

    if (dwLine & XLLINE_MITERLIMIT)
    {
        FLOATOBJ fMiter;
        FLOATOBJ_SetFloat(&fMiter, plineattrs->eMiterLimit);
        uint16 uint16_miter = (uint16)FLOATOBJ_GetLong(&fMiter);

        //
        // PCLXL interpreter doesn't accept miterlimiter less than 1.
        // If it is less than 1, it replaces the value with 10.
        // We'd better set 1 instead.
        //
        // Actuall less than 1 means 0 here, though.
        //
        if (uint16_miter < 1)
        {
            uint16_miter = 1;
        }
        SetMiterLimit(uint16_miter);
        pGState->SetMiterLimit(plineattrs->eMiterLimit);
    }

    pGState->SetLineType((XLLineType)plineattrs->fl);
    return S_OK;
}

HRESULT
XLOutput::
SetBrush(
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::SetBrush\n"));
    XLBrush *pBrush = this;
    CMNBRUSH cmnbrush;

    if (S_OK == pBrush->CheckCurrentBrush(pbo))
        return S_OK;

    if (NULL == pbo)
    {
        Send_ubyte(0);
        Send_attr_ubyte(eNullBrush);
    }

    SetupBrush(pbo, pptlBrushOrg, &cmnbrush);
    Send_cmd(eSetBrushSource);

    pBrush->SetBrush(&cmnbrush);
    return S_OK;
}

HRESULT
XLOutput::
Paint(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::Paint\n"));
    return Send_cmd(ePaintPath);
}

HRESULT
XLOutput::
SetPaletteData(
    ColorDepth value,
    DWORD      dwPaletteNum,
    DWORD     *pdwColorTable)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwI;

    if (NULL == pdwColorTable)
    {
        XL_ERR(("XLOutput::SetPaletteData pdwColorTable == NULL\n"));
        return E_UNEXPECTED;
    }
    switch (value)
    {
    case e8Bit:
        WriteByte(PCLXL_ubyte_array);
        Send_uint16((uint16)dwPaletteNum);
        for (dwI = 0; dwI < dwPaletteNum; dwI ++)
            WriteByte((ubyte)DWORD2GRAY(*(pdwColorTable+dwI)));
        Send_attr_ubyte(ePaletteData);
        break;
    case e24Bit:
        WriteByte(PCLXL_ubyte_array);
        Send_uint16((uint16)dwPaletteNum * 3);
        for (dwI = 0; dwI < dwPaletteNum; dwI ++)
        {
            Write((PBYTE)(pdwColorTable+dwI), 3);
        }
        Send_attr_ubyte(ePaletteData);
        break;
    default:
        //
        // DCR: only supports 8bits gray scale
        //
        XL_ERR(("XLOutput::SetPaletteData: unsupported ColorDepth:%d\n", value));
    }

    return S_OK;
}

HRESULT
XLOutput::
SetFont(
    FontType fonttype,
    PBYTE    pFontName,
    DWORD    dwFontHeight,
    DWORD    dwFontWidth,
    DWORD    dwSymbolSet,
    DWORD    dwFontSimulation)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    FLOATOBJ fSize;
    LONG lvalue;

    if (NULL == pFontName)
    {
        XL_ERR(("XLOutput::SetFont: Invalie pFontName parameter\n"));
        return E_UNEXPECTED;
    }

    XLGState *pGState = this;

    if (S_OK == pGState->CheckCurrentFont(fonttype,
	          pFontName,
	          dwFontHeight,
	          dwFontWidth,
	          dwSymbolSet,
	          dwFontSimulation))
        return S_OK;

    FLOATOBJ_SetLong(&fSize, dwFontHeight);
    lvalue = FLOATOBJ_GetFloat(&fSize);

    //
    // Select font
    //
    Send_ubyte_array_header(PCLXL_FONTNAME_SIZE);
    Write(pFontName, PCLXL_FONTNAME_SIZE);
    Send_attr_ubyte(eFontName);
    Send_real32(lvalue);
    Send_attr_ubyte(eCharSize);
    Send_uint16((uint16)dwSymbolSet);
    Send_attr_ubyte(eSymbolSet);
    Send_cmd(eSetFont);

    //
    // TrueType font outline or device font
    // Font Scale
    // Font bold/italic simulaiton
    //
    if (fonttype == kFontTypeTTOutline ||
        fonttype == kFontTypeDevice     )
    {

        if (dwFontWidth != pGState->GetFontWidth() ||
            dwFontHeight != pGState->GetFontHeight()  )
        {
            //
            // Scale X and Y
            //
            if (dwFontWidth != 0 && dwFontHeight != dwFontWidth)
            {
                FLOATOBJ fTemp;
                FLOATOBJ_SetLong(&fTemp, dwFontWidth);
                FLOATOBJ_DivFloat(&fTemp, fSize);
                lvalue = FLOATOBJ_GetFloat(&fTemp);
                Send_real32_xy((real32)lvalue, (real32)real32_IEEE_1_0F);
                Send_attr_ubyte(eCharScale);
                Send_cmd(eSetCharScale);
            }
            else
            {
                Send_real32_xy((real32)real32_IEEE_1_0F, (real32)real32_IEEE_1_0F);
                Send_attr_ubyte(eCharScale);
                Send_cmd(eSetCharScale);
            }
        }

        DWORD dwCurrentFontSim = pGState->GetFontSimulation();

        //
        // Bold simulation
        //
        if ((dwFontSimulation & XLOUTPUT_FONTSIM_BOLD) !=
            (dwCurrentFontSim& XLOUTPUT_FONTSIM_BOLD))
        {
            if (dwFontSimulation & XLOUTPUT_FONTSIM_BOLD)
            {
                //
                // Hardcoded bold value 0.01500
                //
                #define XL_BOLD_VALUE 0x3c75c28f

                Send_real32((real32)XL_BOLD_VALUE);
            }
            else
                Send_real32((real32)0);

            Send_attr_ubyte(eCharBoldValue);
            Send_cmd(eSetCharBoldValue);
        }

        //
        // Italic simulation
        //
        if ((dwFontSimulation & XLOUTPUT_FONTSIM_ITALIC) !=
            (dwCurrentFontSim & XLOUTPUT_FONTSIM_ITALIC))
        {
            if (dwFontSimulation & XLOUTPUT_FONTSIM_ITALIC)
            {
                //
                // Hardcoded italic value 0.316200
                //
                #define XL_ITALIC_VALUE 0x3ea1e4f7
                Send_real32_xy((real32)XL_ITALIC_VALUE, (real32)0);
            }
            else
                Send_real32_xy((real32)0, (real32)0);

            Send_attr_ubyte(eCharShear);
            Send_cmd(eSetCharShear);
        }

        //
        // Vertical font simulation
        //
        if ((dwFontSimulation & XLOUTPUT_FONTSIM_VERTICAL) !=
            (dwCurrentFontSim & XLOUTPUT_FONTSIM_VERTICAL))
        {
            if (dwFontSimulation & XLOUTPUT_FONTSIM_VERTICAL)
            {
                Send_ubyte(eVertical);
            }
            else
            {
                Send_ubyte(eHorizontal);
            }
            Send_attr_ubyte(eWritingMode);
            Send_cmd(eSetCharAttributes);
        }
    }
    else
    {
        if (kFontTypeTTBitmap != pGState->GetFontType())
        {
            //
            // Bitmap font can't be scaled x and y. Need to set 1 : 1.
            //
            Send_real32_xy((real32)real32_IEEE_1_0F, (real32)real32_IEEE_1_0F);
            Send_attr_ubyte(eCharScale);
            Send_cmd(eSetCharScale);
        }
    }

    //
    // Change GState to set current selected font.
    //
    pGState->SetFont(fonttype,
                     pFontName,
                     dwFontHeight,
                     dwFontWidth,
                     dwSymbolSet,
                     dwFontSimulation);


    return S_OK;
}


HRESULT
XLOutput::
SetSourceTxMode(
    TxMode SrcTxMode)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XLGState *pGState = this;
    if (SrcTxMode == pGState->GetSourceTxMode())
    {
        return S_OK;
    }

    if (S_OK == SetTxMode(SrcTxMode) &&
        S_OK == Send_cmd(eSetSourceTxMode))
    {
        pGState->SetSourceTxMode(SrcTxMode);
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT
XLOutput::
SetPaintTxMode(
    TxMode PaintTxMode)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XLGState *pGState = this;
    if (PaintTxMode == pGState->GetPaintTxMode())
    {
        return S_OK;
    }

    if (S_OK == SetTxMode(PaintTxMode) &&
        S_OK == Send_cmd(eSetPatternTxMode))
    {
        pGState->SetPaintTxMode(PaintTxMode);
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\cmnhdr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cmnhdr.h

Abstract:

    Vector module common header file.

Environment:

        Windows Whistler

Revision History:

    03/23/00 
        Created it.

--*/

#ifndef _CMNHDR_H_
#define _CMNHDR_H_

#ifdef __cplusplus

//
// Color ID
//
#define NOT_SOLID_COLOR     0xFFFFFFFF
#define RGB_WHITE           0x00FFFFFF
#define RGB_BLACK           0x00000000

//
// Hatch Pattern ID
// 
#define HS_HORIZONTAL       0       /* ----- */
#define HS_VERTICAL         1       /* ||||| */
#define HS_FDIAGONAL        2       /* \\\\\ */
#define HS_BDIAGONAL        3       /* ///// */
#define HS_CROSS            4       /* +++++ */
#define HS_DIAGCROSS        5       /* xxxxx */

//
// PCL6 real32 values
//
#define real32_IEEE_1_0F    ((FLOATL)0x3F800000)
#define real32_IEEE_10_0F   ((FLOATL)0x41200000)

//
// floating point numbers
//
#if defined(_X86_) && !defined(USERMODE_DRIVER)
#define FLOATL_IEEE_0_005MF ((FLOATL)0xbba3d70a)
#define FLOATL_IEEE_0_005F  ((FLOATL)0x3ba3d70a)
#define FLOATL_IEEE_0_0F    ((FLOATL)0x00000000)
#define FLOATL_IEEE_1_0F    ((FLOATL)0x3F800000)
#else
#define FLOATL_IEEE_0_005MF -0.005f
#define FLOATL_IEEE_0_005F   0.005f
#define FLOATL_IEEE_0_0F     0.0f
#define FLOATL_IEEE_1_0F     1.0f
#endif

//
// GDI FIX
//
#define FIX_SHIFT           4
#define FIX_ONE             (1 << FIX_SHIFT)
#define FIX2sint16(x)       ((WORD)((x) >> FIX_SHIFT))

//
// Misc macros
//
#define SWAPW(a)        (USHORT)(((BYTE)((a) >> 8)) | ((BYTE)(a) << 8))
#define SWAPDW(a)       (ULONG) ((((((a) >> 24) & 0x000000ff)  | \
                                (((((a) >> 8) & 0x0000ff00)   | \
                                ((((a) << 8) & 0x00ff0000)    | \
                                (((a) << 24) & 0xff000000)))))))

#define SIGNATURE( sig )                                                \
public:                                                                 \
    class TSignature {                                                  \
    public:                                                             \
        DWORD _Signature;                                               \
        TSignature() : _Signature( SWAPDW( sig )) { }          \
    };                                                                  \
    TSignature _Signature;                                              \
                                                                        \
    BOOL bSigCheck() const                                              \
    {   return _Signature._Signature == SWAPDW( sig ); }       \
private:

#endif // __cplusplus
#endif // _CMNHDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\glyfcach.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     glfcach.h

Abstract:

    PCL XL glyph cache

Environment:

    Windows Whistler

Revision History:

    11/09/00
      Created it.

--*/
#ifndef _GLFCACH_H_
#define _GLFCACH_H_

typedef struct _GLYPHID
{
    ULONG    ulGlyphID;
    struct _GLYPHID *pPrevGID;
    struct _GLYPHID *pNextGID;
} GLYPHID, *PGLYPHID;

typedef struct _GLYPHTABLE
{
    WORD  wGlyphNum;
    WORD  wFontID;
    DWORD dwAvailableEntries;
    struct _GLYPHID *pFirstGID;
    struct _GLYPHID *pGlyphID;
} GLYPHTABLE, *PGLYPHTABLE;

class XLGlyphCache
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'glyf' )

public:

    //
    // Constructure/Destructure
    //
    XLGlyphCache::
    XLGlyphCache( VOID );

    XLGlyphCache::
    ~XLGlyphCache( VOID );

    //
    // Functions
    //
    HRESULT XLGlyphCache::XLCreateFont(ULONG ulFontID);
    HRESULT XLGlyphCache::AddGlyphID(ULONG ulFontID, ULONG ulGlyphID);
    ULONG   XLGlyphCache::UlSearchFontID( ULONG ulFontID);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    #define INIT_ARRAY 8
    #define ADD_ARRAY  8
    #define INIT_GLYPH_ARRAY 16
    #define ADD_GLYPH_ARRAY  16

    ULONG        m_ulNumberOfFonts;
    ULONG        m_ulNumberOfArray;
    PULONG       m_paulFontID;
    PGLYPHTABLE *m_ppGlyphTable;

    VOID     FreeAll(VOID);
    HRESULT  IncreaseArray(VOID);
    PGLYPHID PSearchGlyph( WORD wSearchRange, BOOL bForward, PGLYPHID pGlyphID);
    HRESULT  IncreaseGlyphArray(ULONG ulFontID);
};

#endif // _GLFCACH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxlcmn.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     pclxlcmn.h

Abstract:

    PCL XL minidriver common utility

Environment:

    Windows Whistler

Revision History:

    08/23/99 
      Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "pclxle.h"
#include "xlgstate.h"


PBYTE
PubGetFontName(
    PDEVOBJ pdevobj,
    ULONG ulFontID)
/*++

Routine Description:


    Create PCL XL base font name for TrueType font.
    We just know ID for the font.

Arguments:

    Font ID.

Return Value:

    Base font name string.

Note:

--*/
{

    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;

    //
    // FaceName initialization "MS PCLXLFont 123"
    // This name has to be in sync with GPD file.
    //

    pxlpdev->ubFontName[16] = NULL;
    pxlpdev->ubFontName[15] = (BYTE)(ulFontID % 10 + '0');
    ulFontID = ulFontID / 10;
    pxlpdev->ubFontName[14] = (BYTE)(ulFontID % 10 + '0');
    ulFontID = ulFontID / 10;
    pxlpdev->ubFontName[13] = (BYTE)(ulFontID % 10 + '0');

    return (PBYTE)&(pxlpdev->ubFontName[0]);
}

ROP4
UlVectMixToRop4(
    IN MIX mix
    )

/*++

Routine Description:

    Convert a MIX parameter to a ROP4 parameter

Arguments:

    mix - Specifies the input MIX parameter

Return Value:

    ROP4 value corresponding to the input MIX value

--*/

{
    static BYTE Rop2ToRop3[] = {

        0xFF,  // R2_WHITE
        0x00,  // R2_BLACK
        0x05,  // R2_NOTMERGEPEN
        0x0A,  // R2_MASKNOTPEN
        0x0F,  // R2_NOTCOPYPEN
        0x50,  // R2_MASKPENNOT
        0x55,  // R2_NOT
        0x5A,  // R2_XORPEN
        0x5F,  // R2_NOTMASKPEN
        0xA0,  // R2_MASKPEN
        0xA5,  // R2_NOTXORPEN
        0xAA,  // R2_NOP
        0xAF,  // R2_MERGENOTPEN
        0xF0,  // R2_COPYPEN
        0xF5,  // R2_MERGEPENNOT
        0xFA,  // R2_MERGEPEN
        0xFF   // R2_WHITE
    };

    return ((ROP4) Rop2ToRop3[(mix >> 8) & 0xf] << 8) | Rop2ToRop3[mix & 0xf];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\gstate.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     gstate.cpp

Abstract:

    PCL XL Graphics state manager

Environment:

    Windows Whistler

Revision History:

    08/23/99 
      Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "pclxle.h"
#include "xlgstate.h"

//
// XLLine
//

//
// Default setting of LineAttrs
//
const LINEATTRS gLineAttrs =
{
    LA_GEOMETRIC,           // fl
    JOIN_ROUND,             // iJoin
    ENDCAP_ROUND,           // iEndCap
    {FLOATL_IEEE_0_0F},     // elWidth
    FLOATL_IEEE_0_0F,       // eMiterLimit
    0,                      // cstyle
    (FLOAT_LONG*) NULL,     // pstyle
    {FLOATL_IEEE_0_0F}      // elStyleState
}; 

const LINEATTRS *pgLineAttrs = &gLineAttrs;

XLLine::
XLLine(
    VOID):
/*++

Routine Description:

    XLLine constructor

Arguments:

Return Value:

Note:

--*/
    m_dwGenFlags(0),
    m_LineAttrs(gLineAttrs)
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    XL_VERBOSE(("XLLine::CTor\n"));
}

XLLine::
~XLLine(
    VOID)
/*++

Routine Description:

    XLLine destructor

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLLine::DTor\n"));

    if ( NULL != m_LineAttrs.pstyle)
    {
        //
        // Free memory
        //
        MemFree(m_LineAttrs.pstyle);
    }
}

#if DBG
VOID
XLLine::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

VOID
XLLine::
ResetLine(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_LineAttrs  = gLineAttrs;
}

DWORD
XLLine::
GetDifferentAttribute(
    IN LINEATTRS *plineattrs)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwRet;

    XL_VERBOSE(("XLLine::GetDifferentAttribute\n"));

    dwRet = XLLINE_NONE;

    if (NULL == plineattrs)
    {
        XL_ERR(("XLLine::GetDifferentAttribute: plineattrs == NULL.\n"));
        return dwRet;
    }

    if ( m_LineAttrs.fl != plineattrs->fl )
        dwRet |= XLLINE_LINETYPE;

    if ( m_LineAttrs.iJoin != plineattrs->iJoin )
        dwRet |= XLLINE_JOIN;

    if ( m_LineAttrs.iEndCap != plineattrs->iEndCap )
        dwRet |= XLLINE_ENDCAP;

    if ( m_LineAttrs.elWidth.l != plineattrs->elWidth.l)
        dwRet |= XLLINE_WIDTH;

    if ( m_LineAttrs.eMiterLimit != plineattrs->eMiterLimit )
        dwRet |= XLLINE_MITERLIMIT;

    if ( m_LineAttrs.cstyle != plineattrs->cstyle ||
             plineattrs->cstyle != 0 &&
             memcmp(m_LineAttrs.pstyle,
                   plineattrs->pstyle,
                   sizeof(FLOAT_LONG) * m_LineAttrs.cstyle) ||
         m_LineAttrs.elStyleState.l != plineattrs->elStyleState.l )
        dwRet |= XLLINE_STYLE;

    XL_VERBOSE(("XLLine::GetDifferentAttribute returns %08x.\n", dwRet));
    return dwRet;
}

HRESULT
XLLine::
SetLineType(
    IN XLLineType LineType )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetLineType\n"));
    m_LineAttrs.fl = (FLONG)LineType;
    return S_OK;
}


HRESULT
XLLine::
SetLineJoin(
    IN XLLineJoin LineJoin )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetLineJoin\n"));
    m_LineAttrs.iJoin = (ULONG)LineJoin;
    return S_OK;
}


HRESULT
XLLine::
SetLineEndCap(
    IN XLLineEndCap LineEndCap )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetLineEndCap\n"));
    m_LineAttrs.iEndCap = (ULONG)LineEndCap;
    return S_OK;
}


HRESULT
XLLine::
SetLineWidth(
    IN FLOAT_LONG elWidth )
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLLine::SetLineWidth\n"));
    m_LineAttrs.elWidth = elWidth;
    return S_OK;
}

HRESULT
XLLine::
SetMiterLimit(
    IN FLOATL eMiterLimit )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetMiterLimit\n"));
    m_LineAttrs.eMiterLimit = eMiterLimit;
    return S_OK;
}


HRESULT
XLLine::
SetLineStyle(
    IN ULONG ulCStyle,
    IN PFLOAT_LONG pStyle,
    IN FLOAT_LONG elStyleState )
/*++
    Routine Description:

    Arguments:

    Return Value:
        None
--*/
{
    XL_VERBOSE(("XLLine::SetLineStyle\n"));

    m_LineAttrs.elStyleState = elStyleState;

    //
    // Error check
    //     Make sure the pointer is valid.
    //     Make sure the the ulCStyle is valid, not ZERO.
    //
    if ( NULL == pStyle || 0 == ulCStyle )
    {
        XL_VERBOSE(("XLLine::SetLineStyle: pStyle == NULL.\n"));
        if (NULL != m_LineAttrs.pstyle)
        {
            MemFree(m_LineAttrs.pstyle);
        }
        m_LineAttrs.pstyle = NULL;
        m_LineAttrs.cstyle = 0;
        return S_OK;
    }

    if ( m_LineAttrs.cstyle > 0 && NULL != m_LineAttrs.pstyle)
    {
        //
        // Free memory and reset.
        //
        MemFree(m_LineAttrs.pstyle);
        m_LineAttrs.pstyle = NULL;
        m_LineAttrs.cstyle = 0;
    }

    m_LineAttrs.pstyle = (PFLOAT_LONG) MemAlloc(ulCStyle * sizeof(FLOAT_LONG));

    if ( NULL == m_LineAttrs.pstyle )
    {
        m_LineAttrs.cstyle = 0;
        XL_ERR(("XLLine::SetLineStyle: Out of memory.\n"));
        return E_OUTOFMEMORY;
    }

    m_LineAttrs.cstyle = ulCStyle;
    memcpy( m_LineAttrs.pstyle, pStyle, ulCStyle * sizeof(FLOAT_LONG));

    return S_OK;
}


//
// Common Brush
//

Brush::
Brush(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    m_Brush.dwSig = BRUSH_SIGNATURE;
    m_Brush.BrushType = kNotInitialized;
    XL_VERBOSE(("Brush:: Ctor\n"));
}

Brush::
~Brush(
    IN VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("Brush:: Dtor\n"));

}

#if DBG
VOID
Brush::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

VOID
Brush::
ResetBrush(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_Brush.BrushType = kNotInitialized;
}

HRESULT
Brush::
CheckCurrentBrush(
    IN BRUSHOBJ *pbo)
/*+++
    Routine Description
        This function checks if the current selected brush is same as
        the one specified in the parameter. 

    Note
        pbo->iSolidColor == NOT_SOLID_COLOR
        {
            iHatch < HS_DDI_MAX
                CMNBRUSH (solid color, hatch pattern)
                    --> kBrushTypeHatch

            iHatch >= HS_DDI_MAX
                CMNBRUSH pattern Brush
                    --> kBrushTypePattern
            
        }

        pbo->iSolidColor != NOT_SOLID_COLOR
        {
            Solid color, solid pattern fill
                --> kBrushTypeSolid
        }

        List of members to check
            pbo->iSolidColor (Solid color ID or NOT_SOLID_COLOR)
            lHatch (HS_XXX or >= HS_MAX_ID)
            dwColor (BRUSHOBJ_ulGetBrushColor(pbo))
            psoPattern bitmap

    Return value
        S_FALSE if the specified brush is different from the current selected.
        S_OK    if the specified brush is same as the curren one.

---*/
{
    HRESULT lrRet;

    XL_VERBOSE(("Brush::CheckCurrentBrush\n"));

    //
    // Error check: parameter
    //
    if (NULL == pbo && m_Brush.BrushType != kNoBrush ||
        m_Brush.BrushType == kNotInitialized          )
    {
        XL_VERBOSE(("Brush::CheckCurrentBrush: Set NULL Brush (pbo==NULL)\n"));
        return S_FALSE;
    }

    lrRet = S_OK;

    switch ( m_Brush.BrushType )
    {
    case kNoBrush:
        if (pbo != NULL)
            lrRet = S_FALSE;
        XL_VERBOSE(("Brush::CheckCurrentBrush: kNoBrush:%d\n", lrRet));
        break;

    case kBrushTypeSolid:
        //
        // 1. Check the brush type.
        // 2. Check solid color.
        //
        if ( pbo->iSolidColor != m_Brush.ulSolidColor ||
             BRUSHOBJ_ulGetBrushColor(pbo) != m_Brush.dwColor )
            lrRet = S_FALSE;
        XL_VERBOSE(("Brush::CheckCurrentBrush: kBrushTyepSolid:%d\n", lrRet));
        break;

    case kBrushTypeHatch:
        //
        // 1. Check the brush type.
        // 2. Check hatch type.
        // 3. Check color.
        //
        if (pbo->iSolidColor == NOT_SOLID_COLOR)
        {
            XLBRUSH *pBrush = (XLBRUSH*)BRUSHOBJ_pvGetRbrush(pbo);
            ULONG ulHatch = 0;

            if (NULL != pBrush)
            {
                if (pBrush->dwSig != XLBRUSH_SIG)
                {
                    lrRet = E_UNEXPECTED;
                    XL_ERR(("Brush::CheckCurrentBrush: BRUSHOBJ_pvGetRbrush returned invalid BRUSH.\n"));
                    break;
                }

                ulHatch = pBrush->dwHatch;

                if ( NOT_SOLID_COLOR != m_Brush.ulSolidColor ||
                     ulHatch != m_Brush.ulHatch ||
                     pbo->iSolidColor != m_Brush.ulSolidColor ||
                     pBrush->dwColor != m_Brush.dwColor )
                {
                    lrRet = S_FALSE;
                }
            }
            else
            {
                //
                // GDI requests to set solid color or NULL brush.
                //
                XL_ERR(("Brush::CheckCurrentBrush: BRUSHOBJ_pvGetRbrush returned NULL.\n"));
                lrRet = S_FALSE;
            }
            XL_VERBOSE(("Brush::CheckCurrentBrush: kBrushTypeHatch:ID(%d),%d\n", ulHatch, lrRet));
        }
        else
            lrRet = S_FALSE;
        break;

    case kBrushTypePattern:
        //
        // 1. Check brush type.
        // 2. Check pattern brush.
        //
        if (pbo->iSolidColor == NOT_SOLID_COLOR)
        {
            XLBRUSH *pBrush = (XLBRUSH*)BRUSHOBJ_pvGetRbrush(pbo);

            if (NULL != pBrush)
            {
                if (pBrush->dwSig != XLBRUSH_SIG)
                {
                    lrRet = E_UNEXPECTED;
                    XL_ERR(("Brush::CheckCurrentBrush: BRUSHOBJ_pvGetRbrush returned invalid BRUSH.\n"));
                    break;
                }

                if ( NOT_SOLID_COLOR == m_Brush.ulSolidColor ||
                     m_Brush.dwPatternBrushID != pBrush->dwPatternID)
                {
                    lrRet = S_FALSE;
                }
            }
            else
            {
                //
                // GDI requests to set solid color or NULL brush.
                //
                lrRet = S_FALSE;
            }
        }
        else
        {
            lrRet = S_FALSE;
        }
        XL_VERBOSE(("Brush::CheckCurrentBrush: kBrushTypePattern:%d\n", lrRet));
        break;
    }

    return lrRet;
}

HRESULT 
Brush::
SetBrush(
    IN CMNBRUSH *pBrush)
/*+++
    Routine Description
        This function sets if the current selected brush is same as
        the one specified in the parameter. 

---*/
{
    HRESULT lrRet;

    XL_VERBOSE(("Brush::SetBrush\n"));

    //
    // Error check: Parameter
    //
    if ( NULL == pBrush )
    {
        XL_ERR(("Brush::SetBrush: pBrush is NULL.\n"));
        return E_UNEXPECTED;
    }

    m_Brush.BrushType    = pBrush->BrushType;
    m_Brush.ulSolidColor = pBrush->ulSolidColor;
    m_Brush.ulHatch      = pBrush->ulHatch;
    m_Brush.dwCEntries   = pBrush->dwCEntries;
    m_Brush.dwColor      = pBrush->dwColor;
    m_Brush.dwPatternBrushID = pBrush->dwPatternBrushID;

    return S_OK;
}

//
// XLClip
//

XLClip::
XLClip(
    VOID):
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
    m_ClipType(kNoClip)
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    m_XLClip.dwSig = CLIP_SIGNATURE;
    XL_VERBOSE(("XLClip:: Ctor\n"));
}

XLClip::
~XLClip(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLClip:: Dtor\n"));
}

#if DBG
VOID
XLClip::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

HRESULT
XLClip::
ClearClip(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLClip::ClearClip\n"));
    m_ClipType = kNoClip;
    return S_OK;
}

HRESULT
XLClip::
CheckClip(
    IN CLIPOBJ *pco)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{

    HRESULT lrRet = S_OK;

    XL_VERBOSE(("XLClip::CheckClip\n"));

    //
    // Error check: Parameter
    //
    if (!pco)
    {
        //
        // It is not necessary to clip if pco is NULL.
        //
        XL_VERBOSE(("XLClip::CheckClip: pco == NULL.\n"));
        if (kNoClip != m_ClipType)
            lrRet = S_FALSE;
    }
    else
    {
        switch (pco->iDComplexity)
        {
        case DC_TRIVIAL:
            if ( m_ClipType != kNoClip )
                lrRet = S_FALSE;
            XL_VERBOSE(("XLClip::Type: DC_TRIVIAL:%d\n", lrRet));
            break;

        case DC_RECT:
            if ( m_ClipType != kClipTypeRectangle ||
                 m_XLClip.rclClipRect.left != pco->rclBounds.left ||
                 m_XLClip.rclClipRect.right != pco->rclBounds.right ||
                 m_XLClip.rclClipRect.top != pco->rclBounds.top ||
                 m_XLClip.rclClipRect.bottom != pco->rclBounds.bottom  )
                lrRet = S_FALSE;
            XL_VERBOSE(("XLClip::Type: DC_RECT:%d\n", lrRet));
            break;

        case DC_COMPLEX:
        #if 0 // It seems like we can't rely on iUniq.
              // Always sends complex clip path.
            if ( m_ClipType != kClipTypeComplex ||
                 m_XLClip.ulUniq == 0           ||
                 pco->iUniq == 0                ||
                 m_XLClip.ulUniq != pco->iUniq   ) 
                lrRet = S_FALSE;
        #else
            lrRet = S_FALSE;
        #endif
            XL_VERBOSE(("XLClip::Type: DC_COMPLEX\n", lrRet));
            break;
        default:
            if ( m_ClipType != kNoClip )
                lrRet = S_FALSE;
            XL_VERBOSE(("XLClip::Type: DC_TRIVIAL:%d\n", lrRet));
        }
    }

    return lrRet;
}

HRESULT
XLClip::
SetClip(
   IN CLIPOBJ *pco)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{

    HRESULT lrRet;

    XL_VERBOSE(("XLClip::SetClip\n"));

    //
    // Error check: Parameter
    //
    if (!pco)
    {
        //
        // It is not necessary to clip if pco is NULL.
        //
        XL_VERBOSE(("XLClip::SetClip: pco == NULL.\n"));
        return E_UNEXPECTED;
    }

    switch (pco->iDComplexity)
    {
    case DC_TRIVIAL:
        XL_VERBOSE(("XLClip::SetClip Type: DC_TRIVIAL\n"));
        m_ClipType = kNoClip;
        lrRet = S_OK;
        break;

    case DC_RECT:
        XL_VERBOSE(("XLClip::SetClip Type: DC_RECT\n"));
        m_ClipType = kClipTypeRectangle;
        m_XLClip.rclClipRect.left   = pco->rclBounds.left;
        m_XLClip.rclClipRect.right  = pco->rclBounds.right;
        m_XLClip.rclClipRect.top    = pco->rclBounds.top;
        m_XLClip.rclClipRect.bottom = pco->rclBounds.bottom;
        lrRet = S_OK;
        break;

    case DC_COMPLEX:
        XL_VERBOSE(("XLClip::SetClip Type: DC_COMPLEX\n"));
        m_ClipType = kClipTypeComplex;
        m_XLClip.ulUniq = pco->iUniq;
        lrRet = S_OK;
        break;

    default:
        XL_ERR(("XLClip::SetClip: Unexpected iDCompelxity\n"));
        m_ClipType = kNoClip;
        lrRet = E_UNEXPECTED;
    }

    return lrRet;
}   




//
// XLRop
// 

XLRop::
XLRop(
    VOID):
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
    m_rop3(0xCC) // SRCCPY
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    XL_VERBOSE(("XLRop:: Ctor\n"));
}

XLRop::
~XLRop(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLRop:: Dtor\n"));
}

#if DBG
VOID
XLRop::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

HRESULT
XLRop::
CheckROP3(
    IN ROP3 rop3 )
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    HRESULT lrRet;

    XL_VERBOSE(("XLRop::CheckROP3\n"));

    if (rop3 != m_rop3)
        lrRet = S_FALSE;
    else
        lrRet = S_OK;

    return lrRet;
}


HRESULT
XLRop::
SetROP3(
    IN ROP3 rop3 )
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLRop::SetROP3\n"));

    m_rop3 = rop3;
    return S_OK;
}

XLFont::
XLFont(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    XL_VERBOSE(("XLFont::CTor\n"));
    ResetFont();
}

XLFont::
~XLFont(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::DTor\n"));
}

#if DBG
VOID 
XLFont::
SetDbgLevel(
DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

VOID
XLFont::
ResetFont(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_XLFontType = kFontNone;
    m_aubFontName[0] = (BYTE) NULL;
    m_dwFontHeight = 0;
    m_dwFontWidth = 0;
    m_dwFontSymbolSet = 0;
    m_dwFontSimulation = 0;
}

HRESULT
XLFont::
CheckCurrentFont(
    FontType XLFontType,
    PBYTE pPCLXLFontName,
    DWORD dwFontHeight,
    DWORD dwFontWidth,
    DWORD dwFontSymbolSet,
    DWORD dwFontSimulation)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    HRESULT lrRet = S_OK;

    XL_VERBOSE(("XLFont::CheckCurrentFont\n"));

    switch (XLFontType)
    {
    case kFontNone:
        lrRet = S_FALSE;
        break;

    case kFontTypeDevice:
        ASSERT((pPCLXLFontName));
        if (m_XLFontType == kFontTypeDevice ||
            strcmp((CHAR*)pPCLXLFontName, (CHAR*)m_aubFontName) ||
            dwFontHeight != m_dwFontHeight ||
            dwFontWidth != m_dwFontWidth ||
            dwFontSymbolSet != m_dwFontSymbolSet)
            lrRet = S_FALSE;
        break;

    case kFontTypeTTBitmap:
        ASSERT((pPCLXLFontName));
        if (m_XLFontType == kFontTypeTTBitmap ||
            strcmp((CHAR*)pPCLXLFontName, (CHAR*)m_aubFontName))
            lrRet = S_FALSE;
        break;

    case kFontTypeTTOutline:
        ASSERT((pPCLXLFontName));
        if (m_XLFontType == kFontTypeTTOutline ||
            strcmp((CHAR*)pPCLXLFontName, (CHAR*)m_aubFontName) ||
            dwFontHeight != m_dwFontHeight ||
            dwFontWidth != m_dwFontWidth ||
            dwFontSymbolSet != m_dwFontSymbolSet ||
            dwFontSimulation != m_dwFontSimulation )
            lrRet = S_FALSE;
        break;
    default:
        XL_ERR(("XLFont::CheckCurrentFont: Invalid font type.\n"));
        lrRet = E_UNEXPECTED;
        break;
    }

    return lrRet;
}


HRESULT
XLFont::
SetFont(
    FontType XLFontType,
    PBYTE pPCLXLFontName,
    DWORD dwFontHeight,
    DWORD dwFontWidth,
    DWORD dwFontSymbolSet,
    DWORD dwFontSimulation)
/*++

Routine Description:

    Set font in GState.

Arguments:

    XLFontType - FontType enum, Font type (Device/TTBitmap/TTOutline)
    pPCLXLFontName - XL font name (base name + attributes)
    dwFontHeight - Font height
    dwFontWidth - Font width
    dwFontSymbolSet - Font's symbol set
    dwFontSimulation - Font attributes (Bold/Italic)

Return Value:

Note:

--*/
{
    HRESULT lrRet;

    XL_VERBOSE(("XLFont::SetFont\n"));

    switch (XLFontType)
    {
    case kFontTypeDevice:
    case kFontTypeTTOutline:
    case kFontTypeTTBitmap:
        ASSERT(pPCLXLFontName);
        m_XLFontType = XLFontType;
        CopyMemory(m_aubFontName, pPCLXLFontName, PCLXL_FONTNAME_SIZE);
        m_aubFontName[PCLXL_FONTNAME_SIZE] = NULL;
        m_dwFontHeight = dwFontHeight;
        m_dwFontWidth = dwFontWidth;
        m_dwFontSymbolSet = dwFontSymbolSet;
        m_dwFontSimulation = dwFontSimulation;
        lrRet = S_OK;
        break;
    default:
        XL_ERR(("XLFont::CheckCurrentFont: Invalid font type.\n"));
        lrRet = E_UNEXPECTED;
        break;
    }

    return lrRet;

}

HRESULT
XLFont::
GetFontName(
    PBYTE paubFontName)
/*++

Routine Description:

    Returns current selected font base name.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontName\n"));

    if (NULL == paubFontName)
    {
        XL_ERR(("GetFontName: Invalid fontname pointer\n"));
        return E_UNEXPECTED;
    }

    //
    // Assumption: paubFontName is an array of 16 + 1 bytes.
    //
    CopyMemory(paubFontName, m_aubFontName, PCLXL_FONTNAME_SIZE);
    paubFontName[PCLXL_FONTNAME_SIZE] = NULL;

    return S_OK;

}

FontType
XLFont::
GetFontType(VOID)
/*++

Routine Description:

    Returns current font's type.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontType\n"));
    return m_XLFontType;
}

DWORD
XLFont::
GetFontHeight(VOID)
/*++

Routine Description:

    Returns current font's height.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontHeight\n"));
    return m_dwFontHeight;
}

DWORD
XLFont::
GetFontWidth(VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontWidth\n"));
    return m_dwFontWidth;
}

DWORD
XLFont::
GetFontSymbolSet(VOID)
/*++

Routine Description:

    Return font symbol set.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontSymbolSet\n"));
    return m_dwFontSymbolSet;
}

DWORD
XLFont::
GetFontSimulation(VOID)
/*++

Routine Description:

    Return current font simulation.

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLFont::GetFontSimulation\n"));
    return m_dwFontSimulation;
}

//
// XLTxMode
//
XLTxMode::
XLTxMode()
   :m_SourceTxMode(eNotSet),
    m_PaintTxMode(eNotSet)
{
#if DBG
    SetDbgLevel(GSTATEDBG);
#endif
    XL_VERBOSE(("XLTxMode::CTor\n"));
}

XLTxMode::
~XLTxMode()
{
    XL_VERBOSE(("XLTxMode::DTor\n"));
}

HRESULT
XLTxMode::
SetSourceTxMode(
    TxMode SrcTxMode)
{
    XL_VERBOSE(("XLTxMode::SetSourceTxMode\n"));
    m_SourceTxMode = SrcTxMode;
    return S_OK;
}

HRESULT
XLTxMode::
SetPaintTxMode(
    TxMode PaintTxMode)
{
    XL_VERBOSE(("XLTxMode::SetPaintTxMode\n"));
    m_PaintTxMode = PaintTxMode;
    return S_OK;
}

TxMode
XLTxMode::
GetSourceTxMode()
{
    XL_VERBOSE(("XLTxMode::GetSourceTxMode\n"));
    return m_SourceTxMode;
}

TxMode
XLTxMode::
GetPaintTxMode()
{
    XL_VERBOSE(("XLTxMode::GetPaintTxMode\n"));
    return m_PaintTxMode;
}

#if DBG
VOID
XLTxMode::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    m_dbglevel = dwLevel;
}
#endif

//
// XLGState
//

VOID
XLGState::
ResetGState(
VOID)
/*++

Routine Description:

Reset Graphics State.

Arguments:

Return Value:

Note:

ROP3 is set to SRCPY(0xCC)

--*/
{
    XLLine *pXLine = this;
    pXLine->ResetLine();

    XLBrush *pXBrush = this;
    pXBrush->ResetBrush();

    XLPen *pXPen = this;
    pXPen->ResetBrush();

    XLClip *pXClip = this;
    pXClip->ClearClip();

    //
    // Set CC (SrcCopy)
    //
    XLRop *pXRop = this;
    pXRop->SetROP3(0xCC);

    XLFont *pXFont = this;
    pXFont->ResetFont();

    XLTxMode *pXLTxMode = this;
    pXLTxMode->SetSourceTxMode(eNotSet);
    pXLTxMode->SetPaintTxMode(eNotSet);

}

#if DBG
VOID
XLGState::
SetAllDbgLevel(
DWORD dwLevel)
/*++

Routine Description:

Set debug level in all classes.

Arguments:

Return Value:

Note:

--*/
{
    XLLine *pXLine = this;
    pXLine->SetDbgLevel(dwLevel);

    XLBrush *pXBrush = this;
    pXBrush->SetDbgLevel(dwLevel);

    XLPen *pXPen = this;
    pXPen->SetDbgLevel(dwLevel);

    XLClip *pXClip = this;
    pXClip->SetDbgLevel(dwLevel);

    XLRop *pXRop = this;
    pXRop->SetDbgLevel(dwLevel);

    XLFont *pXFont = this;
    pXFont->SetDbgLevel(dwLevel);

    XLTxMode *pTxMode = this;
    pTxMode->SetDbgLevel(dwLevel);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxlcmd.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pclxlcmd.cpp

Abstract:

    PCL-XL command definition

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created it.

Note:

    Please refer to PCL XL Feature Reference Protocol Class 2.0

--*/

#include "xlpdev.h"
#include "pclxlcmd.h"

//
// Binary Stream Tag
//

const BYTE PCLXL_NULL  = 0x00;
const BYTE PCLXL_HT    = 0x09;
const BYTE PCLXL_LF    = 0x0a;
const BYTE PCLXL_VT    = 0x0b;
const BYTE PCLXL_FF    = 0x0c;
const BYTE PCLXL_CR    = 0x0d;
const BYTE PCLXL_SP    = 0x20;

const BYTE PCLXL_BeginSession = 0x41;
const BYTE PCLXL_EndSession   = 0x42;
const BYTE PCLXL_BeginPage    = 0x43;
const BYTE PCLXL_EndPage      = 0x44;

const BYTE PCLXL_Comment         = 0x47;
const BYTE PCLXL_OpenDataSource  = 0x48;
const BYTE PCLXL_CloseDataSource = 0x49;

const BYTE PCLXL_BeginFontHeader = 0x4f;
const BYTE PCLXL_ReadFontHeader  = 0x50;
const BYTE PCLXL_EndFontHeader   = 0x51;
const BYTE PCLXL_BeginChar       = 0x52;
const BYTE PCLXL_ReadChar        = 0x53;
const BYTE PCLXL_EndChar         = 0x54;
const BYTE PCLXL_RemoveFont      = 0x55;

const BYTE PCLXL_BeginStream = 0x5b;
const BYTE PCLXL_ReadStream  = 0x5c;
const BYTE PCLXL_EndStream   = 0x5d;
const BYTE PCLXL_ExecStream  = 0x5e;


const BYTE PCLXL_PopGS  = 0x60;
const BYTE PCLXL_PushGS = 0x61;

const BYTE PCLXL_SetClipReplace    = 0x62;
const BYTE PCLXL_SetBrushSource    = 0x63;
const BYTE PCLXL_SetCharAngle      = 0x64;
const BYTE PCLXL_SetCharScale      = 0x65;
const BYTE PCLXL_SetCharShear      = 0x66;
const BYTE PCLXL_SetClipIntersect  = 0x67;
const BYTE PCLXL_SetClipRectangle  = 0x68;
const BYTE PCLXL_SetClipToPage     = 0x69;
const BYTE PCLXL_SetColorSpace     = 0x6a;
const BYTE PCLXL_SetCursor         = 0x6b;
const BYTE PCLXL_SetCursorRel      = 0x6c;
const BYTE PCLXL_SetHalftoneMethod = 0x6d;
const BYTE PCLXL_SetFillMode       = 0x6e;
const BYTE PCLXL_SetFont           = 0x6f;

const BYTE PCLXL_SetLineDash       = 0x70;
const BYTE PCLXL_SetLineCap        = 0x71;
const BYTE PCLXL_SetLineJoin       = 0x72;
const BYTE PCLXL_SetMiterLimit     = 0x73;
const BYTE PCLXL_SetPageDefaultCTM = 0x74;
const BYTE PCLXL_SetPageOrigin     = 0x75;
const BYTE PCLXL_SetPageRotation   = 0x76;
const BYTE PCLXL_SetPageScale      = 0x77;
const BYTE PCLXL_SetPatternTxMode  = 0x78;
const BYTE PCLXL_SetPenSource      = 0x79;
const BYTE PCLXL_SetPenWidth       = 0x7a;
const BYTE PCLXL_SetROP            = 0x7b;
const BYTE PCLXL_SetSourceTxMode   = 0x7c;
const BYTE PCLXL_SetCharBoldValue  = 0x7d;

const BYTE PCLXL_SetClipMode       = 0x7f;
const BYTE PCLXL_SetPathToClip     = 0x80;
const BYTE PCLXL_SetCharSubMode    = 0x81;

const BYTE PCLXL_CloseSubPath      = 0x84;
const BYTE PCLXL_NewPath           = 0x85;
const BYTE PCLXL_PaintPath         = 0x86;

const BYTE PCLXL_ArcPath           = 0x91;

const BYTE PCLXL_BezierPath        = 0x93;

const BYTE PCLXL_BezierRelPath     = 0x95;
const BYTE PCLXL_Chord             = 0x96;
const BYTE PCLXL_ChordPath         = 0x97;
const BYTE PCLXL_Ellipse           = 0x98;
const BYTE PCLXL_EllipsePath       = 0x99;

const BYTE PCLXL_LinePath          = 0x9b;

const BYTE PCLXL_LineRelPath       = 0x9d;
const BYTE PCLXL_Pie               = 0x9e;
const BYTE PCLXL_PiePath           = 0x9f;

const BYTE PCLXL_Rectangle         = 0xa0;
const BYTE PCLXL_RectanglePath     = 0xa1;
const BYTE PCLXL_RoundRectangle    = 0xa2;
const BYTE PCLXL_RoundRectanglePath= 0xa3;

const BYTE PCLXL_Text     = 0xa8;
const BYTE PCLXL_TextPath = 0xa9;

const BYTE PCLXL_BeginImage       = 0xb0;
const BYTE PCLXL_ReadImage        = 0xb1;
const BYTE PCLXL_EndImage         = 0xb2;
const BYTE PCLXL_BeginRestPattern = 0xb3;
const BYTE PCLXL_ReadRastPattern  = 0xb4;
const BYTE PCLXL_EndRastPattern   = 0xb5;
const BYTE PCLXL_BeginScan        = 0xb6;

const BYTE PCLXL_EndScan     = 0xb8;
const BYTE PCLXL_ScanLineRel = 0xb9;

const BYTE PCLXL_ubyte  = 0xc0;
const BYTE PCLXL_uint16 = 0xc1;
const BYTE PCLXL_uint32 = 0xc2;
const BYTE PCLXL_sint16 = 0xc3;
const BYTE PCLXL_sint32 = 0xc4;
const BYTE PCLXL_real32 = 0xc5;

const BYTE PCLXL_ubyte_array  = 0xc8;
const BYTE PCLXL_uint16_array = 0xc9;
const BYTE PCLXL_uint32_array = 0xca;
const BYTE PCLXL_sint16_array = 0xcb;
const BYTE PCLXL_sint32_array = 0xcc;
const BYTE PCLXL_real32_array = 0xcd;

const BYTE PCLXL_ubyte_xy  = 0xd0;
const BYTE PCLXL_uint16_xy = 0xd1;
const BYTE PCLXL_uint32_xy = 0xd2;
const BYTE PCLXL_sint16_xy = 0xd3;
const BYTE PCLXL_sint32_xy = 0xd4;
const BYTE PCLXL_real32_xy = 0xd5;

const BYTE PCLXL_ubyte_box = 0xe0;
const BYTE PCLXL_uint16_box = 0xe1;
const BYTE PCLXL_uint32_box = 0xe2;
const BYTE PCLXL_sint16_box = 0xe3;
const BYTE PCLXL_sint32_box = 0xe4;
const BYTE PCLXL_real32_box = 0xe5;

const BYTE PCLXL_attr_ubyte  = 0xf8;
const BYTE PCLXL_attr_uint16 = 0xf9;

const BYTE PCLXL_dataLength = 0xfa;

const BYTE PCLXL_dataLengthByte = 0xfb;


//
// Attribute tag
//

const BYTE PCLXL_PaletteDepth =      0x02;
const BYTE PCLXL_ColorSpace =        0x03;
const BYTE PCLXL_NullBrush =         0x04;
const BYTE PCLXL_NullPen =           0x05;
const BYTE PCLXL_PaleteData =        0x06;

const BYTE PCLXL_PatternSelectID =   0x08;
const BYTE PCLXL_GrayLevel =         0x09;

const BYTE PCLXL_RGBColor =          0x0b;
const BYTE PCLXL_PatternOrigin =     0x0c;
const BYTE PCLXL_NewDestinationSize =0x0d;

const BYTE PCLXL_ColorimetricColorSpace = 0x11;

const BYTE PCLXL_DeviceMatrix =        0x21;
const BYTE PCLXL_DitherMatrixDataType =0x22;
const BYTE PCLXL_DitherOrigin =        0x23;
const BYTE PCLXL_MediaDestination =    0x24;
const BYTE PCLXL_MediaSize =           0x25;
const BYTE PCLXL_MediaSource =         0x26;
const BYTE PCLXL_MediaType =           0x27;
const BYTE PCLXL_Orientation =         0x28;
const BYTE PCLXL_PageAngle =           0x29;
const BYTE PCLXL_PageOrigin =          0x2a;
const BYTE PCLXL_PageScale =           0x2b;
const BYTE PCLXL_ROP3 =                0x2c;
const BYTE PCLXL_TxMode =              0x2d;

const BYTE PCLXL_CustomMediaSize =     0x2f;

const BYTE PCLXL_CustomMediaSizeUnits =0x30;
const BYTE PCLXL_PageCopies =          0x31;
const BYTE PCLXL_DitherMatrixSize =    0x32;
const BYTE PCLXL_DithermatrixDepth =   0x33;
const BYTE PCLXL_SimplexPageMode =     0x34;
const BYTE PCLXL_DuplexPageMode =      0x35;
const BYTE PCLXL_DuplexPageSide =      0x36;

const BYTE PCLXL_ArcDirection =    0x41;
const BYTE PCLXL_BoundingBox =     0x42;
const BYTE PCLXL_DashOffset =      0x43;
const BYTE PCLXL_EllipseDimension =0x44;
const BYTE PCLXL_EndPoint =        0x45;
const BYTE PCLXL_FillMode =        0x46;
const BYTE PCLXL_LineCap      =    0x47;
const BYTE PCLXL_LineJoin       =  0x48;
const BYTE PCLXL_MiterLength =     0x49;
const BYTE PCLXL_PenDashStyle =    0x4a;
const BYTE PCLXL_PenWidth =        0x4b;
const BYTE PCLXL_Point =           0x4c;
const BYTE PCLXL_NumberOfPoints =  0x4d;
const BYTE PCLXL_SolidLine =       0x4e;
const BYTE PCLXL_StartPoint =      0x4f;

const BYTE PCLXL_PointType =       0x50;
const BYTE PCLXL_ControlPoint1 =   0x51;
const BYTE PCLXL_ControlPoint2 =   0x52;
const BYTE PCLXL_ClipRegion =      0x53;
const BYTE PCLXL_ClipMode =        0x54;

const BYTE PCLXL_ColorDepth =        0x62;
const BYTE PCLXL_BlockHeight =       0x63;
const BYTE PCLXL_ColorMapping =      0x64;
const BYTE PCLXL_CompressMode =      0x65;
const BYTE PCLXL_DestinationBox =    0x66;
const BYTE PCLXL_DestinationSize =   0x67;
const BYTE PCLXL_PatternPersistence =0x68;
const BYTE PCLXL_PatternDefineID =   0x69;

const BYTE PCLXL_SourceHeight =      0x6b;
const BYTE PCLXL_SourceWidth =       0x6c;
const BYTE PCLXL_StartLine =         0x6d;
const BYTE PCLXL_XPairType =         0x6e;
const BYTE PCLXL_NumberOfXPairs =    0x6f;

const BYTE PCLXL_XStart =            0x70;
const BYTE PCLXL_XEnd =              0x71;
const BYTE PCLXL_NumberOfScanLines = 0x72;

const BYTE PCLXL_CommentData =     0x81;
const BYTE PCLXL_DataOrg =         0x82;

const BYTE PCLXL_Measure =         0x86;

const BYTE PCLXL_SourceType =      0x88;
const BYTE PCLXL_UnitsPerMeasure = 0x89;

const BYTE PCLXL_StreamName =      0x8b;
const BYTE PCLXL_StreamDataLength =0x8c;

const BYTE PCLXL_ErrorReport =     0x8f;

const BYTE PCLXL_CharAngle =        0xa1;
const BYTE PCLXL_CharCode =         0xa2;
const BYTE PCLXL_CharDataSize =     0xa3;
const BYTE PCLXL_CharScale =        0xa4;
const BYTE PCLXL_CharShear =        0xa5;
const BYTE PCLXL_CharSize =         0xa6;
const BYTE PCLXL_FontHeaderLength = 0xa7;
const BYTE PCLXL_FontName =         0xa8;
const BYTE PCLXL_FontFormat =       0xa9;
const BYTE PCLXL_SymbolSet =        0xaa;
const BYTE PCLXL_TextData =         0xab;
const BYTE PCLXL_CharSubModeArray = 0xac;

const BYTE PCLXL_XSpacingData =     0xaf;

const BYTE PCLXL_YSpacingData =     0xb0;
const BYTE PCLXL_CharBoldValue =    0xb1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\font.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    font.cpp

Abstract:

    PCL XL minidriver plug-in font managing header file

Environment:

    Windows Whistler

Revision History:

    08/23/99 
      Created it.

--*/

tyedef enum {
    eXLNull,
    eXLTrueType,
    eXLDevice,
    eXLSubstitution
} XLFontType;

typedef enum {
    eXLTTNull,
    eXLTTBitmap,
    eXLTTTrueType
} XLTrueTypeFontType;

class XLFont
{
public:
    XLFont:
    XLFont();

    XLFont::
    ~XLFont();

    HRESULT SetFont(FONTOBJ *pfo, STROBJ *pstro);
    HRESULT SetSubstitutionTable(TTSUBST_TABLE* pTable);
    HRESULT SetTTDownloadType(XLTrueTypeFontType TTType);
    HRESULT SetUFM(UNIFM_HDR *pUFM);
    HRESULT SetGTT(UNI_GLYPHSETDATA *pGTT);

    //
    // Functions to emit commands
    //
    HRESULT DownloadFont();
    HRESULT SelectFont();
    HRESULT SendString();

private:
    //
    // DDI parameters
    //
    STROBJ            *m_pstro;
    FONTOBJ           *m_pfo;
    IFIMETRICS        *m_pifi;

    //
    // font info
    //
    XLFontType         m_FontType;
    XLTrueTypeFontType m_TrueTypeType;
    DWORD              m_dwFlags;
    CHAR               m_ubFontName[17];
    FLOATOBJ           m_floHeight;
    FLOATOBJ           m_floWidth;
    UNIFM_HDR         *m_pUFM;
    UNI_GLYPHSETDATA  *m_pGTT;

    TTSUBST_TABLE      m_pTTSubTbl;
};


XLFont::
XLFont()
{
    m_FontType = eXLNull;
    m_TrueTypeType = eXLTTNull;
    m_dwFlags = 0;
}

XLFont::
~XLFont()
{
}

HRESULT
XLFont::
SetFont(
    FONTOBJ *pfo,
    STROBJ  *pstro)
{
    m_pstro = pstro;
    m_pfo   = pfo;
    m_pifi  = FONTOBJ_pifi(pfo);

    if (pfo->flFontType & DEVICEFONT_FONTTYPE)
    {
        m_FontType = eXLDevice;
    }
    else
    {
        // !!Need to consider font substitution.
        m_FontType = eXLTrueType;
    }
    return S_OK;
}

HRESULT
XLFont::
SetTTDownloadType(
    XLTrueTypeFontType TTType)
{
    m_TrueTypeType = TTType;
    return S_OK;
}

HRESULT
XLFont::
SetSubstitutionTable(
    TTSUBST_TABLE* pTable)
{
    m_pTTSUbTbl = pTable;
    return S_OK;
}


HRESULT
XLFont::
SetUFM(
    UNIFM_HDR *pUFM)
{
    m_pUFM = pUFM;
    return S_OK;
}

HRESULT
XLFont::
SetGTT(
    UNI_GLYPHSETDATA *pGTT)
{
    m_pGTT = pGTT;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxlcmd.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     pclxlcmd.h

Abstract:

    PCL XL commands

Environment:

    Windows Whistler

Revision History:

    03/23/00 
      Created it.

--*/

#ifndef _PCLXLCMD_H_
#define _PCLXLCMD_H_

//
// Binary Stream Tag
//

extern const BYTE PCLXL_NULL;
extern const BYTE PCLXL_HT;
extern const BYTE PCLXL_LF;
extern const BYTE PCLXL_VT;
extern const BYTE PCLXL_FF;
extern const BYTE PCLXL_CR;
extern const BYTE PCLXL_SP;

extern const BYTE PCLXL_BeginSession;
extern const BYTE PCLXL_EndSession;
extern const BYTE PCLXL_BeginPage;
extern const BYTE PCLXL_EndPage;

extern const BYTE PCLXL_Comment;
extern const BYTE PCLXL_OpenDataSource;
extern const BYTE PCLXL_CloseDataSource;

extern const BYTE PCLXL_BeginFontHeader;
extern const BYTE PCLXL_ReadFontHeader;
extern const BYTE PCLXL_EndFontHeader;
extern const BYTE PCLXL_BeginChar;
extern const BYTE PCLXL_ReadChar;
extern const BYTE PCLXL_EndChar;
extern const BYTE PCLXL_RemoveFont;

extern const BYTE PCLXL_BeginStream;
extern const BYTE PCLXL_ReadStream;
extern const BYTE PCLXL_EndStream;
extern const BYTE PCLXL_ExecStream;


extern const BYTE PCLXL_PopGS;
extern const BYTE PCLXL_PushGS;

extern const BYTE PCLXL_SetClipReplace;
extern const BYTE PCLXL_SetBrushSource;
extern const BYTE PCLXL_SetCharAngle;
extern const BYTE PCLXL_SetCharScale;
extern const BYTE PCLXL_SetCharShear;
extern const BYTE PCLXL_SetClipIntersect;
extern const BYTE PCLXL_SetClipRectangle;
extern const BYTE PCLXL_SetClipToPage;
extern const BYTE PCLXL_SetColorSpace;
extern const BYTE PCLXL_SetCursor;
extern const BYTE PCLXL_SetCursorRel;
extern const BYTE PCLXL_SetHalftoneMethod;
extern const BYTE PCLXL_SetFillMode;
extern const BYTE PCLXL_SetFont;

extern const BYTE PCLXL_SetLineDash;
extern const BYTE PCLXL_SetLineCap;
extern const BYTE PCLXL_SetLineJoin;
extern const BYTE PCLXL_SetMiterLimit;
extern const BYTE PCLXL_SetPageDefaultCTM;
extern const BYTE PCLXL_SetPageOrigin;
extern const BYTE PCLXL_SetPageRotation;
extern const BYTE PCLXL_SetPageScale;
extern const BYTE PCLXL_SetPatternTxMode;
extern const BYTE PCLXL_SetPenSource;
extern const BYTE PCLXL_SetPenWidth;
extern const BYTE PCLXL_SetROP;
extern const BYTE PCLXL_SetSourceTxMode;
extern const BYTE PCLXL_SetCharBoldValue;

extern const BYTE PCLXL_SetClipMode;
extern const BYTE PCLXL_SetPathToClip;
extern const BYTE PCLXL_SetCharSubMode;

extern const BYTE PCLXL_CloseSubPath;
extern const BYTE PCLXL_NewPath;
extern const BYTE PCLXL_PaintPath;

extern const BYTE PCLXL_ArcPath;

extern const BYTE PCLXL_BezierPath;

extern const BYTE PCLXL_BezierRelPath;
extern const BYTE PCLXL_Chord;
extern const BYTE PCLXL_ChordPath;
extern const BYTE PCLXL_Ellipse;
extern const BYTE PCLXL_EllipsePath;

extern const BYTE PCLXL_LinePath;
extern const BYTE PCLXL_Pie;
extern const BYTE PCLXL_PiePath;
extern const BYTE PCLXL_Rectangle;
extern const BYTE PCLXL_RectanglePath;

extern const BYTE PCLXL_RoundRectangle;
extern const BYTE PCLXL_RoundRectanglePath;

extern const BYTE PCLXL_Text;
extern const BYTE PCLXL_TextPath;

extern const BYTE PCLXL_BeginImage;
extern const BYTE PCLXL_ReadImage;
extern const BYTE PCLXL_EndImage;
extern const BYTE PCLXL_BeginRestPattern;
extern const BYTE PCLXL_ReadRastPattern;
extern const BYTE PCLXL_EndRastPattern;
extern const BYTE PCLXL_BeginScan;

extern const BYTE PCLXL_EndScan;
extern const BYTE PCLXL_ScanLineRel;

extern const BYTE PCLXL_ubyte;
extern const BYTE PCLXL_uint16;
extern const BYTE PCLXL_uint32;
extern const BYTE PCLXL_sint16;
extern const BYTE PCLXL_sint32;
extern const BYTE PCLXL_real32;

extern const BYTE PCLXL_ubyte_array;
extern const BYTE PCLXL_uint16_array;
extern const BYTE PCLXL_uint32_array;
extern const BYTE PCLXL_sint16_array;
extern const BYTE PCLXL_sint32_array;
extern const BYTE PCLXL_real32_array;

extern const BYTE PCLXL_ubyte_xy;
extern const BYTE PCLXL_uint16_xy;
extern const BYTE PCLXL_uint32_xy;
extern const BYTE PCLXL_sint16_xy;
extern const BYTE PCLXL_sint32_xy;
extern const BYTE PCLXL_real32_xy;

extern const BYTE PCLXL_ubyte_box;
extern const BYTE PCLXL_uint16_box;
extern const BYTE PCLXL_uint32_box;
extern const BYTE PCLXL_sint16_box;
extern const BYTE PCLXL_sint32_box;
extern const BYTE PCLXL_real32_box;

extern const BYTE PCLXL_attr_ubyte;
extern const BYTE PCLXL_attr_uint16;

extern const BYTE PCLXL_dataLength;

extern const BYTE PCLXL_dataLengthByte;


//
// Attribute tag
//

extern const BYTE PCLXL_PaletteDepth;
extern const BYTE PCLXL_ColorSpace;
extern const BYTE PCLXL_NullBrush;
extern const BYTE PCLXL_NullPen;
extern const BYTE PCLXL_PaleteData;

extern const BYTE PCLXL_PatternSelectID;
extern const BYTE PCLXL_GrayLevel;

extern const BYTE PCLXL_RGBColor;
extern const BYTE PCLXL_PatternOrigin;
extern const BYTE PCLXL_NewDestinationSize;

extern const BYTE PCLXL_ColorimetricColorSpace;

extern const BYTE PCLXL_DeviceMatrix;
extern const BYTE PCLXL_DitherMatrixDataType;
extern const BYTE PCLXL_DitherOrigin;
extern const BYTE PCLXL_MediaDestination;
extern const BYTE PCLXL_MediaSize;
extern const BYTE PCLXL_MediaSource;
extern const BYTE PCLXL_MediaType;
extern const BYTE PCLXL_Orientation;
extern const BYTE PCLXL_PageAngle;
extern const BYTE PCLXL_PageOrigin;
extern const BYTE PCLXL_PageScale;
extern const BYTE PCLXL_ROP3;
extern const BYTE PCLXL_TxMode;

extern const BYTE PCLXL_CustomMediaSize;

extern const BYTE PCLXL_CustomMediaSizeUnits;
extern const BYTE PCLXL_PageCopies;
extern const BYTE PCLXL_DitherMatrixSize;
extern const BYTE PCLXL_DithermatrixDepth;
extern const BYTE PCLXL_SimplexPageMode;
extern const BYTE PCLXL_DuplexPageMode;
extern const BYTE PCLXL_DuplexPageSide;

extern const BYTE PCLXL_ArcDirection;
extern const BYTE PCLXL_BoundingBox;
extern const BYTE PCLXL_DashOffset;
extern const BYTE PCLXL_EllipseDimension;
extern const BYTE PCLXL_EndPoint;
extern const BYTE PCLXL_FillMode;
extern const BYTE PCLXL_LineCap;
extern const BYTE PCLXL_LineJoin;
extern const BYTE PCLXL_MiterLength;
extern const BYTE PCLXL_PenDashStyle;
extern const BYTE PCLXL_PenWidth;
extern const BYTE PCLXL_Point;
extern const BYTE PCLXL_NumberOfPoints;
extern const BYTE PCLXL_SolidLine;
extern const BYTE PCLXL_StartPoint;

extern const BYTE PCLXL_PointType;
extern const BYTE PCLXL_ControlPoint1;
extern const BYTE PCLXL_ControlPoint2;
extern const BYTE PCLXL_ClipRegion;
extern const BYTE PCLXL_ClipMode;

extern const BYTE PCLXL_ColorDepth;
extern const BYTE PCLXL_BlockHeight;
extern const BYTE PCLXL_ColorMapping;
extern const BYTE PCLXL_CompressMode;
extern const BYTE PCLXL_DestinationBox;
extern const BYTE PCLXL_DestinationSize;
extern const BYTE PCLXL_PatternPersistence;
extern const BYTE PCLXL_PatternDefineID;

extern const BYTE PCLXL_SourceHeight;
extern const BYTE PCLXL_SourceWidth;
extern const BYTE PCLXL_StartLine;
extern const BYTE PCLXL_XPairType;
extern const BYTE PCLXL_NumberOfXPairs;

extern const BYTE PCLXL_XStart;
extern const BYTE PCLXL_XEnd;
extern const BYTE PCLXL_NumberOfScanLines;

extern const BYTE PCLXL_CommentData;
extern const BYTE PCLXL_DataOrg;

extern const BYTE PCLXL_Measure;

extern const BYTE PCLXL_SourceType;
extern const BYTE PCLXL_UnitsPerMeasure;

extern const BYTE PCLXL_StreamName;
extern const BYTE PCLXL_StreamDataLength;

extern const BYTE PCLXL_ErrorReport;

extern const BYTE PCLXL_CharAngle;
extern const BYTE PCLXL_CharCode;
extern const BYTE PCLXL_CharDataSize;
extern const BYTE PCLXL_CharScale;
extern const BYTE PCLXL_CharShear;
extern const BYTE PCLXL_CharSize;
extern const BYTE PCLXL_FontHeaderLength;
extern const BYTE PCLXL_FontName;
extern const BYTE PCLXL_FontFormat;
extern const BYTE PCLXL_SymbolSet;
extern const BYTE PCLXL_TextData;
extern const BYTE PCLXL_CharSubModeArray;

extern const BYTE PCLXL_XSpacingData;

extern const BYTE PCLXL_YSpacingData;
extern const BYTE PCLXL_CharBoldValue;

#endif // _PCLXLCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxle.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     pclxle.h

Abstract:

    PCL XL attribute ID enum

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _PCLXLE_H_
#define _PCLXLE_H_

//
// Attribute ID Nuber to Attribute Name Table
//

typedef enum
{
    eCMYColor         =  1,
    ePaletteDepth     =  2,
    eColorSpace       =  3,
    eDDColorSpace     = eColorSpace,
    eNullBrush        =  4,
    eNullPen          =  5,
    ePaletteData      =  6,
    ePaletteIndex     =  7,
    ePatternSelectID  =  8,
    eGrayLevel        =  9,
    eSRGBColor        =  10,
    eRGBColor         =  11,
    ePatternOrigin    =  12,
    eNewDestinationSize=  13,
    ePrimaryArray          =  14,
    ePrimaryDepth          =  15,
    eColorimetricColorSpace=  17,
    eXYChromaticities      =  18,
    eWhitePointReference   =  19,
    eCRGBMinMax            =  20,
    eGammaGain             =  21,
    eCIELabColorSpace      =  22,
    eMinimumL              =  23,
    eMaximumL              =  24,
    eMinimumA              =  25,
    eMaximumA              =  26,
    eMinimumB              =  27,
    eMaximumB              =  28,

    eDeviceMatrix     =  33,
    eDitherMatrixDataType =  34,
    eDitherOrigin     =  35,
    eMediaDest        =  36,
    eMediaSize        =  37,
    eMediaSource      =  38,
    eMediaType        =  39,
    eOrientation      =  40,
    ePageAngle        =  41,
    ePageOrigin       =  42,
    ePageScale        =  43,
    eROP3             =  44,
    eTxMode           =  45,
    eCustomMediaSize  =  47,
    eCustomMediaSizeUnits =  48,
    ePageCopies       =  49,
    eDitherMatrixSize =  50,
    eDitherMatrixDepth=  51,
    eSimplexPageMode  =  52,
    eDuplexPageMode   =  53,
    eDuplexPageSide   =  54,
    eArcDirection     =  65,
    eBoundingBox      =  66,
    eDashOffset       =  67,
    eEllipseDimension =  68,
    eEndPoint         =  69,
    eFillMode         =  70,
    eLineCapStyle     =  71,
    eLineJoinStyle    =  72,
    eMiterLength      =  73,
    eLineDashStyle    =  74,
    ePenWidth         =  75,
    ePoint            =  76,
    eNumberOfPoints   =  77,
    eSolidLine        =  78,
    eStartPoint       =  79,
    ePointType        =  80,
    eControlPoint1    =  81,
    eControlPoint2    =  82,
    eClipRegion       =  83,
    eClipMode         =  84,

    eColorDepthArray  =  97,
    eColorDepth       =  98,
    ePixelDepth       = eColorDepth,
    eBlockHeight      =  99,
    eColorMapping     =  100,
    ePixelEncoding    = eColorMapping,
    eCompressMode     =  101,
    eDestinationBox   =  102,
    eDestinationSize  =  103,
    ePatternPersistence=  104,
    ePatternDefineID  =  105,
    eSourceHeight     =  107,
    eSourceWidth      =  108,
    eStartLine        =  109,
    ePadBytesMultiple =  110,
    eBlockByteLength  =  111,
    eYStart           =  112,
    eXStart           =  113,
    eXEnd             =  114,
    eNumberOfScanLines=  115,

    eCommentData      =  129,
    eDataOrg          =  130,
    eMeasure          =  134,
    eSourceType       =  136,
    eUnitsPerMeasure  =  137,
    eQueryKey         =  138,
    eStreamName       =  139,
    eStreamDataLength =  140,


    eErrorReport      =  143,
    eIOReadTimeOut    =  144,


    eVUExtension      =  145,
    eVUDataLength     =  146,
    eVUAttr1          =  147,
    eVUAttr2          =  148,
    eVUAttr3          =  149,
    eVUAttr4          =  150,
    eVUAttr5          =  151,
    eVUAttr6          =  152,
    eVUAttr7          =  153,
    eVUAttr8          =  154,
    eVUAttr9          =  155,
    eVUAttr10         =  156,
    eVUAttr11         =  157,
    eVUAttr12         =  158,
    eVUTableSize         =  146,
    eVUMediaFinish       =  eVUAttr1,
    eVUMediaSource       =  147,
    eVUMediaType         =  148,
    eVUColorTableID      =  147,
    eVUTypeOfTable       =  148,
    eVUDeviceMatrix      =  147,
    eVUDeviceMatrixByID  =  148,
    eVUColorTreatment    =  147,
    eVUColorTreatmentByID=  148,
    ePassThroughCommand=  158,
    ePassThroughArray  =  159,
    eDiagnostics      =  160,
    eCharAngle        =  161,
    eCharCode         =  162,
    eCharDataSize     =  163,
    eCharScale        =  164,
    eCharShear        =  165,
    eCharSize         =  166,
    eFontHeaderLength =  167,
    eFontName         =  168,
    eFontFormat       =  169,
    eSymbolSet        =  170,
    eTextData         =  171,
    eCharSubModeArray =  172,
    eWritingMode      =  173,
    eBitmapCharScale  =  174,
    eXSpacingData     =  175,
    eYSpacingData     =  176,
    eCharBoldValue    =  177
} Attribute;

//
// Atttribute enum
//
typedef enum
{
    eClockWise = 0,
    eCounterClockWise = 1
} ArcDirection;

typedef enum
{
    eNoSubstitution = 0, 
    eVerticalSubstitution = 1
} CharSubModeArray;

typedef enum
{
    eClipNonZeroWinding = 0, 
    eClipEvenOdd = 1
} ClipMode;

typedef enum
{
    eInterior = 0, 
    eExterior = 1
} ClipRegion;

typedef enum
{
    e1Bit  = 0, 
    e4Bit  = 1, 
    e8Bit  = 2,
    e24Bit = 3
} ColorDepth;

typedef enum
{
    eCRGB = 5 
} ColorimetricColorSpace;

typedef enum
{
    eDirectPixel = 0, 
    eIndexedPixel = 1
} ColorMapping;

typedef enum
{
    eGray = 1, 
    eRGB = 2, 
    eSRGB = 6
} ColorSpace;

typedef enum
{
    eNoCompression = 0, 
    eRLECompression = 1, 
    eJPEGCompression = 2,
    eDeltaRowCompression = 3,
    eInvalidValue = 0xff
} CompressMode;

typedef enum
{
    eBinaryHighByteFirst = 0, 
    eBinaryLowByteFirst = 1
} DataOrg;

typedef enum
{
    eDefault = 0
} DataSource;

typedef enum
{
    eUByte = 0, 
    eSByte = 1, 
    eUint16 = 2, 
    eSint16 = 3
} DataType;

typedef enum
{
    eDeviceBest = 0
} DitherMatrix;

typedef enum
{
    eDuplexHorizontalBinding = 0, 
    eDuplexVerticalBinding = 1
} DuplexPageMode;

typedef enum
{
    eFrontMediaSide = 0, 
    eBackMediaSide = 1
} DuplexPageSide;

typedef enum
{    
    eBackChannel = 1, 
    eErrorPage = 2, 
    eBackChAndErrPage = 3,
    eNWBackChannel = 4,
    eNWErrorPage = 5,
    eNWBackChAndErrPage = 6
} ErrorReport;

typedef enum
{
    eFillNonZeroWinding = 0, 
    eFillEvenOdd = 1
} FillMode;

typedef enum
{
    eButtCap = 0, 
    eRoundCap = 1, 
    eSquareCap = 2, 
    eTriangleCap = 3
} LineCap;

typedef enum
{
    eMiterJoin = 0, 
    eRoundJoin = 1, 
    eBevelJoin = 2, 
    eNoJoin = 3
} LineJoin;

typedef enum
{
    eInch = 0, 
    eMillimeter = 1, 
    eTenthsOfAMillimeter = 2
} Measure;

typedef enum
{
    eLetterPaper = 0, 
    eLegalPaper = 1, 
    eA4Paper = 2, 
    eExecPaper = 3,
    eLedgerPaper = 4,
    eA3Paper = 5,
    eCOM10Envelope = 6,
    eMonarchEnvelope = 7,
    eC5Envelope = 8,
    eDLEnvelope = 9,
    eJB4Paper = 10,
    eJB5Paper = 11,
    eB5Envelope = 12,
    eJPostcard = 13,
    eJDoublePostcard = 14,
    eA5Paper = 15,
    eA6Paper = 16,
    eJB6Paper = 17
} MediaSize;

typedef enum
{
    eDefaultSource = 0, 
    eAutoSelect = 1, 
    eManualFeed = 2, 
    eMultiPurposeTray = 3,
    eUpperCassette = 4,
    eLowerCassette = 5,
    eEnvelopeTray = 6,
    eThirdCassette = 7
} MediaSource;

// typedef enum External Trays

typedef enum
{
    eDefaultDestination = 0, 
    eFaceDownBin = 1, 
    eFaceUpBin = 2, 
    eJobOffsetBin = 3
} MediaDestination;

// typedef enum External Bins 1-251 5-255

typedef enum
{
    ePortraitOrientation = 0, 
    eLandscapeOrientation = 1, 
    eReversePortrait = 2, 
    eReverseLandscape = 3
} Orientation;

typedef enum
{
    eTempPattern = 0, 
    ePagePattern = 1, 
    eSessionPattern = 2
} PatternPersistence;


// BUGBUG!! symbol set enum.
//typedef enum SymbolSet
//{
//};

typedef enum
{
    eSimplexFrontSide = 0
} SimplexPageMode;

typedef enum
{
    eOpaque = 0, 
    eTransparent = 1,
    eNotSet = 2
} TxMode;

typedef enum
{
    eHorizontal = 0, 
    eVertical = 1
} WritingMode;

#endif // _PCLXLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\truetype.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    truetype.cpp

    Abstract:

        TrueType font handlig object

    Environment:

        Windows Whistler

    Revision History:

        10/04/99     
            Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "xltext.h"
#include "xltt.h"

//
// Function to  retrieve True Type font information from the True Type file
// 
// Need to parse through and pick up the tables needed for the PCL spec. There
// are 8 tables of which 5 are required and three are optional. Tables are
// sorted in alphabetical order.   The PCL tables needed are:
// cvt -  optional
// fpgm - optional
// gdir - required (Empty table. See truetype.h)
// head - required
// hhea - required
// vhea - required (For vertical fonts)
// hmtx - required
// maxp - required
// prep - optional
//
// loca - required for glyph data
//
// The optional tables are used in hinted fonts.
//

XLTrueType::
XLTrueType(
    VOID):
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
    m_pfo(NULL),
    m_pTTFile(NULL),
    m_pTTHeader(NULL),
    m_pTTDirHead(NULL),
    m_usNumTables(0),
    m_ulFileSize(0),
    m_dwFlags(0),
    m_dwNumTag(0),
    m_dwNumGlyph(0)
{
#if DBG
    SetDbgLevel(TRUETYPEDBG);
#endif
    XL_VERBOSE(("XLTrueType::CTor. "));
    XL_VERBOSE(("m_pTTFile=0x%x. ", m_pTTFile));
    XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));
}

XLTrueType::
~XLTrueType(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::DTor.\n"));
}

HRESULT
XLTrueType::
OpenTTFile(
    FONTOBJ* pfo)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::OpenTTFile entry.(pfo=%x) ", pfo));
    XL_VERBOSE(("m_pTTFile=0x%x. ", m_pTTFile));
    XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));
    HRESULT hResult = S_FALSE;

    //
    // Make sure that pfo is no NULL.
    //
    if (NULL != pfo)
    {
        //
        // Call engine function if the pointer to TrueType font is NULL.
        //
        if (NULL == m_pTTFile)
        {
            XL_VERBOSE(("XLTrueType:Calls FONTOBJ_pvTrueTypeFontFile.\n"));
            if (m_pTTFile = FONTOBJ_pvTrueTypeFontFile(pfo, &m_ulFileSize))
            {
                XL_VERBOSE(("XLTrueType:GDI returns m_pTTFile=0x%x.\n", m_pTTFile));
                XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));
                m_pfo = pfo;
                m_dwFlags = 0;

                //
                // Check if this font is TTC.
                //
                if ((DWORD)TTTag_ttcf == *(PDWORD)m_pTTFile)
                {
                    XL_VERBOSE(("XLTrueType::OpenTTFile: TTC file.\n"));
                    m_dwFlags |= XLTT_TTC;
                }

                IFIMETRICS *pIFI = FONTOBJ_pifi(pfo);
                if (NULL != pIFI)
                {
                    if ('@' == *((PBYTE)pIFI + pIFI->dpwszFamilyName))
                    {
                        m_dwFlags |= XLTT_VERTICAL_FONT; 
                        XL_VERBOSE(("XLTrueType::OpenTTFile: Vertical Font.\n"));
                    }
                }

                if (S_OK != ParseTTDir())
                {
                    XL_ERR(("XLTrueType::OpenTTFile TrueType font parsing failed.\n"));
                    //
                    // Reset pointers
                    //
                    m_pTTFile = NULL;
                    m_pfo = NULL;
                    hResult = S_FALSE;
                }
                else
                {
                    hResult = S_OK;
                }
            }
            else
            {
                XL_ERR(("XLTrueType::OpenTTFile FONTOBJ_pvTrueTypeFontFile failed.\n"));
                hResult = S_FALSE;
            }
        }
        else
            hResult = S_OK;
    }
#if DBG
    else
        XL_ERR(("XLTrueType::OpenTTFile pfo is NULL.\n"));
#endif


    return hResult;
}

HRESULT
XLTrueType::
CloseTTFile(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::CloseTTFile entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x. ", m_pTTFile));
    XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));

    m_pfo         = NULL;
    m_pTTFile     = NULL;
    m_pTTHeader   = NULL;
    m_pTTDirHead  = NULL;
    m_usNumTables = 0;
    m_ulFileSize  = 0;
    m_dwFlags     = 0;
    m_dwNumTag    = 0;
    m_dwNumGlyph  = 0;

    return S_OK;
}

HRESULT
XLTrueType::
SameFont(
    FONTOBJ* pfo)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::SameFont entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x. ", m_pTTFile));
    XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));

    //
    // iTTUniq  from MSDN
    //
    // Specifies the associated TrueType file. Two separate point size
    // realizations of a TrueType font face will have FONTOBJ structures
    // that share the same iTTUniq value, but will have different iUniq values.
    // Only TrueType font types can have a nonzero iTTUniq member.
    // For more information see flFontType. 
    //
    // We compare only iTTUniq. IUniq will have different values for separate
    // point size realizations.
    //
    if ( !(pfo->flFontType & TRUETYPE_FONTTYPE) ||
         m_pfo == NULL                          ||
         pfo->iTTUniq != m_pfo->iTTUniq          )
    {
        return S_FALSE;
    }

    return S_OK;
}


HRESULT
XLTrueType::
GetHeader(
    PTTHEADER *ppHeader)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT hResult;

    XL_VERBOSE(("XLTrueType::GetHeader.\n"));

    //
    // Error check
    //
    if (NULL == m_pTTFile)
    {
        XL_ERR(("XLTrueType::GetHeader m_pTTFile is NULL.\n"));
        return E_UNEXPECTED;
    }

    //
    // Incomming parameter validation
    //
    if (NULL == ppHeader)
    {
        XL_ERR(("XLTrueType::GetHeader ppHeader is invalid.\n"));
        return E_UNEXPECTED;
    }

    if (m_pTTHeader)
    {
        *ppHeader = m_pTTHeader;
        hResult = S_OK;
    }
    else
    {
        *ppHeader = NULL;
        hResult = S_FALSE;
    }

    return hResult;
}

DWORD
XLTrueType::
GetSizeOfTable(
    TTTag tag)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetSizeOfTable entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x.\n", m_pTTFile));

    //
    // Error check
    //
    if (NULL == m_pTTFile)
    {
        XL_ERR(("XLTrueType::GetSizeOfTable m_pTTFile is NULL.\n"));
        return 0;
    }

    DWORD dwID = TagID_MAX;
    if (S_OK == TagAndID(&dwID, &tag))
        return SWAPDW(m_pTTDir[dwID]->ulLength);
    else
    {
        XL_ERR(("XLTrueType::GetSizeOfTable: Invalid tag.\n"));
        return 0;
    }
}

HRESULT
XLTrueType::
GetTable(
    TTTag  tag,
    PVOID  *ppTable,
    PDWORD pdwSize)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetTable entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x.\n", m_pTTFile));
    XL_VERBOSE(("Tag=%c%c%c%c\n", 0xff &  tag,
                                  0xff & (tag >> 8),
                                  0xff & (tag >> 16),
                                  0xff & (tag >> 24)));

    //
    // Error check
    //
    if (NULL == ppTable || NULL == pdwSize)
    {
        XL_ERR(("XLTrueType::GetTable ppTable is invalid.\n"));
        return E_UNEXPECTED;
    }
    if (NULL == m_pTTFile)
    {
        *ppTable = NULL;
        *pdwSize = 0;
        XL_ERR(("XLTrueType::GetTable m_pTTFile is NULL.\n"));
        return E_UNEXPECTED;
    }

    DWORD dwID = TagID_MAX;
    if (S_OK == TagAndID(&dwID, &tag) &&
        NULL != m_pTTDir[dwID]         )
    {
        *ppTable = (PVOID)((PBYTE)m_pTTFile + SWAPDW(m_pTTDir[dwID]->ulOffset));
        *pdwSize = SWAPDW(m_pTTDir[dwID]->ulLength);
    }
    else
    {
        *ppTable = NULL;
        *pdwSize = 0;
        XL_VERBOSE(("XLTrueType::GetTable Invalid tag.\n"));
    }

    if (*ppTable && *pdwSize)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLTrueType::
GetTableDir(
    TTTag  tag,
    PVOID  *ppTable)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetTableDir entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x.\n", m_pTTFile));
    XL_VERBOSE(("Tag=%c%c%c%c\n", 0xff &  tag,
                                  0xff & (tag >> 8),
                                  0xff & (tag >> 16),
                                  0xff & (tag >> 24)));

    //
    // Error check
    //
    if (NULL == ppTable)
    {
        XL_ERR(("XLTrueType::GetTable ppTable is NULL.\n"));
        return E_UNEXPECTED;
    }
    if (NULL == m_pTTFile)
    {
        *ppTable = NULL;
        XL_ERR(("XLTrueType::GetTable m_pTTFile is NULL.\n"));
        return E_UNEXPECTED;
    }

    DWORD dwID = TagID_MAX;
    if (S_OK == TagAndID(&dwID, &tag))
        *ppTable = m_pTTDir[dwID];
    else
    {
        XL_ERR(("XLTrueType::GetTableDir Invalid tag.\n"));
        *ppTable = NULL;
    }

    if (*ppTable)
        return S_OK;
    else
        return S_FALSE;
}


HRESULT
XLTrueType::
ParseTTDir(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::ParseTTDir entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x.\n", m_pTTFile));

    HRESULT hResult;

    //
    // Already parsed?
    //
    if (m_dwFlags & XLTT_DIR_PARSED)
    {
        XL_VERBOSE(("XLTrueType::ParseTTDir TTFile is already parsed.\n"));
        return S_OK;
    }

    //
    // Error check
    //
    if (NULL == m_pTTFile)
    {
        XL_ERR(("XLTrueType::ParseTTDir m_pTTFile is NULL.\n"));
        return E_UNEXPECTED;
    }

    //
    // Parse Table Directory
    //
    // Get header pointer
    //
    if (m_dwFlags & XLTT_TTC)
    {
        //
        // Get TrueType font header of TTC.
        // Stolen from PostScript driver.
        // A trick to figure out the inde xin a TTC file. Bodin suggested
        // follwoing:
        //
        // From: Bodin Dresevic <bodind@MICROSOFT.com>
        // Date: Fri, 18 Apr 1997 16:00:23 -0700
        // ...
        // If TTC file supports vertical writing (mort or gsub table are
        // present), then you can get to the index in the ttf file within TTC
        // as follows:
        //
        // iTTC = (pfo.iFace - 1) / 2; // pfo.iFace is 1 based, iTTC is zero
        // based.
        //
        // If the font does not support vertical writing (do not know of any
        // ttc's like that, but they could exist in principle) than iTTC is just
        // iTTC = pfo.iFace - 1;
        //
        // In principle, one could have a mixture of faces, some supporting 
        // vertical writing and some not, but I doubt that any such fonts
        // really exist.
        // ...
        //
        ULONG ulTTC =  (ULONG)( (m_pfo->iFace - 1) / 2 );
        ULONG ulDirCount = SWAPDW( ((PTTCHEADER)m_pTTFile)->ulDirCount );

        if (ulTTC >= ulDirCount)
        {
            XL_ERR(("XLTrueType::ParseTTDir Invalid TTC index.\n"));
            CloseTTFile();
            return E_UNEXPECTED;
        }

        //
        // TTC header
        //    dwTTCTag    = 'ttcf'
        //    dwVersion
        //    ulDirCount
        //    dwOffset[0]
        //    dwOffset[1]
        //    ..
        //
        DWORD dwOffset = *(PDWORD)((PBYTE)m_pTTFile +
                                          sizeof(TTCHEADER) +
                                          ulTTC * sizeof(DWORD));
        dwOffset = SWAPDW(dwOffset);
        m_pTTHeader = (PTTHEADER)((PBYTE)m_pTTFile + dwOffset);
    }
    else
    {
        m_pTTHeader = (PTTHEADER)m_pTTFile;
    }

    //
    // Get table directory pointer
    //
    m_pTTDirHead  = (PTTDIR)(m_pTTHeader + 1);
    m_usNumTables = SWAPW(m_pTTHeader->usNumTables);

    //
    // Parse table directory and make sure that necessary tags exist.
    //
    PTTDIR pTTDirTmp = m_pTTDirHead;
    TTTag tag;
    USHORT usI;
    DWORD  dwTagID;
    
    //
    // Initialize m_pTTDir to NULL.
    //
    for (usI = 0; usI < TagID_MAX; usI ++)
    {
        m_pTTDir[usI] = NULL;
    }

    m_dwNumTag = 0;

    //
    // Initialize m_pTTDir
    //
    for (usI = 0; usI < m_usNumTables; usI ++, pTTDirTmp++)
    {
        XL_VERBOSE(("XLTrueType::ParseTTDir Tag=%c%c%c%c\n",
                                              0xff &  pTTDirTmp->ulTag,
                                              0xff & (pTTDirTmp->ulTag >> 8),
                                              0xff & (pTTDirTmp->ulTag >> 16),
                                              0xff & (pTTDirTmp->ulTag >> 24)));
        XL_VERBOSE(("                       CheckSum=0x%x\n", pTTDirTmp->ulCheckSum));
        XL_VERBOSE(("                       Offset=0x%x\n", pTTDirTmp->ulOffset));
        XL_VERBOSE(("                       Length=0x%x\n", pTTDirTmp->ulLength));
        //
        // Get TagID for the tag.
        //
        dwTagID = TagID_MAX;
        tag = (TTTag)pTTDirTmp->ulTag;
        if (S_OK == TagAndID(&dwTagID, &tag))
        {
            //
            // The tag is in our tag table. In TrueType.h, TTTag and TagID;
            //
            m_pTTDir[dwTagID] = pTTDirTmp;
            m_dwNumTag ++;
        }
    }

    //
    // Initialize flags, etc.
    //
    // Get head table's short/long offset flag and the number of glyph.
    //
    DWORD dwSize;
    PHEAD pHead;
    if (S_OK == GetTable(TTTag_head, (PVOID*)&pHead, &dwSize))
    {
        //
        // Don't need to swap, It's a boolean flag.
        //
        if (0 == pHead->indexToLocFormat)
            m_dwFlags |= XLTT_SHORT_OFFSET_TO_LOC;
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::ParseTTDir head table is not found.\n"));
        hResult = E_UNEXPECTED;
    }

    PMAXP pMaxp;
    if (S_OK == hResult &&
        S_OK == GetTable(TTTag_maxp, (PVOID*)&pMaxp, &dwSize))
    {
        m_dwNumGlyph = SWAPW(pMaxp->numGlyphs);
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::ParseTTDir maxp table is not found.\n"));
        hResult = E_UNEXPECTED;
    }

    PHHEA pHhea;
    if (S_OK == hResult &&
        S_OK == GetTable(TTTag_hhea, (PVOID*)&pHhea, &dwSize))
    {
        m_dwNumOfHMetrics = SWAPW(pHhea->usNumberOfHMetrics);
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::ParseTTDir hhea table is not found.\n"));
        hResult = E_UNEXPECTED;
    }

    PVHEA pVhea;
    //
    // Only check if the font is vertical.
    //
    if (m_dwFlags &  XLTT_VERTICAL_FONT)
    {
        if (S_OK == hResult &&
            S_OK == GetTable(TTTag_vhea, (PVOID*)&pVhea, &dwSize))
        {
            m_dwNumOfVMetrics = SWAPW(pVhea->usNumberOfVMetrics);
            hResult = S_OK;
        }
        else
        {
            XL_ERR(("XLTrueType::ParseTTDir vhea table is not found.\n"));
            hResult = E_UNEXPECTED;
        }
    }

    if (S_OK == hResult)
    {
        m_dwFlags |= XLTT_DIR_PARSED;
    }
    else
    {
        CloseTTFile();
        m_dwFlags &= ~XLTT_DIR_PARSED;
    }
    return hResult;
}

HRESULT
XLTrueType::
GetHMTXData(
    HGLYPH hGlyphID,
    PUSHORT pusAdvanceWidth,
    PSHORT  psLeftSideBearing)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT hResult;
    PHMTX pHmtx;
    DWORD dwSize;

    XL_VERBOSE(("XLTrueType::GetHMTXData entry.\n"));

    //
    // Error check
    //
    if (NULL == pusAdvanceWidth || NULL == psLeftSideBearing)
    {
        return E_UNEXPECTED;
    }

    if (hGlyphID >= m_dwNumGlyph)
    {
        return E_UNEXPECTED;
    }

    //
    // http://www.microsoft.com/typography/OTSPEC/hmtx.htm
    //
    if (S_OK == GetTable(TTTag_hmtx, (PVOID*)&pHmtx, &dwSize))
    {
        if (hGlyphID < m_dwNumOfHMetrics)
        {
            *pusAdvanceWidth = SWAPW(pHmtx[hGlyphID].usAdvanceWidth);
            *psLeftSideBearing = SWAPW(pHmtx[hGlyphID].sLeftSideBearing);
        }
        else
        {
            PSHORT pasLeftSideBearing = (PSHORT)(pHmtx+m_dwNumOfHMetrics);

            *pusAdvanceWidth = SWAPW(pHmtx[m_dwNumOfHMetrics - 1].usAdvanceWidth);
            *psLeftSideBearing = SWAPW(pasLeftSideBearing[hGlyphID - m_dwNumOfHMetrics]);
        }
        XL_VERBOSE(("XLTrueType::GetHMTXData AW=%d, LSB=%d.\n",
                                   *pusAdvanceWidth,
                                   *psLeftSideBearing));
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::GetHMTXData failed.\n"));
        hResult = E_UNEXPECTED;
    }

    return hResult;
}

HRESULT
XLTrueType::
GetVMTXData(
    HGLYPH hGlyphID,
    PUSHORT pusAdvanceWidth,
    PSHORT psTopSideBearing,
    PSHORT psLeftSideBearing)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT hResult;
    PVMTX pVmtx;
    DWORD dwSize;

    XL_VERBOSE(("XLTrueType::GetVMTXData entry.\n"));

    //
    // Error check
    //
    if (NULL == pusAdvanceWidth ||
        NULL == psLeftSideBearing ||
        NULL == psTopSideBearing)
    {
        return E_UNEXPECTED;
    }

    if (hGlyphID >= m_dwNumGlyph)
    {
        return E_UNEXPECTED;
    }

    //
    // http://www.microsoft.com/typography/OTSPEC/Vmtx.htm
    //
    if (S_OK == GetHMTXData(hGlyphID, pusAdvanceWidth, psLeftSideBearing) &&
        S_OK == GetTable(TTTag_vmtx, (PVOID*)&pVmtx, &dwSize))
    {
        if (hGlyphID <= m_dwNumOfVMetrics)
        {
            *psTopSideBearing = SWAPW(pVmtx[hGlyphID].sTopSideBearing);
        }
        else
        {
            PSHORT pasTopSideBearing = (PSHORT)(pVmtx+m_dwNumOfVMetrics);

            *psTopSideBearing = SWAPW(pasTopSideBearing[hGlyphID - m_dwNumOfVMetrics]);
        }
        XL_VERBOSE(("XLTrueType::GetVMTXData TSB=%d\n", *psTopSideBearing));
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::ParseTTDir maxp table is not found.\n"));
        hResult = E_UNEXPECTED;
    }

    return hResult;
}
 

HRESULT
XLTrueType::
TagAndID(
    DWORD *pdwID,
    TTTag *ptag)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD dwI;
    HRESULT hResult = S_FALSE;

    const struct {
        TagID tagID;
        TTTag tag;
    } TagIDConv[TagID_MAX] =
    {
        {TagID_cvt , TTTag_cvt },
        {TagID_fpgm, TTTag_fpgm},
        {TagID_gdir, TTTag_gdir}, // Empty table. See truetype.h.
        {TagID_head, TTTag_head},
        {TagID_maxp, TTTag_maxp},
        {TagID_perp, TTTag_perp},

        {TagID_hhea, TTTag_hhea},
        {TagID_hmtx, TTTag_hmtx},
        {TagID_vhea, TTTag_vhea},
        {TagID_vmtx, TTTag_vmtx},

        {TagID_loca, TTTag_loca},
        {TagID_glyf, TTTag_glyf}
    };

    if (NULL != pdwID && NULL != ptag)
    {

        if (*pdwID == TagID_MAX)
        {
            for (dwI = 0; dwI < TagID_MAX; dwI ++)
            {
                if (TagIDConv[dwI].tag ==  *ptag)
                {
                    hResult = S_OK;
                    *pdwID = dwI;
                    break;
                }
            }
        }
        else
        if (*ptag == TTTag_INVALID && *pdwID < TagID_MAX)
        {
            *ptag = TagIDConv[*pdwID].tag;
            hResult = S_OK;
        }
    }
    else
    {
        hResult = E_UNEXPECTED;
    }

    return  hResult;
}

DWORD
XLTrueType::
GetNumOfTag(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetNumOfTag.\n"));
    return m_dwNumTag;
}

HRESULT
XLTrueType::
GetGlyphData(
    HGLYPH hGlyph,
    PBYTE *ppubGlyphData,
    PDWORD pdwGlyphDataSize)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetGlyphData.\n"));
    
    PVOID pLoca, pGlyf;
    HRESULT hResult = S_FALSE;
    DWORD dwTableSize, dwOffset;

    if (NULL == ppubGlyphData || NULL == pdwGlyphDataSize)
    {
        XL_ERR(("XLTrueType::GetGlyphData: invalid params.\n"));
        hResult = E_UNEXPECTED;
    }
    else
    if (S_OK == GetTable( TTTag_loca, &pLoca, &dwTableSize) &&
        S_OK == GetTable( TTTag_glyf, &pGlyf, &dwTableSize)  )
    {
        if (m_dwFlags & XLTT_SHORT_OFFSET_TO_LOC)
        {
            USHORT *pusOffset, usI, usJ;

            pusOffset = (USHORT*) pLoca + hGlyph;
            usI = SWAPW(pusOffset[0]);
            usJ = SWAPW(pusOffset[1]);
            dwOffset = usI;

            *pdwGlyphDataSize = (USHORT) (usJ - usI) << 1;
            *ppubGlyphData = (PBYTE)pGlyf + (dwOffset << 1);
        }
        else
        {
            ULONG *pusOffset, ulI, ulJ;

            pusOffset = (ULONG*) pLoca + hGlyph;
            ulI = SWAPDW(pusOffset[0]);
            ulJ = SWAPDW(pusOffset[1]);
            dwOffset = ulI;

            *pdwGlyphDataSize = (ULONG)(ulJ - ulI);
            *ppubGlyphData = (PBYTE)pGlyf + dwOffset;
        }
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::GetGlyphData: GetTable failed.\n"));
    }
    return hResult;
}

HRESULT
XLTrueType::
GetTypoDescender(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    return S_OK;
}

HRESULT
XLTrueType::
IsTTC(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT lRet;

    if (!(m_dwFlags & XLTT_DIR_PARSED))
        lRet = E_UNEXPECTED;
    else
    if (m_dwFlags &  XLTT_TTC)
        lRet = S_OK;
    else
        lRet = S_FALSE;

    return lRet;
}

HRESULT
XLTrueType::
IsVertical(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT lRet;

    if (!(m_dwFlags & XLTT_DIR_PARSED))
        lRet = E_UNEXPECTED;
    else
    if (m_dwFlags &  XLTT_VERTICAL_FONT)
        lRet = S_OK;
    else
        lRet = S_FALSE;

    return lRet;
}

HRESULT
XLTrueType::
IsDBCSFont(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT lRet;

    if (!(m_dwFlags & XLTT_DIR_PARSED) || NULL == m_pfo)
        lRet = E_UNEXPECTED;
    else
    if (m_pfo->flFontType & FO_DBCS_FONT)
        lRet = S_OK;
    else
        lRet = S_FALSE;

    return lRet;
}

#if DBG
VOID
XLTrueType::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    m_dbglevel = dwLevel;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxlcmn.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     pclxlcmn.h

Abstract:

    PCL XL minidriver common utility function header file

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _PCLXLCMN_H_
#define _PCLXLCMN_H_

#define DATALENGTH_HEADER_SIZE 5
#define READIMAGE_HEADER_SIZE 15

PBYTE
PubGetFontName(
    PDEVOBJ pdevobj,
    ULONG ulFontID);

HRESULT
FlushCachedText(
    PDEVOBJ pdevobj);

HRESULT
RemoveAllFonts(
    PDEVOBJ pdevobj);

ROP4
UlVectMixToRop4(
    IN MIX mix);

HRESULT
GetXForm(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    FLOATOBJ_XFORM* pxform);

HRESULT
GetFONTOBJ(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ  pUFObj,
    FONTOBJ **pFontObj);

HRESULT
GetXYScale(
    FLOATOBJ_XFORM *pxform,
    FLOATOBJ *pfoXScale,
    FLOATOBJ *pfoYScale);

HRESULT
IsXYSame(
    FLOATOBJ_XFORM *pxform);

inline
VOID
DetermineOutputFormat(
    XLATEOBJ    *pxlo,
    ColorDepth   DeviceColorDepth,
    INT          iBitmapFormat,
    OutputFormat *pOutputF,
    ULONG        *pulOutputBPP);

extern "C" BOOL
BSaveFont(
    PDEVOBJ pdevobj);
#endif // _PCLXLCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlbmpcvt.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlbmpcvt.h

Abstract:

    Bitmap conversion header

Environment:

    Windows Whistler

Revision History:

    03/23/00
        Created it.

--*/

#ifndef _XLBMPCVT_H_
#define _XLBMPCVT_H_

//
// Macros for getting color components
//

#define RED(x)            ((BYTE) ((x)      ))
#define GREEN(x)          ((BYTE) ((x) >>  8))
#define BLUE(x)           ((BYTE) ((x) >> 16))

#define CYAN(x)           ((BYTE) ((x)      ))
#define MAGENTA(x)        ((BYTE) ((x) >>  8))
#define YELLOW(x)         ((BYTE) ((x) >> 16))
#define BLACK(x)          ((BYTE) ((x) >> 24))

//
// Macro to convert from RGB to grayscale
//
// The formula we're using is: grayscale = 0.3*R + 0.59*G + 0.11*B.
// Scale it up with 256 to avoid a division operation.
//
//
#define RGB2GRAY(r, g, b) ((BYTE) (((r)*77 + (g)*151 + (b)*28) >> 8))


#define GET_COLOR_TABLE(pxlo) \
        (pxlo ?\
            (((pxlo)->flXlate & XO_TABLE) ?\
              ((pxlo)->pulXlate ? (pxlo)->pulXlate : XLATEOBJ_piVector(pxlo)) :\
            NULL) :\
        NULL)

inline
BYTE DWORD2GRAY(
    DWORD dwColor)
/*++

Routine Description:

    Converts RGB 24 bit color to 8 bit gray scale.

Arguments:

    RGB 24 bit color

Return Value:

    8 bit gray scale.

Note:

--*/
{
    return RGB2GRAY(RED(dwColor), GREEN(dwColor), BLUE(dwColor));
}

typedef enum {
    e1bpp  = BMF_1BPP,
    e4bpp  = BMF_4BPP,
    e8bpp  = BMF_8BPP,
    e16bpp = BMF_16BPP,
    e24bpp = BMF_24BPP,
    e32bpp = BMF_32BPP
} BPP;

typedef enum {
    eOutputGray,
    eOutputPal,
    eOutputRGB,
    eOutputCMYK
} OutputFormat;

typedef enum {
    eOddPixelZero,
    eOddPixelOne
} OddPixel;

typedef enum {
    eBitZero,
    eBitOne,
    eBitTwo,
    eBitThree,
    eBitFour,
    eBitFive,
    eBitSize,
    eBitSeven
} FirstBit;

typedef BOOL (*PFNDIBCONV)(PBYTE, DWORD);

class BMPConv 
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'cpmb' )

public:

    BMPConv::
    BMPConv( VOID );

    BMPConv::
    ~BMPConv( VOID );

    BOOL
    BSetInputBPP(BPP InputBPP);

    BOOL
    BSetOutputBPP(BPP OutputBPP);

    BOOL
    BSetOutputBMPFormat(OutputFormat BitmapFormat);

    BOOL
    BSetXLATEOBJ(XLATEOBJ *pxlo);

    DWORD
    DwGetDstSize(VOID);

    BOOL
    BSetCompressionType(CompressMode CMode);

    CompressMode
    GetCompressionType(VOID);

    PBYTE
    PubConvertBMP(PBYTE pubSrc, DWORD dwcbSrcSize);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    //
    // Attrbutes
    //

    #define BMPCONV_SET_INPUTBPP        0x00000001
    #define BMPCONV_SET_OUTPUTBPP       0x00000002
    #define BMPCONV_SET_OUTPUTBMPFORMAT 0x00000004
    #define BMPCONV_SET_XLATEOBJ        0x00000008

    #define BMPCONV_2COLOR_24BPP        0x00000010

    #define BMPCONV_CHECKXLATEOBJ       0x00000f00
    #define BMPCONV_XLATE               0x00000100
    #define BMPCONV_BGR                 0x00000200
    #define BMPCONV_32BPP_RGB           0x00000400
    #define BMPCONV_32BPP_BGR           0x00000800

    DWORD m_flags;

    BPP          m_InputBPP;        // Source bitmap bits per pixel
    BPP          m_OutputBPP;       // Destination bitmap bits per pixel
    DWORD        m_dwWidth;
    OutputFormat m_OutputFormat;    // Destination bitmap format
    OddPixel     m_OddPixelStart; // 0 or 1, whether scanline starts on odd-pixel
    FirstBit     m_FirstBit;      // 0 to 7: starting bit of the scanline's first pixel

    XLATEOBJ *m_pxlo;

    CompressMode m_CMode;

    //
    // Destination buffer
    //
    DWORD m_dwOutputBuffSize;
    PBYTE m_pubOutputBuff;

    DWORD m_dwRLEOutputBuffSize;
    DWORD m_dwRLEOutputDataSize;
    PBYTE m_pubRLEOutputBuff;

    DWORD m_dwDRCOutputBuffSize;
    DWORD m_dwDRCPrevOutputBuffSize;
    DWORD m_dwDRCOutputDataSize;
    PBYTE m_pubDRCOutputBuff;
    PBYTE m_pubDRCPrevOutputBuff;

    //
    // Internal functions
    //
    BOOL
    BCopy( PBYTE       pubSrc,
           DWORD       dwSrcPixelNum);

    BOOL
    B4BPPtoCMYK(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    B4BPPtoRGB(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    B4BPPtoGray(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    B8BPPtoGray(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B8BPPtoRGB(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B8BPPtoCMYK(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B16BPPtoGray(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B16BPPtoRGB(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B24BPPtoGray(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B24BPPtoRGB(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B32BPPtoGray(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B32BPPtoRGB(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B32BPPtoCMYK(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    BArbtoGray(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    BArbtoRGB(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

#ifdef WINNT_40
    BOOL
    B24BPPToImageMask(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);
#endif // WINNT_40


    BOOL
    BConversionProc(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    BCompressRLE(VOID);

    BOOL
    BCompressDRC(VOID);

    DWORD
    DwCheckXlateObj(XLATEOBJ*, BPP);

};


BPP
NumToBPP(
    ULONG ulBPP);

ULONG
UlBPPtoNum(
    BPP Bpp);

#endif // _XLBMPCVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\raster.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    xlraster.cpp

Abstract:

    Implementation of PCLXL raster mode

Functions:

    PCLXLSetCursor
    PCLXLSendBitmap
    PCLXLFreeRaster
    PCLXLResetPalette


Environment:

    Windows Whistler

Revision History:

    09/22/00 
     Created it.

--*/

#include "lib.h"
#include "gpd.h"
#include "winres.h"
#include "pdev.h"
#include "common.h"
#include "xlpdev.h"
#include "pclxle.h"
#include "pclxlcmd.h"
#include "xldebug.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "xlbmpcvt.h"
#include "pclxlcmn.h"
#include "xlraster.h"

//
// XLRASTER data structure
// The pointer is stored in pPDev->pVectorPDEV in case of kPCLXL_RASTER.
//
typedef struct _XLRASTER {
    XLOutput *pOutput;
    PBYTE    pubDstBuff;
    DWORD    dwDstBuffSize;
    PBYTE    pubRLEBuff;
    DWORD    dwRLEBuffSize;
    BOOL     bSentPalette;
} XLRASTER, *PXLRASTER;


//
// Local function prototypes
//
extern BOOL BFindWhetherColor(
    IN   PDEV    *pPDev);

//
// Functions
//
extern "C" HRESULT
PCLXLSendBitmap(
    PDEVOBJ pdevobj,
    ULONG   ulInputBPP,
    LONG    lHeight,
    LONG    lcbScanlineWidth,
    INT     iLeft,
    INT     iRight,
    PBYTE   pbData,
    PDWORD  pdwcbOut)
/*++

Routine Description:

    Send bitmap

Arguments:

pdevobj - a pointer to DEVOBJ
ulInputBPP - input bits per pixel
lHeight - height in pixel
lcbScanlineWidth - scanline with in byte
iLeft - left edge of scaline to print
iRight - right edge of scanline to print
pbData - a pointer to bitmap data
pdwcbOut - a pointer to a DWORD buffer to store the size of written data

Return Value:

    S_OK if succeeded. Otherwise S_FALSE or E_UNEXPECTED.

Note:


--*/
{
    LONG  lScanline, lWidth;
    ULONG ulOutputBPP;
    DWORD dwI, dwBufSize, dwLenNormal, dwLenRLE, dwcbLineSize, dwcbBmpSize;
    PDWORD pdwLen;
    PBYTE pubSrc, pBufNormal, pBufRLE, pBuf, pBmpSize;
    ColorMapping CMapping;
    XLOutput *pOutput;
    INT iBitmapFormat;
    OutputFormat OutputF;
    HRESULT hRet;

    //
    // Parameter varidation
    //
    if (NULL == pdevobj || NULL == pdwcbOut)
    {
        ERR(("PCLXLSendBitmap: Invalid parameters.\n"));
        return E_UNEXPECTED;
    }

    PXLRASTER pXLRaster = (PXLRASTER)(((PPDEV)pdevobj)->pVectorPDEV);

    //
    // Allocate XLRASTER
    // Will be freed in RMDisablePDEV.
    //
    if (NULL == pXLRaster)
    {
        pXLRaster = (PXLRASTER)MemAllocZ(sizeof(XLRASTER));
        ((PPDEV)pdevobj)->pVectorPDEV =  (PVOID) pXLRaster;

        if (NULL == pXLRaster)
        {
            ERR(("PCLXLSendBitmap: Memory allocation failed.\n"));
            return E_UNEXPECTED;
        }

        pXLRaster->pOutput = new XLOutput;

        if (NULL == pXLRaster->pOutput)
        {
            ERR(("PCLXLSendBitmap: XLOutput initialization failed.\n"));
            return E_UNEXPECTED;
        }

        pOutput = pXLRaster->pOutput;
        pOutput->SetResolutionForBrush(((PPDEV)pdevobj)->ptGrxRes.x);

        ColorDepth CD;
        if (BFindWhetherColor((PDEV*)pdevobj))
        {
            if (((PDEV*)pdevobj)->pColorModeEx && 
                ((PDEV*)pdevobj)->pColorModeEx->dwPrinterBPP == 24)
            {
                CD = e24Bit;
            }
            else
            {
                CD = e8Bit;
            }
        }
        else
        {
            CD = e8Bit;
        }

        pOutput->SetDeviceColorDepth(CD);
    }
    else
    {
        pOutput = pXLRaster->pOutput;
    }

    //
    // Set source transparent mode
    //
    pOutput->SetPaintTxMode(eOpaque);
    pOutput->SetSourceTxMode(eOpaque);

    //
    // Get Output format and input format
    //
    iBitmapFormat = (INT)NumToBPP(ulInputBPP);
    DetermineOutputFormat(NULL, pOutput->GetDeviceColorDepth(), iBitmapFormat, &OutputF, &ulOutputBPP);

    //
    // DetermineOutputFormat check if pxlo is available. In this raster case,
    // pxlo is always NULL and it needs to use 1bpp output.
    //
    if (iBitmapFormat == e1bpp)
    {
        OutputF = eOutputPal;
        ulOutputBPP = 1;
    }

    //
    // Set CMapping.
    // Send palette for 1BPP halftone image for B&W printers.
    // Palette is sent per page for XL Raster mode.
    //
    if (ulOutputBPP == 1)
    {
        if (!pXLRaster->bSentPalette)
        {
            ColorDepth CDepth = e8Bit;
            
            //
            // Hardcoded black and white palette for XL RASTER.
            //
            DWORD adwColorTable[2] = {0x00ffffff, 0x0};
            pOutput->SetColorSpace(eGray);
            pOutput->SetPaletteDepth(CDepth);
            pOutput->SetPaletteData(CDepth, 2, adwColorTable);
            pOutput->Send_cmd(eSetColorSpace);
            pXLRaster->bSentPalette = TRUE;

        }

        //
        // Set index pixel (palette) for black and white printer
        //
        CMapping = eIndexedPixel;
    }
    else
    {
        //
        // Initialize pixel mapping.
        //
        CMapping = eDirectPixel;
    }

    //
    // Get height, width, and scanline size.
    //
    // The number of bytes in a scaline.
    //
    dwcbLineSize = lcbScanlineWidth;

    //
    // The number of pixel in a scanline
    // lWidth = lcbScanlineWidth / (ulInputBPP / 8);
    //
    lWidth = lcbScanlineWidth * 8 / ulInputBPP;

    //
    // Buffer size
    // The size of scaline has to be DWORD align.
    //
    // height x width + header + endimage
    // width has to be DWORD-aligned.
    //
    dwBufSize = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2) +
                DATALENGTH_HEADER_SIZE + sizeof(PCLXL_EndImage);

    //
    // BeginImage
    //
    pOutput->BeginImage(
                   CMapping,
                   ulOutputBPP,
                   lWidth,
                   lHeight,
                   lWidth,
                   lHeight);

    //
    // Normal and RLE destination bitmap buffer allocation.
    //
    // Check if the normal and RLE destination buffer is available and the size
    // is larger than required size. Otherwise, we can reused the buffer.
    //
    if (NULL == pXLRaster->pubDstBuff ||
        NULL == pXLRaster->pubRLEBuff ||
        pXLRaster->dwDstBuffSize < dwBufSize)
    {
        if (NULL != pXLRaster->pubDstBuff &&
           pXLRaster->dwDstBuffSize < dwBufSize)
        {
            MemFree(pXLRaster->pubDstBuff);
            pXLRaster->pubDstBuff = NULL;
            pXLRaster->dwDstBuffSize = 0;
        }
        if (NULL != pXLRaster->pubRLEBuff &&
           pXLRaster->dwRLEBuffSize < dwBufSize)
        {
            MemFree(pXLRaster->pubRLEBuff);
            pXLRaster->pubRLEBuff = NULL;
            pXLRaster->dwRLEBuffSize = 0;
        }
        if (NULL == (pBufNormal = (PBYTE)MemAllocZ(dwBufSize)))
        {
            ERR(("PCLXLSendBitmap: Memory allocation failed.\n"));
            pOutput->Delete();
            pXLRaster->dwDstBuffSize = 0;
            return E_UNEXPECTED;
        }
        else
        {
            pXLRaster->pubDstBuff = pBufNormal;
            pXLRaster->dwDstBuffSize = dwBufSize;
        }
        if (NULL == (pBufRLE = (PBYTE)MemAllocZ(dwBufSize)))
        {
            ERR(("PCLXLSendBitmap: Memory allocation failed.\n"));
            if (NULL != pBufNormal)
            {
                MemFree(pXLRaster->pubDstBuff);
                pXLRaster->pubDstBuff = NULL;
            }
            pOutput->Delete();
            pXLRaster->dwRLEBuffSize = 0;
            return E_UNEXPECTED;
        }
        else
        {
            pXLRaster->pubRLEBuff = pBufRLE;
            pXLRaster->dwRLEBuffSize = dwBufSize;
        }
    }
    else
    {
        pBufNormal = pXLRaster->pubDstBuff;
        pBufRLE = pXLRaster->pubRLEBuff;
    }

    //
    // Convert src bitmap to dst bitmap
    //
    CompressMode CMode;
    BMPConv BMPC;
    PBYTE pubDst;
    DWORD dwSize;

    //
    // Setup BMPConv
    //
    BMPC.BSetInputBPP((BPP)iBitmapFormat);
    BMPC.BSetOutputBPP(NumToBPP(ulOutputBPP));
    BMPC.BSetOutputBMPFormat(OutputF);

    //
    // Conversion.
    // Take two steps. No compression and RLE compression. At the end, compare
    // the size of buffers and decide which one we take.
    //
    #define NO_COMPRESSION 0
    #define RLE_COMPRESSION 1
    for (dwI = 0; dwI < 2; dwI ++)
    {
        if (NO_COMPRESSION == dwI)
        {
            VERBOSE(("PCLXLSendBitmap(): No-compres\n"));
            pBuf = pBufNormal;
            pdwLen = &dwLenNormal;
            CMode = eNoCompression;
        }
        else
        if (RLE_COMPRESSION == dwI)
        {
            VERBOSE(("PCLXLSendBitmap(): RLE-compres\n"));
            pBuf = pBufRLE;
            pdwLen = &dwLenRLE;
            CMode = eRLECompression;
        }

        lScanline = lHeight;

        hRet = S_OK;

        //
        // Set pubSrc
        //
        pubSrc = pbData;

        //
        // Set dataLength tag
        //
        *pBuf = PCLXL_dataLength;

        //
        // Get the pointer to the buffer where we store the size of data.
        //
        pBmpSize = pBuf + 1;
        pBuf += DATALENGTH_HEADER_SIZE;
        *pdwLen = DATALENGTH_HEADER_SIZE;

        //
        // Set compression flag in BMPConv
        //
        BMPC.BSetCompressionType(CMode);

        dwcbBmpSize = 0;

        //
        // Scaline base conversion
        //
        while (lScanline-- > 0 && dwcbBmpSize + *pdwLen < dwBufSize)
        {
            pubDst = BMPC.PubConvertBMP(pubSrc , dwcbLineSize);
            dwSize = BMPC.DwGetDstSize();
            VERBOSE(("PCLXLSendBitmap[0x%x]: dwDstSize=0x%x\n", lScanline, dwSize));

            if ( dwcbBmpSize +
                 dwSize +
                 DATALENGTH_HEADER_SIZE +
                 sizeof(PCLXL_EndImage) > dwBufSize || NULL == pubDst)
            {
                VERBOSE(("PCLXLSendBitmap: Mode(%d) buffer size is too small.\n", dwI));
                hRet = E_UNEXPECTED;
                break;
            }

            memcpy(pBuf, pubDst, dwSize);
            dwcbBmpSize += dwSize;
            pBuf += dwSize;

            pubSrc += lcbScanlineWidth;
        }

        if (hRet == S_OK && lScanline > 0 || hRet != S_OK)
        {
            hRet = S_FALSE;
            VERBOSE(("ComonRopBlt: Mode(%d) conversion failed.\n", dwI));
        }

        if (hRet == S_OK)
        {
            if (dwI == NO_COMPRESSION)
            {
                //
                // Scanline on PCL-XL has to be DWORD align.
                //
                // count byte of scanline = lWidth * ulOutputBPP / 8
                //
                dwcbBmpSize = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2);
            }

            //
            // Set the size of bitmap
            //
            CopyMemory(pBmpSize, &dwcbBmpSize, sizeof(dwcbBmpSize));
            *pdwLen += dwcbBmpSize;

            //
            // Set endimage command
            //
            *pBuf = PCLXL_EndImage;
            (*pdwLen) ++;
        }
        else
        {
            //
            // Conversion failed!
            //
            *pdwLen = 0;
        }
    }
    #undef NO_COMPRESSION
    #undef RLE_COMPRESSION

    //
    // Compare which mode is smaller, RLE or non-compression.
    // Take smaller one.
    //
    DWORD dwBitmapSize;

    if (dwLenRLE != 0 && dwLenRLE < dwLenNormal)
    {
        VERBOSE(("PCLXLSendBitmap RLE: dwSize=0x%x\n", dwLenRLE));
        pBuf = pBufRLE;
        pdwLen = &dwLenRLE;
        CMode = eRLECompression;
        hRet = S_OK;
    }
    else if (dwLenNormal != 0)
    {
        VERBOSE(("PCLXLSendBitmap Normal: dwSize=0x%x\n", dwLenNormal));
        pBuf = pBufNormal;
        pdwLen = &dwLenNormal;
        CMode = eNoCompression;
        hRet = S_OK;
    }
    else
    {
        pBuf = NULL;
        pdwLen = NULL;
        CMode = eInvalidValue;
        hRet = E_FAIL;
    }

    if (pBuf)
    {
        //
        // ReadImage and send the bitmap.
        //
        pOutput->ReadImage(lHeight, CMode);
        pOutput->Flush(pdevobj);

        CopyMemory(&dwBitmapSize, pBuf + 1, sizeof(DWORD));

        if (dwBitmapSize > 0xff)
        {
            //
            // dataLength
            // size (uin32) (bitmap size)
            // DATA
            // EndImage
            //
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, *pdwLen);
        }
        else
        {
            //
            // dataLength
            // size (byte) (bitmap size)
            // DATA
            // EndImage
            //
            pBuf += 3;
            *pBuf = PCLXL_dataLengthByte;
            *(pBuf + 1) = (BYTE)dwBitmapSize;
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, (*pdwLen) - 3);
        }

        *pdwcbOut = *pdwLen;

    }
    else
    {
        pOutput->Delete();
    }
    return hRet;
}

extern "C" HRESULT
PCLXLSetCursor(
    PDEVOBJ pdevobj,
    ULONG   ulX,
    ULONG   ulY)
/*++

Routine Description:

    Send cursor move command

Arguments:

pdevobj - a pointer to DEVOBJ
ulX - X position
ulY - Y position

Return Value:

    S_OK if succeeded. Otherwise S_FALSE or E_UNEXPECTED.

Note:

--*/
{
    //
    // Parameter varidation
    //
    if (NULL == pdevobj)
    {
        return E_UNEXPECTED;
    }

    PXLRASTER pXLRaster = (PXLRASTER)(((PPDEV)pdevobj)->pVectorPDEV);

    //
    // Allocate XLRASTER
    // Will be freed in RMDisablePDEV.
    //
    if (NULL == pXLRaster)
    {
        pXLRaster = (PXLRASTER)MemAllocZ(sizeof(XLRASTER));
        ((PPDEV)pdevobj)->pVectorPDEV =  (PVOID) pXLRaster;

        if (NULL == pXLRaster)
        {
            return E_UNEXPECTED;
        }

        pXLRaster->pOutput = new XLOutput;

        if (NULL == pXLRaster->pOutput)
        {
            ERR(("PCLXLSendBitmap: XLOutput initialization failed.\n"));
            return E_UNEXPECTED;
        }

        pXLRaster->pOutput->SetResolutionForBrush(((PPDEV)pdevobj)->ptGrxRes.x);

        ColorDepth CD;
        if (BFindWhetherColor((PDEV*)pdevobj))
        {
            if (((PDEV*)pdevobj)->pColorModeEx && 
                ((PDEV*)pdevobj)->pColorModeEx->dwPrinterBPP == 24)
            {
                CD = e24Bit;
            }
            else
            {
                CD = e8Bit;
            }
        }
        else
        {
            CD = e8Bit;
        }
        pXLRaster->pOutput->SetDeviceColorDepth(CD);
    }

    //
    // Send cusor move command
    //
    return pXLRaster->pOutput->SetCursor(ulX, ulY);
}

extern "C" HRESULT
PCLXLFreeRaster(
    PDEVOBJ pdevobj)
/*++

Routine Description:

    Free XLRASTER

Arguments:

pdevobj - a pointer to DEVOBJ

Return Value:

    S_OK if succeeded. Otherwise S_FALSE or E_UNEXPECTED.

Note:

--*/
{
    //
    // Parameter varidation
    //
    if (NULL == pdevobj)
    {
        return E_UNEXPECTED;
    }

    PXLRASTER pXLRaster = (PXLRASTER)(((PPDEV)pdevobj)->pVectorPDEV);

    if (pXLRaster->pubRLEBuff)
    {
        MemFree(pXLRaster->pubRLEBuff);
        pXLRaster->pubRLEBuff = NULL;
    }
    if (pXLRaster->pubDstBuff)
    {
        MemFree(pXLRaster->pubDstBuff);
        pXLRaster->pubDstBuff = NULL;
    }

    delete pXLRaster->pOutput;

    MemFree(pXLRaster);
    ((PPDEV)pdevobj)->pVectorPDEV = NULL;


    return S_OK;
}

extern "C" HRESULT
PCLXLResetPalette(
    PDEVOBJ pdevobj)
/*++

Routine Description:

    Reset palette flag in XLRASTER
    Palette has to be set per page.

Arguments:

pdevobj - a pointer to DEVOBJ

Return Value:

    S_OK if succeeded. Otherwise S_FALSE or E_UNEXPECTED.

Note:

--*/
{
    //
    // Parameter varidation
    //
    if (NULL == pdevobj)
    {
        return E_UNEXPECTED;
    }

    PXLRASTER pXLRaster = (PXLRASTER)(((PPDEV)pdevobj)->pVectorPDEV);

    if (pXLRaster)
    {
        pXLRaster->bSentPalette = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xldebug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     xldebug.h

Abstract:

    PCL XL debug class

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _XLDEBUG_H_
#define  _XLDEBUG_H_

#if DBG

class XLDebug {
public:
    virtual VOID SetDbgLevel(DWORD dwLevel) = 0;

protected:
    DWORD     m_dbglevel;
};

#endif
#endif // _XLDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlddi.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    xlddi.cpp

Abstract:

    Implementation of PCLXL drawing DDI entry points

Functions:

    PCLXLBitBlt
    PCLXLStretchBlt
    PCLXLStretchBltROP
    PCLXLCopyBits
    PCLXLPlgBlt
    PCLXLAlphaBlend
    PCLXLGradientFill
    PCLXLTextOut
    PCLXLStrokePath
    PCLXLFillPath
    PCLXLStrokeAndFillPath
    PCLXLRealizeBrush
    PCLXLStartPage
    PCLXLSendPage
    PCLXLEscape
    PCLXLStartDcc
    PCLXLEndDoc


Environment:

    Windows XP/Windows Server 2003 family.

Revision History:

    08/23/99 
     Created it.

--*/

#include "lib.h"
#include "gpd.h"
#include "winres.h"
#include "pdev.h"
#include "common.h"
#include "xlpdev.h"
#include "pclxle.h"
#include "pclxlcmd.h"
#include "xldebug.h"
#include "xlbmpcvt.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "pclxlcmd.h"
#include "pclxlcmn.h"
#include "xltt.h"

////////////////////////////////////////////////////////////////////////////////
//
// Globals
//
extern const LINEATTRS *pgLineAttrs;

////////////////////////////////////////////////////////////////////////////////
//
// Local function prototypes
//

HRESULT
CommonRopBlt(
   IN PDEVOBJ    pdevobj,
   IN SURFOBJ    *psoSrc,
   IN CLIPOBJ    *pco,
   IN XLATEOBJ   *pxlo,
   IN BRUSHOBJ   *pbo,
   IN RECTL      *prclSrc,
   IN RECTL      *prclDst,
   IN POINTL     *pptlBrush,
   IN ROP4        rop4);

BOOL
BSendReadImageData(
    IN PDEVOBJ pdevobj,
    IN CompressMode CMode,
    IN PBYTE   pBuf,
    IN LONG    lStart,
    IN LONG    lHeight,
    IN DWORD   dwcbSize);

PDWORD
PdwChangeTransparentPalette(
    ULONG  iTransColor,
    PDWORD pdwColorTable,
    DWORD  dwEntries);

HRESULT hrChangePixelColorInScanLine(
    IN      PBYTE pubSrc,
    IN      ULONG ulBPP,
    IN      ULONG ulNumPixels,
    IN      ULONG ulTransColor,
    IN OUT  PBYTE pubChanged,
    IN      ULONG ulNumBytes);

extern "C" BOOL
CreateMaskSurface(
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMsk,
    ULONG       iTransColor);

extern "C" SURFOBJ *
CreateBitmapSURFOBJ(
    PDEV    *pPDev,
    HBITMAP *phBmp,
    LONG    cxSize,
    LONG    cySize,
    DWORD   Format);

////////////////////////////////////////////////////////////////////////////////
//
// Drawing DDI entries
//

extern "C" BOOL APIENTRY
PCLXLBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4)
/*++

Routine Description:

    Implementation of DDI entry point DrvBitBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoTrg - Describes the target surface
    psoSrc - Describes the source surface
    psoMask - Describes the mask for rop4
    pco - Limits the area to be modified
    pxlo - Specifies how color indices are translated between the source
           and target surfaces
    prclTrg - Defines the area to be modified
    pptlSrc - Defines the upper left corner of the source rectangle
    pptlMask - Defines which pixel in the mask corresponds
               to the upper left corner of the source rectangle
    pbo - Defines the pattern for bitblt
    pptlBrush - Defines the origin of the brush in the Dstination surface
    rop4 - ROP code that defines how the mask, pattern, source, and
           Dstination pixels are combined to write to the Dstination surface

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoTrg->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLBitBlt() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    {
        RECTL rclSrc;

        //
        // create prclSrc (source rectangle)
        //

        if (pptlSrc)
        {
            rclSrc.left   = pptlSrc->x;
            rclSrc.top    = pptlSrc->y;
            rclSrc.right  = pptlSrc->x + RECT_WIDTH(prclTrg);
            rclSrc.bottom = pptlSrc->y + RECT_HEIGHT(prclTrg);
        }
        else
        {
            rclSrc.left   = 0;
            rclSrc.top    = 0;
            rclSrc.right  = RECT_WIDTH(prclTrg);
            rclSrc.bottom = RECT_HEIGHT(prclTrg);
        }

        if (S_OK == CommonRopBlt(pdevobj, psoSrc, pco, pxlo, pbo, &rclSrc, prclTrg, pptlBrush, rop4))
            return TRUE;
        else
            return FALSE;
    }

}


extern "C" BOOL APIENTRY
PCLXLStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode)
/*++

Routine Description:

    Implementation of DDI entry point DrvStretchBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Defines the surface on which to draw
    psoSrc - Defines the source for blt operation
    psoMask - Defines a surface that provides a mask for the source
    pco - Limits the area to be modified on the Dstination
    pxlo - Specifies how color dwIndexes are to be translated
           between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    pptlHTOrg - Specifies the origin of the halftone brush
    prclDst - Defines the area to be modified on the Dstination surface
    prclSrc - Defines the area to be copied from the source surface
    pptlMask - Specifies which pixel in the given mask corresponds to
               the upper left pixel in the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLStretchBlt() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    if (S_OK == CommonRopBlt(pdevobj, psoSrc, pco, pxlo, NULL, prclSrc, prclDst, NULL, 0xCC))
        return TRUE;
    else
        return FALSE;

}


extern "C" BOOL APIENTRY
PCLXLStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4)
/*++

Routine Description:

    Implementation of DDI entry point DrvStretchBltROP.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Specifies the target surface
    psoSrc - Specifies the source surface
    psoMask - Specifies the mask surface
    pco - Limits the area to be modified
    pxlo - Specifies how color indices are translated
           between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    prclHTOrg - Specifies the halftone origin
    prclDst - Area to be modified on the destination surface
    prclSrc - Rectangle area on the source surface
    prclMask - Rectangle area on the mask surface
    pptlMask - Defines which pixel in the mask corresponds to
               the upper left corner of the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels
    pbo - Defines the pattern for bitblt
    rop4 - ROP code that defines how the mask, pattern, source, and
           destination pixels are combined on the destination surface

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLStretchBltROP() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    if (S_OK == CommonRopBlt(pdevobj, psoSrc, pco, pxlo, pbo, prclSrc, prclDst, NULL, rop4))
        return TRUE;
    else
        return FALSE;

}


extern "C" BOOL APIENTRY
PCLXLCopyBits(
    SURFOBJ        *psoDst,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDst,
    POINTL         *pptlSrc)
/*++

Routine Description:

    Implementation of DDI entry point DrvCopyBits.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Points to the Dstination surface
    psoSrc - Points to the source surface
    pxlo - XLATEOBJ provided by the engine
    pco - Defines a clipping region on the Dstination surface
    pxlo - Defines the translation of color indices
           between the source and target surfaces
    prclDst - Defines the area to be modified
    pptlSrc - Defines the upper-left corner of the source rectangle

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    PXLPDEV    pxlpdev;

    RECTL rclSrc;

    VERBOSE(("PCLXLCopyBits() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    //
    // create prclSrc (source rectangle)
    //

    rclSrc.top    = pptlSrc->y;
    rclSrc.left   = pptlSrc->x;
    rclSrc.bottom = pptlSrc->y + RECT_HEIGHT(prclDst);
    rclSrc.right  = pptlSrc->x + RECT_WIDTH(prclDst);

    if (S_OK == CommonRopBlt(pdevobj, psoSrc, pco, pxlo, NULL, &rclSrc, prclDst, NULL, 0xCC))
        return TRUE;
    else
        return FALSE;

}


extern "C" BOOL APIENTRY
PCLXLPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode)
/*++

Routine Description:

    Implementation of DDI entry point DrvPlgBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Defines the surface on which to draw
    psoSrc - Defines the source for blt operation
    psoMask - Defines a surface that provides a mask for the source
    pco - Limits the area to be modified on the Dstination
    pxlo - Specifies how color dwIndexes are to be translated
        between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    pptlBrushOrg - Specifies the origin of the halftone brush
    ppfixDest - Defines the area to be modified on the Dstination surface
    prclSrc - Defines the area to be copied from the source surface
    pptlMask - Specifies which pixel in the given mask corresponds to
        the upper left pixel in the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    VERBOSE(("PCLXLBltBlt() entry.\n"));

    return EngPlgBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlBrushOrg,
             pptfixDst, prclSrc, pptlMask, iMode);
}


extern "C" BOOL APIENTRY
PCLXLAlphaBlend(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLAlphaBlend() entry.\n"));
    PDEV *pPDev = (PDEV*)psoDst->dhpdev;
    BOOL bRet;

    if (NULL == pPDev)
    {
        return FALSE;
    }

    pPDev->fMode2 |= PF2_WHITEN_SURFACE;
    bRet = EngAlphaBlend(psoDst,
                         psoSrc,
                         pco,
                         pxlo,
                         prclDst,
                         prclSrc,
                         pBlendObj);
    pPDev->fMode2 &= ~(PF2_WHITEN_SURFACE|PF2_SURFACE_WHITENED);
    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLGradientFill(
    SURFOBJ    *psoDst,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLGradientFill() entry.\n"));
    PDEV *pPDev = (PDEV*) psoDst->dhpdev;
    BOOL bRet;

    if (NULL == pPDev)
    {
        return FALSE;
    }

    if (ulMode == GRADIENT_FILL_TRIANGLE)
    {
        pPDev->fMode2 |= PF2_WHITEN_SURFACE;
    }
    bRet = EngGradientFill(psoDst,
                           pco,
                           pxlo,
                           pVertex,
                           nVertex,
                           pMesh,
                           nMesh,
                           prclExtents,
                           pptlDitherOrg,
                           ulMode);
    pPDev->fMode2 &= ~(PF2_WHITEN_SURFACE|PF2_SURFACE_WHITENED);
    return bRet;
}

extern "C" BOOL APIENTRY
PCLXLTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved)
{
    PDEVOBJ  pdevobj         = (PDEVOBJ) psoDst->dhpdev;
    PDEV     *pPDev          = (PDEV*) psoDst->dhpdev;
    PXLPDEV  pxlpdev         = (PXLPDEV)pdevobj->pdevOEM;

    HRESULT  hr              = E_FAIL;
    ULONG    ulXlate[2]      = {0x0, RGB_WHITE}; //2 colors in psoMsk. Black and White.
    XLATEOBJ xlo;

    ZeroMemory ( &xlo, sizeof (XLATEOBJ) );
    xlo.cEntries = 2;
    xlo.pulXlate = (PULONG)ulXlate;
    xlo.flXlate  =  XO_TABLE; // use the entries in pulXlate table.


    if ( NULL == pxlpdev ||
         NULL == psoSrc )
    {
        return FALSE;
    }

    //
    // Step 1. Create a mask and download it to printer using ROP DSO (238 = 0xEE). 
    //      The mask is a 1bpp image created out of the image in psoSrc. Wherever 
    //      the TransColor is present
    //      in the image, the corresponding pixel in the mask gets value 0. At all other places 
    //      the pixel will get value of 1. 
    //      if we copy the mask to a color printer (using ROP of SRC_COPY), 
    //      you will notice that the image is black and white,
    //      and black is present on the same place where the Transparent Color should be there.
    //      Instead of SRC_COPY if we use rop=238 which is (SOURCE | DESTINATION), the white color 
    //      of the mask will get OR'ed with destinaion and the region becomes white. The black 
    //      color 
    //      of the mask will not be printed and instead whatever is there already on the sheet 
    //      (if something is present) will be visible 
    //          Assuming x is the pixel already present on the sheet.
    //          0 | x = x (ORing anything with 0  is anything)
    //          1 | x = 1
    //      1 represents white color (RGB_WHITE = 0xFFFFFF = all 1s).
    //
    // Step 2.
    //      In the image, wherever the TransColor is present, change it to white. 
    //      Now the image has 2 kinds of white colors. Those that 
    //      are originally present in the image, and those that we just put in there.
    // Step 3.
    //      Download the image with rop DSAnd (=136 = 0x88). 
    //      Assuming x is the pixel already present on the sheet 
    //      and y be the pixel in the image and 1 represents white color 
    //      (RGB_WHITE = 0xFFFFFF = all 1s).
    //          1 & y = y  Image falling on the area that we whited in step 1.
    //          1 & x = x  The white parts of the image (that was earlier TransColor) falling in 
    //                     the area. 
    //                     that is supposed to be visible from under the image.
    //

    //
    //
    // Step 1 Create appropriate mask.
    // For images that are greater than 1bpp
    //    Use unidrv's CreateMaskSurface to create mask. The logic of a mask surface
    //    is explained above.
    // For images that are 1bpp
    //    CreateMaskSurface does not create mask for 1bpp image. So for that we'll 
    //    create mask ourselves. Since mask is 1bpp and so is the image, we can simply
    //    use the image as the mask, except that we might need to manipulate the palette.
    //    The benefit here is that we are using the same image as mask, instead of 
    //    creating a new image and using memory.
    // 

    if ( BMF_1BPP == psoSrc->iBitmapFormat )
    {

        //
        // For paletted images (1bpp images have palette), iTransColor is actually the index into
        // the palette, and not the actual RGB color itself.
        // As explained above, the transparent color should be black in the mask, while the
        // non-transparent color should be white. Black is 
        // index 0 in xlo.pulXlate = (PULONG)ulXlate. So if TransColor is 0, then
        // we can simply use the xlo that we created above. 
        // If not, we need to switch black and white in the palette.
        // (To repeat. While sending the mask, iTransColor should be sent as black and
        // the color that is to be printed should be sent as white). 
        //
        if ( 0 != iTransColor ) 
        {
            //
            // Reverse Colors.
            //
            ulXlate[0] = RGB_WHITE; 
            ulXlate[1] = RGB_BLACK; 
        }
        hr = CommonRopBlt(pdevobj, psoSrc, pco, &xlo, NULL, prclSrc, prclDst, NULL, 0xEE);

    }
    else
    {
        SURFOBJ  *psoMsk = NULL;
        HBITMAP  hBmpMsk = NULL;

        if (psoMsk = CreateBitmapSURFOBJ(pPDev,
                                          &hBmpMsk,
                                          psoSrc->sizlBitmap.cx,
                                          psoSrc->sizlBitmap.cy,
                                          BMF_1BPP) )
        {
            if ( CreateMaskSurface(psoSrc,psoMsk,iTransColor) )
            {
                
                hr = CommonRopBlt(pdevobj, psoMsk, pco, &xlo, NULL, prclSrc, prclDst, NULL, 0xEE);
            } 
        }

        //
        // Release allocated objects.
        //
        if ( psoMsk )
        { 
            EngUnlockSurface(psoMsk);
            psoMsk = NULL;  
        }

        if (hBmpMsk)
        {   
            EngDeleteSurface((HSURF)hBmpMsk); 
            hBmpMsk = NULL; 
        }
    }


    if ( FAILED (hr) )
    {
        ERR(("PCLXLTransparentBlt: Mask could not be created or rendered.\n"));
        goto Cleanup;
    }

    //
    // Step 2 and 3. 
    // Set the flags and call CommonRopBlt. CommonRopBlt is the function that
    // dumps images to printer. CommonRopBlt will look at the 
    // flags and know that for this image, it has to replace 
    // the colored pixels with White
    // 

    pxlpdev->dwFlags |= XLPDEV_FLAGS_SUBST_TRNCOLOR_WITH_WHITE;
    pxlpdev->ulTransColor = iTransColor;

    //
    // ROP is DSAnd = 136 = 0x88.
    //
    hr = CommonRopBlt(pdevobj, psoSrc, pco, pxlo, NULL, prclSrc, prclDst, NULL, 136);

    pxlpdev->ulTransColor = 0;
    pxlpdev->dwFlags &= ~XLPDEV_FLAGS_SUBST_TRNCOLOR_WITH_WHITE;

Cleanup:

    if ( SUCCEEDED (hr) )
    {
        return TRUE;
    }

    return FALSE;
}

extern "C" BOOL APIENTRY
PCLXLTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;

    VERBOSE(("PCLXLTextOut() entry.\n"));

    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    XLOutput *pOutput = pxlpdev->pOutput;

    //
    // Clip
    //
    if (!SUCCEEDED(pOutput->SetClip(pco)))
        return FALSE;

    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mix));

    if (!ROP3_NEED_SOURCE(rop))
        rop = 0x00fc;


    //
    // Set ROP and TxMode.
    // Send NewPath to flush memory.
    //
    pOutput->SetROP3(rop);
    pOutput->Send_cmd(eNewPath);
    pOutput->SetPaintTxMode(eOpaque);
    pOutput->SetSourceTxMode(eOpaque);

    //
    // Opaque Rectangle
    //
    if (prclOpaque)
    {
        pOutput->SetPenColor(NULL, NULL);
        pOutput->SetBrush(pboOpaque, pptlOrg);
        pOutput->Send_cmd(eNewPath);
        pOutput->RectanglePath(prclOpaque);
        pOutput->Paint();
    }

    //
    // Draw underline, strikeout, etc.
    //
    if (prclExtra)
    {
        pOutput->SetPenColor(NULL, NULL);
        pOutput->SetBrush(pboFore, pptlOrg);
        pOutput->Send_cmd(eNewPath);
        while(NULL != prclExtra) 
        {
            pOutput->RectanglePath(prclExtra++);
        }
        pOutput->Paint();
    }

    //
    // Text Color
    //
    pOutput->SetBrush(pboFore, pptlOrg);
    pOutput->Flush(pdevobj);

    //
    // Device font/TrueType download
    //
    DrvTextOut(
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix);

    //
    // Bug reported by HP.
    // Plug-in could have command callback and DrvStartPage sets plug-in's
    // pdev in pdevOEM.
    // Need to reset it.
    //
    ((PPDEV)pdevobj)->devobj.pdevOEM = ((PPDEV)pdevobj)->pVectorPDEV;

    //
    // Flush cached text before changing font
    //
    FlushCachedText(pdevobj);

    //
    // Reset text angle
    //
    pxlpdev->dwTextAngle = 0;

    //
    // Close TrueType font
    //
    pxlpdev->pTTFile->CloseTTFile();

    return TRUE;
}


extern "C" BOOL APIENTRY
PCLXLLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    POINTFIX   Pointfix;
    LINEATTRS  lineattrs;

    VERBOSE(("PCLXLLineTo() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
    Pointfix.x = x2 << 4;
    Pointfix.y = y2 << 4;
    lineattrs = *pgLineAttrs;
    lineattrs.elWidth.e = FLOATL_IEEE_1_0F;

    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mix));
    TxMode     TxModeValue;

    //
    // Quick return in the case of AA (destination).
    //
    if (rop == 0xAA)
    {
        return TRUE;
    }

    //
    // If there is any Pattern involved, set TxMode to Opaque.
    //
    if (ROP3_NEED_PATTERN(rop))
    {
        TxModeValue = eOpaque;
    }
    else
    {
        TxModeValue = eTransparent;
    }

    BOOL bRet;
    XLOutput *pOutput = pxlpdev->pOutput;

    if (S_OK == pOutput->SetClip(pco) &&
        S_OK == pOutput->SetROP3(rop) &&
        S_OK == pOutput->SetPaintTxMode(TxModeValue) &&
        S_OK == pOutput->SetSourceTxMode(TxModeValue) &&
        S_OK == pOutput->SetPen(&lineattrs, NULL) &&
        S_OK == pOutput->SetPenColor(pbo, NULL) &&
        S_OK == pOutput->SetBrush(NULL, NULL) &&
        S_OK == pOutput->Send_cmd(eNewPath) &&
        S_OK == pOutput->SetCursor(x1, y1) &&
        S_OK == pOutput->LinePath(&Pointfix, 1) &&
        S_OK == pOutput->Paint() &&
        S_OK == pOutput->Flush(pdevobj))
        bRet = TRUE;
    else
    {
        pOutput->Delete();
        bRet = FALSE;
    }


    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    TxMode     TxModeValue;

    VERBOSE(("PCLXLStokePath() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    BOOL bRet;
    XLOutput *pOutput = pxlpdev->pOutput;

    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mix));

    //
    // Quick return in the case of AA (destination).
    //
    if (rop == 0xAA)
    {
        return TRUE;
    }

    //
    // If there is any Pattern involved, set TxMode to Opaque.
    //
    if (ROP3_NEED_PATTERN(rop))
    {
        TxModeValue = eOpaque;
    }
    else
    {
        TxModeValue = eTransparent;
    }

    if (S_OK == pOutput->SetClip(pco) &&
        S_OK == pOutput->SetROP3(rop) &&
        S_OK == pOutput->SetPaintTxMode(TxModeValue) &&
        S_OK == pOutput->SetSourceTxMode(TxModeValue) &&
        S_OK == pOutput->SetPen(plineattrs, pxo) &&
        S_OK == pOutput->SetPenColor(pbo, pptlBrushOrg) &&
        S_OK == pOutput->SetBrush(NULL, NULL) &&
        S_OK == pOutput->Path(ppo) &&
        S_OK == pOutput->Paint() &&
        S_OK == pOutput->Flush(pdevobj))
        bRet = TRUE;
    else
    {
        pOutput->Delete();
        bRet = FALSE;
    }


    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLFillPath() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    BOOL bRet;
    XLOutput *pOutput = pxlpdev->pOutput;

    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mix));
    TxMode     TxModeValue;

    //
    // Quick return in the case of AA (destination).
    //
    if (rop == 0xAA)
    {
        return TRUE;
    }

    //
    // Performance fix suggested by HP.
    // Fix the performance problem on CD9T_LET.cdr.
    //
    if (pco && pco->iFComplexity == FC_COMPLEX)
    {
        return FALSE;
    }

    //
    // If there is any Pattern involved, set TxMode to Opaque.
    //
    if (ROP3_NEED_PATTERN(rop))
    {
        TxModeValue = eOpaque;
    }
    else
    {
        TxModeValue = eTransparent;
    }

    //
    // Setup fill mode
    //
    FillMode FM;
    if (flOptions == FP_ALTERNATEMODE)
    {
        FM =  eFillEvenOdd;
    }
    else if (flOptions == FP_WINDINGMODE)
    {
        FM =  eFillNonZeroWinding;
    }

    if (S_OK == pOutput->SetClip(pco) &&
        S_OK == pOutput->SetROP3(rop) &&
        S_OK == pOutput->SetPaintTxMode(TxModeValue) &&
        S_OK == pOutput->SetSourceTxMode(TxModeValue) &&
        S_OK == pOutput->SetFillMode(FM) &&
        S_OK == pOutput->SetPenColor(NULL, NULL) &&
        S_OK == pOutput->SetBrush(pbo, pptlBrushOrg) &&
        S_OK == pOutput->Path(ppo) &&
        S_OK == pOutput->Paint() &&
        S_OK == pOutput->Flush(pdevobj))
        bRet = TRUE;
    else
    {
        pOutput->Delete();
        bRet = FALSE;
    }

    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLStrokeAndFillPath() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
    XLOutput *pOutput = pxlpdev->pOutput;
    BOOL bRet;
    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mixFill));
    TxMode     TxModeValue;

    //
    // Quick return in the case of AA (destination).
    //
    if (rop == 0xAA)
    {
        return TRUE;
    }

    //
    // If there is any Pattern involved, set TxMode to Opaque.
    //
    if (ROP3_NEED_PATTERN(rop))
    {
        TxModeValue = eOpaque;
    }
    else
    {
        TxModeValue = eTransparent;
    }

    //
    // Setup fill mode
    //
    FillMode FM;
    if (flOptions == FP_ALTERNATEMODE)
    {
        FM =  eFillEvenOdd;
    }
    else if (flOptions == FP_WINDINGMODE)
    {
        FM =  eFillNonZeroWinding;
    }

    if (S_OK == pOutput->SetClip(pco) &&
        S_OK == pOutput->SetROP3(rop) &&
        S_OK == pOutput->SetPaintTxMode(TxModeValue) &&
        S_OK == pOutput->SetSourceTxMode(TxModeValue) &&
        S_OK == pOutput->SetFillMode(FM) &&
        S_OK == pOutput->SetPen(plineattrs, pxo) &&
        S_OK == pOutput->SetPenColor(pboStroke, pptlBrushOrg) &&
        S_OK == pOutput->SetBrush(pboFill, pptlBrushOrg) &&
        S_OK == pOutput->Path(ppo) &&
        S_OK == pOutput->Paint() &&
        S_OK == pOutput->Flush(pdevobj))
        bRet = TRUE;
    else
    {
        pOutput->Delete();
        bRet = FALSE;
    }

    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    PXLPDEV    pxlpdev;
    XLBRUSH    *pBrush;
    BOOL       bRet;
    OutputFormat OutputF;

    VERBOSE(("PCLXLRealizeBrush() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    if (iHatch >= HS_DDI_MAX)
    {
        LONG  lHeight, lWidth, lScanline;
        ULONG ulOutputBPP, ulInputBPP;
        DWORD dwI, dwBufSize, dwLenNormal, dwLenRLE,dwLenDRC, dwcbLineSize, dwcbBmpSize;
        PDWORD pdwLen;
        PBYTE pubSrc, pBufNormal, pBufRLE, pBufDRC, pBuf, pBmpSize;
        XLOutput *pOutput = pxlpdev->pOutput;

        DetermineOutputFormat(pxlo, pOutput->GetDeviceColorDepth(), psoPattern->iBitmapFormat, &OutputF, &ulOutputBPP);

        //
        // Get Info
        //
        ulInputBPP = UlBPPtoNum((BPP)psoPattern->iBitmapFormat);
        lHeight    = psoPattern->sizlBitmap.cy;
        lWidth     = psoPattern->sizlBitmap.cx;

        dwcbLineSize = ((lWidth * ulInputBPP) + 7) >> 3;
        dwBufSize  = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2) +
                     DATALENGTH_HEADER_SIZE + sizeof(PCLXL_EndRastPattern);

        VERBOSE(("PCLXLRealizeBrush():InBPP=%d,Width=%d,Height=%d,Line=%d,Size=%d.\n",
                ulInputBPP, lWidth, lHeight, dwcbLineSize, dwBufSize));

        //
        // Allocate output buffer
        //
        pBufNormal = pBufRLE = pBufDRC = NULL;
        if (COMMANDPTR(((PPDEV)pdevobj)->pDriverInfo,CMD_ENABLEDRC))
        {
            if (NULL == (pBufDRC = (PBYTE)MemAlloc(dwBufSize)))
            {
                ERR(("PCLXLRealizeBrush: MemAlloc failed.\n"));
                return FALSE;
            }
        }
        if (NULL == (pBufNormal = (PBYTE)MemAlloc(dwBufSize)) ||
            NULL == (pBufRLE = (PBYTE)MemAlloc(dwBufSize))     )
        {
            if (pBufNormal != NULL)
                MemFree(pBufNormal);
            if (pBufRLE != NULL)
                MemFree(pBufRLE);
            ERR(("PCLXLRealizeBrush: MemAlloc failed.\n"));
            return FALSE;
        }

        CompressMode CMode;
        BMPConv BMPC;
        PBYTE pubDst;
        DWORD dwDstSize;

        #if DBG
        BMPC.SetDbgLevel(BRUSHDBG);
        #endif
        BMPC.BSetInputBPP((BPP)psoPattern->iBitmapFormat);
        BMPC.BSetOutputBPP(NumToBPP(ulOutputBPP));
        BMPC.BSetOutputBMPFormat(OutputF);
        BMPC.BSetXLATEOBJ(pxlo);

        dwLenNormal = dwLenRLE = dwLenDRC = 0;

        #define NO_COMPRESSION 0
        #define RLE_COMPRESSION 1
        #define DRC_COMPRESSION 2
        DWORD dwComp;

        if (COMMANDPTR(((PPDEV)pdevobj)->pDriverInfo,CMD_ENABLEDRC))
        {
            //
            // Try DRC compression.
            //
            dwComp =  3;
        }
        else
        {
            //
            // Only non and RLE comp.
            //
            dwComp = 2;
        }
        for (dwI = 0; dwI < dwComp; dwI ++)
        {
            bRet = TRUE;

            if (NO_COMPRESSION == dwI)
            {
                pBuf = pBufNormal;
                pdwLen = &dwLenNormal;
                CMode = eNoCompression;
            }
            else
            if (RLE_COMPRESSION == dwI)
            {
                pBuf = pBufRLE;
                pdwLen = &dwLenRLE;
                CMode = eRLECompression;
            }
            else
            if (DRC_COMPRESSION == dwI)
            {
                pBuf = pBufDRC;
                pdwLen = &dwLenDRC;
                CMode = eDeltaRowCompression;
            }

            BMPC.BSetCompressionType(CMode);

            lScanline  = lHeight;
            pubSrc     = (PBYTE)psoPattern->pvScan0;

            *pBuf = PCLXL_dataLength;
            pBmpSize = pBuf + 1; // DWORD bitmap size
            pBuf += DATALENGTH_HEADER_SIZE;
            (*pdwLen) = DATALENGTH_HEADER_SIZE;

            dwcbBmpSize = 0;

            while (lScanline-- > 0 && dwcbBmpSize + *pdwLen < dwBufSize)
            {
                pubDst = BMPC.PubConvertBMP(pubSrc, dwcbLineSize);
                dwDstSize = BMPC.DwGetDstSize();
                VERBOSE(("PCLXLRealizeBrush[0x%x]: dwDstSize=0x%x\n", lScanline, dwDstSize));
                
                if ( dwcbBmpSize +
                     dwDstSize +
                     DATALENGTH_HEADER_SIZE +
                     sizeof(PCLXL_EndRastPattern) > dwBufSize || NULL == pubDst)
                {
                    ERR(("PCLXLRealizeBrush: Buffer size is too small.(%d)\n", dwI));
                    bRet = FALSE;
                    break;
                }

                memcpy(pBuf, pubDst, dwDstSize);
                dwcbBmpSize += dwDstSize;
                pBuf += dwDstSize;
                pubSrc += psoPattern->lDelta;

            }

            if (lScanline > 0)
            {
                bRet = FALSE;
#if DBG
                ERR(("PCLXLRealizeBrush: Conversion failed.\n"));
#endif
            }

            if (bRet)
            {
                if (dwI == NO_COMPRESSION)
                {
                    //
                    // Scanline on PCL-XL has to be DWORD align.
                    //
                    // count byte of scanline = lWidth * ulOutputBPP / 8
                    //
                    dwcbBmpSize = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2);
                }

                CopyMemory(pBmpSize, &dwcbBmpSize, sizeof(dwcbBmpSize));
                (*pdwLen) += dwcbBmpSize;

                *pBuf = PCLXL_EndRastPattern;
                (*pdwLen) ++;
            }
            else
            {
                *pdwLen = 0; 
            }
        }
        #undef NO_COMPRESSION
        #undef RLE_COMPRESSION
        #undef DRC_COMPRESSION

        if (dwLenRLE == 0 && dwLenDRC != 0 && dwLenDRC < dwLenNormal ||
            dwLenRLE != 0 && dwLenDRC != 0 && dwLenDRC < dwLenRLE && 
                                              dwLenDRC < dwLenNormal  )
        {
            pBuf = pBufDRC;
            pdwLen = &dwLenDRC;
            CMode = eDeltaRowCompression;

            MemFree(pBufNormal);
            MemFree(pBufRLE);
        }
        else
        if (dwLenRLE != 0 && dwLenRLE < dwLenNormal)
        {
            pBuf = pBufRLE;
            pdwLen = &dwLenRLE;
            CMode = eRLECompression;

            MemFree(pBufNormal);
            MemFree(pBufDRC);
        }
        else
        if (dwLenNormal != 0)
        {
            pBuf = pBufNormal;
            pdwLen = &dwLenNormal;
            CMode = eNoCompression;

            MemFree(pBufRLE);
            MemFree(pBufDRC);
        }
        else
        {
            MemFree(pBufNormal);
            MemFree(pBufRLE);
            MemFree(pBufDRC);
            ERR(("PCLXLRealizeBrush: Conversion failed. Return FALSE.\n"));
            return FALSE;
        }


        //
        // Output
        //
        ColorMapping CMapping;
        DWORD dwScale;

        //
        // Pattern scaling factor
        // Scale the destination size of pattern.
        // Resolution / 150 seems to be a good scaling factor.
        //
        dwScale = (pOutput->GetResolutionForBrush() + 149)/ 150;

        if (pOutput->GetDeviceColorDepth() == e24Bit)
        {
            pOutput->SetColorSpace(eRGB);
        }
        else
        {
            pOutput->SetColorSpace(eGray);
        }
        if (OutputF == eOutputPal)
        {
            DWORD *pdwColorTable;

            if ((pdwColorTable = GET_COLOR_TABLE(pxlo)))
            {
                pOutput->SetPalette(ulOutputBPP, pxlo->cEntries, pdwColorTable);
                CMapping = eIndexedPixel;
            }
            else
            {
                CMapping = eDirectPixel;
            }
        }
        else
        {
            CMapping = eDirectPixel;
        }
        pOutput->Send_cmd(eSetColorSpace);

        pOutput->SetOutputBPP(CMapping, ulOutputBPP);
        pOutput->SetSourceWidth((uint16)lWidth);
        pOutput->SetSourceHeight((uint16)lHeight);
        pOutput->SetDestinationSize((uint16)(lWidth * dwScale), (uint16)(lHeight * dwScale));
        pOutput->SetPatternDefineID((sint16)pxlpdev->dwLastBrushID);
        pOutput->SetPatternPersistence(eSessionPattern);
        pOutput->Send_cmd(eBeginRastPattern);
        pOutput->Flush(pdevobj);
        pOutput->ReadRasterPattern(lHeight, CMode);
        pOutput->Flush(pdevobj);

        DWORD dwBitmapSize;
        CopyMemory(&dwBitmapSize, pBuf + 1, sizeof(DWORD));

        if (dwBitmapSize > 0xff)
        {
            //
            // dataLength
            // size (uin32) (bitmap size)
            // DATA
            // EndImage
            //
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, *pdwLen);
        }
        else
        {
            //
            // dataLength
            // size (byte) (bitmap size)
            // DATA
            // EndImage
            //
            PBYTE pTmp = pBuf;

            pBuf += 3;
            *pBuf = PCLXL_dataLengthByte;
            *(pBuf + 1) = (BYTE)dwBitmapSize;
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, (*pdwLen) - 3);

            //
            // Restore the original pointer
            //
            pBuf = pTmp;
        }
        MemFree(pBuf);

    }

    DWORD dwBrushSize;
    if (pxlo->cEntries)
    {
        dwBrushSize = sizeof(XLBRUSH) + (pxlo->cEntries + 1) * sizeof(DWORD);
    }
    else
    {
        dwBrushSize = sizeof(XLBRUSH) + sizeof(DWORD);
    }

    if (pBrush = (XLBRUSH*)BRUSHOBJ_pvAllocRbrush(pbo, dwBrushSize))
    {

        pBrush->dwSig = XLBRUSH_SIG;
        pBrush->dwHatch     = iHatch;

        if (iHatch >= HS_DDI_MAX)
        {
            pBrush->dwPatternID = pxlpdev->dwLastBrushID++;
        }
        else
        {
            //
            // Set 0 for hatch brush case
            //
            pBrush->dwPatternID = 0;
        }

        DWORD *pdwColorTable;

        pdwColorTable = GET_COLOR_TABLE(pxlo);

        //
        // get color for Graphics state cache for either palette case or
        // solid color.
        //
        pBrush->dwColor = BRUSHOBJ_ulGetBrushColor(pbo);

        if (pdwColorTable && pxlo->cEntries != 0)
        {
            //
            // Copy palette table.
            //
            CopyMemory(pBrush->adwColor, pdwColorTable, pxlo->cEntries * sizeof(DWORD));
            pBrush->dwCEntries = pxlo->cEntries;
        }
        else
        {
            pBrush->dwCEntries = 0;
        }

        pBrush->dwOutputFormat = (DWORD)OutputF;

        pbo->pvRbrush = (PVOID)pBrush;
        bRet = TRUE;
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLStartPage(
    SURFOBJ    *pso)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    BOOL       bRet;

    VERBOSE(("PCLXLStartPage() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    XLOutput *pOutput = pxlpdev->pOutput;

    pxlpdev->dwFlags |= XLPDEV_FLAGS_STARTPAGE_CALLED;

    bRet = DrvStartPage(pso);


    //
    // Bug reported by HP.
    // Plug-in could have command callback and DrvStartPage sets plug-in's
    // pdev in pdevOEM.
    // Need to reset it.
    //
    ((PPDEV)pdevobj)->devobj.pdevOEM = ((PPDEV)pdevobj)->pVectorPDEV;

    //
    // Reset printing mode.
    // SourceTxMode, PaintTxMode
    // ROP
    //
    pOutput->SetPaintTxMode(eOpaque);
    pOutput->SetSourceTxMode(eOpaque);
    pOutput->SetROP3(0xCC);

    pOutput->Flush(pdevobj);

    //
    // Needs to reset attribute when EndPage and BeginPage are sent.
    //
    if (!(pxlpdev->dwFlags & XLPDEV_FLAGS_FIRSTPAGE))
    {
        BSaveFont(pdevobj);

        //
        // Reset graphcis state each page.
        //
        pOutput->ResetGState();

    }
    else
    {
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_FIRSTPAGE;
    }


    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLSendPage(
    SURFOBJ    *pso)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    XLOutput  *pOutput;

    VERBOSE(("PCLXLEndPage() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    pxlpdev->dwFlags &= ~XLPDEV_FLAGS_STARTPAGE_CALLED;

    pOutput = pxlpdev->pOutput;
    pOutput->Flush(pdevobj);

    return DrvSendPage(pso);
}


extern "C" ULONG APIENTRY
PCLXLEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLEscape() entry.\n"));

    return DrvEscape(
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut);
}


extern "C" BOOL APIENTRY
PCLXLStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLStartDoc() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    //
    // Initialize flag
    //
    pxlpdev->dwFlags |= XLPDEV_FLAGS_FIRSTPAGE;

    return DrvStartDoc(
            pso,
            pwszDocName,
            dwJobId);
}


extern "C" BOOL APIENTRY
PCLXLEndDoc(
    SURFOBJ    *pso,
    FLONG       fl)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    BOOL       bRet;

    VERBOSE(("PCLXLEndDoc() entry.\n"));

    if (NULL == pdevobj->pdevOEM)
    {
        bRet = FALSE;
    }
    {
        pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
        if (S_OK == RemoveAllFonts(pdevobj))
        {
            bRet = TRUE;
        }
        else
        {
            bRet = FALSE;
        }
    }

    pxlpdev->dwFlags |= XLPDEV_FLAGS_ENDDOC_CALLED;

    return bRet && DrvEndDoc(pso, fl);
}

////////////////////////////////////////////////////////////////////////////////
//
// Sub functions
//

HRESULT
RemoveAllFonts(
    PDEVOBJ pdevobj)
{
    PXLPDEV    pxlpdev;
    XLOutput  *pOutput;
    DWORD      dwI;
    HRESULT    hResult;

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
    pOutput = pxlpdev->pOutput;

    hResult = S_OK;

    for (dwI = 0; dwI < pxlpdev->dwNumOfTTFont; dwI++)
    {
        if (S_OK != pOutput->Send_ubyte_array_header(PCLXL_FONTNAME_SIZE) ||
            S_OK != pOutput->Write(PubGetFontName(pdevobj, dwI+1), PCLXL_FONTNAME_SIZE)||
            S_OK != pOutput->Send_attr_ubyte(eFontName) ||
            S_OK != pOutput->Send_cmd(eRemoveFont))
        {
            hResult = S_FALSE;
            break;
        }
    }

    pOutput->Flush(pdevobj);
    pxlpdev->dwNumOfTTFont = 0;
    return hResult;
}

HRESULT
CommonRopBlt(
   IN PDEVOBJ    pdevobj,
   IN SURFOBJ    *psoSrc,
   IN CLIPOBJ    *pco,
   IN XLATEOBJ   *pxlo,
   IN BRUSHOBJ   *pbo,
   IN RECTL      *prclSrc,
   IN RECTL      *prclDst,
   IN POINTL     *pptlBrush,
   IN ROP4        rop4)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT hRet;

    VERBOSE(("CommonRopBlt() entry.\n"));

    //
    // Error check
    //

    if (pdevobj == NULL ||
        prclDst == NULL  )
    {
        ERR(("CommonRopBlt: one of parameters is NULL.\n"));
        return E_UNEXPECTED;
    }

    PXLPDEV    pxlpdev= (PXLPDEV)pdevobj->pdevOEM;


    hRet = S_OK;

    XLOutput *pOutput = pxlpdev->pOutput;
    OutputFormat OutputF;

    //
    // Set Clip
    //
    if (!SUCCEEDED(pOutput->SetClip(pco)))
        return S_FALSE;

    //
    // Set Cursor
    //
    pOutput->SetCursor(prclDst->left, prclDst->top);

    //
    // 1. ROP conversion
    //
    // (1) Fill Dstination
    //     0x00 BLACKNESS
    //     0xFF WHITENESS
    //
    // (2) Pattern copy     -> P
    //     0xF0 PATCOPY     P
    //
    // (3) SRC/NOTSRCOPY    -> S or ~S
    //     0x11           ~( S | D)
    //     0x33             ~S
    //     0x44            ( S & ~D)
    //     0x66            ( D ^ S)
    //     0x77           ~( D & S)
    //     0x99           ~( S ^ D)
    //     0xCC              S
    //     0xDD            ( S | ~D)
    //
    // (4) Misc ROP support
    //     0xAA            D
    //     0x0F PATNOT     ~P
    //
    //
    ROP3 rop3 = GET_FOREGROUND_ROP3(rop4);
    DWORD dwCase = 0;

    #define ROP_BLACKWHITE  0x1
    #define ROP_PATTERN     0x2
    #define ROP_BITMAP      0x4
    #define ROP_DEST        0x8


    //
    // Set ROP3
    //
    pOutput->SetROP3(GET_FOREGROUND_ROP3(rop4));

    switch (rop3)
    {
    case 0x00:
    case 0xFF:
        dwCase = ROP_BLACKWHITE;
        break;

    case 0xF0:
        dwCase = ROP_PATTERN;
        break;

    case 0x11:
    case 0x33:
    case 0x44:
    case 0x66:
    case 0x77:
    case 0x99:
    case 0xCC:
    case 0xDD:
        dwCase = ROP_BITMAP;
        break;

    case 0xAA:
        dwCase = ROP_DEST;
        break;
    
    case 0x0F:
        dwCase = ROP_PATTERN;
        break;

    default:
        if (ROP3_NEED_SOURCE(rop3))
        {
            dwCase |= ROP_BITMAP;
        }
        if (ROP3_NEED_PATTERN(rop3))
        {
            dwCase |= ROP_PATTERN;
        }
        if (ROP3_NEED_DEST(rop3))
        {
            dwCase |= ROP_DEST;
        }
        break;
    }

    //
    // Black & White case
    //
    if (dwCase & ROP_BLACKWHITE)
    {
        VERBOSE(("CommonRopBlt(): BlackWhite.\n"));
        //
        // SetBrushSource
        // NewPath
        // RectanglePath
        // PaintPath
        //

        CMNBRUSH CmnBrush;
        CmnBrush.dwSig            = BRUSH_SIGNATURE;
        CmnBrush.BrushType        = kBrushTypeSolid;
        CmnBrush.ulSolidColor     = 0x00;
        CmnBrush.ulHatch          = 0xFFFFFFFF;
        CmnBrush.dwColor          = 0x00FFFFFF;
        CmnBrush.dwPatternBrushID = 0xFFFFFFFF;

        pOutput->SetSourceTxMode(eOpaque);
        pOutput->SetPaintTxMode(eOpaque);

        if(rop3 == 0x00)
        {
            if (e24Bit == pOutput->GetDeviceColorDepth())
            {
                pOutput->SetRGBColor(0);
                CmnBrush.dwColor = 0x00;
            }
            else
            {
                pOutput->SetGrayLevel(0x00);
                CmnBrush.dwColor = 0x00;
            }
        }
        else
        {
            if (e24Bit == pOutput->GetDeviceColorDepth())
            {
                pOutput->SetRGBColor(0x00ffffff);
                CmnBrush.dwColor = 0x00ffffff;
            }
            else
            {
                pOutput->SetGrayLevel(0xff);
                CmnBrush.dwColor = 0x00ffffff;
            }
        }

        ((XLBrush*)pOutput)->SetBrush(&CmnBrush);

        pOutput->Send_cmd(eSetBrushSource);
        pOutput->SetPenColor(NULL, NULL);
        if (!(dwCase & ROP_BITMAP))
        {
            pOutput->Send_cmd(eNewPath);
            pOutput->RectanglePath(prclDst);
            pOutput->Send_cmd(ePaintPath);
        }
        pOutput->Flush(pdevobj);
    }

    //
    // Pattern fill case
    //
    if (dwCase & (ROP_DEST|ROP_PATTERN))
    {
        VERBOSE(("CommonRopBlt(): Pattern.\n"));

        //
        // SetPaintTxMode
        // SetSourceTxMode
        // SetBrushSource
        // NewPath
        // RectanglePath
        // PaintPath
        //
        pOutput->SetSourceTxMode(eOpaque);
        pOutput->SetPaintTxMode(eOpaque);
        pOutput->SetBrush(pbo, pptlBrush);
        pOutput->SetPenColor(NULL, NULL);
        if (!(dwCase & ROP_BITMAP))
        {
            pOutput->Send_cmd(eNewPath);
            pOutput->RectanglePath(prclDst);
            pOutput->Send_cmd(ePaintPath);
        }
        pOutput->Flush(pdevobj);
    }

    //
    // Bitmap case
    //
    if (dwCase & ROP_BITMAP)
    {
        LONG  lHeight, lWidth, lScanline;
        ULONG ulOutputBPP, ulInputBPP;
        DWORD dwI, dwBufSize, dwLen, dwcbLineSize, dwcbBmpSize;
        PDWORD pdwLen;
        PBYTE pubSrc, pBuf, pBufOrg = NULL, pBmpSize, pBufEnd;
        ColorMapping CMapping;
        SURFOBJ *psoBmp;
        HBITMAP hBitmap = NULL;
        PBYTE  pubChanged = NULL;
        // temporary rectangle used if the image is downscaled by the engine
        RECTL rctlBitmap;

        // zero out the temporary rectangle
        memset( &rctlBitmap, 0, sizeof(RECTL) );


        VERBOSE(("CommonRopBlt(): Bitmap\n"));

        if (psoSrc == NULL ||
            prclSrc == NULL )
        {
            ERR(("UNIDRV:CommonRopBlt:psoSrc, pxlo, or prclSrc == NULL.\n"));
            pOutput->Flush(pdevobj);
            return E_UNEXPECTED;
        }

        //
        // Input BPP
        //

        ulInputBPP = UlBPPtoNum((BPP)psoSrc->iBitmapFormat);

        psoBmp = NULL;

        // 
        // If the source image is larger than it will appear on the 
        // destination surface, shrink it to the target size.  No point
        // in sending extra bits.
        // 
        // This optimization could be further optimized by building up a clip 
        // object here if one is specified.  How much of a gain this is
        // worth I don't know.
        //
        if (prclDst->right - prclDst->left < prclSrc->right - prclSrc->left ||
            prclDst->bottom - prclDst->top < prclSrc->bottom - prclSrc->top  )
        {

            //
            // Shrink source bitmap.
            //
            PDEV *pPDev = (PDEV*)pdevobj;
            SIZEL sizlDest;
            DWORD dwScanlineLength;
            POINTL ptlBrushOrg;

            // Translate destination rectangle to origin 0,0 and same dimensions as before
            rctlBitmap.left = 0;
            rctlBitmap.top = 0;
            rctlBitmap.right = prclDst->right - prclDst->left;
            rctlBitmap.bottom = prclDst->bottom - prclDst->top;
            

            sizlDest.cx = prclDst->right - prclDst->left;
            sizlDest.cy = prclDst->bottom - prclDst->top;
            dwScanlineLength = (sizlDest.cx * ulInputBPP + 7 ) >> 3;

            if (pptlBrush)
            {
                ptlBrushOrg =  *pptlBrush;
            }
            else
            {
                ptlBrushOrg.x = ptlBrushOrg.y = 0;
            }

            // When we do the transfer, don't do color translation because that will be handled by the printer.
            // Also, don't pass the clip object, because it's in the wrong coordinate space.  We could build a
            // a new clip object, but the value of doing so is questionable, and it would take a lot more testing.
            if ((psoBmp = CreateBitmapSURFOBJ(pPDev,
                                               &hBitmap,
	               sizlDest.cx,
	               sizlDest.cy,
	               psoSrc->iBitmapFormat)) &&
                EngStretchBlt(psoBmp, psoSrc, NULL, NULL, NULL, NULL, &ptlBrushOrg, &rctlBitmap, prclSrc, NULL, HALFTONE))
            {
                psoSrc = psoBmp;
                prclSrc = &rctlBitmap;
            }
            else
            {
                ERR(("CreateBitmapSURFOBJ or EngStretchBlt failed.\n"));
            }
        }

        //
        // Set source opaque mode
        // GDI bug. CopyBits is called recursively.
        //
        {
            PDEV *pPDev = (PDEV*)pdevobj;
            if (pPDev->fMode2 & PF2_SURFACE_WHITENED)
            {
                pOutput->SetSourceTxMode(eTransparent);
            }
            else
            {
                pOutput->SetSourceTxMode(eOpaque);
            }
        }
        pOutput->SetPaintTxMode(eOpaque);

        //
        // Bitmap output
        //
        DetermineOutputFormat(pxlo, pOutput->GetDeviceColorDepth(), psoSrc->iBitmapFormat, &OutputF, &ulOutputBPP);

        if (pOutput->GetDeviceColorDepth() == e24Bit)
        {
            pOutput->SetColorSpace(eRGB);
        }
        else
        {
            pOutput->SetColorSpace(eGray);
        }
        if (OutputF == eOutputPal)
        {
            DWORD *pdwColorTable = NULL;

            if (pdwColorTable = GET_COLOR_TABLE(pxlo))
            {
                if ( pxlpdev->dwFlags & XLPDEV_FLAGS_SUBST_TRNCOLOR_WITH_WHITE )
                {

                    ULONG ulTransColor = pxlpdev->ulTransColor;
                    pdwColorTable = PdwChangeTransparentPalette(ulTransColor, pdwColorTable, pxlo->cEntries); 
                    if (pdwColorTable)
                    {
                        pOutput->SetPalette(ulOutputBPP, pxlo->cEntries, pdwColorTable);
                        MemFree (pdwColorTable);
                        pdwColorTable = NULL;
                    }
                    else
                    {
                        ERR(("CommonRopBlt: PdwChangeTransparentPalette returned NULL.\n"));
                        goto ErrorReturn;
                    }
                
                }
                else
                {
                    pOutput->SetPalette(ulOutputBPP, pxlo->cEntries, pdwColorTable);
                }
            }
            CMapping = eIndexedPixel;
        }
        else
        {
            CMapping = eDirectPixel;
        }

        pOutput->Send_cmd(eSetColorSpace);

        //
        // Get height, width, and scanline size.
        //
        lWidth = prclSrc->right - prclSrc->left;
        lHeight = prclSrc->bottom - prclSrc->top;
        dwcbLineSize = ((lWidth * ulInputBPP) + 7) >> 3;

        //
        // Allocates memory to hold whole bitmap.
        //
        dwBufSize = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2);

        //
        // Limit Buffer Size to 16k, else if the scan line is big, huge memory will
        // be allocated. But the size has to be at least able to hold one scanline.
        //
        #define BMPBUFSIZE 16384
        if (dwBufSize > BMPBUFSIZE)
        {
            if (dwcbLineSize > BMPBUFSIZE)
                dwBufSize = dwcbLineSize;
            else
                dwBufSize = BMPBUFSIZE;
        }


        //
        // Allocate appropriate buffers before doing BeginImage.
        // PCLXL expects certain things to happen after BeginImage.
        // If we attempt to allocate within BeginImage and then allocation
        // fails, and we try to exit midway, PCLXL will not be able to handle 
        // the resulting output properly.
        //
        // When doing TransparentBlt, we need to change colors of pixels. Instead of 
        // altering memory within psoSrc, we'll make copy of scan line and then alter images.
        // So memory needs to be allocated for that.
        //
        if ( pxlpdev->dwFlags & XLPDEV_FLAGS_SUBST_TRNCOLOR_WITH_WHITE &&
             eDirectPixel == CMapping )
        {
            if ( NULL == (pubChanged = (PBYTE) MemAlloc(dwcbLineSize)) )
            {
                ERR(("CommonRopBlt: Cannot allocate memory for pubChanged.\n"));
                goto ErrorReturn;
            }
        }

        //
        // Allocate output buffer
        //
        if (NULL == (pBuf = (PBYTE)MemAlloc(dwBufSize)))
        {
            ERR(("CommonRopBlt: MemAlloc failed.\n"));
        }
        else
        {

            //
            // BeginImage
            //
            pOutput->BeginImage(
                           CMapping,
                           ulOutputBPP,
                           lWidth,
                           lHeight,
                           prclDst->right - prclDst->left,
                           prclDst->bottom - prclDst->top);
            pOutput->Flush(pdevobj);


            VERBOSE(("CommonRopBlt: ulInputBPP=%d, ulOutputBPP=%d, lWidth=0x%x, lHeight=0x%x, dwcbLineSize=0x%x, dwBufSize=0x%x\n",ulInputBPP, ulOutputBPP, lWidth, lHeight, dwcbLineSize, dwBufSize));

            pBufOrg = pBuf;
            pBufEnd = pBuf + (ULONG_PTR)(dwBufSize); //point pBufEnd to byte after last allocatted byte.

            CompressMode CurrentCMode, PreviousCMode;
            BMPConv BMPC;
            PBYTE pubDst;
            DWORD dwSize;

            LONG lScans,  //number of scan lines stored in pBufOrg
                 lStart;  //From which scan line do we start sending scan lines to printer.
                          //e.g. if lStart=5, it means 0-4 scan lines have been sent, now 5th scan line (and may be more) has to be sent

            #if DBG
            BMPC.SetDbgLevel(BITMAPDBG);
            #endif
            BMPC.BSetInputBPP((BPP)psoSrc->iBitmapFormat);
            BMPC.BSetOutputBPP(NumToBPP(ulOutputBPP));
            BMPC.BSetOutputBMPFormat(OutputF);
            BMPC.BSetXLATEOBJ(pxlo);

            lScanline = lHeight;

            //
            // Set pubSrc
            //
            pubSrc = (PBYTE)psoSrc->pvScan0;
            if (!psoBmp)
            {
                pubSrc += (LONG_PTR) prclSrc->top * psoSrc->lDelta + ((ulInputBPP * prclSrc->left) >> 3);
            }

            dwcbBmpSize = 0;
            lScans = 0;
            lStart = 0;

            PreviousCMode = eInvalidValue;

            while (lScanline-- > 0)
            {
                PBYTE pubSrcLocal = pubSrc;
            
                //
                // When this is called from TransparentBlt, the Transparent Color 
                // has to be replaced by white. This is to be done only for 
                // direct images, not for paletted images. 
                //
                if ( (pxlpdev->dwFlags & XLPDEV_FLAGS_SUBST_TRNCOLOR_WITH_WHITE)  &&
                      eDirectPixel == CMapping )
                {
                    hRet = hrChangePixelColorInScanLine( pubSrc,
                                                       ulInputBPP,
                                                       lWidth,
                                                       pxlpdev->ulTransColor,
                                                       pubChanged,
                                                       dwcbLineSize); 
                    if ( FAILED (hRet) )
                    {
                        goto ErrorReturn;
                    }

                    pubSrcLocal = pubChanged;

                }

                //
                // First try compression and see if the compress data is smaller
                // than the original data. If it's smaller, go ahead to use the
                // compression. Otherwise, use original data.
                //
                // While it is permitted to mix eRLECompression and eNoCompression
                // blocks of ReadImage data, XL does not allow mixing JPEG or 
                // DeltaRow image blocks with any other compression method.
                //

                //
                // DRC Compression
                //
                if (COMMANDPTR(((PPDEV)pdevobj)->pDriverInfo,CMD_ENABLEDRC))
                {
                    CurrentCMode = eDeltaRowCompression;
                    BMPC.BSetCompressionType(CurrentCMode);
                    pubDst = BMPC.PubConvertBMP(pubSrcLocal, dwcbLineSize);
                    dwSize = BMPC.DwGetDstSize();
                    VERBOSE(("CommonRopBlt: Comp(DRC:0x%x)\n", dwSize));
                }
                else
                {
                    //
                    // RLE compression
                    //
                    BMPC.BSetCompressionType(eRLECompression);
                    pubDst = BMPC.PubConvertBMP(pubSrcLocal, dwcbLineSize);
                    dwSize = BMPC.DwGetDstSize();
                    VERBOSE(("CommonRopBlt: Comp(RLE:0x%x)\n", dwSize));

                    if (dwSize < dwcbLineSize)
                    {
                        CurrentCMode = eRLECompression;
                    }
                    else
                    {
                        CurrentCMode = eNoCompression;
                        BMPC.BSetCompressionType(eNoCompression);
                        pubDst = BMPC.PubConvertBMP(pubSrcLocal, dwcbLineSize);
                        dwSize = BMPC.DwGetDstSize();
                        VERBOSE(("CommonRopBlt: Comp(NO:0x%x)\n", dwSize));
                    }
                }

                //
                // Output bitmap.
                // 1. Mostly we try to store the data bits in pBufOrg and send them
                // all at once after processing has been done on the full image.
                // This storage is done on a per scan line basis.
                // But if image is really big, pBufOrg gets filled up and more
                // scan lines cannot be copied. So we empty pBufOrg to make place
                // for remaining scan lines. If either of these is true, pBufOrg
                // needs to be flushed. (Both these conditions are essentially the same).
                //      dwcbBmpSize + dwSize > dwBufSize 
                //      pBuf + dwSize > pBufEnd          
                //
                // 2. If the compression has to change, we dump the data bits
                //    using the older compression method that have been stored in 
                //    pBufOrg and/or pbDst.
                //

                if (dwcbBmpSize + dwSize > dwBufSize ||
                     PreviousCMode != eInvalidValue && PreviousCMode != CurrentCMode)
                {
                    if (PreviousCMode == eInvalidValue)
                    {
                        PreviousCMode = CurrentCMode;
                    }

                    //
                    // Four possible cases
                    //  1&2. dwcbBmpSize == 0 i.e. nothing is present in pBufOrg
                    //     So just dump whatever is present in pubDst.
                    //     This covers both cases i.e. whether dwSize > dwBufSize or not.
                    //  3. dwcmBmpSize is not zero 
                    //       dump the image in pBufOrg, clean pBufOrg, and then later
                    //       on put the contents of pubDst in pBufOrg(pBuf).
                    //  4. dwcbBmpSize is not zero and dwSize > dwBufSize
                    //      i.e. somehow the compression caused the size of the 
                    //      scan line to increase beyond the dwBufSize.
                    //      Because pBufOrg is at most dwBufSize, we cannot
                    //      copy pubDst to pBufOrg. So we have to dump pubDst here.
                    //

                    if (dwcbBmpSize == 0)
                    {
                        //
                        // Case 1&2
                        //
                        BSendReadImageData(pdevobj,
	                                       PreviousCMode,
	                                       pubDst,
	                                       lStart,
	                                       1,
	                                       dwSize);
                        dwSize = 0;
                        lStart++; //One line emitted. Therefore increment lStart
                    }
                    else
                    {
                        //
                        // There is some image data stored in the pBufOrg buffer.
                        // Emit that data. (case 3)
                        //
                        BSendReadImageData(pdevobj,
                                           PreviousCMode,
                                           pBufOrg,
                                           lStart,
                                           lScans,
                                           dwcbBmpSize);
                        lStart += lScans; //lScans lines emitted

                        if ( dwSize > dwBufSize )
                        {
                            //
                            // Case 4.
                            //
                            BSendReadImageData(pdevobj,
                                               PreviousCMode,
                                               pubDst,
                                               lStart,
                                               1,
                                               dwSize);
                            dwSize = 0;
                            lStart++;
                        }

                    }

                    //
                    // Reset parameters
                    //
                    dwcbBmpSize = 0;
                    lScans = 0;
                    pBuf = pBufOrg;

                }

                if (NULL == pubDst)
                {
                    ERR(("CommonRopBlt: Conversion failed. pubDst is NULL.\n"));
                    goto ErrorReturn;
                }

                //
                // If post-compression size of image is more than zero, AND
                // if destination buffer(pBuf) has enough space, then copy the compressed
                // data to the destination. (Data can also be in uncompressed format if
                // compression does not result in size saving).
                // Increment lScans to indicicate that we are putting one more scan 
                // line worth of data in pBufOrg
                //
                if (dwSize > 0 && 
                    pBuf + dwSize <= pBufEnd) 
                {
                    memcpy(pBuf, pubDst, dwSize);
                    dwcbBmpSize += dwSize;
                    pBuf += dwSize;
                    lScans ++;
                }

                PreviousCMode = CurrentCMode;

                if (CurrentCMode == eNoCompression)
                {
                    DWORD dwDiff = (((lWidth * ulOutputBPP + 31) >> 5) << 2) - dwSize;
                    if (dwDiff)
                    {
                        memset(pBuf, 0, dwDiff);
                        dwcbBmpSize += dwDiff;
                        pBuf += dwDiff;
                    }
                }


                pubSrc += psoSrc->lDelta;
            }

            if (dwcbBmpSize > 0)
            {
                BSendReadImageData(pdevobj, CurrentCMode, pBufOrg, lStart, lScans, dwcbBmpSize);
            }
            pOutput->Send_cmd(eEndImage);
            pOutput->Flush(pdevobj);
        }

ErrorReturn:
        if (pBufOrg != NULL)
            MemFree(pBufOrg);

        if ( NULL != pubChanged )
        {
            MemFree(pubChanged);
        }

        if (NULL != psoBmp)
        {
            EngUnlockSurface(psoBmp);
            if (hBitmap && !EngDeleteSurface((HSURF)hBitmap))
            {
                ERR(("CommonRopBlt: EngDeleteSurface failed.\n"));
                hRet = FALSE;
            }
        }
    }

    return hRet;
}

BOOL
BSendReadImageData(
    IN PDEVOBJ pdevobj,
    IN CompressMode CMode,
    IN PBYTE   pBuf,
    IN LONG    lStart,
    IN LONG    lHeight,
    IN DWORD   dwcbSize)
{
    VERBOSE(("BSendReadImageData(CMode=%d, lHeight=0x%x, dwcbSize=0x%x\n", CMode, lHeight, dwcbSize));
    //
    // dataLength (1)
    // size (byte or long) (1 or 4)
    // 
    DWORD dwHeaderSize;
    BYTE aubHeader[DATALENGTH_HEADER_SIZE];
    PXLPDEV pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    XLOutput *pOutput = pxlpdev->pOutput;
    //
    // Print the converted data.
    //
    pOutput->ReadImage(lStart, lHeight, CMode);
    pOutput->Flush(pdevobj);

    if (dwcbSize > 0xff)
    {
        //
        // dataLength
        // size (uin32) (bitmap size)
        //
        aubHeader[0] = PCLXL_dataLength;
        dwHeaderSize = DATALENGTH_HEADER_SIZE;
        CopyMemory(aubHeader + 1, &dwcbSize, sizeof(dwcbSize));
    }
    else
    {
        //
        // dataLength
        // size (byte) (bitmap size)
        //
        aubHeader[0] = PCLXL_dataLengthByte;
        dwHeaderSize = DATALENGTH_HEADER_SIZE - 3;
        CopyMemory(aubHeader + 1, &dwcbSize, sizeof(BYTE));
    }

    //
    // dataLength
    // size (byte/uint32)
    // DATA
    // EndImage
    //
    WriteSpoolBuf((PPDEV)pdevobj, aubHeader, dwHeaderSize);
    WriteSpoolBuf((PPDEV)pdevobj, pBuf, dwcbSize);

    return TRUE;
}

inline
VOID
DetermineOutputFormat(
    XLATEOBJ    *pxlo,
    ColorDepth   DeviceColorDepth,
    INT          iBitmapFormat,
    OutputFormat *pOutputF,
    ULONG        *pulOutputBPP)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    switch ((BPP)iBitmapFormat)
    {
    case e1bpp:
    case e4bpp:
        *pOutputF = eOutputPal;
        break;

    case e8bpp:
    case e16bpp:
        //
        // Color device or not?
        //
        if (DeviceColorDepth == e24Bit)
            *pOutputF = eOutputPal;
        else
            *pOutputF = eOutputGray;
        break;

    case e24bpp:
    case e32bpp:
        //
        // Color device or not?
        //
        if (DeviceColorDepth == e24Bit)
            *pOutputF = eOutputRGB;
        else
            *pOutputF = eOutputGray;
        break;
    }

    switch (*pOutputF)
    {
    case eOutputGray:
        *pulOutputBPP = 8;
        break;

    case eOutputPal:
        *pulOutputBPP = UlBPPtoNum((BPP)iBitmapFormat);
        break;

    case eOutputRGB:
    case eOutputCMYK:
        *pulOutputBPP = 24;
        break;
    }

    //
    // Make sure that color table is available for palette output.
    //
    if (*pOutputF == eOutputPal)
    {
        if (!(GET_COLOR_TABLE(pxlo)))
        {
            if (DeviceColorDepth == e24Bit)
            {
                *pOutputF = eOutputRGB;
                *pulOutputBPP = 24;
            }
            else
            {
                *pOutputF = eOutputGray;
                *pulOutputBPP = 8;
            }
        }
    }
}

PDWORD
PdwChangeTransparentPalette(
    ULONG  iTransColor,
    PDWORD pdwColorTable,
    DWORD  dwEntries)
/*++

Routine Description:
    Creates another copy of palatte and replace the transparent color by white
    Returns the pointer of a new palette.
    The calling function has responsibility to release the palette.

Arguments:


Return Value:


Note:


--*/
{
    PDWORD pdwNewPalette = NULL;

    //
    // Parameter check
    //
    if (NULL == pdwColorTable ||
        dwEntries == 0         )
    {
        return NULL;
    }

    if (NULL == (pdwNewPalette = (PDWORD)MemAlloc(sizeof(DWORD) * dwEntries)))
    {
        return NULL;
    }

    CopyMemory(pdwNewPalette, pdwColorTable, sizeof(DWORD) * dwEntries);

    //
    // When printing in palette mode, iTransColor indicates the index into
    // the palette, instead of the color in the palette. The palette entry 
    // at that index is the color.
    //
    pdwNewPalette[iTransColor] = RGB_WHITE;


    return pdwNewPalette;
}


/*++

Routine Name
    hrChangePixelColorInScanLine

Routine Description:
    Changes the pixels in scan line that match a certain color to White 

Arguments:
    pubSrc      : The original scan line.
    ulBPP       : Bits Per Pixel of scan line.
    ulNumPixels : Number of Pixels in the scan line.
    ulTransColor: The color that needs to be changed.
    pubChanged  : The memory where the new(changed) scan line should be put.
    ulNumBytes  : Number of bytes in pubChanged buffer.

Return Value:
    S_OK   : if success  
    E_FAIL: Otherwise


Note:


--*/
HRESULT hrChangePixelColorInScanLine( 
    IN      PBYTE pubSrc,  
    IN      ULONG ulBPP,
    IN      ULONG ulNumPixels,
    IN      ULONG ulTransColor,
    IN OUT  PBYTE pubChanged, 
    IN      ULONG ulNumBytes )//NumBytes in pubChanged
    
{

    ULONG   ulBytesPerPixel = 3; //24bpp is more common that 16 or 32bpp
    ULONG   ulColor         = 0;
    ULONG   ulDestSize      = 0; //Required destination number of bytes.
    HRESULT hr              = S_OK;

    //
    // First do input validation
    //
    if ( NULL == pubSrc     ||
         NULL == pubChanged )
    {
        ASSERT(("Null Parameter\n"));
        return E_UNEXPECTED;
    }

    //
    // Make sure pubChanged has enough memory to hold 
    // the changed scan line.
    //

    ulBytesPerPixel = ulBPP >> 3; //8 bits per pixel.
    ulDestSize      = ulBytesPerPixel * ulNumPixels;
    
    if ( ulNumBytes < ulDestSize )
    {
        ASSERT((FALSE, "Insufficient size of destination buffer\n"));
        return E_FAIL;
    }

    //
    // Copy Scanline from Source to Destination. Then go through the scan line and
    // change the transparent color to white
    // Go through each pixel (there are ulNumPixels pixels).
    // Whenever the pixels's color is same as ulTransColor, replace it
    // with white. 
    //
    // Only direct images are supported in this function.
    // No palletes.
    // 8bpp images are mostly palettes. But when printing to monochrome
    // pclxl device, they are being treated as direct images.
    //
    CopyMemory (pubChanged, pubSrc, ulNumBytes);

    switch (ulBPP)
    {
        case 8:
        {
            for (ULONG ul = 0; ul < ulNumPixels ; ul++, pubChanged += ulBytesPerPixel)
            {
                ulColor = (ULONG) pubChanged[0] ;

                if ( ulTransColor == ulColor )
                {
                    pubChanged[0]   = 0xFF;
                }
            }
        }
        break;

        case 16:
        {
            for (ULONG ul = 0; ul < ulNumPixels ; ul++, pubChanged += ulBytesPerPixel)
            {
                ulColor = ((ULONG) pubChanged[0]) | ((ULONG) pubChanged[1] <<  8);

                if ( ulTransColor == ulColor )
                {
                    pubChanged[0]   = 0xFF;
                    pubChanged[1]   = 0xFF;
                }
            }
        }
        break;

        case 24:
        {

            for (ULONG ul = 0; ul < ulNumPixels ; ul++, pubChanged += ulBytesPerPixel)
            {
                ulColor = ((ULONG) pubChanged[0])       | 
                          ((ULONG) pubChanged[1] <<  8) | 
                          ((ULONG) pubChanged[2] << 16);

                if ( ulTransColor == ulColor )
                {
                    //
                    // White is 0xFFFFFF (3 bytes of FF)
                    //
                    pubChanged[0]   = 0xFF;
                    pubChanged[1]   = 0xFF;
                    pubChanged[2]   = 0xFF;
                }
            }
        }
        break;

        case 32:
        {
            for (ULONG ul = 0; ul < ulNumPixels ; ul++, pubChanged += ulBytesPerPixel)
            {
                ulColor = *(PDWORD)pubChanged;
                if ( ulTransColor == ulColor )
                {
                    *(PDWORD)pubChanged |= 0x00FFFFFF; //This modifies only RGB. Alpha channel info retained.
                }
            }
        }
        break;

        default:
            ASSERT((FALSE, "Unsupported bpp value %d\n", ulBPP));
            hr = E_FAIL;

        } //switch

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\text.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    text.cpp

Abstract:

    font/text output handling functions implementation

Environment:

    Windows Whistler

Revision History:

    04/6/99     
        Created initial framework.

--*/

#include "lib.h"
#include "gpd.h"
#include "winres.h"
#include "pdev.h"
#include "common.h"
#include "..\..\font\font.h"
#include "xlpdev.h"
#include "xldebug.h"
#include <assert.h>
#include "pclxlcmd.h"
#include "pclxle.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "xltext.h"
#include "xlbmpcvt.h"
#include "pclxlcmn.h"
#include "xltt.h"
#include "math.h"

//
// TrueType outline format switch
//
#define CLASS12 1

#define COMPGLYF 1

//
// Local functions prototypes
//

DWORD
DwDownloadCompositeGlyph(
    PDEVOBJ pdevobj,
    ULONG ulFontID,
    PGLYF pGlyph);

BOOL
BDownloadGlyphData(
    PDEVOBJ  pdevobj,
    ULONG    ulFontID,
    DWORD    dwGlyphID,
    HGLYPH   hGlyph,
    PBYTE    pubGlyphData,
    DWORD    dwGlyphDataSize,
    BOOL     bSpace);

extern "C" HRESULT APIENTRY
PCLXLDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult);

//
// XL Text entry point
//

extern "C" BOOL APIENTRY
PCLXLTextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:

    IPrintOemUni TextOutAsBitmap interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLTextOutAsBitmap() entry.\r\n"));

    PDEVOBJ  pdevobj  = (PDEVOBJ)pso->dhpdev;
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    GLYPHPOS *pGlyphPos;
    PATHOBJ   *pPathObj;
    GLYPHBITS   *pGlyphBits;
    GLYPHDATA   *pGlyphData;

    HRESULT   hResult;
    ULONG     ulJ, ulGlyphs, ulCount, ulcbBmpSize, ulcbLineAlign, ulcbLineSize;
    LONG      lI;
    BOOL      bMore;
    PBYTE     pubBitmap;
    BYTE      aubDataHdr[8];
    BYTE      aubZero[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    DWORD     adwColorTable[2];
    DWORD     dwDataHdrSize;

    if (pstro->cGlyphs == 0)
    {
        VERBOSE(("PCLXLTextOutAsBitmap: cGlyphs = 0\n"));
        return TRUE;
    }

    XLOutput *pOutput = pxlpdev->pOutput;

    //
    // UNIDRV switchs the format of font in the middle of downloading
    // character glyphs. We need to end the BeginChar sequence.
    //
    if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
    {
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        pOutput->Send_cmd(eEndChar);
    }

    ROP4 rop = UlVectMixToRop4(mix);

    if ( S_OK != pOutput->SetClip(pco) ||
         S_OK != pOutput->SetPenColor(NULL, NULL) ||
         S_OK != pOutput->Flush(pdevobj))
        return FALSE;

    STROBJ_vEnumStart(pstro);

    do 
    {
        bMore = STROBJ_bEnum (pstro, &ulGlyphs, &pGlyphPos);

        if (bMore == DDI_ERROR)
        {
            return FALSE;
        }

        for (ulCount = 0; ulCount < ulGlyphs; ulCount++, pGlyphPos++)
        {
            //
            // get the path of the glyph from the FONTOBJ
            //
            if (!FONTOBJ_cGetGlyphs (pfo,
	     FO_PATHOBJ,
	     1,
	     &pGlyphPos->hg, 
	     (PVOID *)&pPathObj))
            {
                ERR(("PCLXLTextOutAsBitmap: cGetGlyphs failed\n"));
                hResult = S_FALSE;
            }
            else
            {
                if (S_OK == pOutput->Send_cmd(ePushGS) &&
                    S_OK == pOutput->SetBrush(pboFore, pptlOrg) &&
                    S_OK == pOutput->SetPageOrigin((uint16)pGlyphPos->ptl.x,
	                   (uint16)pGlyphPos->ptl.x) &&
                    S_OK == pOutput->Path(pPathObj) &&
                    S_OK == pOutput->Paint() &&
                    S_OK == pOutput->Send_cmd(ePopGS))
                    hResult = S_OK;
                else
                    hResult = S_FALSE;
            }

            if (hResult == S_FALSE)
            {
                pOutput->Delete();

                adwColorTable[1] = 0x00FFFFFF;

                if (pboFore)
                {
                    if (pboFore->iSolidColor == NOT_SOLID_COLOR)
                    {
                        adwColorTable[0] = BRUSHOBJ_ulGetBrushColor(pboFore);
                    }
                    else
                    {
                        adwColorTable[0] = pboFore->iSolidColor;
                    }
                }
                else
                    adwColorTable[0] = 0x00000000;

                //
                // get the path of the glyph from the FONTOBJ
                //
                if (!FONTOBJ_cGetGlyphs (pfo,
                                         FO_GLYPHBITS,
                                         1,
                                         &pGlyphPos->hg, 
                                         (PVOID *)&pGlyphData))
                {
                    ERR(("PCLXLTextOutAsBitmap: cGetGlyphs failed\n"));
                    return FALSE;
                }

                pGlyphBits = pGlyphData->gdf.pgb;
                ulcbLineSize = (pGlyphBits->sizlBitmap.cx + 7) >> 3;
                ulcbLineAlign = (sizeof(DWORD) - ulcbLineSize % sizeof(DWORD)) % sizeof(DWORD);
                ulcbBmpSize = (ulcbLineSize + ulcbLineAlign) * pGlyphBits->sizlBitmap.cy;
                if (ulcbBmpSize <= 0xff)
                {
                    aubDataHdr[0] = PCLXL_dataLengthByte;
                    aubDataHdr[1] = (BYTE)(ulcbBmpSize & 0xff);
                    dwDataHdrSize = 2;
                }
                else
                {
                    aubDataHdr[0] = PCLXL_dataLength;
                    aubDataHdr[1] = (BYTE)(ulcbBmpSize & 0xff);
                    aubDataHdr[2] = (BYTE)((ulcbBmpSize >> 8) & 0xff);
                    aubDataHdr[3] = (BYTE)((ulcbBmpSize >> 16) & 0xff);
                    aubDataHdr[4] = (BYTE)((ulcbBmpSize >> 24) & 0xff);
                    dwDataHdrSize = 5;
                }

                //
                // Hack ROP for Print As Graphics
                //
                rop = 0xFC;

                if (S_OK == pOutput->SetCursor(pGlyphPos->ptl.x + pGlyphBits->ptlOrigin.x,
	               pGlyphPos->ptl.y + pGlyphBits->ptlOrigin.y) &&
                    S_OK == pOutput->SetROP3(GET_FOREGROUND_ROP3(rop)) &&
                    S_OK == pOutput->SetPaintTxMode(eOpaque) &&
                    S_OK == pOutput->SetSourceTxMode(eTransparent))
                {
                    hResult = S_OK;
                }
                else
                {
                    hResult = S_FALSE;
                }

                if (pOutput->GetDeviceColorDepth() != e24Bit)
                {
                    if (S_OK == hResult &&
                        S_OK == pOutput->SetColorSpace(eGray) &&
                        S_OK == pOutput->Send_cmd(eSetColorSpace) &&
                        S_OK == pOutput->SetBrush(pboFore, pptlOrg) &&
                        S_OK == pOutput->SetOutputBPP(eDirectPixel, 1))
                    {
                        hResult = S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                    }
                }
                else
                {
                    if (S_OK == hResult &&
                        S_OK == pOutput->SetColorSpace(eRGB) &&
                        S_OK == pOutput->SetPaletteDepth(e8Bit) &&
                        S_OK == pOutput->SetPaletteData(pOutput->GetDeviceColorDepth(), 2, adwColorTable) &&
                        S_OK == pOutput->Send_cmd(eSetColorSpace) &&
                        S_OK == pOutput->SetOutputBPP(eIndexedPixel, 1))
                    {
                        hResult = S_OK;
                    }
                    else
                    {
                        hResult = S_FALSE;
                    }
                }

                if (S_OK == hResult &&
                    S_OK == pOutput->SetSourceWidth((uint16)pGlyphBits->sizlBitmap.cx) &&
                    S_OK == pOutput->SetSourceHeight((uint16)pGlyphBits->sizlBitmap.cy) &&
                    S_OK == pOutput->SetDestinationSize((uint16)pGlyphBits->sizlBitmap.cx,
                                               (uint16)pGlyphBits->sizlBitmap.cy) &&
                    S_OK == pOutput->Send_cmd(eBeginImage) &&
                    S_OK == pOutput->ReadImage(pGlyphBits->sizlBitmap.cy, eNoCompression) &&
                    S_OK == pOutput->Flush(pdevobj))
                    hResult = S_OK;
                else
                    hResult = S_FALSE;

                WriteSpoolBuf((PPDEV)pdevobj, aubDataHdr, dwDataHdrSize);

                pubBitmap = pGlyphBits->aj;

                //
                // Bitmap data has to be DWORD-align.
                //
                // Invert bitmap
                //
                for (lI = 0; lI < pGlyphBits->sizlBitmap.cy; lI ++)
                {
                    for (ulJ = 0; ulJ < ulcbLineSize; ulJ++)
                    {
                        *(pubBitmap+ulJ) = ~*(pubBitmap+ulJ);
                    }
                    WriteSpoolBuf((PPDEV)pdevobj, pubBitmap, ulcbLineSize);
                    pubBitmap += ulcbLineSize;
                    WriteSpoolBuf((PPDEV)pdevobj, aubZero, ulcbLineAlign);
                }

                if (S_OK == hResult &&
                    S_OK == pOutput->Send_cmd(eEndImage) &&
                    S_OK == pOutput->Flush(pdevobj))
                    hResult = S_OK;
                else
                    hResult = S_FALSE;
            }
            else
                hResult = pOutput->Flush(pdevobj);

        }
    }
    while (bMore && hResult == S_OK);

    if (S_OK == hResult)
        return TRUE;
    else
        return FALSE;
}


extern "C" HRESULT APIENTRY
PCLXLDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadFontHeader interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLDownloadFontHeader() entry.\r\n"));

    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;

    HRESULT hResult;

    if (NULL == pxlpdev)
    {
        ERR(("PCLXL:DownloadFontHeader Invalid pdevOEM.\r\n"));
        return S_FALSE;
    }

    //
    // UNIDRV switchs the format of font in the middle of downloading
    // character glyphs. We need to end the BeginChar sequence.
    //
    if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
    {
        XLOutput *pOutput = pxlpdev->pOutput;
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        pOutput->Send_cmd(eEndChar);
    }

    if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
    {
        VERBOSE(("PCLXLDownloadFontHeader() BITMAP.\n"));

        //
        // Get current text resolution
        //
        if (pxlpdev->dwTextRes == 0)
        {
            GETINFO_STDVAR StdVar;
            DWORD dwSizeNeeded;

            StdVar.dwSize = sizeof(GETINFO_STDVAR);
            StdVar.dwNumOfVariable = 1;
            StdVar.StdVar[0].dwStdVarID = FNT_INFO_TEXTYRES;
            StdVar.StdVar[0].lStdVariable  = 0;
            pUFObj->pfnGetInfo(pUFObj,
                               UFO_GETINFO_STDVARIABLE,
                               &StdVar,
                               StdVar.dwSize,
                               &dwSizeNeeded);

            pxlpdev->dwTextRes    = StdVar.StdVar[0].lStdVariable;
        }

        //
        // PCL XL FontHeader initialization
        // Get the max character number from GPD file.
        //
        PCLXL_FONTHEADER   PCLXLFontHeader;
        PCLXLFontHeader.ubFormat           = 0;
        PCLXLFontHeader.ubOrientation      = ePortraitOrientation;
        PCLXLFontHeader.wMapping           = 0x0200;
        PCLXLFontHeader.ubFontScallingTech = eBitmap;
        PCLXLFontHeader.ubVariety          = 0;
        PCLXLFontHeader.wNumOfChars        = SWAPW(1+((PPDEV)pdevobj)->pGlobals->dwMaxGlyphID - ((PPDEV)pdevobj)->pGlobals->dwMinGlyphID);

        //
        // BR Segment initialization
        //
        PCLXL_BR_SEGMENT   PCLXLBRSegment;
        PCLXLBRSegment.wSignature         = PCLXL_BR_SIGNATURE;
        PCLXLBRSegment.wSegmentSize       = 0;
        PCLXLBRSegment.wSegmentSizeAlign  = SWAPW(PCLXL_BR_SEGMENT_SIZE);
        PCLXLBRSegment.wXResolution       = SWAPW(pxlpdev->dwTextRes);
        PCLXLBRSegment.wYResolution       = SWAPW(pxlpdev->dwTextRes);

        //
        // NULL Segment initialization
        //
        PCLXL_NULL_SEGMENT PCLXLNULLSegment;
        PCLXLNULLSegment.wSignature        = PCLXL_NULL_SIGNATURE;
        PCLXLNULLSegment.wSegmentSize      = 0;
        PCLXLNULLSegment.wSegmentSizeAlign = 0;

        {
            //
            // Output
            //
            XLOutput *pOutput = pxlpdev->pOutput;

            //
            // BeginFontHeader
            //

            pOutput->Send_ubyte(0);
            pOutput->Send_attr_ubyte(eFontFormat);
            pOutput->Send_ubyte_array_header(16);
            pOutput->Write(PubGetFontName(pdevobj, pUFObj->ulFontID), PCLXL_FONTNAME_SIZE);
            pOutput->Send_attr_ubyte(eFontName);
            pOutput->Send_cmd(eBeginFontHeader);

            //
            // ReadFontHeader
            //
            uint32   uint32_FontHeaderSize;
            uint32_FontHeaderSize = sizeof(PCLXLFontHeader);

            pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
            pOutput->Send_attr_ubyte(eFontHeaderLength);
            pOutput->Send_cmd(eReadFontHeader);
            pOutput->WriteByte(PCLXL_dataLengthByte);
            pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
            pOutput->Write((PBYTE)&PCLXLFontHeader, uint32_FontHeaderSize);

            uint32_FontHeaderSize = sizeof(PCLXLBRSegment);
            pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
            pOutput->Send_attr_ubyte(eFontHeaderLength);
            pOutput->Send_cmd(eReadFontHeader);
            pOutput->WriteByte(PCLXL_dataLengthByte);
            pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
            pOutput->Write((PBYTE)&PCLXLBRSegment, uint32_FontHeaderSize);

            uint32_FontHeaderSize = sizeof(PCLXLNULLSegment);
            pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
            pOutput->Send_attr_ubyte(eFontHeaderLength);
            pOutput->Send_cmd(eReadFontHeader);
            pOutput->WriteByte(PCLXL_dataLengthByte);
            pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
            pOutput->Write((PBYTE)&PCLXLNULLSegment, uint32_FontHeaderSize);

            //
            // EndFontHeader
            //
            pOutput->Send_cmd(eEndFontHeader);

            pOutput->Flush(pdevobj);
        }

        *pdwResult = sizeof(PCLXL_FONTHEADER)  +
                     sizeof(PCLXL_BR_SEGMENT)  +
                     sizeof(PCLXL_NULL_SEGMENT);
        hResult = S_OK;
    }
    else
    if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
    {
        VERBOSE(("PCLXLDownloadFontHeader() OUTLINE.\n"));

        //
        // Get FONTOBJ
        //
        FONTOBJ *pFontObj;
        if (S_OK != GetFONTOBJ(pdevobj, pUFObj, &pFontObj))
        {
            ERR(("PCLXL:DownloadFontHeader UFO_GETINFO_FONTOBJ failed.\r\n"));
            return E_UNEXPECTED;
        }

        //
        // ASSUMPTION: pxlpdev->pTTFile is initialized in EnablePDEV.
        //             The pointer is always available.
        //
        XLTrueType *pTTFile = pxlpdev->pTTFile;
        if (S_OK != pTTFile->SameFont(pFontObj))
        {
            if (S_OK != pTTFile->OpenTTFile(pFontObj))
            {
                ERR(("PCLXL:DownloadFontHeader XLTrueType>OpenTTFile failed.\r\n"));
                return E_UNEXPECTED;
            }
        }
        else
            pTTFile = pxlpdev->pTTFile;

        //
        // PCL XL FontHeader initialization
        // Get the max character number from GPD file.
        //
        PCLXL_FONTHEADER   PCLXLFontHeader;
        PCLXLFontHeader.ubFormat           = 0;
        PCLXLFontHeader.ubOrientation      = ePortraitOrientation;
        PCLXLFontHeader.wMapping           = 0x0200;
        PCLXLFontHeader.ubFontScallingTech = eTrueType;
        PCLXLFontHeader.ubVariety          = 0;
        PCLXLFontHeader.wNumOfChars        = SWAPW(1+((PPDEV)pdevobj)->pGlobals->dwMaxGlyphID - ((PPDEV)pdevobj)->pGlobals->dwMinGlyphID);

        //
        // PCL XL GT Table Directory
        //
        PTTDIR pTableDir;
        TTTag tag;
        DWORD dwI, dwTableOffset, dwNumTag, dwGTSegSize, dwDWAlign, dwTableSize;

        //
        // GetNumOfTag returns 11 tags including loca table.
        // Header requires
        //              head
        //              maxp
        //              gdir
        //              hhea (only for class 0)
        //              hmtx (only for class 0)
        //              vhea (only for vertical font and class 0)
        //              vmtx (only for vertical font and class 0)
        //
        // Optional
        //              cvt
        //              fpgm
        //              perp
        //
        // We need to get the number of Tag to download.
        // XLTrueType object caches available table directories includeing loca
        // table. Here we go through the cached table to see if which one of
        // above table is available.
        //
        // See truetype.h
        // TagID_first = 0. TagID_First is the number of tags which are used for
        // font header.
        //

        dwNumTag = 0;
        dwGTSegSize = 0;

        PCLXL_GT_TABLE_DIR PCLXLGTTblDir[TagID_Header];
        for (dwI = (USHORT)TagID_First; dwI < (USHORT)TagID_Header; dwI ++)
        {
            //
            // Check a table for the tag is available in the TrueType font.
            //
            tag = TTTag_INVALID;
            pTableDir = NULL;

#if CLASS12
            //
            // Support only Class 1 and Class 2
            //
            if (dwI == TagID_hhea || dwI == TagID_hmtx ||
                dwI == TagID_vhea || dwI == TagID_vmtx  )
            {
                continue;
            }
#else
            //
            // Support Class 1 and Class 2 for horizontal font.
            // Class 0 for vertical font. PCL XL interpreter doesn't work fine.
            //
            if (S_OK != pTTFile->IsVertical())
            {
                if (dwI == TagID_hhea || dwI == TagID_hmtx ||
                    dwI == TagID_vhea || dwI == TagID_vmtx  )
                {
                    continue;
                }
            }
#endif

            if (S_OK == pTTFile->TagAndID(&dwI, &tag) &&
                S_OK == pTTFile->GetTableDir(tag, (PVOID*)&pTableDir))
            {
                //
                // dwTableOffset is an offset from the top of the TrueType
                // Soft Font Directory Header to the start of the table data in
                // the PCL XL embedded data stream.
                //
                if (pTableDir)
                {
                    PCLXLGTTblDir[dwNumTag].dwTableTag      = pTableDir->ulTag;
                    //PCLXLGTTblDir[dwNumTag].dwTableCheckSum = pTableDir->ulCheckSum;
                    PCLXLGTTblDir[dwNumTag].dwTableCheckSum = 0;
                    PCLXLGTTblDir[dwNumTag].dwTableOffset   = 0;

                    //
                    // DWORD alignment
                    //
                    dwTableSize = SWAPDW(pTableDir->ulLength);
                    dwTableSize = ((dwTableSize + 3) >> 2) << 2;

                    PCLXLGTTblDir[dwNumTag].dwTableSize     = SWAPDW(dwTableSize);
                }

                dwNumTag ++;
            }
            else
            if (tag == TTTag_gdir)
            {
                //
                // 'gdir' special case.
                //
                PCLXLGTTblDir[dwNumTag].dwTableTag      = TTTag_gdir;
                PCLXLGTTblDir[dwNumTag].dwTableCheckSum = 0;
                PCLXLGTTblDir[dwNumTag].dwTableOffset   = 0;
                PCLXLGTTblDir[dwNumTag].dwTableSize     = 0;
                dwNumTag ++;
            }
        }

        dwGTSegSize = sizeof(PCLXL_GT_TABLE_DIR_HEADER) +
                      sizeof(TTDIR) * dwNumTag;
        dwTableOffset = sizeof(PCLXL_GT_TABLE_DIR_HEADER) +
                        dwNumTag * sizeof(TTDIR);

        //
        // Set dwTableOffset in PCLXLGTTblDir
        //
        for (dwI = 0; dwI < dwNumTag; dwI ++)
        {
            //
            // Skip virtual glyph data table (gdir)
            //
            if (PCLXLGTTblDir[dwI].dwTableTag != TTTag_gdir)
            {
                PCLXLGTTblDir[dwI].dwTableOffset = SWAPDW(dwTableOffset);

                dwTableSize = SWAPDW(PCLXLGTTblDir[dwI].dwTableSize);
                dwTableOffset += dwTableSize;
                dwGTSegSize   += dwTableSize;
            }
            else
            {
                //
                // Fill gdir table dir offset
                //
                PCLXLGTTblDir[dwNumTag - 1].dwTableOffset   = 0;
            }

            VERBOSE(("PCLXLDownloadFontHeader:Tag[%d]=%c%c%c%c, Size=0x%0x, Offset=0x%0x\n",
	 dwI,
	 0xff &  PCLXLGTTblDir[dwI].dwTableTag,
	 0xff & (PCLXLGTTblDir[dwI].dwTableTag >> 8),
	 0xff & (PCLXLGTTblDir[dwI].dwTableTag >> 16),
	 0xff & (PCLXLGTTblDir[dwI].dwTableTag >> 24),
	 PCLXLGTTblDir[dwI].dwTableSize,
	 PCLXLGTTblDir[dwI].dwTableOffset));
        }

        //
        // PCL XL GT Segment initialization
        //
        PTTHEADER pTTHeader;
        if (S_OK != pTTFile->GetHeader(&pTTHeader))
        {
            ERR(("PCLXL:DownloadFontHeader XLTTFile::GetHeader failed.\r\n"));
            return S_FALSE;
        }

        PCLXL_GT_SEGMENT PCLXLGTSegment;
        PCLXLGTSegment.wSignature    = PCLXL_GT_SIGNATURE;
        PCLXLGTSegment.wSegmentSize1 = HIWORD(dwGTSegSize);
        PCLXLGTSegment.wSegmentSize1 = SWAPW(PCLXLGTSegment.wSegmentSize1);
        PCLXLGTSegment.wSegmentSize2 = LOWORD(dwGTSegSize);
        PCLXLGTSegment.wSegmentSize2 = SWAPW(PCLXLGTSegment.wSegmentSize2);

        PCLXL_GT_TABLE_DIR_HEADER PCLXLDirHeader;

        //
        // N = Number of Tables
        // Search Range = (maximum power of 2 <= N) * 16
        // Entry Selector = Log2(maximum power of 2 <= N)
        // Range Shift = (N * 16) - Search Range
        //
        WORD wSearchRange, wEntrySelector, wTemp;
        wSearchRange = 2;
        for (wSearchRange = 2; wSearchRange <= dwNumTag; wSearchRange <<= 1);
        wSearchRange >>= 1;

        wTemp = wSearchRange;
        wSearchRange <<= 4;

        for (wEntrySelector = 0; wTemp > 1; wTemp >>= 1, wEntrySelector++);

        //
        // HP Monolithic driver set 'ttcf' in the SFNTVersion.
        //
        {
            HRESULT hRet;
            if (S_OK == (hRet = pTTFile->IsTTC()))
            {
                PCLXLDirHeader.dwSFNTVersion = TTTag_ttcf;
            }
            else if (S_FALSE == hRet)
            {
                PCLXLDirHeader.dwSFNTVersion = pTTHeader->dwSfntVersion;
            }
            else
            {
                ERR(("PCLXL:DownloadFontHeader XLTrueType.IsTTC failed.\r\n"));
                return E_UNEXPECTED;
            }
        }
        PCLXLDirHeader.wNumOfTables  = SWAPW((WORD)dwNumTag);
        PCLXLDirHeader.wSearchRange  = SWAPW(wSearchRange);
        PCLXLDirHeader.wEntrySelector= SWAPW(wEntrySelector);
        PCLXLDirHeader.wRangeShift   = SWAPW((dwNumTag << 4) - wSearchRange);

        //
        // GC Segment initialization
        //
        PCLXL_GC_SEGMENT PCLXLGCSegment;
        PCLXLGCSegment.wSignature        = PCLXL_GC_SIGNATURE;
        PCLXLGCSegment.wSegmentSize      = 0;
        PCLXLGCSegment.wSegmentSizeAlign = SWAPW(PCLXL_GC_SEGMENT_HEAD_SIZE);
        PCLXLGCSegment.wFormat           = 0;
        PCLXLGCSegment.wDefaultGalleyCharacter = 0xFFFF;
        PCLXLGCSegment.wNumberOfRegions  = 0;

        //
        // NULL Segment initialization
        //
        PCLXL_NULL_SEGMENT PCLXLNULLSegment;

        PCLXLNULLSegment.wSignature        = PCLXL_NULL_SIGNATURE;
        PCLXLNULLSegment.wSegmentSize      = 0;
        PCLXLNULLSegment.wSegmentSizeAlign = 0;

        //
        // Output
        //
        *pdwResult = 0;
        XLOutput *pOutput = pxlpdev->pOutput;

        //
        // BeginFontHeader
        //
        pOutput->Send_ubyte(0);
        pOutput->Send_attr_ubyte(eFontFormat);
        pOutput->Send_ubyte_array_header(PCLXL_FONTNAME_SIZE);
        pOutput->Write(PubGetFontName(pdevobj, pUFObj->ulFontID), PCLXL_FONTNAME_SIZE);
        pOutput->Send_attr_ubyte(eFontName);
        pOutput->Send_cmd(eBeginFontHeader);

        //
        // FontHeader
        //
        uint32   uint32_FontHeaderSize;
        uint32_FontHeaderSize = sizeof(PCLXLFontHeader);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLFontHeader, uint32_FontHeaderSize);

        *pdwResult +=  sizeof(PCLXLFontHeader);

        //
        // GT Header
        //
        uint32_FontHeaderSize = sizeof(PCLXL_GT_SEGMENT);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLGTSegment, uint32_FontHeaderSize);

        *pdwResult +=  sizeof(PCLXL_GT_SEGMENT);
        
        //
        // TrueType Softfont Directory Header
        // Table Dir
        //
        uint32_FontHeaderSize = sizeof(PCLXL_GT_TABLE_DIR_HEADER);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLDirHeader, sizeof(PCLXLDirHeader));

        uint32_FontHeaderSize = sizeof(PCLXL_GT_TABLE_DIR) * dwNumTag;
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)PCLXLGTTblDir, sizeof(PCLXL_GT_TABLE_DIR) * dwNumTag);

        pOutput->Flush(pdevobj);
        *pdwResult +=  sizeof(PCLXL_GT_TABLE_DIR);
        
        //
        // Table data
        //

        PBYTE pubData;
        const BYTE  ubNullData[4] = {0, 0, 0, 0};
        for (dwI = (USHORT)TagID_First; dwI < (USHORT)TagID_Header; dwI ++)
        {
#if CLASS12
            //
            // Support only Class 1 and Class 2
            //
            if (dwI == TagID_hhea || dwI == TagID_hmtx ||
                dwI == TagID_vhea || dwI == TagID_vmtx  )
            {
                continue;
            }
#else
            //
            // Support Class 1 and Class 2 for horizontal font.
            // Class 0 for vertical font. PCL XL interpreter doesn't work fine.
            //
            if (S_OK != pTTFile->IsVertical())
            {
                //
                // Support only Class 1 and Class 2
                //
                if (dwI == TagID_hhea || dwI == TagID_hmtx ||
                    dwI == TagID_vhea || dwI == TagID_vmtx  )
                {
                    continue;
                }
            }
#endif
            //
            // Check a table for the tag is available in the TrueType font.
            //
            tag = TTTag_INVALID;
            if (S_OK == pTTFile->TagAndID(&dwI, &tag) &&
                S_OK == pTTFile->GetTable(tag,
	          (PVOID*)&pubData,
	          &uint32_FontHeaderSize))
            {
                VERBOSE(("PCLXLDownloadFontHeader:Tag[%d]=%c%c%c%c\n",
	             dwI,
                                             0xff &  tag,
                                             0xff & (tag >> 8),
                                             0xff & (tag >> 16),
                                             0xff & (tag >> 24)));

                //
                // DWORD alignment
                //
                dwDWAlign =  ((uint32_FontHeaderSize + 3) >> 2) << 2;

                if (dwDWAlign <= 0x2000)
                {
                    pOutput->Send_uint16((uint16)(dwDWAlign));
                    pOutput->Send_attr_ubyte(eFontHeaderLength);
                    pOutput->Send_cmd(eReadFontHeader);

                    if (dwDWAlign <= 0xFF)
                    {
                        pOutput->WriteByte(PCLXL_dataLengthByte);
                        pOutput->WriteByte((ubyte)dwDWAlign);
                    }
                    else
                    {
                        pOutput->WriteByte(PCLXL_dataLength);
                        pOutput->Write((PBYTE)&dwDWAlign, sizeof(uint32));
                    }
                    pOutput->Write(pubData, uint32_FontHeaderSize);
                    if (uint32_FontHeaderSize = dwDWAlign - uint32_FontHeaderSize)
                        pOutput->Write((PBYTE)ubNullData, uint32_FontHeaderSize);
                }
                else
                {
                    DWORD dwRemain = dwDWAlign;
                    DWORD dwx2000 = 0x2000;

                    while (dwRemain >= 0x2000)
                    {
                        pOutput->Send_uint16((uint16)0x2000);
                        pOutput->Send_attr_ubyte(eFontHeaderLength);
                        pOutput->Send_cmd(eReadFontHeader);
                        pOutput->WriteByte(PCLXL_dataLength);
                        pOutput->Write((PBYTE)&dwx2000, sizeof(uint32));
                        pOutput->Write(pubData, dwx2000);
                        dwRemain -= 0x2000;
                        uint32_FontHeaderSize -= 0x2000;
                        pubData += 0x2000;
                    }

                    if (dwRemain > 0)
                    {
                        pOutput->Send_uint16((uint16)dwRemain);
                        pOutput->Send_attr_ubyte(eFontHeaderLength);
                        pOutput->Send_cmd(eReadFontHeader);

                        if (dwRemain <= 0xFF)
                        {
                            pOutput->WriteByte(PCLXL_dataLengthByte);
                            pOutput->WriteByte((ubyte)dwRemain);
                        }
                        else
                        {
                            pOutput->WriteByte(PCLXL_dataLength);
                            pOutput->Write((PBYTE)&dwRemain, sizeof(uint32));
                        }
                        pOutput->Write(pubData, uint32_FontHeaderSize);
                        if (uint32_FontHeaderSize = dwRemain - uint32_FontHeaderSize)
                            pOutput->Write((PBYTE)ubNullData, uint32_FontHeaderSize);
                    }
                }

                *pdwResult += + dwDWAlign;
            }
        }

        //
        // GC segment
        //
        // Current there is no region.
        //
        uint32_FontHeaderSize = sizeof(PCLXLGCSegment) - sizeof(PCLXL_GC_REGION);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLGCSegment, uint32_FontHeaderSize);

        //
        // NULL header
        //
        uint32_FontHeaderSize = sizeof(PCLXLNULLSegment);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLNULLSegment, uint32_FontHeaderSize);

        *pdwResult += sizeof(PCLXLNULLSegment);

        //
        // EndFontHeader
        //
        pOutput->Send_cmd(eEndFontHeader);

        pOutput->Flush(pdevobj);

        //
        // Download special characters.
        //
        {
            //
            // Get glyph data
            //
            PBYTE pubGlyphData;
            DWORD dwGlyphDataSize = 0;
            DWORD dwCompositeDataSize = 0;

            if (S_OK != (hResult = pTTFile->GetGlyphData(0,
	                         &pubGlyphData,
	                         &dwGlyphDataSize)))
            {
                ERR(("PCLXL:DownloadFontHeader GetGlyphData failed.\r\n"));
                return hResult;
            }

            //
            // Composte glyph handling.
            // http://www.microsoft.com/typography/OTSPEC/glyf.htm
            // 
            // Space character can have data the size of which is ZERO!
            // We don't need to return S_FALSE here.
            //

            BOOL bSpace = FALSE;

            if (dwGlyphDataSize != 0 && NULL != pubGlyphData)
            {
                #if COMPGLYF
                if (((PGLYF)pubGlyphData)->numberOfContours == COMPONENTCTRCOUNT)
                {
                    dwCompositeDataSize = DwDownloadCompositeGlyph(
	              pdevobj,
	              pUFObj->ulFontID,
	              (PGLYF)pubGlyphData);
                }
                #endif

            }
            else
            {
                bSpace = TRUE;
            }

            //
            // Download actual 0 glyph data
            //
            if (! BDownloadGlyphData(pdevobj,
	     pUFObj->ulFontID,
	     0xFFFF,
	     0,
	     pubGlyphData,
	     dwGlyphDataSize,
	     bSpace))
            {
                ERR(("PCLXL:DownloadCharGlyph BDownloadGlyphData failed.\r\n"));
                return S_FALSE;
            }

            pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
            pOutput->Send_cmd(eEndChar);
            pOutput->Flush(pdevobj);
        }
    }
    else
        hResult = S_FALSE;

    //
    // Add 1 to TrueType font counter.
    //
    if (hResult == S_OK)
    {
        pxlpdev->dwNumOfTTFont ++;
    }
    return hResult;
}

extern "C" HRESULT APIENTRY
PCLXLDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadCharGlyph interface

Arguments:


Return Value:


Note:


--*/
{
    HRESULT hResult;
    uint32              uint32_datasize;

    VERBOSE(("PCLXLDownloadCharGlyph() entry.\r\n"));

    //
    // Initialize locals
    //
    hResult = E_UNEXPECTED;
    uint32_datasize = 0;

    //
    // Bitmap font download
    //
    if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
    {
        VERBOSE(("PCLXLDownloadCharGlyph() BITMAP.\n"));

        hResult = S_OK;

        //
        // Get glyph data
        //
        GETINFO_GLYPHBITMAP GBmp;
        GLYPHBITS          *pgb;
        DWORD               dwBmpSize;
        WORD                wTopOffset;

        GBmp.dwSize     = sizeof(GETINFO_GLYPHBITMAP);
        GBmp.hGlyph     = hGlyph;
        GBmp.pGlyphData = NULL;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\r\n"));
            return S_FALSE;
        }

        //
        // Initalize header
        //
        PCLXL_BITMAP_CHAR BitmapChar;
        pgb = GBmp.pGlyphData->gdf.pgb;
        wTopOffset = (WORD)(- pgb->ptlOrigin.y);

        BitmapChar.ubFormat    = 0;
        BitmapChar.ubClass     = 0;
        BitmapChar.wLeftOffset = SWAPW(pgb->ptlOrigin.x);
        BitmapChar.wTopOffset  = SWAPW(wTopOffset);
        BitmapChar.wCharWidth  = SWAPW(pgb->sizlBitmap.cx);
        BitmapChar.wCharHeight = SWAPW(pgb->sizlBitmap.cy);

        dwBmpSize = pgb->sizlBitmap.cy * ((pgb->sizlBitmap.cx + 7) >> 3);
        uint32_datasize = dwBmpSize + sizeof(BitmapChar);

        //
        // Output
        //
        PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
        XLOutput *pOutput = pxlpdev->pOutput;

        //
        // BeginChar
        //
        // by GPD

        //
        // BeginChar
        //
        if (!(pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON))
        {
            pxlpdev->dwFlags |= XLPDEV_FLAGS_CHARDOWNLOAD_ON;

            pOutput->Send_ubyte_array_header(PCLXL_FONTNAME_SIZE);
            pOutput->Write(PubGetFontName(pdevobj, pUFObj->ulFontID), PCLXL_FONTNAME_SIZE);
            pOutput->Send_attr_ubyte(eFontName);
            pOutput->Send_cmd(eBeginChar);
        }

        //
        // ReadChar
        //
        pOutput->Send_uint16((uint16)((PPDEV)pdevobj)->dwNextGlyph);
        pOutput->Send_attr_ubyte(eCharCode);
        if (0xFFFF0000 & uint32_datasize)
        {
            pOutput->Send_uint32(uint32_datasize);
        }
        else if (0x0000FF00)
        {
            pOutput->Send_uint16((uint16)uint32_datasize);
        }
        else
        {
            pOutput->Send_ubyte((ubyte)uint32_datasize);
        }
        pOutput->Send_attr_ubyte(eCharDataSize);
        pOutput->Send_cmd(eReadChar);
        
        if (uint32_datasize <= 0xff)
        {
            pOutput->WriteByte(PCLXL_dataLengthByte);
            pOutput->WriteByte((ubyte)uint32_datasize);
        }
        else
        {
            pOutput->WriteByte(PCLXL_dataLength);
            pOutput->Write((PBYTE)&uint32_datasize, sizeof(uint32));
        }
        pOutput->Write((PBYTE)&BitmapChar, sizeof(BitmapChar));
        pOutput->Flush(pdevobj);


        //
        // Direct Write
        //
        WriteSpoolBuf((PPDEV)pdevobj, (PBYTE)pgb->aj, dwBmpSize);

        //
        // EndChar
        // Now EndChar is sent by FlushCachedText
        //pOutput->Send_cmd(eEndChar);

        pOutput->Flush(pdevobj);

        //
        // Get fixed pitch TT width
        //
        pxlpdev->dwFixedTTWidth = (GBmp.pGlyphData->ptqD.x.HighPart + 15) / 16;

        //
        // Set pdwWidth and pdwResult
        //
        *pdwWidth = (GBmp.pGlyphData->ptqD.x.HighPart + 15) >> 4;

        *pdwResult = (DWORD) uint32_datasize;
        VERBOSE(("PCLXLDownloadCharGlyph() Width=%d, DataSize=%d\n", *pdwWidth, uint32_datasize));
    }
    else
    //
    // TrueType outline font download
    //
    if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
    {
        VERBOSE(("PCLXLDownloadCharGlyph() OUTLINE.\n"));

        PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
        FONTOBJ *pFontObj;

        //
        // Get FONTOBJ by calling pUFObj->pfnGetInfo.
        //
        if (S_OK != GetFONTOBJ(pdevobj, pUFObj, &pFontObj))
        {
            ERR(("PCLXL:DownloadCharGlyph UFO_GETINFO_FONTOBJ failed.\r\n"));
            return E_UNEXPECTED;
        }

        //
        // Open get a pointer to memory-maped TrueType.
        //
        // ASSUMPTION: pxlpdev->pTTFile is initialized in EnablePDEV.
        //             The pointer is always available.
        //
        XLTrueType *pTTFile = pxlpdev->pTTFile;
        if (S_OK != pTTFile->SameFont(pFontObj))
        {
            pTTFile->OpenTTFile(pFontObj);
        }
        else
            pTTFile = pxlpdev->pTTFile;

        //
        // Get glyph data
        //
        PBYTE pubGlyphData;
        DWORD dwGlyphDataSize = 0;
        DWORD dwCompositeDataSize = 0;

        if (S_OK != (hResult = pTTFile->GetGlyphData(hGlyph,
                                                     &pubGlyphData,
                                                     &dwGlyphDataSize)))
        {
            ERR(("PCLXL:DownloadCharGlyph GetGlyphData failed.\r\n"));
            return hResult;
        }

        //
        // Composte glyph handling.
        // http://www.microsoft.com/typography/OTSPEC/glyf.htm
        // 
        // Space character can have data the size of which is ZERO!
        // We don't need to return S_FALSE here.
        //
        BOOL bSpace;

        if (dwGlyphDataSize != 0 && NULL != pubGlyphData)
        {
            #if COMPGLYF
            if (((PGLYF)pubGlyphData)->numberOfContours == COMPONENTCTRCOUNT)
            {
                dwCompositeDataSize = DwDownloadCompositeGlyph(
                                          pdevobj,
                                          pUFObj->ulFontID,
                                          (PGLYF)pubGlyphData);
            }
            #endif

            bSpace = FALSE;
        }
        else
        {
            //
            // For space character.
            //
            bSpace = TRUE;
        }

        //
        // Download actual hGlyph's glyph data
        //
        if (! BDownloadGlyphData(pdevobj,
	 pUFObj->ulFontID,
	 ((PDEV*)pdevobj)->dwNextGlyph,
	 hGlyph,
	 pubGlyphData,
	 dwGlyphDataSize,
	 bSpace))
        {
            ERR(("PCLXL:DownloadCharGlyph BDownloadGlyphData failed.\r\n"));
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                XLOutput *pOutput = pxlpdev->pOutput;
                pOutput->Send_cmd(eEndChar);
            }
            return S_FALSE;
        }

        //
        // It's Scalable font. We can't get the width.
        //
        *pdwWidth = 0;

        //
        // Size of memory to be used.
        // There is a case where the size is zero. Add 1 to hack UNIDRV.
        //
        if (bSpace)
        {
            dwGlyphDataSize = 1;
        }

        *pdwResult = (DWORD) dwGlyphDataSize + dwCompositeDataSize;

    }

    return hResult;
}

BOOL
BDownloadGlyphData(
    PDEVOBJ  pdevobj,
    ULONG    ulFontID,
    DWORD    dwGlyphID,
    HGLYPH   hGlyph,
    PBYTE    pubGlyphData,
    DWORD    dwGlyphDataSize,
    BOOL     bSpace)
{
    PCLXL_TRUETYPE_CHAR_C0 OutlineCharC0;
    PCLXL_TRUETYPE_CHAR_C1 OutlineCharC1;
    PCLXL_TRUETYPE_CHAR_C2 OutlineCharC2;
    uint32              uint32_datasize;

    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    XLTrueType *pTTFile = pxlpdev->pTTFile;
    XLOutput *pOutput = pxlpdev->pOutput;

    if (!(pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON))
    {
        pxlpdev->dwFlags |= XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        pOutput->Send_ubyte_array_header(PCLXL_FONTNAME_SIZE);
        pOutput->Write(PubGetFontName(pdevobj, ulFontID), PCLXL_FONTNAME_SIZE);
        pOutput->Send_attr_ubyte(eFontName);
        pOutput->Send_cmd(eBeginChar);
    }

#if CLASS12
    //
    // Class 1 for Horizontal font
    // Class 2 for Vertical font
    //
    if (S_OK != pTTFile->IsVertical())
    {
        USHORT usAdvanceWidth;
        SHORT  sLeftSideBearing;

        if (S_OK != pTTFile->GetHMTXData(hGlyph, &usAdvanceWidth, &sLeftSideBearing))
        {
            ERR(("PCLXLDownloadFontHeader::GetHMTXData failed.\n"));
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }

        //
        // The initialization of TrueType Glyphs Format 1 Class 1.
        //
        uint32_datasize = dwGlyphDataSize +
                          sizeof(OutlineCharC1.wCharDataSize) +
                          sizeof(OutlineCharC1.wLeftSideBearing) +
                          sizeof(OutlineCharC1.wAdvanceWidth) +
                          sizeof(OutlineCharC1.wTrueTypeGlyphID);

        OutlineCharC1.ubFormat         = 1;
        OutlineCharC1.ubClass          = 1;
        OutlineCharC1.wCharDataSize    = SWAPW((WORD)uint32_datasize);
        OutlineCharC1.wLeftSideBearing = SWAPW((WORD)sLeftSideBearing);
        OutlineCharC1.wAdvanceWidth    = SWAPW((WORD)usAdvanceWidth);
        OutlineCharC1.wTrueTypeGlyphID = SWAPW((WORD)hGlyph);

        uint32_datasize += sizeof(OutlineCharC1.ubFormat) +
                           sizeof(OutlineCharC1.ubClass);

        if (S_OK != pOutput->Send_uint16((uint16)dwGlyphID) ||
            S_OK != pOutput->Send_attr_ubyte(eCharCode) ||
            S_OK != pOutput->Send_uint16((uint16)uint32_datasize) ||
            S_OK != pOutput->Send_attr_ubyte(eCharDataSize) ||
            S_OK != pOutput->Send_cmd(eReadChar))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }
    else
    {
        USHORT usAdvanceWidth;
        SHORT  sLeftSideBearing;
        SHORT  sTopSideBearing;

        if (S_OK != pTTFile->GetVMTXData(hGlyph, &usAdvanceWidth, &sTopSideBearing, &sLeftSideBearing))
        {
            ERR(("PCLXLDownloadCharGlyph::GetVMTXData failed.\n"));
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }

        //
        // The initialization of TrueType Glyphs Format 1 Class 2.
        //
        uint32_datasize = dwGlyphDataSize +
                          sizeof(OutlineCharC2.wLeftSideBearing) +
                          sizeof(OutlineCharC2.wTopSideBearing) +
                          sizeof(OutlineCharC2.wAdvanceWidth) +
                          sizeof(OutlineCharC2.wCharDataSize) +
                          sizeof(OutlineCharC2.wTrueTypeGlyphID);

        OutlineCharC2.ubFormat         = 1;
        OutlineCharC2.ubClass          = 2;
        OutlineCharC2.wCharDataSize    = SWAPW((WORD)uint32_datasize);
        OutlineCharC2.wLeftSideBearing = SWAPW((WORD)sLeftSideBearing);
        OutlineCharC2.wAdvanceWidth    = SWAPW((WORD)usAdvanceWidth);
        OutlineCharC2.wTopSideBearing  = SWAPW((WORD)sTopSideBearing);
        OutlineCharC2.wTrueTypeGlyphID = SWAPW((WORD)hGlyph);

        uint32_datasize += sizeof(OutlineCharC2.ubFormat) +
                           sizeof(OutlineCharC2.ubClass);


        if (S_OK != pOutput->Send_uint16((uint16)dwGlyphID) ||
            S_OK != pOutput->Send_attr_ubyte(eCharCode) ||
            S_OK != pOutput->Send_uint16((uint16)uint32_datasize) ||
            S_OK != pOutput->Send_attr_ubyte(eCharDataSize) ||
            S_OK != pOutput->Send_cmd(eReadChar))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }
#else{
        //
        // The initialization of TrueType Glyphs Format 1 Class 0.
        //
        uint32_datasize = dwGlyphDataSize +
                          sizeof(OutlineCharC0.wCharDataSize) +
                          sizeof(OutlineCharC0.wTrueTypeGlyphID);

        OutlineCharC0.ubFormat         = 1;
        OutlineCharC0.ubClass          = 0;
        OutlineCharC0.wCharDataSize    = SWAPW((WORD)uint32_datasize);
        OutlineCharC0.wTrueTypeGlyphID = SWAPW((WORD)hGlyph);

        uint32_datasize += sizeof(OutlineCharC0.ubFormat) +
                           sizeof(OutlineCharC0.ubClass);

        if (S_OK != pOutput->Send_uint16((uint16)dwGlyphID) ||
            S_OK != pOutput->Send_attr_ubyte(eCharCode) ||
            S_OK != pOutput->Send_uint16((uint16)uint32_datasize) ||
            S_OK != pOutput->Send_attr_ubyte(eCharDataSize) ||
            S_OK != pOutput->Send_cmd(eReadChar))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }
#endif

    if (uint32_datasize <= 0xff)
    {
        if (S_OK != pOutput->WriteByte(PCLXL_dataLengthByte) ||
            S_OK != pOutput->WriteByte((ubyte)uint32_datasize))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }
    else
    {
        if (S_OK != pOutput->WriteByte(PCLXL_dataLength) ||
            S_OK != pOutput->Write((PBYTE)&uint32_datasize, sizeof(uint32)))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }

#if CLASS12
    if (S_OK != pTTFile->IsVertical())
    {
        pOutput->Write((PBYTE)&OutlineCharC1, sizeof(OutlineCharC1));
    }
    else
    {
        pOutput->Write((PBYTE)&OutlineCharC2, sizeof(OutlineCharC2));
    }
#else
        pOutput->Write((PBYTE)&OutlineCharC0, sizeof(OutlineCharC0));
#endif
    if (S_OK == pOutput->Flush(pdevobj))
    {
        if (!bSpace)
        {
            //
            // Direct Write
            //
            dwGlyphDataSize = (DWORD)WriteSpoolBuf((PPDEV)pdevobj,
                                                   pubGlyphData,
                                                   dwGlyphDataSize);
        }
        return TRUE;
    }
    else
    {
        if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
        {
            pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
            pOutput->Delete();
        }
        return FALSE;
    }
}

extern "C" HRESULT APIENTRY
PCLXLTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni TTDownloadMethod interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLTTDownloadMethod() entry.\r\n"));

    //
    // Error Check
    //
    if (NULL == pdevobj  ||
        NULL == pUFObj   ||
        NULL == pUFObj->pIFIMetrics   ||
        NULL == pdwResult )
    {
        ERR(("PCLXLTTDownloadMethod(): invalid parameters.\r\n"));
        return E_UNEXPECTED;
    }

    //
    // Initialize
    //
    *pdwResult = TTDOWNLOAD_GRAPHICS;

    if (((PPDEV)pdevobj)->pGlobals->fontformat == UNUSED_ITEM)
    {
        //
        // There is no font download format specified.
        // Prints as graphics.
        //
        return S_OK;
    }

    //
    // Return GRAPHICS for non-TrueType font
    //
    if ( !(pUFObj->pIFIMetrics->flInfo & FM_INFO_TECH_TRUETYPE) )
    {
        ERR(("PCLXLTTDownloadMethod(): invalid font.\r\n"));
        return S_OK;
    }

    //
    // Text As Graphics
    //
    if (((PPDEV)pdevobj)->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS)
    {
        return S_OK;
    }

    //
    // Get XForm and X and Y scaling factors.
    //
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    FLOATOBJ_XFORM xform;
    FLOATOBJ foXScale, foYScale;

    if (S_OK != GetXForm(pdevobj, pUFObj, &xform) ||
        S_OK != GetXYScale(&xform, &foXScale, &foYScale))
    {
        ERR(("PCLXLTTDownloadMethod(): Failed to get X and Y Scale.\r\n"));
        return E_UNEXPECTED;
    }
    //
    // Scale fwdUnitsPerEm
    //
    FLOATOBJ_MulLong(&foYScale, pUFObj->pIFIMetrics->fwdUnitsPerEm);
    FLOATOBJ_MulLong(&foXScale, pUFObj->pIFIMetrics->fwdUnitsPerEm);
    pxlpdev->fwdUnitsPerEm = (FWORD)FLOATOBJ_GetLong(&foYScale);
    pxlpdev->fwdMaxCharWidth = (FWORD)FLOATOBJ_GetLong(&foXScale);


    //
    // Download as Bitmap softfont
    //
    if (((PPDEV)pdevobj)->pGlobals->fontformat == FF_HPPCL ||
        ((PPDEV)pdevobj)->pGlobals->fontformat == FF_HPPCL_RES)
    {
        *pdwResult = TTDOWNLOAD_BITMAP;
        return S_OK;
    }

    //
    // Parse TrueType font
    //
    XLTrueType *pTTFile = pxlpdev->pTTFile;
    FONTOBJ *pFontObj;

    if (S_OK == GetFONTOBJ(pdevobj, pUFObj, &pFontObj))
    {
        if (S_OK != pTTFile->OpenTTFile(pFontObj))
        {
            ERR(("PCLXL:TTDownloadMethod(): Failed to open TT file.\n"));
            return S_FALSE;
        }
    }

    //
    // Reverse width and height, if the font is a vertial font.
    //
    if (S_OK == pTTFile->IsVertical())
    {
        FWORD fwdTmp;
        fwdTmp = pxlpdev->fwdUnitsPerEm;
        pxlpdev->fwdUnitsPerEm = pxlpdev->fwdMaxCharWidth;
        pxlpdev->fwdMaxCharWidth = fwdTmp;
    }

    //
    // Always return TrueType Outline
    //
    *pdwResult = TTDOWNLOAD_TTOUTLINE;

    VERBOSE(("PCLXLTTDownloadMethod() pdwResult=%d\n", *pdwResult));
    return S_OK;
}

extern "C" HRESULT APIENTRY
PCLXLOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
/*++

Routine Description:

    IPrintOemUni OutputCharStr interface

Arguments:


Return Value:


Note:


--*/
{
    PXLPDEV    pxlpdev;

    //
    // UNIFONTOBJ callback data structures
    //
    GETINFO_GLYPHSTRING GStr;
    GETINFO_GLYPHWIDTH  GWidth;

    //
    // Device font TRANSDATA structure
    //
    PTRANSDATA pTransOrg, pTrans;

    PPOINTL pptlCharAdvance;
    PWORD pawChar;

    PLONG plWidth;
    DWORD dwGetInfo, dwI, dwcbInitSize;


    VERBOSE(("PCLXLOutputCharStr() entry.\r\n"));

    //
    // Error parameter check
    //
    if (0 == dwCount    ||
        NULL == pGlyph  ||
        NULL == pUFObj   )
    {
        ERR(("PCLXLOutptuChar: Invalid parameters\n"));
        return E_UNEXPECTED;
    }

    pxlpdev= (PXLPDEV)pdevobj->pdevOEM;

    //
    // Get current text resolution
    //
    if (pxlpdev->dwTextRes == 0)
    {
        GETINFO_STDVAR StdVar;
        DWORD dwSizeNeeded;

        StdVar.dwSize = sizeof(GETINFO_STDVAR);
        StdVar.dwNumOfVariable = 1;
        StdVar.StdVar[0].dwStdVarID = FNT_INFO_TEXTYRES;
        StdVar.StdVar[0].lStdVariable  = 0;
        pUFObj->pfnGetInfo(pUFObj,
                           UFO_GETINFO_STDVARIABLE,
                           &StdVar,
                           StdVar.dwSize,
                           &dwSizeNeeded);

        pxlpdev->dwTextRes    = StdVar.StdVar[0].lStdVariable;
    }

    //
    // Allocate memory for character cache
    //
    if (0 == pxlpdev->dwMaxCharCount ||
        pxlpdev->dwMaxCharCount < pxlpdev->dwCharCount + dwCount)
    {
        DWORD dwInitCount = INIT_CHAR_NUM;

        //
        // Calculate the initial data size
        //
        if (dwInitCount < pxlpdev->dwCharCount + dwCount)
        {
            dwInitCount = pxlpdev->dwCharCount + dwCount;
        }

        //
        // Allocate memory
        //
        if (!(pptlCharAdvance  = (PPOINTL)MemAlloc(sizeof(POINTL) * dwInitCount)) ||
            !(pawChar      = (PWORD)MemAlloc(sizeof(WORD) * dwInitCount))  )
        {
            ERR(("PCLXL:CharWidth buffer allocation failed.\n"));
            if (pptlCharAdvance)
            {
               MemFree(pptlCharAdvance);
            }
            return E_UNEXPECTED;
        }

        //
        // Copy the old buffer to new buffer
        //
        if (pxlpdev->dwCharCount > 0)
        {
            CopyMemory(pptlCharAdvance, pxlpdev->pptlCharAdvance, pxlpdev->dwCharCount * sizeof(POINTL));
            CopyMemory(pawChar, pxlpdev->pawChar, pxlpdev->dwCharCount * sizeof(WORD));
        }

        if (pxlpdev->pptlCharAdvance)
            MemFree(pxlpdev->pptlCharAdvance);
        if (pxlpdev->pawChar)
            MemFree(pxlpdev->pawChar);

        pxlpdev->pptlCharAdvance = pptlCharAdvance;
        pxlpdev->pawChar        = pawChar;
        pxlpdev->dwMaxCharCount = dwInitCount;
    }

    XLOutput *pOutput = pxlpdev->pOutput;

    //
    // Y cursor position is different from the previous OutputCharGlyph
    // Flush the string cache
    //
    if (0 == pxlpdev->dwCharCount)
    {
        pxlpdev->lStartX =
        pxlpdev->lX = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->ptlFirstGlyph.x;
        pxlpdev->lStartY =
        pxlpdev->lY = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->ptlFirstGlyph.y;

        if (((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->iRot)
        {
            pxlpdev->dwTextAngle = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->iRot;
        }
    }


    //
    // Init pawChar
    //
    
    pawChar = pxlpdev->pawChar + pxlpdev->dwCharCount;

    switch(dwType)
    {
    case TYPE_GLYPHHANDLE:
        //
        // Get TRANSDATA
        //
        GStr.dwSize          = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount         = dwCount;
        GStr.dwTypeIn        = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn        = pGlyph;
        GStr.dwTypeOut       = TYPE_TRANSDATA;
        GStr.pGlyphOut       = NULL;
        GStr.dwGlyphOutSize  = 0;

        dwGetInfo = GStr.dwSize;

        //
        // Get necessary buffer size
        //
        pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_GLYPHSTRING,
                            &GStr,
                            dwGetInfo,
                            &dwGetInfo);

        if (!GStr.dwGlyphOutSize)
        {
            ERR(("PCLXLOutptuChar: GetInfo( 1st GLYPHSTRING) failed\n"));
            return E_UNEXPECTED;
        }

        if (NULL == pxlpdev->pTransOrg ||
            dwCount * sizeof(TRANSDATA) > pxlpdev->dwcbTransSize ||
            GStr.dwGlyphOutSize > pxlpdev->dwcbTransSize)
        {
            dwcbInitSize = INIT_CHAR_NUM * sizeof(TRANSDATA);
            if (dwcbInitSize < GStr.dwGlyphOutSize)
            {
                dwcbInitSize = GStr.dwGlyphOutSize;
            }
            if (dwcbInitSize < dwCount * sizeof(TRANSDATA))
            {
                dwcbInitSize = dwCount * sizeof(TRANSDATA);
            }

            if (NULL == pxlpdev->pTransOrg)
            {
                MemFree(pxlpdev->pTransOrg);
            }
            if ((pTransOrg = (PTRANSDATA)MemAlloc(dwcbInitSize)) == NULL)
            {
                ERR(("PCLXLOutptuChar: MemAlloc failed\n"));
                return E_UNEXPECTED;
            }
            pxlpdev->pTransOrg = pTransOrg;
            pxlpdev->dwcbTransSize = dwcbInitSize;
        }
        else
        {
            pTransOrg = pxlpdev->pTransOrg;
        }

        GStr.pGlyphOut =  (PVOID)pTransOrg;

        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
	&GStr,
	dwGetInfo,
	&dwGetInfo))
        {
            ERR(("PCLXLOutptuChar: GetInfo( 2nd GLYPHSTRING) failed\n"));
            return E_UNEXPECTED;
        }

        pTrans = pTransOrg;

        for (dwI = 0; dwI < dwCount; dwI++, pTrans++)
        {
            switch(pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_COMPOSE:
                ERR(("PCLXL:OutputCharGlyph: Unsupported ubType\n"));
                break;
            case MTYPE_DIRECT:
                VERBOSE(("PCLXLOutputCharStr:%c\n", pTrans->uCode.ubCode));
                *pawChar++ = pTrans->uCode.ubCode;
                break;
            case MTYPE_PAIRED:
                *pawChar++ = *(PWORD)(pTrans->uCode.ubPairs);
                break;
            }
        }
        break;

    case TYPE_GLYPHID:
        for (dwI = 0; dwI < dwCount; dwI++, pawChar++)
        {
            CopyMemory(pawChar, (PDWORD)pGlyph + dwI, sizeof(WORD));
        }
        break;
    }

    //
    // Get Character width
    //

    //
    // Store char position info
    //

    pptlCharAdvance = pxlpdev->pptlCharAdvance + pxlpdev->dwCharCount;

    //
    // dwCharCount holds the number of chars in the character cache
    // dwCharCount = 0: Store start X pos
    //                  Current Y pos
    //
    if (pxlpdev->dwCharCount == 0)
    {
        //
        // UNIDRV hack
        // Get the first character position.
        //
        pxlpdev->lPrevX    =
        pxlpdev->lStartX   =
        pxlpdev->lX = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->ptlFirstGlyph.x;
        pxlpdev->lPrevY    =
        pxlpdev->lStartY   =
        pxlpdev->lY = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->ptlFirstGlyph.y;
        VERBOSE(("PCLXLOutputCharStr: %d",pxlpdev->lStartX));
    }

    GLYPHPOS *pgp = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->pgp;

    if (pxlpdev->dwCharCount > 0)
    {
        if (pxlpdev->dwCharCount < ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->cGlyphsToPrint)
        {
            pgp += pxlpdev->dwCharCount;
        }

        (pptlCharAdvance - 1)->x = pgp->ptl.x - pxlpdev->lPrevX;
        (pptlCharAdvance - 1)->y = pgp->ptl.y - pxlpdev->lPrevY;
    }

    for (dwI = 0; dwI < dwCount - 1; dwI ++, pptlCharAdvance ++, pgp ++)
    {
        pptlCharAdvance->x = pgp[1].ptl.x - pgp->ptl.x; 
        pptlCharAdvance->y = pgp[1].ptl.y - pgp->ptl.y; 
        VERBOSE((",(%d, %d)", pptlCharAdvance->x, pptlCharAdvance->y));
    }
    VERBOSE(("\n"));

    pptlCharAdvance->x = pptlCharAdvance->y = 0;
    pxlpdev->lPrevX = pgp->ptl.x;
    pxlpdev->lPrevY = pgp->ptl.y;
    pxlpdev->dwCharCount += dwCount;

    return S_OK;
}

extern "C" HRESULT APIENTRY
PCLXLSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
/*++

Routine Description:

    IPrintOemUni SendFontCmd interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLSendFontCmd() entry.\r\n"));

    CHAR  cSymbolSet[16];
    PBYTE pubCmd;

    if (NULL == pFInv             ||
        NULL == pFInv->pubCommand ||
        0    == pFInv->dwCount     )
    {
        VERBOSE(("PCLXLSendFontCmd: unexpected FINVOCATION\n"));
        return S_OK;
    }

    PXLPDEV pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
    XLOutput *pOutput = pxlpdev->pOutput;

    if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
    {
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        pOutput->Send_cmd(eEndChar);
    }

    if (pUFObj->dwFlags & UFOFLAG_TTFONT)
    {
        if (pFInv->dwCount == sizeof(DWORD))
        {
            if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
            {
                pOutput->SetFont(kFontTypeTTBitmap,
                     PubGetFontName(pdevobj, pUFObj->ulFontID),
                     pxlpdev->fwdUnitsPerEm,
                     pxlpdev->fwdMaxCharWidth,
                     0x0002,
                     (DWORD)0);
            }
            else
            {
                DWORD dwFontSimulation = pUFObj->dwFlags & (UFOFLAG_TTOUTLINE_BOLD_SIM|UFOFLAG_TTOUTLINE_ITALIC_SIM|UFOFLAG_TTOUTLINE_VERTICAL);

                //
                // UFOFLAG_TTOUTLINE_BOLD_SIM   = 0x08
                // UFOFLAG_TTOUTLINE_ITALIC_SIM = 0x10
                // UFOFLAG_TTOUTLINE_VERTICAL   = 0x20
                //
                // XLOUTPUT_FONTSIM_BOLD   = 0x01
                // XLOUTPUT_FONTSIM_ITALIC = 0x02
                // XLOUTPUT_FONTSIM_VERTICAL = 0x03
                //
                dwFontSimulation >>= 3;

                pOutput->SetFont(kFontTypeTTOutline,
                     PubGetFontName(pdevobj, pUFObj->ulFontID),
                     pxlpdev->fwdUnitsPerEm,
                     pxlpdev->fwdMaxCharWidth,
                     0x0002,
                     dwFontSimulation);
            }
        }
        else
        {
            VERBOSE(("PCLXLSendFontCmd: unexpected FINVOCATION\n"));
            return S_FALSE;
        }
    }
    else
    {
        DWORD dwSizeNeeded, dwSize, dwSymbolSet;

        pubCmd = pFInv->pubCommand;
        pubCmd += pFInv->dwCount;
        pubCmd --;

        //
        // Get a symbol set
        //
        // ASSUMPTION: Font selecton string is like following!!!!
        //
        // "Courier         590"
        //  12345678901234567890
        // the size of font name is 16. Plus space and symbol set number.
        //
        if (pFInv->dwCount < 0x11)
        {
            ERR(("PCLXL:SendFontCmd: Invalid font selection command.\n"));
            return E_UNEXPECTED;
        }

        dwSize = 0;
        while (*pubCmd != 0x20 && dwSize < pFInv->dwCount)
        {
            pubCmd--;
            dwSize ++;
        }

        if (dwSize != 0)
        {
            pubCmd++;
            CopyMemory(cSymbolSet, pubCmd, dwSize);
        }
        cSymbolSet[dwSize] = NULL;

        dwSymbolSet = (DWORD)atoi(cSymbolSet);

        //
        // Get FONTOBJ
        //
        FONTOBJ *pFontObj;
        GetFONTOBJ(pdevobj, pUFObj, &pFontObj);


        //
        // Get XForm
        //
        FLOATOBJ foXScale, foYScale;
        FLOATOBJ_XFORM xform;

        if (S_OK != GetXForm(pdevobj, pUFObj, &xform) ||
            S_OK != GetXYScale(&xform, &foXScale, &foYScale))
        {
            return E_UNEXPECTED;
        }

        //
        // Scale Height and Width
        //
        // Is X scaled differently from Y?
        // If so, set X.
        //
        DWORD dwFontWidth;
        FLOATOBJ_MulLong(&foYScale, pUFObj->pIFIMetrics->fwdUnitsPerEm);
        FLOATOBJ_MulLong(&foXScale, pUFObj->pIFIMetrics->fwdUnitsPerEm);
        pxlpdev->dwFontHeight = (FWORD)FLOATOBJ_GetLong(&foYScale);
        pxlpdev->dwFontWidth = (FWORD)FLOATOBJ_GetLong(&foXScale);
        if (S_OK == IsXYSame(&xform))
        {
            dwFontWidth = 0;
        }
        else
        {
            dwFontWidth = pxlpdev->dwFontWidth;
        }

        BYTE aubFontName[PCLXL_FONTNAME_SIZE + 1];
        CopyMemory(aubFontName, pFInv->pubCommand, PCLXL_FONTNAME_SIZE);
        aubFontName[PCLXL_FONTNAME_SIZE] = NULL;
        pOutput->SetFont(kFontTypeDevice,
                         (PBYTE)aubFontName,
                         pxlpdev->dwFontHeight,
                         dwFontWidth,
                         dwSymbolSet,
                         0);
    }

    pOutput->Flush(pdevobj);

    if (pxlpdev->dwFlags & XLPDEV_FLAGS_RESET_FONT)
    {
        BSaveFont(pdevobj);
    }

    return S_OK;
}


HRESULT
FlushCachedText(
    PDEVOBJ pdevobj)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    DWORD dwI;

    VERBOSE(("PCLXLFlushCachedText: Flush cached characters:%d\r\n", pxlpdev->dwCharCount));

    if (pxlpdev->dwCharCount == 0)
        return S_OK;

    XLOutput *pOutput = pxlpdev->pOutput;

    PWORD pawChar = pxlpdev->pawChar;
    PPOINTL pptlCharAdvance = pxlpdev->pptlCharAdvance;

    sint16 sint16_advance;
    ubyte  ubyte_advance;

    XLGState *pGState = pxlpdev->pOutput;

    if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
    {
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        pOutput->Send_cmd(eEndChar);
    }

    //
    // Flush cached char string
    //

    //
    // Reselect font
    //
    if (pxlpdev->dwFlags & XLPDEV_FLAGS_RESET_FONT)
    {
        BYTE aubFontName[PCLXL_FONTNAME_SIZE + 1];

        VERBOSE(("PCLXLFlushCachedText: ResetFont\n"));

        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_RESET_FONT;
        pxlpdev->pXLFont->GetFontName(aubFontName);
        pOutput->SetFont(pxlpdev->pXLFont->GetFontType(),
                         aubFontName,
                         pxlpdev->pXLFont->GetFontHeight(),
                         pxlpdev->pXLFont->GetFontWidth(),
                         pxlpdev->pXLFont->GetFontSymbolSet(),
                         pxlpdev->pXLFont->GetFontSimulation());
    }

    //
    // Set cursor
    //
    pOutput->SetCursor(pxlpdev->lStartX, pxlpdev->lStartY);

    //
    // Set text angle
    //
    if (pxlpdev->dwTextAngle && kFontTypeTTBitmap != pGState->GetFontType())
    {
        pOutput->Send_uint16((uint16)pxlpdev->dwTextAngle);
        pOutput->Send_attr_ubyte(eCharAngle);
        pOutput->Send_cmd(eSetCharAngle);
    }

    //
    // Characters
    //
    pOutput->Send_uint16_array_header((uint16)pxlpdev->dwCharCount);
    VERBOSE(("String = "));
    for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pawChar++)
    {
        pOutput->Write((PBYTE)pawChar, sizeof(WORD));
        VERBOSE(("0x%x ", *pawChar));
    }
    VERBOSE(("\r\n"));
    pOutput->Send_attr_ubyte(eTextData);

    //
    // X advance
    //
    VERBOSE(("Advance(0x%x)(x,y) = (%d,%d),", pptlCharAdvance, pptlCharAdvance->x, pptlCharAdvance->y));

    BOOL bXUByte = TRUE;
    BOOL bYUByte = TRUE;
    BOOL bXAdvanceTrue = FALSE;
    BOOL bYAdvanceTrue = FALSE;
    for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
    {
        //
        // If the char advance is ubyte, set bUByte flag to optimize XSpacing
        //
        if (pptlCharAdvance->x & 0xffffff00)
            bXUByte = FALSE;
        if (pptlCharAdvance->y & 0xffffff00)
            bYUByte = FALSE;
        if (pptlCharAdvance->x != 0)
            bXAdvanceTrue = TRUE;
        if (pptlCharAdvance->y != 0)
            bYAdvanceTrue = TRUE;
    }

    //
    // X Advance
    //
    if (bXAdvanceTrue)
    {
        pptlCharAdvance = pxlpdev->pptlCharAdvance;

        VERBOSE(("X = "));
        if (bXUByte == TRUE)
        {
            //
            // ubyte XSpacing
            //
            pOutput->Send_ubyte_array_header((uint16)pxlpdev->dwCharCount);

            for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
            {
                ubyte_advance = (ubyte)pptlCharAdvance->x;
                pOutput->Write((PBYTE)&ubyte_advance, sizeof(ubyte));
#if DBG
                VERBOSE(("%d ", ubyte_advance));
                if (0 == ubyte_advance)
                {
                    VERBOSE(("\nXSpacing is zero!.\n"));
                }
#endif
            }
        }
        else
        {
            //
            // sint16 XSpacing
            //
            pOutput->Send_sint16_array_header((uint16)pxlpdev->dwCharCount);

            for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
            {
                sint16_advance = (sint16)pptlCharAdvance->x;
                pOutput->Write((PBYTE)&sint16_advance, sizeof(sint16));
#if DBG
                VERBOSE(("%d ", sint16_advance));
                if (0 == sint16_advance)
                {
                    VERBOSE(("\nXSpacing is zero!.\n"));
                }
#endif
            }
        }

        VERBOSE(("\r\n"));
        pOutput->Send_attr_ubyte(eXSpacingData);
    }
    //
    // Y Advance
    //
    if (bYAdvanceTrue)
    {
        pptlCharAdvance = pxlpdev->pptlCharAdvance;

        VERBOSE(("Y = "));
        if (bYUByte == TRUE)
        {
            //
            // ubyte YSpacing
            //
            pOutput->Send_ubyte_array_header((uint16)pxlpdev->dwCharCount);

            for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
            {
                ubyte_advance = (ubyte)pptlCharAdvance->y;
                pOutput->Write((PBYTE)&ubyte_advance, sizeof(ubyte));
#if DBG
                VERBOSE(("%d ", ubyte_advance));
                if (0 == ubyte_advance)
                {
                    VERBOSE(("\nYSpacing is zero!.\n"));
                }
#endif
            }
        }
        else
        {
            //
            // sint16 YSpacing
            //
            pOutput->Send_sint16_array_header((uint16)pxlpdev->dwCharCount);

            for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
            {
                sint16_advance = (sint16)pptlCharAdvance->y;
                pOutput->Write((PBYTE)&sint16_advance, sizeof(sint16));
#if DBG
                VERBOSE(("%d ", sint16_advance));
                if (0 == sint16_advance)
                {
                    VERBOSE(("\nYSpacing is zero!.\n"));
                }
#endif
            }
        }

        VERBOSE(("\r\n"));
        pOutput->Send_attr_ubyte(eYSpacingData);
    }

    pOutput->Send_cmd(eText);

    //
    // Reset text angle
    //
    if (pxlpdev->dwTextAngle && kFontTypeTTBitmap != pGState->GetFontType())
    {
        pOutput->Send_uint16(0);
        pOutput->Send_attr_ubyte(eCharAngle);
        pOutput->Send_cmd(eSetCharAngle);
        pxlpdev->dwTextAngle = 0;
    }

    pOutput->Flush(pdevobj);

    pxlpdev->dwCharCount = 0;

    return S_OK;
}

HRESULT
GetFONTOBJ(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    FONTOBJ   **ppFontObj)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    //
    // Error Check
    //
    if (NULL == ppFontObj                ||
        pdevobj->dwSize != sizeof(DEVOBJ) )
    {
        ERR(("PCLXL:GetFONTOBJ: invalid parameter[s].\n"));
        return E_UNEXPECTED;
    }

    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    DWORD dwGetInfo;
    GETINFO_FONTOBJ GFontObj;

    dwGetInfo = 
    GFontObj.dwSize = sizeof(GETINFO_FONTOBJ);
    GFontObj.pFontObj = NULL;

    if (!pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_FONTOBJ,
                            &GFontObj,
                            dwGetInfo,
                            &dwGetInfo))
    {
        ERR(("PCLXL:GetXForm: GetInfo(FONTOBJ) failed\n"));
        return E_UNEXPECTED;
    }

    *ppFontObj = GFontObj.pFontObj;
    return S_OK;
}

HRESULT
GetXForm(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    FLOATOBJ_XFORM* pxform)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    //
    // Error Check
    //
    if (NULL == pxform ||
        NULL == pdevobj ||
        pdevobj->dwSize != sizeof(DEVOBJ) )
    {
        ERR(("PCLXL:GetXForm: invalid parameter[s].\n"));
        return E_UNEXPECTED;
    }

    FONTOBJ *pFontObj;
    if (S_OK != GetFONTOBJ(pdevobj, pUFObj, &pFontObj))
    {
        ERR(("PCLXL:GetXForm: GetFONTOBJ failed.\n"));
        return E_UNEXPECTED;
    }

    XFORMOBJ *pxo = FONTOBJ_pxoGetXform(pFontObj);
    XFORMOBJ_iGetFloatObjXform(pxo, pxform);

    return S_OK;
}

HRESULT
GetXYScale(
    FLOATOBJ_XFORM *pxform,
    FLOATOBJ *pfoXScale,
    FLOATOBJ *pfoYScale)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    //
    // Error Check
    //
    if (NULL == pxform     ||
        NULL == pfoXScale ||
        NULL == pfoYScale  )
    {
        ERR(("PCLXL:GetXYScale: invalid parameter[s].\n"));
        return E_UNEXPECTED;
    }

#if 0
    if( pxform->eM11 )
    {
        //
        // Either 0 or 180 rotation
        //
        if( pxform->eM11 > 0 )
        {
            //
            // Normal case,  0 degree rotation
            //
            *pfoXScale = pxform->eM11;
            *pfoYScale = pxform->eM22;
        }
        else
        {
            //
            // Reverse case,  180 degree rotation
            //
            *pfoXScale = -pxform->eM11;
            *pfoYScale = -pxform->eM22;
        }
    }
    else
    {
        //
        // Must be 90 or 270 degree rotation
        //
        if( pxform->eM12 < 0 )
        {
            //
            // The 90 degree case
            //
            *pfoXScale = pxform->eM21;
            *pfoYScale = -pxform->eM12;
        }
        else
        {
            //
            // The 270 degree case
            //
            *pfoXScale = -pxform->eM21;
            *pfoYScale = pxform->eM12;
        }
    }
#else
    if (pxform->eM21 == 0 && pxform->eM12 == 0)
    {
        //
        // 0 or 180 degree rotation
        //
        if( pxform->eM11 > 0 )
        {
            //
            // The 0 degree case
            //
            *pfoXScale = pxform->eM11;
            *pfoYScale = pxform->eM22;
        }
        else
        {
            //
            // The 180 degree case
            //
            *pfoXScale = -pxform->eM11;
            *pfoYScale = -pxform->eM22;
        }
    }
    else
    if (pxform->eM11 == 0 && pxform->eM22 == 0)
    {
        //
        // Must be 90 or 270 degree rotation
        //
        if( pxform->eM21 < 0 )
        {
            //
            // The 90 degree case
            //
            *pfoXScale = -pxform->eM21;
            *pfoYScale = pxform->eM12;
        }
        else
        {
            //
            // The 270 degree case
            //
            *pfoXScale = pxform->eM21;
            *pfoYScale = -pxform->eM12;
        }
    }
    else
    {
#pragma warning( disable: 4244)
        *pfoXScale = sqrt(pxform->eM11 * pxform->eM11 +
                          pxform->eM12 * pxform->eM12);
        *pfoYScale = sqrt(pxform->eM22 * pxform->eM22 +
                          pxform->eM21 * pxform->eM21);
#pragma warning( default: 4244)
    }
#endif

    return S_OK;
}


HRESULT
IsXYSame(
    FLOATOBJ_XFORM *pxform)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    BOOL     bRet;
    FLOATOBJ eM11 = pxform->eM11;

    if (FLOATOBJ_EqualLong(&eM11, 0))
    {
        return S_OK;
    }

    //
    // 0-90 or 180-270 case
    //     (eM11 > 0 & eM22 > 0)
    //     (eM12 < 0 & eM21 < 0)
    //
    // eM11 = (eM11 - eM22) / eM11;
    //
    FLOATOBJ_Sub(&(eM11), &(pxform->eM22));
    FLOATOBJ_Div(&(eM11), &(pxform->eM11));

    //
    // eM11 < 0.5%
    //
    bRet = FLOATOBJ_LessThanLong(&(eM11), FLOATL_IEEE_0_005F)
         & FLOATOBJ_GreaterThanLong(&(eM11), FLOATL_IEEE_0_005MF);

    if (!bRet)
    {
        //
        // 90-180 or 270-360 case
        //     (eM11 < 0, eM22 > 0)
        //     (eM11 > 0, eM22 < 0)
        //
        // eM11 = (eM11 + eM22) / eM11;
        //
        eM11 = pxform->eM11;
        FLOATOBJ_Add(&(eM11), &(pxform->eM22));
        FLOATOBJ_Div(&(eM11), &(pxform->eM11));

        //
        // eM11 < 0.5%
        //
        bRet = FLOATOBJ_LessThanLong(&(eM11), FLOATL_IEEE_0_005F)
             & FLOATOBJ_GreaterThanLong(&(eM11), FLOATL_IEEE_0_005MF);
    }

    if (bRet)
        return S_OK;
    else
        return S_FALSE;
}

DWORD
DwDownloadCompositeGlyph(
    PDEVOBJ pdevobj,
    ULONG ulFontID,
    PGLYF pGlyph)
/*++

Routine Description:

   Download composite glyph data.
Arguments:

    pdevobj - a pointer to PDEVOBJ
    ulFontID - font ID for this glyph.
    pGlyph - a pointer to GLYF data structure.

Return Value:


Note:


--*/
{
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    XLTrueType *pTTFile = pxlpdev->pTTFile;

    PBYTE pubCGlyphData = (PBYTE)pGlyph;
    DWORD dwCGlyphDataSize, dwRet;

    dwRet = 0;

    if (pGlyph->numberOfContours != COMPONENTCTRCOUNT)
    {
        //
        // Error check. Make sure that this is a composite glyph.
        //
        return dwRet;
    }

    //
    // According to TrueType font spec, if numberOfContours == -1,
    // it has composite glyph data.
    //
    // When downloading special glyphs, specify the value 0xFFFF for the
    // CharCode attribute to the ReadChar operator.
    // This "special" CharCode value tells PCL XL 2.0 that
    // it is a "special" glyph.
    //
    // pCGlyf points an array of CGLYF. pCGlyf->flags says that there is
    // at least one more composite glyph available.
    // I need to go through all glyph data.
    //
    PCGLYF pCGlyf = (PCGLYF)(pubCGlyphData + sizeof(GLYF));
    SHORT sFlags;
    BOOL  bSpace;

    do
    {
        //
        // Swap bytes in any date in TrueType font, since it's Motorola-style ordering (Big Endian).
        //
        sFlags = SWAPW(pCGlyf->flags);

        //
        // Get glyph data from TrueType font object.
        //
        if (S_OK != pTTFile->GetGlyphData( SWAPW(pCGlyf->glyphIndex),
	           &pubCGlyphData,
	           &dwCGlyphDataSize))
        {
            ERR(("PCLXL:DownloadCharGlyph GetGlyphData failed.\r\n"));
            return FALSE;
        }

        if (NULL != pubCGlyphData && dwCGlyphDataSize != 0)
        {
            if (((PGLYF)pubCGlyphData)->numberOfContours == COMPONENTCTRCOUNT)
            {
                //
                // A recursive call to DwDownloadCompositeGlyph for this glyph.
                //
                dwRet += DwDownloadCompositeGlyph(pdevobj, ulFontID, (PGLYF)pubCGlyphData);
            }

            bSpace = FALSE;
        }
        else
        {
            bSpace = TRUE;
        }

        //
        // Download the actual glyph data for this glyph with 0xFFFF.
        // Special character (PCL XL 2.0)
        //
        if (!BDownloadGlyphData(pdevobj,
	ulFontID,
	0xFFFF,
	SWAPW(pCGlyf->glyphIndex),
	pubCGlyphData,
	dwCGlyphDataSize,
	bSpace))
        {
            ERR(("PCLXL:DownloadCharGlyph BDownloadGlyphData failed.\r\n"));
            return dwRet;
        }

        dwRet += dwCGlyphDataSize;

        //
        // If ARG_1_AND_2_ARE_WORDS is set, the arguments are words.
        // Otherwise, they are bytes.
        //
        PBYTE pByte = (PBYTE)pCGlyf;
        if (sFlags & ARG_1_AND_2_ARE_WORDS)
        {
            pByte += sizeof(CGLYF);
        }
        else
        {
            pByte += sizeof(CGLYF_BYTE);
        }

        pCGlyf = (PCGLYF)pByte;

    } while (sFlags & MORE_COMPONENTS);

    return dwRet;
}

inline BOOL
BSaveFont(
    PDEVOBJ pdevobj)
{
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    pxlpdev->dwFlags |= XLPDEV_FLAGS_RESET_FONT;

    if (NULL == pxlpdev->pXLFont)
    {
        pxlpdev->pXLFont = new XLFont;
        if (NULL == pxlpdev->pXLFont)
        {
            return FALSE;
        }
    }

    XLGState *pGState = pxlpdev->pOutput;
    BYTE aubFontName[PCLXL_FONTNAME_SIZE + 1];

    pGState->GetFontName(aubFontName);
    pxlpdev->pXLFont->SetFont(pGState->GetFontType(),
                              aubFontName,
                              pGState->GetFontHeight(),
                              pGState->GetFontWidth(),
                              pGState->GetFontSymbolSet(),
                              pGState->GetFontSimulation());

    pGState->ResetFont();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlenable.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlenable.cpp

Abstract:

    Implementation of enable/disable function for PCLXL

Environment:

    Windows Whistler

Revision History:

     08/23/99 
     Created it.

--*/


#include "xlpdev.h"
#include "xldebug.h"
#include <assert.h>
#include "pclxle.h"
#include "pclxlcmd.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "xlbmpcvt.h"
#include "pclxlcmn.h"
#include "xltt.h"

////////////////////////////////////////////////////////////////////////////////
//
// Local function prototypes
//
inline BOOL BIsColor(
        IN  PDEVOBJ pDevObj);

////////////////////////////////////////////////////////////////////////////////
//
// Functions
//

extern "C" VOID APIENTRY
PCLXLDisableDriver(VOID)
/*++

Routine Description:

    IPrintOemUni DisableDriver interface
    Free all resources, and get prepared to be unloaded.

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLDisaleDriver() entry.\r\n"));
}

extern "C" PDEVOEM APIENTRY
PCLXLEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
/*++

Routine Description:

    IPrintOemUni EnablePDEV interface
    Construct its own PDEV. At this time, the driver also passes a function
    table which contains its own implementation of DDI entrypoints

Arguments:

    pdevobj        - pointer to a DEVOBJ structure. pdevobj->pdevOEM is undefined.
    pPrinterName   - name of the current printer.
    Cpatterns      -
    phsurfPatterns -
    cjGdiInfo      - size of GDIINFO
    pGdiInfo       - a pointer to GDIINFO
    cjDevInfo      - size of DEVINFO
    pDevInfo       - These parameters are identical to what39s passed into DrvEnablePDEV.
    pded: points to a function table which contains the system driver39s
    implementation of DDI entrypoints.


Return Value:


--*/
{
    PXLPDEV     pxlpdev;

    VERBOSE(("PCLXLEnablePDEV() entry.\r\n"));

    //
    // Allocate the XLPDEV
    //
    if (!(pxlpdev = (PXLPDEV)MemAllocZ(sizeof(XLPDEV))))
        return NULL;

    pxlpdev->dwSig = XLPDEV_SIG;

    //
    // Save UNIDRV PDEV
    //
    pxlpdev->pPDev = (PPDEV)pdevobj;


    //
    // HS_HORIZONTAL: 0
    // HS_VERTICAL:   1
    // HS_BDIAGONAL:  2
    // HS_FDIAGONAL:  3
    // HS_CROSS:      4
    // HS_DIAGCROSS:  5
    //
    pxlpdev->dwLastBrushID = 10; // Raster pattern ID starts from 10.

    //
    // Initialize buffers
    //
    // Text string data
    //
    pxlpdev->pTransOrg = (PTRANSDATA)NULL;
    pxlpdev->dwcbTransSize = 0;
    pxlpdev->plWidth   = (PLONG)NULL;
    pxlpdev->dwcbWidthSize = 0;

    //
    // Initialize buffers
    //
    // String cache
    //
    pxlpdev->pptlCharAdvance = (PPOINTL)NULL;
    pxlpdev->pawChar = (PWORD)NULL;
    pxlpdev->dwCharCount = 
    pxlpdev->dwMaxCharCount = 0;

    //
    // Initalize XOutput
    //
    pxlpdev->pOutput = new XLOutput;

    if (NULL == pxlpdev->pOutput)
    {
       MemFree(pxlpdev);
       return NULL;
    }
    pxlpdev->pOutput->SetResolutionForBrush(((PPDEV)pdevobj)->ptGrxRes.x);
    
    ColorDepth CD;
    if (BIsColor(pdevobj))
    {
        CD = e24Bit;
    }
    else
    {
        CD = e8Bit;
    }
    pxlpdev->pOutput->SetDeviceColorDepth(CD);

#if DBG
    pxlpdev->pOutput->SetOutputDbgLevel(OUTPUTDBG);
    pxlpdev->pOutput->SetGStateDbgLevel(GSTATEDBG);
#endif

    //
    // Initialize device font name buffer
    //
    if (!SUCCEEDED(StringCchCopyA(pxlpdev->ubFontName, CCHOF(pxlpdev->ubFontName),"MS PCLXLFont    ")))
    {
        delete pxlpdev->pOutput;
        MemFree(pxlpdev);
        return NULL;
    }

    //
    // Initialize
    // Fixed pitch TT
    // Number of downloaded TrueType font
    //
    pxlpdev->dwFixedTTWidth = 0;
    pxlpdev->dwNumOfTTFont = 0;

    //
    // TrueType file object
    //
    pxlpdev->pTTFile = new XLTrueType;

    if (NULL == pxlpdev->pTTFile)
    {
        delete pxlpdev->pOutput;
        MemFree(pxlpdev);
        return NULL;
    }

    //
    // Text resolution and Font Height
    //
    pxlpdev->dwFontHeight = 
    pxlpdev->dwTextRes = 0;

    //
    // Text Angle
    //
    pxlpdev->dwTextAngle = 0;

    //
    // JPEG support
    //
    //pDevInfo->flGraphicsCaps2 |= GCAPS2_JPEGSRC;
    pDevInfo->flGraphicsCaps |= GCAPS_BEZIERS |
	GCAPS_BEZIERS |
	//GCAPS_GEOMETRICWIDE |
	GCAPS_ALTERNATEFILL |
	GCAPS_WINDINGFILL |
	GCAPS_NUP |
	GCAPS_OPAQUERECT |
	GCAPS_COLOR_DITHER |
	GCAPS_HORIZSTRIKE  |
	GCAPS_VERTSTRIKE   |
	GCAPS_OPAQUERECT;

    //
    // PCL-XL always expects GDI to give the driver full color information.
    // Even if PCLXL may be printing monochrome, it still wants full color info.
    //
    pDevInfo->cxDither = pDevInfo->cyDither = 0;
    pDevInfo->iDitherFormat = BMF_24BPP;

    //
    // Set cursor offset.
    //
    pxlpdev->pOutput->SetCursorOffset(((PPDEV)pdevobj)->sf.ptPrintOffsetM.x,
                                      ((PPDEV)pdevobj)->sf.ptPrintOffsetM.y);

    //
    // Return the result
    //
    return (PDEVOEM)pxlpdev;
}

extern "C" BOOL APIENTRY
PCLXLResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
/*++

Routine Description:

    IPrintOemUni ResetPDEV interface
    OEMResetPDEV transfers the state of the driver from the old PDEVOBJ to the
    new PDEVOBJ when an application calls ResetDC.

Arguments:

pdevobjOld - pdevobj containing Old PDEV
pdevobjNew - pdevobj containing New PDEV

Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLResetPDEV entry.\r\n"));

    PXLPDEV pxlpdevOld = (PXLPDEV)pdevobjOld->pdevOEM;
    PXLPDEV pxlpdevNew = (PXLPDEV)pdevobjNew->pdevOEM;

    if (!(pxlpdevOld->dwFlags & XLPDEV_FLAGS_FIRSTPAGE))
    {
        RemoveAllFonts(pdevobjOld);
    }

    pxlpdevNew->dwFlags |= XLPDEV_FLAGS_RESETPDEV_CALLED;

    return TRUE;
}

extern "C" VOID APIENTRY
PCLXLDisablePDEV(
    PDEVOBJ         pdevobj)
/*++

Routine Description:

    IPrintOemUni DisablePDEV interface
    Free resources allocated for the PDEV.

Arguments:

    pdevobj -

Return Value:


Note:


--*/
{

    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLDisablePDEV() entry.\r\n"));

    //
    // Error check
    //
    if (!pdevobj)
    {
        ERR(("PCLXLDisablePDEV(): invalid pdevobj.\r\n"));
        return;
    }

    //
    // free memory for XLPDEV and any memory block that hangs off XLPDEV.
    //
    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    if (pxlpdev)
    {

        //
        // *Trans data buffer
        // *Width data buffer
        // *String cache(string and width) buffer
        //
        if (pxlpdev->pTransOrg)
            MemFree(pxlpdev->pTransOrg);
        if (pxlpdev->plWidth)
            MemFree(pxlpdev->plWidth);
        if (pxlpdev->pptlCharAdvance)
            MemFree(pxlpdev->pptlCharAdvance);
        if (pxlpdev->pawChar)
            MemFree(pxlpdev->pawChar);

        //
        // Delete XLTrueType
        //
        delete pxlpdev->pTTFile;

        //
        // Delete XLOutput
        //
        delete pxlpdev->pOutput;

        //
        // Delete XLFont
        //
        delete pxlpdev->pXLFont;

        //
        // Free XLPDEV
        //
        MemFree(pxlpdev);
    }
}

extern "C"
BOOL
PCLXLDriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni DriverDMS interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLDriverDMS() entry.\r\n"));

    if (cbSize >= sizeof(DWORD))
    {
        *(PDWORD)pBuffer =

            HOOK_TEXTOUT    |
            HOOK_LINETO     |
            HOOK_COPYBITS   |
            HOOK_BITBLT     |
            HOOK_STRETCHBLT |
            HOOK_PAINT      |
            HOOK_PLGBLT     |
            HOOK_STRETCHBLTROP  |
            HOOK_TRANSPARENTBLT |
            HOOK_ALPHABLEND     |
            HOOK_GRADIENTFILL   |
            HOOK_STROKEPATH |
            HOOK_FILLPATH   |
            HOOK_STROKEANDFILLPATH;

    }
    return TRUE;
}


inline BOOL BIsColor(
        IN  PDEVOBJ pdevobj)
{

    //
    // If no ColorModeEx is present or if its bColor attribute
    // is not set, then its not color.
    //
    if ( NULL == ((PPDEV)pdevobj)->pColorModeEx || 
         FALSE == ((PPDEV)pdevobj)->pColorModeEx->bColor)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlgstate.h ===
/*+++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlgstate.h

Abstract:

    Header file for vector graphics state management.

Environment:

    Windows Whistler

Revision History:

    03/23/00
        Created it.

Note:

    1. Line
        Store Windows NT DDI LINEATTRS sturcture information

    2. Brush
        Brush type (pattern/solid/hatch)
            Hatch brush type
            Pattern brush ID
            Solid brush color

    3. Clip
        Tracks the type of clipping (rectangle/complex).
        Clip rectangle

    4. ROP3 or Transparent/Opaque

        if a printer supports quaternary raster operation,

---*/

#ifndef _XLGSTATE_H_
#define _XLGSTATE_H_

//
// LINE
//

#ifdef __cplusplus

typedef enum {
    kXLLineJoin_Round = JOIN_ROUND,
    kXLLineJoin_Bevel = JOIN_BEVEL,
    kXLLineJoin_Miter = JOIN_MITER
} XLLineJoin;

typedef enum {
        kXLLineType_LA_GEOMETRIC = LA_GEOMETRIC,
        kXLLineType_LA_ALTERNATE = LA_ALTERNATE,
        kXLLineType_LA_STARTGAP  = LA_STARTGAP,
        kXLLineType_LA_STYLED    = LA_STYLED
} XLLineType;

typedef enum {
    kXLLineEndCapRound  = ENDCAP_ROUND,
    kXLLineEndCapSquare = ENDCAP_SQUARE,
    kXLLineEndCapButt   = ENDCAP_BUTT
} XLLineEndCap;

class XLLine
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'line' )

public:

    //
    // Constructure/Destructure
    //
    XLLine::
    XLLine( VOID );

    XLLine::
    XLLine( IN LINEATTRS *plineattrs );

    XLLine::
    ~XLLine( VOID );
    
    // typedef struct {
    // {
    //     FLONG       fl;
    //     ULONG       iJoin;
    //     ULONG       iEndCap;
    //     FLOAT_LONG  elWidth;
    //     FLOATL      eMiterLimit;
    //     ULONG       cstyle;
    //     PFLOAT_LONG pstyle;
    //     FLOAT_LONG  elStyleState;
    // } LINEATTRS, *PLINEATTRS;

    #define XLLINE_NONE        0x00000000
    #define XLLINE_LINETYPE    0x00000001
    #define XLLINE_JOIN        0x00000002
    #define XLLINE_ENDCAP      0x00000004
    #define XLLINE_WIDTH       0x00000008
    #define XLLINE_MITERLIMIT  0x00000010
    #define XLLINE_STYLE       0x00000020

    DWORD GetDifferentAttribute( IN LINEATTRS* plineattrs );

    //
    // Reset line
    //
    VOID ResetLine(VOID);

    //
    // Attributes set functions
    //

    //
    // Line type
    //

    HRESULT SetLineType(IN XLLineType LineType );

    //
    // Line Join
    //

    HRESULT SetLineJoin( IN XLLineJoin LineJoin );

    //
    // Line Join
    //

    HRESULT SetLineEndCap( IN XLLineEndCap LineEndCap );

    //
    // Line width
    //
    HRESULT SetLineWidth( IN FLOAT_LONG elWidth );

    //
    // Line Miter Limit
    //
    HRESULT SetMiterLimit( IN FLOATL eMiterLimit );

    //
    // Line style
    //
    HRESULT SetLineStyle( IN ULONG ulCStyle,
                          IN PFLOAT_LONG pStyle,
                          IN FLOAT_LONG elStyleState );
#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:

    DWORD       m_dwGenFlags;
    LINEATTRS   m_LineAttrs;
};

#endif


//
// Brush
//
#define BRUSH_SIGNATURE 0x48425658 // XBRH

typedef enum {
    kNotInitialized,
    kNoBrush,
    kBrushTypeSolid,
    kBrushTypeHatch,
    kBrushTypePattern
} BrushType;

typedef struct {
    DWORD dwSig;                // Signature BRUSH_SIGNATURE
    BrushType BrushType;        // Brush type
    ULONG ulSolidColor;         // BRUSHOBJ.iSolidColor
    ULONG ulHatch;              // Hatch pattern ID
    DWORD dwCEntries;           // the number of palette 
    DWORD dwColor;              // RGB from BRUSHOBJ_ulGetBrushColor
    DWORD dwPatternBrushID;     // Pattern brush ID
} CMNBRUSH, *PCMNBRUSH;

#ifdef __cplusplus

class Brush
#if DBG
    : public XLDebug
#endif
{

public:
    Brush::
    Brush(VOID);

    Brush::
    ~Brush(VOID);

    //
    // Current brush interface
    //
    HRESULT
    CheckCurrentBrush( IN BRUSHOBJ *pbo);

    //
    // Reset Brush
    //
    VOID ResetBrush(VOID);

    HRESULT
    SetBrush( IN CMNBRUSH *pbrush);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    //
    // Current selected brush
    //
    CMNBRUSH m_Brush;
};

class XLBrush : public Brush
{
    SIGNATURE( 'brsh' )

public:
    XLBrush::
    XLBrush(VOID){};

    XLBrush::
    ~XLBrush(VOID){};
};

#endif

//
// XLPen
//

#ifdef __cplusplus

class XLPen : public Brush
{
    SIGNATURE( 'pen ' )

public:
    XLPen::
    XLPen(VOID){};

    XLPen::
    ~XLPen(VOID){};
};

#endif


//
// XLClip
//

typedef enum {
    kNoClip = 0,
    kClipTypeRectangle,
    kClipTypeComplex
} ClipType;

#define CLIP_SIGNATURE 0x50494c43 // CLIP

typedef struct {
    DWORD dwSig;                // Signature CLIP_SIGNATURE
    RECTL rclClipRect;
    ULONG ulUniq;
} UNICLIP, *PUNICLIP;

#ifdef __cplusplus

class XLClip
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'clip' )

public:
    XLClip::
    XLClip(VOID);

    XLClip::
    ~XLClip(VOID);

    HRESULT ClearClip(VOID);

    HRESULT CheckClip( IN CLIPOBJ *pco );

    HRESULT SetClip( IN CLIPOBJ *pco );

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    ClipType m_ClipType;
    UNICLIP m_XLClip;

};

#endif



//
// XLRop
//

#ifdef __cplusplus

class XLRop
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'rop ' )
public:
    XLRop::
    XLRop(VOID);

    XLRop::
    ~XLRop(VOID);

    HRESULT CheckROP3( IN ROP3 rop3 );

    HRESULT SetROP3( IN ROP3 rop3 );

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    ROP3 m_rop3;
};

#endif


//
// XLFont
//

#ifndef PCLXL_FONTNAME_SIZE
#define PCLXL_FONTNAME_SIZE 16
#endif

#ifdef __cplusplus

typedef enum _FontType {
    kFontNone,
    kFontTypeDevice,
    kFontTypeTTBitmap,
    kFontTypeTTOutline
} FontType;


class XLFont
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'font' )

public:

    //
    // Constructure/Destructure
    //
    XLFont::
    XLFont( VOID );

    XLFont::
    ~XLFont( VOID );

    //
    // font interface
    //
    HRESULT
    CheckCurrentFont(
        FontType XLFontType,
        PBYTE pPCLXLFontName,
        DWORD dwFontHeight,
        DWORD dwFontWidth,
        DWORD dwFontSymbolSet,
        DWORD dwFontSimulation);

    HRESULT
    SetFont(
        FontType XLFontType,
        PBYTE pPCLXLFontName,
        DWORD dwFontHeight,
        DWORD dwFontWidth,
        DWORD dwFontSymbolSet,
        DWORD dwFontSimulation);

    VOID
    ResetFont(VOID);

    HRESULT
    GetFontName(
        PBYTE paubFontName);

    DWORD
    GetFontHeight(VOID);

    DWORD
    GetFontWidth(VOID);

    DWORD
    GetFontSymbolSet(VOID);

    FontType
    GetFontType(VOID);

    DWORD
    GetFontSimulation(VOID);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:

    FontType m_XLFontType;
    BYTE  m_aubFontName[PCLXL_FONTNAME_SIZE+1]; // PCL XL font name
    DWORD m_dwFontHeight;
    DWORD m_dwFontWidth;
    DWORD m_dwFontSymbolSet;
    DWORD m_dwFontSimulation;
};

#endif

//
// XLTxMode
//

class XLTxMode
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'txmd' )

public:

    //
    // Constructure/Destructure
    //
    XLTxMode::
    XLTxMode( VOID );

    XLTxMode::
    ~XLTxMode( VOID );

    //
    // txmode interface
    //
    HRESULT SetSourceTxMode(TxMode SrcTxMode);
    HRESULT SetPaintTxMode(TxMode SrcTxMode);

    TxMode GetSourceTxMode();
    TxMode GetPaintTxMode();

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    TxMode m_SourceTxMode;
    TxMode m_PaintTxMode;
};

//
// XLGState
//

typedef enum _PenBrush 
{
    kPen,
    kBrush
} PenBrush;

#ifdef __cplusplus

class XLGState : public XLLine,
                 public XLBrush,
                 public XLPen,
                 public XLClip,
                 public XLRop,
                 public XLFont,
                 public XLTxMode
{
    SIGNATURE( 'xlgs' )

public:

    XLGState::
    XLGState( VOID ){};

    XLGState::
    ~XLGState( VOID ){};

    VOID
    ResetGState(VOID);

#if DBG
    VOID
    SetAllDbgLevel(DWORD dwLevel);
#endif

};

#endif

#endif // _XLGSTATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlglfch.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     glfcach.h

Abstract:

    PCL XL glyph cache

Environment:

    Windows Whistler

Revision History:

    11/09/00
      Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "glyfcach.h"

XLGlyphCache::
XLGlyphCache(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::Ctor entry.\n"));
    m_ulNumberOfFonts = NULL;
    m_ulNumberOfArray = NULL;
    m_paulFontID = NULL;
    m_ppGlyphTable = NULL;
#if DBG
    m_dbglevel = GLYPHCACHE;
#endif
}

XLGlyphCache::
~XLGlyphCache(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::Dtor entry.\n"));
    FreeAll();
}

VOID
XLGlyphCache::
FreeAll(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::FreeAll entry.\n"));

    MemFree(m_paulFontID);

    ULONG ulI;
    PGLYPHTABLE *ppGlyphTable = m_ppGlyphTable;
    PGLYPHTABLE pGlyphTable;

    for (ulI = 0; ulI < m_ulNumberOfFonts; ulI++, ppGlyphTable++)
    {
        if (pGlyphTable = *ppGlyphTable)
        {
            if (pGlyphTable->pGlyphID)
            {
                MemFree(pGlyphTable->pGlyphID);
            }
            MemFree(pGlyphTable);
        }
    }
    if (m_ppGlyphTable)
    {
        MemFree(m_ppGlyphTable);
    }
}


HRESULT
XLGlyphCache::
XLCreateFont(
    ULONG ulFontID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::CreateFont(ulFontiD=%d) entry.\n", ulFontID));

    HRESULT hResult;
    ULONG ulI;

    //
    // Search font ID
    //
    ULONG ulArrayID = UlSearchFontID(ulFontID);

    //
    // New font ID
    //
    if (ulArrayID == 0xFFFF || ulArrayID == m_ulNumberOfFonts)
    {
        //
        // Out of buffer. Increase array
        // 
        if (m_ulNumberOfArray == m_ulNumberOfFonts)
        {
            if (S_OK != (hResult = IncreaseArray()))
            {
                XL_ERR(("XLGlyphCache::CreateFont IncreaseArray failed.\n"));
                return hResult;
            }
        }

        *(m_paulFontID + m_ulNumberOfFonts) = ulFontID;

        PGLYPHTABLE pGlyphTable;
        if (!(pGlyphTable = (PGLYPHTABLE)MemAllocZ(sizeof(GLYPHTABLE))))
        {
            XL_ERR(("XLGlyphCache::CreateFont MemAllocZ failed.\n"));
            return E_UNEXPECTED;
        }

        pGlyphTable->wFontID = (WORD)ulFontID;
        pGlyphTable->wGlyphNum = 0;
        pGlyphTable->pFirstGID = NULL;
        pGlyphTable->pGlyphID = NULL;
        pGlyphTable->dwAvailableEntries = 0;

        PGLYPHID pGlyphID;
        if (!(pGlyphID = (PGLYPHID)MemAllocZ(INIT_GLYPH_ARRAY * sizeof(GLYPHID))))
        {
            XL_ERR(("XLGlyphCache::CreateFont MemAllocZ failed.\n"));
            MemFree(pGlyphTable);
            return E_UNEXPECTED;
        }

        pGlyphTable->pGlyphID = pGlyphID;
        pGlyphTable->dwAvailableEntries = INIT_GLYPH_ARRAY;

        *(m_ppGlyphTable + m_ulNumberOfFonts) = pGlyphTable;
        m_ulNumberOfFonts ++;

        XL_VERBOSE(("XLGlyphCache::CreateFont New font ID.\n"));

    }

    return S_OK;
}

HRESULT
XLGlyphCache::
IncreaseArray(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::IncreaseArray entry.\n"));

    if (NULL == m_paulFontID || NULL == m_ppGlyphTable)
    {
        if (NULL == m_paulFontID)
        {
            if (!(m_paulFontID = (PULONG)MemAllocZ(INIT_ARRAY * sizeof(ULONG))))
            {
                FreeAll();
                XL_ERR(("XLGlyphCache::IncreaseArray MemAllocZ failed.\n"));
                return E_UNEXPECTED;
            }
        }
        if (NULL == m_ppGlyphTable)
        {
            if (!(m_ppGlyphTable = (GLYPHTABLE**)MemAllocZ(INIT_ARRAY * sizeof(GLYPHTABLE))))
            {
                FreeAll();
                XL_ERR(("XLGlyphCache::IncreaseArray MemAllocZ failed.\n"));
                return E_UNEXPECTED;
            }
        }

        m_ulNumberOfArray = INIT_ARRAY;
        m_ulNumberOfFonts = 0;
    }
    else if (m_ulNumberOfArray == m_ulNumberOfFonts)
    {
        ULONG ulArraySize = m_ulNumberOfArray + ADD_ARRAY;
        PULONG paulTmpFontID;
        PGLYPHTABLE *ppTmpGlyphTable;

        //
        // Allocate new buffer
        //
        if (!(paulTmpFontID = (PULONG)MemAllocZ(ulArraySize)))
        {
            XL_ERR(("XLGlyphCache::IncreaseArray MemAllocZ failed.\n"));
            return E_UNEXPECTED;
        }
        if (!(ppTmpGlyphTable = (GLYPHTABLE**)MemAllocZ(ulArraySize * sizeof(GLYPHTABLE))))
        {
            MemFree(paulTmpFontID);
            XL_ERR(("XLGlyphCache::IncreaseArray MemAllocZ failed.\n"));
            return E_UNEXPECTED;
        }

        //
        // Copy old one to new one
        //
        CopyMemory(paulTmpFontID,
                   m_paulFontID,
                   m_ulNumberOfArray * sizeof(ULONG));
        CopyMemory(ppTmpGlyphTable,
                   m_ppGlyphTable,
                   m_ulNumberOfArray * sizeof(GLYPHTABLE));
        //
        // Free old buffer
        //
        MemFree(m_paulFontID);
        MemFree(m_ppGlyphTable);

        //
        // Set new buffer
        //
        m_paulFontID = paulTmpFontID;
        m_ppGlyphTable = ppTmpGlyphTable;
        m_ulNumberOfArray = ulArraySize;
    }

    return S_OK;
}

ULONG
XLGlyphCache::
UlSearchFontID(
    ULONG ulFontID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::UlSearchFontID entry.\n"));

    ULONG ulReturn, ulI;
    BOOL  bFound;

    if (NULL == m_paulFontID)
    {
        //
        // Error case. Returns 0xFFFF.
        // Here is an assumption. The number of fonts in one document doesn't
        // become larger than 65535.
        //
        XL_ERR(("XLGlyphCache::UlSearchFontID failed.\n"));
        return 0xFFFF;
    }

    bFound = TRUE;

    //
    // Search font ID
    //
    ulI = m_ulNumberOfFonts / 2;
    PULONG paulFontID = m_paulFontID + ulI;

    while ( *paulFontID != ulFontID)
    {
        if (ulI == 0)
        {
            bFound = FALSE;
            break;
        }

        ulI = ulI / 2;

        if (ulI == 0)
        {
            ulI = 1;
        }

        if (*paulFontID < ulFontID)
        {
            paulFontID += ulI; 
        }
        else
        {
            paulFontID -= ulI; 
        }

        if (ulI == 1)
        {
            ulI = 0;
        }
    }

    if (!bFound)
    {
        ulReturn = m_ulNumberOfFonts;
    }
    else
    {
        ulReturn = (ULONG)(paulFontID - m_paulFontID);
    }

    XL_VERBOSE(("XLGlyphCache::UlSearchFontID(ulFontID=%d, ulArrayID=%d).\n", ulFontID, ulReturn));
    return ulReturn;
}

HRESULT
XLGlyphCache::
AddGlyphID(
    ULONG ulFontID,
    ULONG ulGlyphID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::AddGlyphID entry (ulFontiD=%d, ulGlyphID=%d).\n", ulFontID, ulGlyphID));

    ULONG ulArrayID;

    //
    // Get the pointer to GLYPYTABLE of this font.
    //
    if (0xFFFF == (ulArrayID = UlSearchFontID(ulFontID)))
    {
        XL_ERR(("XLGlyphCache::AddGlyphID UlSearchFontID failed.\n"));
        return E_UNEXPECTED;
    }

    PGLYPHTABLE pGlyphTable = *(m_ppGlyphTable+ulArrayID);
    PGLYPHID pGlyphID = pGlyphTable->pFirstGID;
    BOOL bFound;
    WORD wI, wSearchRange;

    wSearchRange = pGlyphTable->wGlyphNum / 2;
    pGlyphID = PSearchGlyph(wSearchRange, TRUE, pGlyphID);
    bFound = TRUE;

    if (pGlyphID)
    {
        while (pGlyphID->ulGlyphID != ulGlyphID)
        {
            if (wSearchRange == 0)
            {
                bFound = FALSE;
                break;
            }
            wSearchRange = wSearchRange / 2;
            if (wSearchRange == 0)
            {
                wSearchRange = 1;
            }

            if (pGlyphID->ulGlyphID > ulGlyphID)
            {
                pGlyphID = PSearchGlyph(wSearchRange, TRUE, pGlyphID);
            }
            else
            {
                pGlyphID = PSearchGlyph(wSearchRange, FALSE, pGlyphID);
            }

            if (wSearchRange == 1)
            {
                wSearchRange = 0;
            }

            if (NULL == pGlyphID)
            {
                bFound = FALSE;
                break;
            }
        }
    }
    else
    {
        //
        // PSearchGlyph failed. There is not glyph available in the cache.
        //
        bFound = FALSE;
    }

    if (bFound)
    {
        XL_VERBOSE(("XLGlyphCache::AddGlyphID FOUND glyph in the cache.\n"));
        return S_FALSE;
    }
    else if (pGlyphID)
    {
        PGLYPHID pPrevGID = pGlyphID->pPrevGID;
        PGLYPHID pNextGID = pGlyphID->pNextGID;
        PGLYPHID pNewGID;

        IncreaseGlyphArray(ulFontID);

        pNewGID = pGlyphTable->pGlyphID + pGlyphTable->wGlyphNum;

        if (pGlyphID->ulGlyphID < ulGlyphID && ulGlyphID < pNextGID->ulGlyphID)
        {
            pGlyphID->pNextGID = pNewGID;
            pNewGID->pPrevGID = pGlyphID;
            pNewGID->pNextGID = pNextGID;
            pNextGID->pPrevGID = pNewGID;
        }
        else
        if (pPrevGID->ulGlyphID < ulGlyphID && ulGlyphID < pGlyphID->ulGlyphID)
        {
            pPrevGID->pNextGID = pNewGID;
            pNewGID->pPrevGID = pPrevGID;
            pNewGID->pNextGID = pGlyphID;
            pGlyphID->pPrevGID = pNewGID;
        }

        pNewGID->ulGlyphID = ulGlyphID;
        pGlyphTable->wGlyphNum++;

        XL_VERBOSE(("XLGlyphCache::AddGlyphID ADDED glyph in the cache.\n"));
        return S_OK;
    }
    else
    {
        PGLYPHID pNewGID;

        IncreaseGlyphArray(ulFontID);

        pNewGID = pGlyphTable->pGlyphID + pGlyphTable->wGlyphNum;
        pNewGID->ulGlyphID = ulGlyphID;
        pNewGID->pPrevGID = NULL;
        pNewGID->pNextGID = NULL;
        pGlyphTable->wGlyphNum++;

        XL_VERBOSE(("XLGlyphCache::AddGlyphID ADDED glyph in the cache.\n"));
        return S_OK;
    }
}

PGLYPHID
XLGlyphCache::
PSearchGlyph(
    WORD wSearchRange,
    BOOL bForward,
    PGLYPHID pGlyphID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::PSearchGlyph entry (wSearchRange=%d,bForward=%d).\n",wSearchRange, bForward));

    WORD wI;

    if (pGlyphID)
    {
        if (bForward)
        {
            for (wI = 0; wI < wSearchRange; wI++)
            {
                if (pGlyphID->pNextGID)
                {
                    pGlyphID = pGlyphID->pNextGID;
                }
                else
                {
                    pGlyphID = NULL;
                    break;
                }
            }
        }
        else
        {
            for (wI = 0; wI < wSearchRange; wI++)
            {
                if (pGlyphID->pNextGID)
                {
                    pGlyphID = pGlyphID->pNextGID;
                }
                else
                {
                    pGlyphID = NULL;
                    break;
                }
            }
        }
    }
    XL_VERBOSE(("XLGlyphCache::PSearchGlyph pGlyphID = %0x.\n", pGlyphID));
    return pGlyphID;
}

HRESULT
XLGlyphCache::
IncreaseGlyphArray(
    ULONG ulFontID)
{
    ULONG ulArrayID;

    //
    // Get the pointer to GLYPYTABLE of this font.
    //
    if (0xFFFF == (ulArrayID = UlSearchFontID(ulFontID)))
    {
        XL_ERR(("XLGlyphCache::AddGlyphID UlSearchFontID failed.\n"));
        return E_UNEXPECTED;
    }

    PGLYPHTABLE pGlyphTable = *(m_ppGlyphTable+ulArrayID);
    //
    // Get the pointer to GLYPYTABLE of this font.
    //
    if (0xFFFF == (ulArrayID = UlSearchFontID(ulFontID)))
    {
        XL_ERR(("XLGlyphCache::AddGlyphID UlSearchFontID failed.\n"));
        return E_UNEXPECTED;
    }

    if (pGlyphTable->wGlyphNum == pGlyphTable->dwAvailableEntries)
    {
        PGLYPHID pGlyphID;

        if (!(pGlyphID = (PGLYPHID)MemAllocZ((pGlyphTable->dwAvailableEntries + ADD_GLYPH_ARRAY) * sizeof(GLYPHID))))
        {
            XL_ERR(("XLGlyphCache::AddGlyphID MemAllocZ failed.\n"));
            return E_UNEXPECTED;
        }

        CopyMemory(pGlyphID, pGlyphTable->pGlyphID, pGlyphTable->dwAvailableEntries * sizeof(GLYPHID));
        pGlyphTable->pFirstGID = pGlyphID + (pGlyphTable->pFirstGID - pGlyphTable->pGlyphID);
        MemFree(pGlyphTable->pGlyphID);
        pGlyphTable->pGlyphID = pGlyphID;
        pGlyphTable->dwAvailableEntries += ADD_GLYPH_ARRAY;

    }
return S_OK;
}

#if DBG
VOID
XLGlyphCache::
SetDbgLevel(
DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
m_dbglevel = dwLevel;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xltext.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     xltext.h

Abstract:

    PCL XL Font related data structures

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _XLTEXT_H_
#define _XLTEXT_H_

//
// Downloading Soft Fonts in PCL XL 2.0
//

//
// Downloading Font Headers
//

//
// The PCL XL 2.0 Format 0 Font Header
//

//
// Orientation is defined in pclxle.h
//

//
// Font Scaling Technology
//
typedef enum {
    eTrueType = 1,
    eBitmap   = 254
} FontScale;

//
// Mapping
//
typedef enum {
    eUnicode = 590,
    eWin31Latin1 = 629,
    eWin31JDBCS = 619,
    eGB2312_1980 = 579,
    eBig5 = 596,
    eKS_C5601_1987 = 616
} Mapping;

typedef struct _PCLXL_FONTHEADER {
    BYTE ubFormat;
    BYTE ubOrientation;
    WORD wMapping;
    BYTE ubFontScallingTech;
    BYTE ubVariety;
    WORD wNumOfChars;
} PCLXL_FONTHEADER, *PPCLXL_FONTHEADER;


//
// Font Data Segment
//

//
// The BR Segment (Bitmap Resolution Segment) (Bitmap Fonts Only)
//

#define PCLXL_BR_SIGNATURE        'RB'
#define PCLXL_BR_SEGMENT_SIZE       4
#define PCLXL_BR_RESOLUTION_300   300
#define PCLXL_BR_RESOLUTION_600   600
#define PCLXL_BR_RESOLUTION_1200 1200

typedef struct _PCLXL_BR_SEGMENT {
    WORD  wSignature;
    WORD  wSegmentSize;
    WORD  wSegmentSizeAlign;
    WORD  wXResolution;
    WORD  wYResolution;
} PCLXL_BR_SEGMENT, *PPCLXL_BR_SEGMENT;

//
// The GC Segment (Galley Character Segment) (TrueType Fonts Only)
//

typedef struct _PCLXL_GC_REGION {
    WORD UpperLeftCharCode;
    WORD LowerRightCharCode;
    WORD GalleyChar;
} PCLXL_GC_REGION, *PPCLXL_GC_REGION;

#define PCLXL_GC_SIGNATURE        'CG'
#define PCLXL_GC_SEGMENT_HEAD_SIZE 6

typedef struct _PCLXL_GC_SEGMENT {
    WORD  wSignature;
    WORD  wSegmentSize;
    WORD  wSegmentSizeAlign;
    WORD  wFormat;
    WORD  wDefaultGalleyCharacter;
    WORD  wNumberOfRegions;
    PCLXL_GC_REGION Region[1];
} PCLXL_GC_SEGMENT, *PPCLXL_GC_SEGMENT;


//
// The GT Segment (Global TrueType Segment) (TrueType Fonts Only)
//

typedef struct _PCLXL_GT_TABLE_DIR {
    DWORD dwTableTag;
    DWORD dwTableCheckSum;
    DWORD dwTableOffset;
    DWORD dwTableSize;
} PCLXL_GT_TABLE_DIR, PPCLXL_GT_TABLE_DIR;

#define PCLXL_GT_SIGNATURE        'TG'

typedef struct _PCLXL_GT_SEGMENT {
    WORD  wSignature;
    WORD  wSegmentSize1;
    WORD  wSegmentSize2;
} PCLXL_GT_SEGMENT, *PPCLXL_GT_SEGMENT;

typedef struct _PCLXL_GT_TABLE_DIR_HEADER {
    DWORD dwSFNTVersion;
    WORD  wNumOfTables;
    WORD  wSearchRange;
    WORD  wEntrySelector;
    WORD  wRangeShift;
} PCLXL_GT_TABLE_DIR_HEADER, *PPCLXL_GT_TABLE_DIR_HEADER;

//
// The NULL Segment
//

#define PCLXL_NULL_SIGNATURE 0xFFFF

typedef struct _PCLXL_NULL_SEGMENT {
    WORD  wSignature;
    WORD  wSegmentSize;
    WORD  wSegmentSizeAlign;
} PCLXL_NULL_SEGMENT, *PPCLXL_NULL_SEGMENT;

//
// The VE Segment (Vertical Exclude Segment) (Vertical TrueType Fonts Only)
//

typedef struct _PCLXL_VE_RANGE {
    WORD RangeFirstCode;
    WORD RangeLastCode;
} PCLXL_VE_RANGE, *PPCLXL_VE_RANGE;

#define PCLXL_VE_SIGNATURE        'EV'

typedef struct _PCLXL_VE_SEGMENT {
    WORD wSignature;
    WORD wSegmentSize;
    WORD wSegmentSizeAlign;
    WORD wFormat;
    WORD wNumberOfRanges;
    PCLXL_VE_RANGE Range[1];
} PCLXL_VE_SEGMENT, *PPCLXL_VE_SEGMENT;

//
// The VI Segment (Vendor Information Segment)
//

#define PCLXL_VI_SIGNATURE        'IV'

typedef struct _PCLXL_VI_SEGMENT {
    WORD wSignature;
    WORD wSegmentSize;
    WORD wSegmentSizeAlign;
} PCLXL_VI_SEGMENT, *PPCLXL_VI_SEGMENT;

//
// The VR Segment (Vertical Rotation Segment) (Vertical TrueType Fonts Only)
//

#define PCLXL_VR_SIGNATURE 'RV'

typedef struct _PCLXL_VR_SEGMENT {
    WORD wSignature;
    WORD wSegmentSize;
    WORD wSegmentSizeAlign;
    WORD wFormat;
    SHORT sTypoDescender;
} PCLXL_VR_SEGMENT, *PPCLXL_VR_SEGMENT;

//
// The VT Segment (Vertical Transformation Segment)
// (Vertical TrueType Fonts with Substitutes Only)
//

typedef struct _PCLXL_VT_GLYPH {
    WORD wHorizontalGlyphID;
    WORD wVerticalSubstituteGlyphID;
} PCLXL_VT_GLYPH, *PPCLXL_VT_GLYPH;

#define PCLXL_VT_SIGNATURE 'TV'

typedef struct _PCLXL_VT_SEGMENT {
    WORD wSignature;
    WORD wSegmentSize;
    WORD wSegmentSizeAlign;
    PCLXL_VT_GLYPH GlyphTable[1];
} PCLXL_VT_SEGMENT, *PPCLXL_VT_SEGMENT;

//
// Downloading Characters
//

//
// Bitmap Characters Format 0
//

typedef struct _PCLXL_BITMAP_CHAR {
    BYTE ubFormat;
    BYTE ubClass;
    WORD wLeftOffset;
    WORD wTopOffset;
    WORD wCharWidth;
    WORD wCharHeight;
} PCLXL_BITMAP_CHAR, *PPCLXL_BITMAP_CHAR;


//
// TrueType Glyphs Format 1 Class 0
//

typedef struct _PCLXL_TRUETYPE_CHAR_C0 {
    BYTE ubFormat;
    BYTE ubClass;
    WORD wCharDataSize;
    WORD wTrueTypeGlyphID;
} PCLXL_TRUETYPE_CHAR_C0, *PPCLXL_TRUETYPE_CHAR_C0;


//
// TrueType Glyphs Format 1 Class 1
//

typedef struct _PCLXL_TRUETYPE_CHAR_C1 {
    BYTE ubFormat;
    BYTE ubClass;
    WORD wCharDataSize;
    WORD wLeftSideBearing;
    WORD wAdvanceWidth;
    WORD wTrueTypeGlyphID;
} PCLXL_TRUETYPE_CHAR_C1, *PPCLXL_TRUETYPE_CHAR_C1;

//
// TrueType Glyphs Format 1 Class 2
//

typedef struct _PCLXL_TRUETYPE_CHAR_C2 {
    BYTE ubFormat;
    BYTE ubClass;
    WORD wCharDataSize;
    WORD wLeftSideBearing;
    WORD wAdvanceWidth;
    WORD wTopSideBearing;
    WORD wTrueTypeGlyphID;
} PCLXL_TRUETYPE_CHAR_C2, *PPCLXL_TRUETYPE_CHAR_C2;

#endif // _XLTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlpdev.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     xlpdev.h

Abstract:

    PCL XL module PDEV header file    

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _XLPDEV_H_
#define _XLPDEV_H_

#include "lib.h"
#include "winnls.h"
#include "unilib.h"
#include "prntfont.h"

#include "gpd.h"
#include "mini.h"

#include "winres.h"
#include "pdev.h"

#include "cmnhdr.h"

//
// Debug text.
//
#if DBG
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define XL_DBGMSG(level, prefix, msg) { \
            if (this->m_dbglevel <= (level)) { \
                DbgPrint("%s %s (%d): ", prefix, __FILE__, __LINE__); \
                DbgPrint msg; \
            } \
        }

#define XL_DBGPRINT(level, msg) { \
            if (this->m_dbglevel <= (level)) { \
                DbgPrint msg; \
            } \
        }
#define XL_VERBOSE(msg) XL_DBGPRINT(DBG_VERBOSE, msg)
#define XL_TERSE(msg) XL_DBGPRINT(DBG_TERSE, msg)
#define XL_WARNING(msg) XL_DBGMSG(DBG_WARNING, "WRN", msg)
#define XL_ERR(msg) XL_DBGMSG(DBG_ERROR, "ERR", msg)

#else

#define XL_VERBOSE(msg)
#define XL_TERSE(msg)
#define XL_WARNING(msg)
#define XL_ERR(msg)

#endif

typedef ULONG ROP3;
typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'PCLX'      // Declaser series dll
#define DLLTEXT(s)      __TEXT("PCLXL:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L

//
// Master Unit
//
#define MASTER_UNIT 1200

//
// Device font resolution
//
#define DEVICEFONT_UNIT 600

//
// Buffer macros
//
#define INIT_CHAR_NUM 256

//
// Memory allocation
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }


//
// Others
//
#define GET_COLOR_TABLE(pxlo) \
        (pxlo ?\
            (((pxlo)->flXlate & XO_TABLE) ?\
              ((pxlo)->pulXlate ? (pxlo)->pulXlate : XLATEOBJ_piVector(pxlo)) :\
            NULL) :\
        NULL)

//
//      OEM UD Type Defines
////////////////////////////////////////////////////////

//
// Warning: the following enum order must match the order in OEMHookFuncs[].
//
enum {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,

    MAX_DDI_HOOKS,
};

struct IPrintOemDriverUni;

extern const DWORD dw1BPPPal[];
extern const DWORD dw4BPPPal[];

#define XLBRUSH_SIG 'rblx'

typedef struct _XLBRUSH {
    DWORD dwSig;
    DWORD dwHatch;
    DWORD dwOutputFormat;
    DWORD dwPatternID; // Pattern ID. 0 if it's not a pattern.
    DWORD dwCEntries;
    DWORD dwColor;
    DWORD adwColor[1];
} XLBRUSH, *PXLBRUSH;

class XLOutput;
class XLTrueType;
class XLFont;
class XLGlyphCache;

#define XLPDEV_SIG 'dplx'

typedef struct _XLPDEV {
    DWORD dwSig;

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // UNIDRV PDEV
    //
    PPDEV pPDev;

    //
    // General flags
    // 
    DWORD dwFlags;
#define XLPDEV_FLAGS_RESET_FONT       0x00000001
#define XLPDEV_FLAGS_FIRSTPAGE        0x00000002
#define XLPDEV_FLAGS_CHARDOWNLOAD_ON  0x00000004
#define XLPDEV_FLAGS_ENDDOC_CALLED    0x00000008
#define XLPDEV_FLAGS_RESETPDEV_CALLED 0x00000010
#define XLPDEV_FLAGS_STARTPAGE_CALLED 0x00000020
#define XLPDEV_FLAGS_SUBST_TRNCOLOR_WITH_WHITE 0x00000040 //Used in CommonRopBlt when rendering DrvTransparentBlt

    //
    // Device font data structures
    //
    DWORD      dwcbTransSize;
    PTRANSDATA pTransOrg;
    DWORD      dwcbWidthSize;
    PLONG      plWidth;

    //
    // Device font string cache
    //
    DWORD      dwCharCount;
    DWORD      dwMaxCharCount;
    PPOINTL    pptlCharAdvance;
    PWORD      pawChar;
    LONG       lStartX;
    LONG       lStartY;
    LONG       lPrevX;
    LONG       lPrevY;

    #define PCLXL_FONTNAME_SIZE 16
    CHAR ubFontName[PCLXL_FONTNAME_SIZE+1];

    //
    // TrueType font width
    //
    DWORD      dwFixedTTWidth;

    //
    // Cursor position cache
    //
    LONG lX;
    LONG lY;

    //
    // Scaled IFIMETRICS.fwdUnitsPerEm.
    //        IFIMETRICS.fwdMaxCharWidth
    //
    FWORD      fwdUnitsPerEm;
    FWORD      fwdMaxCharWidth;

    //
    // Text rotation
    //
    DWORD      dwTextAngle;

    //
    //
    // Brush
    //
    DWORD      dwLastBrushID;
    DWORD      dwFontHeight;
    DWORD      dwFontWidth;
    DWORD      dwTextRes;

    //
    // TrueType
    //
    DWORD      dwNumOfTTFont;
    XLTrueType *pTTFile;

    //
    // Output
    //
    XLOutput   *pOutput;

    //
    // Reset font cache
    //
    XLFont     *pXLFont;

    //
    // Glyph cache
    //
    XLGlyphCache *pXLGlyph;

    //
    // Transparent Color
    //
    ULONG  ulTransColor; //Index for palette. Actual for RGB. Used in conjunction with XLPDEV_FLAGS_SUBST_TRNCOLOR_WITH_WHITE
} XLPDEV, *PXLPDEV;

#endif // _XLPDEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xltt.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xltt.h

Abstract:

    TrueType font handlig object

Environment:

    Windows Whistler

Revision History:

    03/23/00
        Created it.

--*/

#ifndef _XLTT_H_
#define _XLTT_H_

//
// TrueType font 
//
// Header
//
typedef struct _TTHEADER {
    DWORD  dwSfntVersion;
    USHORT usNumTables;
    USHORT usSearchRange;
    USHORT usEntrySelector;
    USHORT usRangeShift;
} TTHEADER, *PTTHEADER;

typedef struct _TTCHEADER {
    DWORD dwTTCTag;
    DWORD dwVersion;
    ULONG ulDirCount;
} TTCHEADER, *PTTCHEADER;

//
// Directory
//
typedef struct _TTDIR {
    ULONG  ulTag;
    ULONG  ulCheckSum;
    ULONG  ulOffset;
    ULONG  ulLength;
} TTDIR, *PTTDIR;

//
// head table
// 
typedef DWORD longDateTime[2];

typedef struct _HEAD {
    DWORD Tableversionnumber;
    DWORD fontRevision;
    ULONG checkSumAdjustment;
    ULONG magicNumber;
    USHORT flags;
    USHORT unitsPerEm;
    longDateTime created;
    longDateTime modified;
    FWORD xMin;
    FWORD yMin;
    FWORD xMax;
    FWORD yMax;
    USHORT macStyle;
    USHORT lowestRecPPEM;
    SHORT fontDirectionHint;
    SHORT indexToLocFormat;
    SHORT glyphDataFormat;
} HEAD, *PHEAD;

//
// maxp table
//
typedef struct _MAXP {
    DWORD  Tableversionnumber;
    USHORT numGlyphs;
    USHORT maxPoints;
    USHORT maxContours;
    USHORT maxCompositePoints;
    USHORT maxCompositeContours;
    USHORT maxZones;
    USHORT maxTwilightPoints;
    USHORT maxStorage;
    USHORT maxFunctionDefs;
    USHORT maxInstructionDefs;
    USHORT maxStackElements;
    USHORT maxSizeOfInstructions;
    USHORT maxComponentElements;
    USHORT maxComponentDepth;
} MAXP, *PMAXP;

//
// hhea table
//
typedef struct _HHEA {
    DWORD dwVersion;
    SHORT sAscender;
    SHORT sDescender;
    SHORT sLineGap;
    USHORT usAdvanceWidthMax;
    SHORT sMinLeftSideBearing;
    SHORT sMinRightSideBearing;
    SHORT sxMaxExtent;
    SHORT sCaretSlopeRise;
    SHORT sCaretSlopeRun;
    SHORT sCaretOffset;
    SHORT sReserved1;
    SHORT sReserved2;
    SHORT sReserved3;
    SHORT sReserved4;
    SHORT sMetricDataFormat;
    USHORT usNumberOfHMetrics;
} HHEA, *PHHEA;

//
// vhea table
//
typedef struct _VHEA {
    DWORD dwVersion;
    SHORT sAscender;
    SHORT sDescender;
    SHORT sLineGap;
    USHORT usAdvanceHightMax;
    SHORT sMinTopSideBearing;
    SHORT sMinBottomSideBearing;
    SHORT syMaxExtent;
    SHORT sCaretSlopeRise;
    SHORT sCaretSlopeRun;
    SHORT sCaretOffset;
    SHORT sReserved1;
    SHORT sReserved2;
    SHORT sReserved3;
    SHORT sReserved4;
    SHORT sMetricDataFormat;
    USHORT usNumberOfVMetrics;
} VHEA, *PVHEA;

//
// hmtx table
//
typedef struct _HMTX {
    USHORT usAdvanceWidth;
    SHORT  sLeftSideBearing;
} HMTX, *PHMTX;

//
// vmtx table
//
typedef struct _VMTX {
    USHORT usAdvanceWidth;
    SHORT  sTopSideBearing;
} VMTX, *PVMTX;


//
// glyf table
//
typedef struct _GLYF {
    SHORT  numberOfContours;
    SHORT  xMin;
    SHORT  yMin;
    SHORT  xMax;
    SHORT  yMax;
} GLYF, *PGLYF;

//
// Composite glyph description
//
// SHORT -1
//
#define COMPONENTCTRCOUNT           -1

typedef struct _CGLYF {
    SHORT  flags;
    SHORT  glyphIndex;
    SHORT  argument1;
    SHORT  argument2;
} CGLYF, *PCGLYF;

typedef struct _CGLYF_BYTE {
    SHORT  flags;
    SHORT  glyphIndex;
    BYTE   argument1;
    BYTE   argument2;
} CGLYF_BYTE, *PCGLYF_BYTE;

//
// Format 1 Class 1 or 2 is used to download TrueType font.
// Now hhea, hmtx, vhea, vmtx are not necessary.
// 
typedef enum TagID {
    TagID_First = 0,
    TagID_cvt = 0,
    TagID_fpgm,
    TagID_gdir, // Empty table. This is a placeholder for the table that printer
                // will allocate to store downloaded charactres.
    TagID_head,
    TagID_maxp,
    TagID_perp,

    TagID_hhea,
    TagID_hmtx,
    TagID_vhea,
    TagID_vmtx,

    TagID_loca,
    TagID_glyf,
    TagID_os2,

    TagID_MAX,
    TagID_Header = TagID_vmtx + 1
};

typedef enum TTTag {
    TTTag_cvt  = ' tvc', //0
    TTTag_fpgm = 'mgpf', //1
    TTTag_gdir = 'ridg', //2
    TTTag_head = 'daeh', //3
    TTTag_maxp = 'pxam', //4
    TTTag_perp = 'perp', //5

    TTTag_hhea = 'aehh', //6
    TTTag_hmtx = 'xtmh', //7
    TTTag_vhea = 'aehv', //8
    TTTag_vmtx = 'xtmv', //9
    TTTag_loca = 'acol', //10

    TTTag_glyf = 'fylg', //11
    TTTag_os2  = '2/SO', //12
    TTTag_ttcf = 'fctt', //13

    TTTag_INVALID = 0xFFFFFFFF
};


class XLTrueType
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE ('xltt')

public:

    XLTrueType::
    XLTrueType(VOID);

    XLTrueType::
    ~XLTrueType(VOID);

    HRESULT OpenTTFile(FONTOBJ *pfo);
    HRESULT CloseTTFile(VOID);

    HRESULT SameFont(FONTOBJ* pfo);

    HRESULT IsTTC(VOID);
    HRESULT IsVertical(VOID);
    HRESULT IsDBCSFont(VOID);
    HRESULT GetHeader(PTTHEADER *pHeader);
    DWORD   GetSizeOfTable(TTTag tag);
    HRESULT GetTableDir(TTTag tag, PVOID *pTable);
    HRESULT GetTable(TTTag tag, PVOID *pTable, PDWORD pdwSize);
    DWORD   GetNumOfTag(VOID);
    HRESULT TagAndID(DWORD *pdwID, TTTag *ptag);
    HRESULT GetGlyphData(HGLYPH hGlyph, PBYTE *ppubGlyphData, PDWORD pdwGlyphDataSize);
    HRESULT GetHMTXData(HGLYPH hGlyph, PUSHORT pusAdvanceWidth, PSHORT psLeftSideBearing);
    HRESULT GetVMTXData(HGLYPH hGlyph, PUSHORT pusAdvanceWidth, PSHORT psTopSideBearing, PSHORT psLeftSideBearing);
    HRESULT GetTypoDescender(VOID);

#if DBG
     VOID SetDbgLevel(DWORD dwLevel);
#endif

private:
    DWORD m_dwFlags;
    FONTOBJ *m_pfo;
    PVOID m_pTTFile;
    ULONG m_ulFileSize;

    PTTHEADER m_pTTHeader;
    USHORT    m_usNumTables;
    PTTDIR    m_pTTDirHead;

    DWORD     m_dwNumTag;
    DWORD     m_dwNumGlyph;
    PTTDIR    m_pTTDir[TagID_MAX];

    DWORD     m_dwNumOfHMetrics;
    DWORD     m_dwNumOfVMetrics;

    HRESULT ParseTTDir(VOID);
};

//
// XLTrueType.m_dwFlags
//
#define XLTT_TTC                 0x00000001        // Font is TTC.
#define XLTT_SHORT_OFFSET_TO_LOC 0x00000002        // Short offset to loca table
#define XLTT_VERTICAL_FONT       0x00000004        // Font is a vertial font.

#define XLTT_DIR_PARSED          0x80000000        // The table directory is
                                                   // parsed.
#endif // _XLTT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xloutput.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     xloutput.h

Abstract:

    PCL XL low level output

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _XLOUTPUT_H_
#define _XLOUTPUT_H_

#define RECT_WIDTH(pRect)   ((pRect)->right - (pRect)->left)
#define RECT_HEIGHT(pRect)  ((pRect)->bottom - (pRect)->top)
#define GET_FOREGROUND_ROP3(rop4) ((rop4) & 0xFF)
#define GET_BACKGROUND_ROP3(rop4) (((rop4) >> 8) & 0xFF)
#define ROP3_NEED_PATTERN(rop3)   (((rop3 >> 4) & 0x0F) != (rop3 & 0x0F))
#define ROP3_NEED_SOURCE(rop3)    (((rop3 >> 2) & 0x33) != (rop3 & 0x33))
#define ROP3_NEED_DEST(rop3)      (((rop3 >> 1) & 0x55) != (rop3 & 0x55))


//
// PCLXL number type
//
typedef BYTE  ubyte;
typedef WORD  uint16;
typedef SHORT sint16;
typedef DWORD uint32;
typedef LONG  sint32;
typedef DWORD real32;

class XLWrite
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'xlwr' )

public:
    XLWrite::
    XLWrite();

    XLWrite::
    ~XLWrite();

    inline
    HRESULT
    WriteByte(BYTE ubData);

    inline
    HRESULT
    Write(PBYTE pData, DWORD dwSize);

    inline
    HRESULT
    XLWrite::
    WriteFloat(
        real32 real32_value);

    HRESULT
    Flush(PDEVOBJ pdevobj);

    HRESULT
    Delete(VOID);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    HRESULT
    IncreaseBuffer(DWORD dwAdditionalDataSize);

#define XLWrite_INITSIZE 2048
#define XLWrite_ADDSIZE  2048

    PBYTE m_pBuffer;
    PBYTE m_pCurrentPoint;
    DWORD m_dwBufferSize;
    DWORD m_dwCurrentDataSize;
};


typedef enum XLCmd {
    eBeginSession = 0x41,
    eEndSession   = 0x42,
    eBeginPage    = 0x43,
    eEndPage      = 0x44,

    eComment         = 0x47,
    eOpenDataSource  = 0x48,
    eCloseDataSource = 0x49,

    eBeginFontHeader = 0x4f,
    eReadFontHeader  = 0x50,
    eEndFontHeader   = 0x51,
    eBeginChar       = 0x52,
    eReadChar        = 0x53,
    eEndChar         = 0x54,
    eRemoveFont      = 0x55,
    eSetCharAttributes= 0x56,

    eBeginStream = 0x5b,
    eReadStream  = 0x5c,
    eEndStream   = 0x5d,
    eExecStream  = 0x5e,


    ePopGS  = 0x60,
    ePushGS = 0x61,

    eSetClipReplace    = 0x62,
    eSetBrushSource    = 0x63,
    eSetCharAngle      = 0x64,
    eSetCharScale      = 0x65,
    eSetCharShear      = 0x66,
    eSetClipIntersect  = 0x67,
    eSetClipRectangle  = 0x68,
    eSetClipToPage     = 0x69,
    eSetColorSpace     = 0x6a,
    eSetCursor         = 0x6b,
    eSetCursorRel      = 0x6c,
    eSetHalftoneMethod = 0x6d,
    eSetFillMode       = 0x6e,
    eSetFont           = 0x6f,

    eSetLineDash       = 0x70,
    eSetLineCap        = 0x71,
    eSetLineJoin       = 0x72,
    eSetMiterLimit     = 0x73,
    eSetPageDefaultCTM = 0x74,
    eSetPageOrigin     = 0x75,
    eSetPageRotation   = 0x76,
    eSetPageScale      = 0x77,
    eSetPatternTxMode  = 0x78,
    eSetPenSource      = 0x79,
    eSetPenWidth       = 0x7a,
    eSetROP            = 0x7b,
    eSetSourceTxMode   = 0x7c,
    eSetCharBoldValue  = 0x7d,

    eSetClipMode       = 0x7f,
    eSetPathToClip     = 0x80,
    eSetCharSubMode    = 0x81,

    eCloseSubPath      = 0x84,
    eNewPath           = 0x85,
    ePaintPath         = 0x86,

    eArcPath           = 0x91,

    eBezierPath        = 0x93,

    eBezierRelPath     = 0x95,
    eChord             = 0x96,
    eChordPath         = 0x97,
    eEllipse           = 0x98,
    eEllipsePath       = 0x99,

    eLinePath          = 0x9b,

    eLineRelPath       = 0x9d,
    ePie               = 0x9e,
    ePiePath           = 0x9f,

    eRectangle         = 0xa0,
    eRectanglePath     = 0xa1,
    eRoundRectangle     = 0xa2,
    eRoundRectanglePath = 0xa3,

    eText     = 0xa8,
    eTextPath = 0xa9,

    eBeginImage       = 0xb0,
    eReadImage        = 0xb1,
    eEndImage         = 0xb2,
    eBeginRastPattern = 0xb3,
    eReadRastPattern  = 0xb4,
    eEndRastPattern   = 0xb5,
    eBeginScan        = 0xb6,

    eEndScan     = 0xb8,
    eScanLineRel = 0xb9
};


//
// Note: It is necessary to initialize HatchBrushAvailability when creating
//       XLOutput.
//
// BUGBUG: Brush management object has to be implemented
//

class XLGState;
class XLOutput: public XLWrite, 
                public XLGState
{
    SIGNATURE( 'tolx' )

public:
    XLOutput::
    XLOutput(VOID);

    XLOutput::
    ~XLOutput(VOID);

    //
    // Set scaling factor
    //
    DWORD
    GetResolutionForBrush();

    VOID
    SetResolutionForBrush(DWORD dwRes);

    //
    // Set device color depth (color/monochrome)
    // 
    HRESULT
    SetDeviceColorDepth(ColorDepth DeviceColorDepth);

    ColorDepth
    GetDeviceColorDepth(VOID);

    //
    // HatchBrushAvailability set/get functions
    //
    VOID
    SetHatchBrushAvailability(
        DWORD dwHatchBrushAvailability);

    DWORD
    GetHatchBrushAvailability(
        VOID);

    //
    // Command
    //
    HRESULT
    Send_cmd(XLCmd Cmd);

    HRESULT
    Send_attr_ubyte(Attribute Attr);

    HRESULT
    Send_attr_uint16(Attribute Attr);


    //
    // Number
    //
    HRESULT
    Send_ubyte(ubyte ubyte_data);
    HRESULT
    Send_ubyte_xy(ubyte ubyte_x, ubyte ubyte_y);
    HRESULT
    Send_ubyte_box(ubyte ubyte_left, ubyte ubyte_top, ubyte ubyte_right, ubyte ubyte_bottom);
    HRESULT
    Send_ubyte_array_header(DWORD dwArrayNum);

    HRESULT
    Send_uint16(uint16 uint16_data);
    HRESULT
    Send_uint16_xy(uint16 uint16_x, uint16 uint16_y);
    HRESULT
    Send_uint16_box(uint16 uint16_left, uint16 uint16_top, uint16 uint16_right, uint16 uint16_bottom);
    HRESULT
    Send_uint16_array_header(DWORD dwArrayNum);

    HRESULT
    Send_uint32(uint32 uint32_data);
    HRESULT
    Send_uint32_xy(uint32 uint32_x, uint32 uint32_y);
    HRESULT
    Send_uint32_box(uint32 uint32_left, uint32 uint32_top, uint32 uint32_right, uint32 uint32_bottom);
    HRESULT
    Send_uint32_array_header(DWORD dwArrayNum);

    HRESULT
    Send_sint16(sint16 sint16_data);
    HRESULT
    Send_sint16_xy(sint16 sint16_x, sint16 sint16_y);
    HRESULT
    Send_sint16_box(sint16 sint16_left, sint16 sint16_top, sint16 sint16_right, sint16 sint16_bottom);
    HRESULT
    Send_sint16_array_header(DWORD dwArrayNum);

    HRESULT
    Send_sint32(sint32 sint32_data);
    HRESULT
    Send_sint32_xy(sint32 sint32_x, sint32 sint32_y);
    HRESULT
    Send_sint32_box(sint32 sint32_left, sint32 sint32_top, sint32 sint32_right, sint32 sint32_bottom);
    HRESULT
    Send_sint32_array_header(DWORD dwArrayNum);

    HRESULT
    Send_real32(real32 real32_data);
    HRESULT
    Send_real32_xy(real32 real32_x, real32 real32_y);
    HRESULT
    Send_real32_box(real32 real32_left, real32 real32_top, real32 real32_right, real32 real32_bottom);
    HRESULT
    Send_real32_array_header(DWORD dwArrayNum);

    //
    // Attribute
    //
    HRESULT
    SetArcDirection(ArcDirection value);

    HRESULT
    SetCharSubModeArray(CharSubModeArray value);

    HRESULT
    SetClipMode(ClipMode value);

    HRESULT
    SetClipRegion(ClipRegion value);

    HRESULT
    SetColorDepth(ColorDepth value);

    HRESULT
    SetColorimetricColorSpace(ColorimetricColorSpace value);

    HRESULT
    SetColorMapping(ColorMapping value);

    HRESULT
    SetColorSpace(ColorSpace value);

    HRESULT
    SetCompressMode(CompressMode value);

    HRESULT
    SetDataOrg(DataOrg value);

    #if 0
    HRESULT
    SetDataSource(DataSource value);
    #endif

    #if 0
    HRESULT
    SetDataType(DataType value);
    #endif

    #if 0
    HRESULT
    SetDitherMatrix(DitherMatrix value);
    #endif

    HRESULT
    SetDuplexPageMode(DuplexPageMode value);

    HRESULT
    SetDuplexPageSide(DuplexPageSide value);
    
    HRESULT
    SetErrorReport(ErrorReport value);

    HRESULT
    SetFillMode(FillMode value);

    HRESULT
    SetLineCap(LineCap value);

    HRESULT
    SetLineJoin(LineJoin value);

    HRESULT
    SetMiterLimit(uint16 uint16_miter);
            
    HRESULT
    SetMeasure(Measure value);

    HRESULT
    SetMediaSize(MediaSize value);

    HRESULT
    SetMediaSource(MediaSource value);

    HRESULT
    SetMediaDestination(MediaDestination value);

    HRESULT
    SetOrientation(Orientation value);

    HRESULT
    SetPatternPersistence(PatternPersistence value);

    HRESULT
    SetSimplexPageMode(SimplexPageMode value);

    HRESULT
    SetTxMode(TxMode value);

    #if 0
    HRESULT
    SetWritingMode(WritingMode value);
    #endif

    //
    // Number/value set function
    //
    HRESULT
    XLOutput::
    SetSourceWidth(
        uint16 srcwidth);

    HRESULT
    XLOutput::
    SetSourceHeight(
        uint16 srcheight);

    HRESULT
    XLOutput::
    SetDestinationSize(
        uint16 dstwidth,
        uint16 dstheight);

    HRESULT
    SetBoundingBox(
        sint16 left,
        sint16 top,
        sint16 right,
        sint16 bottom);

    HRESULT
    SetBoundingBox(
        uint16 left,
        uint16 top,
        uint16 right,
        uint16 bottom);

    HRESULT
    SetROP3(ROP3 rop3);

    HRESULT
    SetGrayLevel(ubyte ubyte_gray);

    HRESULT
    SetRGBColor(uint32 uint32_RGB);

    HRESULT
    SetPatternDefineID(
        sint16 sint16_patternid);

    HRESULT
    SetPaletteDepth(
        ColorDepth value);

    HRESULT
    SetPaletteData(
        ColorDepth value,
        DWORD      dwPaletteNum,
        DWORD     *pdwColorTable);

    HRESULT
    SetPenWidth(
       uint16 uint16_penwidth);

    HRESULT
    SetPageOrigin(
        uint16 uint16_x,
        uint16 uint16_y);

    HRESULT
    SetPageAngle(
        sint16 suint16_Angle);

    HRESULT
    SetPageScale(
        real32 real32_x,
        real32 real32_y);

    //
    // High level function
    //
    HRESULT
    BeginImage(
        ColorMapping CMapping,
        ULONG   ulOutputBPP,
        ULONG   ulSrcWidth,
        ULONG   ulSrcHeight,
        ULONG   ulDestWidth,
        ULONG   ulDestHeight);

    HRESULT
    XLOutput::
    SetOutputBPP(
        ColorMapping CMapping,
        ULONG   ulOutputBPP);

    HRESULT
    XLOutput::
    SetPalette(
        ULONG ulOutputBPP,
        DWORD dwCEntries,
        DWORD *pdwColor);

    HRESULT
    SetClip(
        CLIPOBJ *pco);

    HRESULT
    RoundRectanglePath(
        RECTL  *prclBounds);

    HRESULT
    SetCursor(
        LONG   lX,
        LONG   lY);

    HRESULT
    ReadImage(
        DWORD   dwBlockHeight,
        CompressMode CMode);

    HRESULT
    ReadImage(
        DWORD   dwStartBlock,
        DWORD   dwBlockHeight,
        CompressMode CMode);

    HRESULT
    ReadRasterPattern(
        DWORD   dwBlockHeight,
        CompressMode CMode);

    HRESULT
    RectanglePath(RECTL *prclRect);

    HRESULT
    BezierPath(POINTFIX *pptfx, LONG lPoints);

    HRESULT
    LinePath(POINTFIX *pptfx, LONG lPoints);

    HRESULT
    Path(PATHOBJ *ppo);

    HRESULT
    Paint(VOID);

    HRESULT
    SetBrush(BRUSHOBJ *pbo,
             POINTL *pptlBrushOrg);

    HRESULT
    SetPen(
        LINEATTRS *plineattrs,
        XFORMOBJ *pxo);

    HRESULT
    SetPenColor(
        BRUSHOBJ *pbo,
        POINTL   *pptlBrushOrg);

    inline
    VOID
    SetupBrush(
        BRUSHOBJ *pbo,
        POINTL *pptlBrushOrg,
        CMNBRUSH *pcmnbrush);

    HRESULT
    SetFont(
        FontType fonttype,
        PBYTE    pFontName,
        DWORD    dwFontHeight,
        DWORD    dwFontWidth,
        DWORD    dwSymbolSet,
        DWORD    dwSimulation);

    #define XLOUTPUT_FONTSIM_BOLD     0x00000001
    #define XLOUTPUT_FONTSIM_ITALIC   0x00000002
    #define XLOUTPUT_FONTSIM_VERTICAL 0x00000004

    HRESULT
    SetSourceTxMode(TxMode SrcTxMode);

    HRESULT
    SetPaintTxMode(TxMode PaintTxMode);

    //
    // Helper function
    //
    HRESULT
    GetCursorPos(
        PLONG plx,
        PLONG ply);

    //
    // Set cursor offset value
    //
    HRESULT
    SetCursorOffset(
        LONG lX,
        LONG lY);

#if DBG
    VOID SetOutputDbgLevel(DWORD dwLevel);
    VOID SetGStateDbgLevel(DWORD dwLevel);
#endif

private:
    #define HORIZONTAL_AVAILABLE 0x00000001
    #define VERTICAL_AVAILABLE   0x00000002
    #define BDIAGONAL_AVAILABLE  0x00000004
    #define FDIAGONAL_AVAILABLE  0x00000008
    #define CROSS_AVAILABLE      0x00000010
    #define DIAGCROSS_AVAILABLE  0x00000020

    DWORD m_dwHatchBrushAvailability;
    DWORD m_dwResolution;
    ColorDepth m_DeviceColorDepth;
    ULONG m_lX;
    ULONG m_lY;
    ULONG m_lOffsetX;
    ULONG m_lOffsetY;
#if DBG
    DWORD m_dbglevel;
    DWORD m_dwNumber;
#endif
   
};


#endif // _XLOUTPUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xloutput.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xloutput.cpp

Abstract:

    PCL-XL low level command output implementation

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created it.

--*/

#include "lib.h"
#include "gpd.h"
#include "winres.h"
#include "pdev.h"
#include "common.h"
#include "xlpdev.h"
#include "pclxle.h"
#include "pclxlcmd.h"
#include "xldebug.h"
#include "xlgstate.h"
#include "xloutput.h"


//
// XLWrite
//

XLWrite::
XLWrite(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
#if DBG
    SetDbgLevel(OUTPUTDBG);
#endif

    XL_VERBOSE(("XLWrite:Ctor.\n")); 

    m_pCurrentPoint = 
    m_pBuffer = (PBYTE)MemAlloc(XLWrite_INITSIZE);

    if (NULL == m_pBuffer)
    {
        XL_ERR(("XLWrite:Ctor: failed to allocate memory.\n")); 
        m_dwBufferSize = 0;
        m_dwCurrentDataSize = 0;
    }
    else
    {
        m_dwBufferSize = XLWrite_INITSIZE;
        m_dwCurrentDataSize = 0;
    }

}

XLWrite::
~XLWrite(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLWrite:Dtor.\n")); 
    if (m_pBuffer)
        MemFree(m_pBuffer);
}

HRESULT
XLWrite::
IncreaseBuffer(
    DWORD dwAdditionalDataSize)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PBYTE pTemp;
    DWORD dwNewBufferSize;

    dwNewBufferSize = m_dwBufferSize + XLWrite_ADDSIZE;
    dwAdditionalDataSize += m_dwBufferSize;

    while (dwAdditionalDataSize > dwNewBufferSize)
        dwNewBufferSize += XLWrite_ADDSIZE;

    if (!(pTemp = (PBYTE)MemAlloc(dwNewBufferSize)))
    {
        XL_ERR(("XLWrite::IncreaseBuffer: Memory allocation failed\n"));
        return E_UNEXPECTED;
    }

    if (m_pBuffer)
    {
        if (m_dwCurrentDataSize > 0)
        {
            CopyMemory(pTemp, m_pBuffer, m_dwCurrentDataSize);
        }

        MemFree(m_pBuffer);
    }
    
    m_dwBufferSize = dwNewBufferSize;
    m_pCurrentPoint = pTemp + m_dwCurrentDataSize;
    m_pBuffer = pTemp;

    return S_OK;
}

inline
HRESULT
XLWrite::
Write(
    PBYTE pData,
    DWORD dwSize)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (m_dwBufferSize < m_dwCurrentDataSize + dwSize)
    {
        if (S_OK != IncreaseBuffer(dwSize))
        {
            XL_ERR(("XLWrite::Write: failed to increae memory\n"));
            return E_UNEXPECTED;
        }
    }

    if (NULL == m_pBuffer || NULL == pData)
    {
        XL_ERR(("XLWrite:Write failed\n"));
        return E_UNEXPECTED;
    }

    CopyMemory(m_pCurrentPoint, pData, dwSize);
    m_pCurrentPoint += dwSize;
    m_dwCurrentDataSize += dwSize;
    return S_OK;
}

inline
HRESULT
XLWrite::
WriteByte(
    BYTE ubData)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    if (m_dwBufferSize < m_dwCurrentDataSize + 2 * sizeof(DWORD))
    {
        //
        // 64 bit alignment
        // Increae quadword
        //
        if (S_OK != IncreaseBuffer(2 * sizeof(DWORD)))
        {
            XL_ERR(("XLWrite::WriteByte: failed to increae memory\n"));
            return E_UNEXPECTED;
        }
    }

    if (NULL == m_pBuffer)
    {
        XL_ERR(("XLWrite:WriteByte failed\n"));
        return E_UNEXPECTED;
    }

    *m_pCurrentPoint++ = ubData;
    m_dwCurrentDataSize ++;
    return S_OK;
}

inline
HRESULT
XLWrite::
WriteFloat(
    real32 real32_value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    return Write((PBYTE)&real32_value, sizeof(real32_value));
}


HRESULT
XLWrite::
Flush(
    PDEVOBJ pdevobj)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    ASSERTMSG(m_pBuffer != NULL, ("XLWrite:m_pBuffer = NULL\n"));

    if (NULL == m_pBuffer || NULL == pdevobj)
    {
        return E_UNEXPECTED;
    }

    WriteSpoolBuf((PPDEV)pdevobj, m_pBuffer, m_dwCurrentDataSize);
    m_dwCurrentDataSize = 0;
    m_pCurrentPoint =  m_pBuffer;
    return S_OK;
}

HRESULT
XLWrite::
Delete(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    ASSERTMSG(m_pBuffer != NULL, ("XLWrite:m_pBuffer = NULL\n"));

    if (NULL == m_pBuffer)
    {
        return E_UNEXPECTED;
    }

    m_dwCurrentDataSize = 0;
    m_pCurrentPoint =  m_pBuffer;
    return S_OK;
}


#if DBG
VOID
XLWrite::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    m_dbglevel = dwLevel;
}
#endif

//
// XLOutput
//

XLOutput::
XLOutput(VOID):
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
#if DBG
    m_dwNumber(0),
#endif
    m_dwHatchBrushAvailability(0)
{
#if DBG
    SetOutputDbgLevel(OUTPUTDBG);
#endif
}

XLOutput::
~XLOutput(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
}

#if DBG
VOID
XLOutput::
SetOutputDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    this->m_dbglevel = dwLevel;
    XLWrite *pXLWrite = this;
    pXLWrite->SetDbgLevel(dwLevel);
}

VOID
XLOutput::
SetGStateDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XLGState *pGState = this;

    pGState->SetAllDbgLevel(dwLevel);
}
#endif

//
// Misc. functions
//
VOID
XLOutput::
SetHatchBrushAvailability(
    DWORD dwHatchBrushAvailability)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    m_dwHatchBrushAvailability = dwHatchBrushAvailability;
}

DWORD
XLOutput::
GetHatchBrushAvailability(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    return m_dwHatchBrushAvailability;
}

HRESULT
XLOutput::
SetDeviceColorDepth(
    ColorDepth DeviceColorDepth)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    m_DeviceColorDepth = DeviceColorDepth;
    return S_OK;
}

ColorDepth
XLOutput::
GetDeviceColorDepth(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    return m_DeviceColorDepth;
}

DWORD
XLOutput::
GetResolutionForBrush(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    return m_dwResolution;
}

VOID
XLOutput::
SetResolutionForBrush(
    DWORD dwRes)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    m_dwResolution = dwRes;
}

HRESULT
XLOutput::
SetCursorOffset(
    LONG lX,
    LONG lY)
{

    m_lOffsetX = lX;
    m_lOffsetY = lY;
    return S_OK;
}

//
// PCL-XL basic send functions
//
HRESULT
XLOutput::
Send_cmd(XLCmd Cmd)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLOutput:Send_cmd(%d).\n", m_dwNumber++)); 
    WriteByte(Cmd);
    return S_OK;
}

HRESULT
XLOutput::
Send_attr_ubyte(
 Attribute Attr)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(Attr);
    return S_OK;
}

HRESULT
XLOutput::
Send_attr_uint16(
 Attribute Attr)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte((ubyte)PCLXL_attr_uint16);
    Send_uint16((uint16)Attr);
    return S_OK;
}

//
// single
//
HRESULT
XLOutput::
Send_ubyte(
 ubyte ubyte_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(ubyte_data);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint16(
 uint16 uint16_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint16);
    Write((PBYTE)&uint16_data, sizeof(uint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_uint32(
 uint32 uint32_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint32);
    Write((PBYTE)&uint32_data, sizeof(uint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint16(
 sint16 sint16_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint16);
    Write((PBYTE)&sint16_data, sizeof(sint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint32(
 sint32 sint32_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint32);
    Write((PBYTE)&sint32_data, sizeof(sint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_real32(
real32 real32_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    WriteByte(PCLXL_real32);
    WriteFloat(real32_data);
    return S_OK;
}

//
// xy
//
HRESULT
XLOutput::
Send_ubyte_xy(
 ubyte ubyte_x,
 ubyte ubyte_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte_xy);
    WriteByte(ubyte_x);
    WriteByte(ubyte_y);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint16_xy(
 uint16 uint16_x,
 uint16 uint16_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint16_xy);
    Write((PBYTE)&uint16_x, sizeof(uint16));
    Write((PBYTE)&uint16_y, sizeof(uint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_uint32_xy(
 uint32 uint32_x,
 uint32 uint32_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint32_xy);
    Write((PBYTE)&uint32_x, sizeof(uint32));
    Write((PBYTE)&uint32_y, sizeof(uint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint16_xy(
 sint16 sint16_x,
 sint16 sint16_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint16_xy);
    Write((PBYTE)&sint16_x, sizeof(sint16));
    Write((PBYTE)&sint16_y, sizeof(sint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint32_xy(
 sint32 sint32_x,
 sint32 sint32_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint32_xy);
    Write((PBYTE)&sint32_x, sizeof(sint32));
    Write((PBYTE)&sint32_y, sizeof(sint32));
    return S_OK;
}


HRESULT
XLOutput::
Send_real32_xy(
real32 real32_x,
real32 real32_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    WriteByte(PCLXL_real32_xy);
    WriteFloat(real32_x);
    WriteFloat(real32_y);
    return S_OK;
}

//
// box
//
HRESULT
XLOutput::
Send_ubyte_box(
 ubyte ubyte_left,
 ubyte ubyte_top,
 ubyte ubyte_right,
 ubyte ubyte_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte_box);
    WriteByte(ubyte_left);
    WriteByte(ubyte_top);
    WriteByte(ubyte_right);
    WriteByte(ubyte_bottom);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint16_box(
 uint16 uint16_left,
 uint16 uint16_top,
 uint16 uint16_right,
 uint16 uint16_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint16_box);
    Write((PBYTE)&uint16_left, sizeof(uint16));
    Write((PBYTE)&uint16_top, sizeof(uint16));
    Write((PBYTE)&uint16_right, sizeof(uint16));
    Write((PBYTE)&uint16_bottom, sizeof(uint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_uint32_box(
 uint32 uint32_left,
 uint32 uint32_top,
 uint32 uint32_right,
 uint32 uint32_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint32_box);
    Write((PBYTE)&uint32_left, sizeof(uint32));
    Write((PBYTE)&uint32_top, sizeof(uint32));
    Write((PBYTE)&uint32_right, sizeof(uint32));
    Write((PBYTE)&uint32_bottom, sizeof(uint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint16_box(
 sint16 sint16_left,
 sint16 sint16_top,
 sint16 sint16_right,
 sint16 sint16_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint16_box);
    Write((PBYTE)&sint16_left, sizeof(sint16));
    Write((PBYTE)&sint16_top, sizeof(sint16));
    Write((PBYTE)&sint16_right, sizeof(sint16));
    Write((PBYTE)&sint16_bottom, sizeof(sint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint32_box(
 sint32 sint32_left,
 sint32 sint32_top,
 sint32 sint32_right,
 sint32 sint32_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint32_box);
    Write((PBYTE)&sint32_left, sizeof(sint32));
    Write((PBYTE)&sint32_top, sizeof(sint32));
    Write((PBYTE)&sint32_right, sizeof(sint32));
    Write((PBYTE)&sint32_bottom, sizeof(sint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_real32_box(
 real32 real32_left,
 real32 real32_top,
 real32 real32_right,
 real32 real32_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    WriteByte(PCLXL_real32_box);

    //
    // left
    //
    WriteFloat(real32_left);

    //
    // top
    //
    WriteFloat(real32_top);

    //
    // right
    //
    WriteFloat(real32_right);

    //
    // bottom
    //
    WriteFloat(real32_bottom);
    return S_OK;
}

//
// array
//
HRESULT
XLOutput::
Send_ubyte_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint16_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint16_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint32_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint32_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_sint16_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint16_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_sint32_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint32_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_real32_array_header(
DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_real32_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

//
// Attributes
//
HRESULT
XLOutput::
SetArcDirection(
ArcDirection value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ArcDirection);
    return S_OK;
}

HRESULT
XLOutput::
SetCharSubModeArray(
CharSubModeArray value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_CharSubModeArray);
    return S_OK;
}

HRESULT
XLOutput::
SetClipMode(
ClipMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ClipMode);
    WriteByte(PCLXL_SetClipMode);
    return S_OK;
}

HRESULT
XLOutput::
SetClipRegion(
ClipRegion value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ClipRegion);
    return S_OK;
}

HRESULT
XLOutput::
SetColorDepth(
ColorDepth value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ColorDepth);
    return S_OK;
}

HRESULT
XLOutput::
SetColorimetricColorSpace(
ColorimetricColorSpace value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ColorimetricColorSpace);
    return S_OK;
}

HRESULT
XLOutput::
SetColorMapping(
ColorMapping value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ColorMapping);
    return S_OK;
}

HRESULT
XLOutput::
SetColorSpace(
ColorSpace value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ColorSpace);
    return S_OK;
}

HRESULT
XLOutput::
SetCompressMode(
CompressMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_CompressMode);
    return S_OK;
}

HRESULT
XLOutput::
SetDataOrg(
DataOrg value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DataOrg);
    return S_OK;
}

#if 0
HRESULT
XLOutput::
SetDataSource(
DataSource value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DataSource);
    return S_OK;
}
#endif

#if 0
HRESULT
XLOutput::
SetDataType(
DataType value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DataType);
    return S_OK;
}
#endif

#if 0
HRESULT
XLOutput::
SetDitherMatrix(
DitherMatrix value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DitherMatrix);
    return S_OK;
}
#endif

HRESULT
XLOutput::
SetDuplexPageMode(
DuplexPageMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DuplexPageMode);
    return S_OK;
}

HRESULT
XLOutput::
SetDuplexPageSide(
DuplexPageSide value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DuplexPageSide);
    return S_OK;
}

HRESULT
XLOutput::
SetErrorReport(
ErrorReport value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ErrorReport);
    WriteByte(value);
    return S_OK;
}

HRESULT
XLOutput::
SetLineCap(
LineCap value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_LineCap);
    WriteByte(PCLXL_SetLineCap);
    return S_OK;
}

HRESULT
XLOutput::
SetLineJoin(
LineJoin value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_LineJoin);
    WriteByte(PCLXL_SetLineJoin);
    return S_OK;
}

HRESULT
XLOutput::
SetMeasure(
Measure value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_Measure);
    return S_OK;
}

HRESULT
XLOutput::
SetMediaSize(
MediaSize value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_MediaSize);
    return S_OK;
}

HRESULT
XLOutput::
SetMediaSource(
MediaSource value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_MediaSource);
    return S_OK;
}

HRESULT
XLOutput::
SetMediaDestination(
MediaDestination value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_MediaDestination);
    return S_OK;
}

HRESULT
XLOutput::
SetOrientation(
Orientation value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_Orientation);
    return S_OK;
}

HRESULT
XLOutput::
SetPatternPersistence(
PatternPersistence value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_PatternPersistence);
    return S_OK;
}

HRESULT
XLOutput::
SetSimplexPageMode(
SimplexPageMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_SimplexPageMode);
    return S_OK;
}

HRESULT
XLOutput::
SetTxMode(
TxMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_TxMode);
    return S_OK;
}

#if 0
HRESULT
XLOutput::
SetWritingMode(
WritingMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_WritingMode);
    return S_OK;
}
#endif

//
// Value set function
//

HRESULT
XLOutput::
SetFillMode(
FillMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    Send_ubyte(value);
    Send_attr_ubyte(eFillMode);
    Send_cmd(eSetFillMode);
    return S_OK;
}


HRESULT
XLOutput::
SetSourceWidth(
uint16 srcwidth)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16(srcwidth) &&
        S_OK == Send_attr_ubyte(eSourceWidth)    )
        return S_OK;
    else
        return S_FALSE;
}


HRESULT
XLOutput::
SetSourceHeight(
uint16 srcheight)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16(srcheight) &&
        S_OK == Send_attr_ubyte(eSourceHeight)    )
        return S_OK;
    else
        return S_FALSE;
}


HRESULT
XLOutput::
SetDestinationSize(
uint16 dstwidth,
uint16 dstheight)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16_xy(dstwidth, dstheight) &&
        S_OK == Send_attr_ubyte(eDestinationSize)    )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetBoundingBox(
uint16 left,
uint16 top,
uint16 right,
uint16 bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16_box(left, top, right, bottom) &&
        S_OK == Send_attr_ubyte(eBoundingBox) )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetBoundingBox(
sint16 left,
sint16 top,
sint16 right,
sint16 bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_sint16_box(left, top, right, bottom) &&
        S_OK == Send_attr_ubyte(eBoundingBox) )
        return S_OK;
    else
        return S_FALSE;
}


HRESULT
XLOutput::
SetROP3(
ROP3 rop3)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XLGState *pGState = this;

    if (S_OK == pGState->CheckROP3(rop3))
        return S_OK;

    if (S_OK == Send_ubyte((ubyte)rop3) &&
        S_OK == Send_attr_ubyte(eROP3) &&
        S_OK == Send_cmd(eSetROP)  &&
        S_OK == pGState->SetROP3(rop3))
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetPatternDefineID(
sint16 sint16_patternid)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_sint16(sint16_patternid) &&
        S_OK == Send_attr_ubyte(ePatternDefineID))
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetPaletteDepth(
ColorDepth value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == WriteByte(PCLXL_ubyte) &&
        S_OK == WriteByte(value) &&
        S_OK == WriteByte(PCLXL_attr_ubyte) &&
        S_OK == WriteByte(PCLXL_PaletteDepth) )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetPenWidth(
uint16 uint16_penwidth)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16(uint16_penwidth) &&
        S_OK == Send_attr_ubyte(ePenWidth) &&
        S_OK == Send_cmd(eSetPenWidth)  )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetMiterLimit(
uint16 uint16_miter)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16(uint16_miter) &&
        S_OK == Send_attr_ubyte(eMiterLength) &&
        S_OK == Send_cmd(eSetMiterLimit))
        return S_OK;
    else
        return S_FALSE;

}

HRESULT
XLOutput::
SetPageOrigin(
uint16 uint16_x,
uint16 uint16_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16_xy(uint16_x, uint16_y) &&
        S_OK == Send_attr_ubyte(ePageOrigin) &&
        S_OK == Send_cmd(eSetPageOrigin))
        return S_OK;
    else
        return S_FALSE;

}

HRESULT
XLOutput::
SetPageAngle(
sint16 sint16_Angle)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_sint16(sint16_Angle) &&
        S_OK == Send_attr_ubyte(ePageAngle) &&
        S_OK == Send_cmd(eSetPageRotation))
        return S_OK;
    else
        return S_FALSE;

}


HRESULT
XLOutput::
SetPageScale(
real32 real32_x,
real32 real32_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_real32_xy(real32_x, real32_y) &&
        S_OK == Send_attr_ubyte(ePageScale) &&
        S_OK == Send_cmd(eSetPageScale))
        return S_OK;
    else
        return S_FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlvminit.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlvminit.cpp

Abstract:

    PCLXL module initializer

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created it.

--*/

#include "vectorc.h"
#include "xlvminit.h"

static VMPROCS PCLXLProcs =
{
    PCLXLDriverDMS,             // PCLXLDriverDMS
    NULL,                       // PCLXLCommandCallback
    NULL,                       // PCLXLImageProcessing
    NULL,                       // PCLXLFilterGraphics
    NULL,                       // PCLXLCompression
    NULL,                       // PCLXLHalftonePattern
    NULL,                       // PCLXLMemoryUsage
    NULL,                       // PCLXLTTYGetInfo
    PCLXLDownloadFontHeader,    // PCLXLDownloadFontHeader
    PCLXLDownloadCharGlyph,     // PCLXLDownloadCharGlyph
    PCLXLTTDownloadMethod,      // PCLXLTTDownloadMethod
    PCLXLOutputCharStr,         // PCLXLOutputCharStr
    PCLXLSendFontCmd,           // PCLXLSendFontCmd
    PCLXLTextOutAsBitmap,                       
    PCLXLEnablePDEV,
    PCLXLResetPDEV,
    NULL,                       // PCLXLCompletePDEV,
    PCLXLDisablePDEV,
    NULL,                       // PCLXLEnableSurface,
    NULL,                       // PCLXLDisableSurface,
    PCLXLDisableDriver,
    PCLXLStartDoc,
    PCLXLStartPage,
    PCLXLSendPage,
    PCLXLEndDoc,
    NULL,
    NULL,
    NULL,
    PCLXLBitBlt,
    PCLXLStretchBlt,
    PCLXLStretchBltROP,
    PCLXLPlgBlt,
    PCLXLCopyBits,
    NULL,
    PCLXLRealizeBrush,
    PCLXLLineTo,
    PCLXLStrokePath,
    PCLXLFillPath,
    PCLXLStrokeAndFillPath,
    PCLXLGradientFill,
    PCLXLAlphaBlend,
    PCLXLTransparentBlt,
    PCLXLTextOut,
    PCLXLEscape,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

PVMPROCS PCLXLInitVectorProcTable (
                            PDEV    *pPDev,
                            DEVINFO *pDevInfo,
                            GDIINFO *pGDIInfo )
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS)
        return NULL;
    else
        return &PCLXLProcs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlvminit.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

        xlvminit.h

Abstract:

        Declaration of functions that this plugin supports. 
        (look in vectorif.h) 

Environment:

        Windows 2000

Revision History:

        02/29/00 -hsingh-
            Created

        03/23/00 
            Modified for PCL XL

--*/


#ifndef _XLVMINIT_H_
#define _XLVMINIT_H_

#include "vectorc.h"

// extern interface declarations
#ifdef __cplusplus
extern "C" {
#endif




    //
    // Part. 1
    // Functions listed in oemkm.h
    //
        BOOL APIENTRY
        PCLXLDriverDMS(
                PVOID   pdevobj,
                PVOID   pvBuffer,
                DWORD   cbSize,
                PDWORD  pcbNeeded
                );

        INT APIENTRY
        PCLXLCommandCallback(
                PDEVOBJ pdevobj,
                DWORD   dwCmdCbID,
                DWORD   dwCount,
                PDWORD  pdwParams
                );

        LONG APIENTRY
        PCLXLImageProcessing(
                PDEVOBJ             pdevobj,
                PBYTE               pSrcBitmap,
                PBITMAPINFOHEADER   pBitmapInfoHeader,
                PBYTE               pColorTable,
                DWORD               dwCallbackID,
                PIPPARAMS           pIPParams,
                OUT PBYTE           *ppbResult
                );

        LONG APIENTRY
        PCLXLFilterGraphics(
                PDEVOBJ     pdevobj,
                PBYTE       pBuf,
                DWORD       dwLen
                );

        
        LONG APIENTRY
        PCLXLCompression(
                PDEVOBJ     pdevobj,
                PBYTE       pInBuf,
                PBYTE       pOutBuf,
                DWORD       dwInLen,
                DWORD       dwOutLen,
                INT     *piResult
                );

        LONG APIENTRY
        PCLXLHalftonePattern(
                PDEVOBJ     pdevobj,
                PBYTE       pHTPattern,
                DWORD       dwHTPatternX,
                DWORD       dwHTPatternY,
                DWORD       dwHTNumPatterns,
                DWORD       dwCallbackID,
                PBYTE       pResource,
                DWORD       dwResourceSize
                );


        LONG APIENTRY
        PCLXLMemoryUsage(
                PDEVOBJ         pdevobj,
                POEMMEMORYUSAGE pMemoryUsage
                );

        LONG APIENTRY
        PCLXLTTYGetInfo(
                PDEVOBJ     pdevobj,
                DWORD       dwInfoIndex,
                PVOID       pOutputBuf,
                DWORD       dwSize,
                DWORD       *pcbcNeeded
                );

        LONG APIENTRY
        PCLXLDownloadFontHeader(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG APIENTRY
        PCLXLDownloadCharGlyph(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                HGLYPH      hGlyph,
                PDWORD      pdwWidth,
                OUT DWORD   *pdwResult
                );

        LONG APIENTRY
        PCLXLTTDownloadMethod(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG APIENTRY
        PCLXLOutputCharStr(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                DWORD       dwType,
                DWORD       dwCount,
                PVOID       pGlyph
                );

        
        LONG APIENTRY
        PCLXLSendFontCmd(
                PDEVOBJ      pdevobj,
                PUNIFONTOBJ  pUFObj,
                PFINVOCATION pFInv
                );

        BOOL APIENTRY
        PCLXLTextOutAsBitmap(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

    //
    // Part 2.
    // Functions listed in enable.c
    // The order of functions listed is same as the order in 
    // static DRVFN UniDriverFuncs[]  in unidrv2\control\enable.c
    //
        PDEVOEM APIENTRY
        PCLXLEnablePDEV(
                PDEVOBJ   pdevobj,
                PWSTR     pPrinterName,
                ULONG     cPatterns,
                HSURF    *phsurfPatterns,
                ULONG     cjGdiInfo,
                GDIINFO  *pGdiInfo,
                ULONG     cjDevInfo,
                DEVINFO  *pDevInfo,
                DRVENABLEDATA  *pded
                );

        BOOL APIENTRY
        PCLXLResetPDEV(
                PDEVOBJ  pPDevOld,
                PDEVOBJ  pPDevNew
                );

        VOID APIENTRY
        PCLXLCompletePDEV(
                DHPDEV  dhpdev,
                HDEV    hdev
                );

        VOID APIENTRY
        PCLXLDisablePDEV(
                PDEVOBJ pPDev
                );

        BOOL APIENTRY
        PCLXLEnableSurface(
                PDEVOBJ pPDev
                );

        VOID APIENTRY
        PCLXLDisableSurface(
                PDEVOBJ pPDev
                );

        VOID APIENTRY
        PCLXLDisableDriver(
                VOID
                );

        BOOL APIENTRY
        PCLXLStartDoc(
                SURFOBJ *pso,
                PWSTR   pDocName,
                DWORD   jobId
                );

        BOOL APIENTRY
        PCLXLStartPage(
                SURFOBJ *pso
                );

        BOOL APIENTRY
        PCLXLSendPage(
                SURFOBJ *pso
                );

        BOOL APIENTRY
        PCLXLEndDoc(
                SURFOBJ *pso,
                FLONG   flags
                );

        BOOL APIENTRY
        PCLXLStartBanding(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL APIENTRY
        PCLXLNextBand(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL APIENTRY
        PCLXLPaint(
                SURFOBJ         *pso,
                CLIPOBJ         *pco,
                BRUSHOBJ        *pbo,
                POINTL          *pptlBrushOrg,
                MIX             mix
                );

        BOOL APIENTRY
        PCLXLBitBlt(
                SURFOBJ    *psoTrg,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclTrg,
                POINTL     *pptlSrc,
                POINTL     *pptlMask,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrush,
                ROP4        rop4
                );

        BOOL APIENTRY
        PCLXLStretchBlt(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode
                );

        BOOL APIENTRY
        PCLXLStretchBltROP(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode,
                BRUSHOBJ   *pbo,
                DWORD       rop4
                );

        BOOL APIENTRY
        PCLXLPlgBlt(
                SURFOBJ         *psoDst,
                SURFOBJ         *psoSrc,
                SURFOBJ         *psoMask,
                CLIPOBJ         *pco,
                XLATEOBJ        *pxlo,
                COLORADJUSTMENT *pca,
                POINTL          *pptlBrushOrg,
                POINTFIX        *pptfixDest,
                RECTL           *prclSrc,
                POINTL          *pptlMask,
                ULONG           iMode
                );

        BOOL APIENTRY
        PCLXLCopyBits(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                POINTL     *pptlSrc
                );

        ULONG APIENTRY
        PCLXLDitherColor(
                DHPDEV  dhpdev,
                ULONG   iMode,
                ULONG   rgbColor,
                ULONG  *pulDither
                );

        BOOL APIENTRY
        PCLXLRealizeBrush(
                BRUSHOBJ   *pbo,
                SURFOBJ    *psoTarget,
                SURFOBJ    *psoPattern,
                SURFOBJ    *psoMask,
                XLATEOBJ   *pxlo,
                ULONG       iHatch
                );

        BOOL  APIENTRY
        PCLXLLineTo(
                SURFOBJ    *pso,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                LONG        x1,
                LONG        y1,
                LONG        x2,
                LONG        y2,
                RECTL      *prclBounds,
                MIX         mix
                );
        
        BOOL APIENTRY
        PCLXLStrokePath(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                LINEATTRS  *plineattrs,
                MIX         mix
                );
        
        BOOL APIENTRY
        PCLXLFillPath(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                MIX         mix,
                FLONG       flOptions 
                );
        
        BOOL APIENTRY
        PCLXLStrokeAndFillPath(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pboStroke,
                LINEATTRS  *plineattrs,
                BRUSHOBJ   *pboFill,
                POINTL     *pptlBrushOrg,
                MIX         mixFill,
                FLONG       flOptions
                );
        
        BOOL APIENTRY
        PCLXLGradientFill(
                SURFOBJ    *psoDest,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                TRIVERTEX  *pVertex,
                ULONG       nVertex,
                PVOID       pMesh,
                ULONG       nMesh,
                RECTL      *prclExtents,
                POINTL     *pptlDitherOrg,
                ULONG       ulMode
                );

        BOOL APIENTRY
        PCLXLAlphaBlend(
                SURFOBJ    *psoDest,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDest,
                RECTL      *prclSrc,
                BLENDOBJ   *pBlendObj
                );

        BOOL APIENTRY
        PCLXLTransparentBlt(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                ULONG      iTransColor,
                ULONG      ulReserved
                );

        BOOL APIENTRY
        PCLXLTextOut(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

        ULONG APIENTRY
        PCLXLEscape(
                SURFOBJ    *pso,
                ULONG       iEsc,
                ULONG       cjIn,
                PVOID       pvIn,
                ULONG       cjOut,
                PVOID       pvOut
                );

        PIFIMETRICS APIENTRY
        PCLXLQueryFont(
                DHPDEV      dhpdev,
                ULONG       iFile,
                ULONG       iFace,
                ULONG      *pid
                );

        PVOID APIENTRY
        PCLXLQueryFontTree(
                DHPDEV  dhpdev,
                ULONG   iFile,
                ULONG   iFace,
                ULONG   iMode,
                ULONG  *pid 
                );

        LONG APIENTRY
        PCLXLQueryFontData(
                DHPDEV      dhpdev,
                FONTOBJ    *pfo,
                ULONG       iMode,
                HGLYPH      hg,
                GLYPHDATA  *pgd,
                PVOID       pv,
                ULONG       cjSize
                );

        ULONG APIENTRY
        PCLXLGetGlyphMode(
                DHPDEV  dhpdev,
                FONTOBJ *pfo
                );

        ULONG APIENTRY
        PCLXLFontManagement(
                SURFOBJ *pso,
                FONTOBJ *pfo,
                ULONG   iMode,
                ULONG   cjIn,
                PVOID   pvIn,
                ULONG   cjOut,
                PVOID   pvOut
                );

        BOOL APIENTRY
        PCLXLQueryAdvanceWidths(
                DHPDEV  dhpdev,
                FONTOBJ *pfo,
                ULONG   iMode,
                HGLYPH *phg,
                PVOID  *pvWidths,
                ULONG   cGlyphs
                );


#ifdef __cplusplus
}
#endif

#endif  // !_XLVMINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\exts\dbgext.h ===
/******************************Module*Header*******************************\
* Module Name: dbgext.h
*
* Created: 10-Sep-1993 08:36:42
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993 Microsoft Corporation
*
* Dependencies:
*
* common macros for debugger extensions
*
*
\**************************************************************************/


/**************************************************************************\
 *
 * GetAddress - symbol of another module
 *
\**************************************************************************/

#define GetAddress(dst, src)                                                    \
__try {                                                                         \
    char *pj = (char *)(src);                                                   \
/* if it is NTSD, don't want the trailing & */                                  \
    if ((ExtensionApis.nSize < sizeof(WINDBG_EXTENSION_APIS)) &&                \
        (*pj == '&'))                                                           \
    {                                                                           \
        pj++;                                                                   \
    }                                                                           \
    *((ULONG *) &dst) = EvalExpression(pj);                                     \
} __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?                  \
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {            \
    Print("NTSD: Access violation on \"%s\", switch to server context\n", src); \
}

#define GetValue(dst,src)                                                       \
    GetAddress(dst,src)                                                         \
    if (TRUE || ExtensionApis.nSize < sizeof(WINDBG_EXTENSION_APIS))            \
    {                                                                           \
        move(dst,dst);                                                          \
    }

/**************************************************************************\
 *
 * move(dst, src ptr)
 *
\**************************************************************************/

#define move(dst, src)                                              \
__try {                                                             \
    if (ExtensionApis.nSize >= sizeof(WINDBG_EXTENSION_APIS))       \
    {                                                               \
        (*ExtensionApis.lpReadProcessMemoryRoutine)(                \
             (ULONG_PTR) (src), &(dst), sizeof(dst), NULL);          \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), &(dst), sizeof(dst), NULL);\
    }                                                               \
                                                                    \
} __except (EXCEPTION_EXECUTE_HANDLER) {                            \
    Print("exception in move()\n");                                 \
}

/**************************************************************************\
 *
 * move2(dst ptr, src ptr, num bytes)
 *
\**************************************************************************/

#define move2(dst, src,bytes)                                       \
__try {                                                             \
    if (ExtensionApis.nSize >= sizeof(WINDBG_EXTENSION_APIS))       \
    {                                                               \
        (*ExtensionApis.lpReadProcessMemoryRoutine)(                \
             (ULONG_PTR) (src), (dst), (bytes), NULL);               \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), (dst), (bytes), NULL);\
    }                                                               \
                                                                    \
} __except (EXCEPTION_EXECUTE_HANDLER) {                            \
    Print("exception in move2()\n");                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\exts\debug.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    debug.cxx

Abstract:

    Generic debug extensions.

Author:

    Albert Ting (AlbertT)  19-Feb-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

HANDLE hCurrentProcess;
WINDBG_EXTENSION_APIS ExtensionApis;

PWINDBG_OUTPUT_ROUTINE Print;
PWINDBG_GET_EXPRESSION EvalExpression;
PWINDBG_GET_SYMBOL GetSymbolRtn;
PWINDBG_CHECK_CONTROL_C CheckControlCRtn;

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;

BOOL bWindbg = FALSE;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ::ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bWindbg = TRUE;

    return;
}

/*++

Routine Name:

    ExtensionApiVersion

Routine Description:

    Windbg calls this function to match between the
    version of windbg and the extension. If the versions
    doesn't match, windbg will not load the extension.

Arguments:

    None.

Return Value:

    None.

--*/
extern "C"
LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    static EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
    return &ApiVersion;
}

/*++

Routine Name:

    CheckVersion

Routine Description:

    This function is called before every command. It gives
    the extension a chance to compare between the versions
    of the target and the extension.

Arguments:

    None

Return Value:

    None.

--*/
extern "C"
VOID
CheckVersion(
    VOID
    )
{
}

VOID
TDebugExt::
vDumpPDL(
    PDLINK pDLink
    )
{
    Print( "%x  %x", pDLink->FLink, pDLink->BLink );

    if( pDLink->FLink == pDLink->BLink ){
        Print( " <empty>\n" );
    } else {
        Print( "\n" );
    }
}

VOID
TDebugExt::
vDumpStr(
    LPCWSTR pszString
    )
{
    WCHAR szString[MAX_PATH];

    if( (LPCWSTR)pszString == NULL ){

        Print( "(NULL)\n" );
        return;
    }

    szString[0] = 0;

    //
    // First try reading to the end of 1k (pages are 4k on x86, but
    // most strings are < 1k ).
    //
    UINT cbShort = (UINT)(0x400 - ( (ULONG_PTR)pszString & 0x3ff ));
    BOOL bFound = FALSE;

    if( cbShort < sizeof( szString )){

        UINT i;

        move2( szString, pszString, cbShort );

        //
        // Look for a NULL.
        //
        for( i=0; i< cbShort/sizeof( pszString[0] ); ++i )
        {
            if( !szString[i] ){
                bFound = TRUE;
            }
        }

    }

    if( !bFound ){

        move( szString, pszString );
    }

    if( szString[0] == 0 ){
        Print( "\"\"\n" );
    } else {
        Print( "%ws\n", szString );
    }
}

VOID
TDebugExt::
vDumpStrA(
    LPCSTR pszString
    )
{
    CHAR szString[MAX_PATH];

    if( (LPCSTR)pszString == NULL ){

        Print( "(NULL)\n" );
        return;
    }

    szString[0] = 0;

    //
    // First try reading to the end of 1k (pages are 4k on x86, but
    // most strings are < 1k ).
    //
    UINT cbShort = 0x400 - (UINT)( (ULONG_PTR)pszString & 0x3ff );
    BOOL bFound = FALSE;

    if( cbShort < sizeof( szString )){

        UINT i;

        move2( szString, pszString, cbShort );

        //
        // Look for a NULL.
        //
        for( i=0; i< cbShort/sizeof( pszString[0] ); ++i )
        {
            if( !szString[i] ){
                bFound = TRUE;
            }
        }

    }

    if( !bFound ){

        move( szString, pszString );
    }

    if( szString[0] == 0 ){
        Print( "\"\"\n" );
    } else {
        Print( "%hs\n", szString );
    }
}

VOID
TDebugExt::
vDumpTime(
    const SYSTEMTIME& st
    )
{
    Print( "%d/%d/%d %d %d:%d:%d.%d\n",
           st.wMonth,
           st.wDay,
           st.wYear,
           st.wDayOfWeek,
           st.wHour,
           st.wMinute,
           st.wSecond,
           st.wMilliseconds );
}


VOID
TDebugExt::
vDumpFlags(
    ULONG_PTR dwFlags,
    PDEBUG_FLAGS pDebugFlags
    )
{
    ULONG_PTR dwFound = 0;

    Print( "%x [ ", dwFlags );

    for( ; pDebugFlags->dwFlag; ++pDebugFlags ){

        if( dwFlags & pDebugFlags->dwFlag ){
            Print( "%s ", pDebugFlags->pszFlag );
            dwFound |= pDebugFlags->dwFlag;
        }
    }

    Print( "]" );

    //
    // Check if there are extra bits set that we don't understand.
    //
    if( dwFound != dwFlags ){
        Print( "<ExtraBits: %x>", dwFlags & ~dwFound );
    }
    Print( "\n" );
}

VOID
TDebugExt::
vDumpValue(
    ULONG_PTR dwValue,
    PDEBUG_VALUES pDebugValues
    )
{
    Print( "%x ", dwValue );

    for( ; pDebugValues->dwValue; ++pDebugValues ){

        if( dwValue == pDebugValues->dwValue ){
            Print( "%s ", pDebugValues->pszValue );
        }
    }
    Print( "\n" );
}

VOID
TDebugExt::
vDumpTrace(
    ULONG_PTR dwAddress
    )
{
#ifdef TRACE_ENABLED

    INT i;
    CHAR szSymbol[64];
    ULONG_PTR dwDisplacement;
    ULONG_PTR adwTrace[ ( OFFSETOF( TBackTraceDB::TTrace, apvBackTrace ) +
                         sizeof( PVOID ) * VBackTrace::kMaxDepth )
                     / sizeof( ULONG_PTR )];

    if( !dwAddress ){
        return;
    }

    move( adwTrace, dwAddress );

    TBackTraceDB::TTrace *pTrace = (TBackTraceDB::TTrace*)adwTrace;

    printf( "Trace %x Hash = %x Count = %x\n",
            dwAddress,
            pTrace->_ulHash,
            pTrace->_lCount );

    for( i=0; i < VBackTrace::kMaxDepth; i++ ){

        if( !pTrace->apvBackTrace[i] ){
            break;
        }
        GetSymbolRtn( (PVOID)pTrace->apvBackTrace[i],
                      szSymbol,
                      &dwDisplacement );
        Print( "%08x %s+%x\n",
               pTrace->apvBackTrace[i], szSymbol,
               dwDisplacement );
    }

    if( i > 0 ){
        Print( "\n" );
    }
#endif
}

ULONG_PTR
TDebugExt::
dwEval(
    LPSTR& lpArgumentString,
    BOOL   bParam
    )
{
    ULONG_PTR dwReturn;
    LPSTR pSpace = NULL;

    while( *lpArgumentString == ' ' ){
        lpArgumentString++;
    }

    //
    // If it's a parameter, scan to next space and delimit.
    //
    if( bParam ){

        for( pSpace = lpArgumentString; *pSpace && *pSpace != ' '; ++pSpace )
            ;

        if( *pSpace == ' ' ){
            *pSpace = 0;
        } else {
            pSpace = NULL;
        }
    }

    dwReturn = (ULONG_PTR)EvalExpression( lpArgumentString );

    while( *lpArgumentString != ' ' && *lpArgumentString ){
        lpArgumentString++;
    }

    if( pSpace ){
        *pSpace = ' ';
    }

    return dwReturn;
}

/********************************************************************

    Generic extensions

********************************************************************/

VOID
TDebugExt::
vLookCalls(
    HANDLE hProcess,
    HANDLE hThread,
    ULONG_PTR dwStartAddr,
    ULONG_PTR dwLength,
    ULONG_PTR dwFlags
    )
{
#if i386
    struct OPCODES {
        BYTE op;
        UINT uLen;
    };

    OPCODES Opcodes[] = {
        0xe8, 5,            // rel16
        0xff, 6,            // r/m16
        0x0, 0
    };

    dwStartAddr = DWordAlign( dwStartAddr );
    dwLength = DWordAlign( dwLength );

    if( !dwStartAddr ){

        //
        // No address specified; use esp.
        //
        dwStartAddr = DWordAlign( (ULONG_PTR)EvalExpression( "ebp" ));
    }

    if( !dwLength ){

        DWORD Status;
        THREAD_BASIC_INFORMATION ThreadInformation;

        Status = NtQueryInformationThread( hThread,
                                           ThreadBasicInformation,
                                           &ThreadInformation,
                                           sizeof( ThreadInformation ),
                                           NULL
                                           );
        if( NT_SUCCESS( Status )){

            TEB Teb;
            ULONG_PTR dwBase;

            move( Teb, ThreadInformation.TebBaseAddress );

            dwBase = DWordAlign( (ULONG_PTR)Teb.NtTib.StackBase );

            if( dwBase > dwStartAddr ){
                dwLength = dwBase - dwStartAddr;
            }

        } else {

            Print( "Unable to get Teb %d\n", Status );
            return;
        }
    }

    Print( "Start %x End %x (Length %x)\n",
           dwStartAddr, dwStartAddr + dwLength, dwLength );

    if( !( dwFlags & (kLCFlagAll|kLCVerbose )))
    {
        Print( "FramePtr Arguments                   "
               "Next call (move one line up)\n" );
    }

    ULONG_PTR dwAddr;

    for( dwAddr = dwStartAddr;
         dwAddr < dwStartAddr + dwLength;
         ++dwAddr ){

        if( CheckControlCRtn()){
            Print( "Aborted.\n" );
            return;
        }

        //
        // Get a value on the stack and see if it looks like an ebp on
        // the stack.  It should be close to the current address, but
        // be greater.
        //
        ULONG_PTR dwNextFrame = 0;
        move( dwNextFrame, dwAddr );

        BOOL bLooksLikeEbp = dwNextFrame > dwAddr &&
                             dwNextFrame - dwAddr < kMaxCallFrame;
        //
        // If we are dumping all, or it looks like an ebp, dump it.
        //
        if(( dwFlags & kLCFlagAll ) || bLooksLikeEbp ){

            //
            // Check if next address looks like a valid call request.
            //
            ULONG_PTR dwRetAddr = 0;

            //
            // Get return address.
            //
            move( dwRetAddr, dwAddr + sizeof( DWORD ));

            //
            // Get 16 bytes before return address.
            //
            BYTE abyBuffer[16];
            ZeroMemory( abyBuffer, sizeof( abyBuffer ));
            move( abyBuffer, dwRetAddr - sizeof( abyBuffer ));

            //
            // Check if previous bytes look like a call instruction.
            //
            UINT i;
            for( i = 0; Opcodes[i].op; ++i ){

                if( abyBuffer[sizeof( abyBuffer )-Opcodes[i].uLen] ==
                    Opcodes[i].op ){

                    CHAR szSymbol[64];
                    ULONG_PTR dwDisplacement;
                    LPCSTR pszNull = "";
                    LPCSTR pszStar = "*** ";
                    LPCSTR pszPrefix = pszNull;

                    if(( dwFlags & kLCFlagAll ) && bLooksLikeEbp ){
                        pszPrefix = pszStar;
                    }

                    GetSymbolRtn( (PVOID)dwRetAddr,
                                  szSymbol,
                                  &dwDisplacement );

                    //
                    // Found what could be a match: dump it out.
                    //

                    DWORD dwArg[4];
                    move( dwArg, dwAddr + 2*sizeof( DWORD ));

                    if( dwFlags & kLCVerbose ){

                        Print( "%s%x %s+0x%x\n",
                               pszPrefix,
                               dwRetAddr,
                               szSymbol,
                               dwDisplacement );

                        Print( "%s%08x: %08x %08x  %08x %08x %08x %08x\n",
                               pszPrefix,
                               dwAddr,
                               dwNextFrame, dwRetAddr,
                               dwArg[0], dwArg[1], dwArg[2], dwArg[3] );

                        DWORD adwNextFrame[2];
                        ZeroMemory( adwNextFrame, sizeof( adwNextFrame ));
                        move( adwNextFrame, dwNextFrame );

                        Print( "%s%08x: %08x %08x\n\n",
                               pszPrefix,
                               dwNextFrame, adwNextFrame[0], adwNextFrame[1] );
                    } else {

                        Print( "%08x %08x %08x %08x  %08x-%s+0x%x\n",
                               dwAddr,
                               dwArg[0], dwArg[1], dwArg[2],
                               dwRetAddr, szSymbol, dwDisplacement );
                    }
                }
            }
        }
    }
#else
    Print( "Only supported on x86\n" );
#endif
}

VOID
TDebugExt::
vFindPointer(
    HANDLE hProcess,
    ULONG_PTR dwStartAddr,
    ULONG_PTR dwEndAddr,
    ULONG_PTR dwStartPtr,
    ULONG_PTR dwEndPtr
    )
{
    BYTE abyBuf[kFPGranularity];

    //
    // Read each granularity chunk then scan the buffer.
    // (Start by rounding down.)
    //
    ULONG_PTR dwCur;
    for( dwCur = dwStartAddr & ~( kFPGranularity - 1 );
         dwCur < dwEndAddr;
         dwCur += kFPGranularity ){

        ZeroMemory( abyBuf, sizeof( abyBuf ));

        move( abyBuf, dwCur );

        ULONG_PTR i;
        for( i=0; i< kFPGranularity; i += sizeof( DWORD ) ){

            ULONG_PTR dwVal = *((PDWORD)(abyBuf+i));
            if( dwVal >= dwStartPtr &&
                dwVal <= dwEndPtr &&
                dwCur + i >= dwStartAddr &&
                dwCur + i <= dwEndAddr ){

                Print( "%08x : %08x\n", dwCur + i, dwVal );
            }
        }

        if( CheckControlCRtn()){
            Print( "Aborted at %08x.\n", dwCur+i );
            return;
        }
    }
}

VOID
TDebugExt::
vCreateRemoteThread(
    HANDLE hProcess,
    ULONG_PTR dwAddr,
    ULONG_PTR dwParm
    )
{
    DWORD dwThreadId = 0;

    if( !CreateRemoteThread( hProcess,
                             NULL,
                             4*4096,
                             (LPTHREAD_START_ROUTINE)dwAddr,
                             (LPVOID)dwParm,
                             0,
                             &dwThreadId )){

        Print( "<Error: Unable to ct %x( %x ) %d.>\n",
               dwAddr, dwParm, GetLastError( ));
        return;
    }

    Print( "<ct %x( %x ) threadid=<%d>>\n", dwAddr, dwParm, dwThreadId );
}


/********************************************************************

    Extension entrypoints.

********************************************************************/

DEBUG_EXT_HEAD( help )
{
    DEBUG_EXT_SETUP_VARS();

    Print( "Spllib Extensions\n" );
    Print( "---------------------------------------------------------\n" );
    Print( "d       dump spooler structure based on signature\n" );
    Print( "ds      dump pIniSpooler\n" );
    Print( "dlcs    dump localspl's critical section (debug builds only)\n" );
    Print( "lastlog dump localspl's debug tracing (uses ddt flags)\n" );
    Print( "ddev    dump Unicode devmode\n" );
    Print( "ddeva   dump Ansi devmode\n" );
    Print( "dmem    dump spllib heap blocks\n" );
    Print( "---------------------------------------------------------\n" );
    Print( "dcs     dump spllib critical section\n" );
    Print( "ddt     dump spllib debug trace buffer\n" );
    Print( "        ** Recent lines printed first! **\n" );
    Print( "        -c Count (number of recent lines to print)\n" );
    Print( "        -l Level (DBG_*) to print\n" );
    Print( "        -b Dump backtrace (x86 only)\n" );
    Print( "        -d Print debug message (default if -x not specified)\n" );
    Print( "        -x Print hex information\n" );
    Print( "        -r Dump raw buffer: specify pointer to lines\n" );
    Print( "        -t tid: Dump specific thread $1\n" );
    Print( "        -s Skip $1 lines that would otherwise print.\n" );
    Print( "        -m Search for $1 in memory block (gpbtAlloc/gpbtFree only)\n" );
    Print( "dbt     dump raw backtrace\n" );
    Print( "dtbt    dump text backtrace\n" );
    Print( "ddp     dump debug pointers\n" );
    Print( "---------------------------------------------------------\n" );
    Print( "fl      free library $1 (hLibrary)\n" );
    Print( "ct      create thread at $1 with arg $2\n" );
    Print( "fp      find pointer from $1 to $2 range, ptr $3 to $4 range\n" );
    Print( "lc      look for calls at $1 for $2 bytes (x86 only)\n" );
    Print( "        -a Check all for return addresses\n" );
    Print( "        -v Verbose\n" );
    Print( "sleep   Sleep for $1 ms\n" );
    Print( "dbti    Dump KM backtrace index\n");
}


DEBUG_EXT_HEAD( dtbt )
{
    DEBUG_EXT_SETUP_VARS();

    for( ; *lpArgumentString; )
    {
        ULONG_PTR p;
        CHAR szSymbol[64];

        p = TDebugExt::dwEval( lpArgumentString, FALSE );

        if( !p )
        {
            break;
        }

        ULONG_PTR dwDisplacement;

        GetSymbolRtn( (PVOID)p,
                      szSymbol,
                      &dwDisplacement );

        Print( "%08x %s+%x\n", p, szSymbol, dwDisplacement );
    }
}

DEBUG_EXT_HEAD( fl )
{
    DEBUG_EXT_SETUP_VARS();

    //
    // Relies on the fact that kernel32 won't be relocated.
    //
    TDebugExt::vCreateRemoteThread( hCurrentProcess,
                                    (ULONG_PTR)&FreeLibrary,
                                    TDebugExt::dwEval( lpArgumentString, FALSE ));
}

DEBUG_EXT_HEAD( fp )
{
    DEBUG_EXT_SETUP_VARS();

    ULONG_PTR dwStartAddr = TDebugExt::dwEval( lpArgumentString, TRUE );
    ULONG_PTR dwEndAddr = TDebugExt::dwEval( lpArgumentString, TRUE );

    ULONG_PTR dwStartPtr = TDebugExt::dwEval( lpArgumentString, TRUE );
    ULONG_PTR dwEndPtr = TDebugExt::dwEval( lpArgumentString, TRUE );

    TDebugExt::vFindPointer( hCurrentProcess,
                             dwStartAddr,
                             dwEndAddr,
                             dwStartPtr,
                             dwEndPtr );
}


DEBUG_EXT_HEAD( ct )
{
    DEBUG_EXT_SETUP_VARS();

    ULONG_PTR dwStartAddr = TDebugExt::dwEval( lpArgumentString, TRUE );
    ULONG_PTR dwParm = TDebugExt::dwEval( lpArgumentString, FALSE );

    TDebugExt::vCreateRemoteThread( hCurrentProcess,
                                    dwStartAddr,
                                    dwParm );
}

DEBUG_EXT_HEAD( sleep )
{
    DEBUG_EXT_SETUP_VARS();

    const UINT_PTR kSleepInterval = 500;

    ULONG_PTR SleepMS = atoi(lpArgumentString);

    UINT_PTR i = SleepMS / kSleepInterval;

    Sleep((DWORD)(SleepMS % kSleepInterval));

    for (i = SleepMS / kSleepInterval; i; --i)
    {
        if (CheckControlCRtn())
        {
            break;
        }
        Sleep(kSleepInterval);
    }
}

DEBUG_EXT_HEAD( lc )
{
    DEBUG_EXT_SETUP_VARS();

    ULONG_PTR dwFlags = 0;

    for( ; *lpArgumentString; ++lpArgumentString ){

        while( *lpArgumentString == ' ' ){
            ++lpArgumentString;
        }

        if (*lpArgumentString != '-') {
            break;
        }

        ++lpArgumentString;

        switch( *lpArgumentString ){
        case 'A':
        case 'a':

            dwFlags |= TDebugExt::kLCFlagAll;
            break;

        case 'V':
        case 'v':

            dwFlags |= TDebugExt::kLCVerbose;
            break;

        default:
            Print( "Unknown option %c.\n", lpArgumentString[0] );
            return;
        }
    }

    ULONG_PTR dwStartAddr = TDebugExt::dwEval( lpArgumentString, TRUE );
    ULONG_PTR dwLength = TDebugExt::dwEval( lpArgumentString, FALSE );

    TDebugExt::vLookCalls( hCurrentProcess,
                           hCurrentThread,
                           dwStartAddr,
                           dwLength,
                           dwFlags );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\exts\stktrace.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    stktrace.cxx

Abstract:

    KM Stack trace index.

Author:

    Albert Ting (AlbertT)  26-Mar-99

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#ifdef STKTRACE_HACK

DEBUG_EXT_HEAD( dbti )
{
    DEBUG_EXT_SETUP_VARS();

    UINT i;

    UINT Index = TDebugExt::dwEval( lpArgumentString, FALSE );
    UINT_PTR p = EvalExpression("&ntoskrnl!RtlpStackTraceDataBase");

    UINT_PTR stdAddr;
    move(stdAddr, p);

    Print("RtlpStackTraceDataBase: %x\n", stdAddr);

    STACK_TRACE_DATABASE std;
    move(std, stdAddr);

    UINT_PTR cBuckets = std.NumberOfBuckets;
    PSTACK_TRACE_DATABASE pstdLarge;

    pstdLarge = (PSTACK_TRACE_DATABASE)LocalAlloc(LPTR,
                                                  sizeof(STACK_TRACE_DATABASE) +
                                                  sizeof(PVOID) * cBuckets);

    Print("Checking %x buckets\n", cBuckets);

    if (!pstdLarge)
    {
        Print("Failed to alloc %x buckets\n", cBuckets);
    }
    else
    {
        move2(pstdLarge, stdAddr, sizeof(STACK_TRACE_DATABASE) + sizeof(PVOID) * cBuckets);

        for (i=0; i < cBuckets; ++i)
        {
            //
            // Walk each hash chain.
            //
            RTL_STACK_TRACE_ENTRY ste;

            for (p = (UINT_PTR)pstdLarge->Buckets[i]; p; p = (UINT_PTR)ste.HashChain)
            {
                if (CheckControlCRtn())
                    return;

                move(ste, p);

                if (ste.Index == Index)
                {
                    break;
                }
            }

            if (p)
            {
                Print("Index %x found: ste = %x, BT = %x\n",
                      Index,
                      p,
                      p + OFFSETOF(RTL_STACK_TRACE_ENTRY, BackTrace));
                break;
            }
        }
    }
}

#else

DEBUG_EXT_HEAD( dbti )
{
    DEBUG_EXT_SETUP_VARS();

    Print("Not enabled.\n");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\exts\spllib.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    spllib.cxx

Abstract:

    Extensions for spllib

Author:

    Albert Ting (AlbertT)  20-Feb-1995

Revision History:

--*/

#include "precomp.hxx"

/********************************************************************

    Helper routines

********************************************************************/

#if !DBG
#error "Only the debug version should be built."
#endif

BOOL
TDebugExt::
bDumpCritSec(
    PVOID pCritSec_,
    ULONG_PTR dwAddr
    )
{
    MCritSec* pCritSec = (MCritSec*)pCritSec_;

    if( !pCritSec->bSigCheck( )){
        return FALSE;
    }

    Print( "MCritSec*\n" );

    Print( "   CriticalSection @ %x\n", dwAddr + OFFSETOF( MCritSec, _CritSec ));
    Print( "     dwThreadOwner %x\n", pCritSec->_dwThreadOwner );
    Print( "      dwEntryCount <%d>  ", pCritSec->_dwEntryCount );

    if( pCritSec->_dwEntryCount ){
        Print( "Owned\n" );
    } else {
        Print( "Not Owned\n" );
    }
    Print( "dwTickCountEntered <%d>\n", pCritSec->_dwTickCountEntered );

    Print( "==== Statistics\n" );

    Print( "  dwTickCountBlockedTotal <%d>\n", pCritSec->_dwTickCountBlockedTotal );
    Print( "   dwTickCountInsideTotal <%d>\n", pCritSec->_dwTickCountInsideTotal );
    Print( "        dwEntryCountTotal <%d>\n", pCritSec->_dwEntryCountTotal );

    Print( "     CritSecHardLock_base " ); vDumpPDL( pCritSec->CritSecHardLock_pdlBase( ));

    ULONG_PTR dwAddrBt = dwAddr + OFFSETOF( MCritSec, _BackTrace )
                     - OFFSETOF_BASE( TBackTraceMem, VBackTrace );

    Print( "               VBackTrace @ %x      !splx.ddt -x     %x\n",
           dwAddrBt, dwAddrBt );

    return TRUE;
}

BOOL
TDebugExt::
bDumpBackTrace(
    ULONG_PTR dwAddr,
    COUNT Count,
    PDWORD pdwSkip,
    DWORD DebugTrace,
    DWORD DebugLevel,
    DWORD dwThreadId,
    ULONG_PTR dwMem
    )
{
#ifdef TRACE_ENABLED

    BYTE abyBackTraceBuffer[sizeof(TBackTraceMem)];   
    TBackTraceMem* pBackTraceMem = (TBackTraceMem*)abyBackTraceBuffer;

    move2( pBackTraceMem, dwAddr, sizeof( TBackTraceMem ));

    if( !pBackTraceMem->bSigCheck( )){
        return FALSE;
    }

    INT iLineStart = pBackTraceMem->_uNextFree;
    INT iLine;

    if( iLineStart < 0 ){
        iLineStart = TBackTraceMem::kMaxCall - 1;
    }

    for( iLine = iLineStart - 1; Count; --iLine, --Count ){

        if( CheckControlCRtn()){
            return TRUE;
        }

        //
        // Handle wrap around case.
        //
        if( iLine < 0 ){
            iLine = TBackTraceMem::kMaxCall - 1;
        }

        if( iLine == iLineStart ||
            !TDebugExt::bDumpDebugTrace( (ULONG_PTR)&pBackTraceMem->_pLines[iLine],
                                        1,
                                        pdwSkip,
                                        DebugTrace,
                                        DebugLevel,
                                        dwThreadId,
                                        dwMem )){
            //
            // Wrapped around yet didn't find enough.
            //
            Print( "Out of lines\n" );
            return TRUE;
        }
    }
    return TRUE;

#else   // #ifdef TRACE_ENABLED

    return FALSE;

#endif  // #ifdef TRACE_ENABLED
}


BOOL
TDebugExt::
bDumpDebugTrace(
    ULONG_PTR dwLineAddr,
    COUNT Count,
    PDWORD pdwSkip,
    DWORD DebugTrace,
    DWORD DebugLevel,
    DWORD dwThreadId,
    ULONG_PTR dwMem
    )
{
    //
    // TLine is a simple class, and can be treated as a "C" struct.
    //
    COUNTB cbTotalLine = sizeof( TBackTraceMem::TLine ) * Count;
    TBackTraceMem::TLine* pLineBase =
        (TBackTraceMem::TLine*) LocalAlloc( LPTR, cbTotalLine );
    BOOL bValidLines = TRUE;

    TBackTraceMem::TLine* pLine;

    if( !pLineBase ){

        Print( "Cannot alloc 0x%x bytes.\n", cbTotalLine );
        return FALSE;
    }

    move2( pLineBase, dwLineAddr, cbTotalLine );

    //
    // Dump out the lines.
    //
    for( pLine = pLineBase ; Count; Count--, pLine++ ){

        if( CheckControlCRtn()){
            goto Done;
        }

        //
        // If we are out of lines, quit.
        //
        if( !pLine->_TickCount ){
            bValidLines = FALSE;
            goto Done;
        }

        //
        // If we are processing DBGMSG, skip levels we don't want.
        //
        if( DebugTrace & DEBUG_TRACE_DBGMSG ){
            if( !( DebugLevel & ( pLine->_Info2 >> DBG_BREAK_SHIFT ))){
                continue;
            }
        }

        //
        // Skip thread Ids we don't want.
        //
        if( dwThreadId && dwThreadId != pLine->_ThreadId ){
            continue;
        }

        //
        // Skip mem we don't want.
        // This is used when we are dumping the memory functions in
        // spllib (gpbtAlloc and gpbtFree).
        //
        if( dwMem &&
            ( dwMem < pLine->_Info1 ||
              dwMem > pLine->_Info1 + pLine->_Info2 )){

            continue;
        }

        if( *pdwSkip ){
            --*pdwSkip;
            continue;
        }

        if( DebugTrace & DEBUG_TRACE_DBGMSG ){

            CHAR szMsg[kStringDefaultMax];

            szMsg[0] = 0;

            if( pLine->_Info1 ){

                move( szMsg, pLine->_Info1 );

                //
                // PageHeap forces all allocated blocks to be placed
                // at the end of a page, with the next page marked
                // as unreadable.  If we don't get a string here,
                // then read up chunk.
                //
                if( !szMsg[0] ){

                    move2( szMsg,
                           pLine->_Info1,
                           kStringChunk -
                               ( (DWORD)pLine->_Info1 & ( kStringChunk - 1 )));
                }

                Print( "* %s", szMsg );

                UINT cchLen = lstrlenA( szMsg );

                if( !cchLen || szMsg[cchLen-1] != '\n' ){

                    Print( "\n" );
                }
            } else {
                Print( "\n" );
            }
        }

        if( DebugTrace & DEBUG_TRACE_HEX ){
            Print( "%08x %08x %08x bt=%x threadid=%x tc=%x [%x]\n",
                   pLine->_Info1,
                   pLine->_Info2,
                   pLine->_Info3,
                   pLine->_hTrace,
                   pLine->_ThreadId,
                   pLine->_TickCount,
                   pLine->_Info1 + pLine->_Info2 );
        }

        if( DebugTrace & DEBUG_TRACE_BT ){
            vDumpTrace( (ULONG_PTR)pLine->_hTrace );
        }
    }

Done:

    LocalFree( pLineBase );
    return bValidLines;
}

BOOL
TDebugExt::
bDumpDbgPointers(
    PVOID pDbgPointers_,
    ULONG_PTR dwAddress
    )
{
    PDBG_POINTERS pDbgPointers = (PDBG_POINTERS)pDbgPointers_;

    Print( "DBG_POINTERS*\n" );

    Print( "hMemHeap     !heap -a           %x\n", pDbgPointers->hMemHeap );
    Print( "hDbgMemHeap  !heap -a           %x\n", pDbgPointers->hDbgMemHeap );
    Print( "pbtAlloc     !splx.ddt -x       %x\n", pDbgPointers->pbtAlloc );
    Print( "pbtFree      !splx.ddt -x       %x\n", pDbgPointers->pbtFree );
    Print( "pbtErrLog    !splx.ddt          %x\n", pDbgPointers->pbtErrLog );
    Print( "pbtTraceLog  !splx.ddt          %x\n", pDbgPointers->pbtTraceLog );

    return TRUE;
}

/********************************************************************

    Extension entrypoints.

********************************************************************/

DEBUG_EXT_ENTRY( dthdm, TThreadM, bDumpThreadM, NULL, FALSE )
DEBUG_EXT_ENTRY( dcs, MCritSec, bDumpCritSec, NULL, FALSE )

DEBUG_EXT_ENTRY( ddp, DBG_POINTERS, bDumpDbgPointers, "&gpDbgPointers", FALSE )

DEBUG_EXT_HEAD(dbt)
{
    DEBUG_EXT_SETUP_VARS();
    TDebugExt::vDumpTrace( TDebugExt::dwEval( lpArgumentString, FALSE ));
}

DEBUG_EXT_HEAD(ddt)
{
    DEBUG_EXT_SETUP_VARS();

    vDumpTraceWithFlags( lpArgumentString, 0 );
}

DEBUG_EXT_HEAD(dmem)
{
    DEBUG_EXT_SETUP_VARS();
    TDebugExt::vDumpMem( lpArgumentString );
}


/********************************************************************

    Helper funcs.

********************************************************************/

VOID
vDumpTraceWithFlags(
    LPSTR lpArgumentString,
    ULONG_PTR dwAddress
    )
{
    COUNT Count = 10;
    BOOL bRaw = FALSE;
    DWORD DebugTrace = DEBUG_TRACE_NONE;
    DWORD DebugLevel = (DWORD)-1;
    DWORD dwThreadId = 0;
    DWORD dwSkip = 0;
    ULONG_PTR dwMem = 0;

    for( ; *lpArgumentString; ++lpArgumentString ){

        while( *lpArgumentString == ' ' ){
            ++lpArgumentString;
        }

        if (*lpArgumentString != '-') {
            break;
        }

        ++lpArgumentString;

        switch( *lpArgumentString++ ){
        case 'T':
        case 't':

            dwThreadId = (DWORD)TDebugExt::dwEvalParam( lpArgumentString );
            break;

        case 'L':
        case 'l':

            DebugLevel = (DWORD)TDebugExt::dwEvalParam( lpArgumentString );
            break;

        case 'C':
        case 'c':

            Count = (COUNT)TDebugExt::dwEvalParam( lpArgumentString );
            break;

        case 'M':
        case 'm':

            dwMem = TDebugExt::dwEvalParam( lpArgumentString );
            break;

        case 'R':
        case 'r':

            bRaw = TRUE;
            break;

        case 'b':
        case 'B':

            DebugTrace |= DEBUG_TRACE_BT;
            break;

        case 'X':
        case 'x':

            DebugTrace |= DEBUG_TRACE_HEX;
            break;

        case 'd':
        case 'D':

            DebugTrace |= DEBUG_TRACE_DBGMSG;
            break;

        case 's':
        case 'S':

            dwSkip = (DWORD)TDebugExt::dwEvalParam( lpArgumentString );
            break;

        default:
            Print( "Unknown option %c.\n", lpArgumentString[-1] );
            return;
        }
    }

    if( !dwAddress ){
        dwAddress = TDebugExt::dwEval( lpArgumentString );
    }

    if( bRaw ){
        TDebugExt::bDumpDebugTrace( dwAddress,
                                    Count,
                                    &dwSkip,
                                    DebugTrace,
                                    DebugLevel,
                                    dwThreadId,
                                    dwMem );
        return;
    }

    //
    // If nothing is set, default to dbg msgs.
    //
    if( !DebugTrace ){
        DebugTrace |= DEBUG_TRACE_DBGMSG;
    }

    if( !TDebugExt::bDumpBackTrace( dwAddress,
                                    Count,
                                    &dwSkip,
                                    DebugTrace,
                                    DebugLevel,
                                    dwThreadId,
                                    dwMem )){
        Print( "Unknown Signature\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\exts\dumpmem.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    dumpmem.cxx

Abstract:

    Dumps a spllib heap list looking for backtraces.

Author:

    Albert Ting (AlbertT)  20-Feb-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

VOID
TDebugExt::
vDumpMem(
    LPCSTR pszFile
    )

/*++

Routine Description:

    Takes an input file of heap blocks and dumps the backtraces.

Arguments:

    pszFile - Space terminated input file name.

Return Value:

--*/

{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CHAR szFile[MAX_PATH];
    LPSTR pcMark;
    BOOL bMore = TRUE;

    enum {
        kLineMax = 0x100
    };

    //
    // Copy & terminate file name.
    //
    StringCchCopyA( szFile, COUNTOF( szFile ), pszFile);

    for( pcMark = szFile;
         *pcMark && ( *pcMark != ' ' );
         ++pcMark ){

        ;
    }

    //
    // If space found, null terminate.
    //
    if( *pcMark ){
        *pcMark = 0;
    }

    //
    // Create the file for reading.
    //
    hFile = CreateFileA( szFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_ALWAYS,
                         0,
                         NULL );

    if( hFile == INVALID_HANDLE_VALUE ){
        Print( "Unable to open file %s\n", szFile );
        goto Done;
    }

    //
    // Loop until EOF.
    //
    while( bMore ){

        CHAR szLine[ kLineMax ];

        if( CheckControlCRtn()){
            Print( "Aborted.\n" );
            goto Done;
        }

        INT i;

        //
        // Read a line.
        //
        for( i=0; i< COUNTOF( szLine ) - 1; ++i ){

            DWORD dwBytesRead = 0;
            BOOL bLeading = TRUE;

            ReadFile( hFile,
                      &szLine[i],
                      sizeof( szLine[i] ),
                      &dwBytesRead,
                      NULL );

            if( dwBytesRead != sizeof( szLine[i] )){
                goto Done;
            }

            if( szLine[i] == '\n' ){
                break;
            }
        }

        //
        // Null terminate.
        //
        szLine[i] = 0;

        LPSTR pszLine;

        //
        // Remove leading zeros and spaces.
        //
        for( pszLine = szLine;
             *pszLine == ' ' || *pszLine == '0';
             ++pszLine ){
            ;
        }

        //
        // Terminate at first colon if necessary.
        //
        for( pcMark = pszLine; *pcMark; ++pcMark ){

            if( *pcMark == ':' ){

                //
                // Null terminate.
                //
                *pcMark = 0;
                break;
            }
        }

        //
        // Received line, get address.
        //
        UINT_PTR Addr = TDebugExt::dwEval( pszLine );

        struct SPLLIB_HEADER {
            DWORD cbSize;
            DWORD AddrBt;
        };

        SPLLIB_HEADER SpllibHeader;
        ZeroMemory( &SpllibHeader, sizeof( SpllibHeader ));

        move( SpllibHeader, Addr+8 );

        Print( "bt= %x s= %x  %x\n\n",
               SpllibHeader.AddrBt,
               SpllibHeader.cbSize,
               Addr );

        //
        // Dump backtrace.
        //
        vDumpTrace( SpllibHeader.AddrBt );

        Print( "\n" );
    }

Done:

    if( hFile != INVALID_HANDLE_VALUE ){
        CloseHandle( hFile );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\exts\wdbgexts.h ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    wdbgexts.h

Abstract:

    This file contains the necessary prototypes and data types for a user
    to write a debugger extension DLL.  This header file is also included
    by the NT debuggers (WINDBG & KD).

    This header file must be included after "windows.h" and "dbghelp.h".

    Please see the NT DDK documentation for specific information about
    how to write your own debugger extension DLL.

Environment:

    Win32 only.

Revision History:

--*/

#ifndef _WDBGEXTS_
#define _WDBGEXTS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(WDBGAPI)
#define WDBGAPI __stdcall
#endif

#if !defined(WDBGAPIV)
#define WDBGAPIV __cdecl
#endif

#ifndef _WINDEF_
typedef CONST void *LPCVOID;
#endif

#ifndef _ULONGLONG_
typedef unsigned __int64 ULONGLONG;
typedef ULONGLONG *PULONGLONG;
#endif


typedef
VOID
(WDBGAPIV*PWINDBG_OUTPUT_ROUTINE)(
    PCSTR lpFormat,
    ...
    );

typedef
ULONG_PTR
(WDBGAPI*PWINDBG_GET_EXPRESSION)(
    PCSTR lpExpression
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_EXPRESSION32)(
    PCSTR lpExpression
    );

typedef
ULONG64
(WDBGAPI*PWINDBG_GET_EXPRESSION64)(
    PCSTR lpExpression
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL)(
    PVOID      offset,
    PCHAR     pchBuffer,
    ULONG_PTR *pDisplacement
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL32)(
    ULONG      offset,
    PCHAR     pchBuffer,
    PULONG     pDisplacement
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL64)(
    ULONG64    offset,
    PCHAR     pchBuffer,
    PULONG64   pDisplacement
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM)(
    ULONG_PTR *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM32)(
    ULONG     *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM64)(
    ULONG64   *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_CONTROL_C)(
    VOID
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE)(
    ULONG_PTR  offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE32)(
    ULONG      offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE64)(
    ULONG64    offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE)(
    ULONG_PTR  offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32)(
    ULONG      offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64)(
    ULONG64    offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_SET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_IOCTL_ROUTINE)(
    USHORT   IoctlType,
    PVOID    lpvData,
    ULONG    cbSize
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_READ_PHYSICAL_MEMORY)(
    ULONGLONG        address,
    PVOID            buffer,
    ULONG            count,
    PULONG           bytesread
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY)(
    ULONGLONG        address,
    PVOID            buffer,
    ULONG            length,
    PULONG           byteswritten
    );


typedef struct _EXTSTACKTRACE {
    ULONG       FramePointer;
    ULONG       ProgramCounter;
    ULONG       ReturnAddress;
    ULONG       Args[4];
} EXTSTACKTRACE, *PEXTSTACKTRACE;

typedef struct _EXTSTACKTRACE32 {
    ULONG       FramePointer;
    ULONG       ProgramCounter;
    ULONG       ReturnAddress;
    ULONG       Args[4];
} EXTSTACKTRACE32, *PEXTSTACKTRACE32;

typedef struct _EXTSTACKTRACE64 {
    ULONG64     FramePointer;
    ULONG64     ProgramCounter;
    ULONG64     ReturnAddress;
    ULONG64     Args[4];
} EXTSTACKTRACE64, *PEXTSTACKTRACE64;


typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE)(
    ULONG             FramePointer,
    ULONG             StackPointer,
    ULONG             ProgramCounter,
    PEXTSTACKTRACE    StackFrames,
    ULONG             Frames
    );

typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE32)(
    ULONG             FramePointer,
    ULONG             StackPointer,
    ULONG             ProgramCounter,
    PEXTSTACKTRACE32  StackFrames,
    ULONG             Frames
    );

typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE64)(
    ULONG64           FramePointer,
    ULONG64           StackPointer,
    ULONG64           ProgramCounter,
    PEXTSTACKTRACE64  StackFrames,
    ULONG             Frames
    );

typedef struct _WINDBG_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE    lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE   lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE             lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS, *PWINDBG_EXTENSION_APIS;

typedef struct _WINDBG_EXTENSION_APIS32 {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION32               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL32                   lpGetSymbolRoutine;
    PWINDBG_DISASM32                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE32  lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE32           lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS32, *PWINDBG_EXTENSION_APIS32;

typedef struct _WINDBG_EXTENSION_APIS64 {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION64               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL64                   lpGetSymbolRoutine;
    PWINDBG_DISASM64                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE64  lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64 lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE64           lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS64, *PWINDBG_EXTENSION_APIS64;


typedef struct _WINDBG_OLD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
} WINDBG_OLD_EXTENSION_APIS, *PWINDBG_OLD_EXTENSION_APIS;

typedef struct _WINDBG_OLDKD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION32               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL32                   lpGetSymbolRoutine;
    PWINDBG_DISASM32                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE32  lpReadVirtualMemRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteVirtualMemRoutine;
    PWINDBG_OLDKD_READ_PHYSICAL_MEMORY     lpReadPhysicalMemRoutine;
    PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY    lpWritePhysicalMemRoutine;
} WINDBG_OLDKD_EXTENSION_APIS, *PWINDBG_OLDKD_EXTENSION_APIS;

typedef
VOID
(WDBGAPI*PWINDBG_OLD_EXTENSION_ROUTINE)(
    ULONG                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE32)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE64)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG64                 dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_OLDKD_EXTENSION_ROUTINE)(
    ULONG                        dwCurrentPc,
    PWINDBG_OLDKD_EXTENSION_APIS lpExtensionApis,
    PCSTR                        lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT)(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT32)(
    PWINDBG_EXTENSION_APIS32 lpExtensionApis,
    USHORT                   MajorVersion,
    USHORT                   MinorVersion
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT64)(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT                   MajorVersion,
    USHORT                   MinorVersion
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_VERSION)(
    VOID
    );

#define EXT_API_VERSION_NUMBER   5
#define EXT_API_VERSION_NUMBER32 5
#define EXT_API_VERSION_NUMBER64 6

typedef struct EXT_API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} EXT_API_VERSION, *LPEXT_API_VERSION;

typedef
LPEXT_API_VERSION
(WDBGAPI*PWINDBG_EXTENSION_API_VERSION)(
    VOID
    );

#define IG_KD_CONTEXT                  1
#define IG_READ_CONTROL_SPACE          2
#define IG_WRITE_CONTROL_SPACE         3
#define IG_READ_IO_SPACE               4
#define IG_WRITE_IO_SPACE              5
#define IG_READ_PHYSICAL               6
#define IG_WRITE_PHYSICAL              7
#define IG_READ_IO_SPACE_EX            8
#define IG_WRITE_IO_SPACE_EX           9
#define IG_KSTACK_HELP                10   // obsolete
#define IG_SET_THREAD                 11
#define IG_READ_MSR                   12
#define IG_WRITE_MSR                  13
#define IG_GET_DEBUGGER_DATA          14
#define IG_GET_KERNEL_VERSION         15
#define IG_RELOAD_SYMBOLS             16
#define IG_GET_SET_SYMPATH            17
#define IG_GET_EXCEPTION_RECORD       18
#define IG_IS_PTR64                   19
#define IG_GET_BUS_DATA               20
#define IG_SET_BUS_DATA               21
#define IG_DUMP_SYMBOL_INFO           22
#define IG_LOWMEM_CHECK               23
#define IG_SEARCH_MEMORY              24
#define IG_GET_CURRENT_THREAD         25
#define IG_GET_CURRENT_PROCESS        26
#define IG_GET_TYPE_SIZE              27
#define IG_GET_CURRENT_PROCESS_HANDLE 28
#define IG_GET_INPUT_LINE             29
#define IG_GET_EXPRESSION_EX          30
#define IG_TRANSLATE_VIRTUAL_TO_PHYSICAL 31

#define IG_GET_TEB_ADDRESS           128
#define IG_GET_PEB_ADDRESS           129

typedef struct _PROCESSORINFO {
    USHORT      Processor;                // current processor
    USHORT      NumberProcessors;         // total number of processors
} PROCESSORINFO, *PPROCESSORINFO;

typedef struct _READCONTROLSPACE {
    USHORT      Processor;
    ULONG       Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE, *PREADCONTROLSPACE;

typedef struct _READCONTROLSPACE32 {
    USHORT      Processor;
    ULONG       Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE32, *PREADCONTROLSPACE32;

typedef struct _READCONTROLSPACE64 {
    USHORT      Processor;
    ULONG64     Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE64, *PREADCONTROLSPACE64;

typedef struct _IOSPACE {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE, *PIOSPACE;

typedef struct _IOSPACE32 {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE32, *PIOSPACE32;

typedef struct _IOSPACE64 {
    ULONG64     Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE64, *PIOSPACE64;

typedef struct _IOSPACE_EX {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX, *PIOSPACE_EX;

typedef struct _IOSPACE_EX32 {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX32, *PIOSPACE_EX32;

typedef struct _IOSPACE_EX64 {
    ULONG64     Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX64, *PIOSPACE_EX64;

typedef struct _GETSETBUSDATA {
    ULONG       BusDataType;
    ULONG       BusNumber;
    ULONG       SlotNumber;
    PVOID       Buffer;
    ULONG       Offset;
    ULONG       Length;
} BUSDATA, *PBUSDATA;

typedef struct _SEARCHMEMORY {
    ULONG64 SearchAddress;
    ULONG64 SearchLength;
    ULONG64 FoundAddress;
    ULONG   PatternLength;
    PVOID   Pattern;
} SEARCHMEMORY, *PSEARCHMEMORY;

typedef struct _PHYSICAL {
    ULONGLONG              Address;
    ULONG                  BufLen;
    UCHAR                  Buf[1];
} PHYSICAL, *PPHYSICAL;

typedef struct _READ_WRITE_MSR {
    ULONG       Msr;
    LONGLONG    Value;
} READ_WRITE_MSR, *PREAD_WRITE_MSR;

typedef struct _GET_SET_SYMPATH {
    PCSTR       Args;       // args to !reload command
    PSTR        Result;     // returns new path
    int         Length;     // Length of result buffer
} GET_SET_SYMPATH, *PGET_SET_SYMPATH;

typedef struct _GET_TEB_ADDRESS {
    ULONGLONG   Address;
} GET_TEB_ADDRESS, *PGET_TEB_ADDRESS;

typedef struct _GET_PEB_ADDRESS {
    ULONG64     CurrentThread;
    ULONGLONG   Address;
} GET_PEB_ADDRESS, *PGET_PEB_ADDRESS;

typedef struct _GET_CURRENT_THREAD_ADDRESS {
    ULONG       Processor;
    ULONG64     Address;
} GET_CURRENT_THREAD_ADDRESS, *PGET_CURRENT_THREAD_ADDRESS;

typedef struct _GET_CURRENT_PROCESS_ADDRESS {
    ULONG       Processor;
    ULONG64     CurrentThread;
    ULONG64     Address;
} GET_CURRENT_PROCESS_ADDRESS, *PGET_CURRENT_PROCESS_ADDRESS;

typedef struct _GET_INPUT_LINE {
    PCSTR       Prompt;
    PSTR        Buffer;
    ULONG       BufferSize;
    ULONG       InputSize;
} GET_INPUT_LINE, *PGET_INPUT_LINE;

typedef struct _GET_EXPRESSION_EX {
    PCSTR       Expression;
    PCSTR       Remainder;
    ULONG64     Value;
} GET_EXPRESSION_EX, *PGET_EXPRESSION_EX;

typedef struct _TRANSLATE_VIRTUAL_TO_PHYSICAL {
    ULONG64     Virtual;
    ULONG64     Physical;
} TRANSLATE_VIRTUAL_TO_PHYSICAL, *PTRANSLATE_VIRTUAL_TO_PHYSICAL;

//
// If DBGKD_VERS_FLAG_DATA is set in Flags, info should be retrieved from
// the KDDEBUGGER_DATA block rather than from the DBGKD_GET_VERSION
// packet.  The data will remain in the version packet for a while to
// reduce compatibility problems.
//

#define DBGKD_VERS_FLAG_MP      0x0001      // kernel is MP built
#define DBGKD_VERS_FLAG_DATA    0x0002      // DebuggerDataList is valid
#define DBGKD_VERS_FLAG_PTR64   0x0004      // native pointers are 64 bits
#define DBGKD_VERS_FLAG_NOMM    0x0008      // No MM - don't decode PTEs
#define DBGKD_VERS_FLAG_HSS     0x0010      // hardware stepping support
#define DBGKD_VERS_FLAG_USER_DEBUG 0x0020   // User debugging support

#define KDBG_TAG    'GBDK'


// **********************************************************************
// DO NOT CHANGE THESE 32 BIT STRUCTURES!
// ONLY MAKE CHAGES TO THE 64 BIT VERSION BELOW!!
// **********************************************************************

//
// The following structure has changed in more than pointer size.
//
// This is the version packet for pre-NT5 Beta 2 systems.
// For now, it is also still used on x86
//
typedef struct _DBGKD_GET_VERSION32 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    ULONG   KernBase;
    ULONG   PsLoadedModuleList;

    USHORT  MachineType;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // Address of the kernel callout routine.
    //

    ULONG   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG   KeUserCallbackDispatcher;   // address in ntdll

    //
    // DbgBreakPointWithStatus is a function which takes a ULONG argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG   BreakpointWithStatus;       // address of breakpoint

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //

    ULONG   DebuggerDataList;

} DBGKD_GET_VERSION32, *PDBGKD_GET_VERSION32;


//
// This is the debugger data packet for pre NT5 Beta 2 systems.
// For now, it is still used on x86
//

typedef struct _DBGKD_DEBUG_DATA_HEADER32 {

    LIST_ENTRY32 List;
    ULONG           OwnerTag;
    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER32, *PDBGKD_DEBUG_DATA_HEADER32;

typedef struct _KDDEBUGGER_DATA32 {

    DBGKD_DEBUG_DATA_HEADER32 Header;
    ULONG   KernBase;
    ULONG   BreakpointWithStatus;       // address of breakpoint
    ULONG   SavedContext;
    USHORT  ThCallbackStack;            // offset in thread data
    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer
    USHORT  PaeEnabled:1;
    ULONG   KiCallUserMode;             // kernel routine
    ULONG   KeUserCallbackDispatcher;   // address in ntdll

    ULONG   PsLoadedModuleList;
    ULONG   PsActiveProcessHead;
    ULONG   PspCidTable;

    ULONG   ExpSystemResourcesList;
    ULONG   ExpPagedPoolDescriptor;
    ULONG   ExpNumberOfPagedPools;

    ULONG   KeTimeIncrement;
    ULONG   KeBugCheckCallbackListHead;
    ULONG   KiBugcheckData;

    ULONG   IopErrorLogListHead;

    ULONG   ObpRootDirectoryObject;
    ULONG   ObpTypeObjectType;

    ULONG   MmSystemCacheStart;
    ULONG   MmSystemCacheEnd;
    ULONG   MmSystemCacheWs;

    ULONG   MmPfnDatabase;
    ULONG   MmSystemPtesStart;
    ULONG   MmSystemPtesEnd;
    ULONG   MmSubsectionBase;
    ULONG   MmNumberOfPagingFiles;

    ULONG   MmLowestPhysicalPage;
    ULONG   MmHighestPhysicalPage;
    ULONG   MmNumberOfPhysicalPages;

    ULONG   MmMaximumNonPagedPoolInBytes;
    ULONG   MmNonPagedSystemStart;
    ULONG   MmNonPagedPoolStart;
    ULONG   MmNonPagedPoolEnd;

    ULONG   MmPagedPoolStart;
    ULONG   MmPagedPoolEnd;
    ULONG   MmPagedPoolInformation;
    ULONG   MmPageSize;

    ULONG   MmSizeOfPagedPoolInBytes;

    ULONG   MmTotalCommitLimit;
    ULONG   MmTotalCommittedPages;
    ULONG   MmSharedCommit;
    ULONG   MmDriverCommit;
    ULONG   MmProcessCommit;
    ULONG   MmPagedPoolCommit;
    ULONG   MmExtendedCommit;

    ULONG   MmZeroedPageListHead;
    ULONG   MmFreePageListHead;
    ULONG   MmStandbyPageListHead;
    ULONG   MmModifiedPageListHead;
    ULONG   MmModifiedNoWritePageListHead;
    ULONG   MmAvailablePages;
    ULONG   MmResidentAvailablePages;

    ULONG   PoolTrackTable;
    ULONG   NonPagedPoolDescriptor;

    ULONG   MmHighestUserAddress;
    ULONG   MmSystemRangeStart;
    ULONG   MmUserProbeAddress;

    ULONG   KdPrintCircularBuffer;
    ULONG   KdPrintCircularBufferEnd;
    ULONG   KdPrintWritePointer;
    ULONG   KdPrintRolloverCount;

    ULONG   MmLoadedUserImageList;

} KDDEBUGGER_DATA32, *PKDDEBUGGER_DATA32;

// **********************************************************************
//
// DO NOT CHANGE KDDEBUGGER_DATA32!!
// ONLY MAKE CHANGES TO KDDEBUGGER_DATA64!!!
//
// **********************************************************************


typedef struct _DBGKD_GET_VERSION64 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    USHORT  MachineType;

    USHORT  Unused[3];

    ULONG64 KernBase;
    ULONG64 PsLoadedModuleList;

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //
    // There will always be an entry for the debugger.
    //

    ULONG64 DebuggerDataList;

} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64;


//
// This structure is used by the debugger for all targets
// It is the same size as DBGKD_DATA_HEADER on all systems
//
typedef struct _DBGKD_DEBUG_DATA_HEADER64 {

    //
    // Link to other blocks
    //

    LIST_ENTRY64 List;

    //
    // This is a unique tag to identify the owner of the block.
    // If your component only uses one pool tag, use it for this, too.
    //

    ULONG           OwnerTag;

    //
    // This must be initialized to the size of the data block,
    // including this structure.
    //

    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;


//
// This structure is the same size on all systems.  The only field
// which must be translated by the debugger is Header.List.
//

//
// DO NOT ADD OR REMOVE FIELDS FROM THE MIDDLE OF THIS STRUCTURE!!!
//
// If you remove a field, replace it with an "unused" placeholder.
// Do not reuse fields until there has been enough time for old debuggers
// and extensions to age out.
//
typedef struct _KDDEBUGGER_DATA64 {

    DBGKD_DEBUG_DATA_HEADER64 Header;

    //
    // Base address of kernel image
    //

    ULONG64   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG64   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic in KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG64   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // pad to a quad boundary
    //
    USHORT  PaeEnabled:1;

    //
    // Address of the kernel callout routine.
    //

    ULONG64   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG64   KeUserCallbackDispatcher;   // address in ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG64   PsLoadedModuleList;
    ULONG64   PsActiveProcessHead;
    ULONG64   PspCidTable;

    ULONG64   ExpSystemResourcesList;
    ULONG64   ExpPagedPoolDescriptor;
    ULONG64   ExpNumberOfPagedPools;

    ULONG64   KeTimeIncrement;
    ULONG64   KeBugCheckCallbackListHead;
    ULONG64   KiBugcheckData;

    ULONG64   IopErrorLogListHead;

    ULONG64   ObpRootDirectoryObject;
    ULONG64   ObpTypeObjectType;

    ULONG64   MmSystemCacheStart;
    ULONG64   MmSystemCacheEnd;
    ULONG64   MmSystemCacheWs;

    ULONG64   MmPfnDatabase;
    ULONG64   MmSystemPtesStart;
    ULONG64   MmSystemPtesEnd;
    ULONG64   MmSubsectionBase;
    ULONG64   MmNumberOfPagingFiles;

    ULONG64   MmLowestPhysicalPage;
    ULONG64   MmHighestPhysicalPage;
    ULONG64   MmNumberOfPhysicalPages;

    ULONG64   MmMaximumNonPagedPoolInBytes;
    ULONG64   MmNonPagedSystemStart;
    ULONG64   MmNonPagedPoolStart;
    ULONG64   MmNonPagedPoolEnd;

    ULONG64   MmPagedPoolStart;
    ULONG64   MmPagedPoolEnd;
    ULONG64   MmPagedPoolInformation;
    ULONG64   MmPageSize;

    ULONG64   MmSizeOfPagedPoolInBytes;

    ULONG64   MmTotalCommitLimit;
    ULONG64   MmTotalCommittedPages;
    ULONG64   MmSharedCommit;
    ULONG64   MmDriverCommit;
    ULONG64   MmProcessCommit;
    ULONG64   MmPagedPoolCommit;
    ULONG64   MmExtendedCommit;

    ULONG64   MmZeroedPageListHead;
    ULONG64   MmFreePageListHead;
    ULONG64   MmStandbyPageListHead;
    ULONG64   MmModifiedPageListHead;
    ULONG64   MmModifiedNoWritePageListHead;
    ULONG64   MmAvailablePages;
    ULONG64   MmResidentAvailablePages;

    ULONG64   PoolTrackTable;
    ULONG64   NonPagedPoolDescriptor;

    ULONG64   MmHighestUserAddress;
    ULONG64   MmSystemRangeStart;
    ULONG64   MmUserProbeAddress;

    ULONG64   KdPrintCircularBuffer;
    ULONG64   KdPrintCircularBufferEnd;
    ULONG64   KdPrintWritePointer;
    ULONG64   KdPrintRolloverCount;

    ULONG64   MmLoadedUserImageList;

    // NT 5.1 Addition

    ULONG64   NtBuildLab;
    ULONG64   KiNormalSystemCall;

    // NT 5.0 QFE addition

    ULONG64   KiProcessorBlock;
    ULONG64   MmUnloadedDrivers;
    ULONG64   MmLastUnloadedDriver;
    ULONG64   MmTriageActionTaken;
    ULONG64   MmSpecialPoolTag;
    ULONG64   KernelVerifier;
    ULONG64   MmVerifierData;
    ULONG64   MmAllocatedNonPagedPool;
    ULONG64   MmPeakCommitment;
    ULONG64   MmTotalCommitLimitMaximum;
    ULONG64   CmNtCSDVersion;

    // NT 5.1 Addition

    ULONG64   MmPhysicalMemoryBlock;

} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;



/************************************

   Type Dump Ioctl

*************************************/


//
// Fields are not indented if this is set
//
#define DBG_DUMP_NO_INDENT                0x00000001
//
// Offsets are not printed if this is set
//
#define DBG_DUMP_NO_OFFSET                0x00000002
//
// Verbose output
//
#define DBG_DUMP_VERBOSE                  0x00000004
//
// Callback is done for each of fields
//
#define DBG_DUMP_CALL_FOR_EACH            0x00000008
//
// A list of type is dumped, listLink should have info about next element pointer
//
#define DBG_DUMP_LIST                     0x00000020
//
// Nothing is printed if this is set (only callbacks and data copies done)
//
#define DBG_DUMP_NO_PRINT                 0x00000040
//
// Ioctl returns the size as usual, but will not do field prints/callbacks if this is set
//
#define DBG_DUMP_GET_SIZE_ONLY            0x00000080
//
// Specifies how much deep into structs we can go
//
#define DBG_DUMP_RECUR_LEVEL(l)           ((l & 0xf) << 8)
//
// No newlines are printed after each field
//
#define DBG_DUMP_COMPACT_OUT              0x00002000
//
// An array of type is dumped, number of elements can be specified in listLink->size
//
#define DBG_DUMP_ARRAY                    0x00008000
//
// The specified addr value is actually the address of field listLink->fName
//
#define DBG_DUMP_ADDRESS_OF_FIELD         0x00010000

//
// The specified addr value is actually the adress at the end of type
//
#define DBG_DUMP_ADDRESS_AT_END           0x00020000

//
// This could be used to copy only the primitive types like ULONG, PVOID etc.
//    - will not work with structures/unions
//
#define DBG_DUMP_COPY_TYPE_DATA           0x00040000
//
// Flag to allow read directly from physical memory
//
#define DBG_DUMP_READ_PHYSICAL            0x00080000
//
// This causes a function type to be dumped in format function(arg1, arg2, ...)
//
#define DBG_DUMP_FUNCTION_FORMAT          0x00100000

//
// Obsolete defs
//
#define DBG_RETURN_TYPE                   0
#define DBG_RETURN_SUBTYPES               0
#define DBG_RETURN_TYPE_VALUES            0

//
// Dump and callback optons for fields - Options used in FIELD_INFO.fOptions
//

//
// Callback is done before printing the field if this is set
//
#define DBG_DUMP_FIELD_CALL_BEFORE_PRINT  0x00000001
//
// No callback is done
//
#define DBG_DUMP_FIELD_NO_CALLBACK_REQ    0x00000002
//
// Subfields of the fields are processesed
//
#define DBG_DUMP_FIELD_RECUR_ON_THIS      0x00000004
//
// fName must match completely for the field to be dumped instead just a prefix
//  match by default
//
#define DBG_DUMP_FIELD_FULL_NAME          0x00000008
//
// This causes array elements of an array field to be printed
//
#define DBG_DUMP_FIELD_ARRAY              0x00000010
//
// The data of the field is copied into fieldCallBack
//
#define DBG_DUMP_FIELD_COPY_FIELD_DATA    0x00000020
//
// In callback or when Ioctl returns, the FIELD_INFO.address has the address of field.
//  If no address is supplied for the type, it contains total offset of the field.
//
#define DBG_DUMP_FIELD_RETURN_ADDRESS     0x00001000
//
// Return the offset and size in bits instead of bytes is case of Bitfield
//
#define DBG_DUMP_FIELD_SIZE_IN_BITS       0x00002000
//
// Nothing is printed  for field if this is set (only callbacks and data copies done)
//
#define DBG_DUMP_FIELD_NO_PRINT           0x00004000
//
// If the field is a pointer, it is dumped as a string, ANSI, WCHAR, MULTI or GUID
// depending on following options
//
#define DBG_DUMP_FIELD_DEFAULT_STRING     0x00010000
#define DBG_DUMP_FIELD_WCHAR_STRING       0x00020000
#define DBG_DUMP_FIELD_MULTI_STRING       0x00040000
#define DBG_DUMP_FIELD_GUID_STRING        0x00080000


//
// Error status returned on TYPE DUMP Ioctl failure
//
#define MEMORY_READ_ERROR            0x01
#define SYMBOL_TYPE_INDEX_NOT_FOUND  0x02
#define SYMBOL_TYPE_INFO_NOT_FOUND   0x03
#define FIELDS_DID_NOT_MATCH         0x04
#define NULL_SYM_DUMP_PARAM          0x05
#define NULL_FIELD_NAME              0x06
#define INCORRECT_VERSION_INFO       0x07
#define EXIT_ON_CONTROLC             0x08
#define CANNOT_ALLOCATE_MEMORY       0x09
#define INSUFFICIENT_SPACE_TO_COPY   0x0a


//////////////////////////////////////////////////////////////////////////*/

typedef
ULONG
(WDBGAPI*PSYM_DUMP_FIELD_CALLBACK)(
    struct _FIELD_INFO *pField,
    PVOID UserContext
    );

typedef struct _FIELD_INFO {
   PUCHAR  fName;          // Name of the field
   PUCHAR  printName;      // Name to be printed at dump
   ULONG   size;           // Size of the field
   ULONG   fOptions;       // Dump Options for the field
   ULONG64 address;        // address of the field
   PVOID   fieldCallBack;  // Return info or callBack routine for the field
} FIELD_INFO, *PFIELD_INFO;

typedef struct _SYM_DUMP_PARAM {
   ULONG               size;          // size of this struct
   PUCHAR              sName;         // type name
   ULONG               Options;       // Dump options
   ULONG64             addr;          // Address to take data for type
   PFIELD_INFO         listLink;      // fName here would be used to do list dump
   PVOID               Context;       // Usercontext passed to CallbackRoutine
   PSYM_DUMP_FIELD_CALLBACK CallbackRoutine;
                                      // Routine called back
   ULONG               nFields;       // # elements in Fields
   PFIELD_INFO         Fields;        // Used to return information about field
} SYM_DUMP_PARAM, *PSYM_DUMP_PARAM;

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif


#ifndef NOEXTAPI

#if   defined(KDEXT_64BIT)
#define WINDBG_EXTENSION_APIS WINDBG_EXTENSION_APIS64
#define PWINDBG_EXTENSION_APIS PWINDBG_EXTENSION_APIS64
#define DECLARE_API(s) DECLARE_API64(s)
#elif defined(KDEXT_32BIT)
#define WINDBG_EXTENSION_APIS WINDBG_EXTENSION_APIS32
#define PWINDBG_EXTENSION_APIS PWINDBG_EXTENSION_APIS32
#define DECLARE_API(s) DECLARE_API32(s)
#else
#define DECLARE_API(s)                             \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG                  dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )
#endif

#define DECLARE_API32(s)                           \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG                  dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )

#define DECLARE_API64(s)                           \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG64                dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )


extern WINDBG_EXTENSION_APIS   ExtensionApis;


#define dprintf          (ExtensionApis.lpOutputRoutine)
#define GetExpression    (ExtensionApis.lpGetExpressionRoutine)
#define CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
#define GetContext       (ExtensionApis.lpGetThreadContextRoutine)
#define SetContext       (ExtensionApis.lpSetThreadContextRoutine)
#define Ioctl            (ExtensionApis.lpIoctlRoutine)
#define Disasm           (ExtensionApis.lpDisasmRoutine)
#define GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
#define ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
#define WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
#define StackTrace       (ExtensionApis.lpStackTraceRoutine)


#define GetKdContext(ppi) \
    Ioctl( IG_KD_CONTEXT, (PVOID)ppi, sizeof(*ppi) )


//
// BOOL
// GetDebuggerData(
//     ULONG Tag,
//     PVOID Buf,
//     ULONG Size
//     )
//

#define GetDebuggerData(TAG, BUF, SIZE)                             \
      ( (((PDBGKD_DEBUG_DATA_HEADER64)(BUF))->OwnerTag = (TAG)),      \
        (((PDBGKD_DEBUG_DATA_HEADER64)(BUF))->Size = (SIZE)),         \
        Ioctl( IG_GET_DEBUGGER_DATA, (PVOID)(BUF), (SIZE) ) )

// Check if LocalAlloc is prototyped
//#ifdef _WINBASE_

__inline VOID
ReadPhysical(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizer
    )
{
    PPHYSICAL phy;
    *sizer = 0;
    phy = (PPHYSICAL)LocalAlloc(LPTR,  sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        Ioctl( IG_READ_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
        *sizer = phy->BufLen;
        CopyMemory( buf, phy->Buf, *sizer );
        LocalFree( phy );
    }
}

__inline VOID
WritePhysical(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizew
    )
{
    PPHYSICAL phy;
    *sizew = 0;
    phy = (PPHYSICAL)LocalAlloc(LPTR, sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        CopyMemory( phy->Buf, buf, size );
        Ioctl( IG_WRITE_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
        *sizew = phy->BufLen;
        LocalFree( phy );
    }
}

__inline VOID
ReadMsr(
    ULONG       MsrReg,
    ULONGLONG   *MsrValue
    )
{
    READ_WRITE_MSR msr;

    msr.Msr = MsrReg;
    Ioctl( IG_READ_MSR, (PVOID)&msr, sizeof(msr) );

    *MsrValue = msr.Value;
}

__inline VOID
WriteMsr(
    ULONG       MsrReg,
    ULONGLONG   MsrValue
    )
{
    READ_WRITE_MSR msr;

    msr.Msr = MsrReg;
    msr.Value = MsrValue;
    Ioctl( IG_WRITE_MSR, (PVOID)&msr, sizeof(msr) );
}

__inline VOID
SetThreadForOperation(
    ULONG_PTR * Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)Thread, sizeof(PULONG));
}

__inline VOID
SetThreadForOperation32(
    ULONG Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)LongToPtr(Thread), sizeof(PULONG));
}

__inline VOID
SetThreadForOperation64(
    PULONG64 Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)Thread, sizeof(PULONG));
}


__inline VOID
ReadControlSpace(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE prc;
    prc = (PREADCONTROLSPACE)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

__inline VOID
ReadControlSpace32(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE32 prc;
    prc = (PREADCONTROLSPACE32)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

#define ReadTypedControlSpace32( _Proc, _Addr, _Buf )  \
     ReadControlSpace64( (USHORT)(_Proc), (ULONG)(_Addr), (PVOID)&(_Buf), (ULONG)sizeof(_Buf) )

__inline VOID
ReadControlSpace64(
    USHORT  processor,
    ULONG64 address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE64 prc;
    prc = (PREADCONTROLSPACE64)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

#define ReadTypedControlSpace64( _Proc, _Addr, _Buf )  \
     ReadControlSpace64( (USHORT)(_Proc), (ULONG64)(_Addr), (PVOID)&(_Buf), (ULONG)sizeof(_Buf) )

// #endif //  _WINBASE_

__inline VOID
ReadIoSpace(
    ULONG   address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
ReadIoSpace32(
    ULONG   address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE32 is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
ReadIoSpace64(
    ULONG64 address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE64 is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
WriteIoSpace(
    ULONG   address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpace32(
    ULONG   address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpace64(
    ULONG64 address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx(
    ULONG   address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx32(
    ULONG   address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx64(
    ULONG64 address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx(
    ULONG   address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx32(
    ULONG   address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx64(
    ULONG64 address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReloadSymbols(
    IN PSTR Arg OPTIONAL
    )
/*++

Routine Description:

    Calls the debugger to reload symbols.

Arguments:

    Args - Supplies the tail of a !reload command string.

        !reload [flags] [module[=address]]
        flags:   /n  do not load from usermode list
                 /u  unload symbols, no reload
                 /v  verbose

        A value of NULL is equivalent to an empty string

Return Value:

    None

--*/
{
    Ioctl(IG_RELOAD_SYMBOLS, (PVOID)Arg, Arg?(strlen(Arg)+1):0);
}

__inline VOID
GetSetSympath(
    IN PSTR Arg,
    OUT PSTR Result OPTIONAL,
    IN int Length
    )
/*++

Routine Description:

    Calls the debugger to set or retrieve symbol search path.

Arguments:

    Arg - Supplies new search path.  If Arg is NULL or string is empty,
            the search path is not changed and the current setting is
            returned in Result.  When the symbol search path is changed,
            a call to ReloadSymbols is made implicitly.

    Result - OPTIONAL Returns the symbol search path setting.

    Length - Supplies the size of the buffer supplied by Result.

Return Value:

    None

--*/
{
    GET_SET_SYMPATH gss;
    gss.Args = Arg;
    gss.Result = Result;
    gss.Length = Length;
    Ioctl(IG_GET_SET_SYMPATH, (PVOID)&gss, sizeof(gss));
}

#if   defined(KDEXT_64BIT)

__inline
ULONG
IsPtr64(
    void
    )
{
    static ULONG flag = -1;
    ULONG dw;
    if (flag == -1) {
        if (Ioctl(IG_IS_PTR64, &dw, sizeof(dw))) {
            flag = ((dw != 0) ? 1 : 0);
        } else {
            flag = 0;
        }
    }
    return flag;
}

__inline
ULONG
ReadListEntry(
    ULONG64 Address,
    PLIST_ENTRY64 List
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (ReadMemory(Address, (PVOID)List, sizeof(*List), &cb) && cb == sizeof(*List));
    } else {
        LIST_ENTRY32 List32;
        ULONG Status;
        Status = ReadMemory(Address,
                            (PVOID)&List32,
                            sizeof(List32),
                            &cb);
        if (Status && cb == sizeof(List32)) {
            List->Flink = (ULONG64)(LONG64)(LONG)List32.Flink;
            List->Blink = (ULONG64)(LONG64)(LONG)List32.Blink;
            return 1;
        }
        return 0;
    }
}

__inline
ULONG
ReadPointer(
    ULONG64 Address,
    PULONG64 Pointer
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (ReadMemory(Address, (PVOID)Pointer, sizeof(*Pointer), &cb) && cb == sizeof(*Pointer));
    } else {
        ULONG Pointer32;
        ULONG Status;
        Status = ReadMemory(Address,
                            (PVOID)&Pointer32,
                            sizeof(Pointer32),
                            &cb);
        if (Status && cb == sizeof(Pointer32)) {
            *Pointer = (ULONG64)(LONG64)(LONG)Pointer32;
            return 1;
        }
        return 0;
    }
}

__inline
ULONG
WritePointer(
    ULONG64 Address,
    ULONG64 Pointer
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (WriteMemory(Address, &Pointer, sizeof(Pointer), &cb) && cb == sizeof(Pointer));
    } else {
        ULONG Pointer32 = (ULONG)Pointer;
        ULONG Status;
        Status = WriteMemory(Address,
                             &Pointer32,
                             sizeof(Pointer32),
                             &cb);
        return (Status && cb == sizeof(Pointer32)) ? 1 : 0;
    }
}

/**
   This does Ioctl call for type info and returns size of the type on success.

 **/
__inline
ULONG
GetTypeSize (
   IN LPCSTR    Type
   )
{
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT | DBG_DUMP_GET_SIZE_ONLY, 0,
      NULL, NULL, NULL, 0, NULL
   };

   return Ioctl( IG_GET_TYPE_SIZE, &Sym, Sym.size );
}

/**
    GetFieldData

   Copies the value of the specified field into pOutValue assuming TypeAddress
   points to start of the type in debugee.

   If the Field is NULL and the size of Type is <= 8 Whole type value is read into
   pOutValue. This is to allow to read in primitive types suchas ULONG, PVOID etc.

   If address is zero this considers Type a global variable.

   It raises an exception if OutSize is less than size to be copied.

   Returns 0 on success, errorvalue (defined with SYM_DUMP_PARAM) otherwise.

 **/
__inline
ULONG
GetFieldData (
    IN  ULONG64 TypeAddress,
    IN  LPCSTR  Type,
    IN  LPCSTR  Field,
    IN  ULONG   OutSize,
    OUT PVOID   pOutValue
   )
{
   FIELD_INFO flds = {(PUCHAR)Field, NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS, 0, pOutValue};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT, TypeAddress,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG RetVal;

   if (!Field) {
       Sym.nFields =0; Sym.Options |= DBG_DUMP_COPY_TYPE_DATA;
       Sym.Context = pOutValue;
   }

   ZeroMemory(pOutValue, OutSize);
   RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

   if (OutSize < ((Field == NULL) ? 8 : flds.size)) {
       // Fail
       dprintf("Not enough space to read %s-%s\n", Type, Field);
       RaiseException(EXCEPTION_ACCESS_VIOLATION, 0, 0, NULL);
       return 0;
   }
   return RetVal;
}

//
// Typecast the buffer where value is to be read
//
#define GetFieldValue(Addr, Type, Field, OutValue)         \
     GetFieldData(Addr, Type, Field, sizeof(OutValue), (PVOID) &(OutValue))

//
// Used to read in value of a short (<= 8 bytes) fields
//
__inline
ULONG64
GetShortField (
    IN  ULONG64 TypeAddress,
    IN  LPCSTR  Name,
    IN  USHORT  StoreAddress
   )
{
    static ULONG64 SavedAddress;
    static PUCHAR  SavedName;
    static ULONG   ReadPhysical;
    FIELD_INFO flds = {(PUCHAR) Name, NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM), SavedName, DBG_DUMP_NO_PRINT | ((StoreAddress & 2) ? DBG_DUMP_READ_PHYSICAL : 0),
       SavedAddress, NULL, NULL, NULL, 1, &flds
    };
      

    if (StoreAddress) {
        Sym.sName = (PUCHAR) Name;
        Sym.nFields = 0;
        SavedName = (PUCHAR) Name;
        Sym.addr = SavedAddress = TypeAddress;
        ReadPhysical = (StoreAddress & 2);
        return SavedAddress ? Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size ) : MEMORY_READ_ERROR; // zero on success
    } else {
        Sym.Options |= ReadPhysical ? DBG_DUMP_READ_PHYSICAL : 0;
    }

    if (!Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size )) {
        return flds.address;
    }
    return 0;
}

//
// Stores the address and type name for future reads
//
#define InitTypeRead(Addr, Type)  GetShortField(Addr, #Type, 1)

//
// Stores the address and type name for future reads
//
#define InitTypeReadPhysical(Addr, Type)  GetShortField(Addr, #Type, 3)
//
// Returns the field's value as ULONG64 if size of field is <= sizeof (ULONG64)
//
#define ReadField(Field)          GetShortField(0, #Field, 0)

//
// Read in a pointer value
//
__inline
ULONG
ReadPtr(
    ULONG64 Addr,
    PULONG64 pPointer
    )
{
    return GetFieldData(Addr, "PVOID", NULL, sizeof(ULONG64), (PVOID) pPointer);
}

/*
 * ListType
 *
 *  Routine ListType gives a callback on each element in the list of Type.
 *
 *   Type  :  Name of the type to be listed
 *
 *   NextPointer : Name of field which gives address of next element in list
 *
 *   Context, CallbackRoutine :
 *            Context and the callback routine. The address field in PFIELD_INFO
 *            parameter of callback contains the address of next Type element in list.
 *
 *   Address, ListByFieldAddress :
 *      if ListByFieldAddress is 0, Adress is the address of first element of Type List.
 *
 *   Lists by LIST_ENTRY are also handled implicitly (by Ioctl). If the NextPointer
 *   is a pointer to LIST_ENTRY type, the type address is properly calculated by
 *   subtracting the offsets.
 *
 *      If ListByFieldAddress is 1, the Address is considered to be the address of field
 *   "NextPointer" of the first Type element and first element address is derived
 *   from it.
 *
 */

__inline
ULONG
ListType (
    IN LPCSTR  Type,
    IN ULONG64 Address,
    IN USHORT  ListByFieldAddress,
    IN LPCSTR  NextPointer,
    IN PVOID   Context,
    IN PSYM_DUMP_FIELD_CALLBACK CallbackRoutine
    )
{
    FIELD_INFO flds = {(PUCHAR)NextPointer, NULL, 0, 0, 0, NULL};
    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM), (PUCHAR) Type, DBG_DUMP_NO_PRINT | DBG_DUMP_LIST, Address,
       &flds, Context, CallbackRoutine, 0, NULL
    };

    if (ListByFieldAddress==1) {
        //
        // Address is the address of "NextPointer"
        //
        Sym.Options |= DBG_DUMP_ADDRESS_OF_FIELD;
    }

    return Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
}


/**

   Routine to get offset of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.

 **/

__inline
ULONG
GetFieldOffset (
   IN LPCSTR     Type,
   IN LPCSTR     Field,
   OUT PULONG   pOffset
   )
{
   FIELD_INFO flds = {
       (PUCHAR)Field,
       (PUCHAR)"",
       0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0,
       NULL};

   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM),
      (PUCHAR)Type,
      DBG_DUMP_NO_PRINT,
      0,
      NULL,
      NULL,
      NULL,
      1,
      &flds
   };

   ULONG Err;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   return Err;
}


#endif // defined(KDEXT_64BIT)

__inline VOID
 GetCurrentProcessHandle(
    PHANDLE hp
    )
{
    Ioctl(IG_GET_CURRENT_PROCESS_HANDLE, hp, sizeof(HANDLE));
}

__inline VOID
 GetTebAddress(
    PULONGLONG Address
    )
{
    GET_TEB_ADDRESS gpt;
    gpt.Address = 0;
    Ioctl(IG_GET_TEB_ADDRESS, (PVOID)&gpt, sizeof(gpt));
    *Address = gpt.Address;
}

__inline VOID
 GetPebAddress(
    ULONG64 CurrentThread,
    PULONGLONG Address
    )
{
    GET_PEB_ADDRESS gpt;
    gpt.CurrentThread = CurrentThread;
    gpt.Address = 0;
    Ioctl(IG_GET_PEB_ADDRESS, (PVOID)&gpt, sizeof(gpt));
    *Address = gpt.Address;
}

__inline VOID
 GetCurrentThreadAddr(
    DWORD    Processor,
    PULONG64  Address
    )
{
    GET_CURRENT_THREAD_ADDRESS ct;
    ct.Processor = Processor;
    Ioctl(IG_GET_CURRENT_THREAD, (PVOID)&ct, sizeof(ct));
    *Address = ct.Address;
}

__inline VOID
 GetCurrentProcessAddr(
    DWORD    Processor,
    ULONG64  CurrentThread,
    PULONG64 Address
    )
{
    GET_CURRENT_PROCESS_ADDRESS cp;
    cp.Processor = Processor;
    cp.CurrentThread = CurrentThread;
    Ioctl(IG_GET_CURRENT_PROCESS, (PVOID)&cp, sizeof(cp));
    *Address = cp.Address;
}

__inline VOID
SearchMemory(
    ULONG64  SearchAddress,
    ULONG64  SearchLength,
    ULONG    PatternLength,
    PVOID    Pattern,
    PULONG64 FoundAddress
    )
{
    SEARCHMEMORY sm;
    sm.SearchAddress = SearchAddress;
    sm.SearchLength  = SearchLength;
    sm.FoundAddress  = 0;
    sm.PatternLength = PatternLength;
    sm.Pattern       = Pattern;
    Ioctl(IG_SEARCH_MEMORY, (PVOID)&sm, sizeof(sm));
    *FoundAddress = sm.FoundAddress;
}

__inline ULONG
GetInputLine(
    PCSTR Prompt,
    PSTR Buffer,
    ULONG BufferSize
    )
{
    GET_INPUT_LINE InLine;
    InLine.Prompt = Prompt;
    InLine.Buffer = Buffer;
    InLine.BufferSize = BufferSize;
    if (Ioctl(IG_GET_INPUT_LINE, (PVOID)&InLine, sizeof(InLine)))
    {
        return InLine.InputSize;
    }
    else
    {
        return 0;
    }
}

__inline BOOL
GetExpressionEx(
    PCSTR Expression,
    ULONG64* Value,
    PCSTR* Remainder
    )
{
    GET_EXPRESSION_EX Expr;
    Expr.Expression = Expression;
    if (Ioctl(IG_GET_EXPRESSION_EX, (PVOID)&Expr, sizeof(Expr)))
    {
        *Value = Expr.Value;

        if (Remainder != NULL)
        {
            *Remainder = Expr.Remainder;
        }

        return TRUE;
    }

    return FALSE;
}

__inline BOOL
TranslateVirtualToPhysical(
    ULONG64 Virtual,
    ULONG64* Physical
    )
{
    TRANSLATE_VIRTUAL_TO_PHYSICAL VToP;
    VToP.Virtual = Virtual;
    if (Ioctl(IG_TRANSLATE_VIRTUAL_TO_PHYSICAL, (PVOID)&VToP, sizeof(VToP)))
    {
        *Physical = VToP.Physical;
        return TRUE;
    }

    return FALSE;
}


#endif


#ifdef __cplusplus
}
#endif

#endif // _WDBGEXTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\exts\localspl.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    localspl.cxx

Abstract:

    SUR localspl structures.

Author:

    Albert Ting (AlbertT)  19-Feb-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

extern "C" {
#include "spltypes.h"
}

/********************************************************************

    Localspl structures; mostly defined in localspl\spltypes.h

********************************************************************/

BOOL
TDebugExt::
bDumpIniSpooler(
    PVOID pIniSpooler_,
    ULONG_PTR dwAddr
    )
{
    static DEBUG_FLAGS adfSpl[] = {
        { "UpdateWinIniDevices",     SPL_UPDATE_WININI_DEVICES },
        { "PrinterChanges",          SPL_PRINTER_CHANGES       },
        { "LogEvents",               SPL_LOG_EVENTS            },
        { "FormsChange",             SPL_FORMS_CHANGE          },
        { "BroadcastChange",         SPL_BROADCAST_CHANGE      },
        { "SecurityCheck",           SPL_SECURITY_CHECK        },
        { "OpenCreatePorts",         SPL_OPEN_CREATE_PORTS     },
        { "FailOpenPrintersPendDel", SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION },
        { "RemoteHandleCheck",       SPL_REMOTE_HANDLE_CHECK   },
        { "PrinterDriverEvent",      SPL_PRINTER_DRIVER_EVENT  },
        { "AlwaysCreateDriverShare", SPL_ALWAYS_CREATE_DRIVER_SHARE },
        { "NoUpdatePrinterIni",      SPL_NO_UPDATE_PRINTERINI  },
        { "NoUpdateJobShd",          SPL_NO_UPDATE_JOBSHD      },
        { "ClusterReg",              SPL_CLUSTER_REG           },
        { "Offline",                 SPL_OFFLINE               },
        { "PendingDeletion",         SPL_PENDING_DELETION      },
        { "ServerThread",            SPL_SERVER_THREAD         },
        { "Print",                   SPL_PRINT                 },
        { "TypeLocal",               SPL_TYPE_LOCAL            },
        { "TypeCluster",             SPL_TYPE_CLUSTER          },
        { NULL,                      0                         }
    };

    PINISPOOLER pIniSpooler = (PINISPOOLER)pIniSpooler_;

    if( !( pIniSpooler->signature == ISP_SIGNATURE )){
        return FALSE;
    }

    Print( "IniSpooler*\n" );

    Print( "        pIniNextSpooler %x\n", pIniSpooler->pIniNextSpooler );
    Print( "                   cRef <%d>\n", pIniSpooler->cRef );
    Print( "           pMachineName " ); vDumpStr( pIniSpooler->pMachineName );
    Print( "                   pDir " ); vDumpStr( pIniSpooler->pDir );

    Print( "            pIniPrinter %x\n", pIniSpooler->pIniPrinter );
    Print( "        pIniEnvironment %x\n", pIniSpooler->pIniEnvironment );
    Print( "            pIniMonitor %x\n", pIniSpooler->pIniMonitor );
    Print( "               pIniPort %x\n", pIniSpooler->pIniPort );
    Print( "                pShared %x\n", pIniSpooler->pShared );
    Print( "           pIniNetPrint %x\n", pIniSpooler->pIniNetPrint );
    Print( "                 pSpool %x\n", pIniSpooler->pSpool );

    Print( "       pDefaultSpoolDir " ); vDumpStr( pIniSpooler->pDefaultSpoolDir );

    Print( "    pszRegistryMonitors " ); vDumpStr(  pIniSpooler->pszRegistryMonitors );
    Print( "pszRegistryEnvironments " ); vDumpStr(  pIniSpooler->pszRegistryEnvironments );
    Print( "    pszRegistryEventLog " ); vDumpStr(  pIniSpooler->pszRegistryEventLog );
    Print( "   pszRegistryProviders " ); vDumpStr(  pIniSpooler->pszRegistryProviders );
    Print( "     pszEventLogMsgFile " ); vDumpStr(  pIniSpooler->pszEventLogMsgFile );

    Print( "      pDriversShareInfo %x\n", pIniSpooler->pDriversShareInfo );
    Print( "        pszDriversShare " ); vDumpStr(  pIniSpooler->pszDriversShare );
    Print( "       pszRegistryForms " ); vDumpStr(  pIniSpooler->pszRegistryForms );

    Print( "           SpoolerFlags " );
    vDumpFlags( pIniSpooler->SpoolerFlags, adfSpl );


    Print( "     pfnReadRegistryExtra %x\n", pIniSpooler->pfnReadRegistryExtra );
    Print( "    pfnWriteRegistryExtra %x\n", pIniSpooler->pfnWriteRegistryExtra );
    Print( "      pfnFreePrinterExtra %x\n", pIniSpooler->pfnFreePrinterExtra );

    Print( "     cEnumNetworkPrinters <%d>\n", pIniSpooler->cEnumerateNetworkPrinters );
    Print( "          cAddNetPrinters <%d>\n", pIniSpooler->cAddNetPrinters );
    Print( "            cFormOrderMax <%d>\n", pIniSpooler->cFormOrderMax );
    Print( "    pNoRemotePrintDrivers " ); vDumpStr( pIniSpooler->pNoRemotePrintDrivers );
    Print( "  cchNoRemotePrintDrivers <%d>\n", pIniSpooler->cchNoRemotePrintDrivers );
    Print( "                  hckRoot %x\n", pIniSpooler->hckRoot );
    Print( "              hckPrinters %x\n", pIniSpooler->hckPrinters );
    Print( "        cFullPrintingJobs <%d>\n", pIniSpooler->cFullPrintingJobs );
    Print( "     hEventNoPrintingJobs %x\n", pIniSpooler->hEventNoPrintingJobs );
    Print( "                hJobIdMap %x\n", pIniSpooler->hJobIdMap );
    Print( "           dwEventLogging <%d>\n", pIniSpooler->dwEventLogging );
    Print( "         bEnableNetPopups <%d>\n", pIniSpooler->bEnableNetPopups );
    Print( "   dwJobCompletionTimeout <%d>\n", pIniSpooler->dwJobCompletionTimeout );
    Print( "            dwBeepEnabled <%d>\n", pIniSpooler->dwBeepEnabled );
    Print( "bEnableNetPopupToComputer <%d>\n", pIniSpooler->bEnableNetPopupToComputer );
    Print( "       bEnableRetryPopups <%d>\n", pIniSpooler->bEnableRetryPopups );
    Print( "           pszClusterSID " ); vDumpStr(  pIniSpooler->pszClusterSID );
    Print( "            hClusterToken <%d>\n", pIniSpooler->hClusterToken );
    Print( "dwRestartJobOnPoolTimeout <%d>\n", pIniSpooler->dwRestartJobOnPoolTimeout );
    Print( " bRestartJobOnPoolEnabled <%d>\n", pIniSpooler->bRestartJobOnPoolEnabled );
    Print( "                bImmortal <%d>\n", pIniSpooler->bImmortal );
    Print( "       pszFullMachineName " ); vDumpStr(  pIniSpooler->pszFullMachineName );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniPrintProc(
    PVOID pIniPrintProc_,
    ULONG_PTR dwAddr
    )
{
    PINIPRINTPROC pIniPrintProc = (PINIPRINTPROC)pIniPrintProc_;

    static DEBUG_FLAGS adfSpl[] = {
        { "UpdateWinIniDevices",  SPL_UPDATE_WININI_DEVICES },
        { NULL,                   0                         }
    };

    if( !( pIniPrintProc->signature == IPP_SIGNATURE )){
        return FALSE;
    }

    Print( "IniPrintProc*\n" );

    Print( "            pNext %x\n", pIniPrintProc->pNext );
    Print( "             cRef <%d>\n", pIniPrintProc->cRef );

    Print( "            pName " ); vDumpStr( pIniPrintProc->pName );
    Print( "         pDLLName " ); vDumpStr( pIniPrintProc->pDLLName );

    Print( "      cbDatatypes %x\n", pIniPrintProc->cbDatatypes );
    Print( "       cDatatypes %x\n", pIniPrintProc->cDatatypes );
    Print( "       pDatatypes %x\n", pIniPrintProc->pDatatypes );
    Print( "        hLibrary %x\n", pIniPrintProc->hLibrary );
    Print( "         Install %x\n", pIniPrintProc->Install );
    Print( "    EnumDatatypes %x\n", pIniPrintProc->EnumDatatypes );
    Print( "             Open %x\n", pIniPrintProc->Open );
    Print( "            Print %x\n", pIniPrintProc->Print );
    Print( "            Close %x\n", pIniPrintProc->Close );
    Print( "          Control %x\n", pIniPrintProc->Control );
    Print( "  CriticalSection @ %x\n", dwAddr
                                       + OFFSETOF( INIPRINTPROC, CriticalSection ));

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniDriver(
    PVOID pIniDriver_,
    ULONG_PTR dwAddr
    )
{
    PINIDRIVER pIniDriver = (PINIDRIVER)pIniDriver_;

    static DEBUG_FLAGS adfSpl[] = {
        { "UpdateWinIniDevices",  SPL_UPDATE_WININI_DEVICES },
        { NULL,                   0                         }
    };

    if( !( pIniDriver->signature == ID_SIGNATURE )){
        return FALSE;
    }

    Print( "IniDriver*\n" );

    Print( "             pNext %x\n", pIniDriver->pNext );
    Print( "              cRef <%d>\n", pIniDriver->cRef );

    Print( "             pName " ); vDumpStr( pIniDriver->pName );
    Print( "       pDriverFile " ); vDumpStr( pIniDriver->pDriverFile );
    Print( "       pConfigFile " ); vDumpStr( pIniDriver->pConfigFile );
    Print( "         pDataFile " ); vDumpStr( pIniDriver->pDataFile );
    Print( "         pHelpFile " ); vDumpStr( pIniDriver->pHelpFile );

    Print( " cchDependentFiles %x\n", pIniDriver->cchDependentFiles );
    Print( "   pDependentFiles %x\n", pIniDriver->pDependentFiles );

    Print( "      pMonitorName " ); vDumpStr( pIniDriver->pMonitorName );
    Print( "  pDefaultDataType " ); vDumpStr( pIniDriver->pDefaultDataType );

    Print( "          cVersion %x\n", pIniDriver->cVersion );
    Print( "   pIniLangMonitor %x\n", pIniDriver->pIniLangMonitor );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniVersion(
    PVOID pIniVersion_,
    ULONG_PTR dwAddr
    )
{
    PINIVERSION pIniVersion = (PINIVERSION)pIniVersion_;

    if( !( pIniVersion->signature == IV_SIGNATURE )){
        return FALSE;
    }

    Print( "IniVersion*\n" );

    Print( "         pNext %x\n", pIniVersion->pNext );
    Print( "         pName " ); vDumpStr( pIniVersion->pName );
    Print( "   szDirectory " ); vDumpStr( pIniVersion->szDirectory );
    Print( " cMajorVersion %x\n", pIniVersion->cMajorVersion );
    Print( " cMinorVersion %x\n", pIniVersion->cMinorVersion );
    Print( "    pIniDriver %x\n", pIniVersion->pIniDriver );

    return TRUE;
}


BOOL
TDebugExt::
bDumpIniEnvironment(
    PVOID pIniEnvironment_,
    ULONG_PTR dwAddr
    )
{
    PINIENVIRONMENT pIniEnvironment = (PINIENVIRONMENT)pIniEnvironment_;

    if( !( pIniEnvironment->signature == IE_SIGNATURE )){
        return FALSE;
    }

    Print( "IniEnvironment*\n" );

    Print( "         pNext %x\n", pIniEnvironment->pNext );
    Print( "          cRef <%d>\n", pIniEnvironment->cRef );

    Print( "         pName " ); vDumpStr(  pIniEnvironment->pName );
    Print( "    pDirectory " ); vDumpStr(  pIniEnvironment->pDirectory );

    Print( "   pIniVersion %x\n", pIniEnvironment->pIniVersion );
    Print( " pIniPrintProc %x\n", pIniEnvironment->pIniPrintProc );
    Print( "   pIniSpooler %x\n", pIniEnvironment->pIniSpooler );

    return TRUE;
}



BOOL
TDebugExt::
bDumpIniMonitor(
    PVOID pIniMonitor_,
    ULONG_PTR dwAddr
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)pIniMonitor_;

    if( !( pIniMonitor->signature == IMO_SIGNATURE )){
        return FALSE;
    }

    Print( "IniMonitor*\n" );

    Print( "         pNext %x\n", pIniMonitor->pNext );
    Print( "          cRef <%d>\n", pIniMonitor->cRef );

    Print( "         pName " ); vDumpStr(  pIniMonitor->pName );
    Print( "   pMonitorDll " ); vDumpStr(  pIniMonitor->pMonitorDll );

    Print( "       hModule %x\n", pIniMonitor->hModule );
    Print( " ==   Monitor2 ==\n" );
    Print( "        EnumPorts %x\n", pIniMonitor->Monitor2.pfnEnumPorts );
    Print( "         OpenPort %x\n", pIniMonitor->Monitor2.pfnOpenPort );
    Print( "       OpenPortEx %x\n", pIniMonitor->Monitor2.pfnOpenPortEx );
    Print( "     StartDocPort %x\n", pIniMonitor->Monitor2.pfnStartDocPort );
    Print( "        WritePort %x\n", pIniMonitor->Monitor2.pfnWritePort );
    Print( "         ReadPort %x\n", pIniMonitor->Monitor2.pfnReadPort );
    Print( "       EndDocPort %x\n", pIniMonitor->Monitor2.pfnEndDocPort );
    Print( "        ClosePort %x\n", pIniMonitor->Monitor2.pfnClosePort );
    Print( "          AddPort %x\n", pIniMonitor->Monitor2.pfnAddPort );
    Print( "       AddPortsEx %x\n", pIniMonitor->Monitor2.pfnAddPortEx );
    Print( "    ConfigurePort %x\n", pIniMonitor->Monitor2.pfnConfigurePort );
    Print( "       DeletePort %x\n", pIniMonitor->Monitor2.pfnDeletePort );
    Print( "    GetPDFromPort %x\n", pIniMonitor->Monitor2.pfnGetPrinterDataFromPort );
    Print( "  SetPortTimeOuts %x\n", pIniMonitor->Monitor2.pfnSetPortTimeOuts );
    Print( "      XcvOpenPort %x\n", pIniMonitor->Monitor2.pfnXcvOpenPort );
    Print( "      XcvDataPort %x\n", pIniMonitor->Monitor2.pfnXcvDataPort );
    Print( "     XcvClosePort %x\n", pIniMonitor->Monitor2.pfnXcvClosePort );
    Print( "         Shutdown %x\n", pIniMonitor->Monitor2.pfnShutdown );

    Print( "     Monitor @ %x\n", dwAddr + OFFSETOF( INIMONITOR, Monitor ));
    Print( "   pIniSpooler %x\n", pIniMonitor->pIniSpooler );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniPort(
    PVOID pIniPort_,
    ULONG_PTR dwAddr
    )
{
    PINIPORT pIniPort = (PINIPORT)pIniPort_;

    if( !( pIniPort->signature == IPO_SIGNATURE )){
        return FALSE;
    }

    Print( "IniPort*\n" );

    Print( "            pNext %x\n", pIniPort->pNext );
    Print( "             cRef <%d>\n", pIniPort->cRef );

    Print( "            pName " ); vDumpStr(  pIniPort->pName );

    Print( "            hProc %x\n", pIniPort->hProc );
    Print( "           Status %x\n", pIniPort->Status );
    Print( "    PrinterStatus %x\n", pIniPort->PrinterStatus );
    Print( "        pszStatus " ); vDumpStr(  pIniPort->pszStatus );

    Print( "        Semaphore %x\n", pIniPort->Semaphore );
    Print( "          pIniJob %x\n", pIniPort->pIniJob );
    Print( "        cPrinters <%d>\n", pIniPort->cPrinters );
    Print( "     ppIniPrinter %x\n", pIniPort->ppIniPrinter );
    Print( "      pIniMonitor %x\n", pIniPort->pIniMonitor );
    Print( "  pIniLangMonitor %x\n", pIniPort->pIniLangMonitor );

    Print( "           hEvent %x\n", pIniPort->hEvent );
    Print( "            hPort %x\n", pIniPort->hPort );
    Print( "            Ready %x\n", pIniPort->Ready );
    Print( "      hPortThread %x\n", pIniPort->hPortThread );
    Print( "      pIniSpooler %x\n", pIniPort->pIniSpooler );
    Print( "InCriticalSection %x\n", pIniPort->InCriticalSection );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniJob(
    PVOID pIniJob_,
    ULONG_PTR dwAddr
    )
{
    PINIJOB pIniJob = (PINIJOB)pIniJob_;

    static DEBUG_FLAGS adfJobStatus[] = {
        { "Printing",           JOB_PRINTING            },
        { "Paused",             JOB_PAUSED              },
        { "Error",              JOB_ERROR               },
        { "Offline",            JOB_OFFLINE             },
        { "PaperOut",           JOB_PAPEROUT            },
        { "PendingDeletion",    JOB_PENDING_DELETION    },
        { "Spooling",           JOB_SPOOLING            },
        { "Despooling",         JOB_DESPOOLING          },
        { "Direct",             JOB_DIRECT              },
        { "Complete",           JOB_COMPLETE            },
        { "Printed",            JOB_PRINTED             },
        { "Restart",            JOB_RESTART             },
        { "Remote",             JOB_REMOTE              },
        { "NotificationSent",   JOB_NOTIFICATION_SENT   },
        { "PrintToFile",        JOB_PRINT_TO_FILE       },
        { "TypeAddJob",         JOB_TYPE_ADDJOB         },
        { "BlockedDevQ",        JOB_BLOCKED_DEVQ        },
        { "SchecduleJob",       JOB_SCHEDULE_JOB        },
        { "Timeout",            JOB_TIMEOUT             },
        { "Abandon",            JOB_ABANDON             },
        { "Deleted",            JOB_DELETED             },
        { "TrueEOJ",            JOB_TRUE_EOJ            },
        { "Compound/Hidden",    JOB_COMPOUND            },
        { NULL,                0                        }
    };

    if( !( pIniJob->signature == IJ_SIGNATURE )){
        return FALSE;
    }

    Print( "IniJob*\n" );

    Print( "     pIniNextJob %x\n", pIniJob->pIniNextJob );
    Print( "     pIniPrevJob %x\n", pIniJob->pIniPrevJob );
    Print( "            cRef <%d>\n", pIniJob->cRef );
    Print( "          Status " ); vDumpFlags( pIniJob->Status, adfJobStatus );
    Print( "           JobId <%d>\n", pIniJob->JobId );
    Print( "        Priority <%d>\n", pIniJob->Priority );

    Print( "         pNotify " ); vDumpStr( pIniJob->pNotify );
    Print( "           pUser " ); vDumpStr( pIniJob->pUser );
    Print( "    pMachineName " ); vDumpStr( pIniJob->pMachineName );
    Print( "       pDocument " ); vDumpStr( pIniJob->pDocument );
    Print( "     pOutputFile " ); vDumpStr( pIniJob->pOutputFile );

    Print( "     pIniPrinter %x\n", pIniJob->pIniPrinter );
    Print( "      pIniDriver %x\n", pIniJob->pIniDriver );
    Print( "        pDevMode %x\n", pIniJob->pDevMode );
    Print( "   pIniPrintProc %x\n", pIniJob->pIniPrintProc );
    Print( "       pDatatype " ); vDumpStr( pIniJob->pDatatype );
    Print( "     pParameters " ); vDumpStr( pIniJob->pParameters );

    Print( "       Submitted @ %x\n", dwAddr + OFFSETOF( INIJOB, Submitted ));
    Print( "            Time %x\n", pIniJob->Time );
    Print( "       StartTime %x\n", pIniJob->StartTime );
    Print( "       UntilTime %x\n", pIniJob->UntilTime );

    Print( "            Size %x\n", pIniJob->Size );
    Print( "      hWriteFile  %x\n", pIniJob->hWriteFile );
    Print( "         pStatus " ); vDumpStr( pIniJob->pStatus );

    Print( "         pBuffer %x\n", pIniJob->pBuffer );
    Print( "        cbBuffer %x\n", pIniJob->cbBuffer );
    Print( "     WaitForRead %x\n", pIniJob->WaitForRead );
    Print( "    WaitForWrite %x\n", pIniJob->WaitForWrite );

    Print( "StartDocComplete %x\n", pIniJob->StartDocComplete );
    Print( "   StartDocError %x\n", pIniJob->StartDocError );
    Print( "        pIniPort %x\n", pIniJob->pIniPort );
    Print( "          hToken %x\n", pIniJob->hToken );
    Print( "             pSD %x\n", pIniJob->pSecurityDescriptor );
    Print( "   cPagesPrinted %x\n", pIniJob->cPagesPrinted );
    Print( "          cPages %x\n", pIniJob->cPages );

    Print( " GenerateOnClose %x\n", pIniJob->GenerateOnClose );
    Print( "       cbPrinted %x\n", pIniJob->cbPrinted );

    Print( "       NextJobId %x\n", pIniJob->NextJobId );
    Print( "  pCurrentIniJob %x\n", pIniJob->pCurrentIniJob );

    return TRUE;
}


BOOL
TDebugExt::
bDumpSpool(
    PVOID pSpool_,
    ULONG_PTR dwAddr
    )
{
    PSPOOL pSpool = (PSPOOL)pSpool_;

    if( !( pSpool->signature == SJ_SIGNATURE )){
        return FALSE;
    }

    Print( "Spool*\n" );

    Print( "            pNext %x\n", pSpool->pNext );
    Print( "             cRef <%d>\n", pSpool->cRef );

    Print( "            pName " ); vDumpStr(  pSpool->pName );
    Print( "         pDatatpe " ); vDumpStr(  pSpool->pDatatype );


    Print( "    pIniPrintProc %x\n", pSpool->pIniPrintProc );
    Print( "         pDevMode %x\n", pSpool->pDevMode );
    Print( "      pIniPrinter %x\n", pSpool->pIniPrinter );
    Print( "         pIniPort %x\n", pSpool->pIniPort );
    Print( "          pIniJob %x\n", pSpool->pIniJob );
    Print( "     TypeofHandle %x\n", pSpool->TypeofHandle );
    Print( "      pIniNetPort %x\n", pSpool->pIniNetPort );
    Print( "            hPort %x\n", pSpool->hPort );
    Print( "           Status %x\n", pSpool->Status );
    Print( "    GrantedAccess %x\n", pSpool->GrantedAccess );
    Print( "      ChangeFlags %x\n", pSpool->ChangeFlags );
    Print( "        WaitFlags %x\n", pSpool->WaitFlags );
    Print( "     pChangeFlags %x\n", pSpool->pChangeFlags );
    Print( "      ChangeEvent %x\n", pSpool->ChangeEvent );
    Print( "    OpenPortError %x\n", pSpool->OpenPortError );
    Print( "          hNotify %x\n", pSpool->hNotify );
    Print( "          eStatus %x\n", pSpool->eStatus );
    Print( "      pIniSpooler %x\n", pSpool->pIniSpooler );

    Print( "  GenerateOnClose %x\n", pSpool->GenerateOnClose );
    Print( "            hFile %x\n", pSpool->hFile );
    Print( "adwNotifyVectors @ %x\n", dwAddr
                                      + OFFSETOF( SPOOL, adwNotifyVectors ));

    Print( "        pUserName " ); vDumpStr(  pSpool->SplClientInfo1.pUserName );
    Print( "     pMachineName " ); vDumpStr(  pSpool->SplClientInfo1.pMachineName );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniPrinter(
    PVOID pIniPrinter_,
    ULONG_PTR dwAddr
    )
{
    PINIPRINTER pIniPrinter = (PINIPRINTER)pIniPrinter_;

    static DEBUG_FLAGS adfStatus[] = {
        { "Paused",           PRINTER_PAUSED           },
        { "Error",            PRINTER_ERROR            },
        { "Offline",          PRINTER_OFFLINE          },
        { "PaperOut",         PRINTER_PAPEROUT         },
        { "PendingDeletion",  PRINTER_PENDING_DELETION },
        { "ZombieObject",     PRINTER_ZOMBIE_OBJECT    },
        { "PendingCreation",  PRINTER_PENDING_CREATION },
        { "Ok",               PRINTER_OK               },
        { "FromReg",          PRINTER_FROM_REG         },
        { "WasShared",        PRINTER_WAS_SHARED       },
        { NULL,               0                        }
    };

    static DEBUG_FLAGS adfAttributes[] = {
        { "Queued",           PRINTER_ATTRIBUTE_QUEUED       },
        { "Direct",           PRINTER_ATTRIBUTE_DIRECT       },
        { "Default",          PRINTER_ATTRIBUTE_DEFAULT      },
        { "Shared",           PRINTER_ATTRIBUTE_SHARED       },
        { "Network",          PRINTER_ATTRIBUTE_NETWORK      },
        { "Hidden",           PRINTER_ATTRIBUTE_HIDDEN       },
        { "Local",            PRINTER_ATTRIBUTE_LOCAL        },
        { "DevQ",             PRINTER_ATTRIBUTE_ENABLE_DEVQ  },
        { "KeepPrintedJobs",  PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS   },
        { "DoCompletedFirst", PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST },
        { "WorkOffline",      PRINTER_ATTRIBUTE_WORK_OFFLINE   },
        { "EnableBidi",       PRINTER_ATTRIBUTE_ENABLE_BIDI    },
        { NULL,               0                                }
    };

    if( !( pIniPrinter->signature == IP_SIGNATURE )){
        return FALSE;
    }

    Print( "IniPrinter*\n" );

    Print( "               pNext %x\n", pIniPrinter->pNext );
    Print( "                cRef %x\n", pIniPrinter->cRef );
    Print( "               pName " ); vDumpStr( pIniPrinter->pName );
    Print( "          pShareName " ); vDumpStr( pIniPrinter->pShareName );

    Print( "       pIniPrintProc %x\n", pIniPrinter->pIniPrintProc );

    Print( "           pDatatype " ); vDumpStr( pIniPrinter->pDatatype );
    Print( "         pParameters " ); vDumpStr( pIniPrinter->pParameters );
    Print( "            pComment " ); vDumpStr( pIniPrinter->pComment );

    Print( "          pIniDriver %x\n", pIniPrinter->pIniDriver );
    Print( "           cbDevMode %x\n", pIniPrinter->cbDevMode );
    Print( "            pDevMode %x\n", pIniPrinter->pDevMode );
    Print( "            Priority <%d>\n", pIniPrinter->Priority );
    Print( "     DefaultPriority <%d>\n", pIniPrinter->DefaultPriority );

    Print( "           StartTime %x\n", pIniPrinter->StartTime );
    Print( "           UntilTime %x\n", pIniPrinter->UntilTime );
    Print( "            pSepFile " ); vDumpStr( pIniPrinter->pSepFile );

    Print( "              Status " );
    vDumpFlags( pIniPrinter->Status, adfStatus );

    Print( "           pLocation " ); vDumpStr( pIniPrinter->pLocation );
    Print( "          Attributes " );
    vDumpFlags( pIniPrinter->Attributes, adfAttributes );

    Print( "               cJobs <%d>\n", pIniPrinter->cJobs );
    Print( "          AveragePPM %x\n", pIniPrinter->AveragePPM );
    Print( "     GenerateOnClose %x\n", pIniPrinter->GenerateOnClose );
    Print( "         pIniNetPort %x\n", pIniPrinter->pIniNetPort );
    Print( " ====   pIniFirstJob %x\n", pIniPrinter->pIniFirstJob );
    Print( "         pIniLastJob %x\n", pIniPrinter->pIniLastJob );
    Print( " pSecurityDescriptor %x\n", pIniPrinter->pSecurityDescriptor );
    Print( "              pSpool %x\n", pIniPrinter->pSpool );

    Print( "           pSpoolDir " ); vDumpStr( pIniPrinter->pSpoolDir );
    Print( "          cTotalJobs %x\n", pIniPrinter->cTotalJobs );
    Print( "         cTotalBytes %x\n", pIniPrinter->cTotalBytes );
    Print( "            stUpTime " ); vDumpTime( pIniPrinter->stUpTime );
    Print( "             MaxcRef %x\n", pIniPrinter->MaxcRef );
    Print( "  cTotalPagesPrinted %x\n", pIniPrinter->cTotalPagesPrinted );
    Print( "           cSpooling %x\n", pIniPrinter->cSpooling );
    Print( "        cMaxSpooling %x\n", pIniPrinter->cMaxSpooling );
    Print( "    cErrorOutOfPaper %x\n", pIniPrinter->cErrorOutOfPaper );
    Print( "      cErrorNotReady %x\n", pIniPrinter->cErrorNotReady );
    Print( "           cJobError %x\n", pIniPrinter->cJobError );
    Print( "         pIniSpooler %x\n", pIniPrinter->pIniSpooler );
    Print( "          cZombieRef %x\n", pIniPrinter->cZombieRef );
    Print( "         dwLastError %x\n", pIniPrinter->dwLastError );
    Print( "          pExtraData %x\n", pIniPrinter->pExtraData );
    Print( "           cChangeID %x\n", pIniPrinter->cChangeID );
    Print( "          dnsTimeout %x\n", pIniPrinter->dnsTimeout );
    Print( "           txTimeout %x\n", pIniPrinter->txTimeout );
    Print( "       pszObjectGUID " ); vDumpStr( pIniPrinter->pszObjectGUID );
    Print( "         DsKeyUpdate %x\n", pIniPrinter->DsKeyUpdate );
    Print( "DsKeyUpdateForeground %x\n", pIniPrinter->DsKeyUpdateForeground );
    return TRUE;
}


/********************************************************************

    Devmodes

********************************************************************/

DEBUG_FLAGS gadfDevModeFields[] = {
    { "Orientation",  DM_ORIENTATION },
    { "PaperSize",  DM_PAPERSIZE },
    { "PaperLength",  DM_PAPERLENGTH },
    { "PaperWidth",  DM_PAPERWIDTH },
    { "Scale",  DM_SCALE },
    { "Copies",  DM_COPIES },
    { "DefaultSource",  DM_DEFAULTSOURCE },
    { "PrintQuality",  DM_PRINTQUALITY },
    { "Color",  DM_COLOR },
    { "Duplex",  DM_DUPLEX },
    { "YResolution",  DM_YRESOLUTION },
    { "TTOption",  DM_TTOPTION },
    { "Collate",  DM_COLLATE },
    { "FormName",  DM_FORMNAME },
    { "LogPixels",  DM_LOGPIXELS },
    { "BitsPerPel",  DM_BITSPERPEL },
    { "PelsWidth",  DM_PELSWIDTH },
    { "PelsHeight",  DM_PELSHEIGHT },
    { "DisplayFlags",  DM_DISPLAYFLAGS },
    { "DisplayFrequency",  DM_DISPLAYFREQUENCY },
    { "ICMMethod",  DM_ICMMETHOD },
    { "ICMIntent",  DM_ICMINTENT },
    { "MediaType",  DM_MEDIATYPE },
    { "DitherType",  DM_DITHERTYPE },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeDefaultSource[] = {
    { "Upper/OnlyOne", DMBIN_UPPER },
    { "Lower", DMBIN_LOWER },
    { "Middle", DMBIN_MIDDLE },
    { "Manual", DMBIN_MANUAL },
    { "Envelope", DMBIN_ENVELOPE },
    { "EnvManual", DMBIN_ENVMANUAL },
    { "Auto", DMBIN_AUTO },
    { "Tractor", DMBIN_TRACTOR },
    { "SmallFmt", DMBIN_SMALLFMT },
    { "LargeFmt", DMBIN_LARGEFMT },
    { "LargeCapacity", DMBIN_LARGECAPACITY },
    { "Cassette", DMBIN_CASSETTE },
    { "FormSource", DMBIN_FORMSOURCE },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModePapers[] = {
    { "Letter", DMPAPER_LETTER },
    { "Legal", DMPAPER_LEGAL },
    { "A4", DMPAPER_A4 },
    { "CSheet", DMPAPER_CSHEET },
    { "DSheet", DMPAPER_DSHEET },
    { "ESheet", DMPAPER_ESHEET },
    { "LetterSmall", DMPAPER_LETTERSMALL },
    { "Tabloid", DMPAPER_TABLOID },
    { "Ledger", DMPAPER_LEDGER },
    { "Statement", DMPAPER_STATEMENT },
    { "Executive", DMPAPER_EXECUTIVE },
    { "A3", DMPAPER_A3 },
    { "A4Small", DMPAPER_A4SMALL },
    { "A5", DMPAPER_A5 },
    { "B4", DMPAPER_B4 },
    { "B5", DMPAPER_B5 },
    { "Folio", DMPAPER_FOLIO },
    { "Quarto", DMPAPER_QUARTO },
    { "10x14", DMPAPER_10X14 },
    { "11x17", DMPAPER_11X17 },
    { "Note", DMPAPER_NOTE },
    { "Env_9", DMPAPER_ENV_9 },
    { "Env_10", DMPAPER_ENV_10 },
    { "Env_11", DMPAPER_ENV_11 },
    { "Env_12", DMPAPER_ENV_12 },
    { "Env_14", DMPAPER_ENV_14 },
    { "Env_DL", DMPAPER_ENV_DL },
    { "Env_C5", DMPAPER_ENV_C6 },
    { "Env_C65", DMPAPER_ENV_C65 },
    { "Env_B4", DMPAPER_ENV_B4 },
    { "Env_B5", DMPAPER_ENV_B5 },
    { "Env_B6", DMPAPER_ENV_B6 },
    { "Env_Italy", DMPAPER_ENV_ITALY },
    { "Env_Monarch", DMPAPER_ENV_MONARCH },
    { "Env_Personal", DMPAPER_ENV_PERSONAL },
    { "Fanfold_US", DMPAPER_FANFOLD_US },
    { "Fanfold_Std_German", DMPAPER_FANFOLD_STD_GERMAN },
    { "Fanfold_Lgl_German", DMPAPER_FANFOLD_LGL_GERMAN },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModePrintQuality[] = {
    { "High", (ULONG_PTR)DMRES_HIGH },
    { "Medium", (ULONG_PTR)DMRES_MEDIUM },
    { "Low", (ULONG_PTR)DMRES_LOW },
    { "Draft", (ULONG_PTR)DMRES_DRAFT },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeColor[] = {
    { "Color", DMCOLOR_COLOR },
    { "Monochrome", DMCOLOR_MONOCHROME },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeDuplex[] = {
    { "Simplex", DMDUP_SIMPLEX },
    { "Horizontal", DMDUP_HORIZONTAL },
    { "Vertical", DMDUP_VERTICAL },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeTTOption[] = {
    { "Bitmap", DMTT_BITMAP },
    { "DownLoad", DMTT_DOWNLOAD },
    { "SubDev", DMTT_SUBDEV },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeCollate[] = {
    { "True", DMCOLLATE_TRUE },
    { "False", DMCOLLATE_FALSE },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeICMMethod[] = {
    { "None", DMICMMETHOD_NONE },
    { "System", DMICMMETHOD_SYSTEM },
    { "Driver", DMICMMETHOD_DRIVER },
    { "Device", DMICMMETHOD_DEVICE },
    { NULL, 0 }
};


DEBUG_VALUES gadvDevModeICMIntent[] = {
    { "Saturate", DMICM_SATURATE },
    { "Contrast", DMICM_CONTRAST },
    { "ColorMetric", DMICM_COLORIMETRIC },
    { NULL, 0 }
};


DEBUG_VALUES gadvDevModeMediaType[] = {
    { "Standard", DMMEDIA_STANDARD },
    { "Glossy", DMMEDIA_GLOSSY },
    { "Transparency", DMMEDIA_TRANSPARENCY },
    { NULL, 0 }
};


DEBUG_VALUES gadvDevModeDitherType[] = {
    { "None", DMDITHER_NONE },
    { "Coarse", DMDITHER_COARSE },
    { "Fine", DMDITHER_FINE },
    { "LineArt", DMDITHER_LINEART },
    { "GrayScale", DMDITHER_GRAYSCALE },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeOrient[] = {
    { "Portrait", DMORIENT_PORTRAIT },
    { "Landscape", DMORIENT_LANDSCAPE },
    { NULL, 0 }
};

BOOL
TDebugExt::
bDumpDevMode(
    PVOID pDevMode_,
    ULONG_PTR dwAddr
    )
{
    PDEVMODE pDevMode = (PDEVMODE)pDevMode_;

    ULONG_PTR dwTotalSize = pDevMode->dmSize + pDevMode->dmDriverExtra;

    Print( "DevMode*\n" );

    Print( "       dmDeviceName %ws\n", pDevMode->dmDeviceName );
    Print( "      dmSpecVersion %x\n", pDevMode->dmSpecVersion );
    Print( "    dmDriverVersion %x\n", pDevMode->dmDriverVersion );

    Print( "====         dmSize %x <%d>   TotalSize %x <%d>\n",
           pDevMode->dmSize,
           pDevMode->dmSize,
           dwTotalSize, dwTotalSize );

    Print( "      dmDriverExtra %x <%d>\n",
           pDevMode->dmDriverExtra,
           pDevMode->dmDriverExtra );

    Print( "           dmFields " );
    vDumpFlags( pDevMode->dmFields, gadfDevModeFields );

    Print( "      dmOrientation " );
    vDumpValue( pDevMode->dmOrientation, gadvDevModeOrient );

    Print( "        dmPaperSize " );
    vDumpValue( pDevMode->dmPaperSize, gadvDevModePapers );

    Print( "      dmPaperLength %x\n", pDevMode->dmPaperLength );
    Print( "       dmPaperWidth %x\n", pDevMode->dmPaperWidth );
    Print( "            dmScale %x\n", pDevMode->dmScale );
    Print( "           dmCopies %x\n", pDevMode->dmCopies );
    Print( "    dmDefaultSource " );
    vDumpValue( pDevMode->dmDefaultSource, gadvDevModeDefaultSource );

    Print( "     dmPrintQuality " );
    vDumpValue( pDevMode->dmPrintQuality, gadvDevModePrintQuality );

    Print( "            dmColor " );
    vDumpValue( pDevMode->dmColor, gadvDevModeColor );

    Print( "           dmDuplex " );
    vDumpValue( pDevMode->dmDuplex, gadvDevModeDuplex );

    Print( "      dmYResolution %x\n", pDevMode->dmYResolution );

    Print( "         dmTTOption " );
    vDumpValue( pDevMode->dmTTOption, gadvDevModeTTOption );

    Print( "          dmCollate " );
    vDumpValue( pDevMode->dmCollate, gadvDevModeCollate );

    Print( "====     dmFormName %ws\n", pDevMode->dmFormName );
    Print( "        dmLogPixels %x\n", pDevMode->dmLogPixels );
    Print( "       dmBitsPerPel %x\n", pDevMode->dmBitsPerPel );
    Print( "        dmPelsWidth %x\n", pDevMode->dmPelsWidth );
    Print( "       dmPelsHeight %x\n", pDevMode->dmPelsHeight );

    Print( "     dmDisplayFlags %x\n", pDevMode->dmDisplayFlags );
    Print( " dmDisplayFrequency %x\n", pDevMode->dmDisplayFrequency );

    Print( "====    dmICMMethod " );
    vDumpValue( pDevMode->dmICMMethod, gadvDevModeICMMethod );

    Print( "        dmICMIntent " );
    vDumpValue( pDevMode->dmICMIntent, gadvDevModeICMIntent );

    Print( "        dmMediaType " );
    vDumpValue( pDevMode->dmMediaType, gadvDevModeMediaType );

    Print( "       dmDitherType " );
    vDumpValue( pDevMode->dmDitherType, gadvDevModeDitherType );

    Print( "====     Private at %x\n", dwAddr+pDevMode->dmSize );

    return TRUE;
}


BOOL
TDebugExt::
bDumpDevModeA(
    PVOID pDevModeA_,
    ULONG_PTR dwAddr
    )
{
    PDEVMODEA pDevMode = (PDEVMODEA)pDevModeA_;

    ULONG_PTR dwTotalSize = pDevMode->dmSize + pDevMode->dmDriverExtra;

    Print( "DevModeA*\n" );

    Print( "       dmDeviceName %hs\n", pDevMode->dmDeviceName );
    Print( "      dmSpecVersion %x\n", pDevMode->dmSpecVersion );
    Print( "    dmDriverVersion %x\n", pDevMode->dmDriverVersion );

    Print( "====         dmSize %x <%d>   TotalSize %x <%d>\n",
           pDevMode->dmSize,
           pDevMode->dmSize,
           dwTotalSize, dwTotalSize );

    Print( "      dmDriverExtra %x <%d>\n",
           pDevMode->dmDriverExtra,
           pDevMode->dmDriverExtra );

    Print( "           dmFields " );
    vDumpFlags( pDevMode->dmFields, gadfDevModeFields );

    Print( "      dmOrientation " );
    vDumpValue( pDevMode->dmOrientation, gadvDevModeOrient );

    Print( "        dmPaperSize " );
    vDumpValue( pDevMode->dmPaperSize, gadvDevModePapers );

    Print( "      dmPaperLength %x\n", pDevMode->dmPaperLength );
    Print( "       dmPaperWidth %x\n", pDevMode->dmPaperWidth );
    Print( "            dmScale %x\n", pDevMode->dmScale );
    Print( "           dmCopies %x\n", pDevMode->dmCopies );
    Print( "    dmDefaultSource " );
    vDumpValue( pDevMode->dmDefaultSource, gadvDevModeDefaultSource );

    Print( "     dmPrintQuality " );
    vDumpValue( pDevMode->dmPrintQuality, gadvDevModePrintQuality );

    Print( "            dmColor " );
    vDumpValue( pDevMode->dmColor, gadvDevModeColor );

    Print( "           dmDuplex " );
    vDumpValue( pDevMode->dmDuplex, gadvDevModeDuplex );

    Print( "      dmYResolution %x\n", pDevMode->dmYResolution );

    Print( "         dmTTOption " );
    vDumpValue( pDevMode->dmTTOption, gadvDevModeTTOption );

    Print( "          dmCollate " );
    vDumpValue( pDevMode->dmCollate, gadvDevModeCollate );

    Print( "====     dmFormName %hs\n", pDevMode->dmFormName );
    Print( "        dmLogPixels %x\n", pDevMode->dmLogPixels );
    Print( "       dmBitsPerPel %x\n", pDevMode->dmBitsPerPel );
    Print( "        dmPelsWidth %x\n", pDevMode->dmPelsWidth );
    Print( "       dmPelsHeight %x\n", pDevMode->dmPelsHeight );

    Print( "     dmDisplayFlags %x\n", pDevMode->dmDisplayFlags );
    Print( " dmDisplayFrequency %x\n", pDevMode->dmDisplayFrequency );

    Print( "====    dmICMMethod " );
    vDumpValue( pDevMode->dmICMMethod, gadvDevModeICMMethod );

    Print( "        dmICMIntent " );
    vDumpValue( pDevMode->dmICMIntent, gadvDevModeICMIntent );

    Print( "        dmMediaType " );
    vDumpValue( pDevMode->dmMediaType, gadvDevModeMediaType );

    Print( "       dmDitherType " );
    vDumpValue( pDevMode->dmDitherType, gadvDevModeDitherType );

    Print( "====     Private at %x\n", dwAddr+pDevMode->dmSize );

    return TRUE;
}


#if 0
BOOL
TDebugExt::
bDumpIniPrinter(
    PVOID pIniPrinter_,
    ULONG_PTR dwAddr
    )
{
    PIniPrinter pIniPrinter = (PIniPrinter)pIniPrinter_;

    static DEBUG_FLAGS adfSpl[] = {
        { "UpdateWinIniDevices", SPL_UPDATE_WININI_DEVICES },
        { NULL, 0  }
    };

    if( !( pIniPrinter->signature == ID_SIGNATURE )){
        return FALSE;
    }

    Print( "IniPrinter*\n" );

    return TRUE;
}

#endif



/********************************************************************

    Extension entrypoints.

********************************************************************/

DEBUG_EXT_ENTRY( ds, INISPOOLER, bDumpIniSpooler, "&localspl!pLocalIniSpooler", FALSE )

DEBUG_EXT_ENTRY( ddev, DEVMODE, bDumpDevMode, NULL, FALSE )
DEBUG_EXT_ENTRY( ddeva, DEVMODEA, bDumpDevModeA, NULL, FALSE )

DEBUG_EXT_ENTRY( dlcs,
                 MCritSec,
                 bDumpCritSec,
                 "&localspl!hcsSpoolerSection",
                 TRUE )

DEBUG_EXT_HEAD(lastlog)
{
    DEBUG_EXT_SETUP_VARS();

    ULONG_PTR dwAddress = 0;

    //
    // Read in localspl's gDbgPointers.
    //
    DBG_POINTERS DbgPointers;
    ULONG_PTR ppDbgPointers = 0;
    ULONG_PTR pDbgPointers = 0;

    ppDbgPointers = EvalExpression( "&localspl!gpDbgPointers" );

    if( !ppDbgPointers ){
        Print( "<Unable to resolve localspl!gpDbgPointers>\n" );
        return;
    }

    move( pDbgPointers, ppDbgPointers );

    if( !pDbgPointers ){
        Print( "<Unable to read valid localspl!gpDbgPointers>\n" );
        return;
    }

    move( DbgPointers, pDbgPointers );

    if( !DbgPointers.pbtTraceLog ){
        Print( "<Unable to read valid DbgPointers.pbtTraceLog>\n" );
        return;
    }

    vDumpTraceWithFlags( lpArgumentString, (ULONG_PTR)DbgPointers.pbtTraceLog );
}

/********************************************************************

    Signature matching dump function.

********************************************************************/


#define DEBUG_EXT_TRY_SETUP()                                          \
    PBYTE var = (PBYTE)EvalExpression( lpArgumentString );             \
    PVOID pvData;                                                      \
    BOOL bDone;                                                        \
    Print( "%x ", var )

#define DEBUG_EXT_TRY( struct, func )                                  \
    pvData = LocalAlloc( LPTR, sizeof( struct ));                      \
    move2( pvData, var, sizeof( struct ));                             \
    bDone = TDebugExt::func( pvData, (ULONG_PTR)var );                  \
    LocalFree( pvData );                                               \
                                                                       \
    if( bDone ){                                                       \
        return;                                                        \
    }

#define DEBUG_EXT_TRY_DONE()                                           \
    Print( "<No Match %x>\n", var )


DEBUG_EXT_HEAD( d )
{
    DEBUG_EXT_SETUP_VARS();
    DEBUG_EXT_TRY_SETUP();

    DEBUG_EXT_TRY( INISPOOLER, bDumpIniSpooler );
    DEBUG_EXT_TRY( INIPRINTER, bDumpIniPrinter );
    DEBUG_EXT_TRY( INIPRINTPROC, bDumpIniPrintProc );
    DEBUG_EXT_TRY( INIVERSION, bDumpIniVersion );
    DEBUG_EXT_TRY( INIDRIVER, bDumpIniDriver );
    DEBUG_EXT_TRY( INIENVIRONMENT, bDumpIniEnvironment );
    DEBUG_EXT_TRY( INIMONITOR, bDumpIniMonitor );
    DEBUG_EXT_TRY( INIJOB, bDumpIniJob );
    DEBUG_EXT_TRY( INIPORT, bDumpIniPort );
    DEBUG_EXT_TRY( SPOOL, bDumpSpool );

    DEBUG_EXT_TRY_DONE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inc\clusrout.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusrout.h

Abstract:

    Cluster code support: entrypoints exposed by the router.

Author:

    Albert Ting (AlbertT) 1-Oct-96

Revision History:

--*/

#ifndef _CLUSROUT_H
#define _CLUSROUT_H

BOOL
ClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    );

BOOL
ClusterSplClose(
    HANDLE hSpooler
    );


BOOL
ClusterSplIsAlive(
    HANDLE hSpooler
    );

#endif // ifdef _CLUSROUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inc\change.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    change.h

Abstract:

    Holds change definitions for spooler system change notify.

Author:

    Albert Ting (AlbertT) 05-Mar-94

Environment:

    User Mode -Win32

Revision History:

--*/
#ifndef _CHANGE_H
#define _CHANGE_H

//
// Timeout value for WaitForPrinterChange
//
#define PRINTER_CHANGE_TIMEOUT_VALUE 600000

//
// Flags used for FFPCN
//
#define PRINTER_NOTIFY_OPTION_SIM_FFPCN         0x10000
#define PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE  0x20000
#define PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE   0x40000
#define PRINTER_NOTIFY_OPTION_SIM_WPC           0x80000

//#define PRINTER_NOTIFY_INFO_DISCARDED         0x1
#define PRINTER_NOTIFY_INFO_DISCARDNOTED        0x010000
#define PRINTER_NOTIFY_INFO_COLORSET            0x020000
#define PRINTER_NOTIFY_INFO_COLOR               0x040000
#define PRINTER_NOTIFY_INFO_COLORMISMATCH       0x080000

//#define PRINTER_NOTIFY_OPTIONS_REFRESH        0x1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inc\data.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.h

Abstract:

    Common definitions for structure offsets for pointer based data.

Author:

Environment:

    User Mode - Win32

Revision History:

Notes: 

    FOR ADDING OR UPDATING Offset structures.

All the offsets should appear in ascending order in the struct. This is critical
for converting 32 bit structures into the corresponding 64 bit structures. Custom 
marshalling will break if this is not adhered to.

See spllib\marshall.cxx for additional information

--*/

#ifndef _DATA_H
#define _DATA_H

#include <offsets.h>
#include <winsprlp.h>

#ifdef PRINTER_OFFSETS
DWORD PrinterInfoStressOffsets[]={offsetof(PRINTER_INFO_STRESSA, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSA, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo1Offsets[]={offsetof(PRINTER_INFO_1A, pDescription),
                             offsetof(PRINTER_INFO_1A, pName),
                             offsetof(PRINTER_INFO_1A, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Offsets[]={offsetof(PRINTER_INFO_2A, pServerName),
                             offsetof(PRINTER_INFO_2A, pPrinterName),
                             offsetof(PRINTER_INFO_2A, pShareName),
                             offsetof(PRINTER_INFO_2A, pPortName),
                             offsetof(PRINTER_INFO_2A, pDriverName),
                             offsetof(PRINTER_INFO_2A, pComment),
                             offsetof(PRINTER_INFO_2A, pLocation),
                             offsetof(PRINTER_INFO_2A, pDevMode),
                             offsetof(PRINTER_INFO_2A, pSepFile),
                             offsetof(PRINTER_INFO_2A, pPrintProcessor),
                             offsetof(PRINTER_INFO_2A, pDatatype),
                             offsetof(PRINTER_INFO_2A, pParameters),
                             offsetof(PRINTER_INFO_2A, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo3Offsets[]={offsetof(PRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo4Offsets[]={offsetof(PRINTER_INFO_4A, pPrinterName),
                             offsetof(PRINTER_INFO_4A, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Offsets[]={offsetof(PRINTER_INFO_5A, pPrinterName),
                             offsetof(PRINTER_INFO_5A, pPortName),
                             0xFFFFFFFF};

DWORD PrinterInfo6Offsets[]={0xFFFFFFFF};

DWORD PrinterInfo7Offsets[]={offsetof(PRINTER_INFO_7A, pszObjectGUID),
                             0xFFFFFFFF};

DWORD PrinterInfo8Offsets[]={offsetof(PRINTER_INFO_8A, pDevMode),
                             0xFFFFFFFF};

DWORD PrinterInfo9Offsets[]={offsetof(PRINTER_INFO_9A, pDevMode),
                             0xFFFFFFFF};
#endif

#ifdef PRINTER_STRINGS
DWORD PrinterInfoStressStrings[]={offsetof(PRINTER_INFO_STRESSA, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSA, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo1Strings[]={offsetof(PRINTER_INFO_1A, pDescription),
                             offsetof(PRINTER_INFO_1A, pName),
                             offsetof(PRINTER_INFO_1A, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Strings[]={offsetof(PRINTER_INFO_2A, pServerName),
                             offsetof(PRINTER_INFO_2A, pPrinterName),
                             offsetof(PRINTER_INFO_2A, pShareName),
                             offsetof(PRINTER_INFO_2A, pPortName),
                             offsetof(PRINTER_INFO_2A, pDriverName),
                             offsetof(PRINTER_INFO_2A, pComment),
                             offsetof(PRINTER_INFO_2A, pLocation),
                             offsetof(PRINTER_INFO_2A, pSepFile),
                             offsetof(PRINTER_INFO_2A, pPrintProcessor),
                             offsetof(PRINTER_INFO_2A, pDatatype),
                             offsetof(PRINTER_INFO_2A, pParameters),
                             0xFFFFFFFF};

DWORD PrinterInfo3Strings[]={0xFFFFFFFF};

DWORD PrinterInfo4Strings[]={offsetof(PRINTER_INFO_4A, pPrinterName),
                             offsetof(PRINTER_INFO_4A, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Strings[]={offsetof(PRINTER_INFO_5A, pPrinterName),
                             offsetof(PRINTER_INFO_5A, pPortName),
                             0xFFFFFFFF};

DWORD PrinterInfo6Strings[]={0xFFFFFFFF};

DWORD PrinterInfo7Strings[]={offsetof(PRINTER_INFO_7A, pszObjectGUID),
                             0xFFFFFFFF};

DWORD PrinterInfo8Strings[]={0xFFFFFFFF};

DWORD PrinterInfo9Strings[]={0xFFFFFFFF};

#endif


#ifdef JOB_OFFSETS
DWORD JobInfo1Offsets[]={offsetof(JOB_INFO_1A, pPrinterName),
                         offsetof(JOB_INFO_1A, pMachineName),
                         offsetof(JOB_INFO_1A, pUserName),
                         offsetof(JOB_INFO_1A, pDocument),
                         offsetof(JOB_INFO_1A, pDatatype),
                         offsetof(JOB_INFO_1A, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2Offsets[]={offsetof(JOB_INFO_2, pPrinterName),
                         offsetof(JOB_INFO_2, pMachineName),
                         offsetof(JOB_INFO_2, pUserName),
                         offsetof(JOB_INFO_2, pDocument),
                         offsetof(JOB_INFO_2, pNotifyName),
                         offsetof(JOB_INFO_2, pDatatype),
                         offsetof(JOB_INFO_2, pPrintProcessor),
                         offsetof(JOB_INFO_2, pParameters),
                         offsetof(JOB_INFO_2, pDriverName),
                         offsetof(JOB_INFO_2, pDevMode),
                         offsetof(JOB_INFO_2, pStatus),
                         offsetof(JOB_INFO_2, pSecurityDescriptor),
                         0xFFFFFFFF};

DWORD JobInfo3Offsets[]={0xFFFFFFFF};
#endif

#ifdef JOB_STRINGS
DWORD JobInfo1Strings[]={offsetof(JOB_INFO_1A, pPrinterName),
                         offsetof(JOB_INFO_1A, pMachineName),
                         offsetof(JOB_INFO_1A, pUserName),
                         offsetof(JOB_INFO_1A, pDocument),
                         offsetof(JOB_INFO_1A, pDatatype),
                         offsetof(JOB_INFO_1A, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2Strings[]={offsetof(JOB_INFO_2, pPrinterName),
                         offsetof(JOB_INFO_2, pMachineName),
                         offsetof(JOB_INFO_2, pUserName),
                         offsetof(JOB_INFO_2, pDocument),
                         offsetof(JOB_INFO_2, pNotifyName),
                         offsetof(JOB_INFO_2, pDatatype),
                         offsetof(JOB_INFO_2, pPrintProcessor),
                         offsetof(JOB_INFO_2, pParameters),
                         offsetof(JOB_INFO_2, pDriverName),
                         offsetof(JOB_INFO_2, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo3Strings[]={0xFFFFFFFF};
#endif


#ifdef DRIVER_OFFSETS
DWORD DriverInfo1Offsets[]={offsetof(DRIVER_INFO_1A, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Offsets[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo3Offsets[]={offsetof(DRIVER_INFO_3A, pName),
                            offsetof(DRIVER_INFO_3A, pEnvironment),
                            offsetof(DRIVER_INFO_3A, pDriverPath),
                            offsetof(DRIVER_INFO_3A, pDataFile),
                            offsetof(DRIVER_INFO_3A, pConfigFile),
                            offsetof(DRIVER_INFO_3A, pHelpFile),
                            offsetof(DRIVER_INFO_3A, pDependentFiles),
                            offsetof(DRIVER_INFO_3A, pMonitorName),
                            offsetof(DRIVER_INFO_3A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo4Offsets[]={offsetof(DRIVER_INFO_4A, pName),
                            offsetof(DRIVER_INFO_4A, pEnvironment),
                            offsetof(DRIVER_INFO_4A, pDriverPath),
                            offsetof(DRIVER_INFO_4A, pDataFile),
                            offsetof(DRIVER_INFO_4A, pConfigFile),
                            offsetof(DRIVER_INFO_4A, pHelpFile),
                            offsetof(DRIVER_INFO_4A, pDependentFiles),
                            offsetof(DRIVER_INFO_4A, pMonitorName),
                            offsetof(DRIVER_INFO_4A, pDefaultDataType),
                            offsetof(DRIVER_INFO_4A, pszzPreviousNames),
                            0xFFFFFFFF};

DWORD DriverInfo5Offsets[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo6Offsets[]={offsetof(DRIVER_INFO_6A, pName),
                            offsetof(DRIVER_INFO_6A, pEnvironment),
                            offsetof(DRIVER_INFO_6A, pDriverPath),
                            offsetof(DRIVER_INFO_6A, pDataFile),
                            offsetof(DRIVER_INFO_6A, pConfigFile),
                            offsetof(DRIVER_INFO_6A, pHelpFile),
                            offsetof(DRIVER_INFO_6A, pDependentFiles),
                            offsetof(DRIVER_INFO_6A, pMonitorName),
                            offsetof(DRIVER_INFO_6A, pDefaultDataType),
                            offsetof(DRIVER_INFO_6A, pszzPreviousNames),
                            offsetof(DRIVER_INFO_6A, pszMfgName),
                            offsetof(DRIVER_INFO_6A, pszOEMUrl),
                            offsetof(DRIVER_INFO_6A, pszHardwareID),
                            offsetof(DRIVER_INFO_6A, pszProvider),
                            0xFFFFFFFF};


#endif

#ifdef DRIVER_STRINGS
DWORD DriverInfo1Strings[]={offsetof(DRIVER_INFO_1A, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Strings[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo3Strings[]={offsetof(DRIVER_INFO_3A, pName),
                            offsetof(DRIVER_INFO_3A, pEnvironment),
                            offsetof(DRIVER_INFO_3A, pDriverPath),
                            offsetof(DRIVER_INFO_3A, pDataFile),
                            offsetof(DRIVER_INFO_3A, pConfigFile),
                            offsetof(DRIVER_INFO_3A, pHelpFile),
                            offsetof(DRIVER_INFO_3A, pMonitorName),
                            offsetof(DRIVER_INFO_3A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo4Strings[]={offsetof(DRIVER_INFO_4A, pName),
                            offsetof(DRIVER_INFO_4A, pEnvironment),
                            offsetof(DRIVER_INFO_4A, pDriverPath),
                            offsetof(DRIVER_INFO_4A, pDataFile),
                            offsetof(DRIVER_INFO_4A, pConfigFile),
                            offsetof(DRIVER_INFO_4A, pHelpFile),
                            offsetof(DRIVER_INFO_4A, pMonitorName),
                            offsetof(DRIVER_INFO_4A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo5Strings[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo6Strings[]={offsetof(DRIVER_INFO_6A, pName),
                            offsetof(DRIVER_INFO_6A, pEnvironment),
                            offsetof(DRIVER_INFO_6A, pDriverPath),
                            offsetof(DRIVER_INFO_6A, pDataFile),
                            offsetof(DRIVER_INFO_6A, pConfigFile),
                            offsetof(DRIVER_INFO_6A, pHelpFile),
                            offsetof(DRIVER_INFO_6A, pMonitorName),
                            offsetof(DRIVER_INFO_6A, pDefaultDataType),
                            offsetof(DRIVER_INFO_6A, pszMfgName),
                            offsetof(DRIVER_INFO_6A, pszOEMUrl),
                            offsetof(DRIVER_INFO_6A, pszHardwareID),
                            offsetof(DRIVER_INFO_6A, pszProvider),
                            0xFFFFFFFF};

DWORD DriverInfoVersionStrings[]={offsetof(DRIVER_INFO_VERSION, pName),
                                  offsetof(DRIVER_INFO_VERSION, pEnvironment),
                                  offsetof(DRIVER_INFO_VERSION, pMonitorName),
                                  offsetof(DRIVER_INFO_VERSION, pDefaultDataType),
                                  offsetof(DRIVER_INFO_VERSION, pszMfgName),
                                  offsetof(DRIVER_INFO_VERSION, pszOEMUrl),
                                  offsetof(DRIVER_INFO_VERSION, pszHardwareID),
                                  offsetof(DRIVER_INFO_VERSION, pszProvider),
                                  0xFFFFFFFF};



#endif


#ifdef ADDJOB_OFFSETS
DWORD AddJobOffsets[]={offsetof(ADDJOB_INFO_1A, Path),
                       0xFFFFFFFF};
DWORD AddJob2Offsets[]={offsetof(ADDJOB_INFO_2W, pData),
                       0xFFFFFFFF};
#endif

#ifdef ADDJOB_STRINGS
DWORD AddJobStrings[]={offsetof(ADDJOB_INFO_1A, Path),
                       0xFFFFFFFF};
DWORD AddJob2Strings[]={offsetof(ADDJOB_INFO_2W, pData),
                        0xFFFFFFFF};

#endif


#ifdef FORM_OFFSETS
DWORD FormInfo1Offsets[]={offsetof(FORM_INFO_1A, pName),
                          0xFFFFFFFF};
#endif

#ifdef FORM_STRINGS
DWORD FormInfo1Strings[]={offsetof(FORM_INFO_1A, pName),
                          0xFFFFFFFF};
#endif


#ifdef PORT_OFFSETS
DWORD PortInfo1Offsets[]={offsetof(PORT_INFO_1A, pName),
                          0xFFFFFFFF};
DWORD PortInfo2Offsets[]={offsetof(PORT_INFO_2A, pPortName),
                          offsetof(PORT_INFO_2A, pMonitorName),
                          offsetof(PORT_INFO_2A, pDescription),
                          0xFFFFFFFF};
DWORD PortInfo3Offsets[]={offsetof(PORT_INFO_3A, pszStatus),
                          0xFFFFFFFF};
#endif

#ifdef PORT_STRINGS
DWORD PortInfo1Strings[]={offsetof(PORT_INFO_1A, pName),
                          0xFFFFFFFF};
DWORD PortInfo2Strings[]={offsetof(PORT_INFO_2A, pPortName),
                          offsetof(PORT_INFO_2A, pMonitorName),
                          offsetof(PORT_INFO_2A, pDescription),
                          0xFFFFFFFF};
#endif


#ifdef PRINTPROCESSOR_OFFSETS
DWORD PrintProcessorInfo1Offsets[]={offsetof(PRINTPROCESSOR_INFO_1A, pName),
                                    0xFFFFFFFF};
#endif

#ifdef PRINTPROCESSOR_STRINGS
DWORD PrintProcessorInfo1Strings[]={offsetof(PRINTPROCESSOR_INFO_1A, pName),
                                    0xFFFFFFFF};
#endif


#ifdef MONITOR_OFFSETS
DWORD MonitorInfo1Offsets[]={offsetof(MONITOR_INFO_1A, pName),
                             0xFFFFFFFF};
DWORD MonitorInfo2Offsets[]={offsetof(MONITOR_INFO_2A, pName),
                             offsetof(MONITOR_INFO_2A, pEnvironment),
                             offsetof(MONITOR_INFO_2A, pDLLName),
                             0xFFFFFFFF};
#endif

#ifdef MONITOR_STRINGS
DWORD MonitorInfo1Strings[]={offsetof(MONITOR_INFO_1A, pName),
                             0xFFFFFFFF};

DWORD MonitorInfo2Strings[]={offsetof(MONITOR_INFO_2A, pName),
                             offsetof(MONITOR_INFO_2A, pEnvironment),
                             offsetof(MONITOR_INFO_2A, pDLLName),
                             0xFFFFFFFF};
#endif


#ifdef DOCINFO_OFFSETS
DWORD DocInfo1Offsets[]={offsetof(DOC_INFO_1A, pDocName),
                         offsetof(DOC_INFO_1A, pOutputFile),
                         offsetof(DOC_INFO_1A, pDatatype),
                         0xFFFFFFFF};
#endif

#ifdef DOCINFO_STRINGS
DWORD DocInfo1Strings[]={offsetof(DOC_INFO_1A, pDocName),
                         offsetof(DOC_INFO_1A, pOutputFile),
                         offsetof(DOC_INFO_1A, pDatatype),
                         0xFFFFFFFF};
#endif


#ifdef DATATYPE_OFFSETS
DWORD DatatypeInfo1Offsets[]={offsetof(DATATYPES_INFO_1A, pName),
                               0xFFFFFFFF};
#endif

#ifdef DATATYPE_STRINGS

DWORD DatatypeInfo1Strings[]={offsetof(DATATYPES_INFO_1A, pName),
                               0xFFFFFFFF};
#endif


#ifdef PRINTER_ENUM_VALUES_OFFSETS

DWORD PrinterEnumValuesOffsets[] = {offsetof(PRINTER_ENUM_VALUESA, pValueName),
                                    offsetof(PRINTER_ENUM_VALUESA, pData),
                                    0xFFFFFFFF};
#endif

#ifdef PROVIDOR_STRINGS
DWORD ProvidorInfo1Strings[]={offsetof(PROVIDOR_INFO_1A, pName),
                              offsetof(PROVIDOR_INFO_1A, pEnvironment),
                              offsetof(PROVIDOR_INFO_1A, pDLLName),
                              0xFFFFFFFF};

DWORD ProvidorInfo2Strings[]={0xFFFFFFFF};
#endif



#ifdef PRINTER_OFFSETS
FieldInfo PrinterInfoStressFields[]={
                             {offsetof(PRINTER_INFO_STRESSA, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },                                 
                             {offsetof(PRINTER_INFO_STRESSA, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalBytes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, stUpTime), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, MaxcRef), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalPagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwGetVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, fFreeBuild), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cSpooling), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cMaxSpooling), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cRef), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cErrorOutOfPaper), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cErrorNotReady), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cJobError), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwNumberOfProcessors), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwProcessorType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwHighPartTotalBytes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cChangeID), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwLastError), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cEnumerateNetworkPrinters), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cAddNetPrinters), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, wProcessorArchitecture), sizeof(WORD), sizeof(WORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, wProcessorLevel), sizeof(WORD), sizeof(WORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cRefIC), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwReserved2), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwReserved3), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };
                             

FieldInfo PrinterInfo1Fields[]={
                                {offsetof(PRINTER_INFO_1A, Flags), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_1A, pDescription), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_1A, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };
FieldInfo PrinterInfo2Fields[]={
                                {offsetof(PRINTER_INFO_2A, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pShareName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pLocation), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pSepFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, DefaultPriority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, AveragePPM), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo3Fields[]={
                                {offsetof(PRINTER_INFO_3, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo4Fields[]={
                                {offsetof(PRINTER_INFO_4A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_4A, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_4A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo5Fields[]={
                                {offsetof(PRINTER_INFO_5A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_5A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_5A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_5A, TransmissionRetryTimeout), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_5A, TransmissionRetryTimeout), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo6Fields[]={
                                {offsetof(PRINTER_INFO_6, dwStatus), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo7Fields[]={
                                {offsetof(PRINTER_INFO_7A, pszObjectGUID), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_7A, dwAction), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo8Fields[]={
                                {offsetof(PRINTER_INFO_8A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo9Fields[]={
                                {offsetof(PRINTER_INFO_9A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

#endif


#ifdef JOB_OFFSETS

FieldInfo JobInfo1Fields[]= {
                             {offsetof(JOB_INFO_1A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pMachineName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pUserName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pDocument), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Position), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, TotalPages), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, PagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Submitted), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };


FieldInfo JobInfo2Fields[]= {
                             {offsetof(JOB_INFO_2A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pMachineName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pUserName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDocument), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pNotifyName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Position), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, TotalPages), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Size), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Submitted), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Time), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, PagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };

FieldInfo JobInfo3Fields[]= {
                            {offsetof(JOB_INFO_3, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {offsetof(JOB_INFO_3, NextJobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {offsetof(JOB_INFO_3, Reserved), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {0xFFFFFFFF, 0, 0, DATA_TYPE}
                            };
#endif


#ifdef DRIVER_OFFSETS

FieldInfo DriverInfo1Fields[]= {
                                {offsetof(DRIVER_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo2Fields[]= {
                                {offsetof(DRIVER_INFO_2A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_2A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_2A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_2A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_2A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo3Fields[]= {
                                {offsetof(DRIVER_INFO_3A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_3A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_3A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_3A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_3A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo4Fields[]= {
                                {offsetof(DRIVER_INFO_4A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_4A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_4A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_4A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_4A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo5Fields[]= {
                                {offsetof(DRIVER_INFO_5A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_5A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_5A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_5A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_5A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_5A, dwDriverAttributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, dwConfigVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, dwDriverVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo DriverInfo6Fields[]= {
                                {offsetof(DRIVER_INFO_6A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_6A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_6A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_6A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, ftDriverDate), sizeof(FILETIME), sizeof(DWORD), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_6A, dwlDriverVersion), sizeof(DWORDLONG), sizeof(DWORDLONG), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszMfgName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszOEMUrl), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszHardwareID), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszProvider), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo DriverInfoVersionFields[]= {
                                {offsetof(DRIVER_INFO_VERSION, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pFileInfo), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, dwFileCount), sizeof(DWORD),sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, ftDriverDate), sizeof(FILETIME), sizeof(DWORD), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, dwlDriverVersion), sizeof(DWORDLONG), sizeof(DWORDLONG), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszMfgName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszOEMUrl), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszHardwareID), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszProvider), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

#endif

#ifdef ADDJOB_OFFSETS
FieldInfo AddJobFields[]= {
                           {offsetof(ADDJOB_INFO_1A, Path), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                           {offsetof(ADDJOB_INFO_1A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                           {0xFFFFFFFF, 0, 0, DATA_TYPE}
                           };
FieldInfo AddJob2Fields[]= {
                           {offsetof(ADDJOB_INFO_2W, pData), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                           {offsetof(ADDJOB_INFO_2W, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                           {0xFFFFFFFF, 0, 0, DATA_TYPE}
                           };

#endif


#ifdef FORM_OFFSETS
FieldInfo FormInfo1Fields[]= {
                              {offsetof(FORM_INFO_1A, Flags), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(FORM_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(FORM_INFO_1A, Size), sizeof(SIZEL), sizeof(DWORD), DATA_TYPE },
                              {offsetof(FORM_INFO_1A, ImageableArea), sizeof(RECTL), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
#endif

#ifdef PORT_OFFSETS
FieldInfo PortInfo1Fields[]= {
                              {offsetof(PORT_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };

FieldInfo PortInfo2Fields[]= {
                              {offsetof(PORT_INFO_2A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, pMonitorName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, pDescription), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, fPortType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(PORT_INFO_2A, Reserved), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
                              
FieldInfo PortInfo3Fields[]= {
                              {offsetof(PORT_INFO_3A, dwStatus), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(PORT_INFO_3A, pszStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_3A, dwSeverity), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
#endif


#ifdef PRINTPROCESSOR_OFFSETS
FieldInfo PrintProcessorInfo1Fields[]= {
                                        {offsetof(PRINTPROCESSOR_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                        {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                        };
                              
#endif


#ifdef MONITOR_OFFSETS
FieldInfo MonitorInfo1Fields[]= {
                                 {offsetof(MONITOR_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
FieldInfo MonitorInfo2Fields[]= {
                                 {offsetof(MONITOR_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {offsetof(MONITOR_INFO_2A, pEnvironment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {offsetof(MONITOR_INFO_2A, pDLLName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
#endif


#ifdef DOCINFO_OFFSETS
FieldInfo DocInfo1Fields[]= {
                             {offsetof(DOC_INFO_1A, pDocName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(DOC_INFO_1A, pOutputFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(DOC_INFO_1A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };
#endif


#ifdef DATATYPE_OFFSETS
FieldInfo DatatypeInfo1Fields[]={
                                 {offsetof(DATATYPES_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
#endif

#ifdef PRINTER_ENUM_VALUES_OFFSETS
FieldInfo PrinterEnumValuesFields[]= {
                                      {offsetof(PRINTER_ENUM_VALUESA, pValueName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, cbValueName), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, dwType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, pData), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, cbData), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                      };

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inc\mtype.h ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation
All rights reserved.

Module Name:

    mtype.h

Abstract:

    Marshalling code needs this information about each field in _INFO_ structures. 
    Data.h define arrays of FieldInfo structures for each _INFO_ structure
    
Author:

    AdinaTru 18 Jan 2000

Revision History:


--*/

#ifndef _MTYPE
#define _MTYPE

typedef enum _EFIELDTYPE 
{
    DATA_TYPE = 0,
    PTR_TYPE  = 1,

} EFIELDTYPE;


typedef enum Call_Route
{
    NATIVE_CALL  = 0,   // either KM call or Spooler in-proc call
    RPC_CALL     = 1,   // RPC call
   
} CALL_ROUTE;

//
// Holds information about a field in public spooler structures _INFO_
//
typedef struct _FieldInfo 
{
    DWORD32 Offset;           // Field's offset inside structure
    ULONG_PTR Size;           // Field's size in bytes
    ULONG_PTR Alignment;      // Field's alignment; Not always the same as the size!!!
    EFIELDTYPE  Type;         // Field's type;  PTR_TYPE if pointer, DATA_TYPE otherwise

} FieldInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inc\ntfytab.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    ntfytab.h

Abstract:

    Table definitions for ntfy*.h.  There must not be any structure
    definitions here since this is included in winspl.idl.  The midl
    compiler generates winspl.h which would include these definions, and
    some files include both ntfytab.h and winspl.h (causing duplicate
    definitions).  This file should hold just #defines.

Author:

    Albert Ting (AlbertT) 04-Oct-94

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef _NTFYTAB_H
#define _NTFYTAB_H

#define TABLE_NULL                0x0
#define TABLE_DWORD               0x1
#define TABLE_STRING              0x2
#define TABLE_DEVMODE             0x3
#define TABLE_TIME                0x4
#define TABLE_SECURITYDESCRIPTOR  0x5
#define TABLE_PRINTPROC           0x6
#define TABLE_DRIVER              0x7

#define TABLE_ZERO                0xf0
#define TABLE_NULLSTRING          0xf1
#define TABLE_SPECIAL             0xff

#define TABLE_JOB_STATUS          0x100
#define TABLE_JOB_POSITION        0x101
#define TABLE_JOB_PRINTERNAME     0x102
#define TABLE_JOB_PORT            0x103

#define TABLE_PRINTER_STATUS      0x200
#define TABLE_PRINTER_DRIVER      0x201
#define TABLE_PRINTER_PORT        0x202
#define TABLE_PRINTER_SERVERNAME  0x203

//
// Must match above #defines (act TABLE_* acts as an index
// to the below array).
//
#define NOTIFY_DATATYPES \
{ \
    0,                     \
    0,                     \
    TABLE_ATTRIB_DATA_PTR, \
    TABLE_ATTRIB_DATA_PTR, \
    TABLE_ATTRIB_DATA_PTR, \
    TABLE_ATTRIB_DATA_PTR, \
    0                      \
}

#define TABLE_ATTRIB_DATA_PTR  0x2


#define INVALID_NOTIFY_FIELD ((WORD)-1)
#define INVALID_NOTIFY_TYPE ((WORD)-1)
//
// index = PRINTER_NOTIFY_TYPE
// value = bytes from PRINTER_NOTIFY_INFO_DATA to actual data.
// (Job has 4 bytes for JobId).
//
//#define NOTIFY_PRINTER_DATA_OFFSETS { 0, 4 }

#define NOTIFY_TYPE_MAX             0x02
#define PRINTER_NOTIFY_NEXT_INFO    0x01

//
// COMPACT   = Data is a DWORD (TABLE_ATTRIB_DATA_PTR must not be set)
//             Router will overwrite and compact old data.
// DISPLAY   = This attribute is displayable in PrintUI
//
#define TABLE_ATTRIB_COMPACT   0x1
#define TABLE_ATTRIB_DISPLAY   0x2


//
// The reply system can support different types of callbacks.
// These types are defined here and are used for RPC marshalling.
//
#define REPLY_PRINTER_CHANGE  0x0


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inc\offsets.h ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation
All rights reserved

Module Name:

    offsets.h

Abstract:

    Global structure declarations used by marshalling and string packing code.

Author:

Environment:

    User Mode - Spoolss

Revision History:

Notes: 

--*/

#ifndef _OFFSETS_H
#define _OFFSETS_H

#include "mType.h"

extern DWORD PrinterInfoStressOffsets[];
extern DWORD PrinterInfoStressStrings[];
extern DWORD PrinterInfo4Offsets[];
extern DWORD PrinterInfo4Strings[];
extern DWORD PrinterInfo1Offsets[];
extern DWORD PrinterInfo1Strings[];
extern DWORD PrinterInfo2Offsets[];
extern DWORD PrinterInfo2Strings[];
extern DWORD PrinterInfo3Offsets[];
extern DWORD PrinterInfo3Strings[];
extern DWORD PrinterInfo5Offsets[];
extern DWORD PrinterInfo5Strings[];
extern DWORD PrinterInfo6Offsets[];
extern DWORD PrinterInfo6Strings[];
extern DWORD PrinterInfo7Offsets[];
extern DWORD PrinterInfo7Strings[];
extern DWORD PrinterInfo8Offsets[];
extern DWORD PrinterInfo8Strings[];
extern DWORD PrinterInfo9Offsets[];
extern DWORD PrinterInfo9Strings[];
extern DWORD JobInfo1Offsets[];
extern DWORD JobInfo1Strings[];
extern DWORD JobInfo2Offsets[];
extern DWORD JobInfo2Strings[];
extern DWORD JobInfo3Offsets[];
extern DWORD JobInfo3Strings[];
extern DWORD DriverInfo1Offsets[];
extern DWORD DriverInfo1Strings[];
extern DWORD DriverInfo2Offsets[];
extern DWORD DriverInfo2Strings[];
extern DWORD DriverInfo3Offsets[];
extern DWORD DriverInfo3Strings[];
extern DWORD DriverInfo4Offsets[];
extern DWORD DriverInfo4Strings[];
extern DWORD DriverInfo5Offsets[];
extern DWORD DriverInfo5Strings[];
extern DWORD DriverInfo6Offsets[];
extern DWORD DriverInfoVersionStrings[];


extern DWORD DriverInfo6Strings[];
extern DWORD AddJobOffsets[];
extern DWORD AddJob2Offsets[];
extern DWORD AddJobStrings[];
extern DWORD AddJob2Strings[];
extern DWORD FormInfo1Offsets[];
extern DWORD FormInfo1Strings[];
extern DWORD PortInfo1Offsets[];
extern DWORD PortInfo1Strings[];
extern DWORD PortInfo2Offsets[];
extern DWORD PortInfo2Strings[];
extern DWORD PortInfo3Offsets[];
extern DWORD PrintProcessorInfo1Offsets[];
extern DWORD PrintProcessorInfo1Strings[];
extern DWORD MonitorInfo1Offsets[];
extern DWORD MonitorInfo2Offsets[];
extern DWORD MonitorInfo1Strings[];
extern DWORD MonitorInfo2Strings[];
extern DWORD DocInfo1Offsets[];
extern DWORD DocInfo1Strings[];
extern DWORD ProvidorInfo1Strings[];
extern DWORD ProvidorInfo2Strings[];
extern DWORD DatatypeInfo1Offsets[];
extern DWORD DatatypeInfo1Strings[];
extern DWORD PrinterEnumValuesOffsets[];


extern FieldInfo PrinterInfoStressFields[];
extern FieldInfo PrinterInfo4Fields[];
extern FieldInfo PrinterInfo1Fields[];
extern FieldInfo PrinterInfo2Fields[];
extern FieldInfo PrinterInfo3Fields[];
extern FieldInfo PrinterInfo5Fields[];
extern FieldInfo PrinterInfo6Fields[];
extern FieldInfo PrinterInfo7Fields[];
extern FieldInfo PrinterInfo8Fields[];
extern FieldInfo PrinterInfo9Fields[];
extern FieldInfo JobInfo1Fields[];
extern FieldInfo JobInfo2Fields[];
extern FieldInfo JobInfo3Fields[];
extern FieldInfo DriverInfo1Fields[];
extern FieldInfo DriverInfo2Fields[];
extern FieldInfo DriverInfo3Fields[];
extern FieldInfo DriverInfo4Fields[];
extern FieldInfo DriverInfo5Fields[];
extern FieldInfo DriverInfo6Fields[];
extern FieldInfo DriverInfoVersionFields[];

extern FieldInfo AddJobFields[];
extern FieldInfo AddJob2Fields[];
extern FieldInfo FormInfo1Fields[];
extern FieldInfo PortInfo1Fields[];
extern FieldInfo PortInfo2Fields[];
extern FieldInfo PortInfo3Fields[];
extern FieldInfo PrintProcessorInfo1Fields[];
extern FieldInfo MonitorInfo1Fields[];
extern FieldInfo MonitorInfo2Fields[];
extern FieldInfo DocInfo1Fields[];
extern FieldInfo DatatypeInfo1Fields[];
extern FieldInfo PrinterEnumValuesFields[];


extern FieldInfo PrinterInfoStressFields32[];
extern FieldInfo PrinterInfo4Fields32[];
extern FieldInfo PrinterInfo1Fields32[];
extern FieldInfo PrinterInfo2Fields32[];
extern FieldInfo PrinterInfo3Fields32[];
extern FieldInfo PrinterInfo5Fields32[];
extern FieldInfo PrinterInfo6Fields32[];
extern FieldInfo PrinterInfo7Fields32[];
extern FieldInfo PrinterInfo8Fields32[];
extern FieldInfo PrinterInfo9Fields32[];
extern FieldInfo JobInfo1Fields32[];
extern FieldInfo JobInfo2Fields32[];
extern FieldInfo JobInfo3Fields32[];
extern FieldInfo DriverInfo1Fields32[];
extern FieldInfo DriverInfo2Fields32[];
extern FieldInfo DriverInfo3Fields32[];
extern FieldInfo DriverInfo4Fields32[];
extern FieldInfo DriverInfo5Fields32[];
extern FieldInfo DriverInfo6Fields32[];
extern FieldInfo AddJobFields32[];
extern FieldInfo FormInfo1Fields32[];
extern FieldInfo PortInfo1Fields32[];
extern FieldInfo PortInfo2Fields32[];
extern FieldInfo PortInfo3Fields32[];
extern FieldInfo PrintProcessorInfo1Fields32[];
extern FieldInfo MonitorInfo1Fields32[];
extern FieldInfo MonitorInfo2Fields32[];
extern FieldInfo DocInfo1Fields32[];
extern FieldInfo DatatypeInfo1Fields32[];
extern FieldInfo PrinterEnumValuesFields32[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inc\splcom.h ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation
All rights reserved.

Module Name:

    splcom.h

Abstract:

    Header file for Common Routines in the Spooler.

    Note -- link with spoolss.lib  to find these routines

Author:

    Krishna Ganugapati (KrishnaG) 02-Feb-1994

Revision History:


--*/

#ifndef  _SPLCOM
#define _SPLCOM

#include "spllib.hxx"

//
// Include necessary for PATTRIBUTE_INFO_3, parameter in GetJobAttributes
// which was moved from prtprocs\winprint to spoolss\dll
//
#include <winddiui.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((ULONG_PTR)addr &= ~1))

#define DWORD_ALIGN_UP(size) (((size)+3)&~3)
#define DWORD_ALIGN_DOWN(size) ((size)&~3)

#define ALIGN_UP(addr, type)  ((type) ((ULONG_PTR) (addr) + (sizeof(type) - 1))&~(sizeof(type) - 1))
#define ALIGN_DOWN(addr, type) ((type) ((ULONG_PTR) (addr) & ~(sizeof(type) - 1)))

#define ALIGN_PTR_UP(addr)      ALIGN_UP(addr, ULONG_PTR)
#define ALIGN_PTR_DOWN(addr)    ALIGN_DOWN(addr, ULONG_PTR)

//
// BitMap macros, assumes map is a DWORD array
//
#define MARKUSE(map, pos) ((map)[(pos) / 32] |= (1 << ((pos) % 32) ))
#define MARKOFF(map, pos) ((map)[(pos) / 32] &= ~(1 << ((pos) % 32) ))

#define ISBITON(map, id) ((map)[id / 32] & ( 1 << ((id) % 32) ) )

#define BROADCAST_TYPE_MESSAGE        1
#define BROADCAST_TYPE_CHANGEDEFAULT  2



VOID
UpdatePrinterRegAll(
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL bDelete
    );

#define UPDATE_REG_CHANGE FALSE
#define UPDATE_REG_DELETE TRUE

#if defined(_MIPS_)
#define LOCAL_ENVIRONMENT L"Windows NT R4000"
#elif defined(_AXP64_)
#define LOCAL_ENVIRONMENT L"Windows Alpha_AXP64"
#elif defined(_ALPHA_)
#define LOCAL_ENVIRONMENT L"Windows NT Alpha_AXP"
#elif defined(_PPC_)
#define LOCAL_ENVIRONMENT L"Windows NT PowerPC"
#elif defined(_IA64_)
#define LOCAL_ENVIRONMENT L"Windows IA64"
#else
#define LOCAL_ENVIRONMENT L"Windows NT x86"
#endif

#define SPOOLER_VERSION 3
#define NOTIFICATION_VERSION 2
#define DSPRINTQUEUE_VERSION SPOOLER_VERSION

//
// Flags for ResetPrinterEx
//


#define RESET_PRINTER_DATATYPE       0x00000001
#define RESET_PRINTER_DEVMODE        0x00000002

VOID
SplShutDownRouter(
    VOID
    );

PVOID
MIDL_user_allocate1 (
    IN size_t NumBytes
    );


VOID
MIDL_user_free1 (
    IN void *MemPointer
    );


BOOL
BroadcastMessage(
    DWORD   dwType,
    DWORD   dwMessage,
    WPARAM  wParam,
    LPARAM  lParam
    );

VOID
DllSetFailCount(
    DWORD   FailCount
    );

LPVOID
DllAllocSplMem(
    DWORD cb
    );

BOOL
DllFreeSplMem(
   LPVOID pMem
   );

LPVOID
ReallocSplMem(
   LPVOID lpOldMem,
   DWORD cbOld,
   DWORD cbNew
   );


LPWSTR
AllocSplStr(
    LPCWSTR lpStr
    );


BOOL
DllFreeSplStr(
   LPWSTR lpStr
   );

BOOL
ReallocSplStr(
   LPWSTR *plpStr,
   LPCWSTR lpStr
   );

LPVOID
AlignRpcPtr (
    LPVOID  pBuffer,
    LPDWORD pcbBuf
    );

VOID
UndoAlignRpcPtr (
    LPVOID  pBuffer,
    LPVOID  pAligned,
    SIZE_T  cbSize,
    LPDWORD pcbNeeded
    );

VOID
UndoAlignKMPtr (
    LPVOID  pDestination,
    LPVOID  pSource
    );

LPVOID
AlignKMPtr (
    LPVOID  pBuffer,
    DWORD   cbBuf
    );

LPBYTE
PackStrings(
   LPWSTR *pSource,
   LPBYTE pDest,
   DWORD *DestOffsets,
   LPBYTE pEnd
   );

BOOL
IsNamedPipeRpcCall(
    VOID
    );

HRESULT
CheckLocalCall(
    VOID
    );

HKEY
GetClientUserHandle(
    IN REGSAM samDesired
    );

VOID
UpdatePrinterRegAll(
    LPWSTR pPrinterName,
    LPWSTR pszValue,
    BOOL   bGenerateNetId
    );

DWORD
UpdatePrinterRegUser(
    HKEY hKey,
    LPWSTR pszKey,
    LPWSTR pPrinterName,
    LPWSTR pszValue,
    BOOL   bGenerateNetId
    );

DWORD
GetNetworkId(
    HKEY hKeyUser,
    LPWSTR pDeviceName);

HANDLE
LoadDriverFiletoConvertDevmode(
    IN  LPWSTR      pDriverFile
    );

HANDLE
LoadDriver(
    LPWSTR      pDriverFile
    );

VOID
UnloadDriver(
    HANDLE      hModule
    );

VOID
UnloadDriverFile(
    IN OUT HANDLE    hDevModeChgInfo
    );

BOOL
SplIsUpgrade(
    VOID
    );

BOOL
SpoolerHasInitialized(
    VOID
    );

//
// DWORD used instead of NTSTATUS to prevent including NT headers.
//
VOID
SplLogEventExternal(
    IN      WORD        EventType,
    IN      DWORD       EventID,
    IN      LPWSTR      pFirstString,
    ...
);

typedef
DWORD
(*PFN_QUERYREMOVE_CALLBACK)(
    LPVOID
    );

HANDLE
SplRegisterForDeviceEvents(
    HANDLE                      hDevice,
    LPVOID                      pData,
    PFN_QUERYREMOVE_CALLBACK    pfnQueryRemove
    );

BOOL
SplUnregisterForDeviceEvents(
    HANDLE  hNotify
    );

DWORD
CallDrvDevModeConversion(
    IN     HANDLE       pfnConvertDevMode,
    IN     LPWSTR       pszPrinterName,
    IN     LPBYTE       pInDevMode,
    IN OUT LPBYTE      *pOutDevMode,
    IN OUT LPDWORD      pdwOutDevModeSize,
    IN     DWORD        dwConvertMode,
    IN     BOOL         bAlloc
    );

typedef struct _pfnWinSpoolDrv {
    BOOL    (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
    BOOL    (*pfnClosePrinter)(HANDLE);
    BOOL    (*pfnDevQueryPrint)(HANDLE, LPDEVMODE, DWORD *, LPWSTR, DWORD);
    BOOL    (*pfnPrinterEvent)(LPWSTR, INT, DWORD, LPARAM, DWORD *);
    LONG    (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);
    HANDLE  (*pfnLoadPrinterDriver)(HANDLE);
    HANDLE  (*pfnRefCntLoadDriver)(LPWSTR, DWORD, DWORD, BOOL);
    BOOL    (*pfnRefCntUnloadDriver)(HANDLE, BOOL);
    BOOL    (*pfnForceUnloadDriver)(LPWSTR);
}   fnWinSpoolDrv, *pfnWinSpoolDrv;


BOOL
SplInitializeWinSpoolDrv(
    pfnWinSpoolDrv   pfnList
    );

typedef enum 
{
    RpcEndPointPolicyUnconfigured = 0,
    RpcEndPointPolicyEnabled,
    RpcEndPointPolicyDisabled,

} ERemoteRPCEndPointPolicy;

//
// The following router export is used by the server process (spoolsv.exe) to
// expose entry points into the server side.
//
typedef struct
{
    HRESULT
    (*FnAllowRemoteCalls)(
        VOID
        );

    HRESULT
    (*FnGetServerPolicy) (
        PCWSTR,
        ULONG*
        );

} PrintSpoolerServerExports;

typedef struct
{
    HANDLE                          SpoolerStatusHandle;
    const PrintSpoolerServerExports *pExports;

}   RouterInitializationParams;

//
// This is used for router initialization.
//
BOOL
InitializeRouter(
    IN      RouterInitializationParams      *pRouterParams
    );


//
// These exports are exported from spoolss.dll but actually chain down to the
// server.
//
HRESULT
AllowRemoteCalls(
    VOID
    );

HRESULT
GetServerPolicy(
    IN  PCWSTR   pszPolicyName,
    IN  ULONG*   pValue
    );



#define AllocSplMem( cb )         DllAllocSplMem( cb )
#define FreeSplMem( pMem )        DllFreeSplMem( pMem )
#define FreeSplStr( lpStr )       DllFreeSplStr( lpStr )

// Spooler treats MAX_PATH as including NULL terminator

#define MAX_PRINTER_NAME    MAX_PATH

// Maximum size PrinterName ( including the ServerName ).
//  "\\MAX_COMPUTER_NAME_LENGTH\MAX_PRINTER_NAME" NULL Terminated
#define MAX_UNC_PRINTER_NAME    ( 2 + INTERNET_MAX_HOST_NAME_LENGTH + 1 + MAX_PRINTER_NAME )

// "\\MAX_PRINTER_NAME,DriverName,Location"
#define MAX_PRINTER_BROWSE_NAME ( MAX_UNC_PRINTER_NAME + 1 + MAX_PATH + 1 + MAX_PATH )

//
// Suffix string for hidden printers
// (e.g., ", Job 00322" or ", Port" or ", LocalOnly")
//
#define PRINTER_NAME_SUFFIX_MAX 20

#define NUMBER_OF_DRV_INFO_6_STRINGS 14

#define MAX_PRINTER_INFO1   ( (MAX_PRINTER_BROWSE_NAME + MAX_UNC_PRINTER_NAME + MAX_PATH) *sizeof(WCHAR) + sizeof( PRINTER_INFO_1) )
#define MAX_DRIVER_INFO_2   ( 5*MAX_PATH*sizeof(WCHAR) + sizeof( DRIVER_INFO_2 ) )
#define MAX_DRIVER_INFO_3   ( 8*MAX_PATH*sizeof(WCHAR) + sizeof( DRIVER_INFO_3 ) )
#define MAX_DRIVER_INFO_6   ( NUMBER_OF_DRV_INFO_6_STRINGS*MAX_PATH*sizeof(WCHAR) + sizeof( DRIVER_INFO_6 ) )
#define MAX_DRIVER_INFO_VERSION  ( NUMBER_OF_DRV_INFO_6_STRINGS*MAX_PATH*sizeof(DRIVER_FILE_INFO)*sizeof(WCHAR) + sizeof( DRIVER_INFO_VERSION ) )


// NT Server Spooler base priority
#define SPOOLSS_SERVER_BASE_PRIORITY        9
#define SPOOLSS_WORKSTATION_BASE_PRIORITY   7

#define MIN_DEVMODE_SIZEW 72
#define MIN_DEVMODE_SIZEA 40

//
// PrinterData value keys for the server handle
//
#define    SPLREG_W3SVCINSTALLED                      TEXT("W3SvcInstalled")


//
// If SPOOLER_REG_SYSTEM is not defined then setup moves the Printers data to
// HKLM\Software\Microsoft\Windows NT\CurrentVersion\Print\Printers during an
// upgrade or clean install. The spooler will then migrate the keys back to
// HKLM\System\CurrentControlSet\Control\Print\Printers when it starts up for
// the first time.
//
#define    SPOOLER_REG_SYSTEM


//
// Event logging constants
//

#define LOG_ERROR   EVENTLOG_ERROR_TYPE
#define LOG_WARNING EVENTLOG_WARNING_TYPE
#define LOG_INFO    EVENTLOG_INFORMATION_TYPE
#define LOG_SUCCESS EVENTLOG_AUDIT_SUCCESS
#define LOG_FAILURE EVENTLOG_AUDIT_FAILURE

#define LOG_ALL_EVENTS                  ( LOG_ERROR | LOG_WARNING | LOG_INFO | LOG_SUCCESS | LOG_FAILURE )
#define LOG_DEFAULTS_WORKSTATION_EVENTS ( LOG_ERROR | LOG_WARNING | LOG_SUCCESS | LOG_FAILURE )

typedef struct _DRIVER_INFO_7A {
    DWORD   cbSize;
    DWORD   cVersion;
    LPSTR   pszDriverName;
    LPSTR   pszInfName;
    LPSTR   pszInstallSourceRoot;
} DRIVER_INFO_7A, *PDRIVER_INFO_7A, *LPDRIVER_INFO_7A;
typedef struct _DRIVER_INFO_7W {
    DWORD   cbSize;
    DWORD   cVersion;
    LPWSTR  pszDriverName;
    LPWSTR  pszInfName;
    LPWSTR  pszInstallSourceRoot;
} DRIVER_INFO_7W, *PDRIVER_INFO_7W, *LPDRIVER_INFO_7W;
#ifdef UNICODE
typedef DRIVER_INFO_7W DRIVER_INFO_7;
typedef PDRIVER_INFO_7W PDRIVER_INFO_7;
typedef LPDRIVER_INFO_7W LPDRIVER_INFO_7;
#else
typedef DRIVER_INFO_7A DRIVER_INFO_7;
typedef PDRIVER_INFO_7A PDRIVER_INFO_7;
typedef LPDRIVER_INFO_7A LPDRIVER_INFO_7;
#endif // UNICODE

//
// The initial commit for the stack is 3 pages on IA64 and 4 pages on X86
//

//
// This reserves 32KB for in-proc server stack on x86 and 48KB for IA64.
//
#ifdef _IA64_
#define INITIAL_STACK_COMMIT (6 * 0x2000)
#else
#define INITIAL_STACK_COMMIT (8 * 0x1000)
#endif

#define LARGE_INITIAL_STACK_COMMIT (64 * 1024)

#ifdef __cplusplus
}
#endif

#endif  // for #ifndef _SPLCOM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inc\ntfyjob.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    ntfyjob.h

Abstract:

    List of fields supported for printer notifications (jobs).  These
    must match JOB_NOTIFY_FIELD_* in winspool.h (order included).

Author:

    Albert Ting (AlbertT) 29-Sept-94

Environment:

    User Mode -Win32

Revision History:

--*/

//      Name,                Attributes,           Router,                   Localspl,                 Offsets

DEFINE( PRINTER_NAME       , TABLE_ATTRIB_COMPACT                     , TABLE_STRING            , TABLE_JOB_PRINTERNAME   , pIniPrinter )
DEFINE( MACHINE_NAME       , TABLE_ATTRIB_COMPACT                     , TABLE_STRING            , TABLE_STRING            , pMachineName )
DEFINE( PORT_NAME          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_JOB_PORT          , pIniPort )
DEFINE( USER_NAME          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pUser )
DEFINE( NOTIFY_NAME        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pNotify )
DEFINE( DATATYPE           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pDatatype )
DEFINE( PRINT_PROCESSOR    , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_PRINTPROC         , pIniPrintProc )
DEFINE( PARAMETERS         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pParameters )
DEFINE( DRIVER_NAME        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_DRIVER            , pIniDriver )
DEFINE( DEVMODE            , TABLE_ATTRIB_COMPACT                     , TABLE_DEVMODE           , TABLE_DEVMODE           , pDevMode )
DEFINE( STATUS             , 0                   |TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_JOB_STATUS        , Status )
DEFINE( STATUS_STRING      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pStatus )
DEFINE( SECURITY_DESCRIPTOR, TABLE_ATTRIB_COMPACT                     , TABLE_SECURITYDESCRIPTOR, TABLE_SECURITYDESCRIPTOR, pSecurityDescriptor )
DEFINE( DOCUMENT           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pDocument )
DEFINE( PRIORITY           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , Priority )
DEFINE( POSITION           , 0                                        , TABLE_DWORD             , TABLE_JOB_POSITION      , signature )
DEFINE( SUBMITTED          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_TIME              , TABLE_TIME              , Submitted )
DEFINE( START_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , StartTime )
DEFINE( UNTIL_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , UntilTime )
DEFINE( TIME               , TABLE_ATTRIB_COMPACT                     , TABLE_DWORD             , TABLE_DWORD             , Time )
DEFINE( TOTAL_PAGES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , cPages )
DEFINE( PAGES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , cPagesPrinted )
DEFINE( TOTAL_BYTES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , Size )
DEFINE( BYTES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , cbPrinted )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inc\ntfyprn.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    ntfyprn.dat

Abstract:

    List of fields supported for printer notifications.  These
    must match PRINTER_NOTIFY_FIELD_* in winspool.h (order included).

Author:

    Albert Ting (AlbertT) 29-Sept-94

Environment:

    User Mode -Win32

Revision History:

--*/

//      Name,                Attributes,                                                     Router                    Localspl                  Offsets

DEFINE( SERVER_NAME        , TABLE_ATTRIB_COMPACT                                          , TABLE_STRING            , TABLE_PRINTER_SERVERNAME, signature )
DEFINE( PRINTER_NAME       , TABLE_ATTRIB_COMPACT                                          , TABLE_STRING            , TABLE_STRING            , pName )
DEFINE( SHARE_NAME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pShareName )
DEFINE( PORT_NAME          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_PRINTER_PORT      , signature )
DEFINE( DRIVER_NAME        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_DRIVER            , pIniDriver )
DEFINE( COMMENT            , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pComment )
DEFINE( LOCATION           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pLocation )
DEFINE( DEVMODE            , TABLE_ATTRIB_COMPACT                                          , TABLE_DEVMODE           , TABLE_DEVMODE           , pDevMode )
DEFINE( SEPFILE            , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pSepFile )
DEFINE( PRINT_PROCESSOR    , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_PRINTPROC         , pIniPrintProc )
DEFINE( PARAMETERS         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pParameters )
DEFINE( DATATYPE           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pDatatype )
DEFINE( SECURITY_DESCRIPTOR, TABLE_ATTRIB_COMPACT                                          , TABLE_SECURITYDESCRIPTOR, TABLE_SECURITYDESCRIPTOR, pSecurityDescriptor )
DEFINE( ATTRIBUTES         , 0                                                             , TABLE_DWORD             , TABLE_DWORD             , Attributes )
DEFINE( PRIORITY           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , Priority )
DEFINE( DEFAULT_PRIORITY   , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , DefaultPriority )
DEFINE( START_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , StartTime )
DEFINE( UNTIL_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , UntilTime )
DEFINE( STATUS             , 0                   |TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_PRINTER_STATUS    , signature )
DEFINE( STATUS_STRING      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_NULLSTRING        , signature )
DEFINE( CJOBS              , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , cJobs )
DEFINE( AVERAGE_PPM        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , AveragePPM )
DEFINE( TOTAL_PAGES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_ZERO              , signature )
DEFINE( PAGES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , cTotalPagesPrinted )
DEFINE( TOTAL_BYTES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_ZERO              , signature )
DEFINE( BYTES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , cTotalBytes )
DEFINE( OBJECT_GUID        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pszObjectGUID )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\configdlg.h ===
#ifndef _CCONFIGDLG_H
#define _CCONFIGDLG_H

#include "inetxcv.h"
#include "xcvdlg.h"

class TConfigDlg: public TXcvDlg {

public:
    TConfigDlg (
        LPCTSTR pServerName,
        HWND hWnd,
        LPCTSTR pszPortName);

    virtual ~TConfigDlg (void);

    virtual BOOL 
    PromptDialog (
        HINSTANCE hInst);

private:
    enum {
        DLG_OK, DLG_CANCEL,  DLG_ERROR
    } DLGRTCODE;

    static INT_PTR CALLBACK 
    DialogProc (
        HWND hDlg,        // handle to dialog box
        UINT message,     // message
        WPARAM wParam,    // first message parameter
        LPARAM lParam);     // second message parameter

    VOID 
    DialogOnInit (
        HWND hDlg);

    VOID 
    DialogOnOK (
        HWND hDlg);

    static INT_PTR CALLBACK 
    AuthDialogProc (
        HWND hDlg,        // handle to dialog box
        UINT message,     // message
        WPARAM wParam,    // first message parameter
        LPARAM lParam);     // second message parameter

    VOID 
    AuthDialogOnInit (
        HWND hDlg);

    VOID 
    AuthDialogOnOK (
        HWND hDlg);

    VOID
    AuthDialogOnCancel (
        HWND hDlg);

    
    BOOL 
    SetConfiguration (VOID);

    BOOL 
    GetConfiguration (VOID);

    static void 
    EnableUserNamePassword (
        HWND hDLg,
        BOOL bEnable);

    INET_XCV_CONFIGURATION m_ConfigurationData;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\deletedlg.cpp ===
/*****************************************************************************\
* MODULE: configdlg.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   07/31/98 WeihaiC    Created
*   04/10/00 WeihaiC    Moved it to client side
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

TDeletePortDlg::TDeletePortDlg (
    LPCWSTR pServerName,
    HWND hWnd,
    LPCWSTR pszPortName):
    TXcvDlg (pServerName, hWnd, pszPortName)
{
    if (m_bAdmin) {
        m_bValid  = TRUE;
    }
    else {
        m_dwLE = ERROR_ACCESS_DENIED;
        m_bValid = FALSE;
    }

}

TDeletePortDlg::~TDeletePortDlg ()
{
}

BOOL 
TDeletePortDlg::GetString (
    LPWSTR lpszBuf, 
    DWORD dwSize,
    UINT iStringID)
{
    return LoadString(m_hInst, iStringID, lpszBuf, dwSize);
}

BOOL 
TDeletePortDlg::PromptDialog (
    HINSTANCE hInst)
    
{
    BOOL bRet = TRUE;


    m_hInst = hInst;
    if (!DoDeletePort ()) {

        DisplayLastError (m_hWnd, IDS_DELETE_PORT);
        
        //
        // The call actually failed. Since we already displayed the error message
        // we need to disable the popup from printui.
        //
        m_dwLE = ERROR_CANCELLED;
        bRet = FALSE;

    }

    return bRet;

}

BOOL
TDeletePortDlg::DoDeletePort ()
{
    DWORD dwStatus;
    BOOL bRet = FALSE;
    DWORD dwNeeded;
     
    if (XcvData (m_hXcvPort, 
                 INET_XCV_DELETE_PORT, 
                 (PBYTE) m_pszPortName,
                 sizeof (WCHAR) * (lstrlen (m_pszPortName) + 1),
                 NULL, 
                 0,
                 &dwNeeded,
                 &dwStatus)) {
         
        if (dwStatus == ERROR_SUCCESS) {
            // The port has been deleted.
            bRet = TRUE;
        }
        else
            SetLastError (dwStatus);
    }
    else
        // 
        // The server might be running an old version of inetpp which does not support XcvData
        // We need to fail the call
        //
        SetLastError (ERROR_NOT_SUPPORTED);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\deletedlg.h ===
#ifndef _CDELETEDLG_H
#define _CDELETEDLG_H

#include "inetxcv.h"
#include "xcvdlg.h"

class TDeletePortDlg: public TXcvDlg {

public:
    TDeletePortDlg (
        LPCTSTR pServerName,
        HWND hWnd,
        LPCTSTR pszPortName);

    ~TDeletePortDlg (void);

    virtual BOOL 
    PromptDialog (
        HINSTANCE hInst);

private:

    BOOL 
    GetString (
        LPWSTR lpszBuf, 
        DWORD dwSize,
        UINT iStringID);

    
    BOOL
    DoDeletePort ();

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\configdlg.cpp ===
/*****************************************************************************\
* MODULE: configdlg.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   07/31/98 WeihaiC    Created
*   04/10/00 WeihaiC    Moved it to client side
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


TConfigDlg::TConfigDlg (
    LPCWSTR pServerName,
    HWND hWnd,
    LPCWSTR pszPortName):
    TXcvDlg (pServerName, hWnd, pszPortName)
{
}

TConfigDlg::~TConfigDlg ()
{
}

VOID
TConfigDlg::EnableUserNamePassword (
    HWND hDlg,
    BOOL bEnable)
{
    EnableWindow( GetDlgItem( hDlg, IDC_USER_NAME ), bEnable );
    EnableWindow( GetDlgItem( hDlg, IDC_PASSWORD ), bEnable );
}



VOID
TConfigDlg::DialogOnInit (
    HWND hDlg)
{
    int nIDButton;

    SetDlgItemText (hDlg, IDC_PORT_NAME, (LPTSTR) m_pszPortName);

    switch (m_ConfigurationData.dwAuthMethod) {
    case AUTH_NT:
        nIDButton = IDC_IMPERSONATION;
        break;

    case AUTH_OTHER:
        nIDButton = IDC_SPECFIEDUSER;
        break;

    case AUTH_ANONYMOUS:
        nIDButton = IDC_ANONYMOUS;
        break;

    }

    CheckDlgButton (hDlg, nIDButton, BST_CHECKED);
    EnableUserNamePassword (hDlg, m_ConfigurationData.dwAuthMethod == AUTH_OTHER);

    if (m_ConfigurationData.szUserName[0]) {

        SetDlgItemText (hDlg, IDC_USER_NAME, (LPTSTR) m_ConfigurationData.szUserName);
        SetDlgItemText (hDlg, IDC_PASSWORD, (LPTSTR) TEXT ("***********"));
    }

    SetWindowLongPtr (hDlg, GWLP_USERDATA, (UINT_PTR) this);

    // Disable all user settings for non admins
    EnableWindow( GetDlgItem( hDlg, IDC_CHECK_ALL_USER ), m_bAdmin );

}

VOID
TConfigDlg::DialogOnOK (
    HWND hDlg)
{
    WCHAR szBuffer [MAX_USERNAME_LEN];
    DWORD dwRet = DLG_ERROR;
    BOOL    bChecked;

    if (IsDlgButtonChecked (hDlg, IDC_ANONYMOUS)) {
        m_ConfigurationData.dwAuthMethod = AUTH_ANONYMOUS;
    }
    else if (IsDlgButtonChecked (hDlg, IDC_SPECFIEDUSER)) {
        m_ConfigurationData.dwAuthMethod = AUTH_OTHER;
    }
    else
        m_ConfigurationData.dwAuthMethod = AUTH_NT;

    if (m_ConfigurationData.dwAuthMethod == AUTH_OTHER) {

        GetDlgItemText (hDlg, IDC_USER_NAME, m_ConfigurationData.szUserName, MAX_USERNAME_LEN);

        if (SendMessage (GetDlgItem (hDlg, IDC_PASSWORD), EM_GETMODIFY, 0, 0)) {

            m_ConfigurationData.bPasswordChanged = TRUE;
            GetDlgItemText (hDlg, IDC_PASSWORD, m_ConfigurationData.szPassword , MAX_PASSWORD_LEN);
        }
    }

    if (m_bAdmin && IsDlgButtonChecked (hDlg,IDC_CHECK_ALL_USER ))
        m_ConfigurationData.bSettingForAll = TRUE;
    else
        m_ConfigurationData.bSettingForAll = FALSE;

    dwRet = DLG_OK;

    DBGMSG (DBG_TRACE, ("Call: TConfigDlg::DialogOnOK (%d, User:%ws Password:%ws)\n",
                        m_ConfigurationData.dwAuthMethod,
                        m_ConfigurationData.szUserName,
                        m_ConfigurationData.szPassword));

    if (!SetConfiguration ()) {
        DisplayLastError (m_hWnd, IDS_CONFIG_ERR);
    }
    else
        EndDialog (hDlg, dwRet);
}


INT_PTR CALLBACK
TConfigDlg::DialogProc(
    HWND hDlg,        // handle to dialog box
    UINT message,     // message
    WPARAM wParam,    // first message parameter
    LPARAM lParam     // second message parameter
    )
{
    BOOL bRet = FALSE;
    TConfigDlg *pConfigInfo = NULL;

    switch (message) {
    case WM_INITDIALOG:
        if (pConfigInfo = (TConfigDlg *)lParam)
            pConfigInfo->DialogOnInit(hDlg);

        bRet =  TRUE;
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            if (pConfigInfo = (TConfigDlg *) GetWindowLongPtr (hDlg, GWLP_USERDATA))
                pConfigInfo->DialogOnOK (hDlg);
            bRet = TRUE;
            break;

        case IDCANCEL:
            EndDialog (hDlg, DLG_CANCEL);
            bRet = TRUE;
            break;

        case IDC_IMPERSONATION:
        case IDC_ANONYMOUS:
            EnableUserNamePassword (hDlg, FALSE);
            bRet = TRUE;
            break;

        case IDC_SPECFIEDUSER:
            EnableUserNamePassword (hDlg, TRUE);
            bRet = TRUE;
            break;

        }
        break;
    }
    return bRet;
}


BOOL
TConfigDlg::PromptDialog (
    HINSTANCE hInst)
{
    INT_PTR     iResult;
    BOOL bRet = FALSE;;

    m_hInst = hInst;

    if (GetConfiguration ()) {

        if (m_ConfigurationData.dwAuthMethod == AUTH_ACCESS_DENIED) {

            iResult = DialogBoxParam( hInst,
                                      TEXT("AuthDlg"),
                                      m_hWnd,
                                      TConfigDlg::AuthDialogProc,
                                      (LPARAM) this );

            if (iResult == DLG_CANCEL) {
                m_dwLE = ERROR_ACCESS_DENIED;
            }
            else
                bRet = iResult == DLG_OK;

        }
        else {

            iResult = DialogBoxParam( hInst,
                                      TEXT("IDD_CONFIGURE_DLG"),
                                      m_hWnd,
                                      TConfigDlg::DialogProc,
                                      (LPARAM) this );

            if (iResult == DLG_CANCEL) {
                m_dwLE = ERROR_CANCELLED;
            }
            else
                bRet =   (iResult == DLG_OK);
        }
    }
    else {
        DisplayLastError (m_hWnd, IDS_CONFIG_ERR);
        bRet = TRUE;
    }

    return bRet;
}

BOOL
TConfigDlg::SetConfiguration ()
{
    INET_CONFIGUREPORT_RESPDATA RespData;
    DWORD dwStatus;
    DWORD dwNeeded;
    BOOL bRet = FALSE;
    PBYTE pEncryptedData;
    DWORD dwSize;

    if (EncryptData ((PBYTE) &m_ConfigurationData,
                     sizeof (INET_XCV_CONFIGURATION),
                     (PBYTE *) &pEncryptedData,
                     &dwSize)) {

        if (XcvData (m_hXcvPort,
                     INET_XCV_SET_CONFIGURATION,
                     pEncryptedData,
                     dwSize,
                     (PBYTE) &RespData,
                     sizeof (INET_CONFIGUREPORT_RESPDATA),
                     &dwNeeded,
                     &dwStatus)) {
            if (dwStatus == ERROR_SUCCESS) {
                bRet = TRUE;
            }
            else
                SetLastError (dwStatus);
        }
        else {
            //
            // The server might be running an old version of inetpp which does not support XcvData
            // We need to fail the call
            //
        }

        LocalFree (pEncryptedData);
    }

    return bRet;
}

BOOL
TConfigDlg::GetConfiguration ()
{
    static CONST WCHAR cszGetConfigration[] = INET_XCV_GET_CONFIGURATION;
    INET_XCV_GETCONFIGURATION_REQ_DATA ReqData;
    DWORD       dwStatus;
    BOOL        bRet                = FALSE;
    DWORD       dwNeeded;
    PBYTE       pEncryptedData      = NULL;
    PBYTE       pConfigData         = NULL;
    DWORD       cbConfigData;

    ReqData.dwVersion = 1;

    if (XcvData (m_hXcvPort,
                 cszGetConfigration,
                 (PBYTE) &ReqData,
                 sizeof (ReqData),
                 NULL,
                 0,
                 &dwNeeded,
                 &dwStatus)) {

        if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {

            // Allocate a buffer
            pEncryptedData = new BYTE[dwNeeded];

            if (pEncryptedData) {

                if (XcvData (m_hXcvPort,
                             cszGetConfigration,
                             (PBYTE) &ReqData,
                             sizeof (ReqData),
                             pEncryptedData,
                             dwNeeded,
                             &dwNeeded,
                             &dwStatus) && dwStatus == ERROR_SUCCESS) {
                    //
                    // Great! We've got the encypted configuration data
                    //

                    if (DecryptData (pEncryptedData, dwNeeded, &pConfigData, &cbConfigData)) {

                        if (cbConfigData == sizeof (m_ConfigurationData)) {

                            CopyMemory (&m_ConfigurationData, pConfigData, cbConfigData);
                            bRet = TRUE;

                        }
                        else
                            SetLastError (ERROR_INVALID_PARAMETER);

                        LocalFree (pConfigData);

                    }
                }
                else {
                    SetLastError (ERROR_INVALID_PARAMETER);
                }

                delete [] pEncryptedData;

            }
        }
        else
            SetLastError (dwStatus);

    }
    else
        //
        // The server might be running an old version of inetpp which does not support XcvData
        // We need to fail the call
        //
        SetLastError (ERROR_NOT_SUPPORTED);


    return bRet;
}


VOID
TConfigDlg::AuthDialogOnInit (HWND hDlg)
{
    SetDlgItemText (hDlg, IDC_PORT_NAME, (LPTSTR) m_pszPortName);

    SetWindowLongPtr (hDlg, GWLP_USERDATA, (UINT_PTR) this);
}

VOID
TConfigDlg::AuthDialogOnOK (HWND hDlg)
{
    m_ConfigurationData.dwAuthMethod = AUTH_OTHER;
    GetDlgItemText (hDlg, IDC_USER_NAME, m_ConfigurationData.szUserName, MAX_USERNAME_LEN);

    if (SendMessage (GetDlgItem (hDlg, IDC_PASSWORD), EM_GETMODIFY, 0, 0)) {
        m_ConfigurationData.bPasswordChanged = TRUE;
        GetDlgItemText (hDlg, IDC_PASSWORD, m_ConfigurationData.szPassword , MAX_PASSWORD_LEN);
    }

    DBGMSG (DBG_TRACE, ("Call: TConfigDlg::DialogOnOK (%d, User:%ws Password:%ws)\n",
                        m_ConfigurationData.dwAuthMethod,
                        m_ConfigurationData.szUserName,
                        m_ConfigurationData.szPassword));


    if (SetConfiguration ()) {
        EndDialog (hDlg, DLG_OK);
    }
    else {
        DisplayLastError (m_hWnd, IDS_AUTH_ERROR);
    }
}

VOID
TConfigDlg::AuthDialogOnCancel (HWND hDlg)
{
    SetLastError (ERROR_ACCESS_DENIED);

    EndDialog (hDlg, DLG_CANCEL);
}

INT_PTR CALLBACK
TConfigDlg::AuthDialogProc(
    HWND hDlg,        // handle to dialog box
    UINT message,     // message
    WPARAM wParam,    // first message parameter
    LPARAM lParam     // second message parameter
    )
{
    TConfigDlg *pAuthInfo = NULL;

    switch (message) {
    case WM_INITDIALOG:
        if (pAuthInfo = (TConfigDlg *)lParam)
            pAuthInfo->AuthDialogOnInit(hDlg);

        return TRUE;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            if (pAuthInfo = (TConfigDlg *) GetWindowLongPtr (hDlg, GWLP_USERDATA))
                pAuthInfo->AuthDialogOnOK (hDlg);
            return TRUE;

        case IDCANCEL:
            if (pAuthInfo = (TConfigDlg *) GetWindowLongPtr (hDlg, GWLP_USERDATA))
                pAuthInfo->AuthDialogOnCancel (hDlg);

            return TRUE;

        default:
            break;
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\precomp.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header file.

    Only place relatively static header files in here.

Environment:

    User Mode -Win32

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <stddef.h>
#include <strsafe.h>
#include <wininet.h>
#include <commctrl.h>

#include <splcom.h>
#include <inetlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\inetppui.cpp ===
/*****************************************************************************\
* MODULE: inetppui.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   03/31/00  WeihaiC     Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

HINSTANCE ghInst = NULL;

#ifndef MODULE

#define MODULE "INETPPUI: "

#endif


#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING |DBG_TRACE| DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

#endif



BOOL
AddPortUI(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszMonitorNameIn,
    PWSTR  *ppszPortNameOut
)
{

    BOOL bRet = FALSE;

    DBGMSG (DBG_TRACE, ("Enter AddPortUI\n"));

    SetLastError (ERROR_NOT_SUPPORTED);

    DBGMSG (DBG_TRACE, ("Leave AddPortUI (Ret=%d)\n", bRet));

    return bRet;
}


BOOL
DeletePortUI(
    PCWSTR pServerName,
    HWND   hWnd,
    PCWSTR pPortName
)
{
    BOOL bRet = FALSE;
    DWORD dwLE;

    DBGMSG (DBG_TRACE, ("Enter DeletePortUI\n"));

    {
        TDeletePortDlg Dlg  (pServerName, hWnd, pPortName);

        if (Dlg.bValid()) {
            bRet = Dlg.PromptDialog(ghInst);

            if (!bRet) {
                dwLE = Dlg.dwLastError ();
            }
        }
        else {
            TXcvDlg::DisplayErrorMsg (ghInst, hWnd, IDS_DELETE_PORT, ERROR_DEVICE_REINITIALIZATION_NEEDED);
            bRet = TRUE;
        }
    }

    if (!bRet) {
        SetLastError (dwLE);
    }

    DBGMSG (DBG_TRACE, ("Leave DeletePortUI (Ret=%d)\n", bRet));

    return bRet;
}

BOOL
ConfigurePortUI(
    PCWSTR pServerName,
    HWND   hWnd,
    PCWSTR pPortName
)
{

    DBGMSG (DBG_TRACE, ("Enter ConfigurePortUI\n"));


    BOOL bRet = FALSE;
    DWORD dwLE;

    {
        TConfigDlg Dlg  (pServerName, hWnd, pPortName);

        if (Dlg.bValid()) {
            bRet = Dlg.PromptDialog(ghInst);

            if (!bRet) {
                dwLE = Dlg.dwLastError ();
            }
        }
        else {
            TXcvDlg::DisplayErrorMsg (ghInst, hWnd, IDS_CONFIG_ERR, ERROR_DEVICE_REINITIALIZATION_NEEDED);
            bRet = TRUE;
        }
    }

    if (!bRet) {
        SetLastError (dwLE);
    }

    DBGMSG (DBG_TRACE, ("Leave ConfigurePortUI (Ret=%d)\n", bRet));

    return bRet;
}


//
// Common string definitions
//



DWORD LocalMonDebug;

MONITORUI MonitorUI =
{
    sizeof(MONITORUI),
    AddPortUI,
    ConfigurePortUI,
    DeletePortUI
};

extern "C" {

BOOL    WINAPI
DllMain (
    HINSTANCE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    INITCOMMONCONTROLSEX icc;

    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        ghInst = hModule;

        //
        // Initialize the common controls, needed for fusion applications
        // because standard controls were moved to comctl32.dll
        //
        InitCommonControls();

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_STANDARD_CLASSES;
        InitCommonControlsEx(&icc);

        return TRUE;

    case DLL_PROCESS_DETACH:
        return TRUE;
    }

    UNREFERENCED_PARAMETER( lpRes );
    return TRUE;
}
}



PMONITORUI
InitializePrintMonitorUI(
    VOID
)
{
    return &MonitorUI;
}


/*****************************************************************************\
*
* These function are for linking with spllib.
*
\*****************************************************************************/
EXTERN_C
LPVOID
DllAllocSplMem(
    DWORD cb
    )
{
    return LocalAlloc(LPTR, cb);
}

EXTERN_C
BOOL
DllFreeSplMem(
   LPVOID pMem
   )
{
    LocalFree(pMem);

    return TRUE;
}


EXTERN_C
BOOL
DllFreeSplStr(
   LPWSTR lpStr
   )
{
    LocalFree(lpStr);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by localui.rc
//
#define DLG_PORTNAME                200
#define IDD_PN_PB_HELP              201
#define IDD_PN_EF_PORTNAME          202

#define DLG_CONFIGURE_LPT           300
#define IDD_CL_EF_TRANSMISSIONRETRY 303
#define IDD_CF_PB_HELP              304


#define IDC_USER_NAME               1000
#define IDC_PASSWORD                1002
#define IDC_EDIT4                   1006
#define IDC_ANONYMOUS               1008
#define IDC_IMPERSONATION           1009
#define IDC_SPECFIEDUSER            1011
#define IDC_CHECK_ALL_USER          1012
#define IDC_PORT_NAME               1013
#define IDS_DELETE_PORT             1014
#define IDS_CONFIG_ERR              1015
#define IDS_ACCESS_DENIED           1016
#define IDS_AUTH_ERROR              1017
#define IDS_INVALID_PRINTER_NAME    1018
#define IDS_INVALID_SETTING         1019
#define IDS_NETWORK_TIMEOUT         1020
#define IDS_INITIALIZATION_ERROR    1021
#define IDS_PORT_DELETED            1022
#define IDC_STATIC                  -1

#define IDI_SECURITY                1101
#define IDI_PRINTER                   1102

#define IDC_DIVIDER5                3573

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        306
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           305
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\xcvdlg.cpp ===
/*****************************************************************************\
* MODULE: configdlg.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   07/31/98 WeihaiC    Created
*   04/10/00 WeihaiC    Moved it to client side
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


TXcvDlg::TXcvDlg (
    LPCWSTR pServerName,
    HWND hWnd,
    LPCWSTR pszPortName):
    m_pServerName (pServerName),
    m_hWnd (hWnd),
    m_pszPortName (pszPortName),
    m_pXcvName (NULL),
    m_hXcvPort (NULL),
    m_bAdmin (FALSE),
    m_hInst (NULL),
    m_dwLE (ERROR_SUCCESS),
    m_bValid (FALSE)
{
    DWORD cbNeeded, dwStatus;
    PRINTER_DEFAULTS pd = {NULL, NULL,  SERVER_ALL_ACCESS};
    HANDLE hServer;
    BOOL bRet = FALSE;

    if (OpenPrinter (NULL, &hServer, &pd)) {
        ClosePrinter (hServer);
        m_bAdmin = TRUE;
    }

    if (m_pXcvName = ConstructXcvName (m_pServerName,  m_pszPortName, L"XcvPort")) {

        if (OpenPrinter (m_pXcvName, &m_hXcvPort, NULL)) {
            m_bValid = TRUE;
        }
    }

}

TXcvDlg::~TXcvDlg ()
{
    if (m_pXcvName) {
        FreeSplMem(m_pXcvName);
    }
    if (m_hXcvPort) {
        ClosePrinter (m_hXcvPort);
    }
}


PWSTR
TXcvDlg::ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
)
{
    DWORD   dwRet   = ERROR_SUCCESS;
    PCWSTR  pOut    = NULL;

    //
    // The returned xcv name can be of two basic forms.  The first
    // form is were the server name is non null and the other is
    // if the server name is null or a null string.
    //
    // Example 1
    //
    //  pServerName = NULL;
    //  pObjectName = IP_1.2.3.4
    //  pObjectType = XcvPort
    //
    // Returned String
    //
    //  ,XcvPort IP_1.2.3.4
    //
    // Example 2
    //
    //  pServerName = \\Server1
    //  pObjectName = IP_1.2.3.4
    //  pObjectType = XcvPort
    //
    // Returned String
    //
    //  \\Server1\,XcvPort IP_1.2.3.4
    //
    dwRet = StrCatAlloc(&pOut,
                        (pServerName && *pServerName) ? pServerName : L"",
                        (pServerName && *pServerName) ? L"\\" : L"",
                        L",",
                        pObjectType,
                        L" ",
                        pObjectName,
                        NULL);

    //
    // Use the return value not the out pointer.
    //
    return dwRet == ERROR_SUCCESS ? (PWSTR)pOut : NULL;
}

VOID
TXcvDlg::DisplayLastError (
    HWND hWnd,
    UINT iTitle)
{
    DisplayErrorMsg (m_hInst, hWnd, iTitle, GetLastError ());
}

VOID
TXcvDlg::DisplayErrorMsg (
    HINSTANCE hInst,
    HWND hWnd,
    UINT iTitle,
    DWORD dwLE)
{

    TCHAR szBuf[MAX_BUF_SIZE];
    TCHAR szMsgBuf[MAX_BUF_SIZE];
    UINT iMsg;
    LPTSTR lpMsgBuf = NULL;
    BOOL bFound = TRUE;

    switch (dwLE) {
    case ERROR_ACCESS_DENIED:
        iMsg = IDS_ACCESS_DENIED;
        break;

    case ERROR_INVALID_NAME:
    case ERROR_INVALID_PRINTER_NAME:
        iMsg = IDS_INVALID_PRINTER_NAME;
        break;

    case ERROR_INTERNET_TIMEOUT:
        iMsg = IDS_NETWORK_TIMEOUT;
        break;

    case ERROR_DEVICE_REINITIALIZATION_NEEDED:
        iMsg = IDS_INITIALIZATION_ERROR;
        break;

    case ERROR_NOT_FOUND:
        iMsg = IDS_PORT_DELETED;
        break;

    default:
        bFound = FALSE;
        break;
    }

    if (LoadString (hInst, iTitle, szBuf, MAX_BUF_SIZE)) {
        if (bFound) {
            if (LoadString (hInst, iMsg, szMsgBuf, MAX_BUF_SIZE))
                MessageBox( hWnd, szMsgBuf, szBuf, MB_OK | MB_ICONERROR);
        }
        else {
            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_SYSTEM |
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          GetLastError(),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL) && lpMsgBuf) {
                MessageBox( hWnd, (LPCTSTR)lpMsgBuf, szBuf, MB_OK | MB_ICONERROR );

                // Free the buffer.
                LocalFree( lpMsgBuf );
            }
            else {
                //
                // Most likely it is because we've got an error code from wininet, where
                // we can not locate the resource file
                //
                if (LoadString (hInst, IDS_INVALID_SETTING, szMsgBuf, MAX_BUF_SIZE))
                    MessageBox( hWnd, szMsgBuf, szBuf, MB_OK | MB_ICONERROR);

            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\priv.h ===
/*****************************************************************************\
* MODULE: priv.h
*
* Private header for the Internet Print Provider Client
*
*
* Copyright (C) 2000 Microsoft
*
* History:
*   5/12/2000   weihaic     Created
*
\*****************************************************************************/

#include "common.h"
#include "inetxcv.h"

#include "resource.h"
#include "xcvdlg.h"
#include "configdlg.h"
#include "deletedlg.h"

#define MAX_BUF_SIZE 256
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\inc\inetlib.h ===
#include "..\lib\encrypt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\clientui\xcvdlg.h ===
#ifndef _XCVDLG_H
#define _XCVDLG_H

#include "inetxcv.h"

class TXcvDlg {

public:
    TXcvDlg (
        LPCTSTR pServerName,
        HWND hWnd,
        LPCTSTR pszPortName);

    virtual ~TXcvDlg (void);

    inline BOOL
    bValid(VOID) CONST {
        return m_bValid;
    }

    inline DWORD
    dwLastError (VOID) CONST {
        return m_dwLE;
    }
    virtual BOOL
    PromptDialog (
        HINSTANCE   hInst) = 0;

    static VOID
    DisplayErrorMsg (
        HINSTANCE   hInst,
        HWND        hWnd,
        UINT        iTitle,
        DWORD       dwLE);

protected:

    PWSTR
    ConstructXcvName(
        PCWSTR  pServerName,
        PCWSTR  pObjectName,
        PCWSTR  pObjectType);

    VOID
    DisplayLastError (
        HWND    hWnd,
        UINT    iTitle);

private:
    enum {
        DLG_OK, DLG_CANCEL,  DLG_ERROR
    } DLGRTCODE;

protected:
    LPCTSTR     m_pszPortName;
    BOOL        m_bValid;
    HWND        m_hWnd;
    LPTSTR      m_pXcvName;
    HANDLE      m_hXcvPort;
    LPCTSTR     m_pServerName;
    BOOL        m_bAdmin;
    HINSTANCE   m_hInst;
    DWORD       m_dwLE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\inc\common.h ===
/*****************************************************************************\
* MODULE: inetpp.h
*
* Header file for the INETPP provider routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _INETPP_COMMON_H
#define _INETPP_COMMON_H


// Max length for  username & password
//
#define MAX_USERNAME_LEN 256
#define MAX_PASSWORD_LEN 256
#define MAX_PORTNAME_LEN 512

#define AUTH_ANONYMOUS  0
#define AUTH_BASIC      1
#define AUTH_NT         2
#define AUTH_IE         3
#define AUTH_OTHER      4
#define AUTH_ACCESS_DENIED 0x100
#define AUTH_UNKNOWN    0xffff

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\inc\inetxcv.h ===
#ifndef _INET_XCV_H
#define _INET_XCV_H


typedef struct INET_CONFIGUREPORT_RESPDATA {
    DWORD dwVersion;
    DWORD dwError;
    DWORD dwErrorStringLen;
    WCHAR dwErrorString[1];
} INET_CONFIGUREPORT_RESPDATA;
typedef INET_CONFIGUREPORT_RESPDATA *PINET_CONFIGUREPORT_RESPDATA;

typedef struct INET_XCV_GETCONFIGURATION_REQ_DATA {
    DWORD dwVersion;
} INET_XCV_GETCONFIGURATION_REQ_DATA;
typedef INET_XCV_GETCONFIGURATION_REQ_DATA *PINET_XCV_GETCONFIGURATION_REQ_DATA;

typedef struct INET_XCV_CONFIGURATION {
    DWORD dwVersion;
    DWORD dwAuthMethod;
    WCHAR szUserName[MAX_USERNAME_LEN];
    WCHAR szPassword[MAX_PASSWORD_LEN];
    BOOL  bIgnoreSecurityDlg;
    BOOL  bSettingForAll;
    BOOL  bPasswordChanged;
} INET_XCV_CONFIGURATION;
typedef INET_XCV_CONFIGURATION *PINET_XCV_CONFIGURATION;

#define INET_XCV_SET_CONFIGURATION  L"SetConfiguration"
#define INET_XCV_GET_CONFIGURATION  L"GetConfiguration"
#define INET_XCV_DELETE_PORT        L"DeletePort"
#define INET_XCV_ADD_PORT           L"AddPort"

#define MAX_INET_XCV_NAME_LEN 256

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\lib\encrypt.cpp ===
/*****************************************************************************\
* MODULE: encrypt.cxx
*
* The module contains routines for encryption and decryption of data
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   05/19/00 WeihaiC    Created
*
\*****************************************************************************/

#include "precomp.h"

//
// The caller needs to call LocalFree to free the output data
//

BOOL
EncryptData (
    PBYTE pDataInput,
    DWORD cbDataInput,
    PBYTE *ppDataOutput,
    PDWORD pcbDataOutput)
{
    BOOL bRet = FALSE;
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;

    DataIn.pbData = pDataInput;
    DataIn.cbData = cbDataInput;
    ZeroMemory (&DataOut, sizeof (DATA_BLOB));

    if(CryptProtectData(&DataIn,
                        L"Encrypt",                 // A description sting.
                        NULL,                       // Optional entropy not used.
                        NULL,                       // Reserved.
                        NULL,                       // Do not pass a PromptStruct.
                        CRYPTPROTECT_UI_FORBIDDEN,  // Never show UI
                        &DataOut)) {

        bRet = TRUE;
        *ppDataOutput = DataOut.pbData;
        *pcbDataOutput = DataOut.cbData;
    }
    return bRet;
}

BOOL
DecryptData (
    PBYTE pDataInput,
    DWORD cbDataInput,
    PBYTE *ppDataOutput,
    PDWORD pcbDataOutput)
{
    BOOL bRet = FALSE;
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;
    LPWSTR pDataDesp;

    DataIn.pbData = pDataInput;
    DataIn.cbData = cbDataInput;
    ZeroMemory (&DataOut, sizeof (DATA_BLOB));

    if(CryptUnprotectData(&DataIn,
                          &pDataDesp,                   // A description sting.
                          NULL,                         // Optional entropy not used.
                          NULL,                         // Reserved.
                          NULL,                         // Do not pass a PromptStruct.
                          CRYPTPROTECT_UI_FORBIDDEN,    // Never show UI
                          &DataOut)) {

        bRet = TRUE;
        *ppDataOutput = DataOut.pbData;
        *pcbDataOutput = DataOut.cbData;
        LocalFree (pDataDesp);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\lib\encrypt.h ===
#ifndef _ENCRYPT_H
#define _ENCRYPT_H

BOOL
EncryptData (
    PBYTE pDataInput, 
    DWORD cbDataInput, 
    PBYTE *ppDataOutput, 
    PDWORD pcbDataOutput);

BOOL
DecryptData (
    PBYTE pDataInput, 
    DWORD cbDataInput, 
    PBYTE *ppDataOutput, 
    PDWORD pcbDataOutput);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\lib\precomp.h ===
#include <windows.h>
#include <wincrypt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\basicsec.h ===
/*****************************************************************************\
* MODULE: basicsec.h
*
* Header file for basic-security.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   24-Aug-1997 HWP-Guys    Created.
*
\*****************************************************************************/

#ifdef NOT_IMPLEMENTED

DWORD AuthenticateUser(
    LPVOID *lppvContext,
    LPTSTR lpszServerName,
    LPTSTR lpszScheme,
    DWORD  dwFlags,
    LPSTR  lpszInBuffer,
    DWORD  dwInBufferLength,
    LPTSTR lpszUserName,
    LPTSTR lpszPassword);

VOID UnloadAuthenticateUser(
    LPVOID *lppvContext,
    LPTSTR lpszServer,
    LPTSTR lpszScheme);

DWORD PreAuthenticateUser(
    LPVOID  *lppvContext,
    LPTSTR  lpszServerName,
    LPTSTR  lpszScheme,
    DWORD   dwFlags,
    LPSTR   lpszInBuffer,
    DWORD   dwInBufferLength,
    LPSTR   lpszOutBuffer,
    LPDWORD lpdwOutBufferLength,
    LPTSTR  lpszUserName,
    LPTSTR  lpszPassword);

BOOL GetTokenHandle(
    PHANDLE phToken)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\anonycon.cxx ===
/*****************************************************************************\
* MODULE: anonycon.cxx
*
* The module contains class for connections using anonymous account
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   07/31/98    Weihaic     Created
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

CAnonymousConnection::CAnonymousConnection (
    BOOL bSecure,
    INTERNET_PORT nServerPort,
    BOOL bIgnoreSecurityDlg):

    CAnyConnection (bSecure, nServerPort, bIgnoreSecurityDlg, AUTH_ANONYMOUS)
{
}


HINTERNET
CAnonymousConnection::OpenRequest (
    LPTSTR      lpszUrl)
{
    HINTERNET hReq = NULL;

            hReq = InetHttpOpenRequest(m_hConnect,
                                       g_szPOST,
                                       lpszUrl,
                                       g_szHttpVersion,
                                       NULL,
                                       NULL,
                                       INETPP_REQ_FLAGS | INTERNET_FLAG_NO_AUTH | (m_bSecure?INTERNET_FLAG_SECURE:0),
                                       0);

    if ( hReq ) {
        if ( InetInternetSetOption (hReq,
                                    INTERNET_OPTION_USERNAME,
                                    TEXT (""),
                                    1) &&
             InetInternetSetOption (hReq,
                                    INTERNET_OPTION_PASSWORD,
                                    TEXT (""),
                                    1) ) {
        }
        else {
            CloseRequest (hReq);
            hReq = NULL;
        }
    }

    return hReq;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\anycon.cxx ===
/*****************************************************************************\
* MODULE: anycon.cxx
*
* The module contains the base class for connections
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   07/31/98    Weihaic     Created
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

/******************************************************************************
* Class Data Static Members
*****************************************************************************/
const DWORD CAnyConnection::gm_dwConnectTimeout = 30000;   // Thirty second timeout on connect
const DWORD CAnyConnection::gm_dwSendTimeout    = 30000;   // Thirty timeout on send timeout
const DWORD CAnyConnection::gm_dwReceiveTimeout = 60000;   // Thirty seconds on receive timeout
const DWORD CAnyConnection::gm_dwSendSize       = 0x10000; // We use a 16K sections when sending
                                                           // data through WININET
extern BOOL Ping (LPTSTR pszServerName);

CAnyConnection::CAnyConnection (
    BOOL    bSecure,
    INTERNET_PORT nServerPort,
    BOOL bIgnoreSecurityDlg,
    DWORD dwAuthMethod):

    m_lpszPassword (NULL),
    m_lpszUserName (NULL),
    m_hSession (NULL),
    m_hConnect (NULL),
    m_dwAccessFlag (INTERNET_OPEN_TYPE_PRECONFIG),
    m_bSecure (bSecure),
    m_bShowSecDlg (FALSE),
    m_dwAuthMethod (dwAuthMethod),
    m_bIgnoreSecurityDlg (bIgnoreSecurityDlg),
    m_bValid (FALSE)

{
    if (!nServerPort) {
        if (bSecure) {
            m_nServerPort = INTERNET_DEFAULT_HTTPS_PORT;
        }
        else {
            m_nServerPort = INTERNET_DEFAULT_HTTP_PORT;
        }
    }
    else
        m_nServerPort = nServerPort;


    m_bValid = TRUE;
}

CAnyConnection::~CAnyConnection ()
{
    if (m_hConnect) {
        (void) CAnyConnection::Disconnect ();
    }

    if (m_hSession) {
        (void) CAnyConnection::CloseSession ();
    }
    LocalFree (m_lpszPassword);
    m_lpszPassword = NULL;
    LocalFree (m_lpszUserName);
    m_lpszUserName = NULL;
}

HINTERNET
CAnyConnection::OpenSession ()
{

    m_hSession = InetInternetOpen(g_szUserAgent,
                                  m_dwAccessFlag,
                                  NULL,
                                  NULL,
                                  0);

    if (m_hSession) {  // Set up the callback function if successful

        // Also set an internet connection timeout for the session for when we try the
        // connection, should we do this instead of a ping?
        DWORD dwTimeout = gm_dwConnectTimeout;

        if (!InetInternetSetOption( m_hSession,
                                    INTERNET_OPTION_CONNECT_TIMEOUT,
                                    (LPVOID)&dwTimeout,
                                    sizeof(dwTimeout)
                                  ))
            goto Cleanup;

        // Now set the Send and Receive Timeout values

        dwTimeout = gm_dwSendTimeout;

        if (!InetInternetSetOption( m_hSession,
                                    INTERNET_OPTION_SEND_TIMEOUT,
                                    (LPVOID)&dwTimeout,
                                    sizeof(dwTimeout)
                                  ))
            goto Cleanup;

        dwTimeout = gm_dwReceiveTimeout;

        if (!InetInternetSetOption( m_hSession,
                                    INTERNET_OPTION_RECEIVE_TIMEOUT,
                                    (LPVOID)&dwTimeout,
                                    sizeof(dwTimeout)
                                  ))
            goto Cleanup;
    }

    return m_hSession;

Cleanup:

    if (m_hSession) {
        InetInternetCloseHandle (m_hSession);
        m_hSession = NULL;
    }

    return m_hSession;
}

BOOL CAnyConnection::CloseSession ()
{
    BOOL bRet =  InetInternetCloseHandle (m_hSession);

    m_hSession = NULL;

    return bRet;
}

HINTERNET
CAnyConnection::Connect(
    LPTSTR lpszServerName)
{

    if (m_hSession) {
        // Ping the server if it is in the intranet to make sure that the server is online

        if (lpszServerName &&

            (_tcschr ( lpszServerName, TEXT ('.')) || Ping (lpszServerName) )) {

            m_hConnect = InetInternetConnect(m_hSession,
                                             lpszServerName,
                                             m_nServerPort,
                                             NULL,//m_lpszUserName,
                                             NULL, //m_lpszPassword,
                                             INTERNET_SERVICE_HTTP,
                                             0,
                                             0);
        }
    }

    return m_hConnect;
}

BOOL
CAnyConnection::Disconnect ()
{
    BOOL bRet = InetInternetCloseHandle (m_hConnect);

    m_hConnect = NULL;

    return bRet;
}


HINTERNET
CAnyConnection::OpenRequest (
    LPTSTR      lpszUrl)
{
    HINTERNET hReq = NULL;
    DWORD dwFlags;

    if (m_hConnect) {
        // We need to create an Asynchronous Context for the Rest of the operations to use,
        // passing this in of course makes this request also asynchronous

                hReq = InetHttpOpenRequest(m_hConnect,
                                           g_szPOST,
                                           lpszUrl,
                                           g_szHttpVersion,
                                           NULL,
                                           NULL,
                                           INETPP_REQ_FLAGS | (m_bSecure? INTERNET_FLAG_SECURE:0),
                                           0);


    }
    return hReq;
}

BOOL
CAnyConnection::CloseRequest (HINTERNET hReq)
{
    //
    // We have to close the handle manually, since WININET seems not to be giving us
    // an INTERNET_STATUS_HANDLE_CLOSING message
    //
    BOOL bSuccess;

    bSuccess = InetInternetCloseHandle (hReq); // When this handle is closed, the context will be closed

    return bSuccess;
}



BOOL
CAnyConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    DWORD          cbData,
    LPBYTE         pidi)
{
    BOOL        bRet = FALSE;
    CMemStream  *pStream;

    pStream = new CMemStream (pidi, cbData);

    if (pStream && pStream->bValid ()){

        bRet = SendRequest (hReq, lpszHdr, pStream);
    }

    if (pStream) {
        delete pStream;
    }
    return bRet;
}

BOOL CAnyConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    CStream        *pStream)
{
    BOOL  bRet = FALSE;
    DWORD dwStatus;
    DWORD cbStatus = sizeof(dwStatus);
    BOOL  bRetry = FALSE;
    DWORD dwRetryCount = 0;
    BOOL  bShowUI = FALSE;

    DWORD cbData;
    PBYTE pBuf = NULL;
    DWORD cbRead;


    if (!pStream->GetTotalSize (&cbData))
        return FALSE;

    pBuf = new BYTE[gm_dwSendSize];
    if (!pBuf)
        return FALSE;

#define MAX_RETRY 3
    do {
        BOOL bSuccess = FALSE;
        BOOL bLeave;

        if (cbData < gm_dwSendSize) {

            if (pStream->Reset() &&
                pStream->Read (pBuf, cbData, &cbRead) && cbRead == cbData) {

                // If what we want to send is small, we send it with HttpSendRequest and not
                // HttpSendRequestEx, this is to wotk around a problem where we get timeouts on
                // receive on very small data transactions
                bSuccess = InetHttpSendRequest(hReq,
                                               lpszHdr,
                                               (lpszHdr ? (DWORD)-1 : 0),
                                               pBuf,
                                               cbData);
            }

        } else {
            do {
                BOOL bSuccessSend;
                // The timeout value for the packets applies for an entire session, so, instead of sending in
                // one chuck, we have to send in smaller chunks
                INTERNET_BUFFERS BufferIn;

                bLeave = TRUE;

                BufferIn.dwStructSize = sizeof( INTERNET_BUFFERS );
                BufferIn.Next = NULL;
                BufferIn.lpcszHeader = lpszHdr;
                if (lpszHdr)
                    BufferIn.dwHeadersLength = sizeof(TCHAR)*lstrlen(lpszHdr);
                else
                    BufferIn.dwHeadersLength = 0;
                BufferIn.dwHeadersTotal = 1;    // There is one header to send
                BufferIn.lpvBuffer = NULL;      // We defer this to the multiple write side
                BufferIn.dwBufferLength = 0;    // The total buffer length
                BufferIn.dwBufferTotal = cbData; // This is the size of the data we are about to send
                BufferIn.dwOffsetLow = 0;       // No offset into the buffers
                BufferIn.dwOffsetHigh = 0;

                // Since we will only ever be sending one request per hReq handle, we can associate
                // the context with all of these operations

                bSuccess = InetHttpSendRequestEx (hReq,
                                                  &BufferIn,
                                                  NULL,
                                                  0,
                                                  0);

                if (bSuccess) {
                    bSuccess = pStream->Reset();
                }

                DWORD   dwBufPos    = 0;      // This is our current point in the buffer
                DWORD   dwRemaining = cbData;  // These are the number of bytes left to send

                bSuccessSend = bSuccess;

                while (bSuccess && dwRemaining) {  // While we have data to send and the operations are
                                                   // successful
                    DWORD dwWrite = min( dwRemaining, gm_dwSendSize); // The amount to write
                    DWORD dwWritten;               // The amount actually written

                    if (pStream->Read (pBuf, dwWrite, &cbRead) && cbRead == dwWrite) {

                        bSuccess = InetInternetWriteFile (hReq, pBuf, dwWrite, &dwWritten);

                        if (bSuccess) {
                            bSuccess = dwWritten ? TRUE : FALSE;

                            dwRemaining -= dwWritten;            // Remaining amount decreases by this
                            dwBufPos += dwWritten;                // Advance through the buffer

                            if (dwWritten != dwWrite) {
                                // We need to adjust the pointer, since not all the bytes are
                                // successfully sent to the server
                                //
                                bSuccess = pStream->SetPtr (dwBufPos);
                            }
                        }
                    }
                    else
                        bSuccess = FALSE;
                }

                BOOL bEndSuccess = FALSE;

                if (bSuccessSend) {  // We started the request successfully, so we can end it successfully
                   bEndSuccess = InetHttpEndRequest (hReq,
                                                     NULL,
                                                     0,
                                                     0);

                }

                if (!bEndSuccess && GetLastError() == ERROR_INTERNET_FORCE_RETRY)
                        bLeave = FALSE;


                bSuccess = bSuccess  && bEndSuccess && bSuccessSend;

            }  while (!bLeave);
        }

        if (bSuccess) {

            if ( InetHttpQueryInfo(hReq,
                                   HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE,
                                   &dwStatus,
                                   &cbStatus,
                                   NULL) ) {
                switch (dwStatus) {
                case HTTP_STATUS_DENIED:
                case HTTP_STATUS_PROXY_AUTH_REQ:
                    SetLastError (ERROR_ACCESS_DENIED);
                    break;
                case HTTP_STATUS_FORBIDDEN:
                    SetLastError (HTTP_STATUS_FORBIDDEN);
                    break;
                case HTTP_STATUS_OK:
                    bRet = TRUE;
                    break;
                case HTTP_STATUS_SERVER_ERROR:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("CAnyConnection::SendRequest : HTTP_STATUS_SERVER_ERROR")));

                    SetLastError (ERROR_INVALID_PRINTER_NAME);
                    break;
                default:

                    if ((dwStatus >= HTTP_STATUS_BAD_REQUEST) &&
                        (dwStatus < HTTP_STATUS_SERVER_ERROR)) {

                        SetLastError(ERROR_INVALID_PRINTER_NAME);

                    } else {

                        // We get some other errors, but don't know how to handle it
                        //
                        DBG_MSG(DBG_LEV_ERROR, (TEXT("CAnyConnection::SendRequest : Unknown Error (%d)"), dwStatus));

                        SetLastError (ERROR_INVALID_HANDLE);
                    }
                    break;
                }
            }
        }
        else {

            if (m_bSecure) {

                DWORD dwFlags = 0;
                DWORD dwRet;

                if (m_bShowSecDlg) {
                    bShowUI = TRUE;
                    dwRet = InetInternetErrorDlg (GetTopWindow (NULL),
                                              hReq,
                                              GetLastError(),
                                              FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS, NULL);

                    if (dwRet == ERROR_SUCCESS || dwRet == ERROR_INTERNET_FORCE_RETRY) {
                        bRetry = TRUE;
                    }
                }
                else {
                    switch (GetLastError ()) {
                    case ERROR_INTERNET_INVALID_CA:
                        dwFlags = SECURITY_FLAG_IGNORE_UNKNOWN_CA;
                        break;
                    default:
                        // All other failure, try to ignore everything and retry
                        dwFlags = SECURITY_FLAG_IGNORE_REVOCATION |
                                  SECURITY_FLAG_IGNORE_UNKNOWN_CA |
                                  SECURITY_FLAG_IGNORE_WRONG_USAGE |
                                  SECURITY_FLAG_IGNORE_CERT_CN_INVALID |
                                  SECURITY_FLAG_IGNORE_CERT_DATE_INVALID|
                                  SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTPS |
                                  SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTP ;
                        break;
                    }

                    if (InetInternetSetOption(hReq,
                                           INTERNET_OPTION_SECURITY_FLAGS,
                                           &dwFlags,
                                           sizeof (DWORD))) {
                        bRetry = TRUE;
                    }
                }
            }
        }
    }
    while (bRetry && ++dwRetryCount < MAX_RETRY);

    if (!bRet && GetLastError () ==  ERROR_INTERNET_LOGIN_FAILURE)
    {
        SetLastError (ERROR_ACCESS_DENIED);
    }

    if (bShowUI) {
        // We only show the dialog once.
        m_bShowSecDlg = FALSE;
    }

    if (pBuf) {
        delete [] pBuf;
    }

    return bRet;
}

BOOL CAnyConnection::ReadFile (
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    BOOL bSuccess;

    bSuccess = InetInternetReadFile(hReq, lpvBuffer, cbBuffer, lpcbRd);

    return bSuccess;
}


BOOL CAnyConnection::SetPassword (
    HINTERNET hReq,
    LPTSTR lpszUserName,
    LPTSTR lpszPassword)
{
    BOOL bRet = FALSE;
    TCHAR szNULL[] = TEXT ("");

    if (!lpszUserName) {
        lpszUserName = szNULL;
    }

    if (!lpszPassword) {
        lpszPassword = szNULL;
    }

    if ( InetInternetSetOption (hReq,
                                INTERNET_OPTION_USERNAME,
                                lpszUserName,
                                (DWORD) (lstrlen(lpszUserName) + 1)) &&
         InetInternetSetOption (hReq,
                                INTERNET_OPTION_PASSWORD,
                                lpszPassword,
                                (DWORD) (lstrlen(lpszPassword) + 1)) ) {
        bRet = TRUE;
    }

    return bRet;
}

BOOL CAnyConnection::GetAuthSchem (
    HINTERNET hReq,
    LPSTR lpszScheme,
    DWORD dwSize)
{
    DWORD dwIndex = 0;

    return InetHttpQueryInfo(hReq, HTTP_QUERY_WWW_AUTHENTICATE, (LPVOID)lpszScheme, &dwSize, &dwIndex);
}

void CAnyConnection::SetShowSecurityDlg (
    BOOL bShowSecDlg)
{
    m_bShowSecDlg = bShowSecDlg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\cachemgr.cxx ===
/*****************************************************************************\
* MODULE: cachemgr.cxx
*
* The module contains routines to implement the caching algorithm for
* the printers provider
*
* Purpose:
*
* Description:
*
*   The Caching algorithm operates based on a state machine. There are five
*   states in the cache:
*
*       CACHE_STATE_INIT
*       CACHE_STATE_ACCESSED_VALID,
*       CACHE_STATE_DATA_VALID,
*       CACHE_STATE_ACCESSED_VALID_AGAIN,
*       CACHE_STATE_NOT_ACCESSED_VALID_AGAIN
*
*       CACHE_STATE_INIT is the initial state. Once the first cache hit
*       comes in, the cahce manager calles FetchData to fetch the data
*       and goes into CACHE_STATE_ACCESSED_VALID state.
*
*       In CACHE_STATE_ACCESSED_VALID state, the cache manager waits
*       for the minimum cache timeout and go to CACHE_STATE_DATA_VALID
*
*       In CACHE_STATE_DATA_VALID state, the cache manager waits for
*       another cache hit withing half of the last fetch time.
*
*       If there is a hit during this waiting, the cache manager will go
*       for another fetch and go to CACHE_STATE_ACCESSED_VALID state.
*
*       If there is no hit during the waiting period, the cache manager
*       waits for another timeout or another cache hit.
*
*       If there is no access during the waiting, the cache manager
*       invalidates the cache. Otherwise, the cache manager go out and
*       do anther data fetch and then go to CACHE_STATE_ACCESSED_VALID.
*
*
*
* Copyright (C) 1998-1999 Microsoft Corporation
*
* History:
*     10/16/98 weihaic    Created
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"


extern BOOL _ppinfo_net_get_info(
                IN  PCINETMONPORT   pIniPort,
                OUT PPRINTER_INFO_2 *ppInfo,
                OUT LPDWORD         lpBufAllocated,
                IN  ALLOCATORFN     pAllocator);

extern BOOL ppjob_EnumForCache(
                IN  PCINETMONPORT   pIniPort,
                OUT LPPPJOB_ENUM    *ppje);



//  cdwMaxCacheValidTime is the maximum expire time for the current cache
//  Idealy, we should put a large number to increase the effiency of the cache
//  so we choose 30 seconds (30*1000) as the final number. For testing purpose,
//  we put 15 seconds to increase the hit of the fetch data code
//
//  weihaic 10/23/98
//
const DWORD cdwMaxCacheValidTime = 30*1000;      // The cache content will expire after 30 seconds.
const DWORD cdwMinCacheValidTime = 2*1000;       // The cache content will be valid for at least 2 seconds


CacheMgr::CacheMgr ():
    m_dwState (CACHE_STATE_INIT),
    m_pIniPort (NULL),
    m_pData (NULL),
    m_hDataReadyEvent (NULL),
    m_hHitEvent (NULL),
    m_hInvalidateCacheEvent (NULL),
    m_hThread (NULL),
    m_bCacheStopped (FALSE),
    m_bAccessed (FALSE),
    m_bInvalidateFlag (FALSE),
    m_dwThreadRefCount (0),
    m_bValid (FALSE)
{
    if ((m_hDataReadyEvent = CreateEvent (NULL, TRUE, FALSE, NULL)) &&
        (m_hHitEvent = CreateEvent (NULL, FALSE, FALSE, NULL)) &&
        (m_hInvalidateCacheEvent = CreateEvent (NULL, FALSE, FALSE, NULL)) )

        m_bValid = TRUE;
}


CacheMgr::~CacheMgr ()
{
}

VOID
CacheMgr::AttachThreadHandle (
    HANDLE hThread
    )
{
    CacheData.Lock();

    m_hThread = hThread;
    m_dwThreadRefCount = 1;

    DBGMSGT (DBG_CACHE_TRACE, ( TEXT ("AttachThreadHandle (hThread = %d)"), hThread));

    CacheData.Unlock();
}

HANDLE
CacheMgr::GetThreadHandle (
    VOID
    )
{
    HANDLE hThread;

    CacheData.Lock();

    hThread = m_hThread;

    if (m_hThread)
    {
        m_dwThreadRefCount++;
    }

    DBGMSGT (DBG_CACHE_TRACE, ( TEXT ("GetThreadHandle (hThread = %d, Count = %d)"), hThread, m_dwThreadRefCount));

    CacheData.Unlock();

    return hThread;
}

VOID
CacheMgr::ReleaseThreadHandle (
    VOID
    )
{
    HANDLE hThread = NULL;

    CacheData.Lock();

    if (m_hThread)
    {
        m_dwThreadRefCount--;

        DBGMSGT (DBG_CACHE_TRACE, ( TEXT ("ReleaseThreadHandle (hThread = %d, Count = %d)"), hThread, m_dwThreadRefCount));

        if (m_dwThreadRefCount == 0)
        {
            hThread = m_hThread;
            m_hThread = NULL;
        }
    }

    CacheData.Unlock();

    if (hThread)
    {
        CloseHandle (hThread);
    }
}


VOID
CacheMgr::Shutdown ()
{
    HANDLE hThread;

    CacheRead.Lock ();
    // No more read is possible

    m_bCacheStopped = TRUE;
    if (hThread = GetThreadHandle ()) {

        SetEvent (m_hInvalidateCacheEvent);

        // Wait for another thread to exit
        WaitForSingleObject (hThread, INFINITE);

        ReleaseThreadHandle ();
    }

    if (m_hDataReadyEvent) {
        CloseHandle (m_hDataReadyEvent);
    }

    if (m_hHitEvent) {
        CloseHandle (m_hHitEvent);
    }

    if (m_hInvalidateCacheEvent) {
        CloseHandle (m_hInvalidateCacheEvent);
    }

    m_bValid = FALSE;

    CacheRead.Unlock ();

    delete this;
}

BOOL
CacheMgr::SetupAsyncFetch (
    PCINETMONPORT pIniPort)
{
    BOOL    bRet = FALSE;

    PTHREADCONTEXT pThreadData = new THREADCONTEXT;
    HANDLE  hThread = NULL;

    if (pThreadData) {
        pThreadData->pIniPort = pIniPort;
        pThreadData->pCache = this;

        pThreadData->pSidToken = new CSid;

        if (pThreadData->pSidToken && pThreadData->pSidToken->bValid()) {

            if (hThread = CreateThread (NULL, COMMITTED_STACK_SIZE, (LPTHREAD_START_ROUTINE)CacheMgr::WorkingThread,
                                          (PVOID) pThreadData, CREATE_SUSPENDED, NULL)) {
                bRet = TRUE;
            }
        }

        if (bRet)
        {
            AttachThreadHandle (hThread);

            //
            // The thread is created in the suspended state
            //
            if (ResumeThread (hThread) == -1)
            {
                //
                //  Resume thread failed, so we need to clean up the thread handle
                //
                ReleaseThreadHandle ();
                bRet = FALSE;
            }
        }

        if (!bRet) {

            if (pThreadData->pSidToken) {
                delete pThreadData->pSidToken;
            }

            delete (pThreadData);
        }
    }

    return bRet;
}

VOID
CacheMgr::TransitState (
    PCINETMONPORT pIniPort)
{
    PVOID   pData = NULL;
    DWORD   dwFetchTime = 0;
    CACHESTATE dwState, dwOldState;
    BOOL    bNewData;
    HANDLE  hHandles[2];

    hHandles [0] = m_hHitEvent;
    hHandles [1] = m_hInvalidateCacheEvent;


    dwState = m_dwState;

    do {

        DBGMSGT (DBG_CACHE_TRACE, ( TEXT ("TransitState: current state %d"), m_dwState));

        dwState = m_dwState;
        bNewData = FALSE;
        m_bAccessed = FALSE;

        switch (dwState) {
        case CACHE_STATE_INIT:

            // Clean the data ready event
            ResetEvent (m_hDataReadyEvent);

            if (GetFetchTime (pIniPort, &dwFetchTime, &pData)) {
                bNewData = TRUE;
                dwState = CACHE_STATE_ACCESSED_VALID;
            }
            else {
                //Invalid Cache Content
                DBGMSGT (DBG_CACHE_ERROR, ( TEXT ("TransitState: FatalError %d"), GetLastError));

                // Invalidate the cache content, so that when the next get comes, it will
                // get the NULL  pointer.
                pData = NULL;
                bNewData = TRUE;
                dwState = CACHE_STATE_ACCESSED_VALID;
            }

            break;

        case CACHE_STATE_ACCESSED_VALID:

            WaitForSingleObject (m_hInvalidateCacheEvent, cdwMinCacheValidTime);
            dwState = CACHE_STATE_DATA_VALID;

            break;

        case CACHE_STATE_DATA_VALID:


            WaitForSingleObject (m_hInvalidateCacheEvent, dwFetchTime / 2);

            if (m_bAccessed) {
                // The cache has been accessed during the waiting time
                dwState = CACHE_STATE_ACCESSED_VALID_AGAIN;
            }
            else {
                // The cache has not been accessed during the waiting time
                dwState = CACHE_STATE_NOT_ACCESSED_VALID_AGAIN;
            }
            break;

        case CACHE_STATE_ACCESSED_VALID_AGAIN:
            if (GetFetchTime (pIniPort, &dwFetchTime, &pData)) {
                bNewData = TRUE;
                dwState = CACHE_STATE_ACCESSED_VALID;
            }
            else {
                //Invalid Cache Content
                DBGMSGT (DBG_CACHE_ERROR, ( TEXT ("TransitState: FatalError %d"), GetLastError));

                // Invalidate the cache content, so that when the next access to cache comes,
                // it will get a NULL  pointer.
                pData = NULL;
                bNewData = TRUE;
                dwState = CACHE_STATE_ACCESSED_VALID;
            }

            break;

        case CACHE_STATE_NOT_ACCESSED_VALID_AGAIN:

            // This has to be a long wait so that the cache will be valid for an access long after
            // the last fetch happeen


            ResetEvent (m_hHitEvent);

            switch (WaitForMultipleObjects (2, hHandles, FALSE, cdwMaxCacheValidTime ))
            {
            case WAIT_TIMEOUT:
                dwState = CACHE_STATE_INIT;
                break;
            case WAIT_OBJECT_0:
                //Accessed

                if (GetFetchTime (pIniPort, &dwFetchTime, &pData)) {
                    bNewData = TRUE;
                    dwState = CACHE_STATE_ACCESSED_VALID;
                }
                else {
                    //Invalid Cache Content
                    DBGMSGT (DBG_CACHE_ERROR, ( TEXT ("TransitState: FatalError %d"), GetLastError));

                    // Invalidate the cache content, so that when the next access to cache comes,
                    // it will get a NULL  pointer.
                    pData = NULL;
                    bNewData = TRUE;
                    dwState = CACHE_STATE_ACCESSED_VALID;
                }
                break;

            case WAIT_OBJECT_0 + 1:

                dwState = CACHE_STATE_INIT;
                break;

            default:
                // ERROR
                DBGMSGT (DBG_CACHE_ERROR, ( TEXT ("TransitState: WaitForSingleObject FatalError %d"), GetLastError));

                // Invalidate the cache
                dwState = CACHE_STATE_INIT;
                break;

            }
            break;

        default:
            DBGMSGT (DBG_CACHE_ERROR, (TEXT ("AsyncFech: wrong state %d"), m_dwState));
            // Invalidate the cache
            dwState = CACHE_STATE_INIT;
        }

        if (m_bCacheStopped) {
            // Cache is being stopped. Cleanup everything this thread generates
            if (bNewData) {
                FreeBuffer (pIniPort, pData);
            }
            // Since the caching thread is going to abort, so we need to raise
            // this flag so that the waiting thread can go on.
            SetEvent (m_hDataReadyEvent);
            break;
        }


        dwOldState = m_dwState;
        SetState (pIniPort, dwState, bNewData, pData);

        if (dwOldState == CACHE_STATE_INIT) {
            SetEvent (m_hDataReadyEvent);
        }

        if (m_bInvalidateFlag) {
            // Another thread called invalidate thread and hope get rid of the thread
            m_dwState = CACHE_STATE_INIT;
        }

    } while ( m_dwState != CACHE_STATE_INIT );


    // Terminate the async fetch thread

    ReleaseThreadHandle ();

    DBGMSGT (DBG_CACHE_TRACE, (TEXT ("CacheMgr::TransitState: Async thread quit")));


    return;

}

VOID
CacheMgr::SetState (
    PCINETMONPORT   pIniPort,
    CACHESTATE      dwState,
    BOOL            bNewData,
    PVOID           pNewData)
{
    PVOID pOldData = NULL;

    m_bAccessed = 0;
    if (bNewData) {
        CacheData.Lock ();
        pOldData = m_pData;
        m_pData = pNewData;

        CacheData.Unlock ();
    }

    // This line must be here, since otherwise, the state is updated to the new one
    // but the data are not
    //
    m_dwState = dwState;

    if (pOldData) {
        FreeBuffer (pIniPort, pOldData);
    }

}

VOID
CacheMgr::WorkingThread (
    PTHREADCONTEXT pThreadData)
{
    CacheMgr *pThis = pThreadData->pCache;
    PCINETMONPORT pIniPort = pThreadData->pIniPort;

    pThreadData->pSidToken->SetCurrentSid ();
    delete pThreadData->pSidToken;
    pThreadData->pSidToken = NULL;

    delete pThreadData;

    pThis->TransitState (pIniPort);
}


BOOL
CacheMgr::GetFetchTime (
    PCINETMONPORT   pIniPort,
    LPDWORD         pdwTime,
    PVOID           *ppData)
{
    BOOL bRet = FALSE;
    DWORD dwT0, dwT1;



    dwT0 = GetTickCount();
    if (FetchData (pIniPort, ppData)) {
        bRet = TRUE;
    }
    dwT1 = GetTickCount();
    *pdwTime =  GetTimeDiff (dwT0, dwT1);


    DBGMSGT (DBG_CACHE_TRACE,
             (TEXT ("GetFetchTime: returns %d, timediff=%d ms"),
              bRet, GetTimeDiff (dwT0, dwT1)));

    return bRet;
}

PVOID
CacheMgr::BeginReadCache (
    PCINETMONPORT   pIniPort)
{
    HANDLE hThread = NULL;

    if (m_bValid) {
        CacheRead.Lock ();

        CUserData CurUser;

        while (TRUE) {
            if (m_dwState == CACHE_STATE_INIT) {

                m_CurUser = CurUser;

                hThread = GetThreadHandle ();

                if (!hThread) {
                    // If there is no thread running, we need to reset the dataready event

                    ResetEvent (m_hDataReadyEvent);
                }


                if (hThread // There is already a thread running
                    || SetupAsyncFetch (pIniPort)) {

                    // We must leave the critical section since it might take forever to
                    // get the information at the first time
                    CacheRead.Unlock ();

                    WaitForSingleObject (m_hDataReadyEvent, INFINITE);

                    CacheRead.Lock ();

                }

                if (hThread)
                {
                    ReleaseThreadHandle ();
                }

                break;
            }
            else {

                if (m_CurUser == CurUser) {
                    if (m_dwState == CACHE_STATE_NOT_ACCESSED_VALID_AGAIN) {
                        SetEvent (m_hHitEvent);
                    }
                    break;
                }
                else {
                    // We must call the internal version of InvalidateCache since
                    // we have to leave the critical section when waiting for the termination
                    // of the working thread.
                    //

                    _InvalidateCache ();
                    // Now, the state becomes CACHE_STATE_INIT
                }
            }
        }

        m_bAccessed = TRUE;

        BOOL bRet = CacheData.Lock ();

        DBGMSGT (DBG_CACHE_TRACE, (TEXT ("CacheData.Lock() = %d"), bRet));


        return m_pData;

    }
    else
        return NULL;
}

VOID
CacheMgr::EndReadCache (VOID)
{

    DBGMSGT (DBG_CACHE_TRACE,
         (TEXT ("CacheMgr::EndReadCache: Entered")));


    if (m_bValid) {

        BOOL bRet = CacheData.Unlock ();

        DBGMSGT (DBG_CACHE_TRACE, (TEXT ("CacheData.Unlock() = %d"), bRet));

        CacheRead.Unlock ();
    }
}

VOID
CacheMgr::_InvalidateCache ()
{

    HANDLE hThread = NULL;

    if (!m_bInvalidateFlag) {

        m_bInvalidateFlag = TRUE;

        SetEvent (m_hInvalidateCacheEvent);
    }

    if (hThread = GetThreadHandle ()) {

        CacheRead.Unlock ();
        // We must leave the critical section since we don't know how long it will take for thread to exit

        // Wait for another thread to exit
        WaitForSingleObject (hThread, INFINITE);

        CacheRead.Lock ();

        ReleaseThreadHandle ();
    }

    // Clean up the event
    ResetEvent (m_hInvalidateCacheEvent);
    m_bInvalidateFlag = FALSE;


    DBGMSGT (DBG_CACHE_TRACE, ( TEXT ("CacheMgr::InvalidateCache dwState=%d"), m_dwState));

}

VOID
CacheMgr::InvalidateCache ()
{
    CacheRead.Lock ();

    _InvalidateCache ();

    CacheRead.Unlock ();
}

VOID
CacheMgr::InvalidateCacheForUser(
    CLogonUserData *pUser )
/*++

Routine Description:
    This routine checks to see whether the given user is currently controlling the cache
    thread. If they are, the thread is terminated.

Arguments:
    pUser    - A pointer to the user.

Return Value:
    None.

--*/
    {

    CacheRead.Lock();

    if (m_CurUser == *(CUserData *)pUser) // Comparison is valid after caste
        _InvalidateCache ();

    CacheRead.Unlock();
}

inline  DWORD
CacheMgr::GetTimeDiff (
    DWORD   t0,
    DWORD   t1)
{
    if (t1 > t0) {
        return t1 - t0;
    }
    else {
        return DWORD(-1) - t0 + t1;
    }
}

LPVOID CacheMgr::Allocator(
    DWORD cb)
{
    return new CHAR[cb];
}


GetPrinterCache::GetPrinterCache(
    PCINETMONPORT   pIniPort):
    m_pIniPort (pIniPort)
{

}

GetPrinterCache::~GetPrinterCache (
    VOID)
{
    if (m_pData) {
        FreeBuffer (m_pIniPort, m_pData);
    }
}


BOOL
GetPrinterCache::FetchData (
    PCINETMONPORT   pIniPort,
    PVOID           *ppData)
{
    BOOL bRet = FALSE;
    PGETPRINTER_CACHEDATA pCacheData = NULL;

    DBGMSGT (DBG_CACHE_TRACE, (TEXT ("GetPrinterCache::FetchData begins")));
#ifdef DEBUG
    if (0) {
        // Simulate the hanging of the current thread
        // For debugging purpose.
        MessageBox (NULL, TEXT ("GetPrinterCache::FetchData called. Press OK to continue."), TEXT ("ALERT"), MB_OK);
    }
#endif


    if (pCacheData = new GETPRINTER_CACHEDATA) {

        semEnterCrit ();

        pCacheData->bRet = _ppinfo_net_get_info(pIniPort,
                                                & (pCacheData->pInfo) ,
                                                & (pCacheData->cbSize),
                                                Allocator);
        semLeaveCrit ();

        pCacheData->dwLastError = GetLastError ();

        DBGMSGT (DBG_CACHE_TRACE, (TEXT ("GetPrinterCache::FetchData bRet=%d, err=%d\n"),
                       pCacheData->bRet, pCacheData->dwLastError ));


        //
        // We must return TRUE, otherwise PPGetPrinter won't get the correct last error
        //

        bRet = TRUE; //pCacheData->cbSize != 0;
    }

    if (!bRet) {
        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("GetPrinterCache::FetchData failed, call FreeBuffer (%x, %x)"), pIniPort, pCacheData));
        FreeBuffer (pIniPort, pCacheData);
    }
    else {
        *ppData = pCacheData;
    }

    return bRet;
}

BOOL
GetPrinterCache::FreeBuffer (
    PCINETMONPORT   pIniPort,
    PVOID           pData)
{
    PGETPRINTER_CACHEDATA pCacheData = (PGETPRINTER_CACHEDATA) pData;

    DBGMSGT (DBG_CACHE_TRACE,
             (TEXT ("FreeBuffer(%x, %x)  called"), pIniPort, pCacheData));

    if (pCacheData) {
        if (pCacheData->pInfo) {
            delete [] (PCHAR)(pCacheData->pInfo);
        }
        delete pCacheData;
    }

    return TRUE;
}

BOOL
GetPrinterCache::BeginReadCache (
    PPRINTER_INFO_2 *ppInfo)
{
    BOOL bRet = FALSE;

    if (m_bValid) {

        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("GetPrinterCache::BeginReadCache: Entered")));

        PGETPRINTER_CACHEDATA pData = (PGETPRINTER_CACHEDATA) CacheMgr::BeginReadCache (m_pIniPort);

        if (pData) {
            if (pData->bRet) {
                *ppInfo = pData->pInfo;
                bRet = TRUE;
            }
            else {
                SetLastError (pData->dwLastError);
            }

        }

        if (!bRet && GetLastError () == ERROR_SUCCESS) {

            SetLastError (ERROR_CAN_NOT_COMPLETE);

        }

        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("GetPrinterCache::BeginReadCache: pData = %x, return = %d, lasterror = %d"),
                  pData, bRet, GetLastError ()));
    }
    else {
        SetLastError (ERROR_CAN_NOT_COMPLETE);
    }


    return bRet;


}

EnumJobsCache::EnumJobsCache(
    PCINETMONPORT   pIniPort):
    m_pIniPort (pIniPort)
{
}

EnumJobsCache::~EnumJobsCache (
    VOID)
{
    if (m_pData) {
        FreeBuffer (m_pIniPort, m_pData);
    }
}


BOOL
EnumJobsCache::FetchData (
    PCINETMONPORT   pIniPort,
    PVOID           *ppData)
{
    BOOL bRet = FALSE;
    HANDLE hPort = (HANDLE)pIniPort;
    PENUMJOBS_CACHEDATA pCacheData = NULL;

    DBGMSGT (DBG_CACHE_TRACE, (TEXT ("EnumJobsCache::FetchData begins")));

    if (pCacheData = new ENUMJOBS_CACHEDATA) {

        pCacheData->pje = NULL;

        semEnterCrit ();
        pCacheData->bRet = ppjob_EnumForCache(pIniPort, & (pCacheData->pje));
        pCacheData->dwLastError = GetLastError ();

        DBGMSGT (DBG_CACHE_TRACE, (TEXT ("EnumJobsCache::FetchData bRet=%d, err=%d\n"),
                                   pCacheData->bRet, pCacheData->dwLastError ));

        if (pCacheData->bRet) {

            if (pCacheData->pje) {
                pCacheData->cbSize = pCacheData->pje->cbSize;
            }
            else {
                pCacheData->cbSize = 0;
            }
        }

        semLeaveCrit ();

        bRet = TRUE;
    }

    if (bRet) {
        *ppData = pCacheData;
    }

    return bRet;
}

BOOL
EnumJobsCache::FreeBuffer (
    PCINETMONPORT   pIniPort,
    PVOID           pData)
{
    PENUMJOBS_CACHEDATA pCacheData = (PENUMJOBS_CACHEDATA) pData;

    if (pCacheData) {
        if (pCacheData->pje) {

            // memFree has access to the global link list, so it is neccesary
            // to run it under critical secion.
            //

            semEnterCrit ();
            memFree(pCacheData->pje, memGetSize(pCacheData->pje));
            semLeaveCrit ();
        }
        delete pCacheData;
    }

    return TRUE;
}

BOOL
EnumJobsCache::BeginReadCache (
    LPPPJOB_ENUM    *ppje)
{
    BOOL bRet = FALSE;

    if (m_bValid) {

        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("EnumJobsCache::BeginReadCache: Entered")));

        PENUMJOBS_CACHEDATA pData = (PENUMJOBS_CACHEDATA) CacheMgr::BeginReadCache (m_pIniPort);


        if (pData) {
            if (pData->bRet) {
                *ppje = pData->pje;
                bRet = TRUE;
            }
            else {
                SetLastError (pData->dwLastError);
            }
        }

        if (!bRet && GetLastError () == ERROR_SUCCESS) {

            SetLastError (ERROR_CAN_NOT_COMPLETE);

        }

        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("EnumJobsCache::BeginReadCache: pData = %x, return = %d, lasterror = %d"),
                  pData, bRet, GetLastError ()));
    }
    else {
        SetLastError (ERROR_CAN_NOT_COMPLETE);
    }

    return bRet;

}

VOID
EnumJobsCache::EndReadCache (
    VOID)
{
    DBGMSGT (DBG_CACHE_TRACE,
             (TEXT ("EnumJobsCache::EndReadCache: Entered")));

    CacheMgr::EndReadCache ();
}

/*********************************************************************************
** End of File (cachemgr.cxx)
*********************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\basicsec.cxx ===
/*****************************************************************************\
* MODULE: basicsec.c
*
* Security routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifdef NOT_IMPLEMENTED

#include "precomp.h"
#include "priv.h"

// NOTE: Currently, this module is not implemented.  In the future this
//       could be functional, but it's not necessary for this particular
//       implementation.
//
//       30-Oct-1996 : ChrisWil (HWP)
//

/*****************************************************************************\
* AuthenticateUser
*
*
\*****************************************************************************/
DWORD AuthenticateUser(
    LPVOID *lppvContext,
    LPTSTR lpszServerName,
    LPTSTR lpszScheme,
    DWORD  dwFlags,
    LPSTR  lpszInBuffer,
    DWORD  dwInBufferLength,
    LPTSTR lpszUserName,
    LPTSTR lpszPassword)
{
    DBG_MSG(DBG_LEV_WARN, (TEXT("Call: AuthenticateUser: Not Implemented")));

    return ERROR_SUCCESS;
}


/*****************************************************************************\
* UnloadAuthenticateUser
*
*
\*****************************************************************************/
VOID UnloadAuthenticateUser(
    LPVOID *lppvContext,
    LPTSTR lpszServer,
    LPTSTR lpszScheme)
{
    DBG_MSG(DBG_LEV_WARN, (TEXT("Call: AuthenticateUser: Not Implemented")));

    return ERROR_SUCCESS;
}


/*****************************************************************************\
* PreAuthenticateUser
*
*
\*****************************************************************************/
DWORD PreAuthenticateUser(
    LPVOID  *lppvContext,
    LPTSTR  lpszServerName,
    LPTSTR  lpszScheme,
    DWORD   dwFlags,
    LPSTR   lpszInBuffer,
    DWORD   dwInBufferLength,
    LPSTR   lpszOutBuffer,
    LPDWORD lpdwOutBufferLength,
    LPTSTR  lpszUserName,
    LPTSTR  lpszPassword)
{
    DBG_MSG(DBG_LEV_WARN, (TEXT("Call: AuthenticateUser: Not Implemented")));

    return ERROR_SUCCESS;
}


/*****************************************************************************\
* GetTokenHandle
*
* Stolen from windows\base\username.c.  Must close the handle that is
* returned.
*
\*****************************************************************************/

#define GETTOK_FLGS (TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY)

BOOL GetTokenHandle(
    PHANDLE phToken)
{
    if (!OpenThreadToken(GetCurrentThread(), GETTOK_FLGS, TRUE, phToken)) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            // This means we are not impersonating anybody.
            // Instead, lets get the token out of the process.
            //
            if (!OpenProcessToken(GetCurrentProcess(), GETTOK_FLGS, phToken)) {

                return FALSE;
            }

        } else {

            return FALSE;
        }
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\debug.cxx ===
/*****************************************************************************\
* MODULE: debug.c
*
* Debugging routines.  This is only linked in on DEBUG builds.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

#ifdef DEBUG

DWORD gdwDbgLevel = DBG_LEV_ERROR | DBG_LEV_FATAL | DBG_CACHE_ERROR;

VOID
CDECL
DbgMsgOut(
    LPCTSTR lpszMsgFormat,
    ...
    )
{
    TCHAR   szMsgText[DBG_MAX_TEXT];
    va_list pArgs;

    va_start(pArgs, lpszMsgFormat);

    StringCchVPrintf(szMsgText,
                     COUNTOF(szMsgText),
                     lpszMsgFormat,
                     pArgs);


    OutputDebugString(szMsgText);

    OutputDebugString(TEXT("\n"));

    va_end(pArgs);
}

VOID
CDECL
DbgMsg (
    LPCTSTR pszFormat,
    ...
    )
{
    TCHAR       szBuf[DBG_MAX_TEXT];
    TCHAR       szTime[30];
    SYSTEMTIME  curTime;
    va_list     pArgs;

    va_start(pArgs, pszFormat);

    GetLocalTime (&curTime);

    StringCchPrintf(szTime,
                    COUNTOF(szTime),
                    TEXT ("%02d:%02d:%02d.%03d "),
                    curTime.wHour,
                    curTime.wMinute,
                    curTime.wSecond,
                    curTime.wMilliseconds);


    StringCchVPrintf(szBuf, COUNTOF(szBuf), pszFormat, pArgs);

    OutputDebugString(szTime);
    OutputDebugString(szBuf);
    OutputDebugString(TEXT ("\n"));

    va_end(pArgs);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\debug.h ===
/*****************************************************************************\
* MODULE: debug.h
*
* Header file for (debug.c).
*
* Double braces are needed for output macros.
*
*     DBGMSG(DBG_LEV_ERROR, ("Error code %d", Error));
*
* This is because we can't use variable parameter lists in macros.
* The statement gets pre-processed to a semi-colon in non-debug mode.
*
* Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
* Setting the flag in the low word causes that level to be printed;
* setting the high word causes a break into the debugger.
* E.g. setting it to 0x00040006 will print out all warning and error
* messages, and break on errors.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#ifndef _INETPP_DEBUG_H
#define _INETPP_DEBUG_H

#ifdef DEBUG

extern DWORD gdwDbgLevel;


// Maximum size of debug string
//
#define DBG_MAX_TEXT       256


// Debug output levels.  By masking in the various levels, you can receive
// all levels of output.
//
#define DBG_LEV_INFO       0x00000001
#define DBG_LEV_CALLTREE   0x00000002
#define DBG_LEV_WARN       0x00000004
#define DBG_LEV_ERROR      0x00000008
#define DBG_LEV_FATAL      0x00000010
#define DBG_CACHE_TRACE    0x00000020
#define DBG_CACHE_ERROR    0x00000040

#define DBG_LEV_ALL        0x0000007F


// Function prototype for debug-routine (debug.c)
//
VOID
CDECL
DbgMsgOut(
    LPCTSTR lpszMsgFormat,
    ...
    );

VOID
CDECL
DbgMsg (
    LPCTSTR pszFormat,
    ...
    );

// Handy macros for use throughout the source.
//
#define DBG_BREAKPOINT()          DebugBreak();
#define DBG_MSG(Lev, MsgArgs)     {if (Lev & gdwDbgLevel) {DbgMsgOut MsgArgs;}}
#define DBG_ASSERT(Expr, MsgArgs) {if (!Expr) {DbgMsgOut MsgArgs; DebugBreak();}}
#define DBGMSGT(dwLevel, x) {if (dwLevel & gdwDbgLevel) {DbgMsg x;}}

#else

#define DBG_BREAKPOINT()
#define DBG_MSG(Lev, MsgArgs)
#define DBG_ASSERT(Expr, MsgArgs)
#define DBGMSGT(dwLevel, x)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\config.h ===
#ifndef INET_CONFIG_DATA_H
#define INET_CONFIG_DATA_H

class CPortConfigData {
public:
    CPortConfigData ();

    CPortConfigData (
        LPCTSTR pUserName, 
        LPCTSTR pPassword);

    ~CPortConfigData ();

    inline BOOL 
    bValid (VOID) CONST {
        return m_bValid;
    }

    inline DWORD 
    GetAuthMethod () CONST {
        return m_dwAuthMethod;
    }

    inline BOOL
    GetIgnoreSecurityDlg () CONST {
        return m_bIgnoreSecurityDlg;
    }

    inline LPCTSTR 
    GetUserName () CONST {
        return m_pUserName;
    };

    inline LPCTSTR 
    GetPassword () CONST {
        return m_pPassword;
    }

    BOOL 
    SetAuthMethod (
        DWORD dwAuthMethod);

    BOOL 
    SetUserName (
        LPCTSTR pUserName);

    BOOL 
    SetPassword (
        LPCTSTR pPassword);

    BOOL
    SetIgnoreSecurityDlg (
        BOOL bIgnoreSecurityDlg) {
        m_bIgnoreSecurityDlg = bIgnoreSecurityDlg;
        return TRUE;
    }
private:
    BOOL    m_bValid;
    LPTSTR  m_pUserName;
    LPTSTR  m_pPassword;
    DWORD   m_dwAuthMethod;
    BOOL    m_bIgnoreSecurityDlg;
};


class CPortConfigDataMgr {
public:
    CPortConfigDataMgr (LPCTSTR pszPortName);
    ~CPortConfigDataMgr ();

    BOOL bValid (VOID) CONST {
        return m_bValid;
    };
    
    BOOL 
    SetPerUserSettings (
        CPortConfigData &ConfigData);

    BOOL 
    SetPerPortSettings (
        CPortConfigData &ConfigData);

    BOOL 
    GetPerPortSettings (
        CPortConfigData* pConfigData) CONST;

    BOOL 
    GetPerUserSettings (
        CPortConfigData* pConfigData) CONST;
        
    BOOL 
    GetCurrentSettings (
        CPortConfigData* pConfigData) CONST;

    BOOL 
    DeleteAllSettings (
        VOID);

private:
    BOOL 
    SetPortSettings (
        HKEY hkPath,
        CPortConfigData &ConfigData);
    
    BOOL 
    GetPortSettings (
        HKEY hkPath,
        CPortConfigData* pConfigData) CONST;

    BOOL
    DeletePerPortSettings (
        VOID);

    BOOL
    DeletePerUserSettings (
        LPTSTR pUser);

    BOOL
    DeleteSettings (
        HKEY hkPath);


    
    BOOL    m_bValid;
    LPTSTR  m_pszPortName;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\config.cxx ===
/*****************************************************************************\
* MODULE: config.cxx
*
* The module contains class to manage connection configurations
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   05/12/00    Weihaic     Created
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

CPortConfigData::CPortConfigData():
    m_bValid (TRUE),
    m_pUserName (NULL),
    m_pPassword (NULL),
    m_dwAuthMethod (AUTH_UNKNOWN),
    m_bIgnoreSecurityDlg (FALSE)

{
}

CPortConfigData::CPortConfigData(
    LPCTSTR pUserName,
    LPCTSTR pPassword):
    m_bValid (FALSE),
    m_pUserName (NULL),
    m_pPassword (NULL),
    m_dwAuthMethod (AUTH_UNKNOWN),
    m_bIgnoreSecurityDlg (FALSE)
{
    if (AssignString (m_pUserName, pUserName) &&
        AssignString (m_pPassword, pPassword))
        m_bValid = TRUE;
}

CPortConfigData::~CPortConfigData()
{
    LocalFree (m_pUserName);
    LocalFree (m_pPassword);
}

BOOL
CPortConfigData::SetUserName (
    LPCTSTR pUserName)
{
    BOOL bRet = FALSE;
    if (m_bValid) {
        bRet =  AssignString(m_pUserName, pUserName);
    }
    return bRet;
}

BOOL
CPortConfigData::SetPassword (
        LPCTSTR pPassword)
{
    BOOL bRet = FALSE;
    if (m_bValid) {
        bRet =  AssignString (m_pPassword, pPassword);
    }
    return bRet;
}


BOOL
CPortConfigData::SetAuthMethod (
    DWORD dwAuthMethod)
{
    BOOL bRet = FALSE;
    if (m_bValid) {
        m_dwAuthMethod = dwAuthMethod;
        bRet = TRUE;
    }
    return bRet;
}


extern    HKEY
        GetClientUserHandle(
            IN REGSAM samDesired
    );

CPortConfigDataMgr::CPortConfigDataMgr (
    LPCTSTR pszPortName):
    m_bValid (FALSE),
    m_pszPortName (NULL)
{
    if (AssignString (m_pszPortName, pszPortName)) {
        m_bValid = TRUE;
    }
}

/*++

Routine Description:

    Delete everyone's personal setting for the http printer


Return Value:

--*/
BOOL
CPortConfigDataMgr::DeleteAllSettings (
    VOID)
{
    BOOL bRet = FALSE;
    WCHAR szKey[MAX_PATH];
    DWORD cchKey;
    DWORD i;
    FILETIME ftLastWriteTime;
    DWORD dwError;
    static LPWSTR szDotDefault = L".Default";
    HANDLE      hToken;

    if (hToken = RevertToPrinterSelf()) {


        //
        // Go through all keys and fix them up.
        //
        for (i=0; TRUE; i++) {

            cchKey = COUNTOF(szKey);

            dwError = RegEnumKeyEx(HKEY_USERS,
                                   i,
                                   szKey,
                                   &cchKey,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &ftLastWriteTime);

            if (dwError != ERROR_SUCCESS)
                break;

            if (!_wcsicmp(szKey, szDotDefault) || wcschr(szKey, L'_'))
                continue;

            DeletePerUserSettings (szKey);

        }
        DeletePerPortSettings ();

        bRet = ImpersonatePrinterClient(hToken);
    }
    return bRet;
}


BOOL
CPortConfigDataMgr::GetPortSettings (
    HKEY hkPath,
    CPortConfigData* pConfigData) CONST
{
    LONG  lStat;
    HKEY  hkPortNames;
    HKEY  hkThisPortName;
    BOOL  bRet = FALSE;
    DWORD dwType;
    DWORD dwSize;
    DWORD dwAuthMethod;
    PBYTE pbData = NULL;

    //
    // Open registry key for Provider-Name.
    //
    lStat = RegOpenKeyEx(hkPath, g_szRegPorts, 0, KEY_READ, &hkPortNames);

    if (lStat == ERROR_SUCCESS) {

        lStat = RegOpenKeyEx(hkPortNames, m_pszPortName, 0, KEY_READ, &hkThisPortName);

        if (lStat == ERROR_SUCCESS) {

            dwType = REG_DWORD;
            dwSize = sizeof (dwAuthMethod);

            lStat = RegQueryValueEx (hkThisPortName, g_szAuthMethod, 0, &dwType, (LPBYTE) &dwAuthMethod, &dwSize);

            if (lStat == ERROR_SUCCESS && dwType == REG_DWORD) {

                switch (dwAuthMethod)
                {
                case AUTH_ANONYMOUS:
                case AUTH_NT:
                case AUTH_OTHER:
                    break;

                default:
                    //
                    //  If the register is messed up because of upgrade,
                    //  we set it to anonymous by default.
                    //
                    dwAuthMethod = AUTH_ANONYMOUS;
                    break;
                }

                pConfigData->SetAuthMethod (dwAuthMethod);

                //
                // Read the user name from the registry.
                //
                if (SUCCEEDED(SafeRegQueryValueAsStringPointer(hkThisPortName,
                                                               g_szUserName,
                                                               reinterpret_cast<PWSTR *>(&pbData),
                                                               0))) {

                    pConfigData->SetUserName(reinterpret_cast<LPCTSTR>(pbData));
                }

                FreeSplMem(pbData);

                //
                // Read the password from the registry.
                //
                dwType = REG_BINARY;
                dwSize = 0;

                lStat = RegQueryValueEx (hkThisPortName, g_szPassword, 0, &dwType, NULL, &dwSize);

                if (lStat == ERROR_SUCCESS && dwType == REG_BINARY) {

                    pbData = new BYTE [dwSize];

                    lStat = RegQueryValueEx (hkThisPortName, g_szPassword, 0, &dwType, pbData, &dwSize);

                    if (lStat == ERROR_SUCCESS) {

                        LPTSTR  pPassword;
                        DWORD   dwPasswordSize;

                        //
                        // Decrypt the password
                        //
                        if (DecryptData (pbData, dwSize, (PBYTE *)&pPassword, &dwPasswordSize)) {

                            pConfigData->SetPassword (pPassword);
                        }
                    }

                    delete [] pbData;
                }

                bRet = TRUE;
            }

            RegCloseKey (hkThisPortName);

        } else {

            SetLastError(lStat);
        }

        RegCloseKey(hkPortNames);

    } else {

        SetLastError(lStat);
    }

    return bRet;
}

BOOL
CPortConfigDataMgr::SetPortSettings (
    HKEY hkPath,
    CPortConfigData &ConfigData)
{
    LONG lStat;
    HKEY hkPortNames;
    HKEY hkThisPortName;
    BOOL bRet = FALSE;

    lStat = RegCreateKeyEx(hkPath,
                           g_szRegPorts,
                           0,
                           NULL,
                           0,
                           KEY_WRITE,
                           NULL,
                           &hkPortNames,
                           NULL);

    if (lStat == ERROR_SUCCESS) {


        lStat = RegCreateKeyEx(hkPortNames,
                               m_pszPortName,
                               0,
                               NULL,
                               0,
                               KEY_WRITE,
                               NULL,
                               &hkThisPortName,
                               NULL);

        if (lStat == ERROR_SUCCESS) {

            DWORD dwAuthMethod = ConfigData.GetAuthMethod ();

            lStat = RegSetValueEx(hkThisPortName,
                                  g_szAuthMethod,
                                  0,
                                  REG_DWORD,
                                  (LPBYTE)&dwAuthMethod,
                                  sizeof (dwAuthMethod));

            bRet = (lStat == ERROR_SUCCESS ? TRUE : FALSE);


            if (lStat == ERROR_SUCCESS) {

                LPCTSTR pUserName = ConfigData.GetUserName ();
                LPCTSTR pPassword = ConfigData.GetPassword ();

                if (pUserName) {

                    lStat = RegSetValueEx(hkThisPortName,
                                          g_szUserName,
                                          0,
                                          REG_SZ,
                                          (LPBYTE) pUserName,
                                          sizeof (TCHAR) * (1 + lstrlen (pUserName)));
                } else
                    lStat = RegDeleteValue (hkThisPortName, g_szUserName);

                if (pPassword) {

                    LPBYTE pEncryptedPassword;
                    DWORD dwEncryptedSize;

                    if (EncryptData ((PBYTE) pPassword,
                                     sizeof (TCHAR) * (lstrlen (pPassword) + 1),
                                     &pEncryptedPassword,
                                     &dwEncryptedSize)) {

                        lStat = RegSetValueEx(hkThisPortName,
                                              g_szPassword,
                                              0,
                                              REG_BINARY,
                                              pEncryptedPassword,
                                              dwEncryptedSize);
                    }
                    else
                        lStat = GetLastError ();

                } else
                    lStat = RegDeleteValue (hkThisPortName, g_szPassword);

                bRet = TRUE;

            }

            RegCloseKey(hkThisPortName);
        }

        RegCloseKey(hkPortNames);

    }

    return bRet;
}

BOOL
CPortConfigDataMgr::SetPerPortSettings (
    CPortConfigData &ConfigData)
{
    LONG lStat;
    HKEY hkPath;
    BOOL bRet = FALSE;
    HANDLE      hToken;

    if (hToken = RevertToPrinterSelf()) {


        lStat = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                               g_szRegProvider,
                               0,
                               NULL,
                               0,
                               KEY_WRITE,
                               NULL,
                               &hkPath,
                               NULL);

        if (lStat == ERROR_SUCCESS) {

            bRet = SetPortSettings (hkPath, ConfigData);

            RegCloseKey (hkPath);

        }


        if (!ImpersonatePrinterClient(hToken))
            bRet = FALSE;
    }


    return bRet;
}

BOOL
CPortConfigDataMgr::SetPerUserSettings (
    CPortConfigData &ConfigData)
{
    LONG lStat;
    HKEY hkPath;
    HKEY hkPortNames;
    HKEY hkCurUser;
    BOOL bRet = FALSE;



    hkCurUser = GetClientUserHandle (KEY_WRITE);

    if (hkCurUser) {

        lStat = RegCreateKeyEx(hkCurUser,
                               g_szPerUserPath,
                               0,
                               NULL,
                               0,
                               KEY_WRITE,
                               NULL,
                               &hkPath,
                               NULL);

        if (lStat == ERROR_SUCCESS) {

            bRet = SetPortSettings (hkPath, ConfigData);

            RegCloseKey (hkPath);
        }

        RegCloseKey (hkCurUser);
    }

    return bRet;

}


BOOL
CPortConfigDataMgr::GetPerPortSettings (
    CPortConfigData* pConfigData) CONST
{
    LONG lStat;
    HKEY hkPath;
    BOOL bRet = FALSE;

    HANDLE      hToken;

    if (hToken = RevertToPrinterSelf()) {


        lStat = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegProvider, 0, KEY_READ, &hkPath);

        if (lStat == ERROR_SUCCESS) {

            bRet = GetPortSettings (hkPath, pConfigData);

            RegCloseKey (hkPath);

        }

        if (!ImpersonatePrinterClient(hToken))
            bRet = FALSE;
    }


    return bRet;
}

BOOL
CPortConfigDataMgr::GetPerUserSettings (
    CPortConfigData* pConfigData) CONST
{
    LONG lStat;
    HKEY hkPath;
    HKEY hkCurUser;
    BOOL bRet = FALSE;

    hkCurUser = GetClientUserHandle (KEY_WRITE);

    if (hkCurUser) {

        lStat = RegOpenKeyEx(hkCurUser, g_szPerUserPath, 0, KEY_READ, &hkPath);

        if (lStat == ERROR_SUCCESS) {

            bRet = GetPortSettings (hkPath, pConfigData);

            RegCloseKey (hkPath);
        }

        RegCloseKey (hkCurUser);
    }

    return bRet;

}

BOOL
CPortConfigDataMgr::GetCurrentSettings (
    CPortConfigData* pConfigData) CONST
{
    BOOL bRet = FALSE;

    bRet = GetPerUserSettings (pConfigData);

    if (!bRet) {
        bRet = GetPerPortSettings (pConfigData);
    }

    return bRet;
}



BOOL
CPortConfigDataMgr::DeleteSettings (
    HKEY hkPath)
{
    LONG lStat;
    HKEY hkPortNames;
    BOOL bRet = FALSE;

    lStat = RegOpenKeyEx(hkPath,
                         g_szRegPorts,
                         0,
                         KEY_ALL_ACCESS,
                         &hkPortNames);

    if (lStat == ERROR_SUCCESS) {

        lStat = RegDeleteKey(hkPortNames,
                             m_pszPortName);

        RegCloseKey(hkPortNames);

        bRet = (lStat == ERROR_SUCCESS ? TRUE : FALSE);

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("RegOpenKeyEx (%s) failed: Error = %d"), g_szRegPorts, lStat));
    }

    return bRet;
}


BOOL
CPortConfigDataMgr::DeletePerPortSettings (
    VOID)
{
    LONG lStat;
    HKEY hkPath;
    HKEY hkPortNames;
    BOOL bRet = FALSE;

    lStat = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         g_szRegProvider,
                         0,
                         KEY_ALL_ACCESS,
                         &hkPath);

    if (lStat == ERROR_SUCCESS) {

        bRet = DeleteSettings (hkPath);
        RegCloseKey(hkPath);

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("RegOpenKeyEx (%s) failed: Error = %d"), g_szRegProvider, lStat));
    }

    return bRet;

}

BOOL
CPortConfigDataMgr::DeletePerUserSettings (
    LPTSTR pUser)

{
    LONG lStat;
    HKEY hkPath;
    HKEY hkCurUser;
    BOOL bRet = FALSE;

    lStat = RegOpenKeyEx( HKEY_USERS, pUser, 0,KEY_ALL_ACCESS, &hkCurUser);

    if (lStat == ERROR_SUCCESS) {

        lStat = RegOpenKeyEx(hkCurUser, g_szPerUserPath, 0, KEY_ALL_ACCESS, &hkPath);

        if (lStat == ERROR_SUCCESS) {

            bRet = DeleteSettings (hkPath);

            RegCloseKey (hkPath);
        }

        RegCloseKey (hkCurUser);
    }

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\inetpp2\server\inetport.cxx ===
/*****************************************************************************\
* MODULE: inetport.cxx
*
* The module contains routines for handling the INETPP functionality.  Use
* of these routines require the locking/unlocking of a critical-section
* to maninpulate the INIMONPORT list.  All internal routines assume the
* crit-sect is locked prior to executing.  CheckMonCrit() is a debugging
* call to verify the monitor-crit-sect is locked.
*
* NOTE: Each of the Inetmon*, InetMonPort calls must be protected by the
*       global-crit-sect.
*       If a new routine is added to this module which is to be called from
*       another module, be sure to include the call to (semCheckCrit), so
*       that the debug-code can catch unprotected access.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   14-Nov-1997 ChrisWil    Added local-spooling functionality.
*   10-Jul-1998 WeihaiC     Change Authentication Dialog Code
*
\*****************************************************************************/

#in