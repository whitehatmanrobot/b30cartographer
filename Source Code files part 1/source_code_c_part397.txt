D
ChgOrdTraceCoc(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_COMMAND Coc,
    IN PCHAR  Text
    )

/*++

Routine Description:

    Print a change order trace record using the change order command and the
    Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCoc:"


    ULONGLONG  FileRef = QUADZERO;

    DebPrint(Severity,
             (PUCHAR) CO_TRACE_FORMAT,
             Debsub,
             uLineNo,
             (Coc != NULL) ? Coc->ChangeOrderGuid.Data1 : 0,
             (Coc != NULL) ? Coc->CxtionGuid.Data1 : 0,
             (Coc != NULL) ? Coc->FileVersionNumber : 0,
             PRINTQUAD(FileRef),
             (Coc != NULL) ? Coc->FileName : L"<Null Coc>",
             Text);

}



VOID
ChgOrdTraceCocW(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_COMMAND Coc,
    IN PCHAR  Text,
    IN ULONG  WStatus
    )

/*++

Routine Description:

    Print a change order trace record using the change order command and the
    Text string and Win32 status.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ChgOrdTraceCocW:"


    CHAR Tstr[256];

    _snprintf(Tstr, sizeof(Tstr), "%s (%s)", Text, ErrLabelW32(WStatus));
    Tstr[sizeof(Tstr)-1] = '\0';


    ChgOrdTraceCoc(Severity, Debsub, uLineNo, Coc, Tstr);

}




VOID
ReplicaStateTrace(
    IN ULONG           Severity,
    IN PCHAR           Debsub,
    IN ULONG           uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN PREPLICA        Replica,
    IN ULONG           Status,
    IN PCHAR           Text
    )

/*++

Routine Description:

    Print a replica state trace record using the command packet and the
    status and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ReplicaStateTrace:"


    PWSTR ReplicaName;

    if ((Replica != NULL)  &&
        (Replica->ReplicaName != NULL) &&
        (Replica->ReplicaName->Name != NULL)) {
        ReplicaName = Replica->ReplicaName->Name;
    } else {
        ReplicaName = L"<null>";
    }

    DebPrint(Severity,
             (PUCHAR) REPLICA_TRACE_FORMAT,
             Debsub,
             uLineNo,
             PtrToUlong(Cmd),
             (Cmd != NULL) ? Cmd->Command : 0xFFFF,
             (Cmd != NULL) ? Cmd->Flags   : 0xFFFF,
             ReplicaName,
             ReplicaAddrToId(Replica),
             (Replica != NULL) ? RSS_NAME(Replica->ServiceState) : "<null>",
             Status,
             Text);
}




VOID
ReplicaStateTrace2(
    IN ULONG           Severity,
    IN PCHAR           Debsub,
    IN ULONG           uLineNo,
    IN PREPLICA        Replica,
    IN PCHAR           Text
    )

/*++

Routine Description:

    Print a cxtion table access trace record for the replica using the
    Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ReplicaStateTrace2:"


    PWSTR ReplicaName;

    if ((Replica != NULL)  &&
        (Replica->ReplicaName != NULL) &&
        (Replica->ReplicaName->Name != NULL)) {
        ReplicaName = Replica->ReplicaName->Name;
    } else {
        ReplicaName = L"<null>";
    }

    DebPrint(Severity,
             (PUCHAR) REPLICA_TRACE_FORMAT2,
             Debsub,
             uLineNo,
             PtrToUlong(Replica),
             ReplicaName,
             ReplicaAddrToId(Replica),
             (Replica != NULL) ? RSS_NAME(Replica->ServiceState) : "<null>",
             Text);
}




VOID
CxtionStateTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCXTION  Cxtion,
    IN PREPLICA Replica,
    IN ULONG    Status,
    IN PCHAR    Text
    )

/*++

Routine Description:

    Print a connection state trace record using the cxtion and the
    status and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "CxtionStateTrace:"


    PWSTR ReplicaName = L"<null>";
    PWSTR  CxtName = L"<null>";
    PCHAR  CxtState = "<null>";
    ULONG  Ctxg = 0, Flags = 0;
    PCHAR  CxtDirection = "?-";

    CHAR   FBuf[120];


    if ((Replica != NULL)  &&
        (Replica->ReplicaName != NULL) &&
        (Replica->ReplicaName->Name != NULL)) {
        ReplicaName = Replica->ReplicaName->Name;
    }


    if (Cxtion != NULL) {
        Flags = Cxtion->Flags;
        CxtState = GetCxtionStateName(Cxtion);
        CxtDirection = Cxtion->Inbound ? "I-" : "O-";

        if (Cxtion->Name != NULL) {
            if (Cxtion->Name->Name != NULL) {
                CxtName = Cxtion->Name->Name;
            }
            if (Cxtion->Name->Guid != NULL) {
                Ctxg = Cxtion->Name->Guid->Data1;
            }
        }
    }


    DebPrint(Severity,
             (PUCHAR) CXTION_TRACE_FORMAT,
             Debsub,
             uLineNo,
             Ctxg,
             CxtName,
             CxtDirection,
             CxtState,
             ReplicaName,
             ReplicaAddrToId(Replica),
             (Replica != NULL) ? RSS_NAME(Replica->ServiceState) : "<null>",
             Status,
             Text);


    FrsFlagsToStr(Flags, CxtionFlagNameTable, sizeof(FBuf), FBuf);

    DebPrint(Severity, (PUCHAR) ":X: %08x, Flags [%s]\n", Debsub, uLineNo, Ctxg, FBuf);


}



VOID
CmdPktTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN PCHAR    Text
    )

/*++

Routine Description:

    Print a command packet trace record using the Cmd and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "CmdPktTrace:"

    ULONG CmdCode = 0, Flags = 0, Ctrl = 0, Tout = 0, TQ = 0, Err = 0;

    if (Cmd != NULL) {
        CmdCode = (ULONG) Cmd->Command;
        Flags   = (ULONG) Cmd->Flags;
        Ctrl    = (ULONG) Cmd->Control;
        Tout    = Cmd->Timeout;
        TQ      = PtrToUlong(Cmd->TargetQueue);
        Err     = Cmd->ErrorStatus;
    }

    DebPrint(Severity,
             (PUCHAR) ":Cd: %08x, Cmd %04x, Flg %04x, Ctrl %04x, Tout %08x, TQ %08x, Err %d [%s]\n",
             Debsub,
             uLineNo,
             PtrToUlong(Cmd),     CmdCode,  Flags,    Ctrl,      Tout,      TQ,      Err,   Text);

}



VOID
SendCmdTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN ULONG    WStatus,
    IN PCHAR    Text
    )

/*++

Routine Description:

    Print a send command packet trace record using the Cmd and the
    status and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "SendCmdTrace:"


    PCXTION  Cxtion;
    PWSTR  CxtTo = L"<null>";
    ULONG  Ctxg = 0, PktLen = 0;


    if (Cmd != NULL) {
        Cxtion = SRCxtion(Cmd);

        if ((Cxtion != NULL) &&
            (Cxtion->Name != NULL) &&
            (Cxtion->Name->Guid != NULL)) {

            Ctxg = Cxtion->Name->Guid->Data1;
        }

        if (SRCommPkt(Cmd) != NULL) {
            PktLen = SRCommPkt(Cmd)->PktLen;
        }

        if ((SRTo(Cmd) != NULL) && (SRTo(Cmd)->Name != NULL)) {
            CxtTo = SRTo(Cmd)->Name;
        }

    }

    DebPrint(Severity,
             (PUCHAR)  ":SR: Cmd %08x, CxtG %08x, WS %s, To   %ws Len:  (%3d) [%s]\n",
             Debsub,
             uLineNo,
             PtrToUlong(Cmd),          Ctxg,     ErrLabelW32(WStatus), CxtTo,  PktLen,     Text);

}




VOID
ReceiveCmdTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCOMMAND_PACKET Cmd,
    IN PCXTION  Cxtion,
    IN ULONG    WStatus,
    IN PCHAR    Text
    )

/*++

Routine Description:

    Print a rcv command packet trace record using the Cmd and the
    status and Text string.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "ReceiveCmdTrace:"


    PWSTR  CxtFrom = L"<null>";
    ULONG  Ctxg = 0, PktLen = 0, CmdCode = 0;


    if (Cmd != NULL) {
        CmdCode = (ULONG) Cmd->Command;


        if (Cxtion != NULL) {
            CxtFrom = Cxtion->PartnerDnsName;

            if ((Cxtion->Name != NULL) && (Cxtion->Name->Guid != NULL)) {
                Ctxg = Cxtion->Name->Guid->Data1;
            }
        }
    }

    DebPrint(Severity,
             (PUCHAR)  ":SR: Cmd %08x, CxtG %08x, WS %s, From %ws CCod: (%03x) [%s]\n",
             Debsub,
             uLineNo,
             PtrToUlong(Cmd),          Ctxg,  ErrLabelW32(WStatus), CxtFrom, CmdCode, Text);


}



VOID
StageFileTrace(
    IN ULONG      Severity,
    IN PCHAR      Debsub,
    IN ULONG      uLineNo,
    IN GUID       *CoGuid,
    IN PWCHAR     FileName,
    IN PULONGLONG pFileSize,
    IN PULONG     pFlags,
    IN PCHAR      Text
    )

/*++

Routine Description:

    Print a stage file acquire/release trace record.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "StageFileTrace:"


    ULONGLONG  FileSize = QUADZERO;
    ULONG  Flags = 0, CoGuidData = 0;
    CHAR   FBuf[120];

    Flags = (pFlags != NULL) ? *pFlags : 0;
    CoGuidData = (CoGuid != NULL) ? CoGuid->Data1 : 0;
    pFileSize = (pFileSize == NULL) ? &FileSize : pFileSize;

    DebPrint(Severity,
             (PUCHAR)  ":: CoG %08x, Flgs %08x,    %5d, Siz %08x %08x, FN: %-15ws, [%s]\n",
             Debsub,
             uLineNo,
             CoGuidData,
             Flags,
             0,
             PRINTQUAD(*pFileSize),
             FileName,
             Text);


    FrsFlagsToStr(Flags, StageFlagNameTable, sizeof(FBuf), FBuf);

    DebPrint(Severity,
             (PUCHAR) ":: CoG %08x, Flags [%s]\n",
             Debsub,
             uLineNo,
             CoGuidData,
             FBuf);


}



VOID
SetCxtionStateTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN ULONG    uLineNo,
    IN PCXTION  Cxtion,
    IN ULONG    NewState
    )
/*++

Routine Description:

    Print a change to cxtion state trace record using the Cxtion and the NewState.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "SetCxtionStateTrace:"

    PWSTR  CxtName     = L"<null>";
    PWSTR  PartnerName = L"<null>";
    PWSTR  PartSrvName = L"<null>";

    PCHAR  CxtionState = "<null>";
    ULONG  Ctxg = 0;

    PCHAR  CxtDirection = "?-";


    if (Cxtion != NULL) {
        CxtionState = GetCxtionStateName(Cxtion);


        if (Cxtion->Name != NULL) {

            if (Cxtion->Name->Guid != NULL) {
                Ctxg = Cxtion->Name->Guid->Data1;
            }

            if (Cxtion->Name->Name != NULL) {
                CxtName = Cxtion->Name->Name;
            }
        }

        CxtDirection = Cxtion->Inbound ? "<-" : "->";

        if ((Cxtion->Partner != NULL) && (Cxtion->Partner->Name != NULL)) {
            PartnerName = Cxtion->Partner->Name;
        }

        if (Cxtion->PartSrvName != NULL) {
            PartSrvName = Cxtion->PartSrvName;
        }
    }

    DebPrint(Severity,
             (PUCHAR)  ":X: %08x, state change from %s to %s for %ws %s %ws\\%ws\n",
             Debsub,
             uLineNo,
             Ctxg,
             CxtionState,
             CxtionStateNames[NewState],
             CxtName,
             CxtDirection,
             PartnerName,
             PartSrvName);

}


#define  FRS_TRACK_FORMAT_1     ":T: CoG: %08x  CxtG: %08x    [%-15s]  Name: %ws\n"
#define  FRS_TRACK_FORMAT_2     ":T: EventTime: %-40s Ver:  %d\n"
#define  FRS_TRACK_FORMAT_3     ":T: FileG:     %-40s FID:  %08x %08x\n"
#define  FRS_TRACK_FORMAT_4     ":T: ParentG:   %-40s Size: %08x %08x\n"
#define  FRS_TRACK_FORMAT_5     ":T: OrigG:     %-40s Attr: %08x\n"
#define  FRS_TRACK_FORMAT_6     ":T: LocnCmd:   %-8s State: %-24s ReplicaName: %ws (%d)\n"
#define  FRS_TRACK_FORMAT_7     ":T: CoFlags:   %08x   [%s]\n"
#define  FRS_TRACK_FORMAT_8     ":T: UsnReason: %08x   [%s]\n"
#define  FRS_TRACK_FORMAT_9     ":T: CxtionG:   %-40s\n"
#define  FRS_TRACK_FORMAT_10    ":T: CheckSum:  %08x %08x %08x %08x\n"
#define  FRS_TRACK_FORMAT_11    ":T: CoArrival: %-40s\n"
#define  FRS_TRACK_FORMAT_12    ":T: FullPathName: %ws\n"


VOID
FrsTrackRecord(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN PCHAR  Text
    )

/*++

Routine Description:

    Print a change order file update tracking record using the change order
    entry and Text string.

 7/29-13:40:58 :T: CoG: 779800ea  CxtG: 000001bb    [RemCo         ]   Name: Thous_5555_988
 7/29-13:40:58 :T: EventTime: Sat Jul 29, 2000 12:05:57                Ver:  0
 7/29-13:40:58 :T: FileG:     b49362c3-216d-4ff4-a2d067fd031e436f      FID   00050000 0000144e
 7/29-13:40:58 :T: ParG:      8d60157a-7dc6-4dfc-acf3eca3c6e4d5d8      Size: 00000000 00000030
 7/29-13:40:58 :T: OrigG:     8071d94a-a659-4ff7-a9467d8d6ad18aec      Attr: 00000020
 7/29-13:40:58 :T: LocnCmd:   Create   State: IBCO_INSTALL_DEL_RETRY   ReplicaName: Replica-A (1)
 7/29-13:40:58 :T: COFlags
 7/29-13:40:58 :T: UsnReason: 00000002   [DatExt ]

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsTrackRecord:"

    PCHANGE_ORDER_COMMAND          CoCmd;
    PDATA_EXTENSION_CHECKSUM       CocDataChkSum     = NULL;
    PDATA_EXTENSION_RETRY_TIMEOUT  CoCmdRetryTimeout = NULL;
    PCHANGE_ORDER_RECORD_EXTENSION CocExt            = NULL;

    CHAR                  FlagBuffer[160];
    CHAR                  GuidStr1[GUID_CHAR_LEN];
    CHAR                  TimeStr[TIME_STRING_LENGTH];


    if (!DoDebug(Severity, Debsub) || (Coe == NULL) || (Text == NULL)) {
        return;
    }
    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();

    try {

        CoCmd = &Coe->Cmd;

        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_1,
                               CoCmd->ChangeOrderGuid.Data1, CoCmd->CxtionGuid.Data1,
                               Text, CoCmd->FileName);

        FileTimeToString((PFILETIME) &CoCmd->EventTime.QuadPart, TimeStr);
        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_2,
                               TimeStr, CoCmd->FileVersionNumber);

        GuidToStr(&CoCmd->FileGuid, GuidStr1);
        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_3,
                               GuidStr1, PRINTQUAD(Coe->FileReferenceNumber));

        GuidToStr(&CoCmd->NewParentGuid, GuidStr1);
        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_4,
                               GuidStr1, PRINTQUAD(CoCmd->FileSize));

        GuidToStr(&CoCmd->OriginatorGuid, GuidStr1);
        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_5,
                               GuidStr1, CoCmd->FileAttributes);

        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_6,
                               CoLocationNames[GET_CO_LOCATION_CMD(Coe->Cmd, Command)],
                               PRINT_CO_STATE(Coe), Coe->NewReplica->ReplicaName->Name,
                               CoCmd->NewReplicaNum);

        FrsFlagsToStr(CoCmd->Flags, CoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_7,
                               CoCmd->Flags, FlagBuffer);

        FrsFlagsToStr(CoCmd->ContentCmd, UsnReasonNameTable, sizeof(FlagBuffer), FlagBuffer);
        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_8,
                               CoCmd->ContentCmd, FlagBuffer);

        GuidToStr(&CoCmd->CxtionGuid, GuidStr1);
        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_9,
                               GuidStr1);

        CocExt = CoCmd->Extension;
		if (CocExt != NULL) {
			CocDataChkSum = DbsDataExtensionFind(CocExt, DataExtend_MD5_CheckSum);
		}

        if ((CocDataChkSum != NULL) &&
            (CocDataChkSum->Prefix.Size == sizeof(DATA_EXTENSION_CHECKSUM))) {

            DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_10,
                                   *(((ULONG *) &CocDataChkSum->Data[0])),
                                   *(((ULONG *) &CocDataChkSum->Data[4])),
                                   *(((ULONG *) &CocDataChkSum->Data[8])),
                                   *(((ULONG *) &CocDataChkSum->Data[12])));
        } else {
            DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_10, 0, 0, 0, 0);
        }

		if (CocExt != NULL) {
			CoCmdRetryTimeout = DbsDataExtensionFind(CocExt, DataExtend_Retry_Timeout);
		}

        if ((CoCmdRetryTimeout != NULL) &&
            (CoCmdRetryTimeout->FirstTryTime != QUADZERO)) {
            FileTimeToString((PFILETIME) &CoCmdRetryTimeout->FirstTryTime, TimeStr);
        } else {
            strcpy(TimeStr, "<null>");
        }
        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_11,
                               TimeStr);

        DebPrintTrackingNoLock(Severity, (PUCHAR) FRS_TRACK_FORMAT_12,
                               ((Coe->FullPathName != NULL) ? Coe->FullPathName : L"<null>"));

    } finally {
        //
        // If the above took an exception make sure we drop the lock.
        //
        DebUnLock();
    }
}


VOID
FrsPrintLongUStr(
    IN ULONG Severity,
    IN PCHAR Debsub,
    IN ULONG uLineNo,
    IN PWCHAR  UStr
    )

/*++

Routine Description:

    Print a long unicode string on multiple lines.

Arguments:


Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsPrintLongUStr:"

    ULONG  i, j, Len;
    WCHAR  Usave;

    if (!DoDebug(Severity, Debsub) || (UStr == NULL)) {
        return;
    }

    //
    // Get debug lock so our output stays in one piece.
    //
    DebLock();

    try {

        Len = wcslen(UStr);
        i = 0;
        j = 0;

        while (i < Len) {
            i += 60;

            if (i > Len) {
                i = Len;
            }

            Usave = UStr[i];
            UStr[i] = UNICODE_NULL;
            FRS_DEB_PRINT("++ %ws\n", &UStr[j]);
            UStr[i] = Usave;

            j = i;
        }

    } finally {
        //
        // If the above took an exception make sure we drop the lock.
        //
        DebUnLock();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\frstable.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frstable.c

Abstract:
    These routines manage the tables used by the FRS.

Author:
    Billy J. Fuller 19-Apr-1997

Environment
    User mode winnt

--*/


#include <ntreppch.h>
#pragma  hdrstop

#define DEBSUB  "FRSTABLE:"

#include <frs.h>


PVOID
GTabAllocTableMem(
    IN PRTL_GENERIC_TABLE   Table,
    IN DWORD                NodeSize
    )
/*++
Routine Description:
    Allocate space for a table entry. The entry includes the user-defined
    struct and some overhead used by the generic table routines. The
    generic table routines call this function when they need memory.

Arguments:
    Table       - Address of the table (not used).
    NodeSize    - Bytes to allocate

Return Value:
    Address of newly allocated memory.
--*/
{
    return FrsAlloc(NodeSize);
}




VOID
GTabFreeTableMem(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                Buffer
    )
/*++
Routine Description:
    Free the space allocated by GTAlloc(). The generic table
    routines call this function to free memory.

Arguments:
    Table   - Address of the table (not used).
    Buffer  - Address of previously allocated memory

Return Value:
    None.
--*/
{
    FrsFree(Buffer);
}


RTL_GENERIC_COMPARE_RESULTS
GTabCmpTableEntry(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                TableEntry1,
    IN PVOID                TableEntry2
    )
/*++
Routine Description:
    Compare two entries in the table for guid/names.

Arguments:
    Table   - Address of the table (not used).
    Entry1  - PGEN_ENTRY
    Entry2  - PGEN_ENTRY

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
    INT             Cmp;
    PGEN_ENTRY      Entry1  = (PGEN_ENTRY)TableEntry1;
    PGEN_ENTRY      Entry2  = (PGEN_ENTRY)TableEntry2;

    //
    // Primary key must be present
    //
    FRS_ASSERT(Entry1->Key1 && Entry2->Key1);

    //
    // Compare primary keys
    //
    Cmp = memcmp(Entry1->Key1, Entry2->Key1, sizeof(GUID));
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0) {
        return (GenericGreaterThan);
    }

    //
    // No second key; done
    //
    if (!Entry1->Key2 || !Entry2->Key2)
        return GenericEqual;

    //
    // Compare secondary keys
    //
    Cmp = _wcsicmp(Entry1->Key2, Entry2->Key2);
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    return (GenericEqual);
}


RTL_GENERIC_COMPARE_RESULTS
GTabCmpTableNumberEntry(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                TableEntry1,
    IN PVOID                TableEntry2
    )
/*++
Routine Description:
    Compare two entries in the table for number

Arguments:
    Table   - Address of the table (not used).
    Entry1  - PGEN_ENTRY
    Entry2  - PGEN_ENTRY

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
    INT             Cmp;
    PGEN_ENTRY      Entry1  = (PGEN_ENTRY)TableEntry1;
    PGEN_ENTRY      Entry2  = (PGEN_ENTRY)TableEntry2;

    //
    // Primary key must be present
    //
    FRS_ASSERT(Entry1->Key1 && Entry2->Key1);

    //
    // Compare primary keys
    //
    Cmp = memcmp(Entry1->Key1, Entry2->Key1, sizeof(ULONG));
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    return GenericEqual;
}


RTL_GENERIC_COMPARE_RESULTS
GTabCmpTableFileTimeEntry(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                TableEntry1,
    IN PVOID                TableEntry2
    )
/*++
Routine Description:
    Compare two entries in the table for number

Arguments:
    Table   - Address of the table (not used).
    Entry1  - PGEN_ENTRY
    Entry2  - PGEN_ENTRY

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
    INT             Cmp;
    PGEN_ENTRY      Entry1  = (PGEN_ENTRY)TableEntry1;
    PGEN_ENTRY      Entry2  = (PGEN_ENTRY)TableEntry2;

    //
    // Primary key must be present
    //
    FRS_ASSERT(Entry1->Key1 && Entry2->Key1);

    //
    // Compare primary keys
    //
    Cmp = CompareFileTime((PFILETIME)Entry1->Key1, (PFILETIME)Entry2->Key1);
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    return GenericEqual;
}


RTL_GENERIC_COMPARE_RESULTS
GTabCmpTableStringAndBoolEntry(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                TableEntry1,
    IN PVOID                TableEntry2
    )
/*++
Routine Description:
    Compare two entries in the table for data with strings used as key.

Arguments:
    Table   - Address of the table (not used).
    Entry1  - PGEN_ENTRY
    Entry2  - PGEN_ENTRY

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
    INT             Cmp;
    PGEN_ENTRY      Entry1  = (PGEN_ENTRY)TableEntry1;
    PGEN_ENTRY      Entry2  = (PGEN_ENTRY)TableEntry2;

    //
    // Primary key must be present
    //
    FRS_ASSERT(Entry1->Key1 && Entry2->Key1);

    //
    // Compare primary keys
    //
    Cmp = _wcsicmp((PWCHAR)(Entry1->Key1), (PWCHAR)(Entry2->Key1));
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    //
    // Compare secondary keys if they exist.
    //

    if ((Entry1->Key2 == NULL) || (Entry2->Key2 == NULL)) {
        return GenericEqual;
    }

    if (*(Entry1->Key2) == *(Entry2->Key2)) {
        return GenericEqual;
    } else if (*(Entry1->Key2) == FALSE) {
        return GenericLessThan;
    }

    return GenericGreaterThan;
}


RTL_GENERIC_COMPARE_RESULTS
GTabCmpTableStringEntry(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                TableEntry1,
    IN PVOID                TableEntry2
    )
/*++
Routine Description:
    Compare two entries in the table for data with strings used as key.

Arguments:
    Table   - Address of the table (not used).
    Entry1  - PGEN_ENTRY
    Entry2  - PGEN_ENTRY

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
    INT             Cmp;
    PGEN_ENTRY      Entry1  = (PGEN_ENTRY)TableEntry1;
    PGEN_ENTRY      Entry2  = (PGEN_ENTRY)TableEntry2;

    //
    // Primary key must be present
    //
    FRS_ASSERT(Entry1->Key1 && Entry2->Key1);

    //
    // Compare primary keys
    //
    Cmp = _wcsicmp((PWCHAR)(Entry1->Key1), (PWCHAR)(Entry2->Key1));
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    //
    // Compare secondary keys if they exist.
    //

    if ((Entry1->Key2 == NULL) || (Entry2->Key2 == NULL)) {
        return GenericEqual;
    }

    Cmp = _wcsicmp(Entry1->Key2, Entry2->Key2);
    if (Cmp < 0) {
        return (GenericLessThan);
    }
    if (Cmp > 0){
        return (GenericGreaterThan);
    }

    return GenericEqual;
}


VOID
GTabLockTable(
    PGEN_TABLE  GTable
    )
/*++
Routine Description:
    Lock the table

Arguments:
    GTable  - frs generic table

Return Value:
    None.
--*/
{
    EnterCriticalSection(&GTable->Critical);
}


VOID
GTabUnLockTable(
    PGEN_TABLE  GTable
    )
/*++
Routine Description:
    Unlock the table

Arguments:
    GTable  - frs generic table

Return Value:
    None.
--*/
{
    LeaveCriticalSection(&GTable->Critical);
}


PGEN_TABLE
GTabAllocNumberTable(
    VOID
    )
/*++
Routine Description:
    Initialize a generic table + lock for numbers.

Arguments:
    None.

Return Value:
    None.
--*/
{
    PGEN_TABLE  GTable;

    GTable = FrsAllocType(GEN_TABLE_TYPE);
    INITIALIZE_CRITICAL_SECTION(&GTable->Critical);
    RtlInitializeGenericTable(&GTable->Table,
                              GTabCmpTableNumberEntry,
                              GTabAllocTableMem,
                              GTabFreeTableMem,
                              NULL);
    return GTable;
}


PGEN_TABLE
GTabAllocFileTimeTable(
    VOID
    )
/*++
Routine Description:
    Initialize a generic table + lock for file time.

Arguments:
    None.

Return Value:
    None.
--*/
{
    PGEN_TABLE  GTable;

    GTable = FrsAllocType(GEN_TABLE_TYPE);
    INITIALIZE_CRITICAL_SECTION(&GTable->Critical);
    RtlInitializeGenericTable(&GTable->Table,
                              GTabCmpTableFileTimeEntry,
                              GTabAllocTableMem,
                              GTabFreeTableMem,
                              NULL);
    return GTable;
}


PGEN_TABLE
GTabAllocStringTable(
    VOID
    )
/*++
Routine Description:
    Initialize a generic table + lock for data with strings
    used as a key.

Arguments:
    None.

Return Value:
    None.
--*/
{
    PGEN_TABLE  GTable;

    GTable = FrsAllocType(GEN_TABLE_TYPE);
    INITIALIZE_CRITICAL_SECTION(&GTable->Critical);
    RtlInitializeGenericTable(&GTable->Table,
                              GTabCmpTableStringEntry,
                              GTabAllocTableMem,
                              GTabFreeTableMem,
                              NULL);
    return GTable;
}


PGEN_TABLE
GTabAllocStringAndBoolTable(
    VOID
    )
/*++
Routine Description:
    Initialize a generic table + lock for data with a string and bool
    used as a key.

Arguments:
    None.

Return Value:
    None.
--*/
{
    PGEN_TABLE  GTable;

    GTable = FrsAllocType(GEN_TABLE_TYPE);
    INITIALIZE_CRITICAL_SECTION(&GTable->Critical);
    RtlInitializeGenericTable(&GTable->Table,
                              GTabCmpTableStringAndBoolEntry,
                              GTabAllocTableMem,
                              GTabFreeTableMem,
                              NULL);
    return GTable;
}


PGEN_TABLE
GTabAllocTable(
    VOID
    )
/*++
Routine Description:
    Initialize a generic table + lock.

Arguments:
    None.

Return Value:
    None.
--*/
{
    PGEN_TABLE  GTable;

    GTable = FrsAllocType(GEN_TABLE_TYPE);
    INITIALIZE_CRITICAL_SECTION(&GTable->Critical);
    RtlInitializeGenericTable(&GTable->Table,
                              GTabCmpTableEntry,
                              GTabAllocTableMem,
                              GTabFreeTableMem,
                              NULL);
    return GTable;
}


VOID
GTabEmptyTableNoLock(
    IN PGEN_TABLE   GTable,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Free every entry in the frs generic table.  Caller has acquired the table lock.

Arguments:

    GTable   - frs generic table
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    PGEN_ENTRY  Entry;  // Next entry in table
    PGEN_ENTRY  Dup;    // Next entry in table
    PVOID       Data;

    //
    // For every entry in the table
    //
    while (Entry = RtlEnumerateGenericTable(&GTable->Table, TRUE)) {
        //
        // Delete the dups
        //
        while (Dup = Entry->Dups) {
            Entry->Dups = Dup->Dups;
            if (CallerFree) {
                //
                // Free up the callers Datum
                //
                (*CallerFree)(Dup->Data);
            }
            Dup = FrsFree(Dup);
        }

        //
        // Delete the entry from the table
        //
        Data = Entry->Data;
        RtlDeleteElementGenericTable(&GTable->Table, Entry);
        if (CallerFree) {
            //
            // Free up the callers Datum
            //
            (*CallerFree)(Data);
        }
    }
}



VOID
GTabEmptyTable(
    IN PGEN_TABLE   GTable,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Free every entry in the frs generic table.

Arguments:

    GTable   - frs generic table
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    GTabLockTable(GTable);

    GTabEmptyTableNoLock(GTable, CallerFree);

    GTabUnLockTable(GTable);
}




PVOID
GTabFreeTable(
    IN PGEN_TABLE   GTable,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Undo the work done by GenTableInitialize.

Arguments:
    GTTable - Address of the gen table.
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    if (GTable == NULL) {
        return NULL;
    }

    //
    // Empty the table
    //
    GTabEmptyTable(GTable, CallerFree);

    DeleteCriticalSection(&GTable->Critical);
    return FrsFreeType(GTable);
}

PVOID
GTabLookupNoLock(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Data for an entry or NULL
--*/
{
    PVOID           Data;
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    Data = (Entry) ? Entry->Data : NULL;
    return Data;
}






PVOID
GTabLookup(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the data for an entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Data for an entry or NULL
--*/
{
    PVOID           Data;
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    GTabLockTable(GTable);
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    Data = (Entry) ? Entry->Data : NULL;
    GTabUnLockTable(GTable);
    return Data;
}


BOOL
GTabIsEntryPresent(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the entry in the table and return TRUE if found.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Boolean
--*/
{
    PVOID           Data;
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    GTabLockTable(GTable);
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    GTabUnLockTable(GTable);
    return (Entry != NULL);
}


PVOID
GTabLookupTableString(
    IN PGEN_TABLE   GTable,
    IN PWCHAR       Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the data for an entry in the table that is indexed by string.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Data for an entry or NULL
--*/
{
    PVOID           Data;
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = (GUID *)Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    GTabLockTable(GTable);
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    Data = (Entry) ? Entry->Data : NULL;
    GTabUnLockTable(GTable);
    return Data;
}


PGEN_ENTRY
GTabLookupEntryNoLock(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Find the data for an entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    Data for an entry or NULL
--*/
{
    PGEN_ENTRY      Entry;  // entry in table
    GEN_ENTRY       Key;    // Search key

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for any table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Search the table
    //
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    return Entry;
}





PGEN_ENTRY
GTabNextEntryNoLock(
    PGEN_TABLE  GTable,
    PVOID       *Key
    )
/*++
Routine Description:
    Return the entry for Key in GTable. The caller is responsible for
    insuring synchronization.

Arguments:
    GTable  - frs generic table
    Key     - NULL on first call

Return Value:
    The address of an entry in the table or NULL.
--*/
{
    PGEN_ENTRY  Entry;
    //
    // Return the entry's address
    //
    Entry = (PVOID)RtlEnumerateGenericTableWithoutSplaying(&GTable->Table, Key);
    return Entry;
}


PVOID
GTabNextDatumNoLock(
    PGEN_TABLE  GTable,
    PVOID       *Key
    )
/*++
Routine Description:
    Return the data for the entry for Key in GTable.
    Caller acquires the table lock.

Arguments:
    GTable  - frs generic table
    Key     - NULL on first call
    GetData - return the entry or the data for the entry

Return Value:
    The address of an entry in the table or NULL.
--*/
{
    PVOID       Data;
    PGEN_ENTRY  Entry;

    //
    // Return the address of the entry's data
    //
    Entry = GTabNextEntryNoLock(GTable, Key);
    Data = (Entry) ? Entry->Data : NULL;
    return Data;
}





PVOID
GTabNextDatum(
    PGEN_TABLE  GTable,
    PVOID       *Key
    )
/*++
Routine Description:
    Return the data for the entry for Key in GTable.

Arguments:
    GTable  - frs generic table
    Key     - NULL on first call
    GetData - return the entry or the data for the entry

Return Value:
    The address of an entry in the table or NULL.
--*/
{
    PVOID       Data;
    PGEN_ENTRY  Entry;

    //
    // Return the address of the entry's data
    //
    GTabLockTable(GTable);
    Entry = GTabNextEntryNoLock(GTable, Key);
    Data = (Entry) ? Entry->Data : NULL;
    GTabUnLockTable(GTable);
    return Data;
}






DWORD
GTabNumberInTable(
    PGEN_TABLE  GTable
    )
/*++
Routine Description:
    Return the number of entries in a table.

Arguments:
    GTable  - frs generic table

Return Value:
    Number of entries in the table.
--*/
{
    if (GTable) {
        return RtlNumberGenericTableElements(&GTable->Table);
    } else {
        return 0;
    }
}


PVOID
GTabInsertUniqueEntry(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN PVOID        Key1,
    IN PVOID        Key2
    )
/*++
Routine Description:
    Insert an entry into the table. If a duplicate is found then
    return the original entry. Do not insert in that case.

Arguments:
    GTable  - frs generic table
    NewData - data for the entry to insert
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    NULL if the entry was successfully inserted in the table.
    Pointer to the data from old entry if a collision is found.
--*/
{
    PGEN_ENTRY  OldEntry;   // Existing entry in the table
    BOOLEAN     IsNew;      // TRUE if insert found existing entry
    GEN_ENTRY   NewEntry;   // new entry to insert.
    PGEN_ENTRY  DupEntry;   // Newly allocated table entry for duplicate.

    //
    // Init the new entry. Have to typecast here becasue the GEN_ENTRY expects a GUID* and PWCHAR.
    //
    NewEntry.Data = NewData;
    NewEntry.Key1 = (GUID*)Key1;
    NewEntry.Key2 = (PWCHAR)Key2;
    NewEntry.Dups = NULL;

    //
    // Lock the table and Insert the entry
    //
    GTabLockTable(GTable);
    OldEntry = RtlInsertElementGenericTable(&GTable->Table,
                                            &NewEntry,
                                            sizeof(NewEntry),
                                            &IsNew);

    GTabUnLockTable(GTable);

    if (!IsNew) {
        return OldEntry;
    }

    return NULL;

}

PVOID
GTabInsertUniqueEntryNoLock(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN PVOID        Key1,
    IN PVOID        Key2
    )
/*++
Routine Description:
    Insert an entry into the table. If a duplicate is found then
    return the original entry. Do not insert in that case.

Arguments:
    GTable  - frs generic table
    NewData - data for the entry to insert
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    NULL if the entry was successfully inserted in the table.
    Pointer to the data from old entry if a collision is found.
--*/
{
    PGEN_ENTRY  OldEntry;   // Existing entry in the table
    BOOLEAN     IsNew;      // TRUE if insert found existing entry
    GEN_ENTRY   NewEntry;   // new entry to insert.
    PGEN_ENTRY  DupEntry;   // Newly allocated table entry for duplicate.

    //
    // Init the new entry. Have to typecast here becasue the GEN_ENTRY expects a GUID* and PWCHAR.
    //
    NewEntry.Data = NewData;
    NewEntry.Key1 = (GUID*)Key1;
    NewEntry.Key2 = (PWCHAR)Key2;
    NewEntry.Dups = NULL;


    OldEntry = RtlInsertElementGenericTable(&GTable->Table,
                                            &NewEntry,
                                            sizeof(NewEntry),
                                            &IsNew);


    if (!IsNew) {
        return OldEntry;
    }

    return NULL;

}


VOID
GTabInsertEntry(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Insert an entry into the table. Duplicates are simply linked
    to the current entry.

Arguments:
    GTable  - frs generic table
    NewData - data for the entry to insert
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    None.
--*/
{
    PGEN_ENTRY  OldEntry;   // Existing entry in the table
    BOOLEAN     IsNew;      // TRUE if insert found existing entry
    GEN_ENTRY   NewEntry;   // new entry to insert.
    PGEN_ENTRY  DupEntry;   // Newly allocated table entry for duplicate.

    //
    // Init the new entry.
    //
    NewEntry.Data = NewData;
    NewEntry.Key1 = Key1;
    NewEntry.Key2 = Key2;
    NewEntry.Dups = NULL;

    //
    // Lock the table and Insert the entry
    //
    GTabLockTable(GTable);
    OldEntry = RtlInsertElementGenericTable(&GTable->Table,
                                            &NewEntry,
                                            sizeof(NewEntry),
                                            &IsNew);
    if (!IsNew) {
        //
        // Duplicate entry; add to list
        //
        DupEntry = FrsAlloc(sizeof(GEN_ENTRY));
        CopyMemory(DupEntry, &NewEntry, sizeof(NewEntry));
        DupEntry->Dups = OldEntry->Dups;
        OldEntry->Dups = DupEntry;
    }
    GTabUnLockTable(GTable);
}


VOID
GTabInsertEntryNoLock(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    )
/*++
Routine Description:
    Insert an entry into the table. Duplicates are simply linked
    to the current entry.

    Caller acquires the table lock.

Arguments:
    GTable  - frs generic table
    NewData - data for the entry to insert
    Key1    - primary key
    Key2    - secondary key (may be NULL)

Return Value:
    None.
--*/
{
    PGEN_ENTRY  OldEntry;   // Existing entry in the table
    BOOLEAN     IsNew;      // TRUE if insert found existing entry
    GEN_ENTRY   NewEntry;   // new entry to insert.
    PGEN_ENTRY  DupEntry;   // Newly allocated table entry for duplicate.

    //
    // Init the new entry.
    //
    NewEntry.Data = NewData;
    NewEntry.Key1 = Key1;
    NewEntry.Key2 = Key2;
    NewEntry.Dups = NULL;

    //
    // Lock the table and Insert the entry
    //
    OldEntry = RtlInsertElementGenericTable(&GTable->Table,
                                            &NewEntry,
                                            sizeof(NewEntry),
                                            &IsNew);
    if (!IsNew) {
        //
        // Duplicate entry; add to list
        //
        DupEntry = FrsAlloc(sizeof(GEN_ENTRY));
        CopyMemory(DupEntry, &NewEntry, sizeof(NewEntry));
        DupEntry->Dups = OldEntry->Dups;
        OldEntry->Dups = DupEntry;
    }
}


VOID
GTabDelete(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Delete the entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    GEN_ENTRY   Key;    // Search key
    PGEN_ENTRY  Entry;  // entry in table
    PGEN_ENTRY  Dup;    // dup entry in table
    PVOID       Data;

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for either table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Find the entry
    //
    GTabLockTable(GTable);
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    if (Entry == NULL) {
        goto out;
    }

    //
    // Delete the dups
    //
    while (Dup = Entry->Dups) {
        Entry->Dups = Dup->Dups;
        if (CallerFree) {
            //
            // Free up the callers Datum
            //
            (*CallerFree)(Dup->Data);
        }
        Dup = FrsFree(Dup);
    }

    //
    // Delete entry
    //
    Data = Entry->Data;
    RtlDeleteElementGenericTable(&GTable->Table, Entry);
    if (CallerFree) {
        //
        // Free up the callers Datum
        //
        (*CallerFree)(Data);
    }

out:
    GTabUnLockTable(GTable);
}


VOID
GTabDeleteNoLock(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2,
    IN PVOID        (*CallerFree)(PVOID)
    )
/*++
Routine Description:
    Delete the entry in the table.

Arguments:
    GTable  - frs generic table
    Key1    - primary key
    Key2    - secondary key (may be NULL)
    CallerFree - The free routine to use to free up the callers datum (optional)

Return Value:
    None.
--*/
{
    GEN_ENTRY   Key;    // Search key
    PGEN_ENTRY  Entry;  // entry in table
    PGEN_ENTRY  Dup;    // dup entry in table
    PVOID       Data;

    FRS_ASSERT(Key1);

    //
    // Set up a search key that is suitable for either table
    //
    Key.Key1 = Key1;
    Key.Key2 = Key2;

    //
    // Find the entry
    //
    Entry = (PVOID)RtlLookupElementGenericTable(&GTable->Table, &Key);
    if (Entry == NULL) {
        return;
    }

    //
    // Delete the dups
    //
    while (Dup = Entry->Dups) {
        Entry->Dups = Dup->Dups;
        if (CallerFree) {
            //
            // Free up the callers Datum
            //
            (*CallerFree)(Dup->Data);
        }
        Dup = FrsFree(Dup);
    }

    //
    // Delete entry
    //
    Data = Entry->Data;
    RtlDeleteElementGenericTable(&GTable->Table, Entry);
    if (CallerFree) {
        //
        // Free up the callers Datum
        //
        (*CallerFree)(Data);
    }
}


VOID
GTabPrintTable(
    IN PGEN_TABLE   GTable
    )
/*++
Routine Description:
    Print the table and all of its dups.

Arguments:
    GTable  - frs generic table

Return Value:
    None.
--*/
{
    PGEN_ENTRY  Entry;
    PGEN_ENTRY  Dup;
    PVOID       Key;
    CHAR        Guid[GUID_CHAR_LEN + 1];

    //
    // print the entries
    //
    GTabLockTable(GTable);
    Key = NULL;

    while (Entry = GTabNextEntryNoLock(GTable, &Key)) {

        GuidToStr(Entry->Key1, &Guid[0]);
        if (Entry->Key2) {
            DPRINT3(0, "\t0x%x %s %ws\n", Entry->Data, Guid, Entry->Key2);
        } else {
            DPRINT2(0, "\t0x%x %s NULL\n", Entry->Data, Guid);
        }

        for (Dup = Entry->Dups; Dup; Dup = Dup->Dups) {

            GuidToStr(Entry->Key1, &Guid[0]);
            if (Dup->Key2) {
                DPRINT3(0, "\t0x%x %s %ws\n", Dup->Data, Guid, Dup->Key2);
            } else {
                DPRINT2(0, "\t0x%x %s NULL\n", Dup->Data, Guid);
            }
        }
    }

    GTabUnLockTable(GTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\guidname.c ===
/*++
Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frsguid.c

Abstract:
    These routines temporarily supply guids for replica sets and
    servers.

Author:
    Billy J. Fuller 06-May-1997

Environment
    User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop

#define DEBSUB  "FRSGNAME:"

#include <frs.h>


PVOID
FrsFreeGName(
    IN PVOID    Arg
    )
/*++
Routine Description:
    Free a gname entry in a table

Arguments:
    Arg - entry in table points to this value

Return Value:
    None.
--*/
{
    PGNAME  GName = Arg;

    if (GName) {
        FrsFree(GName->Guid);
        FrsFree(GName->Name);
        FrsFree(GName);
    }
    return NULL;
}

PGNAME
FrsBuildGName(
    IN OPTIONAL GUID     *Guid,
    IN OPTIONAL PWCHAR   Name
    )
/*++
Routine Description:
    Build a GName

Arguments:
    Guid    - address of a binary guid
    Name    - printable name

Return Value:
    Address of a GName that points to Guid and Name.
--*/
{
    PGNAME GName;

    GName = FrsAlloc(sizeof(GNAME));
    GName->Guid = Guid;
    GName->Name = Name;

    return GName;
}

PGVSN
FrsBuildGVsn(
    IN OPTIONAL GUID       *Guid,
    IN          ULONGLONG   Vsn
    )
/*++
Routine Description:
    Build a gusn

Arguments:
    Guid
    Vsn

Return Value:
    Address of a gusn
--*/
{
    PGVSN GVsn;

    GVsn = FrsAlloc(sizeof(GVSN));
    COPY_GUID(&GVsn->Guid, Guid);
    GVsn->Vsn = Vsn;

    return GVsn;
}

PGNAME
FrsDupGName(
    IN PGNAME SrcGName
    )
/*++
Routine Description:
    Duplicate a gstring

Arguments:
    OrigGName

Return Value:
    None.
--*/
{
    PGNAME  GName;

    //
    // nothing to do
    //
    if (!SrcGName)
        return NULL;

    GName = FrsAlloc(sizeof(GNAME));

    //
    // guid
    //
    if (SrcGName->Guid) {
        GName->Guid = FrsAlloc(sizeof(GUID));
        COPY_GUID(GName->Guid, SrcGName->Guid);
    }
    //
    // name
    //
    if (SrcGName->Name)
        GName->Name = FrsWcsDup(SrcGName->Name);
    //
    // done
    //
    return GName;
}

GUID *
FrsDupGuid(
    IN GUID *Guid
    )
/*++
Routine Description:
    Duplicate a guid

Arguments:
    Guid

Return Value:
    None.
--*/
{
    GUID *NewGuid;

    //
    // nothing to do
    //
    if (!Guid)
        return NULL;

    NewGuid = FrsAlloc(sizeof(GUID));
    COPY_GUID(NewGuid, Guid);

    //
    // done
    //
    return NewGuid;
}

PGNAME
FrsCopyGName(
    IN GUID     *Guid,
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Allocate a gname and duplicate the guid and name into it

Arguments:
    Guid
    Name

Return Value:
    None.
--*/
{
    PGNAME GName;

    GName = FrsAlloc(sizeof(GNAME));

    //
    // guid
    //
    if (Guid) {
        GName->Guid = FrsAlloc(sizeof(GUID));
        COPY_GUID(GName->Guid, Guid);
    }
    //
    // name
    //
    if (Name)
        GName->Name = FrsWcsDup(Name);
    //
    // done
    //
    return GName;
}

VOID
FrsPrintGName(
    IN PGNAME GName
    )
/*++
Routine Description:
    Print a gname

Arguments:
    GName

Return Value:
    None.
--*/
{
    CHAR        Guid[GUID_CHAR_LEN + 1];

    //
    // print the GName
    //
    GuidToStr(GName->Guid, &Guid[0]);
    DPRINT2(0, "%ws %s\n", GName->Name, Guid);
}

VOID
FrsPrintGuid(
    IN GUID *Guid
    )
/*++
Routine Description:
    Print a guid

Arguments:
    Guid

Return Value:
    None.
--*/
{
    CHAR PGuid[GUID_CHAR_LEN + 1];
    //
    // print the GName
    //
    GuidToStr(Guid, &PGuid[0]);
    DPRINT1(0, "%s\n", PGuid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\genhash.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    genhash.c

Abstract:

Generic Hash Table routines.  Each hash table is an array of FRS_LIST entries
that provide interlocked access to each row of the hash table.  Each table
is managed by a GENERIC_HASH_TABLE struct which holds function entry points for
freeing an entry, comparing keys, performing a hash calculation, printing
an entry and dumping the table.


Note:  All hash entries must be prefixed with GENERIC_HASH_ROW_ENTRY at the
beginning of the structure.

Author:

    David Orbits          [davidor]   22-Apr-1997

Environment:

    User Mode Service

Revision History:


--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <genhash.h>
#include <tablefcn.h>


#pragma warning( disable:4102)  // unreferenced label




PGENERIC_HASH_TABLE
GhtCreateTable(
    PCHAR ArgName,
    ULONG NumberRows,
    ULONG KeyOffset,
    ULONG KeyLength,
    PGENERIC_HASH_FREE_ROUTINE     GhtFree,
    PGENERIC_HASH_COMPARE_ROUTINE  GhtCompare,
    PGENERIC_HASH_CALC_ROUTINE     GhtHashCalc,
    PGENERIC_HASH_PRINT_ROUTINE    GhtPrint
    )
/*++

Routine Description:

    Allocate and initialize a hash table.

Arguments:

    ArgName     -- The table name.  [16 byte max]
    NumberRows  -- The number of rows in the table.
    KeyOffset   -- The byte offset to the key value in each table entry.
    KeyLength   -- The byte length of the key value in each table entry.
    GhtFree     -- function to call to free an entry.
    GhtCompare  -- function to comoare two keys.
    GhtHashCalc -- function to calculate the ULONG hash value on a key.
    GhtPrint    -- Function to print out a table entry.
    GhtDump     -- Function to call to dump all table entries.

Return Value:

    ptr to a GENERIC_HASH_TABLE struct or NULL if failure.
    use GetLastError for the error status.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtCreateTable:"

    PGENERIC_HASH_TABLE HashTable;
    PGENERIC_HASH_ROW_ENTRY RowBase, HashRowEntry;
    ULONG NameLen;
    ULONG WStatus;
    ULONG i;


    HashTable = (PGENERIC_HASH_TABLE) FrsAllocType(GENERIC_HASH_TABLE_TYPE);

    RowBase = (PGENERIC_HASH_ROW_ENTRY) FrsAlloc(
        NumberRows * sizeof(GENERIC_HASH_ROW_ENTRY));

    NameLen = min(strlen(ArgName), 15);
    CopyMemory(HashTable->Name, ArgName, NameLen);
    HashTable->Name[NameLen] = '\0';

    HashTable->NumberRows      = NumberRows;
    HashTable->GhtFree         = GhtFree;
    HashTable->GhtCompare      = GhtCompare;
    HashTable->GhtHashCalc     = GhtHashCalc;
    HashTable->GhtPrint        = GhtPrint;
    HashTable->KeyOffset       = KeyOffset;
    HashTable->KeyLength       = KeyLength;
    HashTable->RowLockEnabled  = TRUE;
    HashTable->RefCountEnabled = TRUE;
    HashTable->HeapHandle      = NULL;
    HashTable->UseOffsets      = FALSE;
    HashTable->OffsetBase      = 0;
    HashTable->HashRowBase     = RowBase;
    HashTable->LockTimeout     = 10000;       // milliseconds

    //
    // Initialize all the hash table rows.  Each has a critical section and
    // an event to wait on.
    //
    HashRowEntry = RowBase;

    for (i=0; i<NumberRows; i++) {
        //
        // Create the event first so if we fail GhtDestroyTable sees a null handle.
        //
        //HashRowEntry->Event = CreateEvent(NULL, TRUE, FALSE, NULL);

        WStatus = FrsRtlInitializeList(&HashRowEntry->HashRow);
        if (WStatus != ERROR_SUCCESS) {
            goto CLEANUP;
        }

        //if (HashRowEntry->Event == NULL) {
        //    WStatus = GetLastError();
        //    goto CLEANUP;
        //}

        HashRowEntry += 1;
    }

    return HashTable;


CLEANUP:

    HashTable->NumberRows = i+1;
    GhtDestroyTable(HashTable);
    SetLastError(WStatus);
    return NULL;

}


VOID
GhtDestroyTable(
    PGENERIC_HASH_TABLE HashTable
    )
/*++

Routine Description:

    Free all the memory for a hash table.
    This includes any data elements left in the table.
    No locks are acquired.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtDestroyTable:"

    PGENERIC_HASH_ROW_ENTRY RowEntry;
    ULONG i;

    if (HashTable == NULL) {
        return;
    }

    RowEntry = HashTable->HashRowBase;
    DPRINT1(5, "GhtDestroyTable for %s\n", HashTable->Name);

    //
    // Loop through all the Hash table rows and delete any entries still on
    // each row.
    //
    for (i=0; i<HashTable->NumberRows; i++, RowEntry++) {
        if (RowEntry->HashRow.Count != 0) {
            //DPRINT2(5, "HashRow: %d, RowCount %d\n",i, RowEntry->HashRow.Count);
        }

        ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,

            FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &pE->ListEntry);

            //DPRINT4(5, "    Deleteing entry: %08x, Hval %08x, Index %d, refcnt %d\n",
            //       pE, pE->HashValue, i, pE->ReferenceCount);

            (HashTable->GhtFree)(HashTable, pE);
        );

        FrsRtlDeleteList(&RowEntry->HashRow);
        //if (RowEntry->Event != NULL) {
        //    FRS_CLOSE(RowEntry->Event);
        //}
    }

    FrsFree(HashTable->HashRowBase);
    FrsFreeType(HashTable);
    return;
}


ULONG
GhtCleanTableByFilter(
    PGENERIC_HASH_TABLE HashTable,
    IN PGENERIC_HASH_ENUM_ROUTINE Function,
    PVOID Context
    )
/*++

Routine Description:

    Free the elements in the hash table for which the predicate function
    returns TRUE.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    Function - The function to call for each record in the table.  It is of
               of type PGENERIC_HASH_FILTER_ROUTINE.
               Return TRUE to delete the entry in the table.
    Context -- Arg to pass thru to the filter function.

Return Value:

    The number of entries deleted.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtCleanTableByFilter:"

    PGENERIC_HASH_ROW_ENTRY RowEntry;
    ULONG i;
    ULONG Count = 0;

    if (HashTable == NULL) {
        return Count;
    }

    RowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and delete any entries still on
    // each row.
    //
    for (i=0; i<HashTable->NumberRows; i++, RowEntry++) {
        if (RowEntry->HashRow.Count != 0) {
            //DPRINT2(4, "HashRow: %d, RowCount %d\n", i, RowEntry->HashRow.Count);
        }

        ForEachListEntry(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
            //
            // The iterator pE is of type GENERIC_HASH_ENTRY_HEADER.
            // Call predicate to see if we should do the delete.
            //
            if ((Function)(HashTable, pE, Context)) {

                FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &pE->ListEntry);

                //DPRINT4(4, "Deleting entry: %08x, Hval %08x, Index %d, refcnt %d\n",
                //        pE, pE->HashValue, i, pE->ReferenceCount);

                (HashTable->GhtFree)(HashTable, pE);

                Count += 1;
            }
        );
    }

    return Count;
}



#if DBG
VOID
GhtDumpTable(
    ULONG Sev,
    PGENERIC_HASH_TABLE HashTable
    )
/*++

Routine Description:

    Call the print routine for each element in the table.

Arguments:

    Sev  -- DPRINT severity level.
    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtDumpTable:"

    PGENERIC_HASH_ROW_ENTRY HashRowEntry;
    ULONG i;

    HashRowEntry = HashTable->HashRowBase;
    DPRINT(Sev,"----------------------------------------------\n");
    DPRINT(Sev,"----------------------------------------------\n");
    DPRINT1(Sev, "GhtDumpTable for %s\n", HashTable->Name);
    DPRINT(Sev,"----------------------------------------------\n");
    DPRINT(Sev,"----------------------------------------------\n");

    //
    // Loop through all the Hash table rows and call the print function for
    // each element.
    //
    for (i=0; i<HashTable->NumberRows; i++) {
        if (HashRowEntry->HashRow.Count != 0) {
            DPRINT(Sev, " \n");
            DPRINT(Sev,"----------------------------------------------\n");
            DPRINT2(Sev, "HashRow: %d, RowCount %d\n",
                    i, HashRowEntry->HashRow.Count);
            DPRINT5(Sev, "Inserts: %d,  Removes: %d,  Compares: %d,  Lookups: %d,  Lookupfails: %d \n",
                     HashRowEntry->RowInserts,
                     HashRowEntry->RowRemoves,
                     HashRowEntry->RowCompares,
                     HashRowEntry->RowLookups,
                     HashRowEntry->RowLookupFails);
        }

        ForEachListEntry(&HashRowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
            (HashTable->GhtPrint)(HashTable, pE);
        );

        HashRowEntry += 1;
    }
}
#endif DBG


ULONG_PTR
GhtEnumerateTable(
    IN PGENERIC_HASH_TABLE HashTable,
    IN PGENERIC_HASH_ENUM_ROUTINE Function,
    IN PVOID         Context
    )
/*++

Routine Description:

    This routine walks through the entries in a generic hash table and
    calls the function provided with the entry address and the context.
    No locks are taken by this function so the called function can make
    calls to other GHT routines to lookup or insert new entries.

    THis routine increments the ref count on each entry before it makes the
    call to ensure the entry does not vanish.  It keeps a pointer to the
    entry that tells it where to continue the scan.  If the argument function
    inserts an entry that is earlier in the table the enumeration will not
    pick it up.

Arguments:

    HashTable - The context of the Hash Table to enumerate.
    Function - The function to call for each record in the table.  It is of
               of type PGENERIC_HASH_ENUM_ROUTINE.  Return FALSE to abort the
               enumeration else true.
    Context - A context ptr to pass through to the RecordFunction.

Return Value:

    The status code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtEnumerateTable:"


    PGENERIC_HASH_ROW_ENTRY RowEntry;
    ULONG i;
    ULONG_PTR WStatus;

    RowEntry = HashTable->HashRowBase;

    DPRINT(5,"----------------------------------------------\n");
    DPRINT(5,"----------------------------------------------\n");
    DPRINT1(5, "GhtEnumerateTable for %s\n", HashTable->Name);
    DPRINT(5,"----------------------------------------------\n");
    DPRINT(5,"----------------------------------------------\n");

    //
    // Loop through all the Hash table rows and call the print function for
    // each element.
    //
    for (i=0; i<HashTable->NumberRows; i++) {
        if (RowEntry->HashRow.Count != 0) {
            DPRINT(5, " \n");
            DPRINT(5,"----------------------------------------------\n");
            DPRINT2(5, "HashRow: %d, RowCount %d\n",
                    i, RowEntry->HashRow.Count);
        }

        ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,

            InterlockedIncrement(&pE->ReferenceCount);
            DPRINT2(5, "inc ref: %08x, %d\n", pE, pE->ReferenceCount);

            WStatus = (Function)(HashTable, pE, Context);

            InterlockedDecrement(&pE->ReferenceCount);
            DPRINT2(5, "dec ref: %08x, %d\n", pE, pE->ReferenceCount);

            // Note: If caller needs this we should add code to check for
            // zero ref count and call the delete function.

            if( WStatus != 0 ) {
                return WStatus;
            }
        );

        RowEntry += 1;
    }

    return ERROR_SUCCESS;

}



ULONG_PTR
GhtEnumerateTableNoRef(
    IN PGENERIC_HASH_TABLE HashTable,
    IN PGENERIC_HASH_ENUM_ROUTINE Function,
    IN PVOID         Context
    )
/*++

Routine Description:

    This routine walks through the entries in a generic hash table and
    calls the function provided with the entry address and the context.
    No locks are taken by this function so the called function can make
    calls to other GHT routines to lookup or insert new entries.

    THis routine does not take a ref count out on the entry.
    It keeps a pointer to the next entry that tells it where to continue
    the scan if the argument function deletes the entry. If the argument function
    inserts an entry that is earlier in the table the enumeration will not
    pick it up.

Arguments:

    HashTable - The context of the Hash Table to enumerate.
    Function - The function to call for each record in the table.  It is of
               of type PGENERIC_HASH_ENUM_ROUTINE.  Return FALSE to abort the
               enumeration else true.
    Context - A context ptr to pass through to the RecordFunction.

Return Value:

    The status code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtEnumerateTableNoRef:"


    PGENERIC_HASH_ROW_ENTRY RowEntry;
    ULONG i;
    ULONG_PTR WStatus;

    RowEntry = HashTable->HashRowBase;

    DPRINT1(5, "GhtEnumerateTableNoRef for %s\n", HashTable->Name);

    //
    // Loop through all the Hash table rows and call the print function for
    // each element.
    //
    for (i=0; i<HashTable->NumberRows; i++) {
        if (RowEntry->HashRow.Count != 0) {
            DPRINT(5, " \n");
            DPRINT(5,"----------------------------------------------\n");
            DPRINT2(5, "HashRow: %d, RowCount %d\n",
                    i, RowEntry->HashRow.Count);
        }

        ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,

            WStatus = (Function)(HashTable, pE, Context);

            if (WStatus != 0) {
                return WStatus;
            }
        );

        RowEntry += 1;
    }

    return (ULONG_PTR)0;
}




PGENERIC_HASH_ENTRY_HEADER
GhtGetNextEntry(
    IN PGENERIC_HASH_TABLE HashTable,
    PGENERIC_HASH_ENTRY_HEADER HashEntry
    )
/*++

Routine Description:

    This routine returns the next entry in the table that follows the HashEntry
    argument.  If the HashEntry is NULL it returns the first entry.

    It gets the row lock containing the current entry, decrements the
    ref count on the entry.  It scans forward to the next entry in the table
    getting its row lock if needed, increments its ref count and returns the
    pointer.  If the end of table is reached NULL is returned.

    If an entry is inserted earlier in the table the enumeration will not
    pick it up.

Arguments:

    HashTable - The context of the Hash Table to enumerate.

    HashEntry - The current entry we are looking at.  Used to get the next entry
                If null start scan at beginning of table.

Return Value:

    The status code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtGetNextEntry:"


    PGENERIC_HASH_ROW_ENTRY LastRow;
    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    PLIST_ENTRY Entry;
    RowEntry = HashTable->HashRowBase;


    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    if (HashEntry != NULL) {
        Hval = HashEntry->HashValue;
        HvalIndex = Hval % HashTable->NumberRows;
        RowEntry += HvalIndex;

        //
        // Get the row lock and decrement the ref count.
        // (could delete if it hits zero)
        //
        FrsRtlAcquireListLock(&RowEntry->HashRow);
        InterlockedDecrement(&HashEntry->ReferenceCount);
        //
        // look for next entry in same row.
        // if found, bump ref count, drop lock, return entry.
        //
        Entry = GetListNext(&HashEntry->ListEntry);
        if (Entry != &RowEntry->HashRow.ListHead) {
            goto FOUND;
        }
        //
        // if not found drop row lock and  execute scan code below
        // starting from next row entry.
        //
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        RowEntry += 1;
    }

    //
    // Scan the rest of the table for a non-empty row.
    //
    LastRow = HashTable->HashRowBase + HashTable->NumberRows;

    while (RowEntry < LastRow) {

        if (RowEntry->HashRow.Count != 0) {
            //
            // Found one.  Get the row lock and recheck the count incase
            // someone beat us too it.
            //
            FrsRtlAcquireListLock(&RowEntry->HashRow);
            if (RowEntry->HashRow.Count == 0) {
                //
                // Too bad.  Continue scan.
                //
                FrsRtlReleaseListLock(&RowEntry->HashRow);
                RowEntry += 1;
                continue;
            }
            //
            // We got one. Get the entry address, bump the ref count, drop lock.
            //
            FRS_ASSERT(!IsListEmpty(&RowEntry->HashRow.ListHead));

            Entry = GetListHead(&RowEntry->HashRow.ListHead);
            goto FOUND;
        }

        RowEntry += 1;
    }

    return NULL;

FOUND:
    HashEntry = CONTAINING_RECORD(Entry, GENERIC_HASH_ENTRY_HEADER, ListEntry);
    InterlockedIncrement(&HashEntry->ReferenceCount);
    FrsRtlReleaseListLock(&RowEntry->HashRow);
    return HashEntry;

}


ULONG
GhtCountEntries(
    IN PGENERIC_HASH_TABLE HashTable
    )
/*++

Routine Description:

    This routine walks through the rows in a generic hash table and
    adds up the entry count.  It takes no locks so the count is approx.
    Caller must know the table can't go away.

Arguments:

    HashTable - The context of the Hash Table to count.

Return Value:

    The count.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtCountEntries:"


    ULONG Total = 0;
    PGENERIC_HASH_ROW_ENTRY LastRow, RowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and add counts.
    //

    LastRow = RowEntry + HashTable->NumberRows;

    while (RowEntry < LastRow) {
        Total += RowEntry->HashRow.Count;
        RowEntry += 1;
    }

    return Total;

}


PGENERIC_HASH_ENTRY_HEADER
GhtGetEntryNumber(
    IN PGENERIC_HASH_TABLE HashTable,
    IN LONG EntryNumber
    )
/*++

Routine Description:

    This routine walks through the rows in a generic hash table
    counting entries as it goes.  It returns the requested entry (by number)
    from the table.  Note this will not be the same entry from call to call
    because of intervening inserts and deletes.  It takes no locks until it
    gets to the row of the table that contains the entry.
    The ref count on the entry is incremented.

Arguments:

    HashTable - The context of the Hash Table to enumerate.

    EntryNumber - The ordinal number of the entry in the table.
                  zero is the first entry.

Return Value:

    The address of the entry.

--*/

{
#undef DEBSUB
#define DEBSUB "GhtGetEntryNumber:"


    PGENERIC_HASH_ROW_ENTRY LastRow, RowEntry = HashTable->HashRowBase;
    ULONG Rcount;
    PLIST_ENTRY Entry;
    PGENERIC_HASH_ENTRY_HEADER HashEntry;

    FRS_ASSERT(EntryNumber >= 0);

    //
    // Loop through Hash table rows looking for the row with the entry.
    //
    LastRow = RowEntry + HashTable->NumberRows;

    while (RowEntry < LastRow) {

        Rcount = RowEntry->HashRow.Count;

        if (Rcount > 0) {
            EntryNumber -= Rcount;
            if (EntryNumber < 0) {
                //
                // Should be in this row.  Get the row lock and recheck
                // the count incase someone beat us too it.
                //
                FrsRtlAcquireListLock(&RowEntry->HashRow);
                if (RowEntry->HashRow.Count < Rcount) {
                    //
                    // Too bad. It got shorter, Retry test.
                    //
                    FrsRtlReleaseListLock(&RowEntry->HashRow);
                    EntryNumber += Rcount;
                    continue;
                }

                //
                // We got one. Get the entry address, bump the ref count, drop lock.
                //
                EntryNumber += Rcount;
                Entry = GetListHead(&RowEntry->HashRow.ListHead);
                while (EntryNumber-- > 0) {
                    FRS_ASSERT(Entry != &RowEntry->HashRow.ListHead);
                    Entry = GetListNext(Entry);
                }

                HashEntry = CONTAINING_RECORD(Entry, GENERIC_HASH_ENTRY_HEADER, ListEntry);
                InterlockedIncrement(&HashEntry->ReferenceCount);
                FrsRtlReleaseListLock(&RowEntry->HashRow);
                return HashEntry;

            }
        }
        RowEntry += 1;
    }

    return NULL;

}



PGENERIC_HASH_ENTRY_HEADER
GhtQuickCheck(
    PGENERIC_HASH_TABLE HashTable,
    PGENERIC_HASH_ROW_ENTRY RowEntry,
    PGENERIC_HASH_ENTRY_HEADER HashEntry,
    ULONG Hval
    )
/*++

Routine Description:

    Internal function to do a quick scan of a row to find an entry.
    Used in debug code to check that an entry is actually in the table.


    Assumes caller has the row lock.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    RowEntry -- ptr to the ROW_ENTRY struct.
    HashEntry -- ptr to the hash entry we are looking for.
    Hval -- hash value we are looking for.

Return Value:

    ptr to entry if we find it.
    NULL if we don't.

--*/
{
    PCHAR pKeyValue;

    pKeyValue = ((PCHAR)HashEntry) + HashTable->KeyOffset;

    ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
        //
        // The iterator pE is of type PGENERIC_HASH_ENTRY_HEADER.
        //
        if (pE->HashValue == Hval) {
            if ((HashTable->GhtCompare)(pKeyValue,
                                        ((PCHAR)pE) + HashTable->KeyOffset,
                                        HashTable->KeyLength)) {
                //
                // Found it.
                //
                return pE;
            }
        }
    );

    return NULL;
}


GHT_STATUS
GhtLookup2(
    PGENERIC_HASH_TABLE HashTable,
    PVOID pKeyValue,
    BOOL WaitIfLocked,
    PVOID *RetHashEntry,
    ULONG DupIndex
    )
/*++

Routine Description:

Takes the KeyValue and calls the hash function which returns a ULONG.  Then
calculate the index of HashValue Mod TableLenth.  With the index find the hash
row header and acquire the row lock.  It then walks the list looking for a hash
value match on the KeyValue.  The entires are kept in ascending order so the
lookup stops as soon as new entry value is < the list entry value.  Then call
the compare routine to see if the key data in the entry (entry+key offset)
matches the keyValue passed in.  If it matches, the ref count in the entry is
bumped and the address is returned.

If there are duplicate entries then the ptr to the nth oldest duplicate is
returned where n is supplied by DupIndex.  A value of 0 for DupIndex means
return the last duplicate in the list.  This is the most recent duplicate
inserted since insert puts new entries at the end of the duplicate group.  A
value of one returns the oldest duplicate as determined by time of insert.


TBI -
If the row is locked and WaitIfLocked is TRUE then we wait on the row event.
If the row is locked and WaitIfLocked is FALSE then return status
GHT_STATUS_LOCKCONFLICT.  In this case you can't tell if the entry is in
the table.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    pKeyValue  -- ptr to the keyValue we are looking for.
    WaitIfLocked  -- True means wait if the row is locked.
    RetHashEntry -- Returned ptr if found or NULL.
    DupIndex -- return the nth duplicate, if 0 return last duplicate in list.

Return Value:

    GHT_STATUS_NOT_FOUND -- if not found.
    GHT_STATUS_SUCCESS -- if found.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtLookup2:"

    ULONG GStatus;
    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    PGENERIC_HASH_ENTRY_HEADER LastFoundpE = NULL;

    // Note: Get lock earlier if table resize support is added.

    if (pKeyValue == NULL) {
        *RetHashEntry = NULL;
        return GHT_STATUS_NOT_FOUND;
    }
    //
    // Compute the hash index and calculate the row pointer.
    //
    Hval = (HashTable->GhtHashCalc)(pKeyValue, HashTable->KeyLength);
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (FrsRtlCountList(&RowEntry->HashRow) == 0) {
        *RetHashEntry = NULL;
        RowEntry->RowLookupFails += 1;
        return GHT_STATUS_NOT_FOUND;
    }

    if (DupIndex == 0) {
        DupIndex = 0xFFFFFFFF;
    }


    FrsRtlAcquireListLock(&RowEntry->HashRow);
    //
    // Walk the list looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
        //
        // The iterator pE is of type PGENERIC_HASH_ENTRY_HEADER.
        //
        RowEntry->RowCompares += 1;
        if (Hval < pE->HashValue) {
            //
            // Not on the list.
            //
            break;
        }

        if (pE->HashValue == Hval) {
            if ((HashTable->GhtCompare)(pKeyValue,
                                        ((PCHAR)pE) + HashTable->KeyOffset,
                                        HashTable->KeyLength)) {
                //
                // Found it.  Check DupIndex count.
                //
                RowEntry->RowLookups += 1;
                LastFoundpE = pE;
                if (--DupIndex == 0) {
                    break;
                }
            }
        }
    );


    if (LastFoundpE != NULL) {
        //
        // Found one.  Bump ref count, release the lock, return success.
        //
        InterlockedIncrement(&LastFoundpE->ReferenceCount);
        DPRINT2(5, ":: inc ref: %08x, %d\n", LastFoundpE, LastFoundpE->ReferenceCount);
        GStatus = GHT_STATUS_SUCCESS;
    } else {
        RowEntry->RowLookupFails += 1;
        GStatus = GHT_STATUS_NOT_FOUND;
    }

    ReleaseListLock(&RowEntry->HashRow);
    *RetHashEntry = LastFoundpE;
    return GStatus;
}



GHT_STATUS
GhtInsert(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked,
    BOOL DuplicatesOk
    )
/*++

Routine Description:

Inserts a HashEntry into the HashTable.  It calls the hash function with a ptr
to the key data (HashEntry+key offset) which returns a ULONG that is stored in
HashEntry.HashValue.  Insert then calculates the index of HashValue Mod
TableLenth.  With the index it finds the hash row header and acquires the row
lock.  It then walks the list looking for a hash value match.  The entires are
kept in ascending order so the lookup stops as soon as new entry value is < the
list entry value.  It then inserts the entry in the table, updates the counts in
the row header, releases the lock and returns.  If it finds a match it calls the
user compare function with HashEntry+offset and ListEntry+offset to validate the
match.  The validate returns true if it matches and false if it fails (i.e.
continue walking the list).  Duplicates are allowed when DuplicatesOk is True.
Insert returns GHT_STATUS_SUCCESS if the entry was inserted and
GHT_STATUS_FAILURE if this is a duplicate node and DuplicatesOk is False (the
compare function returned TRUE).  The refcount is incremented if the node was
inserted.


Note:  All hash entries must be prefixed with GENERIC_HASH_ROW_ENTRY at the
beginning of the structure.

TBI -
If the row is locked and WaitIfLocked is FALSE then return status
GHT_STATUS_LOCKCONFLICT else wait on the row.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to new entry to insert.
    WaitIfLocked  -- True means wait if the row is locked.
    DuplicatesOk  -- True means duplicate entries are ok.  They are placed at
                     the end of the list of duplicates.

Return Value:

    GHT_STATUS_FAILURE -- Conflicting entry is in table already.
    GHT_STATUS_SUCCESS -- Insert was successful.


--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtInsert:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    PVOID pKeyValue;
    PLIST_ENTRY BeforeEntry;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;


    //
    // Compute the hash value on the key in the entry.
    //
    pKeyValue = ((PCHAR)HashEntry) + HashTable->KeyOffset;
    Hval = (HashTable->GhtHashCalc)(pKeyValue, HashTable->KeyLength);
    HashEntry->HashValue = Hval;

    //
    // Compute the index and calculate the row pointer.
    //

    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);

    BeforeEntry = &RowEntry->HashRow.ListHead;   // incase of empty list.

    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    ForEachListEntryLock(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,

        RowEntry->RowCompares += 1;
        if (Hval < pE->HashValue) {
            //
            // Not on the list.  Put new entry before this one.
            //
            BeforeEntry = &pE->ListEntry;
            break;
        }

        if (pE->HashValue == Hval) {
            if ((HashTable->GhtCompare)(pKeyValue,
                                        ((PCHAR)pE) + HashTable->KeyOffset,
                                        HashTable->KeyLength)) {
                //
                // Found it.  Release the lock and return failure if no
                // duplicates are allowed.
                //
                if (!DuplicatesOk) {
                    FrsRtlReleaseListLock(&RowEntry->HashRow);
                    return GHT_STATUS_FAILURE;
                }
            }
        }
    );

    //
    // Put new entry on the list in front of 'BeforeEntry'.
    //
    InterlockedIncrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: inc ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);
    RowEntry->RowInserts += 1;

    FrsRtlInsertBeforeEntryListLock( &RowEntry->HashRow,
                                     BeforeEntry,
                                     &HashEntry->ListEntry);

    FrsRtlReleaseListLock(&RowEntry->HashRow);
    return GHT_STATUS_SUCCESS;

}


GHT_STATUS
GhtDeleteEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

Takes HashEntry address and fetches the hash value to acquire the row lock.
Decrement the reference count and if it is one (the count for being in the
table) remove the entry from the row and call the memory free function to
release the entries memory.  Drop the row lock.  Return GHT_STATUS_SUCCESS if we
deleted the entry.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to entry to delete.
    WaitIfLocked  -- True means wait if the row is locked.



Return Value:

    GHT_STATUS_FAILURE -- Entry was not deleted.
    GHT_STATUS_SUCCESS -- Entry was deleted.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtDeleteEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    BOOL Found;
    ULONG GhtStatus;
    LONG  NewCount;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;


    GhtStatus = GHT_STATUS_FAILURE;

    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = HashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);


#if DBG
    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Found = GhtQuickCheck(HashTable, RowEntry, HashEntry, Hval) != NULL;
    if (!Found) {
        DPRINT4(0, "GhtDeleteEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"entry not on list");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }
#endif


    //
    // Decrement the ref count.
    //
    NewCount = InterlockedDecrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: dec ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);

    if (NewCount <= 0) {
        DPRINT4(0, "GhtDeleteEntryByAddress - ref count equal zero: %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"ref count <= zero");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }

    if (NewCount == 1) {
        //
        // Ref count zero.  Remove and free the entry.
        //
        FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &HashEntry->ListEntry);
        (HashTable->GhtFree)(HashTable, HashEntry);
        GhtStatus = GHT_STATUS_SUCCESS;
    }


    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GhtStatus;
}



GHT_STATUS
GhtRemoveEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

Takes HashEntry address and fetches the hash value to acquire the row lock.
Remove the entry from the table.  The reference count is decremented.

Return GHT_STATUS_SUCCESS.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.

Also Note:  The caller must have a lock that prevents other threads from
changing the entry.  In addition removing an entry from one hash table and
inserting it on another will confuse another thread that may be accessing the
entry so the caller better be sure that no other thread assumes the hash
table can't change while it has a reference to the entry.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to entry to delete.
    WaitIfLocked  -- True means wait if the row is locked.



Return Value:

    GHT_STATUS_SUCCESS -- if the entry was removed successfully.
    GHT_STATUS_FAILURE -- if the entry was not on the list.

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtRemoveEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    BOOL Found;
    LONG NewCount;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;


    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = HashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);


#if DBG
    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Found = GhtQuickCheck(HashTable, RowEntry, HashEntry, Hval) != NULL;
    if (!Found) {
        DPRINT4(0, "GhtRemoveEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"entry not on list-2");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }
#endif


    //
    // Decrement the ref count.
    //
    NewCount = InterlockedDecrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: dec ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);

    if (NewCount < 0) {
        DPRINT4(0, ":: ERROR- GhtRemoveEntryByAddress - ref count less than zero: %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"ref count less than zero-2");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }

    if (NewCount > 1) {
        //
        // Other Refs than the caller's exist.  Print a warning.
        //
        DPRINT5(1, ":: WARNING- GhtRemoveEntryByAddress - ref count(%d) > 1: %08x, %08x, %d, %s\n",
                NewCount, HashEntry, Hval, HvalIndex, HashTable->Name);
    }

    FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &HashEntry->ListEntry);

    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GHT_STATUS_SUCCESS;
}



GHT_STATUS
GhtReferenceEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

Takes HashEntry address and fetches the hash value to acquire the row lock.
Increment the reference count.  Drop the row lock.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.  A Lookup which gave you the address bumps the
reference count.  An insert in which you kept the address does NOT bump
the reference count.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to entry to reference.
    WaitIfLocked  -- True means wait if the row is locked.

Return Value:

    GHT_STATUS_SUCCESS

--*/

{
#undef DEBSUB
#define  DEBSUB  "GhtReferenceEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    BOOL Found;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;

    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = HashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);


#if DBG
    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Found = GhtQuickCheck(HashTable, RowEntry, HashEntry, Hval) != NULL;
    if (!Found) {
        DPRINT4(0, "GhtReferenceEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"entry not on list-3");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }
#endif


    //
    // Increment the ref count.
    //
    InterlockedIncrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: inc ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);

    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GHT_STATUS_SUCCESS;
}



GHT_STATUS
GhtDereferenceEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID HashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

Takes HashEntry address and fetches the hash value to acquire the row lock.
Decrement the reference count.  Drop the row lock.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.  A Lookup which gave you the address bumps the
reference count.  An insert in which you kept the address does NOT bump
the reference count.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    HashEntryArg -- ptr to entry to reference.
    WaitIfLocked  -- True means wait if the row is locked.

Return Value:

    GHT_STATUS_SUCCESS

--*/
{
#undef DEBSUB
#define  DEBSUB  "GhtDereferenceEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    BOOL Found;
    LONG NewCount;
    PGENERIC_HASH_ENTRY_HEADER HashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)HashEntryArg;


    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = HashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);


#if DBG
    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Found = GhtQuickCheck(HashTable, RowEntry, HashEntry, Hval) != NULL;
    if (!Found) {
        DPRINT4(0, "GhtDereferenceEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"entry not on list-4");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }
#endif


    //
    // Decrement the ref count.
    //
    NewCount = InterlockedDecrement(&HashEntry->ReferenceCount);
    DPRINT2(5, ":: dec ref: %08x, %d\n", HashEntry, HashEntry->ReferenceCount);

    if (NewCount <= 0) {
        DPRINT4(0, "GhtDereferenceEntryByAddress - ref count now zero: %08x, %08x, %d, %s\n",
                HashEntry, Hval, HvalIndex, HashTable->Name);
        FRS_ASSERT(!"ref count now zero-4");
        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_FAILURE;
    }

    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GHT_STATUS_SUCCESS;
}




GHT_STATUS
GhtAdjustRefCountByKey(
    PGENERIC_HASH_TABLE HashTable,
    PVOID pKeyValue,
    LONG Delta,
    ULONG ActionIfZero,
    BOOL WaitIfLocked,
    PVOID *RetHashEntry
    )
/*++

Routine Description:

Takes keyvalue, finds the HashEntry address and adds Delta to
the reference count.  Drop the row lock.

** WARNING **
If you allow duplicate entries in the hash table this routine will not work
because you can't guarantee that you will adjust a given entry.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Arguments:

    HashTable     -- ptr to a GENERIC_HASH_TABLE struct.
    pKeyValue     -- ptr to a datavalue for the key.
    Delta         -- The amount of the ref count adjustment.
    ActionIfZero  -- If RC is zero Choice of nothing, remove, remove and delete.
    WaitIfLocked  -- True means wait if the row is locked.
    RetHashEntry  -- If GHT_ACTION_REMOVE requested, the hash entry
                     address is returned if element removed else NULL returned.

Return Value:

    GHT_STATUS_SUCCESS
    GHT_STATUS_NOT_FOUND

--*/
{
#undef DEBSUB
#define  DEBSUB  "GhtDecrementRefCountByKey:"


    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    LONG NewCount;

    if (ActionIfZero == GHT_ACTION_REMOVE) {
        *RetHashEntry = NULL;
    }

    // Note: Get lock earlier if table resize support is added.
    //
    // Compute the hash index and calculate the row pointer.
    //
    Hval = (HashTable->GhtHashCalc)(pKeyValue, HashTable->KeyLength);
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (FrsRtlCountList(&RowEntry->HashRow) == 0) {
        RowEntry->RowLookupFails += 1;
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    ForEachListEntry(&RowEntry->HashRow, GENERIC_HASH_ENTRY_HEADER, ListEntry,
        //
        // pE is iterator of type GENERIC_HASH_ENTRY_HEADER.
        //
        RowEntry->RowCompares += 1;
        if (pE->HashValue == Hval) {
            if ((HashTable->GhtCompare)(pKeyValue,
                                        ((PCHAR)pE) + HashTable->KeyOffset,
                                        HashTable->KeyLength)) {
                //
                // Found it.  Adjust ref count,
                //
                NewCount = InterlockedExchangeAdd(&pE->ReferenceCount, Delta);
                DPRINT2(5, ":: adj ref: %08x, %d\n", pE, pE->ReferenceCount);
                RowEntry->RowLookups += 1;
                if (NewCount <= 0) {
                    if (NewCount < 0) {
                        DPRINT4(0, "GhtDecrementRefCountByKey - ref count neg: %08x, %08x, %d, %s\n",
                                pE, Hval, HvalIndex, HashTable->Name);
                        FRS_ASSERT(!"ref count neg-5");
                        ReleaseListLock(&RowEntry->HashRow);
                        return GHT_STATUS_FAILURE;
                    }

                    //
                    // Ref count zero.  Optionally remove and free the entry.
                    //
                    if (ActionIfZero == GHT_ACTION_REMOVE) {
                        *RetHashEntry = pE;
                        FrsRtlRemoveEntryListLock(&RowEntry->HashRow, &pE->ListEntry);
                    } else

                    if (ActionIfZero == GHT_ACTION_DELETE) {
                        (HashTable->GhtFree)(HashTable, pE);
                    } else {

                        //
                        // Not good.  Action was noop so refcount expected to
                        // be > 0.
                        //
                        DPRINT4(0, "GhtDecrementRefCountByKey - ref count zero with Noop Action: %08x, %08x, %d, %s\n",
                                pE, Hval, HvalIndex, HashTable->Name);
                        FRS_ASSERT(!"ref count zero-6");
                        ReleaseListLock(&RowEntry->HashRow);
                        return GHT_STATUS_FAILURE;
                    }
                }

                ReleaseListLock(&RowEntry->HashRow);
                return GHT_STATUS_SUCCESS;
            }
        }
    );

    RowEntry->RowLookupFails += 1;
    return GHT_STATUS_NOT_FOUND;

}




GHT_STATUS
GhtSwapEntryByAddress(
    PGENERIC_HASH_TABLE HashTable,
    PVOID OldHashEntryArg,
    PVOID NewHashEntryArg,
    BOOL WaitIfLocked
    )
/*++

Routine Description:

This routine replaces an existing old hash entry with a new entry.
It verifies tha the old hash entry is still in the table.
It assumes that the key value of the new entry is the same as the old entry.
NO CHECK IS MADE.

The expected use is when the caller needs to reallocate an entry with
more storage.

NOTE ALSO:  The reference count is copied from the old entry to the new one.
Using this routine means that the caller is using  GhtDecrementRefCountByKey()
and GhtIncrementRefCountByKey() to access the ref counts on any element in the
table since the entry could get swapped making the pointer invalid.

TBI -
Return GHT_STATUS_LOCKCONFLICT if we failed to get the lock and
WaitIfLocked was FALSE.

Note: This function is only safe if you have a reference on the entry otherwise
another thread could have already deleted the entry and your entry address is
pointing at freed memory.  A Lookup which gave you the address bumps the
reference count.  An insert in which you kept the address does NOT bump
the reference count.

Arguments:

    HashTable  --  ptr to a GENERIC_HASH_TABLE struct.
    OldHashEntry -- ptr to entry to swap out of table.
    NewHashEntry -- ptr to entry to swap in to table.
    WaitIfLocked  -- True means wait if the row is locked.

Return Value:

    GHT_STATUS_SUCCESS if swap ok.
    GHT_STATUS_NOT_FOUND if old entry not in table.


--*/
// Note:  TBD if necc, implement GhtIncrementRefCountByKey.

{
#undef DEBSUB
#define  DEBSUB  "GhtSwapEntryByAddress:"

    ULONG Hval, HvalIndex;
    PGENERIC_HASH_ROW_ENTRY RowEntry;
    PLIST_ENTRY BeforeEntry;
    BOOL Found;
    PGENERIC_HASH_ENTRY_HEADER Entry;
    PGENERIC_HASH_ENTRY_HEADER NewHashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)NewHashEntryArg;
    PGENERIC_HASH_ENTRY_HEADER OldHashEntry =
        (PGENERIC_HASH_ENTRY_HEADER)OldHashEntryArg;

    //
    // Get the hash value for the element and compute the index and RowEntry
    // address.  Then get the row lock.
    //
    Hval = OldHashEntry->HashValue;
    HvalIndex = Hval % HashTable->NumberRows;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    FrsRtlAcquireListLock(&RowEntry->HashRow);

    //
    // check if the entry is actually on the List.
    //
    // Walk the list with the lock looking for a match on the
    // the hash value then try and match the KeyValue.
    //
    Entry = GhtQuickCheck(HashTable, RowEntry, OldHashEntry, Hval);
    if (Entry != OldHashEntry) {
        DPRINT4(0, "GhtSwapEntryByAddress - entry not on list %08x, %08x, %d, %s\n",
                OldHashEntry, Hval, HvalIndex, HashTable->Name);

        FrsRtlReleaseListLock(&RowEntry->HashRow);
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Copy the ref count and hash value from the old entry to the new one.
    //
    NewHashEntry->ReferenceCount = OldHashEntry->ReferenceCount;
    NewHashEntry->HashValue = OldHashEntry->HashValue;

    //
    // Pull the old entry out and replace with the new entry.
    // List counts do not change so do list juggling here.
    //
    BeforeEntry = OldHashEntry->ListEntry.Flink;
    FrsRemoveEntryList(&OldHashEntry->ListEntry);
    InsertTailList(BeforeEntry, &NewHashEntry->ListEntry);

    FrsRtlReleaseListLock(&RowEntry->HashRow);

    return GHT_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\debug.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This routine reads input from STDIN and initializes the debug structure.
    It reads a list of subsystems to debug and a severity level.

Author:

    Billy Fuller

Environment

    User mode, winnt32
*/
#include <ntreppch.h>
#pragma  hdrstop

#include "debug.h"

// #include <imagehlp.h>
#include <dbghelp.h>
#include <frs.h>
#include <winbase.h>
#include <mapi.h>
#include <ntfrsapi.h>
#include <info.h>

extern PCHAR LatestChanges[];
extern ULONG MaxCoRetryTimeoutCount;
extern ULONG MaxCoRetryTimeoutMinutes;
extern DWORD CommTimeoutInMilliSeconds;
extern ULONG DsPollingLongInterval;
extern ULONG DsPollingShortInterval;
extern DWORD PartnerClockSkew;
extern ULONG ChangeOrderAgingDelay;
extern DWORD ReplicaTombstone;



//
// Track the thread IDs of known threads for the debug log header.
//
typedef struct _KNOWN_THREAD {
    PWCHAR   Name;                    // print Name of thread.
    DWORD    Id;                      // Id returned by CreateThread()
    PTHREAD_START_ROUTINE EntryPoint; // entry point
} KNOWN_THREAD, *PKNOWN_THREAD;

KNOWN_THREAD KnownThreadArray[20];

//
// Send mail will not work if the Default User is unable to send
// mail on this machine.
//
MapiRecipDesc Recips =
    {0, MAPI_TO, 0, 0, 0, NULL};

MapiMessage Message =
    { 0, 0, 0, NULL, NULL, NULL, 0, 0, 1, &Recips, 0, 0 };

LPMAPILOGON     MailLogon;
LPMAPILOGOFF    MailLogoff;
LPMAPISENDMAIL  MailSend;
HANDLE          MailLib;
LHANDLE         MailSession;



WCHAR   DbgExePathW[MAX_PATH+1];
CHAR    DbgExePathA[MAX_PATH+1];
CHAR    DbgSearchPath[MAX_PATH+1];

//
// Flush the trace log every so many lines.
//
LONG    DbgFlushInterval = 100000;

#define DEFAULT_DEBUG_MAX_LOG           (20000)

LONG  StackTraceCount = 100;
LONG  DbgRaiseCount = 50;


OSVERSIONINFOEXW  OsInfo;
SYSTEM_INFO  SystemInfo;
PCHAR ProcessorArchName[12] = {"INTEL", "MIPS", "Alpha", "PPC", "SHX",
                               "ARM", "IA64", "Alpha64", "MSIL", "AMD64",
                               "IA32-on-WIN64", "unknown"};

//
// Suffixes for saved log files and saved assertion files
//      E.g., (ntfrs_0005.log)
//            (DebugInfo.LogFile, DebugInfo.LogFiles, LOG_FILE_SUFFIX)
//
#define LOG_FILE_FORMAT     L"%ws_%04d%ws"
#define LOG_FILE_SUFFIX     L".log"
#define ASSERT_FILE_SUFFIX  L"_assert.log"


//
// Disable the generation of compressed staging files for any local changes.
//
BOOL DisableCompressionStageFiles;
ULONG GOutLogRepeatInterval;

//
// Client side ldap search timeout in minutes. Reg value "Ldap Search Timeout In Minutes". Default is 10 minutes.
//
DWORD LdapSearchTimeoutInMinutes;

//
// Client side ldap_connect timeout in seconds. Reg value "Ldap Bind Timeout In Seconds". Default is 30 seconds.
//
DWORD LdapBindTimeoutInSeconds;

SC_HANDLE
FrsOpenServiceHandle(
    IN PTCHAR  MachineName,
    IN PTCHAR  ServiceName
    );


VOID
FrsPrintRpcStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    );

#if DBG

//
// Collection of debug info from the registry and the CLI
//
DEBUGARG DebugInfo;

//
// allow multiple servers on one machine
//
PWCHAR  ServerName = NULL;
PWCHAR  IniFileName = NULL;
GUID    *ServerGuid = NULL;



VOID
DbgLogDisable(
    VOID
    )
/*++
Routine Description:
    Disable DPRINT log.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgLogDisable:"

    DebLock();
    if (HANDLE_IS_VALID(DebugInfo.LogFILE)) {
        FrsFlushFile(L"LogFILE", DebugInfo.LogFILE);
        DbgFlushInterval = DebugInfo.LogFlushInterval;
        FRS_CLOSE(DebugInfo.LogFILE);
    }
    DebugInfo.LogFILE = INVALID_HANDLE_VALUE;
    DebUnLock();
}





VOID
DbgOpenLogFile(
    VOID
    )
/*++
Routine Description:
    Open the log file by creating names like ntfrs0001.log.
    NumFiles as a 4 digit decimal number and Suffix is like ".log".

    DebLock() must be held (DO NOT CALL DPRINT IN THIS FUNCTION!)

Arguments:
    Base
    Suffix
    NumFiles

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgOpenLogFile:"

    WCHAR                LogPath[MAX_PATH + 1];
    SECURITY_ATTRIBUTES  SecurityAttributes;

    if (DebugInfo.Disabled) {
        DebugInfo.LogFILE = INVALID_HANDLE_VALUE;
        return;
    }

    if (_snwprintf(LogPath, MAX_PATH, LOG_FILE_FORMAT, DebugInfo.LogFile,
                   DebugInfo.LogFiles, LOG_FILE_SUFFIX) < 0) {

        DebugInfo.LogFILE = INVALID_HANDLE_VALUE;
        return;
    }
    //
    // Set this handle to be inheritable so that it can be passed
    // to new processes that ntfrs starts (lodctr, unlodctr) and cause
    // them to write their errors in the ntfrs debug logs.
    //
    SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttributes.bInheritHandle = TRUE;
    SecurityAttributes.lpSecurityDescriptor = NULL; // not same as NULL DACL

    DebugInfo.LogFILE = CreateFile(LogPath,                       //  lpszName
                                   GENERIC_READ | GENERIC_WRITE,  //  fdwAccess
                                   FILE_SHARE_READ,               //  fdwShareMode
                                   &SecurityAttributes,           //  lpsa
                                   CREATE_ALWAYS,                 //  fdwCreate
                                   FILE_FLAG_BACKUP_SEMANTICS,    //  fdwAttrAndFlags
                                   NULL);                         //  hTemplateFile
}


VOID
DbgShiftLogFiles(
    IN PWCHAR   Base,
    IN PWCHAR   Suffix,
    IN PWCHAR   RemoteBase,
    IN ULONG    NumFiles
    )
/*++
Routine Description:
    Shift the files through the range of log/assert file names
    (Base_5_Suffix -> Base_4_Suffix -> ... Base_0_Suffix

    DebLock() must be held (DO NOT CALL DPRINT IN THIS FUNCTION!)

Arguments:
    Base
    Suffix
    NumFiles

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgShiftLogFiles:"

    ULONG       i;
    WCHAR       FromPath[MAX_PATH + 1];
    WCHAR       ToPath[MAX_PATH + 1];
    ULONGLONG   Now;

    //
    // No history
    //
    if ((NumFiles < 2) || DebugInfo.Disabled) {
        return;
    }

    //
    // Save the log file as an assert file
    //
    for (i = 2; i <= NumFiles; ++i) {
        if (_snwprintf(ToPath, MAX_PATH, LOG_FILE_FORMAT, Base, i-1, Suffix) > 0) {
            if (_snwprintf(FromPath, MAX_PATH, LOG_FILE_FORMAT, Base, i, Suffix) > 0) {
                MoveFileEx(FromPath, ToPath, MOVEFILE_REPLACE_EXISTING |
                                             MOVEFILE_WRITE_THROUGH);
            }
        }
    }

    //
    // Copy the last log file to a remote share
    //      WARN - the system time is used to create a unique file
    //             name. This means that the remote share can
    //             fill up!
    //
    if (!RemoteBase) {
        return;
    }

    GetSystemTimeAsFileTime((FILETIME *)&Now);


    if (_snwprintf(FromPath, MAX_PATH, LOG_FILE_FORMAT, Base, NumFiles-1, Suffix) > 0) {
        if (_snwprintf(ToPath,
                       MAX_PATH,
                       L"%ws%ws%08x%_%08x",
                       RemoteBase,
                       Suffix,
                       PRINTQUAD(Now)) > 0) {
            CopyFileEx(FromPath, ToPath, NULL, NULL, FALSE, 0);
        }
    }
}



VOID
DbgSendMail(
    IN PCHAR    Subject,
    IN PCHAR    Content
    )
/*++
Routine Description:
    Send mail as the default user.

Arguments:
    Subject
    Message

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgSendMail:"

    DWORD   MStatus;
    WCHAR   FullPathToDll[MAX_PATH + 1];

    //
    // Nobody to send mail to
    //
    if (!DebugInfo.Recipients) {
        return;
    }

    //
    // Load the mail library and find our entry points
    //
    FullPathToDll[0] = L'\0';
    GetSystemDirectory(FullPathToDll,sizeof(FullPathToDll)/sizeof(FullPathToDll[0]));
    if ((wcslen(FullPathToDll) == 0 )||
        (wcslen(FullPathToDll) + wcslen(L"\\mapi32.dll"))
        >= sizeof(FullPathToDll)) {
        return;
    }
    wcscat(FullPathToDll,L"\\mapi32.dll");

    MailLib = LoadLibrary(FullPathToDll);
    if(!HANDLE_IS_VALID(MailLib)) {
        DPRINT_WS(0, ":S: Load mapi32.dll failed;", GetLastError());
        return;
    }
    MailLogon = (LPMAPILOGON)GetProcAddress(MailLib, "MAPILogon");
    MailLogoff = (LPMAPILOGOFF)GetProcAddress(MailLib, "MAPILogoff");
    MailSend = (LPMAPISENDMAIL)GetProcAddress(MailLib, "MAPISendMail");

    if (!MailLogon || !MailLogoff || !MailSend) {
        DPRINT(0, ":S: ERROR - Could not find mail symbols in mapi32.dll\n");
        FreeLibrary(MailLib);
        return;
    }

    //
    // Log on with the specified profile
    //
    MStatus = MailLogon(0, DebugInfo.Profile, 0, 0, 0, &MailSession);
    if(MStatus) {
        DPRINT1_WS(0, ":S: ERROR - MailLogon failed; MStatus %d;",
                   MStatus, GetLastError());
        FreeLibrary(MailLib);
        return;
    }

    //
    // Send the mail
    //
    Recips.lpszName = DebugInfo.Recipients;
    Message.lpszSubject = Subject;
    Message.lpszNoteText = Content;
    MStatus = MailSend(MailSession, 0, &Message, 0, 0);

    if(MStatus) {
        DPRINT1_WS(0, ":S: ERROR - MailSend failed MStatus %d;", MStatus, GetLastError());
    }

    //
    // Log off and free the library
    //
    MailLogoff(MailSession, 0, 0, 0);
    FreeLibrary(MailLib);
}


VOID
DbgSymbolPrint(
    IN ULONG        Severity,
    IN PCHAR        Debsub,
    IN UINT         LineNo,
    IN ULONG_PTR    Addr
    )
/*++
Routine Description:
    Print a symbol

Arguments:
    Addr

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgSymbolPrint:"

    ULONG_PTR Displacement = 0;

    struct MyMymbol {
        IMAGEHLP_SYMBOL Symbol;
        char Path[MAX_PATH];
    } MySymbol;


    try {
        ZeroMemory(&MySymbol, sizeof(MySymbol));
        MySymbol.Symbol.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        MySymbol.Symbol.MaxNameLength = MAX_PATH;

        if (!SymGetSymFromAddr(ProcessHandle, Addr, &Displacement, &MySymbol.Symbol)) {
            DebPrint(Severity, "++ \t   0x%08x: Unknown Symbol (WStatus %s)\n",
                    Debsub, LineNo, Addr, ErrLabelW32(GetLastError()));
        } else
            DebPrint(Severity, "++ \t   0x%08x: %s\n",
                    Debsub, LineNo, Addr, MySymbol.Symbol.Name);

    } except (EXCEPTION_EXECUTE_HANDLER) {
          DebPrint(Severity, "++ \t   0x%08x: Unknown Symbol (WStatus %s)\n",
                  Debsub, LineNo, Addr, ErrLabelW32(GetExceptionCode()));
        /* FALL THROUGH */
    }
}


VOID
DbgModulePrint(
    IN PWCHAR   Prepense,
    IN ULONG    Addr
    )
/*++
Routine Description:
    Print info about a module containing Addr

Arguments:
    Prepense    - prettypring; printed at the beginning of each line
    Addr

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgModulePrint:"

    IMAGEHLP_MODULE mi;

    try {
        ZeroMemory(&mi, sizeof(mi));
        mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

        if (!SymGetModuleInfo(ProcessHandle, Addr, &mi)) {
            DPRINT1_WS(0, "++ %ws <unknown module;", Prepense, GetLastError());
        } else
            DPRINT2(0, "++ %ws Module is %ws\n", Prepense, mi.ModuleName);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        /* FALL THROUGH */
    }
}


VOID
DbgStackPrint(
    IN ULONG        Severity,
    IN PCHAR        Debsub,
    IN UINT         LineNo,
    IN PULONG_PTR   Stack,
    IN ULONG        Depth
    )
/*++
Routine Description:
    Print the previously acquired stack trace.

Arguments:
    Prepense    - prettypring; printed at the beginning of each line
    Stack       - "return PC" from each frame
    Depth       - Only this many frames

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStackPrint:"

    ULONG  i;

    try {
        for (i = 0; i < Depth && *Stack; ++i, ++Stack) {
            DbgSymbolPrint(Severity, Debsub, LineNo, *Stack);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        /* FALL THROUGH */
    }
}



VOID
DbgStackTrace(
    IN PULONG_PTR   Stack,
    IN ULONG    Depth
    )
/*++
Routine Description:
    Trace the stack back up to Depth frames. The current frame is included.

Arguments:
    Stack   - Saves the "return PC" from each frame
    Depth   - Only this many frames

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStackTrace:"

    ULONG       WStatus;
    HANDLE      ThreadHandle;
    STACKFRAME  Frame;
    ULONG       i = 0;
    CONTEXT     Context;
    ULONG       FrameAddr;

    //
    // I don't know how to generate a stack for an alpha, yet. So, just
    // to get into the build, disable the stack trace on alphas.
    //
    if (Stack) {
        *Stack = 0;
    }
#if ALPHA
    return;
#elif IA64

    //
    // Need stack dump init for IA64.
    //

    return;

#else

    //
    // init
    //

    ZeroMemory(&Context, sizeof(Context));
    ThreadHandle = GetCurrentThread();

    try { try {
        Context.ContextFlags = CONTEXT_FULL;
        if (!GetThreadContext(ThreadHandle, &Context)) {
            DPRINT_WS(0, "++ Can't get context;", GetLastError());
        }

        //
        // let's start clean
        //
        ZeroMemory(&Frame, sizeof(STACKFRAME));

        //
        // from  nt\private\windows\screg\winreg\server\stkwalk.c
        //
        Frame.AddrPC.Segment = 0;
        Frame.AddrPC.Mode = AddrModeFlat;

#ifdef _M_IX86
        Frame.AddrFrame.Offset = Context.Ebp;
        Frame.AddrFrame.Mode = AddrModeFlat;

        Frame.AddrStack.Offset = Context.Esp;
        Frame.AddrStack.Mode = AddrModeFlat;

        Frame.AddrPC.Offset = (DWORD)Context.Eip;
#elif defined(_M_MRX000)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#elif defined(_M_ALPHA)
        Frame.AddrPC.Offset = (DWORD)Context.Fir;
#endif



#if 0
        //
        // setup the program counter
        //
        Frame.AddrPC.Mode = AddrModeFlat;
        Frame.AddrPC.Segment = (WORD)Context.SegCs;
        Frame.AddrPC.Offset = (ULONG)Context.Eip;

        //
        // setup the frame pointer
        //
        Frame.AddrFrame.Mode = AddrModeFlat;
        Frame.AddrFrame.Segment = (WORD)Context.SegSs;
        Frame.AddrFrame.Offset = (ULONG)Context.Ebp;

        //
        // setup the stack pointer
        //
        Frame.AddrStack.Mode = AddrModeFlat;
        Frame.AddrStack.Segment = (WORD)Context.SegSs;
        Frame.AddrStack.Offset = (ULONG)Context.Esp;

#endif

        for (i = 0; i < (Depth - 1); ++i) {
            if (!StackWalk(
                IMAGE_FILE_MACHINE_I386,  // DWORD                          MachineType
                ProcessHandle,            // HANDLE                         hProcess
                ThreadHandle,             // HANDLE                         hThread
                &Frame,                   // LPSTACKFRAME                   StackFrame
                NULL, //(PVOID)&Context,          // PVOID                          ContextRecord
                NULL,                     // PREAD_PROCESS_MEMORY_ROUTINE   ReadMemoryRoutine
                SymFunctionTableAccess,   // PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine
                SymGetModuleBase,         // PGET_MODULE_BASE_ROUTINE       GetModuleBaseRoutine
                NULL)) {                  // PTRANSLATE_ADDRESS_ROUTINE     TranslateAddress

                WStatus = GetLastError();

                //DPRINT1_WS(0, "++ Can't get stack address for level %d;", i, WStatus);
                break;
            }
            if (StackTraceCount-- > 0) {
                DPRINT1(5, "++ Frame.AddrReturn.Offset: %08x \n", Frame.AddrReturn.Offset);
                DbgSymbolPrint(5, DEBSUB, __LINE__, Frame.AddrReturn.Offset);
                //DPRINT1(5, "++ Frame.AddrPC.Offset: %08x \n", Frame.AddrPC.Offset);
                //DbgSymbolPrint(5, DEBSUB, __LINE__, Frame.AddrPC.Offset);
            }

            *Stack++ = Frame.AddrReturn.Offset;
            *Stack = 0;
            //
            // Base of stack?
            //
            if (!Frame.AddrReturn.Offset) {
                break;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        /* FALL THROUGH */
    } } finally {
        FRS_CLOSE(ThreadHandle);
    }
    return;
#endif ALPHA
}


VOID
DbgPrintStackTrace(
    IN ULONG    Severity,
    IN PCHAR    Debsub,
    IN UINT     LineNo
    )
/*++
Routine Description:
    Acquire and print the stack

Arguments:
    Severity
    Debsub

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgPrintStackTrace:"

    ULONG_PTR   Stack[32];

    DbgStackTrace(Stack, ARRAY_SZ(Stack) );
    DbgStackPrint(Severity, Debsub, LineNo, Stack, ARRAY_SZ(Stack) );
}


VOID
DbgStackInit(
    VOID
    )
/*++
Routine Description:
    Initialize anything necessary to get a stack trace

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStackInit:"

    //
    // Initialize the symbol subsystem
    //
    if (!SymInitialize(ProcessHandle, NULL, FALSE)) {
        DPRINT_WS(0, ":S: Could not initialize symbol subsystem (imagehlp)" ,GetLastError());
    }

    //
    // Load our symbols
    //
    if (!SymLoadModule(ProcessHandle, NULL, DbgExePathA, "FRS", 0, 0)) {
        DPRINT1_WS(0, ":S: Could not load symbols for %s", DbgExePathA ,GetLastError());
    }

    //
    // Search path
    //
    if (!SymGetSearchPath(ProcessHandle, DbgSearchPath, MAX_PATH)) {
        DPRINT_WS(0, ":S: Can't get search path; error %s", GetLastError());
    } else {
        DPRINT1(0, ":S: Symbol search path is %s\n", DbgSearchPath);
    }

}


void
DbgShowConfig(
    VOID
    )
/*++
Routine Description:
    Display the OS Version info and the Processor Architecture info.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgShowConfig:"


    ULONG ProductType;
    ULONG Arch;

    if (DebugInfo.BuildLab != NULL) {
        DPRINT1(0, ":H:  BuildLab : %s\n",  DebugInfo.BuildLab);
    }

    DPRINT4(0, ":H:  OS Version %d.%d (%d) - %w\n",
            OsInfo.dwMajorVersion,OsInfo.dwMinorVersion,OsInfo.dwBuildNumber,OsInfo.szCSDVersion);

    ProductType = (ULONG) OsInfo.wProductType;
    DPRINT4(0, ":H:  SP (%hd.%hd) SM: 0x%04hx  PT: 0x%02x\n",
            OsInfo.wServicePackMajor,OsInfo.wServicePackMinor,OsInfo.wSuiteMask, ProductType);

    Arch = SystemInfo.wProcessorArchitecture;
    if (Arch >= ARRAY_SZ(ProcessorArchName)) {
        Arch = ARRAY_SZ(ProcessorArchName)-1;
    }

    DPRINT5(0, ":H:  Processor: %s  Level: 0x%04hx  Revision: 0x%04hx  Processor num/mask: %d/%08x\n",
           ProcessorArchName[Arch], SystemInfo.wProcessorLevel,
           SystemInfo.wProcessorRevision, SystemInfo.dwNumberOfProcessors,
           SystemInfo.dwActiveProcessorMask);

}



VOID
DbgCaptureThreadInfo(
    PWCHAR   ArgName,
    PTHREAD_START_ROUTINE EntryPoint
    )
/*++
Routine Description:
    Search the KnownThreadArray for an entry with a matching name.  If not found,
    Search the FRS Thread list for the thread with the matching entry point.
    If found make an entry in the KnownThreadArray so it is available when
    printing out the debug log header.

Arguments:
    ArgName -- Printable name of thread.
    Main  --  Entry point of thread.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgCaptureThreadInfo:"

    PFRS_THREAD FrsThread;
    ULONG i;

    if (ArgName == NULL) {
        return;
    }

    for (i = 0; i < ARRAY_SZ(KnownThreadArray); i++) {
        //
        // Any room left?
        //
        if ((KnownThreadArray[i].Name == NULL) ||
            (WSTR_EQ(ArgName, KnownThreadArray[i].Name))) {

            FrsThread = ThSupGetThread(EntryPoint);
            if (FrsThread == NULL) {
                return;
            }

            KnownThreadArray[i].EntryPoint = FrsThread->Main;
            KnownThreadArray[i].Id = FrsThread->Id;
            KnownThreadArray[i].Name = ArgName;

            ThSupReleaseRef(FrsThread);
            break;
        }
    }
}



VOID
DbgCaptureThreadInfo2(
    PWCHAR   ArgName,
    PTHREAD_START_ROUTINE EntryPoint,
    ULONG    ThreadId
    )
/*++
Routine Description:
    Search the KnownThreadArray for an entry with a matching name.
    If found make an entry in the KnownThreadArray so it is available when
    printing out the debug log header.

Arguments:
    ArgName -- Printable name of thread.
    Main  --  Entry point of thread.
    ThreadId - Thread ID of the thread to add to the list.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgCaptureThreadInfo2:"

    ULONG i;

    if (ArgName == NULL) {
        return;
    }

    for (i = 0; i < ARRAY_SZ(KnownThreadArray); i++) {
        //
        // Any room left or
        // See if we already have this one and update the thread ID if so.
        // If it was a cmd server thread it may have exited after timeout.
        //
        if ((KnownThreadArray[i].Name == NULL) ||
            (WSTR_EQ(ArgName, KnownThreadArray[i].Name))) {
            KnownThreadArray[i].EntryPoint = EntryPoint;
            KnownThreadArray[i].Id = ThreadId;
            KnownThreadArray[i].Name = ArgName;
            break;
        }
    }
}




VOID
DbgPrintThreadIds(
    IN ULONG Severity
    )
/*++
Routine Description:
    Print the known thread IDs.

Arguments:
    Severity

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgPrintThreadIds:"

    ULONG i;

    DPRINT(Severity, ":H: Known thread IDs -\n");

    //
    // Dump the known thread IDs.
    //
    for (i = 0; i < ARRAY_SZ(KnownThreadArray); i++) {
        if (KnownThreadArray[i].Name != NULL) {
            DPRINT2(Severity, ":H: %-20ws : %d\n",
                    KnownThreadArray[i].Name, KnownThreadArray[i].Id);
        }
    }
}



VOID
DbgPrintInfo(
    IN ULONG Severity
    )
/*++
Routine Description:
    Print the debug info struct

Arguments:
    Severity

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgPrintInfo:"

    SYSTEMTIME  SystemTime;
    ULONG   Unamesize = MAX_PATH + 1;
    ULONG   i;
    WCHAR   Uname[MAX_PATH + 1];
    CHAR    TimeBuf[MAX_PATH];

    //
    // Username
    //
    if (!GetUserName(Uname, &Unamesize)) {
        Uname[0] = L'\0';
    }

    TimeBuf[0] = '\0';

    GetLocalTime(&SystemTime);

    if (_snprintf(TimeBuf, MAX_PATH, "%2d/%2d-%02d:%02d:%02d ",
                  SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour,
                  SystemTime.wMinute, SystemTime.wSecond) < 0) {
        TimeBuf[0] = '\0';
    }

    DPRINT3(Severity, ":H: Service running on %ws as %ws at %s\n",
            ComputerName, Uname, TimeBuf);

    DPRINT(Severity, "\n");
    DPRINT(Severity, ":H: ***** COMPILE INFORMATION:\n");
    DPRINT1(Severity, ":H: \tModule         %s\n", NtFrsModule);
    DPRINT2(Severity, ":H: \tCompile Date   %s %s\n", NtFrsDate, NtFrsTime);

    i = 0;
    while (LatestChanges[i] != NULL) {
        DPRINT1(Severity, ":H:   %s\n", LatestChanges[i]);
        i++;
    }

    DPRINT(Severity, "\n");
    DbgShowConfig();

    DPRINT(Severity, "\n");
    DPRINT(Severity, ":H: ***** DEBUG INFORMATION:\n");
    DPRINT1(Severity, ":H:  Assert Files               : %d\n",  DebugInfo.AssertFiles);
    if (DebugInfo.AssertSeconds) {
        DPRINT1(Severity, ":H:  Assert Seconds             : Assert after %d seconds\n", DebugInfo.AssertSeconds);
    } else {
        DPRINT(Severity, ":H:  Assert Seconds             : Don't force an assert\n");
    }
    DPRINT1(Severity, ":H:  Assert Share               : %ws\n", DebugInfo.AssertShare);
    DPRINT1(Severity, ":H:  ChangeOrderAgingDelay (ms) : %d\n",  ChangeOrderAgingDelay);
    DPRINT1(Severity, ":H:  Check Mem                  : %s\n",  (DebugInfo.Mem) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Check Queues               : %s\n",  (DebugInfo.Queues) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  CommTimeoutInMilliSeconds  : %d\n",  CommTimeoutInMilliSeconds);
    DPRINT1(Severity, ":H:  Compact Mem                : %s\n",  (DebugInfo.MemCompact) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  CompressStagingFiles       : %s\n",  (!DisableCompressionStageFiles) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Copy Logs                  : %s\n",  (DebugInfo.CopyLogs) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Disabled                   : %s\n",  (DebugInfo.Disabled) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  DsPollingLongInterval (ms) : %d\n",  DsPollingLongInterval);
    DPRINT1(Severity, ":H:  DsPollingShortInterval(ms) : %d\n",  DsPollingShortInterval);
    DPRINT1(Severity, ":H:  EnableInstallOverride      : %s\n",  (DebugInfo.EnableInstallOverride) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  EnableJrnlWrapAutoRestore  : %s\n",  (DebugInfo.EnableJrnlWrapAutoRestore) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  EnableRenameUpdates        : %s\n",  (DebugInfo.EnableRenameUpdates) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  FetchRetryReset            : %d\n",  DebugInfo.FetchRetryReset);
    DPRINT1(Severity, ":H:  FetchRetryResetInc         : %d\n",  DebugInfo.FetchRetryInc);
    DPRINT1(Severity, ":H:  FetchRetryTrigger          : %d\n",  DebugInfo.FetchRetryTrigger);
    DPRINT1(Severity, ":H:  Force VvJoin               : %s\n",  (DebugInfo.ForceVvJoin) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Interval                   : %d\n",  DebugInfo.Interval);
    DPRINT1(Severity, ":H:  Log Dir                    : %ws\n", DebugInfo.LogDir ? DebugInfo.LogDir : L"<null>");
    DPRINT1(Severity, ":H:  Log File                   : %ws\n", DebugInfo.LogFile);
    DPRINT1(Severity, ":H:  Log Files                  : %d\n",  DebugInfo.LogFiles);
    DPRINT1(Severity, ":H:  Log Flush Int.             : %d\n",  DebugInfo.LogFlushInterval);
    DPRINT1(Severity, ":H:  Log Lines                  : %d\n",  DebugInfo.LogLines);
    DPRINT1(Severity, ":H:  Log Severity               : %d\n",  DebugInfo.LogSeverity);
    DPRINT1(Severity, ":H:  Max Log Lines              : %d\n",  DebugInfo.MaxLogLines);
    DPRINT1(Severity, ":H:  MaxCoRetryTimeoutCount     : %d\n",  MaxCoRetryTimeoutCount);
    DPRINT1(Severity, ":H:  MaxCoRetryTimeoutMinutes   : %d\n",  MaxCoRetryTimeoutMinutes);
    DPRINT1(Severity, ":H:  OutlogChangeHistory        : %d\n",  DebugInfo.OutlogChangeHistory);
    DPRINT1(Severity, ":H:  PartnerClockSkew (m)       : %d\n",  PartnerClockSkew);
    DPRINT1(Severity, ":H:  Profile                    : %s\n",  DebugInfo.Profile);
    DPRINT1(Severity, ":H:  Recipients                 : %s\n",  DebugInfo.Recipients);
    DPRINT1(Severity, ":H:  ReclaimStagingSpace        : %s\n",  (DebugInfo.ReclaimStagingSpace) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  ReplicaTombstone (d)       : %d\n",  ReplicaTombstone);
    DPRINT1(Severity, ":H:  Restart                    : %s\n",  (DebugInfo.Restart) ? "TRUE" : "FALSE");
    if (DebugInfo.RestartSeconds) {
        DPRINT1(Severity, ":H:  Restart Seconds            : Restart if assert after "
                "%d seconds\n",  DebugInfo.RestartSeconds);
    } else {
        DPRINT(Severity, ":H:  Restart Seconds: Don't Restart\n");
    }
    DPRINT1(Severity, ":H:  SaveOutlogChangeHistory    : %s\n",  (DebugInfo.SaveOutlogChangeHistory) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Severity                   : %d\n",  DebugInfo.Severity);
    DPRINT1(Severity, ":H:  StagingLimitInKb           : %d\n",  StagingLimitInKb);
    DPRINT1(Severity, ":H:  Suppress                   : %s\n",  (DebugInfo.Suppress) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  SuppressIdenticalUpdt      : %s\n",  (DebugInfo.SuppressIdenticalUpdt) ? "TRUE" : "FALSE");
    DPRINT1(Severity, ":H:  Systems                    : %ws\n", DebugInfo.Systems);
    DPRINT1(Severity, ":H:  TestFid                    : %d\n",  DebugInfo.TestFid);

    if (DebugInfo.TestCodeName != NULL) {
        DPRINT1(Severity, ":H:  TestCodeName               : %s\n",  DebugInfo.TestCodeName ? DebugInfo.TestCodeName : "<null>");
        DPRINT1(Severity, ":H:  TestSubCodeNumber          : %d\n",  DebugInfo.TestSubCodeNumber);
        DPRINT1(Severity, ":H:  TestTriggerCount           : %d\n",  DebugInfo.TestTriggerCount);
        DPRINT1(Severity, ":H:  TestTriggerRefresh         : %d\n",  DebugInfo.TestTriggerRefresh);
    }

    DPRINT1(Severity, ":H:  Thread Id                  : %d\n",  DebugInfo.ThreadId);
    DPRINT1(Severity, ":H:  Total Log Lines            : %d\n",  DebugInfo.TotalLogLines);
    DPRINT1(Severity, ":H:  UnjoinTrigger              : %d\n",  DebugInfo.UnjoinTrigger);
    DPRINT1(Severity, ":H:  VvJoinTests                : %s\n",  (DebugInfo.VvJoinTests) ? "TRUE" : "FALSE");
    // DPRINT1(Severity, ":H:  Command Line   : %ws\n", DebugInfo.CommandLine);
    DPRINT(Severity, "\n");

    DbgPrintThreadIds(Severity);

    DEBUG_FLUSH();
}



VOID
DbgPrintAllStats(
    VOID
    )
/*++
Routine Description:
    Print the stats we know about

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgPrintAllStats:"

    DbgPrintInfo(DebugInfo.LogSeverity);
    FrsPrintAllocStats(DebugInfo.LogSeverity, NULL, 0);
    FrsPrintRpcStats(DebugInfo.LogSeverity, NULL, 0);
}


VOID
DbgFlush(
    VOID
    )
/*++
Routine Description:
    Flush the output buffers

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgFlush:"

    DebLock();
    try {
        if (HANDLE_IS_VALID(DebugInfo.LogFILE)) {
            FrsFlushFile(L"LogFILE", DebugInfo.LogFILE);
            DbgFlushInterval = DebugInfo.LogFlushInterval;
        }
    } finally{
        DebUnLock();
    }

}


VOID
DbgStartService(
    IN PWCHAR   ServiceName
    )
/*++
Routine Description:
    Start a service on this machine.

Arguments:
    ServiceName - the service to start

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStartService:"

    SC_HANDLE   ServiceHandle;

    //
    // Open the service.
    //
    ServiceHandle = FrsOpenServiceHandle(NULL, ServiceName);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        DPRINT1(0, ":S: Couldn't open service %ws\n", ServiceName);
        return;
    }
    //
    // Start the service
    //
    if (!StartService(ServiceHandle, 0, NULL)) {
        DPRINT1_WS(0, ":S: Couldn't start %ws;", ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    DPRINT1(4, ":S: Started %ws\n", ServiceName);
}


VOID
DbgStopService(
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Stop a service on this machine.

Arguments:
    ServiceName - the service to stop

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgStopService:"


    BOOL            Status;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = FrsOpenServiceHandle(NULL, ServiceName);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        DPRINT1(0, ":S: Couldn't stop service %ws\n", ServiceName);
        return;
    }

    //
    // Stop the service
    //
    Status = ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);
    if (!WIN_SUCCESS(Status)) {
        DPRINT1_WS(0, ":S: Couldn't stop %ws;", ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return;
    }
    CloseServiceHandle(ServiceHandle);
    DPRINT1(4, ":S: Stopped %ws\n", ServiceName);
}



ULONG
DbgForceAssert(
    IN PVOID Ignored
    )
/*++
Routine Description:
    Force an assert after some seconds

Arguments:
    Ignored

Return Value:
    ERROR_SUCCESS
--*/
{
#undef DEBSUB
#define DEBSUB "DbgForceAssert:"

    BOOL    ForcingAssert = TRUE;

    //
    // Wait for a shutdown event
    //
    WaitForSingleObject(ShutDownEvent, DebugInfo.AssertSeconds * 1000);
    if (!FrsIsShuttingDown) {
        DPRINT(0, ":S: FORCING ASSERT\n");
        FRS_ASSERT(!ForcingAssert);
    }
    return STATUS_SUCCESS;
}


VOID
DbgQueryLogParams(
    )
/*++
Routine Description:

    Read the registry for new values for the logging params.

Arguments:

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgQueryLogParams:"

    PWCHAR  WStr, WStr1;
    PCHAR   AStr;
    PWCHAR  NewLogDirStr = NULL;
    PWCHAR  File;
    DWORD   WStatus;
    DWORD   NewDisabled;
    BOOL    OpenNewLog = FALSE;
    ULARGE_INTEGER FreeBytes;
    ULARGE_INTEGER TotalBytes;

    //
    //  Get new state before taking debug lock since function does DPRINTs.
    //
    CfgRegReadDWord(FKC_DEBUG_DISABLE, NULL, 0, &NewDisabled);

    //
    //  Check for a change in Disable Debug
    //
    DebLock();
    if ((BOOL)NewDisabled != DebugInfo.Disabled) {

        DebugInfo.Disabled = NewDisabled;

        if (DebugInfo.Disabled) {
            //
            // Stop logging.
            //
            if (HANDLE_IS_VALID(DebugInfo.LogFILE)) {
                FrsFlushFile(L"LogFILE", DebugInfo.LogFILE);
                DbgFlushInterval = DebugInfo.LogFlushInterval;
                FRS_CLOSE(DebugInfo.LogFILE);
            }
            DebugInfo.LogFILE = INVALID_HANDLE_VALUE;

        } else {
            //
            // Start logging.
            //
            OpenNewLog = TRUE;
        }
    }

    DebUnLock();

    //
    // Quit now if logging is disabled.
    //
    if (DebugInfo.Disabled) {
        return;
    }

    //
    //   Log File Directory  (only if not running multiple servers on one machine)
    //
    if (ServerName == NULL) {
        CfgRegReadString(FKC_DEBUG_LOG_FILE, NULL, 0, &NewLogDirStr);
        if (NewLogDirStr != NULL) {
            if ((DebugInfo.LogDir == NULL) ||
                 WSTR_NE(NewLogDirStr, DebugInfo.LogDir)) {
                OpenNewLog = TRUE;
            } else {
                NewLogDirStr = FrsFree(NewLogDirStr);
            }
        }
    }

    //
    //   Number of log files
    //
    CfgRegReadDWord(FKC_DEBUG_LOG_FILES, NULL, 0, &DebugInfo.LogFiles);

    //
    //   Flush the trace log after every n lines.
    //
    CfgRegReadDWord(FKC_DEBUG_LOG_FLUSH_INTERVAL, NULL, 0, &DebugInfo.LogFlushInterval);

    //
    //   Severity for console print.
    //
    CfgRegReadDWord(FKC_DEBUG_SEVERITY, NULL, 0, &DebugInfo.Severity);

    //
    //   Log Severity
    //
    CfgRegReadDWord(FKC_DEBUG_LOG_SEVERITY, NULL, 0, &DebugInfo.LogSeverity);

    //
    //   Systems - selected list of functions to trace.  trace all if NULL.
    //
    CfgRegReadString(FKC_DEBUG_SYSTEMS, NULL, 0, &WStr);
    if (WStr != NULL) {
        AStr = DebugInfo.Systems;
        DebLock();
        DebugInfo.Systems = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        DebUnLock();
        WStr = FrsFree(WStr);
        AStr = FrsFree(AStr);
    }

    //
    //   Maximum Log Messages
    //
    CfgRegReadDWord(FKC_DEBUG_MAX_LOG,  NULL, 0, &DebugInfo.MaxLogLines);

    //
    //   Debugger serial line Print  (assume suppress so no dprints leak out)
    //
    DebugInfo.Suppress = TRUE;
    CfgRegReadDWord(FKC_DEBUG_SUPPRESS, NULL, 0, &DebugInfo.Suppress);

    //
    //   Enable break into debugger if present.
    //
    CfgRegReadDWord(FKC_DEBUG_BREAK,  NULL, 0, &DebugInfo.Break);

    //
    // Open a new log if logging was just turned on or if we were.
    // having trouble logging due to errors like out of disk space.
    // Save old log files and open a new log file.
    //
    if ((OpenNewLog || !HANDLE_IS_VALID(DebugInfo.LogFILE)) &&
        (HANDLE_IS_VALID(DebugInfo.LogFile) || (NewLogDirStr != NULL))) {

        WStr = DebugInfo.LogFile;
        WStr1 = DebugInfo.LogDir;
        DebLock();

        if (NewLogDirStr != NULL) {
            //
            // Add the filename prefix to the end of the dir path.
            //
            DebugInfo.LogDir = NewLogDirStr;
            DebugInfo.LogFile = FrsWcsCat(NewLogDirStr, NTFRS_DBG_LOG_FILE);
        }

        //
        // Create new debug directory
        //
        if (!CreateDirectory(DebugInfo.LogDir, NULL)) {
            WStatus = GetLastError();

            if (!WIN_ALREADY_EXISTS(WStatus)) {
                DebugInfo.LogFile = FrsFree(DebugInfo.LogFile);
                DebugInfo.LogDir = FrsFree(DebugInfo.LogDir);
            }
        }

        if (DebugInfo.LogFile != NULL) {
            if (HANDLE_IS_VALID(DebugInfo.LogFILE)) {
                FRS_CLOSE(DebugInfo.LogFILE);
            }

            DbgShiftLogFiles(DebugInfo.LogFile,
                             LOG_FILE_SUFFIX,
                             (DebugInfo.CopyLogs) ? DebugInfo.AssertShare : NULL,
                             DebugInfo.LogFiles);
            DbgOpenLogFile();
        }

        DebUnLock();

        if (NewLogDirStr != NULL) {
            WStr = FrsFree(WStr);
            WStr1 = FrsFree(WStr1);
        }
    }

    //
    // Raise a eventlog message if there isn't enough disk space on the logging volume
    // to accomodate all the log files.
    //
    if (DebugInfo.LogDir != NULL) {
        FreeBytes.QuadPart = QUADZERO;
        TotalBytes.QuadPart = QUADZERO;
        if (GetDiskFreeSpaceEx(DebugInfo.LogDir,
                           &FreeBytes,
                           &TotalBytes,
                           NULL)) {
            //
            // Complain if we have less than 10 MB free.
            //
            if (FreeBytes.QuadPart < (10 * 1000 * 1000)) {
                EPRINT1(EVENT_FRS_LOG_SPACE, DebugInfo.LogDir);
            }
        }
    }


}



VOID
DbgQueryDynamicConfigParams(
    )
/*++
Routine Description:

    Read the registry for new values for config params that can change
    while service is running.

Arguments:

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgQueryDynamicConfigParams:"

    DWORD CompressStagingFiles = 1;
    PWCHAR WStr = NULL;


    //
    // Pick up new debug logging related parameters.
    //
    DbgQueryLogParams();

    //
    // Get boolean to tell us if we should do automatic restore when
    // we hit journal wrap
    //
    CfgRegReadDWord(FKC_ENABLE_JOURNAL_WRAP_AUTOMATIC_RESTORE, NULL, 0, &DebugInfo.EnableJrnlWrapAutoRestore);

    //
    // Check if automatic cleanup of staging files is enabled or disabled.
    //
    CfgRegReadDWord(FKC_RECLAIM_STAGING_SPACE, NULL, 0, &DebugInfo.ReclaimStagingSpace);

    //
    // Check if a new value for outlog history time is set.
    //
    CfgRegReadDWord(FKC_OUTLOG_CHANGE_HISTORY, NULL, 0, &DebugInfo.OutlogChangeHistory);

    //
    // Check if saving outlog history is disabled.
    //
    CfgRegReadDWord(FKC_SAVE_OUTLOG_CHANGE_HISTORY, NULL, 0, &DebugInfo.SaveOutlogChangeHistory);

    //
    // Check if a new value for install override is set.
    //
    CfgRegReadDWord(FKC_ENABLE_INSTALL_OVERRIDE, NULL, 0, &DebugInfo.EnableInstallOverride);

    //
    // Check if a new value for forced rename on file updates is set.
    //
    CfgRegReadDWord(FKC_ENABLE_RENAME_BASED_UPDATES, NULL, 0, &DebugInfo.EnableRenameUpdates);

    //
    // Check if suppress identical updates is disabled.
    //
    CfgRegReadDWord(FKC_SUPPRESS_IDENTICAL_UPDATES, NULL, 0, &DebugInfo.SuppressIdenticalUpdt);

    //
    // Read the new value for the compression parameter.
    //
    CfgRegReadDWord(FKC_COMPRESS_STAGING_FILES, NULL, 0, &CompressStagingFiles);
    DisableCompressionStageFiles = (CompressStagingFiles == 0);

    //
    // Pick up the Outlog file repeat interval.
    //
    CfgRegReadDWord(FKC_OUTLOG_REPEAT_INTERVAL, NULL, 0, &GOutLogRepeatInterval);

    //
    // Find out which reparse points to replicate.
    //
    CfgRegReadReparseTagInfo();

    //
    // Get the Test code params.  They consist of a code name, a sub-code
    // number, a trigger count and a trigger count refresh value.
    //
    CfgRegReadString(FKC_DEBUG_TEST_CODE_NAME, NULL, 0, &WStr);
    if (WStr != NULL) {
        DebugInfo.TestCodeName = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        WStr = FrsFree(WStr);
    }

    CfgRegReadDWord(FKC_DEBUG_TEST_CODE_NUMBER, NULL, 0, &DebugInfo.TestSubCodeNumber);

    CfgRegReadDWord(FKC_DEBUG_TEST_TRIGGER_COUNT, NULL, 0, &DebugInfo.TestTriggerCount);

    CfgRegReadDWord(FKC_DEBUG_TEST_TRIGGER_REFRESH, NULL, 0, &DebugInfo.TestTriggerRefresh);

}


VOID
DbgInitLogTraceFile(
    IN LONG    argc,
    IN PWCHAR  *argv
    )
/*++
Routine Description:

    Initialize enough of the debug subsystem to start the log file.
    The rest can wait until we have synced up with the service controller.

Arguments:
    argc    - from main
    argv    - from main; in wide char format

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgInitLogTraceFile:"

    PWCHAR  WStr;
    PWCHAR  File;
    DWORD   WStatus;

    //
    // Configure initial debug params until we read registry.
    //
    DebugInfo.AssertSeconds = 0;
    DebugInfo.RestartSeconds = 0;
    DebugInfo.Queues = 0;
    DebugInfo.DbsOutOfSpace = DBG_DBS_OUT_OF_SPACE_OP_NONE;
    DebugInfo.DbsOutOfSpaceTrigger = 0;

    //
    // Get the logging config params.
    // Registry overrides defaults and CLI overrides registry.
    //

    //
    //   Disable Debug
    //
    CfgRegReadDWord(FKC_DEBUG_DISABLE, NULL, 0, &DebugInfo.Disabled);
    if (FrsSearchArgv(argc, argv, L"disabledebug", NULL)) {
        DebugInfo.Disabled = TRUE;
    }

    //
    //   Log File (really the dir containing the log files)
    //
    FrsSearchArgv(argc, argv, L"logfile", &DebugInfo.LogDir);
    if (DebugInfo.LogDir == NULL) {
        CfgRegReadString(FKC_DEBUG_LOG_FILE, NULL, 0, &DebugInfo.LogDir);
    }

    if (DebugInfo.LogDir != NULL) {
        //
        // Add the filename prefix to the end of the dir path.
        //
        DebugInfo.LogFile = FrsWcsCat(DebugInfo.LogDir, NTFRS_DBG_LOG_FILE);
    } else {
        DebugInfo.LogFile = NULL;
    }


    //
    //   Share for copying log/assert files
    //
    FrsSearchArgv(argc, argv, L"assertshare", &DebugInfo.AssertShare);
    if (DebugInfo.AssertShare == NULL) {
        CfgRegReadString(FKC_DEBUG_ASSERT_SHARE, NULL, 0, &DebugInfo.AssertShare);
    }

    //
    //   Copy log files into assert share
    //
    CfgRegReadDWord(FKC_DEBUG_COPY_LOG_FILES, NULL, 0, &DebugInfo.CopyLogs);

    //
    //   Number of assert files
    //
    if (!FrsSearchArgvDWord(argc, argv, L"assertfiles", &DebugInfo.AssertFiles)) {
        CfgRegReadDWord(FKC_DEBUG_ASSERT_FILES, NULL, 0, &DebugInfo.AssertFiles);
    }

    //
    //   Number of log files
    //
    if (!FrsSearchArgvDWord(argc, argv, L"logfiles", &DebugInfo.LogFiles)) {
        CfgRegReadDWord(FKC_DEBUG_LOG_FILES, NULL, 0, &DebugInfo.LogFiles);
    }

    //
    //   Flush the trace log after every n lines.
    //
    if (!FrsSearchArgvDWord(argc, argv, L"logflushinterval", &DebugInfo.LogFlushInterval)) {
        CfgRegReadDWord(FKC_DEBUG_LOG_FLUSH_INTERVAL, NULL, 0, &DebugInfo.LogFlushInterval);
    }

    //
    // Create the dir path to the share where Assert Logs are copied.
    //
    if ((DebugInfo.AssertShare != NULL) &&
         wcslen(DebugInfo.AssertShare) && wcslen(ComputerName)) {

        WStr = FrsWcsCat3(DebugInfo.AssertShare, L"\\", ComputerName);
        FrsFree(DebugInfo.AssertShare);
        DebugInfo.AssertShare = WStr;
        WStr = NULL;
    }

    //
    //   Severity for console print.
    //
    if (!FrsSearchArgvDWord(argc, argv, L"severity", &DebugInfo.Severity)) {
        CfgRegReadDWord(FKC_DEBUG_SEVERITY, NULL, 0, &DebugInfo.Severity);
    }

    //
    //   Log Severity
    //
    if (!FrsSearchArgvDWord(argc, argv, L"logseverity", &DebugInfo.LogSeverity)) {
        CfgRegReadDWord(FKC_DEBUG_LOG_SEVERITY, NULL, 0, &DebugInfo.LogSeverity);
    }

    //
    //   Systems - selected list of functions to trace.  trace all if NULL.
    //
    DebugInfo.Systems = NULL;
    if (!FrsSearchArgv(argc, argv, L"systems", &WStr)) {
        CfgRegReadString(FKC_DEBUG_SYSTEMS, NULL, 0, &WStr);
    }
    if (WStr != NULL) {
        DebugInfo.Systems = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        WStr = FrsFree(WStr);
    }

    //
    //   Maximum Log Messages
    //
    DebugInfo.MaxLogLines = DEFAULT_DEBUG_MAX_LOG;
    if (!FrsSearchArgvDWord(argc, argv, L"maxloglines", &DebugInfo.MaxLogLines)) {
        CfgRegReadDWord(FKC_DEBUG_MAX_LOG,  NULL, 0, &DebugInfo.MaxLogLines);
    }

    //
    //   Debugger serial line Print  (assume suppress so no dprints leak out)
    //
    DebugInfo.Suppress = TRUE;
    if (!FrsSearchArgv(argc, argv, L"debuggerprint", NULL)) {
        CfgRegReadDWord(FKC_DEBUG_SUPPRESS, NULL, 0, &DebugInfo.Suppress);
    } else {
        DebugInfo.Suppress = FALSE;
    }

    //
    //   Enable break into debugger if present.
    //
    DebugInfo.Break = TRUE;
    if (!FrsSearchArgv(argc, argv, L"break", NULL)) {
        CfgRegReadDWord(FKC_DEBUG_BREAK,  NULL, 0, &DebugInfo.Break);
    }

    //
    // Turn on debug log if desired.
    // Save old log files and open a new log file.
    //
    if (DebugInfo.LogFile != NULL) {
        //
        // Create the debug directory
        //
        if (!CreateDirectory(DebugInfo.LogDir, NULL)) {
            WStatus = GetLastError();

            if (!WIN_ALREADY_EXISTS(WStatus)) {
                //
                // Need some way to report the following.
                //
                //DPRINT1_WS(0, ":S: CreateDirectory(Logfile) %ws -- failed;",
                //           DebugInfo.LogFile, WStatus);

		EPRINT1(EVENT_FRS_BAD_DEBUG_DIR, DebugInfo.LogDir);
                DebugInfo.LogFile = FrsFree(DebugInfo.LogFile);
                DebugInfo.LogDir = FrsFree(DebugInfo.LogDir);
            }
        }

        if (DebugInfo.LogFile != NULL) {
            DbgShiftLogFiles(DebugInfo.LogFile,
                             LOG_FILE_SUFFIX,
                            (DebugInfo.CopyLogs) ? DebugInfo.AssertShare : NULL,
                             DebugInfo.LogFiles);
            DbgOpenLogFile();
        }
    }

    //
    // Executable's full path for symbols.
    //
    DbgExePathW[0] = L'\0';
    if (GetFullPathNameW(argv[0], MAX_PATH-4, DbgExePathW, &File) == 0) {
        DPRINT1(0, ":S: Could not get the full pathname for %ws\n", argv[0]);
    }

    if (!wcsstr(DbgExePathW, L".exe")) {
        wcscat(DbgExePathW, L".exe");
    }
    DPRINT1(0, ":S: Full pathname for %ws\n", DbgExePathW);

    if (_snprintf(DbgExePathA, sizeof(DbgExePathA), "%ws", DbgExePathW) < 0) {
        DbgExePathA[sizeof(DbgExePathA) - 1] = '\0';
        DPRINT1(0, ":S: Image path too long to get symbols for traceback: %ws\n", DbgExePathW);
        return;
    }

    //
    // Init the symbol support for stack traceback if we are tracking mem allocs.
    //      Don't use the memory subsystem until symbols are enabled
    //
    if (DebugInfo.Mem) {
        DbgStackInit();
    }

}


VOID
DbgMustInit(
    IN LONG    argc,
    IN PWCHAR  *argv
    )
/*++
Routine Description:
    Initialize the debug subsystem

Arguments:
    argc    - from main
    argv    - from main; in wide char format

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgMustInit:"

    ULONG   Len;
    LONG    i;
    PWCHAR  Wcs;
    PWCHAR  WStr;
    DWORD   WStatus;

    //
    // Init the known thread array.
    //
    for (i = 0; i < ARRAY_SZ(KnownThreadArray); i++) {
        KnownThreadArray[i].Name = NULL;
    }
    DbgCaptureThreadInfo2(L"First", NULL, GetCurrentThreadId());

    //
    // Get some config info for the debug log header.
    //
    OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionExW((POSVERSIONINFOW) &OsInfo);

    GetSystemInfo(&SystemInfo);

    //
    // When not running as a service, the exe will restart itself
    // after an assertion failure. When running as a service, the
    // service controller will restart the service.
    //
    // Rebuild the command line for restart.
    //
    if (!RunningAsAService) {
        #define RESTART_PARAM L" /restart"

        Len = wcslen(RESTART_PARAM) + 2;
        for (i = 0; i < argc; ++i) {
            Len += wcslen(argv[i]) + 1;
        }
        DebugInfo.CommandLine = FrsAlloc(Len * sizeof(WCHAR));

        for (i = 0; i < argc; ++i) {
            //
            // Give our parent process time to die so that it will
            // release its handles on the journal, database, ...
            //
            if (wcsstr(argv[i], L"restart")) {
                Sleep(5 * 1000);
                continue;
            }
            wcscat(DebugInfo.CommandLine, argv[i]);
            wcscat(DebugInfo.CommandLine, L" ");
        }
        wcscat(DebugInfo.CommandLine, RESTART_PARAM);
    }

    //
    //   Get rest of config params.  Command line takes precedence over registrr.
    //
    //
    //   Restart the service iff it has asserted and has run at least this long
    //   to avoid assert loops.
    //
    if (!FrsSearchArgvDWord(argc, argv, L"restartseconds", &DebugInfo.RestartSeconds)) {
        CfgRegReadDWord(FKC_DEBUG_RESTART_SECONDS,  NULL, 0, &DebugInfo.RestartSeconds);
    }

    //
    //   Sendmail recipient (future)
    //
    DebugInfo.Recipients = NULL;
    CfgRegReadString(FKC_DEBUG_RECIPIENTS, NULL, 0, &WStr);
    if (WStr != NULL) {
        DebugInfo.Recipients = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        WStr = FrsFree(WStr);
    }

    //
    //   Sendmail Profile (future)
    //
    DebugInfo.Profile = NULL;
    CfgRegReadString(FKC_DEBUG_PROFILE, NULL, 0, &WStr);
    if (WStr != NULL) {
        DebugInfo.Profile = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        WStr = FrsFree(WStr);
    }

    //
    //   Buildlab info
    //
    DebugInfo.BuildLab = NULL;
    CfgRegReadString(FKC_DEBUG_BUILDLAB, NULL, 0, &WStr);
    if (WStr != NULL) {
        DebugInfo.BuildLab = (wcslen(WStr)) ? FrsWtoA(WStr) : NULL;
        WStr = FrsFree(WStr);
    }

    //
    // Use the hardwired config file if there is no Directory Service.
    //
    if (FrsSearchArgv(argc, argv, L"nods", &WStr)) {
        NoDs = TRUE;
        if (WStr != NULL) {
            IniFileName = wcslen(WStr) ? WStr : NULL;
        }
    }

    //
    // Single machine is pretending to be several machines
    //
    if (FrsSearchArgv(argc, argv, L"server", &WStr)) {
        if ((WStr != NULL) && (wcslen(WStr) > 0)) {
            NoDs = TRUE;
            ServerName = WStr;
        }
    }

#ifdef DS_FREE

    NoDs = TRUE;
#endif DS_FREE

    //
    //  The following parameters are testing / debugging.
    //

    //
    //   Check queues
    //
    DebugInfo.Queues = TRUE;
    if (!FrsSearchArgv(argc, argv, L"queues", NULL)) {
        CfgRegReadDWord(FKC_DEBUG_QUEUES, NULL, 0, &DebugInfo.Queues);
    }

    //
    //   Enable VvJoin Tests
    //
    DebugInfo.VvJoinTests = FrsSearchArgv(argc, argv, L"vvjointests", NULL);

    //
    //   forcevvjoin on every join
    //
    DebugInfo.ForceVvJoin = FrsSearchArgv(argc, argv, L"vvjoin", NULL);

    //
    //   Enable rename fid test
    //
    DebugInfo.TestFid = FrsSearchArgv(argc, argv, L"testfid", NULL);

    //
    //   forceunjoin on one cxtion after N remote co's
    //
    DebugInfo.UnjoinTrigger = 0;
    FrsSearchArgvDWord(argc, argv, L"unjoin", &DebugInfo.UnjoinTrigger);

    //
    //   forceunjoin on one cxtion after N remote co's
    //
    DebugInfo.FetchRetryReset = 0;
    if (!FrsSearchArgvDWord(argc, argv, L"fetchretry", &DebugInfo.FetchRetryReset)) {
    }
    DebugInfo.FetchRetryTrigger = DebugInfo.FetchRetryReset;
    DebugInfo.FetchRetryInc     = DebugInfo.FetchRetryReset;

    //
    // Set interval for toggling the schedule
    //
    FrsSearchArgvDWord(argc, argv, L"interval", &DebugInfo.Interval);

    //
    //   Force an assert after N seconds (0 == don't assert)
    //
    DebugInfo.AssertSeconds = 0;
    if (!FrsSearchArgvDWord(argc, argv, L"assertseconds", &DebugInfo.AssertSeconds)) {
        CfgRegReadDWord(FKC_DEBUG_ASSERT_SECONDS, NULL, 0, &DebugInfo.AssertSeconds);
    }

    //
    //   Force REAL out of space errors on database operations
    //
    DebugInfo.DbsOutOfSpace = 0;
    if (!FrsSearchArgvDWord(argc, argv, L"dbsoutOfSpace", &DebugInfo.DbsOutOfSpace)) {
        CfgRegReadDWord(FKC_DEBUG_DBS_OUT_OF_SPACE, NULL, 0, &DebugInfo.DbsOutOfSpace);
    }

    //
    //   Trigger phoney out of space errors on database operations
    //
    DebugInfo.DbsOutOfSpaceTrigger = 0;
    if (!FrsSearchArgvDWord(argc, argv, L"outofspacetrigger", &DebugInfo.DbsOutOfSpaceTrigger)) {
        CfgRegReadDWord(FKC_DEBUG_DBS_OUT_OF_SPACE_TRIGGER, NULL, 0, &DebugInfo.DbsOutOfSpaceTrigger);
    }

    //
    // Enable compression. Default will be on.
    //
    CfgRegReadDWord(FKC_DEBUG_DISABLE_COMPRESSION, NULL, 0, &DebugInfo.DisableCompression);

    //
    // Check if automatic cleanup of staging files is enabled or disabled.
    //
    CfgRegReadDWord(FKC_RECLAIM_STAGING_SPACE, NULL, 0, &DebugInfo.ReclaimStagingSpace);

    //
    // Check if a new value for outlog history time is set.
    //
    CfgRegReadDWord(FKC_OUTLOG_CHANGE_HISTORY, NULL, 0, &DebugInfo.OutlogChangeHistory);

    //
    // Check if saving outlog history is disabled.
    //
    CfgRegReadDWord(FKC_SAVE_OUTLOG_CHANGE_HISTORY, NULL, 0, &DebugInfo.SaveOutlogChangeHistory);

    //
    // Check if a new value for install override is set.
    //
    CfgRegReadDWord(FKC_ENABLE_INSTALL_OVERRIDE, NULL, 0, &DebugInfo.EnableInstallOverride);

    //
    // Check if a new value for forced rename on file updates is set.
    //
    CfgRegReadDWord(FKC_ENABLE_RENAME_BASED_UPDATES, NULL, 0, &DebugInfo.EnableRenameUpdates);

    //
    // Check if suppress identical updates is disabled.
    //
    CfgRegReadDWord(FKC_SUPPRESS_IDENTICAL_UPDATES, NULL, 0, &DebugInfo.SuppressIdenticalUpdt);

    //
    // Ldap Search timeout. Default is 10 minutes.
    //
    CfgRegReadDWord(FKC_LDAP_SEARCH_TIMEOUT_IN_MINUTES, NULL, 0, &LdapSearchTimeoutInMinutes);

    //
    // Ldap Bind timeout. Default is 30 seconds.
    //
    CfgRegReadDWord(FKC_LDAP_BIND_TIMEOUT_IN_SECONDS, NULL, 0, &LdapBindTimeoutInSeconds);

    //
    // Get boolean to tell us if we should do automatic restore when
    // we hit journal wrap
    //
    CfgRegReadDWord(FKC_ENABLE_JOURNAL_WRAP_AUTOMATIC_RESTORE, NULL, 0, &DebugInfo.EnableJrnlWrapAutoRestore);

    //
    // Display the debug parameters.
    //
    DbgPrintInfo(0);



    //
    // Remember our start time (in minutes)
    //
    // 100-nsecs / (10 (microsecs) * 1000 (msecs) * 1000 (secs) * 60 (min)
    //
    GetSystemTimeAsFileTime((FILETIME *)&DebugInfo.StartSeconds);
    DebugInfo.StartSeconds /= (10 * 1000 * 1000);

}


VOID
DbgMinimumInit(
    VOID
    )
/*++
Routine Description:
    Called at the beginning of MainMinimumInit()

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DbgMinimumInit:"

    HANDLE  ThreadHandle;
    DWORD   ThreadId;
    //
    // This thread forces an assert after DebugInfo.AssertSeconds
    //
    if (DebugInfo.AssertSeconds) {
        ThreadHandle = (HANDLE)CreateThread(NULL,
                                            0,
                                            DbgForceAssert,
                                            NULL,
                                            0,
                                            &ThreadId);

        FRS_ASSERT(HANDLE_IS_VALID(ThreadHandle));

        DbgCaptureThreadInfo2(L"ForceAssert", DbgForceAssert, ThreadId);
        FRS_CLOSE(ThreadHandle);
    }
}


BOOL
DoDebug(
    IN ULONG Sev,
    IN UCHAR *DebSub
    )
/*++
Routine Description:
    Should we print this line

Arguments:
    sev
    debsub

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DoDebug:"

    //
    // Debugging has been disabled
    //
    if (DebugInfo.Disabled) {
        return FALSE;
    }

    //
    // Not important enough
    //
    if (Sev > DebugInfo.Severity && Sev > DebugInfo.LogSeverity) {
        return FALSE;
    }

    //
    // Not tracing this subsystem
    //
    if (DebSub &&
        DebugInfo.Systems &&
        (strstr(DebugInfo.Systems, DebSub) == NULL)) {
        return FALSE;
    }
    //
    // Not tracing this thread
    //
    if (DebugInfo.ThreadId &&
        GetCurrentThreadId() != DebugInfo.ThreadId) {
        return FALSE;
    }

    return TRUE;
}


VOID
DebPrintLine(
    IN ULONG    Sev,
    IN PCHAR    Line
    )
/*++
Routine Description:
    Print a line of debug output to various combinations
    of standard out, debugger, kernel debugger, and a log file.

Arguments:
    Sev
    Line

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebPrintLine:"

    DWORD   BytesWritten = 0;
    //
    // stdout
    //
    if ((Sev <= DebugInfo.Severity) && !RunningAsAService) {
        printf("%s", Line);
    }

    //
    // log file
    //
    if (HANDLE_IS_VALID(DebugInfo.LogFILE) && Sev <= DebugInfo.LogSeverity) {
        //
        // Number of messages exceeded; save the old file and
        // start afresh. The existing old file is deleted.
        //
        if (DebugInfo.LogLines > DebugInfo.MaxLogLines) {
            FrsFlushFile(L"LogFILE", DebugInfo.LogFILE);
            DbgFlushInterval = DebugInfo.LogFlushInterval;
            FRS_CLOSE(DebugInfo.LogFILE);

            DbgShiftLogFiles(DebugInfo.LogFile,
                             LOG_FILE_SUFFIX,
                             (DebugInfo.CopyLogs) ? DebugInfo.AssertShare : NULL,
                             DebugInfo.LogFiles);

            DbgOpenLogFile();
            DebugInfo.LogLines = 0;
            DebugInfo.PrintStats = TRUE;
        }

        if (HANDLE_IS_VALID(DebugInfo.LogFILE)) {
            WriteFile(DebugInfo.LogFILE,
                      Line,
                      strlen(Line),
                      &BytesWritten,
                      NULL);
            //
            // Flush the log file every DebugInfo.LogFlushInterval lines and on
            // every severity 0 message.
            //
            if ((--DbgFlushInterval < 0) || (Sev ==0)) {
                if (!WIN_SUCCESS(FrsFlushFile(L"LogFILE", DebugInfo.LogFILE))) {
                    FRS_CLOSE(DebugInfo.LogFILE);
                }
                DbgFlushInterval = DebugInfo.LogFlushInterval;
            }
        }
    }

    //
    // debugger
    //
    if ((Sev <= DebugInfo.Severity) && !DebugInfo.Suppress) {
        OutputDebugStringA(Line);
    }
}


BOOL
DebFormatLine(
    IN ULONG    Sev,
    IN BOOL     Format,
    IN PCHAR    DebSub,
    IN UINT     LineNo,
    IN PCHAR    Line,
    IN ULONG    LineSize,
    IN PUCHAR   Str,
    IN va_list  argptr
    )
/*++
Routine Description:
    Format the line of output

Arguments:
    DebSub
    LineNo
    Line
    LineSize
    Str

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebFormatLine:"

    ULONG       LineUsed;
    SYSTEMTIME  SystemTime;
    BOOL        Ret = TRUE;

    try {
        if (Format) {
            //
            // Increment the line count here to prevent counting
            // the several DPRINTs that don't have a newline.
            //
            ++DebugInfo.LogLines;
            ++DebugInfo.TotalLogLines;
            GetLocalTime(&SystemTime);

            if (_snprintf(Line,
                          LineSize,
                          "<%-31s%4u: %5u: S%1u: %02d:%02d:%02d> ",
                          (DebSub) ? DebSub : "NoName",
                          GetCurrentThreadId(),
                          LineNo,
                          Sev,
                          SystemTime.wHour,
                          SystemTime.wMinute,
                          SystemTime.wSecond) < 0) {
                Line[LineSize - 1] = '\0';
                Ret = FALSE;
            } else {
                LineUsed = strlen(Line);
            }

        } else {
            LineUsed = 0;
        }

        if (Ret) {
            if (((LineUsed + 1) >= LineSize) ||
                (_vsnprintf(Line + LineUsed, LineSize - LineUsed, Str, argptr) < 0)) {
                Ret = FALSE;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Ret = FALSE;
    }

    return Ret;
}



BOOL
DebFormatTrackingLine(
    IN PCHAR    Line,
    IN ULONG    LineSize,
    IN PUCHAR   Str,
    IN va_list  argptr
    )
/*++
Routine Description:
    Format the line of output

Arguments:
    Line
    LineSize
    Str

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebFormatTrackingLine:"

    ULONG       LineUsed = 0;
    SYSTEMTIME  SystemTime;
    BOOL        Ret = TRUE;

    try {
            //
            // Increment the line count here to prevent counting
            // the several DPRINTs that don't have a newline.
            //
            ++DebugInfo.LogLines;
            ++DebugInfo.TotalLogLines;
            GetLocalTime(&SystemTime);

            if (_snprintf(Line,
                          LineSize,
                          "%2d/%2d-%02d:%02d:%02d ",
                          SystemTime.wMonth,
                          SystemTime.wDay,
                          SystemTime.wHour,
                          SystemTime.wMinute,
                          SystemTime.wSecond) < 0) {
                Line[LineSize - 1] = '\0';
                Ret = FALSE;
            } else {
                LineUsed = strlen(Line);
            }


        if (Ret) {
            if (((LineUsed + 1) >= LineSize) ||
                (_vsnprintf(Line + LineUsed, LineSize - LineUsed, Str, argptr) < 0)) {
                Ret = FALSE;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Ret = FALSE;
    }

    return Ret;
}


VOID
DebPrintTrackingNoLock(
    IN ULONG   Sev,
    IN PUCHAR  Str,
    IN ... )
/*++
Routine Description:
    Format and print a line of tracking output to various combinations
    of standard out, debugger, kernel debugger, and a log file. The
    debug print lock is held and the caller filtered lines that
    shouldn't be printed.

Arguments:
    Sev     - severity level
    Str     - printf format

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebPrintTrackingNoLock:"


    CHAR    Buf[512];
    DWORD   BufUsed = 0;

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, Str);

    //
    // Print the line to some combination of stdout, file, and debugger
    //
    if (DebFormatTrackingLine(Buf, sizeof(Buf), Str, argptr)) {
        DebPrintLine(Sev, Buf);
    }

    va_end(argptr);
}


VOID
DebLock(
    VOID
    )
/*++
Routine Description:
    Acquire the print lock

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebLock:"

    EnterCriticalSection(&DebugInfo.Lock);
}



BOOL
DebTryLock(
    VOID
    )
/*++
Routine Description:
    Try to acquire the print lock

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebTryLock:"

    return TryEnterCriticalSection(&DebugInfo.Lock);
}


VOID
DebUnLock(
    VOID
    )
/*++
Routine Description:
    Release the print lock

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebUnLock:"

    BOOL    PrintStats;

    //
    // Print summary stats close to the beginning of each
    // log file. The stats may show up a few lines into
    // the new log file when callers hold the DebLock() across
    // several lines.
    //
    // Be careful not to recurse if MaxLogLines is smaller
    // than the number of lines in the stats.
    //
    if (DebugInfo.PrintStats) {
        if (DebugInfo.PrintingStats) {
            DebugInfo.PrintStats = FALSE;
        } else {
            DebugInfo.PrintingStats = TRUE;
        }
    }
    PrintStats = DebugInfo.PrintStats;
    LeaveCriticalSection(&DebugInfo.Lock);

    if (PrintStats) {
        DbgPrintAllStats();
        EnterCriticalSection(&DebugInfo.Lock);
        DebugInfo.PrintingStats = FALSE;
        LeaveCriticalSection(&DebugInfo.Lock);
    }
}


VOID
DebPrintNoLock(
    IN ULONG   Sev,
    IN BOOL    Format,
    IN PUCHAR  Str,
    IN PCHAR   DebSub,
    IN UINT    LineNo,
    IN ... )
/*++
Routine Description:
    Format and print a line of debug output to various combinations
    of standard out, debugger, kernel debugger, and a log file. The
    debug print lock is held and the caller filtered lines that
    shouldn't be printed.

Arguments:
    Sev     - severity filter
    Format  - Add format info?
    Str     - printf format
    DebSub  - module name
    LineNo

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebPrintNoLock:"


    CHAR    Buf[512];
    DWORD   BufUsed = 0;

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, LineNo);

    //
    // Print the line to some combination of stdout, file, and debugger
    //
    if (DebFormatLine(Sev, Format, DebSub, LineNo, Buf, sizeof(Buf), Str, argptr)) {
        DebPrintLine(Sev, Buf);
    }

    va_end(argptr);
}


VOID
DebPrint(
    IN ULONG   Sev,
    IN PUCHAR  Str,
    IN PCHAR   DebSub,
    IN UINT    LineNo,
    IN ... )
/*++
Routine Description:
    Format and print a line of debug output to various combinations
    of standard out, debugger, kernel debugger, and a log file.

Arguments:
    sev     - severity filter
    str     - printf format
    debsub  - module name
    LineNo

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "DebPrint:"


    CHAR    Buf[512];
    DWORD   BufUsed = 0;

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, LineNo);

    //
    // Don't print this
    //
    if (!DoDebug(Sev, DebSub)) {
        return;
    }

    //
    // Print the line to some combination of stdout, file, and debugger
    //
    DebLock();
    if (DebFormatLine(Sev, TRUE, DebSub, LineNo, Buf, sizeof(Buf), Str, argptr)) {
        DebPrintLine(Sev, Buf);
    }

    DebUnLock();
    va_end(argptr);

#if 0

static int                      failedload                  = FALSE;
static TRANSMITSPECIALFRAME_FN  lpfnTransmitSpecialFrame    = NULL;
        //
        //  Calling nal.dll from inside lsa causes a deadlock during startup
        //
        if ( /* (!RunningAsAService) &&*/  // davidor - lets try it.
            (NmDebugTest(sev, DebSub)))
        {
            if (failedload == FALSE) {

                //
                //  Only try to load the NetMon trace routine once.
                //

                if (!lpfnTransmitSpecialFrame) {
                    HINSTANCE hInst;

                    hInst = LoadLibrary (L"NAL.DLL" );
                    if (hInst) {
                    lpfnTransmitSpecialFrame =
                        (TRANSMITSPECIALFRAME_FN)GetProcAddress ( hInst, "TransmitSpecialFrame" );
                    }
                }

                if (lpfnTransmitSpecialFrame) {
                    int length;
                    int length2;
                    unsigned char buff[256];

                    if (DebSub) {
                        length = _snprintf(buff, sizeof(buff), "<%s%u:%u> ", DebSub, tid, uLineNo);
                        buff[sizeof(buff) - 1] = '\0';
                    } else {
                        length = 0;
                    }

                    length2 = _vsnprintf(buff + length, sizeof(buff) - length, str, argptr );

                    lpfnTransmitSpecialFrame(FRAME_TYPE_COMMENT,
                                             0,
                                             buff,
                                             length + length2 + 1 );
                } else {
                    failedload = TRUE;  // that was our one and only try to load the routine.
                }
            }
        }
#endif 0
}


VOID
DbgDoAssert(
    IN PCHAR    Exp,
    IN UINT     Line,
    IN PCHAR    Debsub
    )
/*++
Routine Description:
    Assertion failure; print a message and exit after allowing some
    time for shutdown.

Arguments:
    Exp     - failing assertion expression
    Line    - line number of failing expression
    Debsub  - module name of failing expression

Return Value:
    Doesn't return
--*/
{
#undef DEBSUB
#define DEBSUB "DbgDoAssert:"


    PWCHAR  ExpW;
    PWCHAR  DebsubW;
    WCHAR   LineW[32];

    //
    // Inform the world
    //
    FrsIsAsserting = TRUE;


    ExpW = FrsAtoW(Exp);
    DebsubW = FrsAtoW(Debsub);
    _snwprintf(LineW, 32, L"%d", Line);
    LineW[ARRAY_SZ(LineW)-1] = L'\0';
    //
    // Post an error log entry followed by recovery steps.
    //
    EPRINT3(EVENT_FRS_ASSERT, DebsubW, LineW, ExpW);
    EPRINT1(EVENT_FRS_IN_ERROR_STATE, JetPath);
    FrsFree(ExpW);
    FrsFree(DebsubW);

    //
    // Stack trace
    //
    if (!DebugInfo.Mem) {
        //
        // Init the symbols here since mem alloc tracing is off.
        //
        DbgStackInit();
    }
    DbgPrintStackTrace(0, Debsub, Line);

    //
    // Failing expression
    //
    DebPrint(0, ":S: ASSERTION FAILURE: %s\n", Debsub, Line, Exp);

    //
    // Save the log file as an assert file
    //
#if 0
    // disable saving assert logs under separate name; too confusing
    //
    if (HANDLE_IS_VALID(DebugInfo.LogFILE)) {
        DebLock();
        FrsFlushFile(L"LogFILE", DebugInfo.LogFILE);
        DbgFlushInterval = DebugInfo.LogFlushInterval;
        FRS_CLOSE(DebugInfo.LogFILE);
        DbgShiftLogFiles(DebugInfo.LogFile,
                         ASSERT_FILE_SUFFIX,
                         DebugInfo.AssertShare,
                         DebugInfo.AssertFiles);

        DebugInfo.LogFILE = CreateFile(LogPath,
                                       GENERIC_READ | GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_FLAG_BACKUP_SEMANTICS,
                                       NULL);
        DebugInfo.LogLines = 0;
        DebugInfo.PrintStats = TRUE;
        DebUnLock();
    }
#endif 0

    DEBUG_FLUSH();


    //
    // Break into the debugger, if any
    //
    if (DebugInfo.Break && IsDebuggerPresent()) {
        DebugBreak();
    }

    //
    // Shutting down during an assert seldom completes; a critical thread
    // is usually the thread that has asserted. One can't simply return
    // from an assert. So exit the process and trust jet and ntfrs to
    // recover at start up.
    //
    // FrsIsShuttingDown = TRUE;
    // SetEvent(ShutDownEvent);
    // ExitThread(1);

    //
    // Raise an exception.
    //
    if (--DbgRaiseCount <= 0) {
        exit(1);
    }

    XRAISEGENEXCEPTION( ERROR_OPERATION_ABORTED );

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\frssrvc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    service.c

Abstract:
    Routines that talk to the service controller.

Author:
    Billy J. Fuller 11-Apr-1997

Environment
    User mode winnt
--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>


extern SERVICE_STATUS           ServiceStatus;
extern CRITICAL_SECTION         ServiceLock;
extern SERVICE_STATUS_HANDLE    ServiceStatusHandle;

//
// This is a lookup table of legal/illegal service state transitions. FrsSetServiceStatus API
// uses this table to validate the input transition requested and takes appropriate action.
//

DWORD StateTransitionLookup[FRS_SVC_TRANSITION_TABLE_SIZE][FRS_SVC_TRANSITION_TABLE_SIZE] = {
    {0,                    SERVICE_STOPPED,         SERVICE_START_PENDING,     SERVICE_STOP_PENDING,      SERVICE_RUNNING           },
    {SERVICE_STOPPED,      FRS_SVC_TRANSITION_NOOP, FRS_SVC_TRANSITION_NOOP,   FRS_SVC_TRANSITION_ILLEGAL,FRS_SVC_TRANSITION_ILLEGAL},
    {SERVICE_START_PENDING,FRS_SVC_TRANSITION_LEGAL,FRS_SVC_TRANSITION_LEGAL,  FRS_SVC_TRANSITION_LEGAL,  FRS_SVC_TRANSITION_LEGAL  },
    {SERVICE_STOP_PENDING, FRS_SVC_TRANSITION_LEGAL,FRS_SVC_TRANSITION_ILLEGAL,FRS_SVC_TRANSITION_LEGAL,  FRS_SVC_TRANSITION_ILLEGAL},
    {SERVICE_RUNNING,      FRS_SVC_TRANSITION_LEGAL,FRS_SVC_TRANSITION_ILLEGAL,FRS_SVC_TRANSITION_LEGAL,  FRS_SVC_TRANSITION_NOOP   }
};


SC_HANDLE
FrsOpenServiceHandle(
    IN PTCHAR  MachineName,
    IN PTCHAR  ServiceName
    )
/*++
Routine Description:
    Open a service on a machine.

Arguments:
    MachineName - the name of the machine to contact
    ServiceName - the service to open

Return Value:
    The service's handle or NULL.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenServiceHandle:"

    SC_HANDLE       SCMHandle;
    SC_HANDLE       ServiceHandle;
    ULONG           WStatus;

    //
    // Attempt to contact the SC manager.
    //
    SCMHandle = OpenSCManager(MachineName, NULL, SC_MANAGER_CONNECT);
    if (!HANDLE_IS_VALID(SCMHandle)) {
        WStatus = GetLastError();

        DPRINT1_WS(0, ":SC: Couldn't open service control manager on machine %ws;",
                   MachineName, WStatus);
        return NULL;
    }

    //
    // Contact the service.
    //
    ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        WStatus = GetLastError();

        DPRINT2_WS(0, ":SC: Couldn't open service control manager for service (%ws) on machine %ws;",
                  ServiceName, MachineName, WStatus);
        ServiceHandle = NULL;
    }

    CloseServiceHandle(SCMHandle);

    return ServiceHandle;
}


DWORD
FrsGetServiceState(
    IN PWCHAR   MachineName,
    IN PWCHAR   ServiceName
    )
/*++
Routine Description:
    Return the service's state

Arguments:
    MachineName - the name of the machine to contact
    ServiceName - the service to check

Return Value:
    The service's state or 0 if the state could not be obtained.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetServiceState:"

    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  LocalServiceStatus;

    //
    // Open the service.
    //
    ServiceHandle = FrsOpenServiceHandle(MachineName, ServiceName);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        return 0;
    }

    //
    // Get the service's status
    //
    if (!QueryServiceStatus(ServiceHandle, &LocalServiceStatus)) {
        DPRINT3(0, ":SC: WARN - QueryServiceStatus(%ws, %ws) returned %d\n",
                MachineName, ServiceName, GetLastError());
        CloseServiceHandle(ServiceHandle);
        return 0;
    }

    CloseServiceHandle(ServiceHandle);

    //
    // Successfully retrieved service status; check state
    //
    return LocalServiceStatus.dwCurrentState;
}





BOOL
FrsIsServiceRunning(
    IN PWCHAR  MachineName,
    IN PWCHAR  ServiceName
    )
/*++
Routine Description:
    Is a service running on a machine.

Arguments:
    MachineName - the name of the machine to contact
    ServiceName - the service to check

Return Value:
    TRUE    - Service is running.
    FALSE   - Service is not running.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsIsServiceRunning:"

    DWORD   State;

    State = FrsGetServiceState(MachineName, ServiceName);
    return (State == SERVICE_RUNNING);
}


DWORD
FrsSetServiceFailureAction(
    VOID
    )
/*++

Routine Description:

    If unset, initialize the service's failure actions.

Arguments:


Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsSetServiceFailureAction:"


#define NUM_ACTIONS                     (3)
#define SERVICE_RESTART_MILLISECONDS    (30 * 60 * 1000)

    SC_HANDLE               ServiceHandle;
    DWORD                   BufSize, BytesNeeded;
    SC_ACTION               *Actions;
    SERVICE_FAILURE_ACTIONS *FailureActions;
    ULONG                   WStatus = ERROR_SUCCESS, i;


    if (!RunningAsAService || !HANDLE_IS_VALID(ServiceStatusHandle)) {
        return ERROR_SUCCESS;
    }

    BufSize = sizeof(SERVICE_FAILURE_ACTIONS) + sizeof(SC_ACTION) * NUM_ACTIONS;
    FailureActions = FrsAlloc(BufSize);

    EnterCriticalSection(&ServiceLock);

    //
    // Retrieve the current failure actions for the service NtFrs
    //
    ServiceHandle = FrsOpenServiceHandle(NULL, SERVICE_NAME);
    if (!HANDLE_IS_VALID(ServiceHandle)) {
        LeaveCriticalSection(&ServiceLock);
        FailureActions = FrsFree(FailureActions);
        DPRINT(0, ":SC: Failed to open service handle.\n");
        return ERROR_OPEN_FAILED;
    }

    if (!QueryServiceConfig2(ServiceHandle,
                             SERVICE_CONFIG_FAILURE_ACTIONS,
                             (PVOID)FailureActions,
                             BufSize,
                             &BytesNeeded)) {
        WStatus = GetLastError();

        CloseServiceHandle(ServiceHandle);
        LeaveCriticalSection(&ServiceLock);

        if (WIN_BUF_TOO_SMALL(WStatus)) {
            DPRINT(0, ":SC: Restart actions for service are already set.\n");
            WStatus = ERROR_SUCCESS;
        } else {
            DPRINT_WS(0, ":SC: Could not query service for restart action;", WStatus);
        }

        FailureActions = FrsFree(FailureActions);

        return WStatus;
    }

    //
    // Check if failure action already set.  E.g. by the User.
    //
    if (FailureActions->cActions) {

        CloseServiceHandle(ServiceHandle);

        LeaveCriticalSection(&ServiceLock);

        DPRINT(0, ":SC: Restart actions for service are already set.\n");
        FailureActions = FrsFree(FailureActions);

        return ERROR_SUCCESS;
    }

    //
    // Service failure actions are unset; initialize them
    //
    WStatus = ERROR_SUCCESS;
    Actions = (SC_ACTION *)(((PUCHAR)FailureActions) +
                             sizeof(SERVICE_FAILURE_ACTIONS));

    for (i = 0; i < NUM_ACTIONS; ++i) {
        Actions[i].Type = SC_ACTION_RESTART;
        Actions[i].Delay = SERVICE_RESTART_MILLISECONDS;
    }

    FailureActions->cActions = NUM_ACTIONS;
    FailureActions->lpsaActions = Actions;

    if (!ChangeServiceConfig2(ServiceHandle,
                              SERVICE_CONFIG_FAILURE_ACTIONS,
                              (PVOID)FailureActions)) {

        WStatus = GetLastError();
    }

    CloseServiceHandle(ServiceHandle);
    LeaveCriticalSection(&ServiceLock);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":SC: Could not set restart actions;", WStatus);
    } else {
        DPRINT(4, ":SC: Success setting restart actions for service.\n");
    }

    FailureActions = FrsFree(FailureActions);

    return WStatus;

}



BOOL
FrsWaitService(
    IN PWCHAR   MachineName,
    IN PWCHAR   ServiceName,
    IN INT      IntervalMS,
    IN INT      TotalMS
    )
/*++
Routine Description:
    This routine determines if the specified NT service is in a running
    state or not. This function will sleep and retry once if the service
    is not yet running.

Arguments:
    MachineName     - machine to contact
    ServiceName     - Name of the NT service to interrogate.
    IntervalMS      - Check every IntervalMS milliseconds.
    TotalMS         - Stop checking after this long.

Return Value:
    TRUE    - Service is running.
    FALSE   - Service state cannot be determined.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsWaitService:"

    do {
        if (FrsIsServiceRunning(MachineName, ServiceName)) {
            return TRUE;
        }

        if (FrsIsShuttingDown) {
            break;
        }

        Sleep(IntervalMS);

    } while ((TotalMS -= IntervalMS) > 0);

    DPRINT2(0, ":SC: %ws is not running on %ws\n", ServiceName, ComputerName);

    return FALSE;
}





DWORD
FrsSetServiceStatus(
    IN DWORD    State,
    IN DWORD    CheckPoint,
    IN DWORD    Hint,
    IN DWORD    ExitCode
    )
/*++

Routine Description:

    Acquire the service lock, ServiceLock, and set the service's state
    using the global service handle and service status set in main.c.
    Check if this is a valid state transition using the lookup table.
    This will prevent the service from making any invalid state transitions.

Arguments:

    Status      - Set the state to this value
    Hint        - Suggested timeout for the service controller
    ExitCode    - For SERVICE_STOPPED;

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsSetServiceStatus:"

    DWORD   WStatus = ERROR_SUCCESS;
    BOOL    Ret;
    DWORD   FromState,ToState;
    DWORD   TransitionCheck = FRS_SVC_TRANSITION_ILLEGAL;

    //
    // Set the service's status after acquiring the lock
    //
    if (RunningAsAService && HANDLE_IS_VALID(ServiceStatusHandle)) {

        EnterCriticalSection(&ServiceLock);
        //
        // Check if this is a valid service state transition.
        //
        for (FromState = 0 ; FromState < FRS_SVC_TRANSITION_TABLE_SIZE ; ++FromState) {
            for (ToState = 0 ; ToState < FRS_SVC_TRANSITION_TABLE_SIZE ; ++ToState) {
                if (StateTransitionLookup[FromState][0] == ServiceStatus.dwCurrentState &&
                    StateTransitionLookup[0][ToState] == State) {
                    TransitionCheck = StateTransitionLookup[FromState][ToState];
                    break;
                }
            }
        }

        if (TransitionCheck == FRS_SVC_TRANSITION_LEGAL) {
            DPRINT2(4,":SC: Current State = %d, Moving to %d\n", ServiceStatus.dwCurrentState, State);
            ServiceStatus.dwCurrentState = State;
            ServiceStatus.dwCheckPoint = CheckPoint;
            ServiceStatus.dwWaitHint = Hint;
            ServiceStatus.dwWin32ExitCode = ExitCode;
            //
            // Do not accept stop control unless the service is in SERVICE_RUNNING state.
            // This prevents the service from getting confused when a stop is called
            // while the service is starting.
            //
            if (ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
                ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
            } else {
                ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN;
            }
            Ret = SetServiceStatus(ServiceStatusHandle, &ServiceStatus);

            if (!Ret) {
                WStatus = GetLastError();
                DPRINT1_WS(0, ":SC: ERROR - SetServiceStatus(%d);", ServiceStatus, WStatus);
            } else {
                DPRINT4(0, ":SC: SetServiceStatus(State %d, CheckPoint %d, Hint %d, ExitCode %d) succeeded\n",
                        State, CheckPoint, Hint, ExitCode);
            }
        } else if (TransitionCheck == FRS_SVC_TRANSITION_ILLEGAL) {
            DPRINT2(0,":SC: Error - Illegal service state transition request. From State = %d, To %d\n", ServiceStatus.dwCurrentState, State);
            WStatus = ERROR_INVALID_PARAMETER;
        }
        LeaveCriticalSection(&ServiceLock);
    }
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\ntutils.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ntutils.c

Abstract:

    This module contains various tools from NT land. Made a separate
    file because of the use of various nt headers.


--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>

#include <ntdddisk.h>

BOOL
FrsIsDiskWriteCacheEnabled(
    IN PWCHAR Path
    )
/*++

Description:

    Determines if the disk has enabled write caching.

Arguments:

    Path    - Fully qualified path of a file or directory

Return value:

    TRUE if write cache is enabled, FALSE otherwise.

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsIsDiskWriteCacheEnabled:"
    DWORD               WStatus;
    ULONG               bytesTransferred;
    PWCHAR              Volume = NULL;
    HANDLE              driveHandle = INVALID_HANDLE_VALUE;

    DISK_CACHE_INFORMATION cacheInfo;
    cacheInfo.WriteCacheEnabled = FALSE;

    try {
        //
        // Extract the volume from Path
        //
        Volume = FrsWcsVolume(Path);
        if (!Volume) {
            goto CLEANUP;
        }

        //
        // Open handle to the PhysicalDrive
        //
        DPRINT1(4, ":S: Checking the write cache state on %ws\n", Volume);
        driveHandle = CreateFile(Volume,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL);

        if (!HANDLE_IS_VALID(driveHandle)) {
            WStatus = GetLastError();
            DPRINT1_WS(4, ":S: WARN - Could not open drive %ws;", Volume, WStatus);
            goto CLEANUP;
        }


        //
        // Get cache info - IOCTL_DISK_GET_CACHE_INFORMATION
        //
        if (!DeviceIoControl(driveHandle,
                             IOCTL_DISK_GET_CACHE_INFORMATION,
                             NULL,
                             0,
                             &cacheInfo,
                             sizeof(DISK_CACHE_INFORMATION),
                             &bytesTransferred,
                             NULL))   {
            WStatus = GetLastError();
            DPRINT1_WS(4, ":S: WARN - DeviceIoControl(%ws);", Volume, WStatus);
            goto CLEANUP;
        }

        DPRINT2(4, ":S: NEW IOCTL: Write cache on %ws is %s\n",
                Volume, (cacheInfo.WriteCacheEnabled) ? "Enabled (WARNING)" : "Disabled");

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "ERROR - Exception.", WStatus);
    }
    //
    // Cleanup handles, memory, ...
    //
    try {
        FRS_CLOSE(driveHandle );
        FrsFree(Volume);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "ERROR - Cleanup Exception.", WStatus);
    }

    return cacheInfo.WriteCacheEnabled;

} // IsDiskWriteCacheEnabled
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\qhash.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    qhash.c

Abstract:

Quick Hash Table routines.  Unlike the Genhash table functions these routines
use a fixed size node (QHASH_ENTRY) and the data fields are passed as
parameters and copied into the node.  The generic hash functions include a
link entry in the users struct to link the node onto a hash chain.  The genhash
functions also include reference counts for the nodes.

The generic hash functions have a lock per hash row where a Qhash table
has only a single lock for the table.

The PQHASH_TABLE struct is a typed struc allocated with FrsAllocTypeSize().

QHASH tables can be used in two ways, for fixed size QuadWord keys and for
more complex non-Quadword keys.

For QHASH tables with QuadWord keys:

    The macro SET_QHASH_TABLE_HASH_CALC() is used to specify the hash function
    to use for the table.  The key is supplied as a quadword and each entry has
    longword flags and a quadword data field for the callers info.

For QHASH tables with Large keys:

    When the QHASH table is created you specify it as a large key table (i.e.
    not a simple Quadword Key) by doing:

    SET_QHASH_TABLE_FLAG(HashTable, QHASH_FLAG_LARGE_KEY);

    For large key tables the QHASH_ENTRY Flags ULONG_PTR and the Flags argument
    to QHashInsert() are expected to point at a caller defined data node with
    the large key value for the node at offset zero.  On lookups the HashCalc2
    function set by SET_QHASH_TABLE_HASH_CALC2() is used to calculate both the
    quadword key for the hashtable entry and the hash value used for indexing
    the main array.  In addition the caller specifies an exact key match
    function via SET_QHASH_TABLE_KEY_MATCH() to be used after the initial
    quadword key matches.  This key match function is passed both the lookup
    argument key and the node address that was saved in the QHASH_ENTRY Flags
    ULONG_PTR so it can perform the complete key match.

The macros QHashAcquireLock(_Table_) and QHashReleaseLock(_Table_) can
be used to lock the table over multiple operations.

The number of entries in the hash table array is specified by the allocation size
when the table is allocated.  When a collision occurs additional entries
are allocated and placed on a free list for use in the collision lists.

The storage for the base hash array and the collision entries are released
when the table is freed by calling FrsFreeType(Table).

An example of allocating a Qhash table with 100 entries in the base hash array:

//PQHASH_TABLE FrsWriteFilter;
//#define FRS_WRITE_FILTER_SIZE       sizeof(QHASH_ENTRY)*100

//    FrsWriteFilter = FrsAllocTypeSize(QHASH_TABLE_TYPE, FRS_WRITE_FILTER_SIZE);
//    SET_QHASH_TABLE_HASH_CALC(FrsWriteFilter, JrnlHashCalcUsn);


Author:

    David Orbits          [davidor]   22-Apr-1997

Environment:

    User Mode Service

Revision History:


--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>


ULONG
QHashDump (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
/*++

Routine Description:

    This function is called thru QHashEnumerateTable() to dump an entry.

Arguments:

    Table - the hash table being enumerated
    BeforeNode  -- ptr to the QhashEntry before the node of interest.
    TargetNode  -- ptr to the QhashEntry of interest.
    Context - Unused.

Return Value:

    FrsErrorStatus

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDump:"

    DPRINT4(5, "Link: %08x, Flags: %08x, Tag: %08x %08x, Data: %08x %08x\n",
           TargetNode->NextEntry,
           TargetNode->Flags,
           PRINTQUAD(TargetNode->QKey),
           PRINTQUAD(TargetNode->QData));

    return FrsErrorSuccess;
}



VOID
QHashExtendTable(
    IN PQHASH_TABLE HashTable
    )
 /*++

 Routine Description:

 Extend the number of entries in the hash table by allocating an
 extension block of up to QHASH_EXTENSION_MAX entries.

 The caller has the table lock.

 Arguments:

     HashTable  --  ptr to a PQHASH_TABLE struct.

 Return Value:

     None.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashExtendTable:"

    ULONG i, NumberExtEntries;
    PQHASH_ENTRY Ext;

    //
    // Allocate a block of memory.
    //
    Ext = FrsAlloc(HashTable->ExtensionAllocSize);
    InsertTailList(&HashTable->ExtensionListHead, (PLIST_ENTRY)Ext);
    NumberExtEntries = (HashTable->ExtensionAllocSize - sizeof(LIST_ENTRY)) /
                       sizeof(QHASH_ENTRY);

    //
    // Put the entries on the free list.
    //
    (PCHAR) Ext = (PCHAR)Ext + sizeof(LIST_ENTRY);

    HashTable->FreeList.Next = &Ext->NextEntry;

    for (i=0; i<NumberExtEntries; i++) {
        Ext->NextEntry.Next = &((Ext+1)->NextEntry);
        Ext++;
    }
    Ext -= 1;
    Ext->NextEntry.Next = NULL;
}


ULONG
QHashEnumerateTable(
    IN PQHASH_TABLE HashTable,
    IN PQHASH_ENUM_ROUTINE Function,
    IN PVOID         Context
    )
/*++

Routine Description:

    This routine walks through the entries in the QHash table
    and calls the function provided with the entry address and the context.
    The table lock is acquired and released here.

Arguments:

    HashTable - The context of the Hash Table to enumerate.
    Function - The function to call for each record in the table.  It is of
               of type PQHASH_ENUM_ROUTINE.  Return FALSE to abort the
               enumeration else true.
    Context - A context ptr to pass through to the RecordFunction.

Return Value:

    The FrsErrorStatus code from the argument function.

--*/

{
#undef DEBSUB
#define DEBSUB "QHashEnumerateTable:"

    PQHASH_ENTRY HashRowEntry;
    PQHASH_ENTRY BeforeEntry;
    ULONG i, FStatus;

    if (HashTable == NULL) {
        return FrsErrorSuccess;
    }

    HashRowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and call the function for
    // each element.
    //

    QHashAcquireLock(HashTable);

    for (i=0; i<HashTable->NumberEntries; i++, HashRowEntry++) {

        if (HashRowEntry->QKey != QUADZERO) {

            FStatus = (Function)(HashTable, NULL, HashRowEntry, Context);
            if (FStatus == FrsErrorDeleteRequested) {
                HashRowEntry->QKey = QUADZERO;
            }
            else
            if (FStatus != FrsErrorSuccess) {
                QHashReleaseLock(HashTable);
                return FStatus;
            }
        }

        //
        // Enumerate collision list if present.
        //
        if (HashRowEntry->NextEntry.Next == NULL) {
            continue;
        }

        BeforeEntry = HashRowEntry;
        ForEachSingleListEntry(&HashRowEntry->NextEntry, QHASH_ENTRY, NextEntry,
            // Enumerator pE is of type PQHASH_ENTRY
            FStatus = (Function)(HashTable, BeforeEntry, pE, Context);

            if (FStatus == FrsErrorDeleteRequested) {
                RemoveSingleListEntry(UNUSED);
                PushEntryList(&HashTable->FreeList, &pE->NextEntry);
                pE = PreviousSingleListEntry(QHASH_ENTRY, NextEntry);
            }
            else

            if (FStatus != FrsErrorSuccess) {
                QHashReleaseLock(HashTable);
                return FStatus;
            }
            BeforeEntry = pE;
        );
    }


    QHashReleaseLock(HashTable);

    return FStatus;

}




GHT_STATUS
QHashLookup(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    OUT PULONGLONG  QData,
    OUT PULONG_PTR  Flags
    )
/*++

Routine Description:

Lookup the Quadword Key in the hash table and if found, return the Qdata
and the flags DWORD.

The table lock is acquired and released here.

 Note: A zero value for QKey is an error because a zero is used
       to denote an empty hash table slot.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    ArgQKey  -- ptr to the Key we are looking for.
    QData  -- If found this is the returned quadword data. (NULL if unused)
    Flags  -- If found this is the returned flags word.

Return Value:

    GHT_STATUS_NOT_FOUND -- if not found.
    GHT_STATUS_SUCCESS -- if found.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashLookup:"

    ULONGLONG QKey;
    ULONG GStatus;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;
    PQHASH_ENTRY LastFoundpE = NULL;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHashLookup (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);

    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    QHashAcquireLock(HashTable);

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {

            //
            // Match.  Return quadword data and flags.
            //
            if (QData != NULL) {
                *QData = RowEntry->QData;
            }
            *Flags = RowEntry->Flags;
            DPRINT5(5, "QHash Lookup (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);
            QHashReleaseLock(HashTable);
            return GHT_STATUS_SUCCESS;
        }
    }


    if (RowEntry->NextEntry.Next == NULL) {
        QHashReleaseLock(HashTable);
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        //
        if (QKey < pE->QKey) {
            //
            // Not on the list.
            //
            break;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it.
                //
                if (QData != NULL) {
                    *QData = pE->QData;
                }
                *Flags = pE->Flags;
                DPRINT5(5, "QHash Lookup (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);
                QHashReleaseLock(HashTable);
                return GHT_STATUS_SUCCESS;
            }
        }
    );

    QHashReleaseLock(HashTable);
    return GHT_STATUS_NOT_FOUND;
}



PQHASH_ENTRY
QHashLookupLock(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey
    )
/*++

Routine Description:

Lookup the Quadword Key in the hash table and if found, return the pointer to
the entry. The table lock is acquired and released by the caller.

Restriction:

    Once the caller drops the table lock no further ref to the QHASH_ENTRY
    is allowed since another thread could delete/update it.

 Note: A zero value for the key is an error because a zero is used
       to denote an empty hash table slot.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    ArgQKey  -- ptr to the Key we are looking for.

Return Value:

    Pointer to QHashEntry, Null if not found.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashLookupLock:"

    ULONGLONG QKey;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHash lookuplock (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);

    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            DPRINT5(5, "QHash Lookup (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);
            return RowEntry;
        }
    }

    if (RowEntry->NextEntry.Next == NULL) {
        return NULL;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        // Check for early terminate and then for a match.
        //
        if (QKey < pE->QKey) {
            return NULL;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                DPRINT5(5, "QHash Lookup (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);
                return pE;
            }
        }
    );

    return NULL;
}




GHT_STATUS
QHashInsert(
    IN PQHASH_TABLE HashTable,
    IN PVOID      ArgQKey,
    IN PULONGLONG QData,
    IN ULONG_PTR Flags,
    IN BOOL HaveLock
    )

 /*++

 Routine Description:

 Insert the Quadword Key in the hash table and if found, return the data
 and the flags DWORD.  The keys are in numerically increasing order on the
 collision chains.

 The table lock is acquired and released here.

 Note: A zero value for the key is an error because a zero is used
       to denote an empty hash table slot.

 Arguments:

     HashTable  --  ptr to a PQHASH_TABLE struct.
     ArgQKey  -- ptr to the Key we are inserting.
     QData  -- This is ptr to the quadword data. (NULL if unused).
     Flags  -- This is the flags word data.  For large Key QHASH tables this
               is the ptr to the data node.  Note that we assume the large
               Key is at a zero offset in the node when doing lookups.
     HaveLock -- True means the caller has taken the lock else we take it.

 Return Value:

    GHT_STATUS_FAILURE -- Conflicting entry is in table already.
    GHT_STATUS_SUCCESS -- Insert was successful.


--*/

{
#undef DEBSUB
#define DEBSUB  "QHashInsert:"

    ULONGLONG QKey;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry, AfterEntry;
    PQHASH_ENTRY pNew;
    PSINGLE_LIST_ENTRY NewEntry;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHashInsert (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));

    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);

    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (!HaveLock) {QHashAcquireLock(HashTable);}

    if (RowEntry->QKey == QUADZERO) {
        pNew = RowEntry;
        goto INSERT_ENTRY;
    }


    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            if (!HaveLock) {QHashReleaseLock(HashTable);}
            return GHT_STATUS_FAILURE;
        }
    }
    AfterEntry  = RowEntry;

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        //
        if (QKey < pE->QKey) {
            //
            // Not on the list.
            //
            break;
        }

        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it, collision.
                //
                if (!HaveLock) {QHashReleaseLock(HashTable);}
                return GHT_STATUS_FAILURE;
            }
        }
        AfterEntry = pE;
    );

    //
    // Not found.  Allocate a new entry and put it in the list.
    //
    NewEntry = PopEntryList(&HashTable->FreeList);
    if (NewEntry == NULL) {
        //
        // Allocate a table extension block.
        //
        QHashExtendTable(HashTable);
        NewEntry = PopEntryList(&HashTable->FreeList);
    }
    //
    // Insert entry in the list.
    //
    pNew = CONTAINING_RECORD(NewEntry, QHASH_ENTRY, NextEntry);
    PushEntryList( &AfterEntry->NextEntry, &pNew->NextEntry);

    //
    // Insert the data and drop the lock.
    //
INSERT_ENTRY:
    pNew->QKey = QKey;
    pNew->Flags = Flags;
    if (QData != NULL) {
        pNew->QData = *QData;
    } else {
        pNew->QData = QUADZERO;
    }

    DPRINT5(5, "QHash Insert (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
         HashTable, pNew, PRINTQUAD(pNew->QKey), PRINTQUAD(pNew->QData), pNew->Flags);

    if (!HaveLock) {QHashReleaseLock(HashTable);}
    return GHT_STATUS_SUCCESS;
}



PQHASH_ENTRY
QHashInsertLock(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    IN PULONGLONG   QData,
    IN ULONG_PTR    Flags
    )

 /*++

 Routine Description:

 Insert the quadword key in the hash table.  Return the pointer to the entry.
 The caller has acquired the table lock and will release it.

 Arguments:

     HashTable  --  ptr to a PQHASH_TABLE struct.
     ArgQKey  -- ptr to the Key we are inserting.
     QData  -- This is ptr to the quadword data. (NULL if unused)
     Flags  -- This is the flags word data.  For large Key QHASH tables this
               is the ptr to the data node.  Note that we assume the large
               Key is at a zero offset in the node when doing lookups.

 Return Value:

    The ptr to the inserted entry or the existing entry if already in the table.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashInsertLock:"

    ULONGLONG QKey;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry, AfterEntry;
    PQHASH_ENTRY pNew;
    PSINGLE_LIST_ENTRY NewEntry;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHashInsertLock (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);
    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (RowEntry->QKey == QUADZERO) {
        pNew = RowEntry;
        goto INSERT_ENTRY;
    }

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            return RowEntry;
        }
    }
    AfterEntry  = RowEntry;

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.  Check for early termination.
        //
        if (QKey < pE->QKey) {
            break;
        }

        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it, return the pointer.
                //
                return pE;
            }
        }
        AfterEntry = pE;
    );

    //
    // Not found.  Allocate a new entry and put it in the list.
    //
    NewEntry = PopEntryList(&HashTable->FreeList);
    if (NewEntry == NULL) {
        //
        // Allocate a table extension block.
        //
        QHashExtendTable(HashTable);
        NewEntry = PopEntryList(&HashTable->FreeList);
    }
    //
    // Insert entry in the list.
    //
    pNew = CONTAINING_RECORD(NewEntry, QHASH_ENTRY, NextEntry);
    PushEntryList( &AfterEntry->NextEntry, &pNew->NextEntry);

    //
    // Insert the data.
    //
INSERT_ENTRY:
    pNew->QKey = QKey;
    pNew->Flags = Flags;

    if (QData != NULL) {
        pNew->QData = *QData;
    } else {
        pNew->QData = QUADZERO;
    }


    DPRINT5(5, "QHash Insert (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
         HashTable, pNew, PRINTQUAD(pNew->QKey), PRINTQUAD(pNew->QData), pNew->Flags);

    return pNew;
}




GHT_STATUS
QHashUpdate(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    IN PULONGLONG   QData,
    IN ULONG_PTR    Flags
    )
/*++

Routine Description:

Lookup the Quadword key in the hash table and if found, update the entry.

The table lock is acquired and released here.

 Arguments:

     HashTable  --  ptr to a PQHASH_TABLE struct.
     ArgQKey  -- ptr to the Key we are updating.
     QData  -- This is ptr to the quadword data. (NULL if unused)
     Flags  -- This is the flags word data.  For large Key QHASH tables this
               is the ptr to the data node.  Note that we assume the large
               Key is at a zero offset in the node when doing lookups.

 Return Value:

    GHT_STATUS_FAILURE -- Entry not in table already.
    GHT_STATUS_SUCCESS -- Update was successful.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashUpdate:"

    ULONGLONG QKey;
    ULONG GStatus;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;
    PQHASH_ENTRY LastFoundpE = NULL;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
        DPRINT3(5, "QHashupdate (%08x): Hval: %08x  QKey: %08lx %08lx\n",
             HashTable, Hval, PRINTQUAD(QKey));
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);
    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    QHashAcquireLock(HashTable);

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {

            if (QData != NULL) {
                RowEntry->QData = *QData;
            }
            RowEntry->Flags = Flags;
            DPRINT5(5, "QHash Update (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);
            QHashReleaseLock(HashTable);
            return GHT_STATUS_SUCCESS;
        }
    }

    if (RowEntry->NextEntry.Next == NULL) {
        QHashReleaseLock(HashTable);
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        //
        if (QKey < pE->QKey) {
            //
            // Not on the list.
            //
            QHashReleaseLock(HashTable);
            return GHT_STATUS_NOT_FOUND;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it.
                //
                if (QData != NULL) {
                    pE->QData = *QData;
                }
                pE->Flags = Flags;

                DPRINT5(5, "QHash Update (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);

                QHashReleaseLock(HashTable);
                return GHT_STATUS_SUCCESS;
            }
        }
    );

    QHashReleaseLock(HashTable);
    return GHT_STATUS_NOT_FOUND;
}



GHT_STATUS
QHashDelete(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey
    )
/*++

Routine Description:

Lookup the Key in the hash table and if found remove it and put it on the
free list.

The table lock is acquired and released here.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    ArgQKey  -- ptr to the Key we are looking for.

Return Value:

    GHT_STATUS_NOT_FOUND -- if not found.
    GHT_STATUS_SUCCESS -- if found and deleted.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDelete:"

    ULONGLONG QKey;
    ULONG GStatus;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;
    PQHASH_ENTRY LastFoundpE = NULL;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);
    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    QHashAcquireLock(HashTable);


    if (RowEntry->QKey == QKey) {

        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            DPRINT5(5, "QHash Delete (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);

            if (IS_QHASH_LARGE_KEY(HashTable) && ((PVOID) RowEntry->Flags != NULL)) {
                (HashTable->HashFree)((PVOID) (RowEntry->Flags));
            }

            RowEntry->QKey = QUADZERO;
            RowEntry->Flags = 0;
            QHashReleaseLock(HashTable);
            return GHT_STATUS_SUCCESS;
        }
    }


    if (RowEntry->NextEntry.Next == NULL) {
        QHashReleaseLock(HashTable);
        return GHT_STATUS_NOT_FOUND;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        //
        if (QKey < pE->QKey) {
            //
            // Not on the list.
            //
            break;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it. Remove from list and put on free list.
                //
                DPRINT5(5, "QHash Delete (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);

                if (IS_QHASH_LARGE_KEY(HashTable) && ((PVOID) pE->Flags != NULL)) {
                    (HashTable->HashFree)((PVOID) (pE->Flags));
                }
                pE->Flags = 0;
                RemoveSingleListEntry(NOT_USED);
                PushEntryList(&HashTable->FreeList, &pE->NextEntry);

                QHashReleaseLock(HashTable);

                return GHT_STATUS_SUCCESS;
            }
        }
    );

    QHashReleaseLock(HashTable);
    return GHT_STATUS_NOT_FOUND;
}



VOID
QHashDeleteLock(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey
    )
/*++

Routine Description:

Delete the entry in the hash table.  Assumes the caller has the lock on the
table and has not dropped the lock since doing the QHashLookupLock() call.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    ArgQKey  -- ptr to the Key we are looking for.

Return Value:

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDeleteLock:"

    ULONGLONG QKey;
    ULONG Hval, HvalIndex;
    PQHASH_ENTRY RowEntry;

    if (IS_QHASH_LARGE_KEY(HashTable)) {
        Hval = (HashTable->HashCalc2)(ArgQKey, &QKey);
    } else {
        CopyMemory(&QKey, ArgQKey, 8);
        Hval = (HashTable->HashCalc)(&QKey, 8);
    }

    FRS_ASSERT(QKey != QUADZERO);
    //
    // Compute the hash index and calculate the row pointer.
    //
    HvalIndex = Hval % HashTable->NumberEntries;
    RowEntry = HashTable->HashRowBase + HvalIndex;

    if (RowEntry->QKey == QKey) {
        if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, RowEntry->Flags)) {
            DPRINT5(5, "QHash Delete (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);

            if (IS_QHASH_LARGE_KEY(HashTable) && ((PVOID) RowEntry->Flags != NULL)) {
                (HashTable->HashFree)((PVOID) (RowEntry->Flags));
            }

            RowEntry->QKey = QUADZERO;
            RowEntry->Flags = 0;
            return;
        }
    }

    if (RowEntry->NextEntry.Next == NULL) {
        return;
    }

    //
    // Scan the collision list.
    //
    ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
        //
        // The iterator pE is of type PQHASH_ENTRY.
        // Check for early termination.
        //
        if (QKey < pE->QKey) {
            break;
        }
        if (pE->QKey == QKey) {
            if (DOES_QHASH_LARGE_KEY_MATCH(HashTable, ArgQKey, pE->Flags)) {
                //
                // Found it. Remove from list and put on free list.
                //
                DPRINT5(5, "QHash Delete (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);

                if (IS_QHASH_LARGE_KEY(HashTable) && ((PVOID) pE->Flags != NULL)) {
                    (HashTable->HashFree)((PVOID) (pE->Flags));
                }

                pE->Flags = 0;
                RemoveSingleListEntry(NOT_USED);
                PushEntryList(&HashTable->FreeList, &pE->NextEntry);
                return;
            }
        }
    );

    return;
}



#if 0
    ////// Currently Unused //////
VOID
QHashDeleteNodeLock(
    IN PQHASH_TABLE HashTable,
    IN PQHASH_ENTRY BeforeNode,
    IN PQHASH_ENTRY TargetNode
    )
/*++

Routine Description:

Delete the TargetNode entry in the hash table.  This is a singly linked list
so Before Node has to be adjusted.  If BeforeNode is NULL then the TargetNode
is head of the collision chain and is not deleted, instead the key is set to 0.

Assumes the caller has the lock on the table and has not dropped the lock
since getting the Node addresses.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    BeforeNode  -- ptr to the QhashEntry before the node to be deleted.
    TargetNode  -- ptr to the QhashEntry to delete.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDeleteNodeLock:"

    FRS_ASSERT(TargetNode != NULL);

    //
    // Special case for node that is part of the main hash vector.
    //
    if (BeforeNode == NULL) {
        TargetNode->QKey = QUADZERO;
        TargetNode->Flags = 0;
        return;
    }

    //
    // Unlink the target entry and put on the free list.
    //
    BeforeNode->NextEntry.Next = TargetNode->NextEntry.Next;
    TargetNode->NextEntry.Next = NULL;
    TargetNode->Flags = 0;

    PushEntryList(&HashTable->FreeList, &TargetNode->NextEntry);

    return;
}
#endif // 0



VOID
QHashDeleteByFlags(
    IN PQHASH_TABLE HashTable,
    IN ULONG_PTR Flags
    )
/*++

Routine Description:

Delete all entries in the hash table that match the given Flags argument.

The table lock is acquired and released here.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.
    Flags -- Match key to select elements to delete.

Return Value:

    None.

--*/

{
#undef DEBSUB
#define DEBSUB  "QHashDeleteByFlags:"

    PQHASH_ENTRY RowEntry;
    ULONG i;


    FRS_ASSERT(!IS_QHASH_LARGE_KEY(HashTable));

    RowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and delete each matching element.
    //

    QHashAcquireLock(HashTable);

    for (i=0; i<HashTable->NumberEntries; i++, RowEntry++) {

        if (RowEntry->Flags == Flags) {
            DPRINT5(5, "QHash DeleteByFlags (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                 HashTable, RowEntry, PRINTQUAD(RowEntry->QKey), PRINTQUAD(RowEntry->QData), RowEntry->Flags);
            RowEntry->QKey = QUADZERO;
            RowEntry->Flags = 0;
        }


        if (RowEntry->NextEntry.Next == NULL) {
            continue;
        }

        //
        // Scan the collision list.
        //
        ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
            //
            // The iterator pE is of type PQHASH_ENTRY.
            // Check for match. Remove from list and put on free list.
            //
            if (pE->Flags == Flags) {

                DPRINT5(5, "QHash DeleteByFlags (%08x): Entry: %08x  Tag: %08lx %08lx, Data: %08lx %08lx, Flags: %08x\n",
                     HashTable, pE, PRINTQUAD(pE->QKey), PRINTQUAD(pE->QData), pE->Flags);

                pE->Flags = 0;
                RemoveSingleListEntry(NOT_USED);
                PushEntryList(&HashTable->FreeList, &pE->NextEntry);
            }
        );
    }

    QHashReleaseLock(HashTable);

    return;
}



VOID
QHashEmptyLargeKeyTable(
    IN PQHASH_TABLE HashTable
    )
/*++

Routine Description:

Delete all the large key nodes in the QHash table.
Put all collision entries on the free list.

The table lock is acquired and released here.

Arguments:

    HashTable  --  ptr to a PQHASH_TABLE struct.

Return Value:

    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "QHashEmptyLargeKeyTable:"

    PQHASH_ENTRY RowEntry;
    ULONG i;

    //
    // No work if not a large key table.
    //
    if (!IS_QHASH_LARGE_KEY(HashTable)) {
        return;
    }

    RowEntry = HashTable->HashRowBase;

    //
    // Loop through all the Hash table rows and delete each matching element.
    //
    QHashAcquireLock(HashTable);

    for (i=0; i<HashTable->NumberEntries; i++, RowEntry++) {

        if ((PVOID)RowEntry->Flags != NULL) {
            (HashTable->HashFree)((PVOID) (RowEntry->Flags));
        }
        RowEntry->QKey = QUADZERO;
        RowEntry->Flags = 0;

        if (RowEntry->NextEntry.Next == NULL) {
            continue;
        }

        //
        // Scan the collision list.
        // Free the large key node and put qhash collision entries on free list.
        //
        ForEachSingleListEntry(&RowEntry->NextEntry, QHASH_ENTRY, NextEntry,
            //
            // The iterator pE is of type PQHASH_ENTRY.
            //
            if ((PVOID)RowEntry->Flags != NULL) {
                (HashTable->HashFree)((PVOID) (pE->Flags));
            }
            pE->Flags = 0;
            RemoveSingleListEntry(NOT_USED);
            PushEntryList(&HashTable->FreeList, &pE->NextEntry);
        );
    }

    QHashReleaseLock(HashTable);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\info.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    info.c

Abstract:

    Support the RPC interface that provides internal info to the caller.

Author:

    Billy J Fuller 27-Mar-1998

Environment

    User mode, winnt32

--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <ntdsapi.h>
#include <frs.h>
#include <ntdsapip.h>   // ms internal flags for DsCrackNames()
#include <ntfrsapi.h>
#include <info.h>
#include <tablefcn.h>
#include <lmaccess.h>
#include <lmapibuf.h>

#ifdef SECURITY_WIN32
#include <security.h>
#else
#define SECURITY_WIN32
#include <security.h>
#undef SECURITY_WIN32
#endif



extern PCHAR LatestChanges[];
extern PCHAR CoLocationNames[];

//
// Useful macros
//
#define IPRINTGNAME(_I_, _G_, _F_, _GUID_, _P_) \
{ \
    if (_G_) { \
        GuidToStr(_G_->Guid, _GUID_); \
        IPRINT3(_I_, _F_, _P_, _G_->Name, _GUID_); \
    } \
}

//
// Try to avoid splitting a record struct across calls.
//
#define  INFO_HAS_SPACE(_info_) (((_info_)->SizeInChars - (_info_)->OffsetToFree) >= 2000)


extern OSVERSIONINFOEX  OsInfo;
extern SYSTEM_INFO  SystemInfo;
extern PCHAR ProcessorArchName[12];

extern FLAG_NAME_TABLE CxtionOptionsFlagNameTable[];

//
// DC name for LDAP binding
//
WCHAR  InfoDcName[MAX_PATH + 1];

//
// Member Subscriber Links
//
typedef struct _INFO_DN  INFO_DN, *PINFO_DN;
struct _INFO_DN  {
    PINFO_DN   Next;
    PWCHAR     Dn;
    PWCHAR     SetType;
};


//
// This table is used to keep contexts across multiple calls from ntfrsutl.exe
//
PGEN_TABLE     FrsInfoContextTable = NULL;
//
// This counter is used to create context handles for each caller.
//
ULONG          FrsInfoContextNum   = 0;

//
// To avoid a DOS attack, limit number of active contexts.
//
#define FRS_INFO_MAX_CONTEXT_ACTIVE  (1000)



VOID
DbsDisplayRecordIPrint(
    IN PTABLE_CTX  TableCtx,
    IN PINFO_TABLE InfoTable,
    IN BOOL        Read,
    IN PULONG      RecordFieldx,
    IN ULONG       FieldCount
    );

//
// From frs\ds.c
//
PVOID *
FrsDsFindValues(
    IN PLDAP        ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr,
    IN BOOL         DoBerVals
    );

PWCHAR
FrsDsExtendDn(
    IN PWCHAR Dn,
    IN PWCHAR Cn
    );

PWCHAR
FrsDsExtendDnOu(
    IN PWCHAR Dn,
    IN PWCHAR Ou
    );

PWCHAR
FrsDsFindValue(
    IN PLDAP        ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr
    );

GUID *
FrsDsFindGuid(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry
    );

PWCHAR
FrsDsMakeRdn(
    IN PWCHAR DN
    );

PWCHAR
FrsDsConvertToSettingsDn(
    IN PWCHAR   Dn
    );

PSCHEDULE
FrsDsFindSchedule(
    IN  PLDAP        Ldap,
    IN  PLDAPMessage LdapEntry,
    OUT PULONG       Len
    );

VOID
FrsPrintRpcStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    );

VOID
FrsPrintThreadStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    );


VOID
InfoPrint(
    IN PNTFRSAPI_INFO   Info,
    IN PCHAR            Format,
    IN ... )
/*++
Routine Description:
    Format and print a line of information output into the info buffer.

Arguments:
    Info    - Info buffer
    Format  - printf format

Return Value:
    None.
--*/
{
    PCHAR   Line;
    ULONG   LineLen;
    LONG    LineSize;

    //
    // varargs stuff
    //
    va_list argptr;
    va_start(argptr, Format);

    //
    // Print the line into the info buffer
    //
    try {
        if (!FlagOn(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
            //
            // Calc offset to start of free buffer space.
            // And calc max space left in buffer.
            //
            Line = ((PCHAR)Info) + Info->OffsetToFree;
            LineSize = (Info->SizeInChars - (ULONG)(Line - (PCHAR)Info)) - 1;

            if ((LineSize <= 0) || (_vsnprintf(Line, LineSize, Format, argptr) < 0)) {
                //
                // Buffer is filled. Set the terminating NULL and the buffer full flag.
                //
                Line[LineSize - 1] = '\0';
                SetFlag(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL);
            } else {

                LineLen = strlen(Line) + 1;
                if (Info->CharsToSkip > 0) {
                    //
                    // Still skipping chars that we previously returned.  Barf.
                    //
                    Info->CharsToSkip = (LineLen > Info->CharsToSkip) ?
                                           0 : Info->CharsToSkip - LineLen;
                } else {
                    //
                    // The line fits.  Bump freespace offset and TotalChars returned.
                    //
                    Info->OffsetToFree += LineLen;
                    Info->TotalChars += LineLen;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    va_end(argptr);
}



#define Tab L"   "
VOID
InfoTabs(
    IN DWORD    Tabs,
    IN PWCHAR   TabW
    )
/*++
Routine Description:
    Create a string of tabs for prettyprint

Arguments:
    Tabs    - number of tabs
    TabW    - preallocated string to receive tabs

Return Value:
    Win32 Status
--*/
{
    DWORD   i;

    //
    // Adjust indentation
    //
    Tabs = (Tabs >= MAX_TABS) ? MAX_TABS : Tabs;
    for (TabW[0] = L'\0', i = 0; i < Tabs; ++i) {
        wcscat(TabW, Tab);
    }
}



DWORD
InfoPrintDbSets(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on replica sets (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintDbSets:"
    PVOID       Key;
    PREPLICA    Replica;
    CHAR        Guid[GUID_CHAR_LEN + 1];
    WCHAR       TabW[MAX_TAB_WCHARS + 1];
    extern PGEN_TABLE   ReplicasByGuid;
    extern PGEN_TABLE   DeletedReplicas;

    InfoTabs(Tabs, TabW);
    IPRINT1(Info, "%wsACTIVE REPLICA SETS\n", TabW);
    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        if (REPLICA_IS_ACTIVE(Replica)) {
            FrsPrintTypeReplica(0, Info, Tabs, Replica, NULL, 0);
        } else {
            //
            // If the replica set is not active, one or more of the GNames
            // could have freed guid pointers (feeefeee, bug 319600) so
            // don't print the replica set in this case, just the name and state.
            //
            if (Replica->SetName) {
                IPRINT3(Info, "%ws   %ws in state %s\n",
                        TabW, Replica->SetName->Name, RSS_NAME(Replica->ServiceState));
            }
        }
    }

    IPRINT0(Info, "\nDELETED REPLICA SETS\n");
    Key = NULL;
    if (DeletedReplicas) {
        while (Replica = GTabNextDatum(DeletedReplicas, &Key)) {
            if (Replica->SetName) {
                IPRINT2(Info, "%ws   %ws\n", TabW, Replica->SetName->Name);
            }
        }
    }

    return ERROR_SUCCESS;
}




BOOL
InfoSearch(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           Base,
    IN ULONG            Scope,
    IN PWCHAR           Filter,
    IN PWCHAR           Attrs[],
    IN ULONG            AttrsOnly,
    IN LDAPMessage      **Res
    )
/*++
Routine Description:
    Perform ldap_search_s

Arguments:
    Info        - RPC output buffer
    Tabs        - number of tabs
    Ldap        - bound ldap handle
    .
    .
    .

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoSearch:"
    DWORD           LStatus;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    InfoTabs(Tabs, TabW);
    LStatus = ldap_search_s(Ldap, Base, Scope, Filter, Attrs, AttrsOnly, Res);

    if (LStatus != LDAP_SUCCESS) {
        IPRINT5(Info, "%wsWARN - ldap_search_s(%ws, %d, %ws); %ws\n",
                TabW, Base, Scope, ComputerName, ldap_err2string(LStatus));
        return FALSE;
    }
    return TRUE;
}


PCONFIG_NODE
InfoAllocBasicNode(
    IN PNTFRSAPI_INFO   Info,
    IN PWCHAR           TabW,
    IN PWCHAR           NodeType,
    IN PWCHAR           ParentDn,
    IN PWCHAR           Filter,
    IN BOOL             *FirstError,
    IN PLDAP            Ldap,
    IN PLDAPMessage     LdapEntry
    )
/*++
Routine Description:
    Allocate a node and fill in the basic info (dn and name)

Arguments:
    Info        - text buffer
    TabW        - Prettyprint
    NodeType    - Prettyprint
    Ldap        - openned, bound ldap
    LdapEntry   - returned from ldap_first/next_entry()

Return Value:
    NULL if basic info is not available.
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoAllocBasicNode:"
    PCONFIG_NODE    Node      = NULL;
    CHAR            Guid[GUID_CHAR_LEN + 1];


    //
    // Fetch values from the DS
    //
    Node = FrsAllocType(CONFIG_NODE_TYPE);
    Node->Dn = FrsDsFindValue(Ldap, LdapEntry, ATTR_DN);
    FRS_WCSLWR(Node->Dn);

    //
    // Name
    //
    Node->Name = FrsBuildGName(FrsDsFindGuid(Ldap, LdapEntry),
                               FrsDsMakeRdn(Node->Dn));
    if (!Node->Dn || !Node->Name->Name || !Node->Name->Guid) {
        IPRINT5(Info, "\n%ws%ws: ERROR - The object returned by the DS"
                " lacks a dn (%08x), Rdn (%08x), or Guid(%08x)\n",
                TabW, NodeType, Node->Dn, Node->Name->Name, Node->Name->Guid);
        if (*FirstError) {
            *FirstError = FALSE;
            IPRINT5(Info, "%ws%ws: ERROR - Using ldp, bind to %ws and search the "
                    "container %ws using the filter "
                    "%ws for more information.\n",
                    TabW, NodeType, &InfoDcName[2], ParentDn, Filter);
        }
        return FrsFreeType(Node);
    }
    IPRINT3(Info, "\n%ws%ws: %ws\n", TabW, NodeType, Node->Name->Name);

    IPRINT2(Info, "%ws   DN   : %ws\n", TabW, Node->Dn);
    GuidToStr(Node->Name->Guid, Guid);
    IPRINT2(Info, "%ws   Guid : %s\n", TabW, Guid);

    return Node;
}


VOID
InfoPrintDsCxtions(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           Base,
    IN BOOL             IsSysVol
    )
/*++
Routine Description:
    Print the cxtions from the DS.

Arguments:
    ldap        - opened and bound ldap connection
    Base        - Name of object or container in DS

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintDsCxtions:"
    PWCHAR          Attrs[10];
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    BOOL            FirstError = TRUE;
    PWCHAR          CxtionOptionsWStr = NULL;
    PWCHAR          WStr = NULL;
    CHAR            TBuff[100];

    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    CHAR            FlagBuffer[120];


    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Search the DS for cxtions
    //
    Attrs[0] = ATTR_DN;
    Attrs[1] = ATTR_SCHEDULE;
    Attrs[2] = ATTR_FROM_SERVER;
    Attrs[3] = ATTR_OBJECT_GUID;
    Attrs[4] = ATTR_USN_CHANGED;
    Attrs[5] = ATTR_ENABLED_CXTION;
    Attrs[6] = ATTR_OPTIONS;
    Attrs[7] = ATTR_WHEN_CHANGED;
    Attrs[8] = ATTR_WHEN_CREATED;
    Attrs[9] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, Base, LDAP_SCOPE_ONELEVEL,
                    CATEGORY_CXTION, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"CXTION", Base,
                                  CATEGORY_CXTION, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Node's partner's name
        //
        Node->PartnerDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_FROM_SERVER);
        FRS_WCSLWR(Node->PartnerDn);
        IPRINT2(Info, "%ws   Partner Dn   : %ws\n", TabW, Node->PartnerDn);
        Node->PartnerName = FrsBuildGName(NULL, FrsDsMakeRdn(Node->PartnerDn));
        IPRINT2(Info, "%ws   Partner Rdn  : %ws\n", TabW, Node->PartnerName->Name);

        //
        // Enabled
        //
        Node->EnabledCxtion = FrsDsFindValue(Ldap, LdapEntry, ATTR_ENABLED_CXTION);
        IPRINT2(Info, "%ws   Enabled      : %ws\n", TabW, Node->EnabledCxtion);

        //
        // Created and Modified
        //
        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CREATED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenCreated  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CHANGED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenChanged  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        //
        // Options
        //
        CxtionOptionsWStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_OPTIONS);
        if (CxtionOptionsWStr != NULL) {
            Node->CxtionOptions = _wtoi(CxtionOptionsWStr);
            CxtionOptionsWStr = FrsFree(CxtionOptionsWStr);
        } else {
            Node->CxtionOptions = 0;
        }

        FrsFlagsToStr(Node->CxtionOptions, CxtionOptionsFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        IPRINT3(Info, "%ws   Options      : 0x%08x [%s]\n",
                TabW, Node->CxtionOptions, FlagBuffer);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }
        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
}


VOID
InfoCrack(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PWCHAR           Dn,
    IN HANDLE           Handle,
    IN PWCHAR           DomainDnsName,
    IN DWORD            DesiredFormat
    )
/*++
Routine Description:
    Find the NT4 account name for Dn. Dn should be the Dn
    of a computer object.

Arguments:
    Dn            - Of computer object
    Handle        - From DsBind
    DomainDnsName - If !NULL, produce new local handle
    DesiredFormat - DS_NT4_ACCOUNT_NAME or DS_STRING_SID_NAME

Return Value:
    NT4 Account Name or NULL
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoCrack:"
    DWORD           WStatus;
    DS_NAME_RESULT  *Cracked;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    HANDLE          LocalHandle = NULL;

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Computer's Dn not available
    //
    if (!Dn) {
        return;
    }

    //
    // Need something to go on!
    //
    if (!HANDLE_IS_VALID(Handle) && !DomainDnsName) {
        return;
    }

    //
    // Bind to Ds
    //
    if (DomainDnsName) {
        WStatus = DsBind(NULL, DomainDnsName, &LocalHandle);
        if (!WIN_SUCCESS(WStatus)) {
            IPRINT4(Info, "%ws   ERROR - DsBind(%ws, %08x); WStatus %s\n",
                    TabW, DomainDnsName, DesiredFormat, ErrLabelW32(WStatus));
            return;
        }
        Handle = LocalHandle;
    }

    //
    // Crack the computer's distinguished name into its NT4 Account Name
    //
    WStatus = DsCrackNames(Handle,              // in   hDS,
                           DS_NAME_NO_FLAGS,    // in   flags,
                           DS_FQDN_1779_NAME,   // in   formatOffered,
                           DesiredFormat,       // in   formatDesired,
                           1,                   // in   cNames,
                           &Dn,                 // in   *rpNames,
                           &Cracked);           // out  *ppResult
    if (!WIN_SUCCESS(WStatus)) {
        IPRINT4(Info, "%ws   ERROR - DsCrackNames(%ws, %08x); WStatus %s\n",
                TabW, Dn, DesiredFormat, ErrLabelW32(WStatus));
        //
        // What else can we do?
        //
        if (HANDLE_IS_VALID(LocalHandle)) {
            DsUnBind(&LocalHandle);
        }
        return;
    }

    //
    // Might have it
    //
    if (Cracked && Cracked->cItems && Cracked->rItems) {
        //
        // Got it!
        //
        if (Cracked->rItems->status == DS_NAME_NO_ERROR) {
            IPRINT2(Info, "%ws   Cracked Domain : %ws\n",
                    TabW, Cracked->rItems->pDomain);
            IPRINT3(Info, "%ws   Cracked Name   : %08x %ws\n",
                    TabW, DesiredFormat, Cracked->rItems->pName);
        //
        // Only got the domain; rebind and try again
        //
        } else if (Cracked->rItems->status == DS_NAME_ERROR_DOMAIN_ONLY) {
            InfoCrack(Info, Tabs, Dn, NULL, Cracked->rItems->pDomain, DesiredFormat);
        } else {
            IPRINT4(Info, "%ws   ERROR - DsCrackNames(%ws, %08x); internal status %d\n",
                    TabW, Dn, DesiredFormat, Cracked->rItems->status);
        }
        DsFreeNameResult(Cracked);
    } else {
        IPRINT3(Info, "%ws   ERROR - DsCrackNames(%ws, %08x); no status\n",
                TabW, Dn, DesiredFormat);
    }
    if (HANDLE_IS_VALID(LocalHandle)) {
        DsUnBind(&LocalHandle);
    }
}


VOID
InfoCrackDns(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           Base
    )
/*++
Routine Description:
    Find the DNS name for Base. Base should be the Dn
    of a computer object.

Arguments:
    Info
    Tabs
    Ldap
    Base

Return Value:
    Prints a message into Info.
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoCrackDns:"
    PWCHAR          Attrs[2];
    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PWCHAR          DnsName     = NULL;

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Computer's Dn not available
    //
    if (!Base) {
        return;
    }

    //
    // Search the DS for the DNS attribute of Base
    //
    Attrs[0] = ATTR_DNS_HOST_NAME;
    Attrs[1] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, Base, LDAP_SCOPE_BASE,
                    CATEGORY_ANY, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }
    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (!LdapEntry) {
        IPRINT2(Info, "%ws   ERROR - No LdapEntry for Dns name on %ws\n", TabW, Base);
        goto cleanup;
    }

    DnsName = FrsDsFindValue(Ldap, LdapEntry, ATTR_DNS_HOST_NAME);
    if (!DnsName) {
        IPRINT2(Info, "%ws   ERROR - No DNS name on %ws\n", TabW, Base);
        goto cleanup;
    }

    //
    // Got it!
    //
    IPRINT2(Info, "%ws   Computer's DNS : %ws\n", TabW, DnsName);

cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFree(DnsName);
}


VOID
InfoPrintMembers(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN BOOL             IsSysVol,
    IN PWCHAR           Base,
    IN HANDLE           DsHandle
    )
/*++
Routine Description:
    Print the members

Arguments:
    ldap    - opened and bound ldap connection
    Base    - Name of object or container in DS

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintMembers:"
    PWCHAR          Attrs[9];
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    BOOL            FirstError = TRUE;
    PWCHAR          WStr = NULL;
    CHAR            TBuff[100];
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Search the DS for members
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = ATTR_SERVER_REF;
    Attrs[5] = ATTR_COMPUTER_REF;
    Attrs[6] = ATTR_WHEN_CHANGED;
    Attrs[7] = ATTR_WHEN_CREATED;
    Attrs[8] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, Base, LDAP_SCOPE_ONELEVEL,
                    CATEGORY_MEMBER, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"MEMBER", Base,
                                  CATEGORY_MEMBER, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // NTDS Settings (DSA) Reference
        //
        Node->SettingsDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_SERVER_REF);
        IPRINT2(Info, "%ws   Server Ref     : %ws\n", TabW, Node->SettingsDn);

        //
        // Computer Reference
        //
        Node->ComputerDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_COMPUTER_REF);
        FRS_WCSLWR(Node->ComputerDn);
        IPRINT2(Info, "%ws   Computer Ref   : %ws\n", TabW, Node->ComputerDn);

        InfoCrack(Info, Tabs, Node->ComputerDn, DsHandle, NULL, DS_NT4_ACCOUNT_NAME);
        InfoCrack(Info, Tabs, Node->ComputerDn, DsHandle, NULL, DS_STRING_SID_NAME);
        InfoCrackDns(Info, Tabs, Ldap, Node->ComputerDn);

        //
        // Created and Modified
        //
        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CREATED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenCreated  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CHANGED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenChanged  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }
        //
        // Get the inbound cxtions
        //
        InfoPrintDsCxtions(Info, Tabs + 1, Ldap, Node->Dn, FALSE);
        if (IsSysVol) {
            if (Node->SettingsDn) {
                InfoPrintDsCxtions(Info, Tabs + 1, Ldap, Node->SettingsDn, TRUE);
            } else {
                IPRINT2(Info, "%ws   WARN - %ws lacks a settings reference\n",
                        TabW, Node->Name->Name);
            }
        }
        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
}


VOID
InfoPrintDsSets(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           SetDnAddr,
    IN HANDLE           DsHandle,
    IN OUT PINFO_DN     *InfoSets
    )
/*++
Routine Description:
    Print replica sets from the ds

Arguments:
    ldap        - opened and bound ldap connection
    Base        - Name of object or container in DS

Return Value:
    None
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintDsSets:"
    PWCHAR          Attrs[12];
    DWORD           i;
    PINFO_DN        InfoSet;
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    BOOL            FirstError = TRUE;
    PWCHAR          WStr = NULL;
    CHAR            TBuff[100];
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Have we processed this settings before?
    //
    for (InfoSet = *InfoSets; InfoSet; InfoSet = InfoSet->Next) {
        if (WSTR_EQ(InfoSet->Dn, SetDnAddr)) {
            IPRINT2(Info, "%ws   %ws processed previously\n", TabW, SetDnAddr);
            break;
        }
    }
    //
    // Yep; get the sets
    //
    if (InfoSet) {
        //
        // Recurse to the next level in the DS hierarchy
        //
        InfoPrintMembers(Info,
                         Tabs + 1,
                         Ldap,
                         FRS_RSTYPE_IS_SYSVOLW(InfoSet->SetType),
                         InfoSet->Dn,
                         DsHandle);
        goto cleanup;
    }

    //
    // Search the DS beginning at Base for sets
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = ATTR_SET_TYPE;
    Attrs[5] = ATTR_PRIMARY_MEMBER;
    Attrs[6] = ATTR_FILE_FILTER;
    Attrs[7] = ATTR_DIRECTORY_FILTER;
    Attrs[8] = ATTR_WHEN_CHANGED;
    Attrs[9] = ATTR_WHEN_CREATED;
    Attrs[10] = ATTR_FRS_FLAGS;
    Attrs[11] = NULL;

    if (!InfoSearch(Info, Tabs, Ldap, SetDnAddr, LDAP_SCOPE_BASE,
                    CATEGORY_REPLICA_SET, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"SET", SetDnAddr,
                                  CATEGORY_REPLICA_SET, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Replica set type
        //
        Node->SetType = FrsDsFindValue(Ldap, LdapEntry, ATTR_SET_TYPE);
        IPRINT2(Info, "%ws   Type          : %ws\n", TabW, Node->SetType);

        //
        // Primary member
        //
        Node->MemberDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_PRIMARY_MEMBER);
        IPRINT2(Info, "%ws   Primary Member: %ws\n", TabW, Node->MemberDn);

        //
        // File filter
        //
        Node->FileFilterList = FrsDsFindValue(Ldap, LdapEntry, ATTR_FILE_FILTER);
        IPRINT2(Info, "%ws   File Filter   : %ws\n", TabW, Node->FileFilterList);

        //
        // Directory filter
        //
        Node->DirFilterList = FrsDsFindValue(Ldap, LdapEntry, ATTR_DIRECTORY_FILTER);
        IPRINT2(Info, "%ws   Dir  Filter   : %ws\n", TabW, Node->DirFilterList);

        //
        // FRS Flags value.
        //
        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_FRS_FLAGS);
        IPRINT2(Info, "%ws   FRS Flags     : %ws\n", TabW, WStr);

        //
        // Created and Modified
        //
        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CREATED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenCreated  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CHANGED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenChanged  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        InfoSet = FrsAlloc(sizeof(INFO_DN));
        InfoSet->Dn = FrsWcsDup(Node->Dn);
        InfoSet->SetType = FrsWcsDup(Node->SetType);
        InfoSet->Next = *InfoSets;
        *InfoSets = InfoSet;

        //
        // Recurse to the next level in the DS hierarchy
        //
        InfoPrintMembers(Info,
                         Tabs + 1,
                         Ldap,
                         FRS_RSTYPE_IS_SYSVOLW(Node->SetType),
                         Node->Dn,
                         DsHandle);
        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
}


VOID
InfoPrintSettings(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           MemberDn,
    IN HANDLE           DsHandle,
    IN OUT PINFO_DN     *InfoSettings,
    IN OUT PINFO_DN     *InfoSets
    )
/*++
Routine Description:
    Scan the DS tree for NTFRS-Settings

Arguments:
    ldap    - opened and bound ldap connection
    Base    - Name of object or container in DS

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintSettings:"
    PWCHAR          Attrs[7];
    PLDAPMessage    LdapEntry;
    PWCHAR          MemberDnAddr;
    PWCHAR          SetDnAddr;
    PWCHAR          SettingsDnAddr;
    PINFO_DN        InfoSetting;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    BOOL            FirstError = TRUE;
    PWCHAR          WStr = NULL;
    CHAR            TBuff[100];
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Find the member component
    //
    MemberDnAddr = wcsstr(MemberDn, L"cn=");
    if (!MemberDnAddr) {
        IPRINT2(Info, "%ws   ERROR - No MemberDnAddr in %ws\n", TabW, MemberDn);
        goto cleanup;
    }
    //
    // Find the set component
    //
    SetDnAddr = wcsstr(MemberDnAddr + 3, L"cn=");
    if (!SetDnAddr) {
        IPRINT2(Info, "%ws   ERROR - No SetDnAddr in %ws\n", TabW, MemberDn);
        goto cleanup;
    }
    //
    // Find the settings component
    //
    SettingsDnAddr = wcsstr(SetDnAddr + 3, L"cn=");
    if (!SettingsDnAddr) {
        IPRINT2(Info, "%ws   ERROR - No SettingsDnAddr in %ws\n", TabW, MemberDn);
        goto cleanup;
    }

    //
    // Have we processed this settings before?
    //
    for (InfoSetting = *InfoSettings; InfoSetting; InfoSetting = InfoSetting->Next) {
        if (WSTR_EQ(InfoSetting->Dn, SettingsDnAddr)) {
            IPRINT2(Info, "%ws   %ws processed previously\n", TabW, SettingsDnAddr);
            break;
        }
    }
    //
    // Yep; get the sets
    //
    if (InfoSetting) {
        InfoPrintDsSets(Info, Tabs + 1, Ldap, SetDnAddr, DsHandle, InfoSets);
        goto cleanup;
    }

    //
    // Search the DS beginning at Base for settings
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = ATTR_WHEN_CHANGED;
    Attrs[5] = ATTR_WHEN_CREATED;
    Attrs[6] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, SettingsDnAddr, LDAP_SCOPE_BASE,
                    CATEGORY_NTFRS_SETTINGS, Attrs,  0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"SETTINGS", SettingsDnAddr,
                                  CATEGORY_NTFRS_SETTINGS, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Created and Modified
        //
        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CREATED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenCreated  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CHANGED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenChanged  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        InfoSetting = FrsAlloc(sizeof(INFO_DN));
        InfoSetting->Dn = FrsWcsDup(Node->Dn);
        InfoSetting->Next = *InfoSettings;
        *InfoSettings = InfoSetting;

        //
        // Recurse to the next level in the DS hierarchy
        //
        InfoPrintDsSets(Info, Tabs + 1, Ldap, SetDnAddr, DsHandle, InfoSets);
        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
}


VOID
InfoPrintSubscribers(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           SubscriptionDn,
    IN PINFO_DN         *InfoSubs
    )
/*++
Routine Description:
    Print subscribers

Arguments:
    Ldap            - opened and bound ldap connection
    SubscriptionDn  - distininguished name of subscriptions object

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintSubscribers:"
    PWCHAR          Attrs[10];
    PLDAPMessage    LdapEntry;
    PINFO_DN        InfoSub;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    BOOL            FirstError = TRUE;
    PWCHAR          WStr = NULL;
    CHAR            TBuff[100];
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Search the DS beginning at Base for the entries of class "Filter"
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = ATTR_REPLICA_ROOT;
    Attrs[5] = ATTR_REPLICA_STAGE;
    Attrs[6] = ATTR_MEMBER_REF;
    Attrs[7] = ATTR_WHEN_CHANGED;
    Attrs[8] = ATTR_WHEN_CREATED;
    Attrs[9] = NULL;
    if (!InfoSearch(Info, Tabs, Ldap, SubscriptionDn, LDAP_SCOPE_ONELEVEL,
                    CATEGORY_SUBSCRIBER, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"SUBSCRIBER", SubscriptionDn,
                                  CATEGORY_SUBSCRIBER, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Member reference
        //
        Node->MemberDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_MEMBER_REF);
        IPRINT2(Info, "%ws   Member Ref: %ws\n", TabW, Node->MemberDn);

        if (Node->MemberDn) {
            InfoSub = FrsAlloc(sizeof(INFO_DN ));
            InfoSub->Dn = FrsWcsDup(Node->MemberDn);
            InfoSub->Next = *InfoSubs;
            *InfoSubs = InfoSub;
        }

        //
        // Root pathname
        //
        Node->Root = FrsDsFindValue(Ldap, LdapEntry, ATTR_REPLICA_ROOT);
        FRS_WCSLWR(Node->Root);
        IPRINT2(Info, "%ws   Root      : %ws\n", TabW, Node->Root);

        //
        // Staging pathname
        //
        Node->Stage = FrsDsFindValue(Ldap, LdapEntry, ATTR_REPLICA_STAGE);
        FRS_WCSLWR(Node->Stage);
        IPRINT2(Info, "%ws   Stage     : %ws\n", TabW, Node->Stage);

        //
        // Created and Modified
        //
        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CREATED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenCreated  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CHANGED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenChanged  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
}


VOID
InfoPrintSubscriptions(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN PWCHAR           ComputerDn,
    IN PINFO_DN         *InfoSubs
    )
/*++
Routine Description:
    Recursively scan the DS tree beginning at computer

Arguments:
    Info
    Tabs
    Ldap
    ComputerDn

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintSubscriptions:"
    PWCHAR          Attrs[8];
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg    = NULL;
    PCONFIG_NODE    Node       = NULL;
    BOOL            FirstError = TRUE;
    PWCHAR          WStr = NULL;
    CHAR            TBuff[100];
    WCHAR           TabW[MAX_TAB_WCHARS + 1];

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Search the DS beginning at Base for the entries of class "Filter"
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_USN_CHANGED;
    Attrs[4] = ATTR_WORKING;
    Attrs[5] = ATTR_WHEN_CHANGED;
    Attrs[6] = ATTR_WHEN_CREATED;
    Attrs[7] = NULL;
    if (!InfoSearch(Info, Tabs + 1, Ldap, ComputerDn, LDAP_SCOPE_SUBTREE,
                    CATEGORY_SUBSCRIPTIONS, Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"SUBSCRIPTION", ComputerDn,
                                  CATEGORY_SUBSCRIPTIONS, &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }

        //
        // Working Directory
        //
        Node->Working = FrsDsFindValue(Ldap, LdapEntry, ATTR_WORKING);
        IPRINT2(Info, "%ws   Working       : %ws\n", TabW, Node->Working);
        IPRINT2(Info, "%ws   Actual Working: %ws\n", TabW, WorkingPath);

        //
        // Created and Modified
        //
        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CREATED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenCreated  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CHANGED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenChanged  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        //
        // Recurse to the next level in the DS hierarchy
        //
        InfoPrintSubscribers(Info, Tabs + 1, Ldap, Node->Dn, InfoSubs);

        Node = FrsFreeType(Node);
    }
cleanup:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
}


BOOL
InfoPrintComputer(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs,
    IN PLDAP            Ldap,
    IN  PWCHAR          FindDn,
    IN  PWCHAR          ObjectCategory,
    IN  ULONG           Scope,
    OUT PINFO_DN        *InfoSubs
    )
/*++
Routine Description:
    Return internal info on DS computer objects.

Arguments:
    Info        - RPC output buffer
    Tabs        - number of tabs
    Ldap        - bound ldap handle
    DefaultNcDn - DN of the DCs default naming context
    FindDn         - Base Dn for search
    ObjectCategory - Object class (computer or user)
                     A user object serves the same purpose as the computer
                     object *sometimes* following a NT4 to NT5 upgrade.
    Scope          - Scope of search (currently BASE or SUBTREE)

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintComputer:"
    DWORD           i;
    DWORD           LStatus;
    PLDAPMessage    LdapEntry;
    PWCHAR          UserAccountControl;
    DWORD           NumVals;
    PINFO_DN        InfoSub;
    BOOL            FoundAComputer = FALSE;
    PCONFIG_NODE    Node        = NULL;
    PLDAPMessage    LdapMsg     = NULL;
    PWCHAR          *Values     = NULL;
    DWORD           WStatus     = ERROR_SUCCESS;
    BOOL            FirstError  = TRUE;
    PWCHAR          WStr = NULL;
    DWORD           ComputerFqdnLen;
    PWCHAR          Attrs[12];
    CHAR            TBuff[100];
    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    WCHAR           Filter[MAX_PATH + 1];
    WCHAR           ComputerFqdn[MAX_PATH + 1];

    //
    // Initialize return value
    //
    *InfoSubs = NULL;

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);

    //
    // Filter that locates our computer object
    //
    if (_snwprintf(Filter, sizeof(Filter)/sizeof(WCHAR) - 1 ,L"(&%s(sAMAccountName=%s$))", ObjectCategory, ComputerName) <0) {
        IPRINT1(Info, "%wsWARN - Buffer too small to hold filter.\n",TabW);
        goto CLEANUP;
    }

    Filter[sizeof(Filter)/sizeof(WCHAR) - 1] = UNICODE_NULL;

    //
    // Search the DS beginning at Base for the entries of class "Filter"
    //
    Attrs[0] = ATTR_OBJECT_GUID;
    Attrs[1] = ATTR_DN;
    Attrs[2] = ATTR_SCHEDULE;
    Attrs[3] = ATTR_COMPUTER_REF_BL;
    Attrs[4] = ATTR_SERVER_REF;
    Attrs[5] = ATTR_SERVER_REF_BL;
    Attrs[6] = ATTR_USER_ACCOUNT_CONTROL;
    Attrs[7] = ATTR_DNS_HOST_NAME;
    Attrs[8] = ATTR_WHEN_CHANGED;
    Attrs[9] = ATTR_WHEN_CREATED;
    Attrs[10] = NULL;
    InfoSearch(Info, Tabs + 1, Ldap, FindDn, Scope, Filter, Attrs, 0, &LdapMsg);

    if (!LdapMsg) {
        goto CLEANUP;
    }
    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL && WIN_SUCCESS(WStatus);
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {
        FoundAComputer = TRUE;

        //
        // Basic info (dn, rdn, and guid)
        //
        Node = InfoAllocBasicNode(Info, TabW, L"COMPUTER", FindDn, Filter,
                                  &FirstError, Ldap, LdapEntry);
        if (!Node) {
            continue;
        }
        UserAccountControl = FrsDsFindValue(Ldap, LdapEntry, ATTR_USER_ACCOUNT_CONTROL);
        if (UserAccountControl) {
            IPRINT2(Info, "%ws   UAC  : 0x%08x\n",
                    TabW, wcstoul(UserAccountControl, NULL, 10));
            UserAccountControl = FrsFree(UserAccountControl);
        }

        //
        // Server reference
        //
        Node->SettingsDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_SERVER_REF_BL);
        IPRINT2(Info, "%ws   Server BL : %ws\n", TabW, Node->SettingsDn);
        if (!Node->SettingsDn) {
            Node->SettingsDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_SERVER_REF);
            IPRINT2(Info, "%ws   Server Ref: %ws\n", TabW, Node->SettingsDn);
        }
        //
        // Make sure it references the settings; not the server
        //
        Node->SettingsDn = FrsDsConvertToSettingsDn(Node->SettingsDn);
        IPRINT2(Info, "%ws   Settings  : %ws\n", TabW, Node->SettingsDn);

        //
        // DNS Host Name
        //
        Node->DnsName = FrsDsFindValue(Ldap, LdapEntry, ATTR_DNS_HOST_NAME);
        IPRINT2(Info, "%ws   DNS Name  : %ws\n", TabW, Node->DnsName);

        //
        // Created and Modified
        //
        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CREATED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenCreated  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        WStr = FrsDsFindValue(Ldap, LdapEntry, ATTR_WHEN_CHANGED);
        FormatGeneralizedTime(WStr, sizeof(TBuff), TBuff);
        IPRINT2(Info, "%ws   WhenChanged  : %s\n", TabW, TBuff);
        FrsFree(WStr);

        //
        // Schedule, if any
        //
        Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);
        if (Node->Schedule) {
            IPRINT1(Info, "%ws   Schedule\n", TabW);
            FrsPrintTypeSchedule(0, Info, Tabs + 1, Node->Schedule, NULL, 0);
        }

        InfoPrintSubscriptions(Info, Tabs + 1, Ldap, Node->Dn, InfoSubs);

        //
        // Subscriber Member Bls
        //
        if (!*InfoSubs) {
            IPRINT2(Info, "%ws   %ws IS NOT A MEMBER OF ANY SET!\n",
                    TabW, ComputerName);
        } else {
            IPRINT1(Info, "%ws   Subscriber Member Back Links:\n", TabW);
            for (InfoSub = *InfoSubs; InfoSub; InfoSub = InfoSub->Next) {
                FRS_WCSLWR(InfoSub->Dn);
                IPRINT2(Info, "%ws      %ws\n", TabW, InfoSub->Dn);
            }
        }

        //
        // Next computer
        //
        Node = FrsFreeType(Node);
    }

CLEANUP:
    LDAP_FREE_MSG(LdapMsg);
    FrsFreeType(Node);
    return FoundAComputer;
}


DWORD
InfoPrintDs(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on DS (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs    - number of tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintDs:"
    DWORD           WStatus;
    DWORD           LStatus;
    DWORD           i;
    PWCHAR          DcAddr;
    PWCHAR          DcName;
    PWCHAR          DcDnsName;
    DWORD           NumVals;
    PWCHAR          Config;
    PLDAPMessage    LdapEntry;
    BOOL            PrintedComputers;
    PINFO_DN        InfoSub;
    PINFO_DN        InfoSetting;
    PINFO_DN        InfoSet;
    PINFO_DN        InfoSubs        = NULL;
    PINFO_DN        InfoSettings    = NULL;
    PINFO_DN        InfoSets        = NULL;
    PWCHAR          SitesDn         = NULL;
    PWCHAR          ServicesDn      = NULL;
    PWCHAR          DefaultNcDn     = NULL;
    PWCHAR          ComputersDn     = NULL;
    PWCHAR          DomainControllersDn = NULL;
    PLDAPMessage    LdapMsg         = NULL;
    PWCHAR          *Values         = NULL;
    PLDAP           Ldap            = NULL;
    HANDLE          LocalDsHandle   = INVALID_HANDLE_VALUE;
    WCHAR           ComputerFqdn[MAX_PATH + 1];
    DWORD           ComputerFqdnLen;
    WCHAR           TabW[MAX_TAB_WCHARS + 1];
    CHAR            Guid[GUID_CHAR_LEN + 1];
    PWCHAR          Attrs[3];
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    struct l_timeval Timeout;

    DWORD           InfoFlags;
    CHAR            FlagBuffer[220];
    ULONG           ulOptions;

    extern PWCHAR DsDomainControllerName;
    extern FLAG_NAME_TABLE DsGetDcInfoFlagNameTable[];
    //
    // Client side ldap_connect timeout in seconds. Reg value "Ldap Bind Timeout In Seconds". Default is 30 seconds.
    //
    extern DWORD LdapBindTimeoutInSeconds;

    //
    // Adjust indentation
    //
    InfoTabs(Tabs, TabW);
    IPRINT1(Info, "%wsNTFRS CONFIGURATION IN THE DS\n", TabW);

    Ldap = NULL;
    if (IsADc) {
        DcAddr = NULL;
        DcName = ComputerName;
        DcDnsName = ComputerDnsName;
        IPRINT1(Info, "%wsSUBSTITUTE DCINFO FOR DC\n", TabW);
        IPRINT2(Info, "%ws   FRS  DomainControllerName: %ws\n", TabW, DsDomainControllerName);
        IPRINT2(Info, "%ws   Computer Name            : %ws\n", TabW, DcName);
        IPRINT2(Info, "%ws   Computer DNS Name        : %ws\n", TabW, DcDnsName);
    } else {
        //
        // Domain Controller
        //
        WStatus = DsGetDcName(NULL,
                              NULL,
                              NULL,
                              NULL,
                              DS_DIRECTORY_SERVICE_REQUIRED |
                              DS_WRITABLE_REQUIRED          |
                              DS_BACKGROUND_ONLY,
                              &DcInfo);
        if (!WIN_SUCCESS(WStatus)) {
            DcInfo = NULL;
            IPRINT2(Info, "%wsWARN - DsGetDcName WStatus %s; Flushing cache...\n",
                    TabW, ErrLabelW32(WStatus));
            WStatus = DsGetDcName(NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  DS_DIRECTORY_SERVICE_REQUIRED |
                                  DS_WRITABLE_REQUIRED          |
                                  DS_FORCE_REDISCOVERY,
                                  &DcInfo);
        }
        //
        // Report the error and retry for any DC
        //
        if (!WIN_SUCCESS(WStatus)) {
            DcInfo = NULL;
            IPRINT3(Info, "%wsERROR - DsGetDcName(%ws); WStatus %s\n",
                    TabW, ComputerName, ErrLabelW32(WStatus));
            goto cleanup;
        }

        //
        // Dump dcinfo
        //
        IPRINT1(Info, "%wsDCINFO\n", TabW);
        IPRINT2(Info, "%ws   LAST DomainControllerName: %ws\n", TabW, DsDomainControllerName);
        IPRINT2(Info, "%ws   DomainControllerName     : %ws\n", TabW, DcInfo->DomainControllerName);
        IPRINT2(Info, "%ws   DomainControllerAddress  : %ws\n", TabW, DcInfo->DomainControllerAddress);
        IPRINT2(Info, "%ws   DomainControllerType     : %08x\n",TabW, DcInfo->DomainControllerAddressType);
        IPRINT2(Info, "%ws   DomainName               : %ws\n", TabW, DcInfo->DomainName);
        IPRINT2(Info, "%ws   DnsForestName            : %ws\n", TabW, DcInfo->DnsForestName);
        IPRINT2(Info, "%ws   DcSiteName               : %ws\n", TabW, DcInfo->DcSiteName);
        IPRINT2(Info, "%ws   ClientSiteName           : %ws\n", TabW, DcInfo->ClientSiteName);

        InfoFlags = DcInfo->Flags;
        FrsFlagsToStr(InfoFlags, DsGetDcInfoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
        IPRINT3(Info, "%ws   Flags                    : %08x [%s]\n",TabW, InfoFlags, FlagBuffer);


        if (!DsDomainControllerName ||
            !DcInfo->DomainControllerName ||
             WSTR_NE(DsDomainControllerName, DcInfo->DomainControllerName)) {
            IPRINT3(Info, "%wsWARN - Using DC %ws; not %ws\n",
                    TabW, DcInfo->DomainControllerName, DsDomainControllerName);
        }

        //
        // Binding address
        //
        DcAddr = DcInfo->DomainControllerAddress;
        DcDnsName = DcInfo->DomainControllerName;
    }
    wcsncpy(InfoDcName, DcDnsName, ARRAY_SZ(InfoDcName)-1);
    InfoDcName[ARRAY_SZ(InfoDcName)-1] = L'\0';

    //
    // BIND to the DS
    //
    IPRINT1(Info, "\n%wsBINDING TO THE DS:\n", TabW);

    //
    // if ldap_open is called with a server name the api will call DsGetDcName
    // passing the server name as the domainname parm...bad, because
    // DsGetDcName will make a load of DNS queries based on the server name,
    // it is designed to construct these queries from a domain name...so all
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up
    // as referrals/forwarders are contacted to attempt to resolve the bogus
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option
    // after the ldap_init but before any other operation using the ldap
    // handle from ldap_init, the delayed connection setup will not call
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client
    // will detect that and use the address directly.
    //

    //
    // Remove the leading \\ if they exist.
    //
    FRS_TRIM_LEADING_2SLASH(DcDnsName);
    FRS_TRIM_LEADING_2SLASH(DcAddr);

    ulOptions = PtrToUlong(LDAP_OPT_ON);
    Timeout.tv_sec = LdapBindTimeoutInSeconds;
    Timeout.tv_usec = 0;

    //
    // Try using DcDnsName first.
    //
    if ((Ldap == NULL) && (DcDnsName != NULL)) {

        Ldap = ldap_init(DcDnsName, LDAP_PORT);
        if (Ldap != NULL) {
            ldap_set_option(Ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
            LStatus = ldap_connect(Ldap, &Timeout);
            if (LStatus != LDAP_SUCCESS) {
                IPRINT4(Info, "%ws   WARN - ldap_connect(%ws); (ldap error %08x = %ws)\n",
                        TabW, DcDnsName, LStatus, ldap_err2string(LStatus));
                ldap_unbind_s(Ldap);
                Ldap = NULL;
            } else {
                IPRINT2(Info, "%ws   ldap_connect     : %ws\n", TabW, DcDnsName);
            }
        }
    }

    //
    // Try using DcAddr next.
    //
    if ((Ldap == NULL) && (DcAddr != NULL)) {

        Ldap = ldap_init(DcAddr, LDAP_PORT);
        if (Ldap != NULL) {
            ldap_set_option(Ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
            LStatus = ldap_connect(Ldap, &Timeout);
            if (LStatus != LDAP_SUCCESS) {
                IPRINT4(Info, "%ws   WARN - ldap_connect(%ws); (ldap error %08x = %ws)\n",
                        TabW, DcAddr, LStatus, ldap_err2string(LStatus));
                ldap_unbind_s(Ldap);
                Ldap = NULL;
            } else {
                IPRINT2(Info, "%ws   ldap_connect     : %ws\n", TabW, DcAddr);
            }
        }
    }

    //
    // Try using DcName finally.
    //
    if ((Ldap == NULL) && (DcName != NULL)) {

        Ldap = ldap_init(DcName, LDAP_PORT);
        if (Ldap != NULL) {
            ldap_set_option(Ldap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
            LStatus = ldap_connect(Ldap, &Timeout);
            if (LStatus != LDAP_SUCCESS) {
                IPRINT4(Info, "%ws   WARN - ldap_connect(%ws); (ldap error %08x = %ws)\n",
                        TabW, DcName, LStatus, ldap_err2string(LStatus));
                ldap_unbind_s(Ldap);
                Ldap = NULL;
            } else {
                IPRINT2(Info, "%ws   ldap_connect     : %ws\n", TabW, DcName);
            }
        }
    }

    //
    // Whatever it is, we can't find it.
    //
    if (!Ldap) {
        IPRINT6(Info, "%ws   ERROR - ldap_connect(DNS %ws, BIOS %ws, IP %ws); (ldap error %08x = %ws)\n",
                TabW, DcDnsName, DcName, DcAddr, LStatus, ldap_err2string(LStatus));
        goto cleanup;
    }

    //
    // Bind to the ldap server
    //
    LStatus = ldap_bind_s(Ldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);

    //
    // No luck; report error and carry on
    //
    if (LStatus != LDAP_SUCCESS) {
        IPRINT4(Info, "%ws   ERROR - ldap_bind_s(%ws); (ldap error %08x = %ws)\n",
                TabW, ComputerName, LStatus, ldap_err2string(LStatus));
        goto cleanup;
    }

    //
    // Bind to the Ds (for various Ds calls such as DsCrackName())
    //
    //
    // DC's Dns Name
    //
    WStatus = ERROR_RETRY;
    if (!WIN_SUCCESS(WStatus) && DcDnsName) {
        WStatus = DsBind(DcDnsName, NULL, &LocalDsHandle);
        if (!WIN_SUCCESS(WStatus)) {
            LocalDsHandle = NULL;
            IPRINT3(Info, "%ws   WARN - DsBind(DcDnsName %ws); WStatus %s\n",
                    TabW, DcDnsName, ErrLabelW32(WStatus));
        } else {
            IPRINT2(Info, "%ws   DsBind     : %ws\n", TabW, DcDnsName);
        }
    }

    //
    // DC's Computer Name
    //
    if (!WIN_SUCCESS(WStatus) && DcName) {
        WStatus = DsBind(DcName, NULL, &LocalDsHandle);
        if (!WIN_SUCCESS(WStatus)) {
            LocalDsHandle = NULL;
            IPRINT3(Info, "%ws   WARN - DsBind(DcName %ws); WStatus %s\n",
                    TabW, DcName, ErrLabelW32(WStatus));
        } else {
            IPRINT2(Info, "%ws   DsBind     : %ws\n", TabW, DcName);
        }
    }

    //
    // DC's IP Address
    //
    if (!WIN_SUCCESS(WStatus) && DcAddr) {
        WStatus = DsBind(DcAddr, NULL, &LocalDsHandle);
        if (!WIN_SUCCESS(WStatus)) {
            LocalDsHandle = NULL;
            IPRINT3(Info, "%ws   WARN - DsBind(DcAddr %ws); WStatus %s\n",
                    TabW, DcAddr, ErrLabelW32(WStatus));
        } else {
            IPRINT2(Info, "%ws   DsBind     : %ws\n", TabW, DcAddr);
        }
    }

    //
    // Whatever it is, we can't find it
    //
    if (!WIN_SUCCESS(WStatus)) {
        IPRINT5(Info, "%ws   ERROR - DsBind(DNS %ws, BIOS %ws, IP %ws); WStatus %s\n",
                TabW, DcDnsName, DcName, DcAddr, ErrLabelW32(WStatus));
        goto cleanup;
    }

    //
    // NAMING CONTEXTS
    //
    IPRINT1(Info, "\n%wsNAMING CONTEXTS:\n", TabW);

    //
    // Find the naming contexts and the default naming context
    //
    Attrs[0] = ATTR_NAMING_CONTEXTS;
    Attrs[1] = ATTR_DEFAULT_NAMING_CONTEXT;
    Attrs[2] = NULL;
    if (!InfoSearch(Info, Tabs + 1, Ldap, CN_ROOT, LDAP_SCOPE_BASE, CATEGORY_ANY,
                    Attrs, 0, &LdapMsg)) {
        goto cleanup;
    }

    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (!LdapEntry) {
        IPRINT2(Info, "%ws   ERROR - ldap_first_entry(contexts, %ws) no entry\n",
                TabW, ComputerName);
        goto cleanup;
    }
    Values = (PWCHAR *)FrsDsFindValues(Ldap, LdapEntry, ATTR_NAMING_CONTEXTS, FALSE);
    if (!Values) {
        IPRINT2(Info, "%ws   ERROR - FrsDsFindValues(contexts, %ws) no entry\n",
                TabW, ComputerName);
        goto cleanup;
    }

    //
    // Now, find the naming context that begins with "CN=configuration"
    //
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        FRS_WCSLWR(Values[NumVals]);
        Config = wcsstr(Values[NumVals], CONFIG_NAMING_CONTEXT);
        if (Config && Config == Values[NumVals]) {
            //
            // Build the pathname for "configuration\sites & services"
            //
            SitesDn = FrsDsExtendDn(Config, CN_SITES);
            ServicesDn = FrsDsExtendDn(Config, CN_SERVICES);
            break;
        }
    }
    LDAP_FREE_VALUES(Values);

    //
    // Finally, find the default naming context
    //
    Values = (PWCHAR *)FrsDsFindValues(Ldap,
                                  LdapEntry,
                                  ATTR_DEFAULT_NAMING_CONTEXT,
                                  FALSE);
    if (!Values) {
        IPRINT2(Info, "%ws   ERROR - FrsDsFindValues(default naming context, %ws) no entry\n",
                TabW, ComputerName);
        goto cleanup;
    }

    DefaultNcDn = FrsWcsDup(Values[0]);
    ComputersDn = FrsDsExtendDn(DefaultNcDn, CN_COMPUTERS);
    DomainControllersDn = FrsDsExtendDnOu(DefaultNcDn, CN_DOMAIN_CONTROLLERS);
    LDAP_FREE_VALUES(Values);

    IPRINT2(Info, "%ws   SitesDn    : %ws\n", TabW, SitesDn);
    IPRINT2(Info, "%ws   ServicesDn : %ws\n", TabW, ServicesDn);
    IPRINT2(Info, "%ws   DefaultNcDn: %ws\n", TabW, DefaultNcDn);
    IPRINT2(Info, "%ws   ComputersDn: %ws\n", TabW, ComputersDn);
    IPRINT2(Info, "%ws   DomainCtlDn: %ws\n", TabW, DomainControllersDn);

    //
    // Retrieve the computer's fully qualified Dn
    //
    ComputerFqdnLen = MAX_PATH;
    if (!GetComputerObjectName(NameFullyQualifiedDN, ComputerFqdn, &ComputerFqdnLen)) {
        IPRINT4(Info, "%ws   ERROR - GetComputerObjectName(%ws); Len %d, WStatus %s\n",
                TabW, ComputerName, ComputerFqdnLen, ErrLabelW32(GetLastError()));
        ComputerFqdn[0] = L'\0';
    } else {
        IPRINT2(Info, "%ws   Fqdn       : %ws\n", TabW, ComputerFqdn);
    }

    //
    // Find and print the computer info
    //
    PrintedComputers = FALSE;
    if (!PrintedComputers && ComputerFqdn[0]) {
        IPRINT1(Info, "%ws   Searching  : Fqdn\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, ComputerFqdn,
                               CATEGORY_COMPUTER, LDAP_SCOPE_BASE, &InfoSubs);
    }
    if (!PrintedComputers && ComputersDn) {
        IPRINT1(Info, "%ws   Searching  : Computers\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, ComputersDn,
                               CATEGORY_COMPUTER, LDAP_SCOPE_SUBTREE, &InfoSubs);
    }
    if (!PrintedComputers && DomainControllersDn) {
        IPRINT1(Info, "%ws   Searching  : Domain Controllers\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, DomainControllersDn,
                               CATEGORY_COMPUTER, LDAP_SCOPE_SUBTREE, &InfoSubs);
    }
    if (!PrintedComputers && DefaultNcDn) {
        IPRINT1(Info, "%ws   Searching  : Default Naming Context\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, DefaultNcDn,
                               CATEGORY_COMPUTER, LDAP_SCOPE_SUBTREE, &InfoSubs);
    }
    if (!PrintedComputers && DefaultNcDn) {
        IPRINT1(Info, "%ws   Searching  : Default Naming Context for USER\n", TabW);
        PrintedComputers = InfoPrintComputer(Info, Tabs, Ldap, DefaultNcDn,
                               CATEGORY_USER, LDAP_SCOPE_SUBTREE, &InfoSubs);
    }

    for (InfoSub = InfoSubs; InfoSub; InfoSub = InfoSub->Next) {
        InfoPrintSettings(Info, Tabs, Ldap, InfoSub->Dn, LocalDsHandle, &InfoSettings,
                          &InfoSets);
    }

cleanup:
    //
    // Cleanup
    //
    LDAP_FREE_VALUES(Values);
    LDAP_FREE_MSG(LdapMsg);
    if (DcInfo) {
        NetApiBufferFree(DcInfo);
        DcInfo = NULL;
    }
    if (Ldap) {
        ldap_unbind_s(Ldap);
    }
    if (HANDLE_IS_VALID(LocalDsHandle)) {
        DsUnBind(&LocalDsHandle);
    }
    FrsFree(SitesDn);
    FrsFree(ServicesDn);
    FrsFree(DefaultNcDn);
    FrsFree(ComputersDn);
    FrsFree(DomainControllersDn);

    while (InfoSub = InfoSubs) {
        InfoSubs = InfoSub->Next;
        FrsFree(InfoSub->Dn);
        FrsFree(InfoSub->SetType);
        FrsFree(InfoSub);
    }
    while (InfoSetting = InfoSettings) {
        InfoSettings = InfoSetting->Next;
        FrsFree(InfoSetting->Dn);
        FrsFree(InfoSetting->SetType);
        FrsFree(InfoSetting);
    }
    while (InfoSet = InfoSets) {
        InfoSets = InfoSet->Next;
        FrsFree(InfoSet->Dn);
        FrsFree(InfoSet->SetType);
        FrsFree(InfoSet);
    }

    //
    // Real error messages are in the info buffer
    //
    return ERROR_SUCCESS;
}


PVOID
InfoFreeInfoTable(
    IN PINFO_TABLE      InfoTable,
    IN PNTFRSAPI_INFO   Info
    )
/*++
Routine Description:
    Free the info IDTable

Arguments:
    InfoTable
    Info

Return Value:
    NULL
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoFreeInfoTable:"
    JET_ERR jerr;

    if (InfoTable == NULL) {
        return NULL;
    }

    if (InfoTable->TableCtx != NULL) {
        DbsFreeTableContext(InfoTable->TableCtx, InfoTable->ThreadCtx->JSesid);
    }

    if (InfoTable->ThreadCtx != NULL) {
        jerr = DbsCloseJetSession(InfoTable->ThreadCtx);
        if (!JET_SUCCESS(jerr)) {
            IPRINT1(Info, "DbsCloseJetSession jet error = %s\n", ErrLabelJet(jerr));
        }

        InfoTable->ThreadCtx = FrsFreeType(InfoTable->ThreadCtx);
    }

    return FrsFree(InfoTable);

}


JET_ERR
InfoConfigTableWorker(
    IN PTHREAD_CTX           ThreadCtx,
    IN PTABLE_CTX            TableCtx,
    IN PCONFIG_TABLE_RECORD  ConfigRecord,
    IN PFRS_INFO_CONTEXT     FrsInfoContext
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an ConfigTable context struct.
    ConfigRecord  - A ptr to a config table record.
    InfoTable

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "InfoConfigTableWorker:"

    PINFO_TABLE  InfoTable = FrsInfoContext->InfoTable;

    //
    // Check if there is enough room for another record.
    //
    if (!INFO_HAS_SPACE(InfoTable->Info)) {
        SetFlag(InfoTable->Info->Flags, NTFRSAPI_INFO_FLAGS_FULL);
    }

    if (FrsInfoContext->KeyValue == NULL) {
        FrsInfoContext->KeyValue = FrsAlloc(sizeof(ULONG));
    }

    CopyMemory(FrsInfoContext->KeyValue, &ConfigRecord->ReplicaNumber, sizeof(ULONG));

    if (FlagOn(InfoTable->Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
        return JET_errNoCurrentRecord;
    }

    IPRINT0(InfoTable->Info, "\n\n");

    DbsDisplayRecordIPrint(TableCtx, InfoTable, TRUE, NULL, 0);

    return JET_errSuccess;
}


JET_ERR
InfoIDTableWorker(
    IN PTHREAD_CTX       ThreadCtx,
    IN PTABLE_CTX        TableCtx,
    IN PIDTABLE_RECORD   IDTableRec,
    IN PFRS_INFO_CONTEXT FrsInfoContext
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an IDTable context struct.
    IDTableRec  - A ptr to a IDTable record.
    InfoTable

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "InfoIDTableWorker:"

    PINFO_TABLE  InfoTable = FrsInfoContext->InfoTable;

    //
    // Check if there is enough room for another record.
    //
    if (!INFO_HAS_SPACE(InfoTable->Info)) {
        SetFlag(InfoTable->Info->Flags, NTFRSAPI_INFO_FLAGS_FULL);
    }

    if (FrsInfoContext->KeyValue == NULL) {
        FrsInfoContext->KeyValue = FrsAlloc(sizeof(GUID));
    }

    COPY_GUID(FrsInfoContext->KeyValue, &IDTableRec->FileGuid);

    if (FlagOn(InfoTable->Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
        return JET_errNoCurrentRecord;
    }

    //
    // Table Descriptor
    //
    IPRINT2(InfoTable->Info, "\nTable Type: ID Table for %ws (%d)\n",
            InfoTable->Replica->ReplicaName->Name, InfoTable->Replica->ReplicaNumber);

    DbsDisplayRecordIPrint(TableCtx, InfoTable, TRUE, NULL, 0);


    return JET_errSuccess;


}


JET_ERR
InfoInOutLogTableWorker(
    IN PTHREAD_CTX              ThreadCtx,
    IN PTABLE_CTX               TableCtx,
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PFRS_INFO_CONTEXT        FrsInfoContext,
    IN PWCHAR                   TableDescriptor
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an IDTable context struct.
    Coc         - A ptr to a inbound log record (change order)
    InfoTable
    TableDescriptor

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "InfoInOutLogTableWorker:"

    PREPLICA Replica;

    PCXTION      Cxtion = NULL;
    PWSTR        CxtName     = L"<null>";
    PWSTR        PartnerName = L"<null>";
    PWSTR        PartSrvName = L"<null>";
    PCHAR        CxtionState = "<null>";
    BOOL         PrintCxtion;
    PINFO_TABLE  InfoTable = FrsInfoContext->InfoTable;

    //
    // Check if there is enough room for another record.
    //
    if (!INFO_HAS_SPACE(InfoTable->Info)) {
        SetFlag(InfoTable->Info->Flags, NTFRSAPI_INFO_FLAGS_FULL);
    }

    if (FrsInfoContext->KeyValue == NULL) {
        FrsInfoContext->KeyValue = FrsAlloc(sizeof(ULONG));
    }

    CopyMemory(FrsInfoContext->KeyValue, &Coc->SequenceNumber, sizeof(ULONG));

    if (FlagOn(InfoTable->Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
        return JET_errNoCurrentRecord;
    }

    //
    // Table Descriptor
    //
    IPRINT3(InfoTable->Info, "\nTable Type: %ws for %ws (%d)\n",
            TableDescriptor, InfoTable->Replica->ReplicaName->Name, InfoTable->Replica->ReplicaNumber);

    //
    // Dump the change order record.
    //
    DbsDisplayRecordIPrint(TableCtx, InfoTable, TRUE, NULL, 0);


    Replica = InfoTable->Replica;
    //
    // Find the cxtion for this CO
    //
    LOCK_CXTION_TABLE(Replica);

    Cxtion = GTabLookupNoLock(Replica->Cxtions, &Coc->CxtionGuid, NULL);

    PrintCxtion = (Cxtion != NULL) && (Cxtion->Inbound);

    if (PrintCxtion) {
        CxtionState = GetCxtionStateName(Cxtion);

        if (Cxtion->Name != NULL) {

            if (Cxtion->Name->Name != NULL) {
                CxtName = Cxtion->Name->Name;
            }
        }

        if ((Cxtion->Partner != NULL) && (Cxtion->Partner->Name != NULL)) {
            PartnerName = Cxtion->Partner->Name;
        }

        if (Cxtion->PartSrvName != NULL) {
            PartSrvName = Cxtion->PartSrvName;
        }
    }
    UNLOCK_CXTION_TABLE(Replica);

    if (PrintCxtion) {
        IPRINT3(InfoTable->Info, "Cxtion Name                  : %ws <- %ws\\%ws\n",
                 CxtName, PartnerName, PartSrvName);

        IPRINT1(InfoTable->Info, "Cxtion State                 : %s\n", CxtionState);
    }

    return JET_errSuccess;

}


JET_ERR
InfoInLogTableWorker(
    IN PTHREAD_CTX              ThreadCtx,
    IN PTABLE_CTX               TableCtx,
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PFRS_INFO_CONTEXT        FrsInfoContext
    )
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an IDTable context struct.
    Coc         - A ptr to a inbound log record (change order)
    InfoTable

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
    return InfoInOutLogTableWorker(ThreadCtx, TableCtx, Coc, FrsInfoContext,
                                   L"Inbound Log Table");
}







JET_ERR
InfoOutLogTableWorker(
    IN PTHREAD_CTX              ThreadCtx,
    IN PTABLE_CTX               TableCtx,
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PFRS_INFO_CONTEXT        FrsInfoContext
    )
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it prints an entry into the info buffer.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an IDTable context struct.
    Coc         - A ptr to a inbound log record (change order)
    InfoTable

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
    return InfoInOutLogTableWorker(ThreadCtx, TableCtx, Coc, FrsInfoContext,
                                   L"Outbound Log Table");
}


DWORD
InfoPrintSingleTable(
    IN PNTFRSAPI_INFO    Info,
    IN PFRS_INFO_CONTEXT FrsInfoContext,
    IN PREPLICA          Replica,
    IN PENUMERATE_TABLE_ROUTINE InfoTableWorker
    )
/*++
Routine Description:

    Display data for the specified table using the InfoPrint interface.

Arguments:
    Info - ptr to the API Info ctx.
    FrsInfoContext - Context saved by the service.
    Replica, -- ptr to the replica struct for the replica set.
    InfoTableWorker -- The function to call to display each record.

Return Value:
    jet error Status

--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintSingleTable:"

    JET_ERR             jerr = JET_errSuccess;
    PINFO_TABLE         InfoTable = NULL;


    try {

        InfoTable = FrsAlloc(sizeof(*InfoTable));
        FrsInfoContext->InfoTable = InfoTable;
        InfoTable->ThreadCtx = FrsAllocType(THREAD_CONTEXT_TYPE);
        InfoTable->TableCtx = DbsCreateTableContext(FrsInfoContext->TableType);
        InfoTable->Info = Info;
        InfoTable->Tabs = 0;   /* Tabs + 1*/   // Pitch this tabs stuff.

        if (FrsInfoContext->KeyValue == NULL) {
            //
            // Print the replica name only if this is the first call.
            //
            if ((FrsInfoContext->TableType == ConfigTablex) ||
                (FrsInfoContext->TableType == ServiceTablex)) {

                IPRINT1(Info, "\n***** %ws\n", FrsInfoContext->TableName);
            } else {
                IPRINT1(Info, "\n***** %ws\n", Replica->ReplicaName->Name);
            }
        }

        //
        // Setup a Jet Session (returning the session ID in ThreadCtx).
        //
        jerr = DbsCreateJetSession(InfoTable->ThreadCtx);
        if (!JET_SUCCESS(jerr)) {
            IPRINT2(Info,"ERROR - %ws: DbsCreateJetSession jet error %s.\n",
                    FrsInfoContext->TableName, ErrLabelJet(jerr));
            goto RETURN;
        }
        //
        // Init the table context and open the table.
        //
        jerr = DbsOpenTable(InfoTable->ThreadCtx,
                            InfoTable->TableCtx,
                            ReplicaAddrToId(Replica),
                            FrsInfoContext->TableType,
                            NULL);
        if (!JET_SUCCESS(jerr)) {
            IPRINT2(Info,"ERROR - %ws: DbsOpenTable jet error %s.\n",
                    FrsInfoContext->TableName, ErrLabelJet(jerr));
            goto RETURN;
        }

        InfoTable->Replica = Replica;

        //
        // Scan thru the Table
        //
        jerr = FrsEnumerateTableFrom(InfoTable->ThreadCtx,
                                     InfoTable->TableCtx,
                                     FrsInfoContext->Indexx,
                                     FrsInfoContext->KeyValue,
                                     FrsInfoContext->ScanDirection,
                                     InfoTableWorker,
                                     FrsInfoContext);
        //
        // We're done.  Return success if we made it to the end
        //
        if (jerr != JET_errNoCurrentRecord &&
            jerr != JET_wrnTableEmpty) {
            IPRINT2(Info,"ERROR - %ws: FrsEnumerateTableFrom jet error %s.\n",
                    FrsInfoContext->TableName, ErrLabelJet(jerr));
        }

RETURN:;

    } finally {
        //
        // Make sure we close jet and free the memory.
        //
        InfoTable = InfoFreeInfoTable(InfoTable, Info);
    }

    return jerr;
}


DWORD
InfoPrintTables(
    IN PNTFRSAPI_INFO    Info,
    IN PFRS_INFO_CONTEXT FrsInfoContext,
    IN PWCHAR            TableDescriptor,
    IN TABLE_TYPE        TableType,
    IN ULONG             InfoIndexx,
    IN PENUMERATE_TABLE_ROUTINE InfoTableWorker
    )
/*++
Routine Description:
    Return internal info on a DB Table (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    FrsInfoContext - Context saved by the service.
    TableDescriptor - Text string for output
    TableType - Table type code (from schema.h)
    InfoIndexx - Table index to use for enumeration (from schema.h)

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintTables:"
    PVOID               Key;
    PREPLICA            Replica = NULL;
    PREPLICA            NextReplica = NULL;
    extern PGEN_TABLE   ReplicasByGuid;

    FrsFree(FrsInfoContext->TableName);

    FrsInfoContext->TableName = FrsWcsDup(TableDescriptor);
    FrsInfoContext->TableType = TableType;
    FrsInfoContext->Indexx = InfoIndexx;

    //
    // Check for single instance tables.
    //
    if ((TableType == ConfigTablex) ||
        (TableType == ServiceTablex)) {

        InfoPrintSingleTable(Info,
                             FrsInfoContext,
                             Replica,
                             InfoTableWorker);
        return ERROR_SUCCESS;
    }

    //
    // For the given table type, dump info for all replica sets.
    //
    if (FrsInfoContext->KeyValue == NULL) {
        //
        // Print the header only for the first call.
        //
        IPRINT1(Info, "NTFRS %ws\n", TableDescriptor);
    }


    do {
        NextReplica = NULL;

        Key = NULL;
        while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
            if (Replica->ReplicaNumber == FrsInfoContext->ReplicaNumber) {
                //
                // Found the replica we were looking for. Break and process it.
                //
                NextReplica = Replica;
                break;
            } else if ((Replica->ReplicaNumber > FrsInfoContext->ReplicaNumber) &&
                       ((NextReplica == NULL) ||
                        (Replica->ReplicaNumber < NextReplica->ReplicaNumber))) {
                //
                // We are getting closer. Pick this one instead.
                //
                NextReplica = Replica;
            }
        }

        if (NextReplica != NULL) {

            FrsInfoContext->ReplicaNumber = NextReplica->ReplicaNumber;

            InfoPrintSingleTable(Info,
                                 FrsInfoContext,
                                 NextReplica,
                                 InfoTableWorker);

            if (!FlagOn(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
                //
                // Buffer is not full yet. We must have completed processing the replica.
                // Move to the next one.
                //
                FrsInfoContext->ReplicaNumber+=1;
                FrsInfoContext->KeyValue = FrsFree(FrsInfoContext->KeyValue);

            } else {
                //
                // Buffer is full. We will come back here looking for the same replica.
                //
                break;
            }
        }

    } while ( NextReplica != NULL );

    return ERROR_SUCCESS;
}



DWORD
InfoPrintMemory(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on memory usage (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs    - number of tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintMemory:"
    FrsPrintAllocStats(0, Info, Tabs);
    FrsPrintRpcStats(0, Info, Tabs);
    return ERROR_SUCCESS;
}





DWORD
InfoPrintThreads(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on thread usage (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs    - number of tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintThreads:"
    FrsPrintThreadStats(0, Info, Tabs);
    return ERROR_SUCCESS;
}


VOID
FrsPrintStageStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    );
DWORD
InfoPrintStage(
    IN PNTFRSAPI_INFO   Info,
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Return internal info on thread usage (see private\net\inc\ntfrsapi.h).

Arguments:
    Info    - RPC output buffer
    Tabs    - number of tabs

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoPrintStage:"
    FrsPrintStageStats(0, Info, Tabs);
    return ERROR_SUCCESS;
}


DWORD
InfoVerify(
    IN ULONG        BlobSize,
    IN OUT PBYTE    Blob
    )
/*++
Routine Description:
    Verify the consistency of the blob.

Arguments:
    BlobSize    - total bytes of Blob
    Blob        - details desired info and provides buffer for info

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoVerify:"
    DWORD   WStatus = ERROR_SUCCESS;
    PBYTE   EoB;
    PBYTE   EoI;
    PBYTE   BoL;
    PBYTE   BoF;
    PNTFRSAPI_INFO  Info = (PNTFRSAPI_INFO)Blob;

    //
    // Not a valid blob
    //
    if (BlobSize < NTFRSAPI_INFO_HEADER_SIZE) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }

    //
    // BlobSize must include the entire Blob
    //
    if (BlobSize != Info->SizeInChars) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }

    //
    // Return our info version
    //
    Info->NtFrsMajor = NTFRS_MAJOR;
    Info->NtFrsMinor = NTFRS_MINOR;
    SetFlag(Info->Flags, NTFRSAPI_INFO_FLAGS_VERSION);

    //
    // Bad major
    //
    if (Info->Major != Info->NtFrsMajor) {
        DPRINT2(4,"NTFRSAPI major rev mismatch (dll=%d), (svc=%d)\n",
                Info->Major, Info->NtFrsMajor);
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }
    //
    // Bad minor -- put a message in the debug log.
    //
    if (Info->Minor != Info->NtFrsMinor) {
        DPRINT2(4,"NTFRSAPI minor rev mismatch (dll=%d), (svc=%d)\n",
                Info->Minor, Info->NtFrsMinor);
    }

    //
    // Not large enough to verify internal consistency (or return any data).
    //
    if (Info->SizeInChars < sizeof(NTFRSAPI_INFO)) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }

    //
    // Buffer full; done
    //
    if (FlagOn(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
        goto CLEANUP;
    }

    //
    // Verify internal offsets
    //
    // make this into a subroutine (table driven?)
    //
    EoB = Blob + BlobSize;
    EoI = ((PBYTE)Info) + (Info->SizeInChars);
    BoL = (PBYTE)(((PCHAR)Info) + Info->OffsetToLines);
    BoF = (PBYTE)(((PCHAR)Info) + Info->OffsetToFree);
    if (EoI > EoB ||
        BoL > EoB ||
        BoF > EoB ||
        EoI < Blob ||
        BoL < Blob ||
        BoF < Blob) {
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;
    }

    //
    // No free space in buffer; done
    //
    if (BoF == EoB) {
        SetFlag(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL);
        goto CLEANUP;
    }

CLEANUP:
    return WStatus;
}



PVOID
InfoFrsInfoContextFree(
    PFRS_INFO_CONTEXT FrsInfoContext
    )
/*++
Routine Description:
    Frees the FRS_INFO_CONTEXT structure.

Arguments:
    FrsInfoContext - Context to free.

Return Value:
    None
--*/
{
#undef DEBSUB
#define  DEBSUB  "InfoFrsInfoContextFree:"

    if (FrsInfoContext == NULL) {
        return NULL;
    }

    FrsFree(FrsInfoContext->KeyValue);
    FrsFree(FrsInfoContext->TableName);
    FrsFree(FrsInfoContext);

    return NULL;
}


DWORD
Info(
    IN ULONG        BlobSize,
    IN OUT PBYTE    Blob
    )
/*++
Routine Description:
    Return internal info (see private\net\inc\ntfrsapi.h).

Arguments:
    BlobSize    - total bytes of Blob
    Blob        - details desired info and provides buffer for info

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "Info:"

    FILETIME            Now;
    ULARGE_INTEGER      ULNow;
    ULARGE_INTEGER      ULLastAccessTime;
    ULARGE_INTEGER      TimeSinceLastAccess;

    DWORD               WStatus;
    ULONG               i;
    ULONG               ProductType;
    ULONG               Arch;
    BOOL                HaveLock = FALSE;

    PNTFRSAPI_INFO      Info = (PNTFRSAPI_INFO)Blob;
    PFRS_INFO_CONTEXT   FrsInfoContext = NULL;
    PVOID               Key;
    CHAR                TimeString[TIME_STRING_LENGTH];


    try {
        //
        // Verify the blob
        //
        WStatus = InfoVerify(BlobSize, Blob);
        if (!WIN_SUCCESS(WStatus)) {
            goto cleanup;
        }

        //
        // The table is initialized in the startup code.
        // If it not yet initialized then return an error.
        //
        if (FrsInfoContextTable == NULL) {
            WStatus = ERROR_RETRY;
            goto cleanup;
        }

        //
        // Free table of all contexts that have not been accessed in
        // the last 1 hour.
        //
        GTabLockTable(FrsInfoContextTable);

	//
	// Get the current time AFTER we grab the table lock.
	// If we got the time before grabbing the lock, then this thread
	// could be context switched out and another could come and grab the 
	// lock. The time stamp on that thread's InfoContext would be later 
	// than this thread's ULNow. That would cause the calculation below
	// to screw up since it assumes ULLastAccessTime < ULNow.
	//
        GetSystemTimeAsFileTime((PFILETIME) &ULNow);

        HaveLock = TRUE;
        Key = NULL;

        while ((FrsInfoContext = GTabNextDatumNoLock(FrsInfoContextTable, &Key)) != NULL) {

            FileTimeToString(&FrsInfoContext->LastAccessTime, TimeString);

            COPY_TIME(&ULLastAccessTime, &FrsInfoContext->LastAccessTime);

	    //
	    // This is an unsigned value and thus the calculation assumes
	    // that ULLastAccessTime is less than ULNow.
	    //
	    FRS_ASSERT(ULLastAccessTime.QuadPart <= ULNow.QuadPart);
            TimeSinceLastAccess.QuadPart =
                (ULNow.QuadPart - ULLastAccessTime.QuadPart) / (CONVERT_FILETIME_TO_MINUTES);

            if (TimeSinceLastAccess.QuadPart > 60) {
                GTabDeleteNoLock(FrsInfoContextTable,
                                 &FrsInfoContext->ContextIndex,
                                 NULL,
                                 InfoFrsInfoContextFree);
                //
                // Reset table enum scan.
                //
                Key = NULL;
            }
        }

        //
        // The caller's context handle was returned in Info->TotalChars
        // when the first call was made.  Use it to find the context.
        //
        FrsInfoContext = GTabLookupNoLock(FrsInfoContextTable, &Info->TotalChars, NULL);

        if (FrsInfoContext == NULL) {
            //
            // Check for DOS attack.
            //
            if (GTabNumberInTable(FrsInfoContextTable) >= FRS_INFO_MAX_CONTEXT_ACTIVE) {
                HaveLock = FALSE;
                GTabUnLockTable(FrsInfoContextTable);
                goto cleanup;
            }

            //
            // First call. Initialize a new context.
            //
            FrsInfoContext = FrsAlloc(sizeof(FRS_INFO_CONTEXT));
            FrsInfoContext->ContextIndex = InterlockedIncrement(&FrsInfoContextNum);
            DPRINT1(4,"Creating new ContextIndex = %d\n", FrsInfoContext->ContextIndex);
            FrsInfoContext->ReplicaNumber = 0;
            FrsInfoContext->ScanDirection = 1;
            FrsInfoContext->SaveTotalChars = 0;
            FrsInfoContext->KeyValue = NULL;
            FrsInfoContext->TableName = NULL;
            FrsInfoContext->TableType = TABLE_TYPE_INVALID;

            GTabInsertEntryNoLock(FrsInfoContextTable,
                                  FrsInfoContext,
                                  &FrsInfoContext->ContextIndex,
                                  NULL);

        } else {
            DPRINT1(4,"Using existing contextIndex = %d\n", FrsInfoContext->ContextIndex);
        }

        //
        // Update LastAccessTime and pickup CharsToSkip. We now use the TotalChars field
        // in the NTFRSAPI_INFO structure to store the ContextIndex so we save the
        // TotalChars in the new FRS_INFO_CONTEXT structure and pick it up here.
        //
        if (FrsInfoContext->KeyValue != NULL) {
            //
            // If we are planning to scan to a specific record in the table then
            // no need to skip characters.
            //
            Info->CharsToSkip = 0;
        } else {
            //
            // Otherwise restore value from save area in caller's context
            // since value passed in by caller is likely bogus.
            //
            Info->CharsToSkip = FrsInfoContext->SaveTotalChars;
        }

        //
        // Restore TotalChars from save area in FrsInfoContext.
        //
        Info->TotalChars = FrsInfoContext->SaveTotalChars;

        GetSystemTimeAsFileTime(&FrsInfoContext->LastAccessTime);

        HaveLock = FALSE;
        GTabUnLockTable(FrsInfoContextTable);

        //
        // Full buffer; done
        //
        if (FlagOn(Info->Flags, NTFRSAPI_INFO_FLAGS_FULL)) {
            goto cleanup;
        }

        if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_VERSION) {
            IPRINT0(Info, "NtFrs Version Information\n");
            IPRINT1(Info, "   NtFrs Major        : %d\n", NtFrsMajor);
            IPRINT1(Info, "   NtFrs Minor        : %d\n", NtFrsMinor);
            // IPRINT1(Info, "   NtFrs Module       : %s\n", NtFrsModule);
            IPRINT2(Info, "   NtFrs Compiled on  : %s %s\n", NtFrsDate, NtFrsTime);
#if    NTFRS_TEST
            IPRINT0(Info, "   NTFRS_TEST Enabled\n");
#endif NTFRS_TEST

            i = 0;
            while (LatestChanges[i] != NULL) {
                IPRINT1(Info, "   %s\n", LatestChanges[i]);
                i++;
            }


            IPRINT4(Info, "OS Version %d.%d (%d) - %w\n",
                    OsInfo.dwMajorVersion, OsInfo.dwMinorVersion,
                    OsInfo.dwBuildNumber, OsInfo.szCSDVersion);

            ProductType = (ULONG) OsInfo.wProductType;
            IPRINT4(Info, "SP (%hd.%hd) SM: 0x%04hx  PT: 0x%02x\n",
                    OsInfo.wServicePackMajor, OsInfo.wServicePackMinor,
                    OsInfo.wSuiteMask, ProductType);

            Arch = SystemInfo.wProcessorArchitecture;
            if (Arch >= ARRAY_SZ(ProcessorArchName)) {
                Arch = ARRAY_SZ(ProcessorArchName)-1;
            }

            IPRINT5(Info, "Processor:  %s Level: 0x%04hx  Revision: 0x%04hx  Processor num/mask: %d/%08x\n",
                   ProcessorArchName[Arch], SystemInfo.wProcessorLevel,
                   SystemInfo.wProcessorRevision, SystemInfo.dwNumberOfProcessors,
                   SystemInfo.dwActiveProcessorMask);

            goto cleanup;

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_SETS) {
            WStatus = InfoPrintDbSets(Info, 0);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_DS) {
            WStatus = InfoPrintDs(Info, 0);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_MEMORY) {
            WStatus = InfoPrintMemory(Info, 0);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_IDTABLE) {
            WStatus = InfoPrintTables(Info,
                                      FrsInfoContext,
                                      L"ID TABLES",
                                      IDTablex,
                                      GuidIndexx,
                                      InfoIDTableWorker);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_INLOG) {
            WStatus = InfoPrintTables(Info,
                                      FrsInfoContext,
                                      L"INLOG TABLES",
                                      INLOGTablex,
                                      ILSequenceNumberIndexx,
                                      InfoInLogTableWorker);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_OUTLOG) {
            WStatus = InfoPrintTables(Info,
                                      FrsInfoContext,
                                      L"OUTLOG TABLES",
                                      OUTLOGTablex,
                                      OLSequenceNumberIndexx,
                                      InfoOutLogTableWorker);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_CONFIGTABLE) {
            WStatus = InfoPrintTables(Info,
                                      FrsInfoContext,
                                      L"CONFIG TABLE",
                                      ConfigTablex,
                                      ReplicaNumberIndexx,
                                      InfoConfigTableWorker);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_THREADS) {
            WStatus = InfoPrintThreads(Info, 0);

        } else if (Info->TypeOfInfo == NTFRSAPI_INFO_TYPE_STAGE) {
            WStatus = InfoPrintStage(Info, 0);

        } else {
            IPRINT1(Info, "NtFrs Doesn't understand TypeOfInfo %d\n", Info->TypeOfInfo);
            WStatus = ERROR_INVALID_PARAMETER;
        }

cleanup:;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        GET_EXCEPTION_CODE(WStatus);
        //
        // Make sure we drop the lock so we don't hang all other callers.
        //
        if (HaveLock) {
            GTabUnLockTable(FrsInfoContextTable);
        }
    }

    //
    // Save the value of TotalChars in the context strut for this caller.
    // Return the ContextIndex (handle) to the caller for use in subsequent calls.
    //
    if (FrsInfoContext != NULL) {
        FrsInfoContext->SaveTotalChars = Info->TotalChars;
        Info->TotalChars = FrsInfoContext->ContextIndex;
    }

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\name.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Name.c

NOTE: The code is copied here from FsRtl because it called the pool allocator.
      The function prefixes were changed to avoid confusion.

Abstract:

    The unicode name support package is for manipulating unicode strings
    The routines allow the caller to dissect and compare strings.

    The following routines are provided by this package:

      o  FrsDissectName - This routine takes a path name string and breaks
         into two parts.  The first name in the string and the remainder.
         It also checks that the first name is valid for an NT file.

      o  FrsColateNames - This routine is used to colate directories
         according to lexical ordering.  Lexical ordering is strict unicode
         numerical oerdering.

      o  FrsDoesNameContainsWildCards - This routine tells the caller if
         a string contains any wildcard characters.

      o  FrsIsNameInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop

#define DEBSUB  "NAME:"

#include <frs.h>

//
//  Local support routine prototypes
//

BOOLEAN
FrsIsNameInExpressionPrivate (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    );



VOID
FrsDissectName (
    IN UNICODE_STRING Path,
    OUT PUNICODE_STRING FirstName,
    OUT PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine cracks a path.  It picks off the first element in the
    given path name and provides both it and the remaining part.  A path
    is a set of file names separated by backslashes.  If a name begins
    with a backslash, the FirstName is the string immediately following
    the backslash.  Here are some examples:

        Path           FirstName    RemainingName
        ----           ---------    -------------
        empty          empty        empty

        \              empty        empty

        A              A            empty

        \A             A            empty

        A\B\C\D\E      A            B\C\D\E

        *A?            *A?          empty


    Note that both output strings use the same string buffer memory of the
    input string, and are not necessarily null terminated.

    Also, this routine makes no judgement as to the legality of each
    file name componant.  This must be done separatly when each file name
    is extracted.

Arguments:

    Path - The full path name to crack.

    FirstName - The first name in the path.  Don't allocate a buffer for
        this string.

    RemainingName - The rest of the path.  Don't allocate a buffer for this
        string.

Return Value:

    None.

--*/

{
    ULONG i = 0;
    ULONG PathLength;
    ULONG FirstNameStart;

    //
    //  Make both output strings empty for now
    //

    FRS_ASSERT( ValueIsMultOf2(Path.Length) );

    FirstName->Length = 0;
    FirstName->MaximumLength = 0;
    FirstName->Buffer = NULL;

    RemainingName->Length = 0;
    RemainingName->MaximumLength = 0;
    RemainingName->Buffer = NULL;

    PathLength = Path.Length / sizeof(WCHAR);

    //
    //  Check for an empty input string
    //

    if (PathLength == 0) {

        return;
    }

    //
    //  Skip over a starting backslash, and make sure there is more.
    //

    if ( Path.Buffer[0] == L'\\' ) {

        i = 1;
    }

    //
    //  Now run down the input string until we hit a backslash or the end
    //  of the string, remembering where we started;
    //

    for ( FirstNameStart = i;
          (i < PathLength) && (Path.Buffer[i] != L'\\');
          i += 1 ) {

        NOTHING;
    }

    //
    //  At this point all characters up to (but not including) i are
    //  in the first part.   So setup the first name
    //

    FirstName->Length = (USHORT)((i - FirstNameStart) * sizeof(WCHAR));
    FirstName->MaximumLength = FirstName->Length;
    FirstName->Buffer = &Path.Buffer[FirstNameStart];

    //
    //  Now the remaining part needs a string only if the first part didn't
    //  exhaust the entire input string.  We know that if anything is left
    //  that is must start with a backslash.  Note that if there is only
    //  a trailing backslash, the length will get correctly set to zero.
    //

    if (i < PathLength) {

        RemainingName->Length = (USHORT)((PathLength - (i + 1)) * sizeof(WCHAR));
        RemainingName->MaximumLength = RemainingName->Length;
        RemainingName->Buffer = &Path.Buffer[i + 1];
    }

    //
    //  And return to our caller
    //

    return;
}

BOOLEAN
FrsDoesNameContainWildCards (
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/
{
    PUSHORT p;

    FRS_ASSERT( ValueIsMultOf2(Name->Length) );

    //
    //  Check each character in the name to see if it's a wildcard
    //  character.
    //

    if( Name->Length ) {
        for( p = Name->Buffer + (Name->Length / sizeof(WCHAR)) - 1;
             p >= Name->Buffer && *p != L'\\' ;
             p-- ) {

            //
            //  check for a wild card character
            //

            if (FrsIsUnicodeCharacterWild( *p )) {

                //
                //  Tell caller that this name contains wild cards
                //

                return TRUE;
            }
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}


BOOLEAN
FrsAreNamesEqual (
    IN PUNICODE_STRING ConstantNameA,
    IN PUNICODE_STRING ConstantNameB,
    IN BOOLEAN IgnoreCase,
    IN PCWCH UpcaseTable OPTIONAL
    )

/*++

Routine Description:

    This routine simple returns whether the two names are exactly equal.
    If the two names are known to be constant, this routine is much
    faster than FrsIsNameInExpression.

Arguments:

    ConstantNameA - Constant name.

    ConstantNameB - Constant name.

    IgnoreCase - TRUE if the Names should be Upcased before comparing.

    UpcaseTable - If supplied, use this table for case insensitive compares,
        otherwise, use the default system upcase table.

Return Value:

    BOOLEAN - TRUE if the two names are lexically equal.

--*/

{
    ULONG Index;
    ULONG NameLength;
    BOOLEAN FreeStrings = FALSE;

    UNICODE_STRING LocalNameA;
    UNICODE_STRING LocalNameB;


    FRS_ASSERT( ValueIsMultOf2(ConstantNameA->Length) );
    FRS_ASSERT( ValueIsMultOf2(ConstantNameB->Length) );

    //
    // If the names aren't even the same size, then return FALSE right away.
    //

    if ( ConstantNameA->Length != ConstantNameB->Length ) {

        return FALSE;
    }

    NameLength = ConstantNameA->Length / sizeof(WCHAR);

    //
    //  If we weren't given an upcase table, we have to upcase the names
    //  ourselves.
    //

    if ( IgnoreCase && !ARGUMENT_PRESENT(UpcaseTable) ) {

        NTSTATUS Status;

        Status = RtlUpcaseUnicodeString( &LocalNameA, ConstantNameA, TRUE );
        if ( !NT_SUCCESS(Status) ) {
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        Status = RtlUpcaseUnicodeString( &LocalNameB, ConstantNameB, TRUE );
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeUnicodeString( &LocalNameA );
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        ConstantNameA = &LocalNameA;
        ConstantNameB = &LocalNameB;

        IgnoreCase = FALSE;
        FreeStrings = TRUE;
    }

    //
    //  Do either case sensitive or insensitive compare.
    //

    if ( !IgnoreCase ) {

        BOOLEAN BytesEqual;

        BytesEqual = (BOOLEAN) RtlEqualMemory( ConstantNameA->Buffer,
                                               ConstantNameB->Buffer,
                                               ConstantNameA->Length );

        if ( FreeStrings ) {

            RtlFreeUnicodeString( &LocalNameA );
            RtlFreeUnicodeString( &LocalNameB );
        }

        return BytesEqual;

    } else {

        for (Index = 0; Index < NameLength; Index += 1) {

            if ( UpcaseTable[ConstantNameA->Buffer[Index]] !=
                 UpcaseTable[ConstantNameB->Buffer[Index]] ) {

                return FALSE;
            }
        }

        return TRUE;
    }
}


//
//  The following routine is just a wrapper around
//  FrsIsNameInExpressionPrivate to make a last minute fix a bit safer.
//

BOOLEAN
FrsIsNameInExpression (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable OPTIONAL
    )

{
    BOOLEAN Result;
    UNICODE_STRING LocalName;


    FRS_ASSERT( ValueIsMultOf2(Expression->Length) );
    FRS_ASSERT( ValueIsMultOf2(Name->Length) );

    //
    //  If we weren't given an upcase table, we have to upcase the names
    //  ourselves.
    //

    if ( IgnoreCase && !ARGUMENT_PRESENT(UpcaseTable) ) {

        NTSTATUS Status;

        Status = RtlUpcaseUnicodeString( &LocalName, Name, TRUE );

        if ( !NT_SUCCESS(Status) ) {
            XRAISEGENEXCEPTION(FrsErrorInternalError);
        }

        Name = &LocalName;

        IgnoreCase = FALSE;

    } else {

        LocalName.Buffer = NULL;
    }

    //
    //  Now call the main routine, remembering to free the upcased string
    //  if we allocated one.
    //

    try {

        Result = FrsIsNameInExpressionPrivate( Expression,
                                                 Name,
                                                 IgnoreCase,
                                                 UpcaseTable );

    } finally {

        if (LocalName.Buffer != NULL) {

            RtlFreeUnicodeString( &LocalName );
        }
    }

    return Result;
}


#define MATCHES_ARRAY_SIZE 16

//
//  Local support routine prototypes
//

BOOLEAN
FrsIsNameInExpressionPrivate (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    IgnoreCase - TRUE if Name should be Upcased before comparing.

    UpcaseTable - UpCase table to use if Ingoring Case.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    WCHAR NameChar, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    FRS_ASSERT( Name->Length != 0 );
    FRS_ASSERT( ValueIsMultOf2(Name->Length) );

    FRS_ASSERT( Expression->Length != 0 );
    FRS_ASSERT( ValueIsMultOf2(Expression->Length) );

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((Expression->Length == 2) && (Expression->Buffer[0] == L'*')) {

        return TRUE;
    }

    FRS_ASSERT( FrsDoesNameContainWildCards( Expression ) );

    FRS_ASSERT( !IgnoreCase || ARGUMENT_PRESENT(UpcaseTable) );

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == L'*') {

        UNICODE_STRING LocalExpression;

        LocalExpression = *Expression;

        LocalExpression.Buffer += 1;
        LocalExpression.Length -= 2;

        //
        //  Only special case an expression with a single *
        //

        if ( !FrsDoesNameContainWildCards( &LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (Name->Length < (USHORT)(Expression->Length - sizeof(WCHAR))) {

                return FALSE;
            }

            StartingNameOffset = ( Name->Length -
                                   LocalExpression.Length ) / sizeof(WCHAR);

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

            if ( !IgnoreCase ) {

                return (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
                                                 Name->Buffer + StartingNameOffset,
                                                 LocalExpression.Length );

            } else {

                for ( ExprOffset = 0;
                      ExprOffset < (USHORT)(LocalExpression.Length / sizeof(WCHAR));
                      ExprOffset += 1 ) {

                    NameChar = Name->Buffer[StartingNameOffset + ExprOffset];
                    NameChar = UpcaseTable[NameChar];

                    ExprChar = LocalExpression.Buffer[ExprOffset];

                    FRS_ASSERT( ExprChar == UpcaseTable[ExprChar] );

                    if ( NameChar != ExprChar ) {

                        return FALSE;
                    }
                }

                return TRUE;
            }
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            NameChar = Name->Buffer[NameOffset / sizeof(WCHAR)];

            NameOffset += sizeof(WCHAR);;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                if ( ExprOffset == Expression->Length ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;
                Length = sizeof(WCHAR);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == Expression->Length ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression->Buffer[ExprOffset / sizeof(WCHAR)];

                FRS_ASSERT( !IgnoreCase || !((ExprChar >= L'a') && (ExprChar <= L'z')) );

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some memory if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) &&
                     (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = Expression->Length / sizeof(WCHAR);
                    AuxBuffer = FrsAlloc((ExpressionChars+1)*sizeof(USHORT)*2*2);

                    //
                    // I don't believe we can have a buffer overrun here. Put an assert
                    // to catch any such case.
                    //
                    FRS_ASSERT((ExpressionChars+1)*sizeof(USHORT)*2*2 >= (MATCHES_ARRAY_SIZE * sizeof(USHORT) + (ExpressionChars+1)*2*sizeof(USHORT)));
                    CopyMemory(AuxBuffer, CurrentMatches, MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    CopyMemory(AuxBuffer + (ExpressionChars+1)*2, PreviousMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == L'*') {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 3;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == '.') ) {

                        USHORT Offset;

                        for ( Offset = NameOffset;
                              Offset < Name->Length;
                              Offset += Length ) {

                            if (Name->Buffer[Offset / sizeof(WCHAR)] == L'.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != L'.') || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;
                    }
                }

                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(WCHAR) * 2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == DOS_QM ) {

                    if ( NameFinished || (NameChar == L'.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == L'.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == L'?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == (WCHAR)(IgnoreCase ?
                                        UpcaseTable[NameChar] : NameChar)) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) &&
                (PreviousDestCount < DestCount) ) {

                while (PreviousDestCount < DestCount) {

                    while ( PreviousMatches[SrcCount] <
                         CurrentMatches[PreviousDestCount] ) {

                        SrcCount += 1;
                    }

                    PreviousDestCount += 1;
                }
            }
        }

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) { FrsFree( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { FrsFree( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\staging.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    staging.c

Abstract:

    This module implements staging support routines for FRS

Author:

    Billy Fuller 26-Jun-1997

    David Orbits Aug-99:  Move utility funcs to util.c, fix func name prefixes.

Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>

#include <winbase.h>

#define STAGEING_IOSIZE  (64 * 1024)

//
// The following IDTable record fields get updated when an install override occurs.
//
ULONG IdtInstallOverrideFieldList[] = {FileIDx};
#define IdtInstallOverrideFieldCount  (sizeof(IdtInstallOverrideFieldList) / sizeof(ULONG))


#define STAGING_RESET_SE    (SE_OWNER_DEFAULTED | \
                             SE_GROUP_DEFAULTED | \
                             SE_DACL_DEFAULTED  | \
                             SE_DACL_AUTO_INHERITED | \
                             SE_SACL_AUTO_INHERITED | \
                             SE_SACL_DEFAULTED)


#define CB_NAMELESSHEADER    FIELD_OFFSET(WIN32_STREAM_ID, cStreamName)





DWORD
FrsDeleteById(
    IN PWCHAR                   VolumeName,
    IN PWCHAR                   Name,
    IN PVOLUME_MONITOR_ENTRY    pVme,
    IN  PVOID                   Id,
    IN  DWORD                   IdLen
    );

DWORD
FrsGetFileInternalInfoByHandle(
    IN HANDLE Handle,
    OUT PFILE_INTERNAL_INFORMATION  InternalFileInfo
    );

DWORD
FrsGetReparseTag(
    IN  HANDLE  Handle,
    OUT ULONG   *ReparseTag
    );

DWORD
FrsGetReparseData(
    IN  HANDLE  Handle,
    OUT PREPARSE_GUID_DATA_BUFFER   *ReparseData,
    OUT ULONG       *ReparseTag
    );

PWCHAR
FrsGetTrueFileNameByHandle(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    OUT PLONGLONG DirFileID
    );

DWORD
StuCreatePreInstallFile(
    IN PCHANGE_ORDER_ENTRY Coe
    );


extern PGEN_TABLE   CompressionTable;


DWORD
StuOpenFile(
    IN  PWCHAR   Name,
    IN  DWORD    Access,
    OUT PHANDLE  pHandle
    )
/*++
Routine Description:
    open a file

Arguments:
    Name
    Access
    pHandle

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "StuOpenFile:"

    DWORD WStatus = ERROR_SUCCESS;

    if (pHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *pHandle = INVALID_HANDLE_VALUE;

    //
    // Open the file
    //
    *pHandle = CreateFile(Name,
                        Access,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_SEQUENTIAL_SCAN |
                        FILE_FLAG_BACKUP_SEMANTICS,
                        NULL);

    if (!HANDLE_IS_VALID(*pHandle)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "Can't open file %ws;", Name, WStatus);
    }

    return WStatus;
}






DWORD
StuWriteFile(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    IN PVOID    Buf,
    IN DWORD    BytesToWrite
    )
/*++
Routine Description:
    Write data into a file

Arguments:
    Name
    Handle
    Buf
    BytesToWrite

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "StuWriteFile:"
    DWORD   BytesWritten;
    BOOL    DidWrite;
    DWORD   WStatus = ERROR_SUCCESS;

    if (!BytesToWrite) {
        return ERROR_SUCCESS;
    }

    //
    // Write the file's name into the file
    //
    DidWrite = WriteFile(Handle, Buf, BytesToWrite, &BytesWritten, NULL);

    //
    // Write error
    //
    if (!DidWrite || BytesWritten != BytesToWrite) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ Can't write file %ws;", Name, WStatus);
        return WStatus;
    }
    //
    // Done
    //
    return WStatus;
}


DWORD
StuReadFile(
    IN  PWCHAR  Name,
    IN  HANDLE  Handle,
    IN  PVOID   Buf,
    IN  DWORD   BytesToRead,
    OUT PDWORD  BytesRead
    )
/*++
Routine Description:
    Read data from a file

Arguments:
    Name -- File name for error message.
    Handle -- Open handle to file.
    Buf - Buffer for read data.
    BytesToRead  -- Number of bytes to read from the current file posn.
    BytesRead -- Actual number of bytes read.

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "StuReadFile:"

    BOOL    DidRead;
    DWORD   WStatus = ERROR_SUCCESS;


    DidRead = ReadFile(Handle, Buf, BytesToRead, BytesRead, NULL);

    //
    // Read error
    //
    if (!DidRead) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "Can't read file %ws;", Name, WStatus);
        return WStatus;
    }

    //
    // Done
    //
    return WStatus;
}




BOOL
StuReadBlockFile(
    IN  PWCHAR  Name,
    IN  HANDLE  Handle,
    IN  PVOID   Buf,
    IN  DWORD   BytesToRead
    )
/*++
Routine Description:
    Read a block of data from a file

Arguments:
    Name -- File name for error message.
    Handle -- Open handle to file.
    Buf - Buffer for read data.
    BytesToRead  -- Number of bytes to read from the current file posn.

Return Value:

    TRUE    - no problem
    FALSE   - couldn't read
--*/
{
#undef DEBSUB
#define DEBSUB  "StuReadBlockFile:"

    ULONG    BytesRead;
    DWORD    WStatus    = ERROR_SUCCESS;


    WStatus = StuReadFile(Name, Handle, Buf, BytesToRead, &BytesRead);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "Can't read file %ws;", Name, WStatus);
        return FALSE;
    }

    //
    // Read error
    //
    if (BytesRead != BytesToRead) {
        DPRINT1_WS(0, "Can't read file %ws;", Name, WStatus);
        return FALSE;
    }

    //
    // Done
    //
    return TRUE;
}



DWORD
StuCreateFile(
    IN  PWCHAR Name,
    OUT PHANDLE pHandle
    )
/*++
Routine Description:
    Create or overwrite a hidden, sequential file and open it with
    backup semantics and sharing disabled.

Arguments:
    Name
    pHandle Handle to return.

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "StuCreateFile:"

    DWORD  WStatus = ERROR_SUCCESS;

    //
    // Create the file
    //
    DPRINT1(4, "++ Creating %ws\n", Name);

    //
    // CREATE_ALWAYS - Always create the file.  If the file already
    //    exists, then it is overwritten.  The attributes for the new
    //    file are what is specified in the dwFlagsAndAttributes
    //    parameter or'd with FILE_ATTRIBUTE_ARCHIVE.  If the
    //    hTemplateFile is specified, then any extended attributes
    //    associated with that file are propogated to the new file.
    //

    *pHandle = INVALID_HANDLE_VALUE;

    *pHandle = CreateFile(Name,
                        GENERIC_READ | GENERIC_WRITE | DELETE | WRITE_DAC | WRITE_OWNER,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN |
                                                     FILE_ATTRIBUTE_HIDDEN,
                        NULL);

   if (!HANDLE_IS_VALID(*pHandle)) {
       WStatus = GetLastError();
       DPRINT1_WS(0, "++ Can't create file %ws;", Name, WStatus);
   }
   //
   // Restrict access on the staging files.
   //
   WStatus = FrsRestrictAccessToFileOrDirectory(Name, *pHandle,
                                                FALSE, // do not inherit acls from parent.
                                                FALSE);// do not push acls to children.
   if (!WIN_SUCCESS(WStatus)) {
       //
       // Can not restrict access to staging file.
       // Delete the staging file. We don't want to
       // create a staging file with access to everyone.
       //
       FrsDeleteByHandle(Name, *pHandle);
       FRS_CLOSE(*pHandle);
   }
   return WStatus;
}





PWCHAR
StuCreStgPath(
    IN PWCHAR   DirPath,
    IN GUID     *Guid,
    IN PWCHAR   Prefix
    )
/*++
Routine Description:
    Convert the change order guid into a staging path name (Replica->Stage\S_Guid).

Arguments:
    DirPath
    Guid
    Prefix

Return Value:
    Pathname for staging file
--*/
{
#undef DEBSUB
#define DEBSUB  "StuCreStgPath:"
    PWCHAR      StageName;
    PWCHAR      StagePath;

    //
    // Staging file name
    //
    StageName = FrsCreateGuidName(Guid, Prefix);

    //
    // Create the staging file path (StagingDirectory\S_Guid)
    //
    StagePath = FrsWcsPath(DirPath, StageName);

    //
    // Free the file name
    //
    FrsFree(StageName);

    return StagePath;
}



BOOL
StuCmpUsn(
    IN HANDLE   Handle,
    IN PCHANGE_ORDER_ENTRY Coe,
    IN USN     *TestUsn
    )
/*++
Routine Description:
    Check that the usn on the file identified by Handle matches
    the supplied USN.

Arguments:
    Handle
    Coe
    TestUsn   -- The Usn to test against.  Generally the caller will pass either
                 the ptr to the FileUsn if the CO has come from a downstream
                 partner as part of a fetch request, or the ptr to the JrnlUsn
                 if this is a local change order.

Return Value:
    TRUE    - Usn's match or the file or the usn don't exist
    FALSE   - Usn's don't match
--*/
{
#undef DEBSUB
#define DEBSUB  "StuCmpUsn:"
    ULONG   Status;
    ULONG   GStatus;
    USN     CurrentFileUsn;
    ULONGLONG  UnusedULongLong;
    ULONG_PTR UnusedFlags;
    PREPLICA   Replica;
    PCHANGE_ORDER_COMMAND Coc = &Coe->Cmd;

    if (!HANDLE_IS_VALID(Handle)) {
        return TRUE;
    }

    //
    // Directory creates must always propagate
    //
    if (CoCmdIsDirectory(Coc) &&
        (CO_NEW_FILE(GET_CO_LOCATION_CMD(*Coc, Command)))) {
            return TRUE;
    }

    //
    // If the Usn changed during the install then we don't want
    // to overwrite the current updated file with this data. The
    // new changes are "more recent". Discard the change order.
    //
    Status = FrsReadFileUsnData(Handle, &CurrentFileUsn);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    if (CurrentFileUsn == *TestUsn) {
        return TRUE;
    }
    //
    // Usn can't move backwards.
    //
    FRS_ASSERT(CurrentFileUsn > *TestUsn);

    CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Usn changed");
    //
    // It is possible that the USN change to the file is caused by our
    // own writing of the object ID on a new file.  To determine if this has
    // happened check the dampening cache for one of our OID close entries
    // using the USN we got from the file.  If the file USN is greater than
    // the value in the dampening cache then a more recent update has occurred
    // and we abort because another change order will be coming.
    //
    Replica = CO_REPLICA(Coe);
    FRS_ASSERT(Replica != NULL);

    GStatus = QHashLookup(Replica->pVme->FrsWriteFilter,
                          &CurrentFileUsn,
                          &UnusedULongLong,  // unused result
                          &UnusedFlags); // unused result

    if (GStatus == GHT_STATUS_SUCCESS) {
        DPRINT1(1, "++ USN Write filter cache hit on %08x %08x\n",
                PRINTQUAD(CurrentFileUsn));
        return TRUE;
    }

    //
    // There must be an update to the file that is after our last write (if any)
    // so it's nogo.
    //
    return FALSE;
}


DWORD
StuDeleteEmptyDirectory(
    IN HANDLE               DirectoryHandle,
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN DWORD                InWStatus
    )
/*++
Routine Description:
    Empty a directory of non-replicating files and dirs if this is
    an ERROR_DIR_NOT_EMPTY and this is a retry change order for a
    directory delete.

Arguments:
    DirectoryHandle - Handle of directory that could not be deleted
    Coe             - change order entry
    InWStatus       - Error from FrsDeleteByHandle()

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "StuDeleteEmptyDirectory:"
    DWORD   WStatus;
    PCHANGE_ORDER_COMMAND Coc = &Coe->Cmd;

    //
    // Empty the directory iff this is a retry change order for
    // a failed directory delete.
    //
    if (InWStatus != ERROR_DIR_NOT_EMPTY ||
        !CoCmdIsDirectory(Coc) ||
        !COC_FLAG_ON(Coc, CO_FLAG_RETRY)) {
        return InWStatus;
    }

    WStatus = FrsEnumerateDirectory(DirectoryHandle,
                                    Coc->FileName,
                                    0,
                                    ENUMERATE_DIRECTORY_FLAGS_NONE,
                                    NULL,
                                    FrsEnumerateDirectoryDeleteWorker);
    return WStatus;
}


ULONG
StuOpenDestinationFile(
    IN PCHANGE_ORDER_ENTRY Coe,
    ULONG                  FileAttributes,
    PHANDLE                ReadHandle,
    PHANDLE                WriteHandle
    )
/*++
Routine Description:

    Open the destination file.  The code below actually does two opens.  The
    first one is by ID and the second one is by filename.  This is because
    open by ID will not trigger any Directory Change Notify requests that
    have been posted to the file system by either local or remote (via SMB server)
    applications.  The IIS server uses change notify to tell it when an ASP
    page has changed so it can refresh/invalidate its cache.

    If the target file has read-only attribute set then we clear it here,
    do the open and reset the attributes back before returning.

    Note: The access modes and the sharing modes are carefully arranged to
    to make the two opens work without conflicting with each other and to
    make the second open with both read and write access.  This is needed because
    the API that sets the compression mode of the file needs both read and write
    access.

Arguments:
    Coe -- The change order entry struct.
    FileAttributes -- the file attributes from the staging file header.
    ReadHandle -- Returned read handle.   Caller must close even on error path.
    WriteHandle -- Returned write handle. Caller must close even on error path.

Return Value:

    Win32 status -

--*/
{
#undef DEBSUB
#define DEBSUB  "StuOpenDestinationFile:"

    DWORD           WStatus, WStatus1;
    BOOL            IsDir;
    NTSTATUS        NtStatus;

    ULONG           CreateDisposition;
    ULONG           OpenOptions;
    PWCHAR          Path = NULL;
    PWCHAR          FullPath = NULL;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;
    ULONG ReparseTag = 0;
    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_ATTRIBUTE_TAG_INFORMATION  FileInfo;


    IsDir = FileAttributes & FILE_ATTRIBUTE_DIRECTORY;

    CreateDisposition = FILE_OPEN;
    if (!IsDir) {
        //
        // In case this is an HSM file don't force the data to be read from
        // tape since the remote co is just going to overwrite all the data anyway.
        //
        // Setting CreateDisposition to FILE_OVERWRITE seems to cause a regression
        // Failure with an ACL Test where we set a deny all ACL and then the
        // open fails.  This is a mystery for now so don't do it.
        // In addtion overwrite fails if RO attribute is set on file.
        //
        //CreateDisposition = FILE_OVERWRITE;
    }

    OpenOptions = ID_OPTIONS;

OPEN_FILE_FOR_READ:

    WStatus = FrsForceOpenId( ReadHandle,
                              NULL,
                              Coe->NewReplica->pVme,
                              &Coe->FileReferenceNumber,
                              FILE_ID_LENGTH,
                              DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES,
                              OpenOptions,
                              FILE_SHARE_WRITE | FILE_SHARE_READ,
                              CreateDisposition);

    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(0, Coe, "FrsForceOpenId failed.", WStatus);
        //
        // Open by file ID fails with invalid parameter status if the file has
        // been deleted.  Fix up the error return so the caller can tell the
        // target file was not found.  This could be an update to an existing
        // file that has been deleted out from under us by the user.
        //
        if (WStatus == ERROR_INVALID_PARAMETER) {
            WStatus = ERROR_FILE_NOT_FOUND;
        }

        //
        // If we got a sharing violation on the target then set a flag in
        // the CO so caller will know.
        //
        if (WStatus == ERROR_SHARING_VIOLATION) {
            SET_COE_FLAG(Coe, COE_FLAG_TRY_OVRIDE_INSTALL);
        } else {
            CLEAR_COE_FLAG(Coe, COE_FLAG_TRY_OVRIDE_INSTALL);
        }

        goto CLEANUP;
    }


    //
    // Note to the unwary.  If this mark handle is placed after the
    // set attributes call then the source info field on the resulting
    // USN record does not set.  Mark handle must be done before the
    // first modification operation on the file.
    // Also, since the close of the Read handle may occur before the
    // write handle we mark the handle here to avoid loss of source info
    // when the write handle is later closed.  The Source Info field is
    // the intersection of the values used in all the open handles.
    //
    WStatus1 = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, *ReadHandle);
    DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", Coc->FileName, WStatus1);


    //
    // Read the actual attributes from the on disk file.
    // If there is a difference with respect to reparse points between the file
    // we want to install and the file on disk, we need to take the appropriate
    // action.
    //
    // Also get the file's attributes so we can turn off any access attributes
    // that prevent deletion and write.
    //
    ZeroMemory(&FileInfo, sizeof(FileInfo));
    NtStatus = NtQueryInformationFile(*ReadHandle,
                                      &IoStatusBlock,
                                      &FileInfo,
                                      sizeof(FileInfo),
                                      FileAttributeTagInformation);

    if (!NT_SUCCESS(NtStatus)) {
    WStatus = RtlNtStatusToDosError(NtStatus);
    CHANGE_ORDER_TRACEW(0, Coe, "NtQueryInformationFile failed.", WStatus);
    goto CLEANUP;
    }

    if(FileInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
    //  
    // Check the reparse tag 
    //

    if(ReparseTagReplicateFileData(FileInfo.ReparseTag)) {
        
OPEN_FILE_NOT_REPARSE_POINT:        
        //
        // In case this is a SIS or HSM file open the underlying file not the
        // reparse point.  For HSM, need to clear FILE_OPEN_NO_RECALL to write it.
        //
        OpenOptions = ID_OPTIONS & ~(FILE_OPEN_REPARSE_POINT |
                     FILE_OPEN_NO_RECALL);


        FRS_CLOSE(*ReadHandle);

        goto OPEN_FILE_FOR_READ;
    
    } else if(ReparseTagReplicateReparsePoint(FileInfo.ReparseTag) && 
          !(FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {

        //
        // The incoming CO is not a reparse point, but the file on disk
        // is. We need to remove the reparse point and then reopen the 
        // file without FILE_OPEN_REPARSE_POINT
        //

        WStatus = FrsDeleteReparsePoint(*ReadHandle);

        if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(0, Coe, "FrsDeleteReparsePoint failed.", WStatus);
        goto CLEANUP;
        }

        goto OPEN_FILE_NOT_REPARSE_POINT;
    }
    }



    if ((FileInfo.FileAttributes & NOREPL_ATTRIBUTES) != 0) {

    DPRINT1(4, "++ Resetting attributes for %ws\n", Coc->FileName);
    WStatus1 = FrsSetFileAttributes(Coc->FileName, *ReadHandle,
                    FileInfo.FileAttributes & ~NOREPL_ATTRIBUTES);
    DPRINT1_WS(4, "++ Can't reset attributes for %ws:",
           Coc->FileName, WStatus1);

    DPRINT1(4, "++ Attributes for %ws now allow replication\n", Coc->FileName);
    }

    //
    // The open by ID is done.  Now go get the full path name and open for
    // write access using the name.  This will trigger any posted directory
    // change notify requests in NTFS.  Save it in the change order entry for
    // tracking report.
    //
    Path = FrsGetFullPathByHandle(Coc->FileName, *ReadHandle);
    if (Path) {
        FullPath = FrsWcsCat(Coe->NewReplica->Volume, Path);
    }

    if (FullPath == NULL) {
        WStatus = ERROR_NOT_ENOUGH_MEMORY;
        DPRINT1_WS(0, "++ WARN - FrsGetFullPathByHandle(%ws)", Coc->FileName, WStatus);
        goto CLEANUP;
    }
    FrsFree(Coe->FullPathName);
    Coe->FullPathName = FullPath;

    //
    // The volume path above is in the form of \\.\E: which is necessary to
    // open a volume handle (( check this )).  But we need \\?\E: here to
    // allow long path names to work.  See CreateFile API description in SDK.
    //
    if (FullPath[2] == L'.') {
        FullPath[2] = L'?';
    }

    DPRINT1(4, "++ FrsGetFullPathByHandle(%ws -> \n", Coc->FileName);
    FrsPrintLongUStr(4, DEBSUB, __LINE__, FullPath);
    
    OpenOptions = OPEN_OPTIONS;


OPEN_FILE_FOR_WRITE:
    //
    // Open the file relative to the parent using the true filename. Use special access
    // for encrypted files.
    //
    if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
        WStatus = FrsOpenSourceFile2W(WriteHandle,
                                      FullPath,
                                      FILE_WRITE_ATTRIBUTES | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                      OpenOptions,
                                      FILE_SHARE_DELETE);
    } else {
        WStatus = FrsOpenSourceFile2W(WriteHandle,
                                      FullPath,
                                      RESTORE_ACCESS | ACCESS_SYSTEM_SECURITY,
                                      OpenOptions,
                                      FILE_SHARE_DELETE);
    }


    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ ERROR - FrsOpenSourceFile2W(%ws -> ", Coc->FileName, WStatus);
        FrsPrintLongUStr(4, DEBSUB, __LINE__, FullPath);

        //
        // Retry dir opens with lesser restrictive sharing mode. (Bug # 120508)
        // This is a case where the explorer has the dir open with Read Access
        // and share all.  If try to open with deny read then we get a sharing
        // violation with the Explorer's open for read handle.
        //
        if (IsDir) {
            DPRINT1(0, "++ Retrying %ws with less restrictive sharing mode.\n", Coc->FileName);

            //
            // Use special access for encrypted files.
            //
            if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                WStatus = FrsOpenSourceFile2W(WriteHandle,
                                              FullPath,
                                              FILE_WRITE_ATTRIBUTES | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                              OpenOptions,
                                              FILE_SHARE_DELETE | FILE_SHARE_READ);
            } else {
                WStatus = FrsOpenSourceFile2W(WriteHandle,
                                              FullPath,
                                              RESTORE_ACCESS | ACCESS_SYSTEM_SECURITY,
                                              OpenOptions,
                                              FILE_SHARE_DELETE | FILE_SHARE_READ);
            }
        } else
        if (WStatus == ERROR_SHARING_VIOLATION) {
            //
            // If we got a sharing violation on the target then set a flag in
            // the CO so caller will know.
            //
            SET_COE_FLAG(Coe, COE_FLAG_TRY_OVRIDE_INSTALL);
        } else {
            CLEAR_COE_FLAG(Coe, COE_FLAG_TRY_OVRIDE_INSTALL);
        }

        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACE(0, Coe, "FrsOpenSourceFile2W failed.");
            goto CLEANUP;
        }
    }

    //
    // Get the file's attributes and ReparseTag
    //
    ZeroMemory(&FileInfo, sizeof(FileInfo));
    NtStatus = NtQueryInformationFile(*WriteHandle,
                                      &IoStatusBlock,
                                      &FileInfo,
                                      sizeof(FileInfo),
                                      FileAttributeTagInformation);


    if (!NT_SUCCESS(NtStatus)) {
    WStatus = RtlNtStatusToDosError(NtStatus);
    CHANGE_ORDER_TRACEW(0, Coe, "NtQueryInformationFile failed.", WStatus);
    goto CLEANUP;
    }


    if(FileInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

    if(ReparseTagReplicateFileData(FileInfo.ReparseTag)) {
        //
        // In case this is a SIS or HSM file open the underlying file not the
        // reparse point.  For HSM, need to clear FILE_OPEN_NO_RECALL to write it.
        //
        OpenOptions = OpenOptions & ~(FILE_OPEN_REPARSE_POINT |
                     FILE_OPEN_NO_RECALL);

    
        FRS_CLOSE(*WriteHandle);

        goto OPEN_FILE_FOR_WRITE;

    }
    }


    //
    // Handles can be marked so that any usn records resulting from operations
    // on the handle will have the same "mark".  In this case, the mark is a bit
    // in the SourceInfo field of the usn record.  The mark tells NtFrs to ignore
    // the usn record during recovery because this was a NtFrs generated change.
    //
    WStatus = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, *WriteHandle);
    DPRINT1_WS(4, "++ FrsMarkHandle(%ws)", Coc->FileName, WStatus);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", Coc->FileName, WStatus);
        WStatus = ERROR_SUCCESS;
    }


CLEANUP:

    FrsFree(Path);

    //
    // FullPath is freed when the COE is freed.
    //

    return  WStatus;
}


ULONG
StuOpenDestinationFileForDelete(
    IN PCHANGE_ORDER_ENTRY Coe,
    ULONG                  FileAttributes,
    PHANDLE                ReadHandle,
    PHANDLE                WriteHandle
    )
/*++
Routine Description:

    Open the destination file.  The code below actually does two opens.  The
    first one is by ID and the second one is by filename.  This is because
    open by ID will not trigger any Directory Change Notify requests that
    have been posted to the file system by either local or remote (via SMB server)
    applications.  The IIS server uses change notify to tell it when an ASP
    page has changed so it can refresh/invalidate its cache.

    If the target file has read-only attribute set then we clear it here,
    do the open and reset the attributes back before returning.

    Note: The access modes and the sharing modes are carefully arranged to
    to make the two opens work without conflicting with each other and to
    make the second open with both read and write access.  This is needed because
    the API that sets the compression mode of the file needs both read and write
    access.

    This function behaves the same as StuOpenDestinationFile() except that the
    Write handle returned by this function has the delete access.

Arguments:
    Coe -- The change order entry struct.
    FileAttributes -- the file attributes from the staging file header.
    ReadHandle -- Returned read handle.   Caller must close even on error path.
    WriteHandle -- Returned write handle. Caller must close even on error path.

Return Value:

    Win32 status -

--*/
{
#undef DEBSUB
#define DEBSUB  "StuOpenDestinationFileForDelete:"

    DWORD           WStatus, WStatus1;
    BOOL            IsDir;
    NTSTATUS        NtStatus;

    ULONG           CreateDisposition;
    ULONG           OpenOptions;
    PWCHAR          Path = NULL;
    PWCHAR          FullPath = NULL;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;

    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_ATTRIBUTE_TAG_INFORMATION  FileInfo;
    ULONG ReparseTag;


    IsDir = FileAttributes & FILE_ATTRIBUTE_DIRECTORY;

    CreateDisposition = FILE_OPEN;
    if (!IsDir) {
        //
        // In case this is an HSM file don't force the data to be read from
        // tape since the remote co is just going to overwrite all the data anyway.
        //
        // Setting CreateDisposition to FILE_OVERWRITE seems to cause a regression
        // Failure with an ACL Test where we set a deny all ACL and then the
        // open fails.  This is a mystery for now so don't do it.
        // In addtion overwrite fails if RO attribute is set on file.
        //
        //CreateDisposition = FILE_OVERWRITE;
    }

    OpenOptions = ID_OPTIONS;

    WStatus = FrsForceOpenId( ReadHandle,
                          NULL,
                          Coe->NewReplica->pVme,
                          &Coe->FileReferenceNumber,
                          FILE_ID_LENGTH,
                          READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES,
                          OpenOptions,
                          FILE_SHARE_DELETE | FILE_SHARE_READ,
                          CreateDisposition);

    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(0, Coe, "FrsForceOpenId failed.", WStatus);
        //
        // Open by file ID fails with invalid parameter status if the file has
        // been deleted.  Fix up the error return so the caller can tell the
        // target file was not found.  This could be an update to an existing
        // file that has been deleted out from under us by the user.
        //
        if (WStatus == ERROR_INVALID_PARAMETER) {
            WStatus = ERROR_FILE_NOT_FOUND;
        }
        goto CLEANUP;
    }

    if(FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
        //
        // Check the reparse tag
        //

        WStatus = FrsGetReparseTag(*ReadHandle, &ReparseTag);

        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(0, Coe, "FrsGetReparseTag failed.", WStatus);
            goto CLEANUP;
        }

        if(ReparseTagReplicateFileData(ReparseTag)) {
            //
            // In case this is a SIS or HSM file open the underlying file not the
            // reparse point.  For HSM, need to clear FILE_OPEN_NO_RECALL to write it.
            //
            OpenOptions = ID_OPTIONS & ~(FILE_OPEN_REPARSE_POINT |
                                         FILE_OPEN_NO_RECALL);


            FRS_CLOSE(*ReadHandle);

            WStatus = FrsForceOpenId( ReadHandle,
                                      NULL,
                                      Coe->NewReplica->pVme,
                                      &Coe->FileReferenceNumber,
                                      FILE_ID_LENGTH,
                                      READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES,
                                      OpenOptions,
                                      FILE_SHARE_DELETE | FILE_SHARE_READ,
                                      CreateDisposition);

            if (!WIN_SUCCESS(WStatus)) {
                CHANGE_ORDER_TRACEW(0, Coe, "FrsForceOpenId failed.", WStatus);
                //
                // Open by file ID fails with invalid parameter status if the file has
                // been deleted.  Fix up the error return so the caller can tell the
                // target file was not found.  This could be an update to an existing
                // file that has been deleted out from under us by the user.
                //
                if (WStatus == ERROR_INVALID_PARAMETER) {
                    WStatus = ERROR_FILE_NOT_FOUND;
                }
                goto CLEANUP;
            }
        }
    }

    //
    // Note to the unwary.  If this mark handle is placed after the
    // set attributes call then the source info field on the resulting
    // USN record does not set.  Mark handle must be done before the
    // first modification operation on the file.
    // Also, since the close of the Read handle may occur before the
    // write handle we mark the handle here to avoid loss of source info
    // when the write handle is later closed.  The Source Info field is
    // the intersection of the values used in all the open handles.
    //
    WStatus1 = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, *ReadHandle);
    DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", Coc->FileName, WStatus1);

    //
    // Get the file's attributes and turn off any access attributes
    // that prevent deletion and write.
    //
    ZeroMemory(&FileInfo, sizeof(FileInfo));
    NtStatus = NtQueryInformationFile(*ReadHandle,
                                      &IoStatusBlock,
                                      &FileInfo,
                                      sizeof(FileInfo),
                                      FileAttributeTagInformation);


    if (NT_SUCCESS(NtStatus)) {
        if ((FileInfo.FileAttributes & NOREPL_ATTRIBUTES) != 0) {

            DPRINT1(4, "++ Resetting attributes for %ws\n", Coc->FileName);
            WStatus1 = FrsSetFileAttributes(Coc->FileName, *ReadHandle,
                                      FileInfo.FileAttributes & ~NOREPL_ATTRIBUTES);
            DPRINT1_WS(4, "++ Can't reset attributes for %ws:",
                       Coc->FileName, WStatus1);

            DPRINT1(4, "++ Attributes for %ws now allow replication\n", Coc->FileName);
        }
    }

    //
    // The open by ID is done.  Now go get the full path name and open for
    // write access using the name.  This will trigger any posted directory
    // change notify requests in NTFS.  Save it in the change order entry for
    // tracking report.
    //
    Path = FrsGetFullPathByHandle(Coc->FileName, *ReadHandle);
    if (Path) {
        FullPath = FrsWcsCat(Coe->NewReplica->Volume, Path);
    }

    if (FullPath == NULL) {
        WStatus = ERROR_NOT_ENOUGH_MEMORY;
        DPRINT1_WS(0, "++ WARN - FrsGetFullPathByHandle(%ws)", Coc->FileName, WStatus);
        goto CLEANUP;
    }
    FrsFree(Coe->FullPathName);
    Coe->FullPathName = FullPath;

    //
    // The volume path above is in the form of \\.\E: which is necessary to
    // open a volume handle (( check this )).  But we need \\?\E: here to
    // allow long path names to work.  See CreateFile API description in SDK.
    //
    if (FullPath[2] == L'.') {
        FullPath[2] = L'?';
    }

    DPRINT1(4, "++ FrsGetFullPathByHandle(%ws -> \n", Coc->FileName);
    FrsPrintLongUStr(4, DEBSUB, __LINE__, FullPath);

    if(ReparseTagReplicateFileData(ReparseTag)) {
        //
        // In case this is a SIS or HSM file open the underlying file not the
        // reparse point.  For HSM, need to clear FILE_OPEN_NO_RECALL to write it.
        // WriteHandleSharingMode should be a non-conflicting sharing mode established
        // above based on how the read handle was opened.
        //
        OpenOptions = OPEN_OPTIONS & ~(FILE_OPEN_REPARSE_POINT |
        //                             FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT);
                                       FILE_OPEN_NO_RECALL);
    } else {
        OpenOptions = OPEN_OPTIONS;
    }
    //
    // Open the file relative to the parent using the true filename. Use special access
    // for encrypted files.
    //
    if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
        WStatus = FrsOpenSourceFile2W(WriteHandle,
                                      FullPath,
                                      DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY,
                                      OpenOptions,
                                      SHARE_NONE);
    } else {
        WStatus = FrsOpenSourceFile2W(WriteHandle,
                                      FullPath,
                                      DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY,
                                      OpenOptions,
                                      SHARE_NONE);
    }
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ ERROR - FrsOpenSourceFile2W(%ws -> ", Coc->FileName, WStatus);
        FrsPrintLongUStr(4, DEBSUB, __LINE__, FullPath);

        //
        // Retry dir opens with lesser restrictive sharing mode. (Bug # 120508)
        // This is a case where the explorer has the dir open with Read Access
        // and share all.  If try to open with deny read then we get a sharing
        // violation with the Explorer's open for read handle.
        //
        if (IsDir) {
            DPRINT1(0, "++ Retrying %ws with less restrictive sharing mode.\n", Coc->FileName);

            //
            // Use special access for encrypted files.
            //
            if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                WStatus = FrsOpenSourceFile2W(WriteHandle,
                                              FullPath,
                                              DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY,
                                              OpenOptions,
                                              FILE_SHARE_READ);
            } else {
                WStatus = FrsOpenSourceFile2W(WriteHandle,
                                              FullPath,
                                              DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY,
                                              OpenOptions,
                                              FILE_SHARE_READ);
            }
        }

        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(0, Coe, "FrsOpenSourceFile2W failed.", WStatus);
            goto CLEANUP;
        }
    }

    //
    // Handles can be marked so that any usn records resulting from operations
    // on the handle will have the same "mark".  In this case, the mark is a bit
    // in the SourceInfo field of the usn record.  The mark tells NtFrs to ignore
    // the usn record during recovery because this was a NtFrs generated change.
    //
    WStatus = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, *WriteHandle);
    DPRINT1_WS(4, "++ FrsMarkHandle(%ws)", Coc->FileName, WStatus);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws)", Coc->FileName, WStatus);
        WStatus = ERROR_SUCCESS;
    }


CLEANUP:

    FrsFree(Path);
    //
    // FullPath get freed with the change order entry.
    //

    return  WStatus;
}


DWORD
StuDelete(
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++
Routine Description:
    Delete a file

Arguments:
    Coe

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB  "StuDelete:"
    DWORD   WStatus;
    HANDLE  ReadHandle  = INVALID_HANDLE_VALUE;
    HANDLE  DstHandle   = INVALID_HANDLE_VALUE;
    PCHANGE_ORDER_COMMAND Coc = &Coe->Cmd;

    //
    // Open the file
    //
/*
    WStatus = FrsOpenBaseNameForInstall(Coe, &Handle);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ Couldn't open file %ws for delete; ", Coc->FileName, WStatus);
        //
        // File has already been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            DPRINT1(4, "++ %ws is already deleted\n", Coc->FileName);
            WStatus = ERROR_SUCCESS;
        }

        goto out;
    }
*/

    WStatus = StuOpenDestinationFileForDelete(Coe, Coe->FileAttributes, &ReadHandle,  &DstHandle);
    FRS_CLOSE(ReadHandle);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ StuOpenDestinationFile failed to open %ws for delete; ", Coc->FileName, WStatus);
        //
        // File has already been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            DPRINT1(4, "++ %ws is already deleted\n", Coc->FileName);
            WStatus = ERROR_SUCCESS;
        }

        goto out;
    }

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    // Billyf: other code may depend on undampened deletes (parent filter entry?)
    // Historically, deletes were undampened because the close-with-usn-dampening
    // of a handle with delete-disposition set generates two usn records.
    // A CL usn record (w/o SourceInfo set, oddly enough) followed by
    // a DEL usn record (w/SourceInfo set). Code has been implemented
    // over the years to handle the undampened delete. So, don't mark
    // the handle because this code may be critical
    //
    // DAO - Start marking the handles for delete.  The journal code can decide
    // how it wants to handle a delete CO on a dir with USN_SOURCE_REPLICATION_MANAGEMENT
    // set in the sourceinfo field.
    //
    WStatus = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, DstHandle);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws); ", Coc->FileName, WStatus);
        WStatus = ERROR_SUCCESS;
    }

    //
    // Don't delete the file if the file has changed recently but go
    // ahead and retire the change order as if the delete had occured.
    // Since this is a remote CO the value in Coc->FileUsn actually came
    // from the IDTable when the change order was processed.
    //
    // Note: Problem with aborting the RmtCo delete if a local change to the file occurs.
    // If the local file change was an Archive bit or last access time updtate
    // then we want the delete to win.  If the local change was anything else
    // then we want to keep the file and let the local CO win.  Since we can't
    // tell what happened to the file until the Local Co is processed we will
    // let the rmt delete win.  This is only a "problem" during the small window
    // between Issuing the Remote Co and the point in time where the delete is
    // actually performed.  If the local update had been processed before the
    // this remote co delete then Reconcile would have rejected the remote CO.
    // This also means that when the local co update is processed and the
    // IDTable shows the file has been deleted then we reject the local CO update.
    //
#if 0
    if (!StuCmpUsn(DstHandle, Coe, &Coc->FileUsn)) {
        //
        // Returning fail status causes the CO to be aborted and the IDTable
        // is not updated.  If it was remote our partner is still notified.
        //
        WIN_SET_FAIL(WStatus);
        goto out;
    }
#endif
    //
    // Reset the attributes that prevent deletion
    //
    WStatus = FrsResetAttributesForReplication(Coc->FileName, DstHandle);
    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }
    //
    // Mark the file for delete
    //
    WStatus = FrsDeleteByHandle(Coc->FileName, DstHandle);
    if (!WIN_SUCCESS(WStatus)) {
        //
        // Empty the dir so we can delete it.  This will only happen for
        // retry COs so the caller must check that there are no valid
        // children before coming back here with a retry co.
        //
        StuDeleteEmptyDirectory(DstHandle, Coe, WStatus);
        WStatus = FrsDeleteByHandle(Coc->FileName, DstHandle);
    }

    CLEANUP1_WS(0, "++ Could not delete %ws;", Coc->FileName, WStatus, out);

out:


    if (WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACE(3, Coe, "Delete success");
        CLEAR_COE_FLAG(Coe, COE_FLAG_NEED_DELETE);
    } else {
        //
        // Set delete still needed flag in the CO.
        //
        CHANGE_ORDER_TRACEW(3, Coe, "Delete failed", WStatus);
        SET_COE_FLAG(Coe, COE_FLAG_NEED_DELETE);
    }

    //
    // If the file was marked for delete, this close will delete it
    //
#if 0
    //
    // WARN - Even though we marked the handle above we are not seeing the source
    // info data in the USN journal.  The following may be affecting it.
    // SP1:
    // In any case the following does not work because the Journal thread
    // can process the close record before this thread is able to update the
    // Write Filter.  The net effect is that we could end up processing
    // an install as a local CO update and re-replicate the file.
    //
    FrsCloseWithUsnDampening(Coc->FileName,
                             &DstHandle,
                             Coe->NewReplica->pVme->FrsWriteFilter,
                             &Coc->FileUsn);
#endif


    if (HANDLE_IS_VALID(DstHandle)) {
        // Not the USN of the close record but.. whatever.
        FrsReadFileUsnData(DstHandle, &Coc->FileUsn);
        FRS_CLOSE(DstHandle);
    }


    return WStatus;
}


DWORD
StuInstallRename(
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN BOOL                 ReplaceIfExists,
    IN BOOL                 Dampen
    )
/*++
Routine Description:
    Rename files. Replace the target file if ReplaceIfExists is TRUE.
    Don't bother dampening the rename if Dampen is FALSE.

Arguments:
    Coe
    ReplaceIfExists
    Dampen

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB  "StuInstallRename:"
    DWORD   WStatus;
    HANDLE  Handle          = INVALID_HANDLE_VALUE;
    HANDLE  DstHandle       = INVALID_HANDLE_VALUE;
    HANDLE  TargetHandle    = INVALID_HANDLE_VALUE;
    HANDLE  VolumeHandle;
    PCHANGE_ORDER_COMMAND Coc = &Coe->Cmd;

    VolumeHandle = Coe->NewReplica->pVme->VolumeHandle;

    //
    // Open the target directory
    //
    WStatus = FrsOpenSourceFileById(&TargetHandle,
                                    NULL,
                                    NULL,
                                    VolumeHandle,
                                    &Coc->NewParentGuid,
                                    OBJECT_ID_LENGTH,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "Parent dir open failed", WStatus);
        goto out;
    }

    //
    // Open the file using the FID, then get the name and re-open using the
    // name so we can do either a rename or a delete.
    //

    WStatus = FrsOpenBaseNameForInstall(Coe, &Handle);
    if (!WIN_SUCCESS(WStatus)) {
        //
        // File has been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            WStatus = ERROR_FILE_NOT_FOUND;
        }
        goto out;
    }

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    if (Dampen) {
        WStatus = FrsMarkHandle(VolumeHandle, Handle);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", Coc->FileName, WStatus);
            WStatus = ERROR_SUCCESS;
        }
    }

    //
    // ENSURE ACCESS TO THE DESTINATION FILE (IF IT EXISTS). Clear ReadOnly Attr.
    //
    // Open the destination file, if it exists
    //
    if (ReplaceIfExists) {
        WStatus = FrsCreateFileRelativeById(&DstHandle,
                                            VolumeHandle,
                                            &Coc->NewParentGuid,
                                            OBJECT_ID_LENGTH,
                                            0,
                                            Coc->FileName,
                                            Coc->FileNameLength,
                                            NULL,
                                            FILE_OPEN,
                                            READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS);
        if (WIN_SUCCESS(WStatus)) {
            //
            // The mark tells NtFrs to ignore the usn record during
            // recovery because this was a NtFrs generated change.
            //
            WStatus = FrsMarkHandle(VolumeHandle, DstHandle);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", Coc->FileName, WStatus);
                WStatus = ERROR_SUCCESS;
            }

            //
            // Ensure rename access
            //
            WStatus = FrsResetAttributesForReplication(Coc->FileName, DstHandle);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(0, "++ ERROR - FrsResetAttributesForReplication(%ws);", Coc->FileName, WStatus);
                FRS_CLOSE(DstHandle);
                goto out;
            }

            //
            // Close the dest so rename can be done.
            //
            FRS_CLOSE(DstHandle);
        }
    }

    //
    // RENAME
    //
    WStatus = FrsRenameByHandle(Coc->FileName,
                                Coc->FileNameLength,
                                Handle,
                                TargetHandle,
                                ReplaceIfExists);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "Rename failed", WStatus);
    }

out:

    FRS_CLOSE(Handle);
    FRS_CLOSE(TargetHandle);

    CHANGE_ORDER_TRACEW(3, Coe, (WIN_SUCCESS(WStatus)) ? "Rename Success" : "Rename Failed", WStatus);

    return WStatus;
}


DWORD
StuPreInstallRename(
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++

Routine Description:

    Rename file into its final directory from the pre-install dir.
    Don't bother dampening the rename if Dampen is FALSE.

    Note: If use of the standard pre-install name (NTFRS_<CO_GUID>) fails
    then Use the fid to find the file since it is possible (in the case of
    pre-install files) that the file name (based on CO Guid) when the
    pre-install file was first created was done by a different CO than this CO
    which is doing the final reaname.  E.g.  the first CO creates pre-install
    and then goes into the fetch retry state when the connection unjoins.  A
    later CO arrives for the same file but with a different CO Guid via a
    different connection.  Bug 367113 was a case like this.


Arguments:
    Coe

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "StuPreInstallRename:"

    DWORD   WStatus;
    PWCHAR  PreInstallName      = NULL;
    HANDLE  PreInstallHandle    = INVALID_HANDLE_VALUE;
    HANDLE  TargetHandle        = INVALID_HANDLE_VALUE;
    HANDLE  VolumeHandle;
    HANDLE  Handle              = INVALID_HANDLE_VALUE;
    PWCHAR  TrueFileName        = NULL;
    PCHANGE_ORDER_COMMAND Coc   = &Coe->Cmd;

    VolumeHandle = Coe->NewReplica->pVme->VolumeHandle;

    //
    // Open the target parent directory
    //
    WStatus = FrsOpenSourceFileById(&TargetHandle,
                                    NULL,
                                    NULL,
                                    VolumeHandle,
                                    &Coc->NewParentGuid,
                                    OBJECT_ID_LENGTH,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "Parent dir open failed", WStatus);
        //
        // Perhaps the parent is in retry and will show up soon. Or
        // perhaps a delete will show up for this co. In any case, retry.
        //
        WStatus = ERROR_RETRY;
        goto cleanup;
    }

    //
    // Open the preinstall file *relative* so that the rename will work
    //
    PreInstallName = FrsCreateGuidName(&Coc->ChangeOrderGuid, PRE_INSTALL_PREFIX);

RETRY:
    WStatus = FrsCreateFileRelativeById(&PreInstallHandle,
                                        Coe->NewReplica->PreInstallHandle,
                                        NULL,
                                        0,
                                        0,
                                        PreInstallName,
                                        (USHORT)(wcslen(PreInstallName) *
                                                 sizeof(WCHAR)),
                                        NULL,
                                        FILE_OPEN,
//                                        READ_ACCESS | DELETE);
                                        DELETE | SYNCHRONIZE);

    if (!WIN_SUCCESS(WStatus)) {

        if (WIN_NOT_FOUND(WStatus) && (TrueFileName == NULL)) {
            //
            // Could be a case of CO that did initial create had a different
            // CO Guid from the current one doing the rename.  Get the true
            // name of the file using the FID and try again.
            //
            //
            // Open the source file and get the current "True" File name.
            //
            WStatus = FrsOpenSourceFileById(&Handle,
                                            NULL,
                                            NULL,
                                            VolumeHandle,
                                            &Coe->FileReferenceNumber,
                                            FILE_ID_LENGTH,
//                                            READ_ACCESS,
                                            READ_ATTRIB_ACCESS,
                                            ID_OPTIONS,
                                            SHARE_ALL,
                                            FILE_OPEN);
            if (!WIN_SUCCESS(WStatus)) {
                CHANGE_ORDER_TRACEW(3, Coe, "File open failed", WStatus);
                goto cleanup;
            }

            TrueFileName = FrsGetTrueFileNameByHandle(PreInstallName, Handle, NULL);
            FRS_CLOSE(Handle);

            FrsFree(PreInstallName);
            PreInstallName = TrueFileName;

            if ((PreInstallName == NULL) || (wcslen(PreInstallName) == 0)) {
                CHANGE_ORDER_TRACE(3, Coe, "Failed to get base filename");
                WStatus = ERROR_FILE_NOT_FOUND;
                goto cleanup;
            }
            DPRINT1(4, "++ True file name is %ws\n", PreInstallName);

            CHANGE_ORDER_TRACE(3, Coe, "Retry open with TrueFileName");
            goto RETRY;
        }

        CHANGE_ORDER_TRACEW(3, Coe, "File open failed", WStatus);
        goto cleanup;
    }

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //

    //
    // Do not mark the handle when parents are reanimated. The
    // reanimation will trigger a local update CO that will
    // be sent out. This is not the based way to send out
    // reanimation COs but it is the simplest. 
    //
    if (!COE_FLAG_ON(Coe, COE_FLAG_GROUP_RAISE_DEAD_PARENT)) {
        WStatus = FrsMarkHandle(VolumeHandle, PreInstallHandle);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", PreInstallName, WStatus);
            WStatus = ERROR_SUCCESS;
        }
    }

    //
    // RENAME
    //
    WStatus = FrsRenameByHandle(Coc->FileName,
                                Coc->FileNameLength,
                                PreInstallHandle,
                                TargetHandle,
                                FALSE);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "Rename failed", WStatus);
        CLEANUP2_WS(0, "++ ERROR - Failed to rename pre-install file %ws for %ws",
                    PreInstallName, Coc->FileName, WStatus, cleanup);
    }

cleanup:

    //
    // close the renamed file and get the USN of the last write to the file.
    //
    if (HANDLE_IS_VALID(PreInstallHandle)) {
        // Not the USN of the close record but.. whatever.
        FrsReadFileUsnData(PreInstallHandle, &Coc->FileUsn);
        FRS_CLOSE(PreInstallHandle);
    }

    FRS_CLOSE(TargetHandle);

    CHANGE_ORDER_TRACE(3, Coe, (WIN_SUCCESS(WStatus)) ? "Rename Success" : "Rename Failed");

    FrsFree(PreInstallName);

    return WStatus;
}


DWORD
StuWriteEncryptedFileRaw(
    PBYTE pbData,
    PVOID pvCallbackContext,
    PULONG ulLength
    )

/*++
Routine Description:
    This is a Callback function passed to WriteEncryptedFileRaw(). EFS calls this
    to get a new chunk of data to write to the encrypted file. This function
    reads the staging file and returns the next chunk of raw encrypted data in
    the pbData parameter and also sets the length in the ulLength parameter.
    When there is no more data to return it returns ERROR_SUCCESS and sets ulLength
    to 0.
    The pvCallbackContext is a structure of the type FRS_ENCRYPT_DATA_CONTEXT. It has
    the handle and the name of the staging file from which the data is read.

Arguments:

    pbData : Buffer to return the next chunk of raw encrypted data in.
    pvCallbackContext : Structure of type FRS_ENCRYPT_DATA_CONTEXT which
        has the handle and the name of the staging file and the bytes of
        raw encrypted data.

    ulLength : Size of data requested.

Return Value:
    WStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "StuWriteEncryptedFileRaw:"

    PFRS_ENCRYPT_DATA_CONTEXT FrsEncryptDataContext = (PFRS_ENCRYPT_DATA_CONTEXT)pvCallbackContext;
    LARGE_INTEGER Length;
    DWORD WStatus = ERROR_SUCCESS;

    Length.LowPart = *ulLength;
    Length.HighPart = 0;

    if (Length.QuadPart > FrsEncryptDataContext->RawEncryptedBytes.QuadPart) {
        *ulLength = FrsEncryptDataContext->RawEncryptedBytes.LowPart;
    } else if (FrsEncryptDataContext->RawEncryptedBytes.LowPart == 0) {
        return ERROR_NO_DATA;
    }

    WStatus = StuReadFile(FrsEncryptDataContext->StagePath, FrsEncryptDataContext->StageHandle, pbData, *ulLength, ulLength);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ Error reading staging file(%ws).", FrsEncryptDataContext->StagePath, WStatus);
        return ERROR_NO_DATA;
    } else {

        DPRINT1(5, "RawEncryptedBytes = %d\n", FrsEncryptDataContext->RawEncryptedBytes.LowPart);

        Length.LowPart = *ulLength;

        FrsEncryptDataContext->RawEncryptedBytes.QuadPart -= Length.QuadPart;
    }
    return ERROR_SUCCESS;
}

DWORD
StuSetReparsePoint(
    IN HANDLE Destination,
    IN PREPARSE_GUID_DATA_BUFFER ReparseData
    )
/*++
Routine Description:

    Set the reparse point on a file.

Arguments:

    Destination -- open handle to the file on which to set the reparse point.
    ReparseData -- the data to set

Return Value:



--*/
{
#undef DEBSUB
#define DEBSUB  "StuSetReparsePoint:"

    DWORD BytesReturned = 0;
    DWORD WStatus = ERROR_SUCCESS;

    if(!DeviceIoControl(Destination,
                        FSCTL_SET_REPARSE_POINT,
                        ReparseData,
                        ReparseData->ReparseDataLength + REPARSE_GUID_DATA_BUFFER_HEADER_SIZE,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL
                        )) {

        //
        // We failed to set the reparse point.
        //

        WStatus = GetLastError();
        DPRINT1(0,"Error setting reparse point. WStatus = 0x%x\n", WStatus);

    }

    return WStatus;
}


ULONG
StuExecuteInstall(
    IN PCHANGE_ORDER_ENTRY Coe
    )
/*++
Routine Description:

    Install the staging file to the target file.  If this is a new file create
    then the target file is a temporary file in the Pre-install directory.
    Otherwise it is the actual target file so the FID remains unchanged.

Arguments:
    Coe -- The change order entry struct.

Return Value:

    Win32 status -
    ERROR_SUCCESS -  All installed or aborted. Don't retry.
    ERROR_GEN_FAILURE - Couldn't install bag it.
    ERROR_SHARING_VIOLATION - Couldn't open the target file.  retry later.
    ERROR_DISK_FULL - Couldn't allocate the target file.  retry later.
    ERROR_HANDLE_DISK_FULL - ?? retry later.

--*/
{
#undef DEBSUB
#define DEBSUB  "StuExecuteInstall:"


    LARGE_INTEGER                 LenOfPartialChunk;
    LONGLONG                      ConflictFid, ConflictParentFileID;
    FRS_ENCRYPT_DATA_CONTEXT      FrsEncryptDataContext;
    FILE_OBJECTID_BUFFER          FileObjID;
    FILE_INTERNAL_INFORMATION     FileInternalInfo;

    FILE_NETWORK_OPEN_INFORMATION FileInfo;

    FRS_COMPRESSED_CHUNK_HEADER   ChunkHeader;
    STAGE_HEADER                  StageHeaderMemory;

    DWORD           WStatus, WStatus1;
    ULONG           GStatus;
    DWORD           BytesRead;
    ULONG           Restored;
    ULONG           ToRestore;
    ULONG           High;
    ULONG           Low;
    ULONG           Flags;
    ULONG           FileAttributes;
    ULONG           ReplicaNumber;
    ULONG_PTR       ConflictReplicaNumber;
    BOOL            AttributeMismatch;
    BOOL            IsDir;
    BOOL            ExistingOid;
    BOOL            ConflictFileInTree;
    PVOID           RestoreContext  = NULL;
    PWCHAR          StagePath       = NULL;
    PSTAGE_HEADER   Header          = NULL;

    HANDLE          DstHandle       = INVALID_HANDLE_VALUE;
    HANDLE          ReadHandle      = INVALID_HANDLE_VALUE;
    HANDLE          StageHandle     = INVALID_HANDLE_VALUE;
    HANDLE          OverHandle      = INVALID_HANDLE_VALUE;
    HANDLE          IDConflictHandle= INVALID_HANDLE_VALUE;
    HANDLE          ConflictParentHandle = INVALID_HANDLE_VALUE;

    PUCHAR          RestoreBuf      = NULL;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;

    DWORD           DecompressStatus     = ERROR_SUCCESS;
    PUCHAR          DecompressedBuf      = NULL;
    DWORD           DecompressedBufLen   = 0;
    DWORD           DecompressedSize     = 0;
    DWORD           BytesProcessed       = 0;
    PVOID           DecompressContext    = NULL;

    PFRS_DECOMPRESS_BUFFER      pFrsDecompressBuffer;
    PFRS_FREE_DECOMPRESS_BUFFER pFrsFreeDecompressContext;

    //DWORD (*pFrsDecompressBuffer)(OUT DecompressedBuf, IN DecompressedBufLen, IN CompressedBuf, IN CompressedBufLen, OUT DecompressedSize, OUT BytesProcessed);
    //PVOID (*pFrsFreeDecompressContext)(IN pDecompressContext);

    REPARSE_GUID_DATA_BUFFER  ReparseDataHeader;
    PREPARSE_GUID_DATA_BUFFER ReparseDataBuffer = NULL;

    PVOID           pEncryptContext      = NULL;
    PVOID           pFrsEncryptContext   = NULL;
    HANDLE          DestHandle           = INVALID_HANDLE_VALUE;
    PWCHAR          Path                 = NULL;
    PWCHAR          DestFile             = NULL;
    ULONG           ReparseDataSize=0;
    BOOL            ReparseDataPresent = FALSE;
    PWCHAR          TrueFileName         = NULL;

    WCHAR           OverrideFileName[(sizeof(INSTALL_OVERRIDE_PREFIX) +
                                      sizeof(L"xxxxxxxx.tmp"))/sizeof(WCHAR) +
                                      8];

    CHAR            GuidStr[GUID_CHAR_LEN + 1];



#ifndef NOVVJOINHACK
Coe->NewReplica->NtFrsApi_HackCount++;
#endif NOVVJOINHACK

    //
    // Acquire shared access to the staging file, install it, and
    // then release access. If the install succeeded, mark the
    // file as "installed" so that the garbage collector can
    // delete the file if necessary.
    //
    Flags = 0;
    WStatus = StageAcquire(&Coc->ChangeOrderGuid, Coc->FileName, QUADZERO, &Flags, 0, NULL);
    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }

    //
    // Consider the case of dynamic membership change. A local create CO is sent to
    // the oubound partner. Not all outbound partners are availabel so the staging file
    // stay in the staging table. Later this member is removed and re-added to the
    // replica set. At this time it gets the same CO from its inbound partner. This
    // new member has a new originator guid so the CO is not dampened. This CO is
    // treated as  a remote CO but because it was already in the staging table it
    // gets picked up with the old flags. STAGE_FLAG_INSTALLED is set which caused
    // the following assert to hit. So make this assertion check only if the
    // originator guid from the CO is same as the current originator guid.
    //
    if (GUIDS_EQUAL(&Coe->NewReplica->ReplicaVersionGuid, &Coc->OriginatorGuid)) {
        FRS_ASSERT((Flags & STAGE_FLAG_INSTALLING) &&
                   (Flags & STAGE_FLAG_CREATED));
    }

    //
    // For the functions that don't return a win status
    //
    WIN_SET_FAIL(WStatus);

    //
    // Create the local staging name. Append a different prefix depending
    // on whether the staging file was sent compressed or uncompressed.
    //
    if (COC_FLAG_ON(Coc, CO_FLAG_COMPRESSED_STAGE)) {
        StagePath = StuCreStgPath(Coe->NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_FINAL_COMPRESSED_PREFIX);
    } else {
        StagePath = StuCreStgPath(Coe->NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_FINAL_PREFIX);
    }

    //
    // StagePath can be NULL is any of the above three parameters are NULL (prefix fix).
    //
    if (StagePath == NULL) {
        goto CLEANUP;
    }

    //
    // Open the stage file for shared, sequential reads
    //
    WStatus = StuOpenFile(StagePath, GENERIC_READ, &StageHandle);

    if (!HANDLE_IS_VALID(StageHandle) || !WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Read the header
    //
    Header = &StageHeaderMemory;
    ZeroMemory(Header, sizeof(STAGE_HEADER));

    WStatus = StuReadFile(StagePath, StageHandle, Header, sizeof(STAGE_HEADER), &BytesRead);
    CLEANUP1_WS(0, "Can't read file %ws;", StagePath, WStatus, CLEANUP);

    //
    // Don't understand this header format
    //
    if (Header->Major != NtFrsStageMajor) {
        DPRINT2(0, "Stage Header Major Version (%d) not supported.  Current Service Version is %d\n",
                Header->Major, NtFrsStageMajor);
        goto CLEANUP;
    }

    //
    // Minor version NTFRS_STAGE_MINOR_1 has change order extension in the header.
    //
    ClearFlag(Header->ChangeOrderCommand.Flags, CO_FLAG_COMPRESSED_STAGE);
    if (Header->Minor >= NTFRS_STAGE_MINOR_1) {
        //
        // The CO extension is provided.
        //
        Header->ChangeOrderCommand.Extension = NULL;//&Header->CocExt;
        //
        // NTFRS_STAGE_MINOR_2 has a compression guid in the stage file.
        //
        if (Header->Minor >= NTFRS_STAGE_MINOR_2) {
            //
            // Test the compression guid as one we understand.
            // A zero guid or Minor version < NTFRS_STAGE_MINOR_2 means uncompressed.
            //
            if (!IS_GUID_ZERO(&Header->CompressionGuid)) {
                GuidToStr(&Header->CompressionGuid, GuidStr);

                if (GTabIsEntryPresent(CompressionTable, &Header->CompressionGuid, NULL)) {
                    DPRINT1(4, "Compression guid valid: %s\n", GuidStr);
                    SetFlag(Header->ChangeOrderCommand.Flags, CO_FLAG_COMPRESSED_STAGE);
                } else {
                    DPRINT1(0, "WARNING - Compression guid invalid: %s\n", GuidStr);
                    goto CLEANUP;
                }
            } else {
                DPRINT(4, "Compression guid zero\n");
            }

            //
            // NTFRS_STAGE_MINOR_3 has reparse point data in the stage file.
            //
            if (Header->Minor >= NTFRS_STAGE_MINOR_3) {
                ReparseDataPresent = Header->ReparseDataPresent;

                //
                // Read the reparse data
                //
                if(ReparseDataPresent) {

                    //
                    // First read the header to find out how big the buffer needs to be.
                    //
                    WStatus = FrsSetFilePointer(StagePath,
                                                StageHandle,
                                                Header->ReparsePointDataHigh,
                                                Header->ReparsePointDataLow);
                    if (!WIN_SUCCESS(WStatus)) {
                        goto CLEANUP;
                    }

                    WStatus = StuReadFile(StagePath,
                                          StageHandle,
                                          &ReparseDataHeader,
                                          REPARSE_GUID_DATA_BUFFER_HEADER_SIZE,
                                          &BytesRead);

                    CLEANUP1_WS(0, "Can't read file %ws;", StagePath, WStatus, CLEANUP);

                    //
                    // If we didn't actually read the whole header there is a serious problem.
                    //
                    FRS_ASSERT(BytesRead == REPARSE_GUID_DATA_BUFFER_HEADER_SIZE);

                    ReparseDataSize = (ULONG)ReparseDataHeader.ReparseDataLength +
                                      (ULONG)REPARSE_GUID_DATA_BUFFER_HEADER_SIZE;

                    ReparseDataBuffer = FrsAlloc(ReparseDataSize);

                    //
                    // Now read the whole buffer
                    //
                    WStatus = FrsSetFilePointer(StagePath,
                                                StageHandle,
                                                Header->ReparsePointDataHigh,
                                                Header->ReparsePointDataLow);
                    if (!WIN_SUCCESS(WStatus)) {
                        goto CLEANUP;
                    }

                    WStatus = StuReadFile(StagePath,
                                          StageHandle,
                                          ReparseDataBuffer,
                                          ReparseDataSize,
                                          &BytesRead);

                    CLEANUP1_WS(0, "Can't read file %ws;", StagePath, WStatus, CLEANUP);

                    //
                    // If we didn't read the whole buffer there is a serious problem.
                    //
                    FRS_ASSERT(BytesRead == ReparseDataSize);
                }
            }
        }

    } else {
        //
        // This is an older stage file.  No CO Extension in the header.
        //
        Header->ChangeOrderCommand.Extension = NULL;
    }

    //
    // Get file attributes from stage header and open the destination file.
    //
    FileAttributes = Header->Attributes.FileAttributes;
    IsDir = FileAttributes & FILE_ATTRIBUTE_DIRECTORY;

    if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED ) {

        //
        // This is an encrypted file so first write all the encrypted data
        // by calling the RAW encrypt file APIS.
        //

        //
        // OpenEncryptedFileRaw API needs a path to open the file. Get the path
        // from the handle.
        //

    //
    // We currently (Sept 2002) do not supporty encrypted files, but 
    // when we add that support we need to correctly deal with the
    // case of a file being both encrypted AND a reparse point.
    // According to DGolds, this is a possibility.
    //

        WStatus = FrsForceOpenId(&DestHandle,
                                 NULL,
                                 Coe->NewReplica->pVme,
                                 &Coe->FileReferenceNumber,
                                 FILE_ID_LENGTH,
                                 READ_ATTRIB_ACCESS,
                                 ID_OPTIONS & ~(FILE_OPEN_REPARSE_POINT | FILE_OPEN_NO_RECALL),
                                 SHARE_ALL,
                                 FILE_OPEN);

        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        //
        // The open by ID is done.  Now go get the full path name.
        // Save it in the change order entry for tracking report.
        //
        Path = FrsGetFullPathByHandle(Coc->FileName, DestHandle);
        if (Path) {
            DestFile = FrsWcsCat(Coe->NewReplica->Volume, Path);
        }

        if (DestFile == NULL) {
            WStatus = ERROR_NOT_ENOUGH_MEMORY;
            CLEANUP1_WS(0, "++ WARN - FrsGetFullPathByHandle(%ws)", Coc->FileName, WStatus, CLEANUP);
        }

        FrsFree(Coe->FullPathName);
        Coe->FullPathName = DestFile;

        //
        // The volume path above is in the form of \\.\E: which is necessary to
        // open a volume handle (( check this )).  But we need \\?\E: here to
        // allow long path names to work.  See CreateFile API description in SDK.
        //
        if (DestFile[2] == L'.') {
            DestFile[2] = L'?';
        }

        DPRINT1(4, "++ FrsGetFullPathByHandle(%ws -> \n", Coc->FileName);
        FrsPrintLongUStr(4, DEBSUB, __LINE__, DestFile);

        if (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            WStatus = OpenEncryptedFileRaw(DestFile,
                                           CREATE_FOR_IMPORT |
                                           CREATE_FOR_DIR,
                                           &pEncryptContext);
        } else {
            WStatus = OpenEncryptedFileRaw(DestFile, CREATE_FOR_IMPORT,
                                           &pEncryptContext);
        }

        CLEANUP1_WS(0, "++ ERROR - OpenEncryptedFileRaw(%ws)", DestFile, WStatus, CLEANUP);

        //
        // Seek to the first byte of encrypted data in the stage file
        //
        if (ERROR_SUCCESS != FrsSetFilePointer(StagePath, StageHandle,
                               Header->EncryptedDataHigh, Header->EncryptedDataLow)) {
            goto CLEANUP;
        }

        FrsEncryptDataContext.StagePath = StagePath;
        FrsEncryptDataContext.StageHandle = StageHandle;
        FrsEncryptDataContext.RawEncryptedBytes.QuadPart = Header->EncryptedDataSize.QuadPart;

        WStatus = WriteEncryptedFileRaw(StuWriteEncryptedFileRaw, &FrsEncryptDataContext, pEncryptContext);

        CloseEncryptedFileRaw(pEncryptContext);

        //
        //  There are conditions e.g. a stream create by backupwrite,
        //  where we will lose the source info data on the USN Journal Close record.
        //  Until that problem is fixed we need to continue using the WriteFilter Table.
        //
        FrsCloseWithUsnDampening(Coc->FileName,
                                 &DestHandle,
                                 Coe->NewReplica->pVme->FrsWriteFilter,
                                 &Coc->FileUsn);

        CLEANUP1_WS(0, "++ ERROR - WriteEncryptedFileRaw(%ws)", DestFile, WStatus, CLEANUP);
    }





    WStatus = StuOpenDestinationFile(Coe, FileAttributes, &ReadHandle,  &DstHandle);
    CLEANUP_WS(1, "WARN - StuOpenDestinationFile failed.", WStatus, CLEANUP);

    //
    // Close the Read Handle now since it conflicts with backup write
    // creating or writing to a file sub-stream.
    //
    FRS_CLOSE(ReadHandle);

    if (!(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
        //
        // Truncate the file if not a directory. Can not truncate encrypted files.
        //
        if (!IsDir && !SetEndOfFile(DstHandle)) {
            DPRINT1_WS(0, "++ WARN - SetEndOfFile(%ws);", Coc->FileName, GetLastError());
        }

        //
        // Set compression mode and attributes
        // Seek to the first byte of data in the stage file
        // File can not be encrypted and compressed at the same time.
        //
        WStatus = FrsSetCompression(Coc->FileName, DstHandle, Header->Compression);
        CLEANUP1_WS(1, "ERROR - Failed to set compression for %ws.", Coc->FileName, WStatus, CLEANUP);

    }

    WStatus = FrsSetFileAttributes(Coc->FileName, DstHandle, FileAttributes & ~NOREPL_ATTRIBUTES);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    WStatus = FrsSetFilePointer(StagePath, StageHandle,
                                Header->DataHigh, Header->DataLow);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // if Compression is enabled. Get the routine to use to compress the data.
    //
    if (!DebugInfo.DisableCompression && COC_FLAG_ON(Coc, CO_FLAG_COMPRESSED_STAGE)) {

        WStatus = FrsGetDecompressionRoutine(Coc,
                                             Header,
                                             &pFrsDecompressBuffer,
                                             &pFrsFreeDecompressContext);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // No suitable decompression routine was found for this file.
            //
            DPRINT1(0, "ERROR - Decompression routine was not found for file %ws\n", Coc->FileName);
            FRS_ASSERT(!"Decompression routine was not found for file.");

        } else if (pFrsDecompressBuffer == NULL) {
            //
            // The function returned success but did not return a routine to decompress.
            // the file with. It means the file is already decompressed.
            //
            CLEAR_COC_FLAG(Coc, CO_FLAG_COMPRESSED_STAGE);
        }
    }


    //
    // Restore the stage file into the target install file.
    //
    RestoreBuf = FrsAlloc(STAGEING_IOSIZE);

    do {
#ifndef NOVVJOINHACK
Coe->NewReplica->NtFrsApi_HackCount++;
#endif NOVVJOINHACK
        //
        // read stage
        //
        WStatus = StuReadFile(StagePath, StageHandle, RestoreBuf, STAGEING_IOSIZE, &ToRestore);
        CLEANUP1_WS(0, "Can't read file %ws;", StagePath, WStatus, CLEANUP);

        if (ToRestore == 0) {
            break;
        }

        //
        // Increment the bytes of files installed counter
        //
        PM_INC_CTR_REPSET(Coe->NewReplica, FInstalledB, ToRestore);

        //
        // If Compression is enabled. Decompress data before installing.
        //
        if (!DebugInfo.DisableCompression && COC_FLAG_ON(Coc, CO_FLAG_COMPRESSED_STAGE)) {

            BytesProcessed = 0;
            DecompressContext = NULL;
            if (DecompressedBuf == NULL) {
                DecompressedBuf = FrsAlloc(STAGEING_IOSIZE);
                DecompressedBufLen = STAGEING_IOSIZE;
            }

            //
            // Loop over all the chunks of decompressed data.
            //
            do {
                DecompressStatus = (*pFrsDecompressBuffer)(DecompressedBuf,
                                                           DecompressedBufLen,
                                                           RestoreBuf,
                                                           ToRestore,
                                                           &DecompressedSize,
                                                           &BytesProcessed,
                                                           &DecompressContext);

                if (!WIN_SUCCESS(DecompressStatus) && DecompressStatus != ERROR_MORE_DATA) {
                    DPRINT1(0,"Error - Decompressing. WStatus = 0x%x\n", DecompressStatus);
                    WStatus = DecompressStatus;
                    goto CLEANUP;
                }

                if (DecompressedSize == 0) {
                    break;
                }

                if (!BackupWrite(DstHandle, DecompressedBuf, DecompressedSize, &Restored, FALSE, TRUE, &RestoreContext)) {

                    WStatus = GetLastError();
                    if (IsDir && WIN_ALREADY_EXISTS(WStatus)) {
                        DPRINT1(1, "++ ERROR - IGNORED for %ws; Directories and Alternate Data Streams!\n",
                                Coc->FileName);
                    }
                    //
                    // Uknown stream header or couldn't apply object id
                    //
                    if (WStatus == ERROR_INVALID_DATA ||
                        WStatus == ERROR_DUP_NAME     ||
                        (IsDir && WIN_ALREADY_EXISTS(WStatus))) {
                        //
                        // Seek to the next stream. Stop if there are none.
                        //
                        BackupSeek(DstHandle, -1, -1, &Low, &High, &RestoreContext);
                        if (Low == 0 && High == 0) {
                            break;
                        }
                    } else {
                        //
                        // Unknown error; abort
                        //
                        CHANGE_ORDER_TRACEW(0, Coe, "BackupWrite failed", WStatus);
                        goto CLEANUP;
                    }
                }

            } while (DecompressStatus == ERROR_MORE_DATA);

            //
            // Free the Decompress context if used.
            //
            if (DecompressContext != NULL) {
                pFrsFreeDecompressContext(&DecompressContext);
            }


            //
            // Rewind the file pointer so we can read the remaining chunck at the next read.
            //
            LenOfPartialChunk.QuadPart = ((LONG)BytesProcessed - (LONG)ToRestore);

            if (!SetFilePointerEx(StageHandle, LenOfPartialChunk, NULL, FILE_CURRENT)) {
                WStatus = GetLastError();
                CLEANUP1_WS(0, "++ Can't set file pointer for %ws;", StagePath, WStatus, CLEANUP);
            }

        } else {
            //
            // Stage file is not compressed.  Update the target install file.
            //
            if (!BackupWrite(DstHandle, RestoreBuf, ToRestore, &Restored, FALSE, TRUE, &RestoreContext)) {

                WStatus = GetLastError();
                if (IsDir && WIN_ALREADY_EXISTS(WStatus)) {
                    DPRINT1(1, "++ ERROR - IGNORED for %ws; Directories and Alternate Data Streams!\n",
                            Coc->FileName);
                }
                //
                // Uknown stream header or couldn't apply object id
                //
                if (WStatus == ERROR_INVALID_DATA ||
                    WStatus == ERROR_DUP_NAME     ||
                    (IsDir && WIN_ALREADY_EXISTS(WStatus))) {
                    //
                    // Seek to the next stream. Stop if there are none.
                    //
                    BackupSeek(DstHandle, -1, -1, &Low, &High, &RestoreContext);
                    if ((Low == 0) && (High == 0)) {
                        break;
                    }
                } else {
                    //
                    // Unknown error; abort
                    //
                    CHANGE_ORDER_TRACEW(0, Coe, "BackupWrite failed", WStatus);
                    goto CLEANUP;
                }
            }
        }
    } while (TRUE);   // End of data restore loop.


    //
    // Write the Reparse Point data if necessary
    //
    if(ReparseDataPresent) {
        WStatus = StuSetReparsePoint(DstHandle, ReparseDataBuffer);
        CLEANUP1_WS(0, "++ Can't set reparse point for %ws;", StagePath, WStatus, CLEANUP);
    }

    //
    // Ensure the correct object ID is on the file.
    //
    FRS_ASSERT(!memcmp(Header->FileObjId.ObjectId, &Coc->FileGuid, sizeof(GUID)));

    //
    // Clear the extended info for the link tracking tool on replicated files.
    // Old Ntraid Bug 195322.  The restore above wrote it to the file.
    //
    ZeroMemory(Header->FileObjId.ExtendedInfo,
               sizeof(Header->FileObjId.ExtendedInfo));

    WStatus = FrsGetOrSetFileObjectId(DstHandle, Coc->FileName, TRUE, &Header->FileObjId);

    if (WStatus == ERROR_DUP_NAME) {


        //
        // If we are doing an override install on an existing file then we
        // need to do the following:
        //
        // 1. If the file is inside the replica tree then rename it to
        //    a non-conflicting name with a special prefix so the journal code
        //    will not process it as a local CO.  Can't use Mark Handle here
        //    since other apps could have file open and prevent the setting
        //    of our SourceInfo flag.  If we can't rename the file then
        //    were stuck and the CO goes thru retry.  Mark the file Temp and Hidden.
        //
        // 2. Delete the OID from the conflicting file.
        //
        // 3. Mark the file for deletion.
        //


        //
        // Open the conflicting file with enough access to delete the OID.
        //
        WStatus = FrsOpenSourceFileById(&IDConflictHandle,
                                        NULL,
                                        NULL,
                                        Coe->NewReplica->pVme->VolumeHandle,
                                        &Header->FileObjId,
                                        OBJECT_ID_LENGTH,
                                            FILE_READ_ATTRIBUTES  |
                                            FILE_WRITE_ATTRIBUTES |
                                            SYNCHRONIZE,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);

        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(0, Coe, "Retry install -- can't open conflicting file", WStatus);
            WStatus = ERROR_RETRY;
            goto CLEANUP;
        }


        //FRS_DEBUG_TEST_POINT1("InstallOverride", 1, TRUE, WStatus = ERROR_RETRY; goto CLEANUP);

        //
        // Mark the handle for the journal.
        //
        WStatus = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, IDConflictHandle);

        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", Coc->FileName, WStatus);
            WStatus = ERROR_SUCCESS;
        }

        //
        // Get the File ID for the conflicting file.
        //
        WStatus = FrsGetFileInternalInfoByHandle(IDConflictHandle, &FileInternalInfo);
        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(0, Coe, "Retry install -- can't get FID on conflicting file", WStatus);
            WStatus = ERROR_RETRY;
            goto CLEANUP;
        }

        ConflictFid = FileInternalInfo.IndexNumber.QuadPart;

        //
        // Find the location of the conflicting file.
        // Check if this file is in a replica tree.  If it is outside the
        // tree we don't want to do the rename or delete.... BUT see HOWEVER
        // note below.
        //
        GStatus = QHashLookup(Coe->NewReplica->pVme->ParentFidTable,
                              &ConflictFid,
                              &ConflictParentFileID,
                              &ConflictReplicaNumber);

        ConflictFileInTree = (GStatus == GHT_STATUS_SUCCESS);

        if (ConflictFileInTree) {
            if ((ULONG)ConflictReplicaNumber != Coe->NewReplica->ReplicaNumber) {
                //
                // This is case 4 above.  Dump some info and keep going.
                //
                CHANGE_ORDER_TRACE(0, Coe, "conflicting file in another Replica");
                DPRINT1(0, "++ WARN: conflicting file in another Replica: Number %d\n", (ULONG)ConflictReplicaNumber);
                FRS_PRINT_TYPE(0, Coe);
            }
        }


        //
        // Delete the OID from the conflicting object.  This is done before attempting
        // to delete the conflicting object because the delete can succeed
        // (if we can open for delete) but if the file is already open
        // then the delete won't take effect until the last handle closes.
        // Meanwhile the OID is still "in-use" so the 2nd attempt to set
        // the OID still fails with ERROR_DUP_NAME.
        //
        WStatus = FrsDeleteFileObjectId(IDConflictHandle, Coc->FileName);
        CHANGE_ORDER_TRACEW(3, Coe, "del OID from blocked target", WStatus);

        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(0, Coe, "Retry install cuz of object id conflict on dir", WStatus);
            WStatus = ERROR_RETRY;
            goto CLEANUP;
        }


        if (IsDir) {

            //
            // The CO is for a dir. Delete the OID and then the dir.
            //
            // Dirs are not candidates for sharing violation override.
            // We could get here with the dup name conflict caused by the user
            // pre-staging the data on the volume or we could be doing a
            // non-authoritative restore (D2) and the file or dir is in the
            // pre-existing directory.  We could also get here via a name
            // morph conflict (DIR-FIL) where this code handles the local
            // deletion of the file that loses out to the rem co for the DIR.
            //

            FRS_CLOSE(IDConflictHandle);

            //
            // Note:  Need to make sure that the dir we are deleting is not in
            // in another replica set on the volume.  This is currently not a
            // problem since every new file that comes into a replica set gets
            // assigned a new object ID.  This breaks link tracking but was done
            // to deal with the case.  The delete will fail if the dir has
            // children but that's ok.
            //
            CHANGE_ORDER_TRACEW(3, Coe, "Deleting conflicting object", WStatus);

            WStatus = FrsDeleteById(Coe->NewReplica->Volume,
                                    Coc->FileName,
                                    Coe->NewReplica->pVme,
                                    &ConflictFid,
                                    FILE_ID_LENGTH);

            if (!WIN_SUCCESS(WStatus)) {
                CHANGE_ORDER_TRACEW(0, Coe, "conflict obj del failed", WStatus);
            }

        } else {

            //
            // CO is for a file and we may have hit a sharing violation
            // on the target so attempt an install override.
            //
            // This file could live in a number of places on the volume.
            //
            //      1. In the current replica tree
            //      2. In the pre-existing dir of this replica tree
            //      3. In the pre-install dir of this replica tree
            //      4. In another replica tree on the volume.
            //      5. Somewhere else on the volume in the case of media restore
            //
            // 1. If the file lives in the current replica tree then this
            //    is an install override situation.  Mark file for delete.
            // 2. Same as one.
            // 3. This is an odd situation because the Guid To Fid translation
            //    on the incoming remote CO should have got us to this file.
            //    It should normally not be an install override situation since
            //    no other apps should have access to a file in the pre-install dir.
            //    Delete the OID.
            // 4. This is unexpected because all new files entered into the
            //    replica tree get assigned a new OID to avoid the problem
            //    of a restore from backup that creates conflicting OIDs
            //    on a member hosting two replica trees on the same volume where
            //    the data was restored in both replica sets but on two other distinct
            //    members.  Mark the file for delete.
            // 5. Mark the file for delete.
            //
            //  HOWEVER - The previous code in this path (i.e. pre- RENAME INSTALL OVERRIDE)
            //  always deleted the conflicting file (or attempted too) when it got
            //  a duplicate name conflict on the object ID.  The assumption being that
            //  the customer had either pre-staged the data on the volume OR was
            //  doing a D2 with the data in the pre-existing dir.  So we will
            //  continue this behavior and just note in the log when the file
            //  appears to be in another replica tree on the volume.
            //


            //
            // Get current file attributes.
            //
            if (!FrsGetFileInfoByHandle(Coc->FileName, IDConflictHandle, &FileInfo)) {
                DPRINT1(4, "++ WARN - GetFileInfo failed (%ws)\n", Coc->FileName);
                FileInfo.FileAttributes = Header->Attributes.FileAttributes;
            }

            //
            // If the conflicting object is not a directory try to rename the
            // the object to a non-conflict name.  We want to take this path to
            // remove the conflicting name in case the conflict was caused by a
            // sharing violation on the target.  If the CO is on a retry we may
            // not know that a sharing violation caused the creating of a
            // pre-install file so we first free the name on the conflict file
            // just in case.  Even if the rename fails continue on to delete the
            // object ID from the conflicting object.
            //
            if (!BooleanFlagOn(FileInfo.FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {


                //FRS_DEBUG_TEST_POINT1("InstallOverride", 2, TRUE, WStatus = ERROR_RETRY; goto SKIP2);

                //
                // Get the File's true on-disk filename and the true parent FID.
                //
                TrueFileName = FrsGetTrueFileNameByHandle(Coc->FileName,
                                                          IDConflictHandle,
                                                          &ConflictParentFileID);

                if (TrueFileName == NULL) {
                    CHANGE_ORDER_TRACE(3, Coe, "Failed to get true file name");
                    WStatus = ERROR_RETRY;
                } else {

                    //
                    // Open parent dir of conflicting file for rename.
                    //
                    WStatus = FrsOpenSourceFileById(&ConflictParentHandle,
                                                    NULL,
                                                    NULL,
                                                    Coe->NewReplica->pVme->VolumeHandle,
                                                    &ConflictParentFileID,
                                                    FILE_ID_LENGTH,
                                                    READ_ATTRIB_ACCESS,
                                                    ID_OPTIONS,
                                                    SHARE_ALL,
                                                    FILE_OPEN);
                    if (!WIN_SUCCESS(WStatus)) {
                        CHANGE_ORDER_TRACEW(0, Coe, "Could not open conflicting file parent dir for override", WStatus);
                        WStatus = ERROR_RETRY;
                    } else {

                       //
                       // Open the conflicting file relative to the parent
                       // using the true filename so we can do the rename.
                       //
                       WStatus = FrsCreateFileRelativeById2(&OverHandle,
                                                            ConflictParentHandle,
                                                            NULL,
                                                            0,
                                                            FILE_ATTRIBUTE_NORMAL,
                                                            TrueFileName,
                                                            (USHORT)(wcslen(TrueFileName) * sizeof(WCHAR)),
                                                            NULL,
                                                            FILE_OPEN,
                                                            DELETE                    |
                                                                FILE_READ_ATTRIBUTES  |
                                                                FILE_WRITE_ATTRIBUTES |
                                                                SYNCHRONIZE,
                                                            SHARE_ALL);

                        if (!WIN_SUCCESS(WStatus)) {
                            CHANGE_ORDER_TRACEW(0, Coe, "Could not open conflicting file for override", WStatus);
                            WStatus = ERROR_RETRY;
                        } else {


                            //
                            // Mark the handle to set the SourceInfo field of the usn record.
                            // NOTE: This may be a no-op of some app has the target file open and
                            //       has performed at least one modify operation.  The first modify
                            //       operation on an open file establishes the SourceInfo state.
                            //
                            WStatus = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, OverHandle);
                            DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", Coc->FileName, WStatus);

                            //
                            // Rename the conflicting file to NTFRS_DELETED_FILE_xxxxxxxx.tmp
                            // Do this here in case the change order includes a name change such
                            // that we would not hit the name conflict in the final rename path.
                            // The journal code filters on the special name so it doesn't
                            // generate a change order.  On close records with the special
                            // name journal code deletes the file.
                            //
                            _snwprintf(OverrideFileName,
                                       ARRAY_SZ(OverrideFileName),
                                       INSTALL_OVERRIDE_PREFIX L"%08x.tmp",
                                       GetTickCount());

                            WStatus = FrsRenameByHandle(OverrideFileName,
                                                        wcslen(OverrideFileName)*sizeof(WCHAR),
                                                        OverHandle,
                                                        ConflictParentHandle,
                                                        FALSE);

                            if (!WIN_SUCCESS(WStatus)) {
                                DPRINT2_WS(1, "++ WARN - Failed to rename blocked target file %ws to %ws",
                                            Coc->FileName, OverrideFileName, WStatus);
                                WStatus = ERROR_RETRY;
                            } else {

                                //
                                // Mark it as hidden and temporary so we don't replicate it.
                                // Only applies to new file creates though.  So not fatal.
                                //
                                WStatus = FrsSetFileAttributes(OverrideFileName,
                                                               OverHandle,
                                                               FileInfo.FileAttributes  |
                                                               FILE_ATTRIBUTE_TEMPORARY |
                                                               FILE_ATTRIBUTE_HIDDEN);
                                DPRINT1_WS(4, "++ WARN - FrsSetFileAttributes(%ws);", OverrideFileName, WStatus);

                                DPRINT3(4, "++ Rename blocking target file %ws to %ws  FID: %08x %08x\n",
                                            TrueFileName, OverrideFileName, PRINTQUAD(ConflictFid));

                                FRS_CLOSE(ConflictParentHandle);

                            }
                        }
                    }
                }
//SKIP2:  ;
            }


            //
            // If we have done an override of an existing file then mark it
            // for deletion to prevent any further name change.
            //

            if (HANDLE_IS_VALID(OverHandle)) {

                //FRS_DEBUG_TEST_POINT1("InstallOverride", 3, TRUE, WStatus = ERROR_RETRY; goto SKIP3);

                WStatus = FrsDeleteByHandle(Coc->FileName, OverHandle);
//SKIP3:
                CHANGE_ORDER_TRACEW(3, Coe, "Deleting conflicting file", WStatus);
                if (WIN_SUCCESS(WStatus)) {
                    DPRINT2(4, "++ Success marking conflict file deleted:  %ws  FID: %08x %08x\n",
                                TrueFileName, PRINTQUAD(ConflictFid));
                }

                FRS_CLOSE(OverHandle);
            }

        }  // end of else on if (IsDir)

        //
        // Now retry setting the OID on the target file or dir.
        //

        //FRS_DEBUG_TEST_POINT1("InstallOverride", 4, TRUE, WStatus = ERROR_DUP_NAME; goto SKIP4);

        WStatus = FrsGetOrSetFileObjectId(DstHandle, Coc->FileName, TRUE, &Header->FileObjId);
//SKIP4:
        if (WStatus == ERROR_DUP_NAME) {
            CHANGE_ORDER_TRACEW(0, Coe, "Failed 2nd try to set OID on override file", WStatus);
            WStatus = ERROR_RETRY;
            goto CLEANUP;
        }

        //
        // Remove the old file's parent FID table entry.
        // Might not be there if didn't get to Install Rename state on the CO.
        //
        GStatus = QHashDelete(Coe->NewReplica->pVme->ParentFidTable, &ConflictFid);
        if (GStatus != GHT_STATUS_SUCCESS ) {
            DPRINT1(4, "++ WARNING: QHashDelete of ParentFidTable Entry, Gstatus: %d\n", GStatus);
        }


    }  // End if (WStatus == ERRROR_DUP_NAME)




    //
    // Problem with the code below is that the attempt to delete the
    // conflicting file will succeed (if we can open for delete) but if the
    // file is already open then the delete won't take effect until the last
    // handle closes.  Meanwhile the OID is still "in-use" so the 2nd
    // attempt (on the success path) to set the OID still fails with ERROR_DUP_NAME.
    // This is a non-retryable result which means the CO gets aborted.
    // Major bummer if we are doing a D2 and some of the old files are still
    // open.
    //
    // So delete the OID from the file and then let the final rename handle
    // the name collision issue.
    //
    // Note - probably need to handle name collision here since the new name
    // of the target file could be different so we would leave a turd file around.
    //


#if 0
    if (WStatus == ERROR_DUP_NAME) {
        //
        // Note:  Need to make sure that the file we are deleting is not in
        // in another replica set on the volume.  This is currently not a
        // problem since every new file that comes into a replica set gets
        // assigned a new object ID.  This breaks link tracking but was done
        // to deal with the case.
        //
        CHANGE_ORDER_TRACEW(0, Coe, "Deleting conflicting file", WStatus);
        WStatus = FrsDeleteById(Coe->NewReplica->Volume,
                                Coc->FileName,
                                Coe->NewReplica->pVme,
                                &Coc->FileGuid,
                                OBJECT_ID_LENGTH);
        if (!WIN_SUCCESS(WStatus)) {

            CHANGE_ORDER_TRACEW(0, Coe, "Stealing object id", WStatus);

            ZeroMemory(&FileObjID, sizeof(FileObjID));
            FrsUuidCreate((GUID *)(&FileObjID.ObjectId[0]));

            ExistingOid = FALSE;
            WStatus = ChgOrdHammerObjectId(Coc->FileName,
                                           &Coc->FileGuid,
                                           OBJECT_ID_LENGTH,
                                           Coe->NewReplica->pVme,
                                           TRUE,
                                           NULL,
                                           &FileObjID,
                                           &ExistingOid);
            if (WIN_SUCCESS(WStatus)) {
                WStatus = FrsGetOrSetFileObjectId(DstHandle,
                                                  Coc->FileName,
                                                  TRUE,
                                                  &Header->FileObjId);
            }
            if (!WIN_SUCCESS(WStatus)) {
                CHANGE_ORDER_TRACEW(0, Coe, "Retry install cuz of object id", WStatus);
                WStatus = ERROR_RETRY;
            }
        } else {
            CHANGE_ORDER_TRACEW(0, Coe, "Deleted conflicting file", WStatus);
            WStatus = FrsGetOrSetFileObjectId(DstHandle,
                                              Coc->FileName,
                                              TRUE,
                                              &Header->FileObjId);
            CHANGE_ORDER_TRACEW(4, Coe, "Set object id", WStatus);
        }
    }
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }
#endif

    //
    // If the staging file was created from a file that had the reparse
    // point attribute set then delete the reparse point.  Note this assumes
    // that backup write restored the reparse point info.  So keep going
    // on an error.
    //
    // If the staging file had the reparse data then we will replicate it
    // so don't delete it.
    //
    if (BooleanFlagOn(FileAttributes, FILE_ATTRIBUTE_REPARSE_POINT) &&
        !(Header->ReparseDataPresent)) {
        WStatus = FrsDeleteReparsePoint(DstHandle);
        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(0, Coe, "FrsDeleteReparsePoint", WStatus);
        }
    }

    //
    // Set times
    //
    WStatus = FrsSetFileTime(Coc->FileName,
                        DstHandle,
                        (PFILETIME)&Header->Attributes.CreationTime.QuadPart,
                        (PFILETIME)&Header->Attributes.LastAccessTime.QuadPart,
                        (PFILETIME)&Header->Attributes.LastWriteTime.QuadPart);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Set final attributes (which could make the file Read Only)
    // Clear the offline attrbute flag since we just wrote the file.
    //
    ClearFlag(FileAttributes, FILE_ATTRIBUTE_OFFLINE);
    WStatus = FrsSetFileAttributes(Coc->FileName, DstHandle, FileAttributes);
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    if (!(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
        //
        // Make sure all of the data is on disk. We don't want to lose
        // it across reboots
        // Can not flush encrypted files.
        //
        WStatus = FrsFlushFile(Coc->FileName, DstHandle);
        CLEANUP1_WS(0, "++ FlushFileBuffers failed on %ws;", Coc->FileName, WStatus, CLEANUP);
    }

    //
    // The Idtable record should reflect these attributes of the staging
    // file we generated.  These fields will be used to update the idtable
    // record when the change order is retired.
    //
    Coe->FileCreateTime.QuadPart = Header->Attributes.CreationTime.QuadPart;
    Coe->FileWriteTime.QuadPart  = Header->Attributes.LastWriteTime.QuadPart;

    AttributeMismatch = ((Coc->FileAttributes ^ FileAttributes) &
                              FILE_ATTRIBUTE_DIRECTORY) != 0;

    if (AttributeMismatch) {
        DPRINT2(0, "++ ERROR: Attribute mismatch between CO (%08x) and File (%08x)\n",
                Coc->FileAttributes, FileAttributes);
        FRS_ASSERT(!"Attribute mismatch between CO and File");
    }

    Coc->FileAttributes = FileAttributes;

    //
    // Return success
    //
    WStatus = ERROR_SUCCESS;


CLEANUP:
    //
    // Release resources in optimal order
    //
    // Leave the file lying around for a retry operation. We don't want
    // to assign a new fid by deleting and recreating the file -- that
    // would confuse the IDTable.
    //
    //
    // Free up the restore context before we close TmpHandle (just in case)
    //
    if (RestoreContext) {
        BackupWrite(DstHandle, NULL, 0, NULL, TRUE, TRUE, &RestoreContext);
    }
    //
    // Close both target file handles.
    //

    //
    // Handles can be marked so that any usn records resulting from operations
    // on the handle will have the same "mark".  In this case, the mark is a bit
    // in the SourceInfo field of the usn record.  The mark tells NtFrs to ignore
    // the usn record during recovery because this was a NtFrs generated change.
    //
    //WStatus1 = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, ReadHandle);
    //DPRINT1_WS(4, "++ FrsMarkHandle(%ws)", Coc->FileName, WStatus1);

    FRS_CLOSE(ReadHandle);

    if (HANDLE_IS_VALID(DstHandle)) {
        //
        // Truncate a partial install
        //
        if (!WIN_SUCCESS(WStatus)) {
            if (!IsDir && !(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                ULONG  SizeHigh = 0, SizeLow = 0;

                WStatus1 = FrsSetFilePointer(Coc->FileName, DstHandle, SizeHigh, SizeLow);

                if (!WIN_SUCCESS(WStatus1)) {
                    CHANGE_ORDER_TRACEW(0, Coe, "WARN SetFilePointer", WStatus1);
                } else {
                    WStatus1 = FrsSetEndOfFile(Coc->FileName, DstHandle);
                    if (!WIN_SUCCESS(WStatus1)) {
                        CHANGE_ORDER_TRACEW(0, Coe, "WARN SetEndOfFile", WStatus1);
                    }
                }
            }
        }


        //
        //  There are conditions e.g. a stream create by backupwrite,
        //  where we will lose the source info data on the USN Journal Close record.
        //  Until that problem is fixed we need to continue using the WriteFilter Table.
        //
        FrsCloseWithUsnDampening(Coc->FileName,
                                 &DstHandle,
                                 Coe->NewReplica->pVme->FrsWriteFilter,
                                 &Coc->FileUsn);

#if 0
        //  Put this back when the FrsCloseWithUsnDampening() is no longer needed.
        //
        // Capture the current USN on the file.
        // Not the USN of the close record but.. whatever.
        //
        if (HANDLE_IS_VALID(DstHandle)) {
            FrsReadFileUsnData(DstHandle, &Coc->FileUsn);
        }

        //
        // Handles can be marked so that any usn records resulting from operations
        // on the handle will have the same "mark".  In this case, the mark is a bit
        // in the SourceInfo field of the usn record.  The mark tells NtFrs to ignore
        // the usn record during recovery because this was a NtFrs generated change.
        //
        //WStatus1 = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, DstHandle);
        //DPRINT1_WS(4, "++ FrsMarkHandle(%ws)", Coc->FileName, WStatus1);

        FRS_CLOSE(DstHandle);
#endif
    }

    FRS_CLOSE(StageHandle);
    FRS_CLOSE(OverHandle);
    FRS_CLOSE(IDConflictHandle);
    FRS_CLOSE(ConflictParentHandle);

    //
    // Free the buffers in descending order by size and release our lock on the
    // staging file.
    //
    FrsFree(RestoreBuf);
    FrsFree(StagePath);
    FrsFree(DecompressedBuf);
    FrsFree(TrueFileName);

    //
    // Used to install encrypted files.
    // DestFile is freed with the change order entry.
    //
    FrsFree(Path);
    FRS_CLOSE(DestHandle);


    //
    // Free the reparse buffer
    //
    FrsFree(ReparseDataBuffer);

    if (WIN_SUCCESS(WStatus)) {
        StageRelease(&Coc->ChangeOrderGuid, Coc->FileName, STAGE_FLAG_INSTALLED, NULL, NULL, NULL);
    } else {
        StageRelease(&Coc->ChangeOrderGuid, Coc->FileName, 0, NULL, NULL, NULL);
    }

    if (WStatus == ERROR_DISK_FULL) {
        if ((Coe->NewReplica->Volume != NULL) && (wcslen(Coe->NewReplica->Volume) >= wcslen(L"\\\\.\\D:"))) {
            //
            // If we are able to get the volume in the form
            // \\.\D: then use the volume in the event log so
            // that we don't print more than one event log
            // message per volume. If we can't get the
            // volume then we print the path.
            //
            EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, &(Coe->NewReplica->Volume[4]));
        } else {
            EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, Coe->NewReplica->Root);
        }
    }

    //
    // DONE
    //
    return WStatus;
}


DWORD
StuInstallStage(
    IN PCHANGE_ORDER_ENTRY Coe
    )
/*++
Routine Description:
    Install a staging file by parsing the change order and performing
    the necessary operations. Not all installations require a staging
    file (e.g., deletes).

Arguments:
    Coe

Return Value:
    Win32 status:
    ERROR_SUCCESS    - All installed
    ERROR_GEN_FAILURE   - Partially installed; temp files are deleted
    ERROR_SHARING_VIOLATION - Couldn't open the target file.  retry later.
    ERROR_DISK_FULL - Couldn't allocate the target file.  retry later.
    ERROR_HANDLE_DISK_FULL - ?? retry later.

--*/
{
#undef DEBSUB
#define DEBSUB  "StuInstallStage:"


    DWORD                   WStatus = ERROR_SUCCESS;
    ULONG                   GStatus;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;

    PCOMMAND_PACKET         Cmd;
    PTABLE_CTX              IDTableCtx;
    PIDTABLE_RECORD         IDTableRec;
    PREPLICA                Replica;

    //
    // Perform the indicated location operation (with or without staging)
    //
    if (CO_FLAG_ON(Coe, CO_FLAG_LOCATION_CMD)) {
        switch (GET_CO_LOCATION_CMD(*Coc, Command)) {
            case CO_LOCATION_CREATE:
            case CO_LOCATION_MOVEIN:
            case CO_LOCATION_MOVEIN2:
                //
                // Install the entire staging file
                //
                return (StuExecuteInstall(Coe));

            case CO_LOCATION_DELETE:
            case CO_LOCATION_MOVEOUT:
                //
                // Just delete the existing file
                //
                return StuDelete(Coe);

            case CO_LOCATION_MOVERS:
            case CO_LOCATION_MOVEDIR:
                //
                // First, rename the file
                //
                WStatus = StuInstallRename(Coe, TRUE, TRUE);
                if (WIN_SUCCESS(WStatus)) {
                    //
                    // Second, check for a staging file with content changes
                    //
                    if (CO_FLAG_ON(Coe, CO_FLAG_CONTENT_CMD) &&
                        Coc->ContentCmd & CO_CONTENT_NEED_STAGE) {
                        WStatus = StuExecuteInstall(Coe);
                    }
                }
                return WStatus;

            default:
                break;
        }
    }
    //
    // Perform the indicated content operation (with or without staging)
    //
    if (WIN_SUCCESS(WStatus) && CO_FLAG_ON(Coe, CO_FLAG_CONTENT_CMD)) {
        //
        // Rename within the same directory
        //
        if (Coc->ContentCmd & USN_REASON_RENAME_NEW_NAME) {
            WStatus = StuInstallRename(Coe, TRUE, TRUE);
        }
        //
        // Data or attribute changes to an existing file
        //
        if (WIN_SUCCESS(WStatus) &&
            Coc->ContentCmd & CO_CONTENT_NEED_STAGE) {

            WStatus = StuExecuteInstall(Coe);

            Replica = CO_REPLICA(Coe);
            FRS_ASSERT(Replica != NULL);

            //
            // if eligible for Override Install and not a dir and
            // not already using a pre-install file and
            // Install Override is enabled then
            // create one now and retry the install.
            //
            if (COE_FLAG_ON(Coe, COE_FLAG_TRY_OVRIDE_INSTALL)  &&
                 (DebugInfo.EnableInstallOverride ||
                  REPLICA_OPTION_ENABLED(Replica, FRS_RSO_FLAGS_ENABLE_INSTALL_OVERRIDE)) &&
                 !COE_FLAG_ON(Coe, COE_FLAG_PREINSTALL_CRE)    &&
                 !CoCmdIsDirectory(Coc) ){


                //
                // Create the replacement file.  The new File ID is
                // set in Coe->FileReferenceNumber;
                //

                //FRS_DEBUG_TEST_POINT1("InstallOverride", 5, TRUE, return ERROR_RETRY);

                WStatus = StuCreatePreInstallFile(Coe);



                if (WIN_SUCCESS(WStatus)) {

                    //
                    // Update the IDTable record with the new File ID so if we
                    // crash the restarted CO will connect to the new file.
                    //
                    IDTableCtx = &Coe->RtCtx->IDTable;
                    FRS_ASSERT(IS_ID_TABLE(IDTableCtx));

                    IDTableRec = IDTableCtx->pDataRecord;
                    FRS_ASSERT(IDTableRec != NULL);

                    //
                    // New data value to update in IDTable record.
                    //
                    IDTableRec->FileID = Coe->FileReferenceNumber;

                    Cmd = DbsPrepFieldUpdateCmdPkt(
                              NULL,                         //  CmdPkt,
                              Replica,                      //  Replica,
                              IDTableCtx,                   //  TableCtx,
                              NULL,                         //  CallContext,
                              IDTablex,                     //  TableType,
                              GuidIndexx,                   //  IndexType,
                              &IDTableRec->FileGuid,        //  KeyValue,
                              OBJECT_ID_LENGTH,             //  KeyValueLength,
                              IdtInstallOverrideFieldCount, //  FieldCount,
                              IdtInstallOverrideFieldList); //  FieldIDList

                    if (Cmd != NULL) {

                        FrsSetCompletionRoutine(Cmd, FrsCompleteKeepPkt, NULL);
                        //
                        // The call is synchronous.
                        //
                        FrsSubmitCommandServerAndWait(&DBServiceCmdServer, Cmd, INFINITE);
                        FrsFreeCommand(Cmd, NULL);
                    }

                    //
                    // Now retry the install with the new file.
                    //
                    WStatus = StuExecuteInstall(Coe);
                }
            }
        }
    }

    //
    // Informational packet; ignore
    //
    return WStatus;
}


DWORD
StuCreatePreInstallFile(
    IN PCHANGE_ORDER_ENTRY Coe
    )
/*++
Routine Description:
    Create the pre-install file in the pre-install directory and return that fid.
    The pre-install file is renamed to the target file and dir, and stamped
    with the appropriate object id once the staging file has been
    installed.

    The parent fids were set to the correct values prior to this call.

Arguments:
    Coe

Return Value:
    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "StuCreatePreInstallFile:"

    LARGE_INTEGER             FileSize;
    FILE_INTERNAL_INFORMATION FileInternalInfo;
    PCHANGE_ORDER_COMMAND     Coc = &Coe->Cmd;
    DWORD                     WStatus;
    HANDLE                    Handle;
    PWCHAR                    Name = NULL;
    ULONG                     CreateAttributes;


    //
    // Create the file name of the pre-install file. It will match the
    // name of the staging file since it uses the same heuristic (the
    // change order guid)
    //
    Name = FrsCreateGuidName(&Coc->ChangeOrderGuid, PRE_INSTALL_PREFIX);

    //
    // Create the temporary (hidden) file in the Pre-install directory.
    // Clear the readonly flag for // now cuz if we come thru here again during
    // recovery we will get access denied when we try to open the pre-exisitng
    // file.  The Install code will set the readonly flag on the file later if necc.
    //
    CreateAttributes = Coc->FileAttributes | FILE_ATTRIBUTE_HIDDEN;
    ClearFlag(CreateAttributes , FILE_ATTRIBUTE_READONLY);

    FileSize.QuadPart = Coc->FileSize;
    if (Coc->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

        ClearFlag(CreateAttributes , FILE_ATTRIBUTE_ENCRYPTED);
        ClearFlag(CreateAttributes , FILE_ATTRIBUTE_HIDDEN);
    }

    WStatus = FrsCreateFileRelativeById(&Handle,
                                        Coe->NewReplica->PreInstallHandle,
                                        NULL,
                                        0,
                                        CreateAttributes,
                                        Name,
                                        (USHORT)(wcslen(Name) * sizeof(WCHAR)),
                                        &FileSize,
                                        FILE_OPEN_IF,
                                        RESTORE_ACCESS);

    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(0, Coe, "Preinstall file create failed", WStatus);
        goto CLEANUP;
    }

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    WStatus = FrsMarkHandle(Coe->NewReplica->pVme->VolumeHandle, Handle);
    DPRINT1_WS(4, "++ FrsMarkHandle(%ws);", Coc->FileName, WStatus);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(0, Coe, "WARN - FrsMarkHandle", WStatus);
        WStatus = ERROR_SUCCESS;
    }

    //
    // Get the file's fid and update the change order.
    //
    WStatus = FrsGetFileInternalInfoByHandle(Handle, &FileInternalInfo);

    //
    // Return the close USN in the change order so we can detect a change
    // if it gets modified locally before we complete the fetch and install.
    //
    // Not the USN of the close record but.. whatever.
    FrsReadFileUsnData(Handle, &Coc->FileUsn);
    FRS_CLOSE(Handle);

    //
    // Update the change order.
    //
    if (WIN_SUCCESS(WStatus)) {
        //
        // If we have passed the fetch retry state then the FID on the
        // target file better not be changing.  There was a bug where the
        // pre-install file was inadvertantly deleted while the change order
        // was in the IBCO_INSTALL_REN_RETRY state and we never noticed
        // because the above is happy to recreate it.  So we end up with an
        // empty file.
        //
        if (!CO_STATE_IS_LE(Coe, IBCO_INSTALL_INITIATED) &&
            !CO_STATE_IS(Coe, IBCO_INSTALL_WAIT) &&
            !CO_STATE_IS(Coe, IBCO_INSTALL_RETRY)) {
            FRS_ASSERT((LONGLONG)Coe->FileReferenceNumber ==
                                 FileInternalInfo.IndexNumber.QuadPart);
        }

        Coe->FileReferenceNumber = FileInternalInfo.IndexNumber.QuadPart;
        //
        // Remember we created a pre-install file for this CO.
        //
        SET_COE_FLAG(Coe, COE_FLAG_PREINSTALL_CRE);
    }

CLEANUP:
    FrsFree(Name);

    if (WStatus == ERROR_DISK_FULL) {
        if ((Coe->NewReplica->Volume != NULL) && (wcslen(Coe->NewReplica->Volume) >= wcslen(L"\\\\.\\D:"))) {
            //
            // If we are able to get the volume in the form
            // \\.\D: then use the volume in the event log so
            // that we don't print more than one event log
            // message per volume. If we can't get the
            // volume then we print the path.
            //
            EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, &(Coe->NewReplica->Volume[4]));
        } else {
            EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, Coe->NewReplica->Root);
        }
    }

    return WStatus;
}


VOID
StuCockOpLock(
    IN  PCHANGE_ORDER_COMMAND  Coc,
    IN  PREPLICA               Replica,
    OUT PHANDLE                Handle,
    OUT OVERLAPPED             *OverLap
    )
/*++
Routine Description:
    If possible, cock an oplock for the source file. Otherwise,
    allow the staging operation to continue if it can acquire
    read access to the file.

Arguments:
    Coc
    Handle
    OverLap

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StuCockOpLock:"

    //
    // Can't oplock a directory
    //
    if ((Replica == NULL) || CoCmdIsDirectory(Coc)) {
        *Handle = INVALID_HANDLE_VALUE;
        OverLap->hEvent = NULL;
        return;
    }

    //
    // Reserve an oplock filter
    //
    FrsOpenSourceFileById(Handle,
                          NULL,
                          OverLap,
                          Replica->pVme->VolumeHandle,
                          &Coc->FileGuid,
                          sizeof(GUID),
                          OPLOCK_ACCESS,
                          ID_OPLOCK_OPTIONS,
                          SHARE_ALL,
                          FILE_OPEN);
}


VOID
StuStagingDumpBackup(
    IN PWCHAR   Name,
    IN PUCHAR   BackupBuf,
    IN DWORD    NumBackupDataBytes
    )
/*++
Routine Description:
    Dump the first buffer of a backup formatted file

Arguments:

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StuStagingDumpBackup:"
    WIN32_STREAM_ID *Id;
    WIN32_STREAM_ID *FirstId;
    WIN32_STREAM_ID *LastId;
    DWORD           Total;
    DWORD           *pWord;
    DWORD           i;
    DWORD           j;
    DWORD           NWords;
    CHAR            Line[256];

    Id = (WIN32_STREAM_ID *)BackupBuf;
    FirstId = Id;
    LastId = (WIN32_STREAM_ID *)(BackupBuf + NumBackupDataBytes);

    while (Id < LastId) {
        if (Id != FirstId) {
            DPRINT(0, "\n");
        }
        DPRINT2(0, "%ws StreamId   : %08x\n", Name, Id->dwStreamId);
        DPRINT2(0, "%ws StreamAttrs: %08x\n", Name, Id->dwStreamAttributes);
        DPRINT2(0, "%ws Size       : %08x\n", Name, Id->Size.LowPart);
        DPRINT2(0, "%ws NameSize   : %08x\n", Name, Id->dwStreamNameSize);
        if (Id->dwStreamNameSize) {
            DPRINT2(0, "%ws Name       : %ws\n", Name, Id->cStreamName);
        }
        pWord = (PVOID)((PCHAR)&Id->cStreamName[0] + Id->dwStreamNameSize);
        NWords = Id->Size.LowPart / sizeof(DWORD);
        sprintf(Line, "%ws ", Name);

        for (Total = j = i = 0; i < NWords; ++i, ++pWord) {
            Total += *pWord;
            sprintf(&Line[strlen(Line)], "%08x ", *pWord);
            if (++j == 2) {
                DPRINT1(0, "%s\n", Line);
                sprintf(Line, "%ws ", Name);
                j = 0;
            }
        }

        if (j) {
            DPRINT1(0, "%s\n", Line);
        }

        DPRINT2(0, "%ws Total %08x\n", Name, Total);
        Id = (PVOID)((PCHAR)Id +
                     (((PCHAR)&Id->cStreamName[0] - (PCHAR)Id) +
                     Id->Size.QuadPart + Id->dwStreamNameSize));
    }
}


DWORD
StuReadEncryptedFileRaw(
    PBYTE pbData,
    PVOID pvCallbackContext,
    ULONG ulLength
    )

/*++
Routine Description:
    This is a Callback function passed to ReadEncryptedFileRaw(). EFS calls this
    function with a new chunk of raw encrypted data everytime until all the
    data is read. This function writes the raw data into the staging file.

    The pvCallbackContext is a structure of the type FRS_ENCRYPT_DATA_CONTEXT. It has
    the handle and the name of the staging file from which the data is read.

Arguments:

    pbData : Buffer containing chunk of raw encrypted data.
    pvCallbackContext : Structure of type FRS_ENCRYPT_DATA_CONTEXT which
        has the handle and the name of the staging file and the bytes of
        raw encrypted data.

    ulLength : Size of data.

Return Value:
    WStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "StuReadEncryptedFileRaw:"

    DWORD WStatus = ERROR_SUCCESS;
    PFRS_ENCRYPT_DATA_CONTEXT FrsEncryptDataContext = (PFRS_ENCRYPT_DATA_CONTEXT)pvCallbackContext;

    WStatus = StuWriteFile(FrsEncryptDataContext->StagePath, FrsEncryptDataContext->StageHandle, pbData, ulLength);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ Error writing raw encrypted data to staging file(%ws),", FrsEncryptDataContext->StagePath,WStatus);
    } else {
        DPRINT1(5, "RawEncryptedBytes = %d\n", FrsEncryptDataContext->RawEncryptedBytes);
        FrsEncryptDataContext->RawEncryptedBytes.QuadPart += ulLength;
    }
    return ERROR_SUCCESS;
}


DWORD
StuGenerateStage(
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PCHANGE_ORDER_ENTRY      Coe,
    IN BOOL                     FromPreExisting,
    IN MD5_CTX                  *Md5,
    OUT PULONGLONG              SizeOfFileGenerated,
    OUT GUID                    *CompressionFormatUsed
    )
/*++
Routine Description:
    Create and populate the staging file.  Currently there are four cases
    of interest based on the state of Coe, FromPreExisting and Md5:

    Coe   FromPreExisting  Md5

    NULL     FALSE       NULL         Fetch on demand or outlog trimmed so stage file must be regenerated
    NULL     FALSE       non-null     Fetch of pre-existing file by downstream partner.  check MD5.
    NULL     TRUE        NULL         doesn't occur
    NULL     TRUE        non-null     doesn't occur
    non-NULL FALSE       NULL         Generate stage file for local CO
    non-NULL FALSE       non-null     doesn't occur -- MD5 only generated for preexisting files
    non-NULL TRUE        NULL         doesn't occur -- MD5 always generated for preexisting files.
    non-NULL TRUE        non-null     Generate stage file from pre-existing file and send MD5 upstream to check for a match.

Arguments:

    Coc -- ptr to change order command.  NULL on incoming fetch requests from downstream partners.

    Coe -- ptr to change order entry.  NULL when regenerating the staging file for fetch

    FromPreExisting -- TRUE if this staging file is being generated from a
                       preexisting file.

    Md5 -- Generate the MD5 digest for the caller and return it if Non-NULL

    SizeOfFileGenerated - Valid when the size generated is needed, otherwise NULL

    CompressionFormatUsed - Returned guid for the compression format used to construct
                            this staging file.

Return Value:
    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB  "StuGenerateStage:"


    OVERLAPPED      OpLockOverLap;
    LONGLONG        StreamBytesLeft;
    LONG            BuffBytesLeft;


    DWORD           WStatus;
    DWORD           NumBackupDataBytes;
    PREPARSE_GUID_DATA_BUFFER ReparseDataBuffer = NULL;
    ULONG           ReparseTag = 0;
    ULONG           OpenOptions;
    WORD            OldSecurityControl;
    WORD            NewSecurityControl;
    WORD            *SecurityControl;
    BOOL            FirstBuffer       = TRUE;
    BOOL            Regenerating      = FALSE;
    BOOL            SkipCo            = FALSE;
    BOOL            FirstOpen         = TRUE;
    BOOL            StartOfStream     = TRUE;
    BOOL            ReparseDataPresent = FALSE;

    PWCHAR          StagePath         = NULL;
    PWCHAR          FinalPath         = NULL;
    PUCHAR          BackupBuf         = NULL;
    PVOID           BackupContext     = NULL;

    HANDLE          OpLockEvent       = NULL;
    HANDLE          SrcHandle         = INVALID_HANDLE_VALUE;
    HANDLE          StageHandle       = INVALID_HANDLE_VALUE;
    HANDLE          OpLockHandle      = INVALID_HANDLE_VALUE;

    WIN32_STREAM_ID *StreamId;

    PSTAGE_HEADER   Header          = NULL;
    STAGE_HEADER    StageHeaderMemory;
    ULONG           Length;
    PREPLICA        NewReplica = NULL;
    WCHAR           TStr[100];

    PUCHAR          CompressedBuf     = NULL;
    DWORD           CompressedBufLen  = 0;
    DWORD           ActCompressedSize = 0;

    PFRS_COMPRESS_BUFFER pFrsCompressBuffer;
    //DWORD           (*pFrsCompressBuffer)(IN UnCompressedBuf, IN UnCompressedBufLen, CompressedBuf, CompressedBufLen, CompressedSize);

    LARGE_INTEGER   DataOffset;
    PVOID           pEncryptContext   = NULL;
    FRS_ENCRYPT_DATA_CONTEXT FrsEncryptDataContext;
    PWCHAR          SrcFile           = NULL;
    PWCHAR          Path              = NULL;
    PWCHAR          Volume            = NULL;

    //
    // Initialize the SizeOfFileGenerated to zero
    //
    if (SizeOfFileGenerated != NULL) {
        *SizeOfFileGenerated = 0;
    }

    //
    // Generate a checksum on the staging file + attributes
    //
    if (Md5) {
        ZeroMemory(Md5, sizeof(*Md5));
        MD5Init(Md5);
    }

    //
    // The staging file may be deleted if the outbound partner takes too long
    // to fetch it.  When this happened, the staging file is regenerated.  The
    // inbound change order entry may be deleted by now and the outbound
    // change order entries are not kept in core.  Hence, the Coe is null when
    // called for re-generation.
    //
    Regenerating = (Coe == NULL);

    //
    // Some basic info changes aren't worth replicating
    //
    if (!Regenerating && !FromPreExisting) {
        WStatus = ChgOrdSkipBasicInfoChange(Coe, &SkipCo);
        if (!WIN_SUCCESS(WStatus)) {
            goto out;
        }
    }

    //
    // Changes aren't important, skip the change order
    //
    if (SkipCo) {
        WIN_SET_FAIL(WStatus);
        goto out;
    }


    OpenOptions = ID_OPTIONS;

RETRY_OPEN:

    //
    // Open the original file for shared, sequential reads and
    // snapshot the file's "state" for comparison with the "state"
    // following the copy.
    //
    NewReplica = ReplicaIdToAddr(Coc->NewReplicaNum);
    if (NewReplica == NULL) {
        WIN_SET_FAIL(WStatus);
        goto out;
    }

    //
    // The header is located at the beginning of the newly created staging file
    //
    // Fill in the header with info from the src file
    //      Compression type
    //      Change order
    //      Attributes
    //
    Header = &StageHeaderMemory;
    ZeroMemory(Header, sizeof(STAGE_HEADER));

    //
    // Special case opens for encrypted files.
    //

    //
    // The following opens hang if a oplock exists on a file.
    // Take the oplock after the open.
    //

    if ((Coc != NULL) ? (Coc->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) :
        ((Coe != NULL) ? (Coe->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) : FALSE)) {

        WStatus = FrsOpenSourceFileById(&SrcHandle,
                                        &Header->Attributes,
                                        NULL,
                                        NewReplica->pVme->VolumeHandle,
                                        &Coc->FileGuid,
                                        sizeof(GUID),
                                        STANDARD_RIGHTS_READ       |
                                            FILE_READ_ATTRIBUTES   |
                                            ACCESS_SYSTEM_SECURITY |
                                            SYNCHRONIZE,
                                        OpenOptions,
                                        SHARE_ALL,
                                        FILE_OPEN);
    } else {
        WStatus = FrsOpenSourceFileById(&SrcHandle,
                                        &Header->Attributes,
                                        NULL,
                                        NewReplica->pVme->VolumeHandle,
                                        &Coc->FileGuid,
                                        sizeof(GUID),
                                        READ_ACCESS | ACCESS_SYSTEM_SECURITY,
                                        OpenOptions,
                                        SHARE_ALL,
                                        FILE_OPEN);
    }

    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }

    //
    // Go ahead and attempt a staging operation even if we can't
    // cock an oplock for the source file.
    //
    StuCockOpLock(Coc, NewReplica, &OpLockHandle, &OpLockOverLap);
    OpLockEvent = OpLockOverLap.hEvent;

    //
    // Keep the file size as accurate as possible for both the reconcile
    // checks when deciding whether to accept the change order and for the
    // code that uses the file size to pre-allocate space.  The file size is
    // updated in the idtable entry when the change order is retired.
    //
    if (!FromPreExisting) {
        Coc->FileSize = Header->Attributes.AllocationSize.QuadPart;
    }

    //
    // Get the object id buffer
    //
    WStatus = FrsGetObjectId(SrcHandle, &Header->FileObjId);
    if (!WIN_SUCCESS(WStatus)) {
        WIN_SET_RETRY(WStatus);
        goto out;
    }

    //
    // What type of reparse is it?
    //
    if (FirstOpen &&
        (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
        FirstOpen = FALSE;

        if (!FromPreExisting) {
            //
            //
            Coc->FileAttributes |= FILE_ATTRIBUTE_REPARSE_POINT;
        }

        //
        // reparse tag
        //
        WStatus = FrsGetReparseData(SrcHandle, &ReparseDataBuffer, &ReparseTag);
        if (!WIN_SUCCESS(WStatus)) {
            goto out;
        }

        if(ReparseDataBuffer) {
            ReparseDataPresent = TRUE;
        }


    //
    // We only go back to open the file and read the file data
    // if we are replicating the file data (but not the reparse point.)
    //
    if(ReparseTagReplicateFileData(ReparseTag)) {
        //
        // We hit a file with a known reparse tag type.
        // Close and reopen the file without the FILE_OPEN_REPARSE_POINT
        // option so backup read will get the underlying data.
        //
        FRS_CLOSE(SrcHandle);
        FRS_CLOSE(OpLockHandle);
        FRS_CLOSE(OpLockEvent);

            ClearFlag(OpenOptions, FILE_OPEN_REPARSE_POINT);
            goto RETRY_OPEN;
        }
    }


    //
    // Assume retriable errors for the boolean functions
    //
    WIN_SET_RETRY(WStatus);

    //
    // Default to no compression if we can't get the compression state
    //
    if (ERROR_SUCCESS != FrsGetCompression(Coc->FileName, SrcHandle, &Header->Compression)) {
        Header->Compression = COMPRESSION_FORMAT_NONE;
    }

    if (!DebugInfo.DisableCompression) {
        //
        // Compression is enabled. Get the routine to use to compress the data.
        //
        WStatus = FrsGetCompressionRoutine(Coc->FileName, SrcHandle, &pFrsCompressBuffer, &Header->CompressionGuid);

        if (WIN_SUCCESS(WStatus) && pFrsCompressBuffer != NULL ) {

            SetFlag(Coc->Flags, CO_FLAG_COMPRESSED_STAGE);
        } else {
            //
            // No suitable compression routine was found for this file.
            // Send this file uncompressed.
            //
            pFrsCompressBuffer = NULL;
        }
    }

    //
    // Return the guid of the compression for that was used to compress this staging
    // file. This will be stored in the STAGE_ENTRY structure for this staging
    // file so it can be accessed easily when a downstream partner is fetching
    // the file. Note if the above call does not return a valid guid then then it
    // should leave it as all zeroes. All zeroes means that the file is uncompressed.
    //
    COPY_GUID(CompressionFormatUsed, &Header->CompressionGuid);

    //
    // insert the change order command.
    //
    CopyMemory(&Header->ChangeOrderCommand, Coc, sizeof(CHANGE_ORDER_COMMAND));
    Header->ChangeOrderCommand.Extension = NULL;
    //
    // Change Order Command Extension.
    //   1. Generating stage file for local co then Coc's chksum is stale.
    //   2. Generating stage file for ondemand fetch, Coc chksum may not match
    //   3. Generating stage file for MD5 check request then Coc chksum may not match.
    //   4. Generating stage file for pre-existing file then Coc doesn't have chksum.
    // At this point the Coc checksum is not useful so leave extension ptr Null
    // and maybe update the Extension in the header once it is computed.
    //
    //if (Coc->Extension != NULL) {
    //    CopyMemory(&Header->CocExt, Coc->Extension, sizeof(CHANGE_ORDER_RECORD_EXTENSION));
        bugbug("if MD5 generated below is different from what is in CO then we need to rewrite the extension");
    //}

    //
    // The backup data begins at the first 32 byte boundary following the header
    //

    Header->ReparseDataPresent = ReparseDataPresent;
    Header->ReparsePointDataLow =  QuadQuadAlignSize(sizeof(STAGE_HEADER));

    if(ReparseDataPresent) {
        Header->DataLow = QuadQuadAlignSize(Header->ReparsePointDataLow + ReparseDataBuffer->ReparseDataLength + REPARSE_GUID_DATA_BUFFER_HEADER_SIZE);
    } else {
        Header->DataLow = QuadQuadAlignSize(sizeof(STAGE_HEADER));
    }

    //
    // Major/minor
    //
    Header->Major = NtFrsStageMajor;
    Header->Minor = NtFrsStageMinor;

    //
    // Create the local staging name. Use a different prefix for compressed files.
    //
    if (!DebugInfo.DisableCompression && pFrsCompressBuffer != NULL) {
        StagePath = StuCreStgPath(NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_GENERATE_COMPRESSED_PREFIX);
    } else {
        StagePath = StuCreStgPath(NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_GENERATE_PREFIX);
    }

    //
    // The file USN in the CO is not valid until the file is installed but the
    // CO can be propagated as soon as the Staging File is Fetched from our
    // inbound partner.  If this CO went out before the install completed then
    // we assume the data is still current and send it on.
    //
    if (Regenerating) {
        //
        // This is a fetch request from an outbound partner.  If it isn't
        // a demand refresh then check if the file USN has changed since we
        // sent out the CO.
        //
        // This still doesn't work because a non-replicating basic info
        // change could have changed the USN on the file.
        // In addition if the install of the file was delayed when the
        // CO was inserted in the outlog, then the USN on the file is
        // still more recent than in the CO, so it still won't match.  Sigh!
        //
#if 0
        if (0 && !BooleanFlagOn(Coc->Flags, CO_FLAG_DEMAND_REFRESH) &&
            !StuCmpUsn(SrcHandle, Coe  /*  NOTE:  COE is NULL HERE */, &Coc->JrnlUsn)) {
            DPRINT(4, "++ Stage File Creation for fetch failed due to FileUSN change.\n");
            DPRINT1(4, "++ Coc->JrnlUsn is: %08x %08x\n", PRINTQUAD(Coc->JrnlUsn));
            DPRINT2(4, "++ Filename: %ws   Vsn: %08x %08x\n", Coc->FileName, PRINTQUAD(Coc->FrsVsn));
            WIN_SET_FAIL(WStatus);
            goto out;
        }
#endif
    } else {
        //
        // This is a stage request for a local CO.  Check to see if the file
        // USN has changed.  Note:  If this local CO was sent thru retry, due to a
        // previous sharing viol say, and then a basic info change was made
        // to the file then the USN value in the change order would not match
        // the USN on the file when the CO is later retried.  To solve this, test
        // if this is a retry CO and if so then generate the stage file anyway.
        // Even if this CO didn't go thru retry a basic info change could still
        // have been done to the file and before we got the first change order
        // here.  So the file USN still wouldn't match.
        //
        // Currently the Coc flag CO_FLAG_FILE_USN_VALID is never set.
        // The code in createdb is commented out because a test for a valid
        // file on a fetch can be bogus.
        //
#if 0
        if (0 && BooleanFlagOn(Coc->Flags, CO_FLAG_FILE_USN_VALID) &&
            !BooleanFlagOn(Coc->Flags, CO_FLAG_RETRY) &&
            !StuCmpUsn(SrcHandle, Coe, &Coc->FileUsn)) {
            //
            // Don't retry; the file has changed on us.
            //
            DPRINT(4, "++ Stage File Creation failed due to FileUSN change.\n");
            DPRINT1(4, "++ Coc->FileUsn is: %08x %08x\n", PRINTQUAD(Coc->FileUsn));
            DPRINT2(4, "++ Filename: %ws   Vsn: %08x %08x\n", Coc->FileName, PRINTQUAD(Coc->FrsVsn));
            WIN_SET_FAIL(WStatus);
            goto out;
        }
#endif
    }

    //
    // Create the staging file
    //
    WStatus = StuCreateFile(StagePath, &StageHandle);
    if (!HANDLE_IS_VALID(StageHandle) || !WIN_SUCCESS(WStatus)) {
        goto out;
    }
/*
    //
    // Approximate size of the staging file
    //
    if (!WIN_SUCCESS(FrsSetFilePointer(StagePath, StageHandle,
                           Header->Attributes.EndOfFile.HighPart,
                           Header->Attributes.EndOfFile.LowPart))) {
        goto out;
    }

    if (!FrsSetEndOfFile(StagePath, StageHandle)) {
        DPRINT2(0, "++ ERROR - %ws: Cannot set EOF to %08x %08x\n",
                StagePath, PRINTQUAD(Header->Attributes.EndOfFile.QuadPart));
        goto out;
    }
*/

    //
    // Get the full path for tracking unless this is from pre-existing or there
    // is no Coe (i.e. not Regenerating) to save it in.
    //
    if ((Coe != NULL) && !FromPreExisting) {
        Path = FrsGetFullPathByHandle(Coc->FileName, SrcHandle);
        if (Path) {
            SrcFile = FrsWcsCat(NewReplica->Volume, Path);
        }

        if (SrcFile == NULL) {
            WStatus = ERROR_NOT_ENOUGH_MEMORY;
            CLEANUP1_WS(0, "++ WARN - FrsGetFullPathByHandle(%ws)", Coc->FileName, WStatus, out);
        }

        FrsFree(Coe->FullPathName);
        Coe->FullPathName = SrcFile;
    }


    //
    // To generate a staging file from an encrypted file the "Raw File" APIs needs
    // to get called to get the raw encrypted data. This raw encrypted data does
    // not contain the file information like the filename, file times, object id,
    // security information, and other non-encrypted streams if present. After all
    // the encrypted data is stored in the staging file, BackupRead needs to be
    // called to collect the remaining file data. The offset and size of the
    // encrypted data needs to be added to the stage header so the encrypted
    // data can be extracted on the destination server.
    //
    if (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

        if (SrcFile == NULL) {
            //
            // OpenEncryptedFileRaw API needs a path to open the file. Get the path
            // from the handle if we didn't get it above.
            //
            Path = FrsGetFullPathByHandle(Coc->FileName, SrcHandle);
            if (Path) {
                SrcFile = FrsWcsCat(NewReplica->Volume, Path);
            }

            if (SrcFile == NULL) {
                WStatus = ERROR_NOT_ENOUGH_MEMORY;
                CLEANUP1_WS(0, "++ WARN - FrsGetFullPathByHandle(%ws)", Coc->FileName, WStatus, out);
            }
        }

        //
        // The volume path above is in the form of \\.\E: which is necessary to
        // open a volume handle (( check this )).  But we need \\?\E: here to
        // allow long path names to work.  See CreateFile API description in SDK.
        //
        if (SrcFile[2] == L'.') {
            SrcFile[2] = L'?';
        }

        DPRINT1(4, "++ FrsGetFullPathByHandle(%ws -> \n", Coc->FileName);
        FrsPrintLongUStr(4, DEBSUB, __LINE__, SrcFile);



        if (Header->Attributes.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            WStatus = OpenEncryptedFileRaw(SrcFile, CREATE_FOR_DIR, &pEncryptContext);
        } else {
            WStatus = OpenEncryptedFileRaw(SrcFile, 0, &pEncryptContext);
        }

        CLEANUP1_WS(0, "++ OpenEncryptedFileRaw failed on %ws;", SrcFile, WStatus, out);

        WStatus = FrsSetFilePointer(StagePath, StageHandle, Header->DataHigh, Header->DataLow);
        CLEANUP1_WS(0, "++ Set file pointer failed on %ws;", StagePath, WStatus, out);

        FrsEncryptDataContext.StagePath = StagePath;
        FrsEncryptDataContext.StageHandle = StageHandle;
        FrsEncryptDataContext.RawEncryptedBytes.QuadPart = 0;

        WStatus = ReadEncryptedFileRaw(StuReadEncryptedFileRaw, &FrsEncryptDataContext, pEncryptContext);

        CloseEncryptedFileRaw(pEncryptContext);

        CLEANUP1_WS(0, "++ ReadEncryptedFileRaw  failed on %ws;", SrcFile, WStatus, out);

        //
        // The encrypted bytes are stored right after the stage header. The other
        // BackupRead data is stored following it.
        //
        Header->EncryptedDataLow = Header->DataLow;
        Header->EncryptedDataSize.QuadPart = FrsEncryptDataContext.RawEncryptedBytes.QuadPart;

        DataOffset.LowPart = Header->DataLow;
        DataOffset.HighPart = Header->DataHigh;

        DataOffset.QuadPart += Header->EncryptedDataSize.QuadPart;

        Header->DataLow = DataOffset.LowPart;
        Header->DataHigh = DataOffset.HighPart;

    }

    //
    // Rewind the file, write the header, and set the file pointer
    // to the next 32 byte boundary
    //
    WStatus = FrsSetFilePointer(StagePath, StageHandle, 0, 0);
    CLEANUP1_WS(0, "++ Rewind failed on %ws;", StagePath, WStatus, out);

    WStatus = StuWriteFile(StagePath, StageHandle, Header, sizeof(STAGE_HEADER));
    CLEANUP1_WS(0, "++ WriteFile failed on %ws;", StagePath, WStatus, out);

    //
    // Write the reparse data
    //
    if(ReparseDataPresent) {
        WStatus = FrsSetFilePointer(StagePath, StageHandle, Header->ReparsePointDataHigh, Header->ReparsePointDataLow);
        CLEANUP1_WS(0, "++ SetFilePointer failed on %ws;", StagePath, WStatus, out);

        WStatus = StuWriteFile(StagePath, StageHandle, ReparseDataBuffer, ReparseDataBuffer->ReparseDataLength + REPARSE_GUID_DATA_BUFFER_HEADER_SIZE);
        CLEANUP1_WS(0, "++ WriteFile failed on %ws;", StagePath, WStatus, out);
    }

    WStatus = FrsSetFilePointer(StagePath, StageHandle, Header->DataHigh, Header->DataLow);
    CLEANUP1_WS(0, "++ SetFilePointer failed on %ws;", StagePath, WStatus, out);

    //
    // Increment the SizeOfFileGenerated if it has been asked
    //
    if (SizeOfFileGenerated != NULL) {
        *SizeOfFileGenerated += Header->DataLow;
    }


    //
    // Backup the src file into the staging file
    //
    BackupBuf = FrsAlloc(STAGEING_IOSIZE);
    StreamBytesLeft = 0;

    while (TRUE) {
        //
        // Check for a triggered oplock
        //
        if (HANDLE_IS_VALID(OpLockEvent)) {
            WStatus = WaitForSingleObject(OpLockEvent, 0);
            if ( WStatus != WAIT_TIMEOUT) {
                goto out;
            }
        }

        //
        // read source
        //
        if (!BackupRead(SrcHandle,
                        BackupBuf,
                        STAGEING_IOSIZE,
                        &NumBackupDataBytes,
                        FALSE,
                        TRUE,
                        &BackupContext)) {
            WStatus = GetLastError();
            CHANGE_ORDER_TRACEW(0, Coe, "ERROR - BackupRead", WStatus);
            //
            // This will cause us to retry for all errors returned by BackupRead.
            // Do we want to retry in all cases?
            WIN_SET_RETRY(WStatus);
            goto out;
        }

        //
        // No more data; Backup done
        //
        if (NumBackupDataBytes == 0) {
            break;
        }

#define __V51_FIND_REPARSE_STREAM__  0
#if __V51_FIND_REPARSE_STREAM__
        //
        // If this is the start of a new backup stream then dump out the
        // WIN32_STREAM_ID structure.
        //

        BuffBytesLeft = (LONG) NumBackupDataBytes;

        while (BuffBytesLeft > 0) {
            //
            // Is a stream header next?
            //
            DPRINT1(4, "++ New StreamBytesLeft: %Ld\n", StreamBytesLeft);
            DPRINT1(4, "++ New BuffBytesLeft: %d\n", BuffBytesLeft);

            if (StreamBytesLeft <= 0) {
                StreamId = (WIN32_STREAM_ID *)
                    ((PCHAR)BackupBuf + (NumBackupDataBytes - (DWORD)BuffBytesLeft));

                Length = StreamId->dwStreamNameSize;

                //
                // header plus name plus data.
                //
                StreamBytesLeft = StreamId->Size.QuadPart + Length
                                + CB_NAMELESSHEADER;

                if (Length > 0) {
                    if (Length > (sizeof(TStr)-sizeof(WCHAR))) {
                        Length = (sizeof(TStr)-sizeof(WCHAR));
                    }
                    CopyMemory(TStr, StreamId->cStreamName, Length);
                    TStr[Length/sizeof(WCHAR)] = UNICODE_NULL;
                } else {
                    wcscpy(TStr, L"<Null>");
                }

                if (StreamId->dwStreamId == BACKUP_REPARSE_DATA) {
                    DPRINT(4, "++ BACKUP_REPARSE_DATA Stream\n");
                }

                DPRINT1(4, "++ Stream Name: %ws\n", TStr);

                DPRINT4(4, "++ ID: %d, Attr: %08x, Size: %Ld, NameSize: %d\n",
                        StreamId->dwStreamId, StreamId->dwStreamAttributes,
                        StreamId->Size.QuadPart, Length);
            }

            //
            // Have we run out of buffer?
            //
            if (StreamBytesLeft > (LONGLONG) BuffBytesLeft) {
                StreamBytesLeft -= (LONGLONG) BuffBytesLeft;
                DPRINT1(4, "++ New StreamBytesLeft: %Ld\n", StreamBytesLeft);
                DPRINT1(4, "++ New BuffBytesLeft: %d\n", BuffBytesLeft);
                break;
            }

            //
            // Reduce buffer bytes by bytes left in stream.
            //
            BuffBytesLeft -= (LONG) StreamBytesLeft;
            StreamBytesLeft = 0;
        }


#endif __V51_FIND_REPARSE_STREAM__

        //
        // The security section contains machine specific info. Get rid
        // of it when computing Md5.
        //
        // Note: Code assumes security section is first in backup file.
        //
        if (Md5) {
            //
            // Is the first buffer large enough to hold a stream header?
            //
            if (FirstBuffer && NumBackupDataBytes >= sizeof(WIN32_STREAM_ID)) {
                //
                // Is the first stream the security info? If so, is it
                // large enough to include an extra dword?
                //
                StreamId = (WIN32_STREAM_ID *)BackupBuf;
                if (StreamId->dwStreamId == BACKUP_SECURITY_DATA &&
                    NumBackupDataBytes >= sizeof(WIN32_STREAM_ID) +
                                          StreamId->dwStreamNameSize +
                                          sizeof(WORD) +
                                          sizeof(WORD)) {
                    //
                    // Assume second word contains the per-machine info.
                    // AND out the machine specific info, computer md5,
                    // put the word back to its original state.
                    //
                    SecurityControl = (PVOID)((PCHAR)&StreamId->cStreamName[0] +
                                               StreamId->dwStreamNameSize +
                                               sizeof(WORD));

                    CopyMemory(&OldSecurityControl, SecurityControl, sizeof(WORD));

                    NewSecurityControl = OldSecurityControl & ~((WORD)STAGING_RESET_SE);
                    CopyMemory(SecurityControl, &NewSecurityControl, sizeof(WORD));

                    MD5Update(Md5, BackupBuf, NumBackupDataBytes);
                    CopyMemory(SecurityControl, &OldSecurityControl, sizeof(WORD));
                }
            } else {
                MD5Update(Md5, BackupBuf, NumBackupDataBytes);
            }
            //
            // Stream id is not alwasy at the top of later buffers
            //
            FirstBuffer = FALSE;
        }

        //
        // Increment the value of the Bytes of Staging generated counter
        // or the staging regenerated counter depending on whether the
        // Regenerating value is FALSE or TRUE
        //
        if (!Regenerating) {
            PM_INC_CTR_REPSET(NewReplica, SFGeneratedB, NumBackupDataBytes);
        } else {
            PM_INC_CTR_REPSET(NewReplica, SFReGeneratedB, NumBackupDataBytes);
        }

        if (!DebugInfo.DisableCompression && pFrsCompressBuffer != NULL) {
            //
            // Compression is enabled. Compress the data before writing to the staging file.
            //
            if (CompressedBuf == NULL) {
                CompressedBuf = FrsAlloc(STAGEING_IOSIZE);
                CompressedBufLen = STAGEING_IOSIZE;
            }

            do {
                WStatus = (*pFrsCompressBuffer)(BackupBuf,            //  input
                                                NumBackupDataBytes,   //  length of input
                                                CompressedBuf,        //  output
                                                CompressedBufLen,     //  length of output
                                                &ActCompressedSize);  //  result size

                if (WStatus == ERROR_MORE_DATA) {
                    DPRINT2(5, "Compressed data is more than %d bytes, increasing buffer to %d bytes and retrying.\n",
                            CompressedBufLen, CompressedBufLen*2);
                    CompressedBuf = FrsFree(CompressedBuf);
                    CompressedBufLen = CompressedBufLen*2;
                    CompressedBuf = FrsAlloc(CompressedBufLen);
                    continue;
                } else {
                    break;
                }

                //
                // Keep increasing the buffer upto 256K. We fail for
                // files whose size increases more than 4 times after
                // compression.
                //
            } while (CompressedBufLen <= STAGEING_IOSIZE*4);

            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1(0,"ERROR compressing data. WStatus = 0x%x\n", WStatus);

                goto out;
            }

            //
            // write the staging file
            //
            WStatus = StuWriteFile(StagePath, StageHandle, CompressedBuf, ActCompressedSize);
            CLEANUP1_WS(0, "++ WriteFile failed on %ws;", StagePath, WStatus, out);

        } else {
            //
            // write the staging file
            //
            WStatus = StuWriteFile(StagePath, StageHandle, BackupBuf, NumBackupDataBytes);
            CLEANUP1_WS(0, "++ WriteFile failed on %ws;", StagePath, WStatus, out);
        }

    }

    //
    // Release handles as soon as possible
    //
    FRS_CLOSE(SrcHandle);
    FRS_CLOSE(OpLockHandle);
    FRS_CLOSE(OpLockEvent);

    //
    // Make sure all of the data is on disk. We don't want to lose
    // it across reboots
    //
    WStatus = FrsFlushFile(StagePath, StageHandle);
    CLEANUP1_WS(0, "++ FlushFileBuffers failed on %ws;", StagePath, WStatus, out);

    //
    // Increment the SizeOfFileGenerated is if has been asked
    //
    if (SizeOfFileGenerated != NULL) {
        GetFileSizeEx(StageHandle, (PLARGE_INTEGER)SizeOfFileGenerated);
    }

    //
    // Done with the staging file handle
    //
    if (BackupContext) {
        BackupRead(StageHandle, NULL, 0, NULL, TRUE, TRUE, &BackupContext);
    }

    FRS_CLOSE(StageHandle);
    BackupContext = NULL;

    //
    // Move the staging file into its final location.  Unless this happens to
    // be generating a staging file for a preexisting file on the downstream
    // partner.  The upstream partner completes the generation of the staging
    // file because it own the "correct" copy.  The downstream partner's
    // staging file may be incorrect.  We won't know for sure until the
    // upstream partner compares the md5 checksum.  The staging file isn't
    // finalized because a shutdown will cause the incorrect staging file to
    // be treated as the correct copy.
    //
    if (!FromPreExisting) {
        if (!DebugInfo.DisableCompression && pFrsCompressBuffer != NULL) {
            FinalPath = StuCreStgPath(NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_FINAL_COMPRESSED_PREFIX);
        } else {
            FinalPath = StuCreStgPath(NewReplica->Stage, &Coc->ChangeOrderGuid, STAGE_FINAL_PREFIX);
        }
        if (!MoveFileEx(StagePath,
                        FinalPath,
                        MOVEFILE_WRITE_THROUGH | MOVEFILE_REPLACE_EXISTING)) {
            WStatus = GetLastError();
            goto out;
        }
    }

    //
    // The Idtable record should reflect these attributes of the staging file
    // we generated.  These fields will be used to update the idtable record
    // when the change order is retired.
    //
    if (!Regenerating && !FromPreExisting) {
        BOOL AttributeMismatch;
        Coe->FileCreateTime.QuadPart = Header->Attributes.CreationTime.QuadPart;
        Coe->FileWriteTime.QuadPart  = Header->Attributes.LastWriteTime.QuadPart;

        AttributeMismatch = ((Coc->FileAttributes ^
                               Header->Attributes.FileAttributes) &
                                  FILE_ATTRIBUTE_DIRECTORY) != 0;

        if (AttributeMismatch) {
            DPRINT2(0, "++ ERROR: Attribute mismatch between CO (%08x) and File (%08x)\n",
                    Coc->FileAttributes, Header->Attributes.FileAttributes);
            FRS_ASSERT(!"Attribute mismatch between CO and File");
        }

        Coc->FileAttributes = Header->Attributes.FileAttributes;
    }

    //
    // The caller is asking for stage file to be generated for a pre-existing
    // file/dir with the same object ID.  The MD5 is generated here but the
    // caller is going to check for matching attributes so return the
    // attributes for the pre-existing file/dir in the Coe->Fileattributes.
    //
    if (!Regenerating && FromPreExisting) {
        Coe->FileAttributes = Header->Attributes.FileAttributes;
    }

    WStatus = ERROR_SUCCESS;

out:
    //
    // Release resources
    //
    FRS_CLOSE(SrcHandle);
    FRS_CLOSE(OpLockHandle);
    FRS_CLOSE(OpLockEvent);

    if (BackupContext) {
        BackupRead(StageHandle, NULL, 0, NULL, TRUE, TRUE, &BackupContext);
    }

    FRS_CLOSE(StageHandle);

    FrsFree(Path);
    //
    // SrcFile will be freed when change order entry is freed if we saved it.
    //
    if ((Coe == NULL) || (Coe->FullPathName == NULL)) {
        FrsFree(SrcFile);
    }
    FrsFree(BackupBuf);
    FrsFree(StagePath);
    FrsFree(FinalPath);
    FrsFree(ReparseDataBuffer);

    //
    //######################### COMPRESSION OF STAGING FILE STARTS ###############
    //
    FrsFree(CompressedBuf);
    //
    //######################### COMPRESSION OF STAGING FILE ENDS ###############
    //

    if (Md5) {
        MD5Final(Md5);
        bugbug("if MD5 generated above is different from what is in CO then we need to rewrite the extension");
        bugmor("Do we need to call MD5Final before we have a valid checksum?")
    }

    if (WStatus == ERROR_DISK_FULL) {
        Volume = FrsWcsVolume(NewReplica->Stage);
        if ((Volume != NULL) && (wcslen(Volume) >= wcslen(L"\\\\.\\D:"))) {
            //
            // If we are able to get the volume in the form
            // \\.\D: then use the volume in the event log so
            // that we don't print more than one event log
            // message per volume. If we can't get the
            // volume then we print the path.
            //
            EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, &Volume[4]);
        }else{
            EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, NewReplica->Stage);
        }
        FrsFree(Volume);
    }

    return WStatus;
}


DWORD
StuGenerateDecompressedStage(
    IN PWCHAR   StageDir,
    IN GUID     *CoGuid,
    IN GUID     *CompressionFormatUsed
    )
/*++
Routine Description:
    Converts a compressed staging file to uncompressed staging file.

Arguments:

    StageDir              : Path to the staging dir.
    CoGuid                : Pointer to the CO guid.
    CompressionFormatUsed : Compression format to use to decompress the
                            staging file.

Return Value:
    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB  "StuGenerateDecompressedStage:"

    PWCHAR  SrcStagePath        = NULL;
    PWCHAR  DestStagePath       = NULL;
    PWCHAR  FinalStagePath      = NULL;
    HANDLE  SrcStageHandle      = INVALID_HANDLE_VALUE;
    HANDLE  DestStageHandle     = INVALID_HANDLE_VALUE;
    DWORD   WStatus             = ERROR_SUCCESS;
    PUCHAR  CompressedBuf       = NULL;
    ULONG   ToDecompress        = 0;
    STAGE_HEADER Header;

    DWORD   DecompressStatus    = ERROR_SUCCESS;
    PUCHAR  DecompressedBuf     = NULL;
    DWORD   DecompressedBufLen  = 0;
    DWORD   DecompressedSize    = 0;
    FRS_COMPRESSED_CHUNK_HEADER ChunkHeader;
    LARGE_INTEGER               LenOfPartialChunk;
    DWORD   BytesProcessed      = 0;
    PVOID   DecompressContext   = NULL;
    PWCHAR  Volume;

    PFRS_DECOMPRESS_BUFFER      pFrsDecompressBuffer;
    PFRS_FREE_DECOMPRESS_BUFFER pFrsFreeDecompressContext;

    //DWORD (*pFrsDecompressBuffer)(OUT DecompressedBuf, IN DecompressedBufLen, IN CompressedBuf, IN CompressedBufLen, OUT DecompressedSize, OUT BytesProcessed);
    //PVOID (*pFrsFreeDecompressContext)(IN pDecompressContext);

    //
    // Get the decompression routines by using the guid passed in.
    //
    if (IS_GUID_ZERO(CompressionFormatUsed)) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }

    WStatus = FrsGetDecompressionRoutineByGuid(CompressionFormatUsed,
                                               &pFrsDecompressBuffer,
                                               &pFrsFreeDecompressContext);
    if (!WIN_SUCCESS(WStatus)) {
        //
        // No suitable decompression routine was found for this file.
        //
        DPRINT(0, "ERROR - No suitable decompression routine was found \n");
        FRS_ASSERT(TRUE);
    }

    SrcStagePath = StuCreStgPath(StageDir, CoGuid, STAGE_FINAL_COMPRESSED_PREFIX);
    //
    // SrcStagePath can be NULL is any of the above three parameters are NULL (prefix fix).
    //
    if (SrcStagePath == NULL) {
        goto CLEANUP;
    }

    DestStagePath = StuCreStgPath(StageDir, CoGuid, STAGE_GENERATE_PREFIX);
    //
    // DestStagePath can be NULL is any of the above three parameters are NULL (prefix fix).
    //
    if (DestStagePath == NULL) {
        goto CLEANUP;
    }

    //
    // Open the stage file for shared, sequential reads
    //
    WStatus = StuOpenFile(SrcStagePath, GENERIC_READ, &SrcStageHandle);
    if (!HANDLE_IS_VALID(SrcStageHandle) || !WIN_SUCCESS(WStatus)) {
        DPRINT2(0,"Error opening %ws. WStatus = %d\n", SrcStagePath, WStatus);
        goto CLEANUP;
    }

    //
    // Delete the dest file if it exits.
    //
    WStatus = FrsDeleteFile(DestStagePath);
    CLEANUP1_WS(0, "Error deleting %ws;", DestStagePath, WStatus, CLEANUP);

    //
    // Create the decompressed staging file.
    //
    WStatus = StuCreateFile(DestStagePath, &DestStageHandle);
    if (!HANDLE_IS_VALID(DestStageHandle) || !WIN_SUCCESS(WStatus)) {
        DPRINT2(0,"Error opening %ws. WStatus = %d\n", DestStagePath, WStatus);
        goto CLEANUP;
    }

    //
    // First copy the stage header.
    //
    //
    // read stage header.
    //
    WStatus = StuReadFile(SrcStagePath, SrcStageHandle, &Header, sizeof(STAGE_HEADER), &ToDecompress);
    CLEANUP1_WS(0, "Can't read file %ws;", SrcStagePath, WStatus, CLEANUP);

    if (ToDecompress == 0) {
        goto CLEANUP;
    }

    //
    // Zero off the compression guid from the header. This down level partner
    // could later on send this staging file to an uplevel partner.
    //
    ZeroMemory(&Header.CompressionGuid, sizeof(GUID));

    //
    // Write the stage header.
    //
    WStatus = StuWriteFile(DestStagePath, DestStageHandle, &Header, sizeof(STAGE_HEADER));
    CLEANUP1_WS(0, "++ WriteFile failed on %ws;", DestStagePath, WStatus, CLEANUP);

    //
    // Set the stage file pointers to point to the start of stage data.
    //
    WStatus = FrsSetFilePointer(SrcStagePath, SrcStageHandle, Header.DataHigh, Header.DataLow);
    CLEANUP1_WS(0, "++ SetFilePointer failed on src %ws;", SrcStagePath, WStatus, CLEANUP);

    WStatus = FrsSetFilePointer(DestStagePath, DestStageHandle, Header.DataHigh, Header.DataLow);
    CLEANUP1_WS(0, "++ SetFilePointer failed on dest %ws;", DestStagePath, WStatus, CLEANUP);


    //
    // Restore the stage file into the temporary file
    //
    CompressedBuf = FrsAlloc(STAGEING_IOSIZE);

    do {
        //
        // read stage
        //
        WStatus = StuReadFile(SrcStagePath, SrcStageHandle, CompressedBuf, STAGEING_IOSIZE, &ToDecompress);
        CLEANUP1_WS(0, "Can't read file %ws;", SrcStagePath, WStatus, CLEANUP);

        if (ToDecompress == 0) {
            break;
        }

        //
        // Compression is enabled. Decompress data before installing.
        //
        BytesProcessed = 0;
        DecompressContext = NULL;
        if (DecompressedBuf == NULL) {
            DecompressedBuf = FrsAlloc(STAGEING_IOSIZE);
            DecompressedBufLen = STAGEING_IOSIZE;
        }
        do {

            DecompressStatus = (*pFrsDecompressBuffer)(DecompressedBuf,
                                                       DecompressedBufLen,
                                                       CompressedBuf,
                                                       ToDecompress,
                                                       &DecompressedSize,
                                                       &BytesProcessed,
                                                       &DecompressContext);

            if (!WIN_SUCCESS(DecompressStatus) && DecompressStatus != ERROR_MORE_DATA) {
                DPRINT1(0,"Error - Decompressing. WStatus = 0x%x\n", DecompressStatus);
                WStatus = DecompressStatus;
                goto CLEANUP;
            }

            if (DecompressedSize == 0) {
                break;
            }

            //
            // Write the decompressed staging file.
            //
            WStatus = StuWriteFile(DestStagePath, DestStageHandle, DecompressedBuf, DecompressedSize);
            CLEANUP1_WS(0, "++ WriteFile failed on %ws;", DestStagePath, WStatus, CLEANUP);

        } while (DecompressStatus == ERROR_MORE_DATA);

        //
        // Free the Decompress context if used.
        //
        if (DecompressContext != NULL) {
            pFrsFreeDecompressContext(&DecompressContext);
        }
        //
        // Rewind the file pointer so we can read the remaining chunck at the next read.
        //

        LenOfPartialChunk.QuadPart = ((LONG)BytesProcessed - (LONG)ToDecompress);

        if (!SetFilePointerEx(SrcStageHandle, LenOfPartialChunk, NULL, FILE_CURRENT)) {
            WStatus = GetLastError();
            CLEANUP1_WS(0, "++ Can't set file pointer for %ws;", SrcStagePath, WStatus, CLEANUP);
        }

    } while (TRUE);

    FRS_CLOSE(SrcStageHandle);
    FRS_CLOSE(DestStageHandle);

    //
    // Do the final rename.
    //

    FinalStagePath = StuCreStgPath(StageDir, CoGuid, STAGE_FINAL_PREFIX);
    //
    // DestStagePath can be NULL is any of the above three parameters are NULL (prefix fix).
    //
    if (FinalStagePath == NULL) {
        goto CLEANUP;
    }

    if (!MoveFileEx(DestStagePath,
                    FinalStagePath,
                    MOVEFILE_WRITE_THROUGH | MOVEFILE_REPLACE_EXISTING)) {
        WStatus = GetLastError();
        DPRINT3(0,"Error moving %ws to %ws. WStatus = %d\n", DestStagePath, FinalStagePath, WStatus);
        goto CLEANUP;
    }

    WStatus = ERROR_SUCCESS;

CLEANUP:

    FrsFree(SrcStagePath);
    FrsFree(DestStagePath);
    FrsFree(CompressedBuf);
    FrsFree(DecompressedBuf);

    FRS_CLOSE(SrcStageHandle);
    FRS_CLOSE(DestStageHandle);

    if (WStatus == ERROR_DISK_FULL) {
        Volume = FrsWcsVolume(StageDir);
        if ((Volume != NULL) && (wcslen(Volume) >= wcslen(L"\\\\.\\D:"))) {
            //
            // If we are able to get the volume in the form
            // \\.\D: then use the volume in the event log so
            // that we don't print more than one event log
            // message per volume. If we can't get the
            // volume then we print the path.
            //
            EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, &Volume[4]);
        }else{
            EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, StageDir);
        }
        FrsFree(Volume);
    }
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\util.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains support routines for the NT File Replication Service.

Author:

    David A. Orbits (davidor)  25-Mar-1997

Environment:

    User Mode Service

Revision History:

--*/
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <tablefcn.h>
#include <ntfrsapi.h>
#include <info.h>
#include <sddl.h>
#ifdef SECURITY_WIN32
#include <security.h>
#else
#define SECURITY_WIN32
#include <security.h>
#undef SECURITY_WIN32
#endif

#include "stdarg.h"

#include <accctrl.h>
#include <aclapi.h>

extern PGEN_TABLE ReparseTagTable;
extern PGEN_TABLE ReplicasByGuid;
extern PGEN_TABLE VolSerialNumberToDriveTable;

VOID
FrsBuildVolSerialNumberToDriveTable(
    PWCHAR      LogicalDrives,
    BOOL        EmptyTable
    );

BOOL
JrnlIsChangeOrderInReplica(
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN PLONGLONG            DirFileID
);

#if 0

LPTSTR
FrsSupInitPath(
    OUT LPTSTR OutPath,
    IN LPTSTR InPath,
    IN ULONG MaxOutPath
    )
/*++

Routine Description:

    Initialize a directory path string.  Add a backslash as needed and
    return a pointer to the start of the file part of the output string.
    Return NULL if the Output path string is too small.
    If InPath is NULL, OutPath is set to NULL and no slash.

Arguments:

    OutPath - The output string with the initialized path.

    InPath - The supplied input path.

    MaxOutPath - The maximum number of charaters that fit in OutPath.

Return Value:

    Pointer to the start of the filename part of the output string.
    NULL if output string is too small.

--*/
    //
    // Capture the directory path and add a backslash if necc.
    //
{
#undef DEBSUB
#define DEBSUB "FrsSupInitPath:"


    ULONG Length;


    Length = wcslen(InPath);
    if (Length > MaxOutPath) {
        return NULL;
    }

    wcscpy(OutPath, InPath);
    if (Length > 0) {
        if (OutPath[Length - 1] != COLON_CHAR &&
            OutPath[Length - 1] != BACKSLASH_CHAR) {
            wcscat(OutPath, L"\\");
            Length += 1;
        }
    }

    return &OutPath[Length];
}
#endif 0

LONG
FrsIsParent(
    IN PWCHAR   Directory,
    IN PWCHAR   Path
    )
/*++

Routine Description:

    Is Path a child of Directory or is the Directory a child of the path.
    In other words, is the directory represented by Path beneath
    the directory hierarchy represented by Directory (or vice-versa).

    E.g., c:\a\b is a child of c:\a.

    In the case of an exact match, Path is considered a child of
    Directory. This routine can be easily spoofed; a better check
    using FIDs and volume IDs should be implemented.

Arguments:

    Directory
    Path

Return Value:
    -1  = Path is a child of Directory or Path is the same as Directory
     0  = No relationship
     1  = Directory is a child of Path

--*/
{
#undef DEBSUB
#define DEBSUB "FrsIsParent:"

    PWCHAR  D;
    PWCHAR  P;
    LONG    Result = 0;
    PWCHAR  IndexPtrDir   = NULL;
    PWCHAR  IndexPtrPath   = NULL;
    DWORD   Colon      = 0;
    DWORD   CloseBrace = 0;
    DWORD   WStatus;
    HANDLE  Handle     = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK Iosb;
    PFILE_FS_VOLUME_INFORMATION   VolumeInfoDir   = NULL;
    PFILE_FS_VOLUME_INFORMATION   VolumeInfoPath  = NULL;
    DWORD   VolumeInfoLength;
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES             Obja;
    UNICODE_STRING          FileName;
    ULONG                   FileAttributes;
    ULONG                   CreateDisposition;
    ULONG             ShareMode;

    //
    // Note: This is easily spoofed into giving false negatives.
    // Need to improve it to uses FIDs and voluem IDs
    //
    //
    // Defensive; NULL strings or empty strings can't be children/parents
    //
    if (!Directory || !Path || !*Directory || !*Path) {
        return Result;
    }

    //
    // If both the paths are on different volumes then they can not overlap.
    //
    //
    // Open the target symlink. If this is a dos type path name then
    // convert it to NtPathName or else use it as it is.
    //

    if (wcscspn(Directory, L":") == 1) {
        WStatus = FrsOpenSourceFileW(&Handle,
                                     Directory,
                                     GENERIC_READ,
                                     FILE_OPEN_FOR_BACKUP_INTENT);
        CLEANUP1_WS(4, "++ Could not open %ws; ", Directory, WStatus, RETURN);

    } else {
        //
        // The path already in Nt style. Use it as it is.
        //
        FileName.Buffer = Directory;
        FileName.Length = (USHORT)(wcslen(Directory) * sizeof(WCHAR));
        FileName.MaximumLength = (USHORT)(wcslen(Directory) * sizeof(WCHAR));

        InitializeObjectAttributes(&Obja,
                                   &FileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        CreateDisposition = FILE_OPEN;               // Open existing file

        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

        FileAttributes = FILE_ATTRIBUTE_NORMAL;

        NtStatus = NtCreateFile(&Handle,
                              GENERIC_READ,
                              &Obja,
                              &Iosb,
                              NULL,              // Initial allocation size
                              FileAttributes,
                              ShareMode,
                              CreateDisposition,
                              FILE_OPEN_FOR_BACKUP_INTENT,
                              NULL, 0);

        WStatus = FrsSetLastNTError(NtStatus);
        CLEANUP1_WS(4, "++ Could not open %ws;", Directory, WStatus, RETURN);
    }

    //
    // Get the volume information.
    //
    VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    VolumeInfoDir = FrsAlloc(VolumeInfoLength);

    NtStatus = NtQueryVolumeInformationFile(Handle,
                                          &Iosb,
                                          VolumeInfoDir,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    CloseHandle(Handle);
    WStatus = FrsSetLastNTError(NtStatus);
    CLEANUP1_WS(4,"ERROR - Getting  NtQueryVolumeInformationFile for %ws\n", Directory, WStatus, RETURN);

    // Open the target symlink. If this is a dos type path name then
    // convert it to NtPathName or else use it as it is.
    //

    if (wcscspn(Path, L":") == 1) {
        WStatus = FrsOpenSourceFileW(&Handle,
                                     Path,
                                     GENERIC_READ,
                                     FILE_OPEN_FOR_BACKUP_INTENT);
        CLEANUP1_WS(4, "++ Could not open %ws; ", Path, WStatus, RETURN);

    } else {
        //
        // The path already in Nt style. Use it as it is.
        //
        FileName.Buffer = Path;
        FileName.Length = (USHORT)(wcslen(Path) * sizeof(WCHAR));
        FileName.MaximumLength = (USHORT)(wcslen(Path) * sizeof(WCHAR));

        InitializeObjectAttributes(&Obja,
                                   &FileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        CreateDisposition = FILE_OPEN;               // Open existing file

        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

        FileAttributes = FILE_ATTRIBUTE_NORMAL;

        NtStatus = NtCreateFile(&Handle,
                              GENERIC_READ,
                              &Obja,
                              &Iosb,
                              NULL,              // Initial allocation size
                              FileAttributes,
                              ShareMode,
                              CreateDisposition,
                              FILE_OPEN_FOR_BACKUP_INTENT,
                              NULL, 0);

        WStatus = FrsSetLastNTError(NtStatus);
        CLEANUP1_WS(4, "++ Could not open %ws;", Path, WStatus, RETURN);
    }

    //
    // Get the volume information.
    //
    VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    VolumeInfoPath = FrsAlloc(VolumeInfoLength);

    NtStatus = NtQueryVolumeInformationFile(Handle,
                                          &Iosb,
                                          VolumeInfoPath,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    WStatus = FrsSetLastNTError(NtStatus);
    CLEANUP1_WS(4,"ERROR - Getting  NtQueryVolumeInformationFile for %ws\n", Path, WStatus, RETURN);

    if (VolumeInfoDir->VolumeSerialNumber != VolumeInfoPath->VolumeSerialNumber) {
        goto RETURN;
    }

    //
    // Find the colon. Every path has to either have a colon followed by a '\'
    // or it should be of the form. "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
    //
    Colon = wcscspn(Directory, L":");

    if (Colon == wcslen(Directory)) {
        //
        // Path does not have a colon. It can be of the form
        // "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
        //
        CloseBrace = wcscspn(Directory, L"}");
        if (Directory[CloseBrace] != L'}' ||
            Directory[CloseBrace + 1] != L'\\') {
            Result = 0;
            goto RETURN;
        }
        //
        // Copy the path up to 1 past the closing brace as it is. It could be \??\Volume...
        // or \\.\Volume... or \\?\Volume.. or some other complex form.
        // Start looking for reparse points past the closing brace.
        //

        IndexPtrDir = &Directory[CloseBrace + 1];

    } else {
        if (Directory[Colon] != L':' ||
            Directory[Colon + 1] != L'\\') {
            Result = 0;
            goto RETURN;
        }
        //
        // Copy the path up to 1 past the colon as it is. It could be d:\
        // or \\.\d:\ or \??\d:\ or some other complex form.
        // Start looking for reparse points past the colon.
        //

        IndexPtrDir = &Directory[Colon + 1];

    }

    //
    // Find the colon. Every path has to either have a colon followed by a '\'
    // or it should be of the form. "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
    //
    Colon = wcscspn(Path, L":");

    if (Colon == wcslen(Path)) {
        //
        // Path does not have a colon. It can be of the form
        // "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
        //
        CloseBrace = wcscspn(Path, L"}");
        if (Path[CloseBrace] != L'}' ||
            Path[CloseBrace + 1] != L'\\') {
            Result = 0;
            goto RETURN;
        }
        //
        // Copy the path up to 1 past the closing brace as it is. It could be \??\Volume...
        // or \\.\Volume... or \\?\Volume.. or some other complex form.
        // Start looking for reparse points past the closing brace.
        //

        IndexPtrPath = &Path[CloseBrace + 1];

    } else {
        if (Path[Colon] != L':' ||
            Path[Colon + 1] != L'\\') {
            Result = 0;
            goto RETURN;
        }
        //
        // Copy the path up to 1 past the colon as it is. It could be d:\
        // or \\.\d:\ or \??\d:\ or some other complex form.
        // Start looking for reparse points past the colon.
        //

        IndexPtrPath = &Path[Colon + 1];

    }

    //
    // Break at the first non-matching wchar (collapse dup \s)
    //
    for (D = IndexPtrDir, P = IndexPtrPath; *P && *D; ++P, ++D) {
        //
        // Skip dup \s
        //
        while (*P == L'\\' && *(P + 1) == L'\\') {
            ++P;
        }
        while (*D == L'\\' && *(D + 1) == L'\\') {
            ++D;
        }
        if (towlower(*P) != towlower(*D)) {
            break;
        }
    }

    //
    // Exact match; consider Path a child of Directory
    //
    if (!*D && !*P) {
        Result = -1;
        goto RETURN;
    }

    //
    // Collapse dup \s
    //
    while (*P == L'\\' && *(P + 1) == L'\\') {
        ++P;
    }
    while (*D == L'\\' && *(D + 1) == L'\\') {
        ++D;
    }

    //
    // Path is a child of Directory
    //
    if ((!*D || (*D == L'\\' && !*(D + 1))) &&
        (!*P || *P == L'\\' || (P != Path && *(P - 1) == L'\\'))) {
        Result = -1;
        goto RETURN;
    }

    //
    // Directory is a child of Path
    //
    if ((!*P || (*P == L'\\' && !*(P + 1))) &&
        (!*D || *D == L'\\' || (D != Directory && *(D - 1) == L'\\'))) {
        Result = 1;
        goto RETURN;
    }

    //
    // no relationship
    //
RETURN:
    FRS_CLOSE(Handle);
    FrsFree(VolumeInfoDir);
    FrsFree(VolumeInfoPath);
    return Result;
}

#if 0

ULONG FrsSupMakeFullFileName(
    IN PREPLICA Replica,
    IN PTCHAR RelativeName,
    OUT PTCHAR FullName,
    IN ULONG MaxLength
    )
{
/*++

Routine Description:

    Build a full file name for a given data source with the supplied
    RelativeName.

Arguments:

    Replica  - The replica tree to provide the root path.

    RelativeName - The relative file name from the root of the data source.

    FullName - The returned full path name of the file.

    MaxLength - The maximum number of characters that fit in FullName.

Return Value:

    Status - ERROR_BAD_PATHNAME if the name is too long.

--*/
#undef DEBSUB
#define DEBSUB "FrsSupMakeFullFileName:"


    ULONG Length, TotalLength;
    PTCHAR pFilePart;

    PCONFIG_TABLE_RECORD ConfigRecord;

    ConfigRecord = (PCONFIG_TABLE_RECORD) (Replica->ConfigTable.pDataRecord);

    //
    // Init the file name string with the DataSource root path.
    //
    pFilePart = FrsSupInitPath( FullName, ConfigRecord->FSRootPath, MaxLength);
    if (pFilePart == NULL) {
        return ERROR_BAD_PATHNAME;
    }

    Length = wcslen(RelativeName);
    TotalLength = Length + wcslen(FullName);
    if (TotalLength > MaxLength) {
        return ERROR_BAD_PATHNAME;
    }
    //
    // Append the relative file name to the end of the base path.
    //
    wcscpy(pFilePart, RelativeName);

    return ERROR_SUCCESS;
}

#endif 0

ULONG
FrsForceDeleteFile(
    PTCHAR DestName
)
/*++

Routine Description:

    Support routine to delete File System Files.  Returns success if file
    is not there or if it was there and was deleted.

Arguments:

    DestName - The fully qualified file name.

Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsForceDeleteFile:"

    ULONG WStatus = ERROR_SUCCESS;
    ULONG FileAttributes;

    if (!DeleteFile(DestName)) {

        WStatus = GetLastError();
        if ((WStatus == ERROR_FILE_NOT_FOUND) ||
            (WStatus == ERROR_PATH_NOT_FOUND)) {
            return ERROR_SUCCESS;
        }

        FileAttributes = GetFileAttributes(DestName);

        if ((FileAttributes != 0xFFFFFFFF) &&
            (FileAttributes & NOREPL_ATTRIBUTES)) {
            //
            // Reset file attributes to allow delete.
            //
            SetFileAttributes(DestName,
                              FILE_ATTRIBUTE_NORMAL |
                              (FileAttributes & ~NOREPL_ATTRIBUTES));
        }

        if (!DeleteFile(DestName)) {
            WStatus = GetLastError();
            DPRINT1_WS(4, "++ WARN - cannot delete %ws;", DestName, WStatus);
        }
    }

    return WStatus;
}


HANDLE
FrsCreateEvent(
    IN  BOOL    ManualReset,
    IN  BOOL    InitialState
)
/*++

Routine Description:

    Support routine to create an event.

Arguments:

    ManualReset     - TRUE if ResetEvent is required
    InitialState    - TRUE if signaled

Return Value:

    Address of the created event handle.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateEvent:"
    HANDLE  Handle;

    Handle = CreateEvent(NULL, ManualReset, InitialState, NULL);
    if (!HANDLE_IS_VALID(Handle)) {
        RaiseException(ERROR_INVALID_HANDLE, 0, 0, NULL);
    }
    return Handle;
}


HANDLE
FrsCreateWaitableTimer(
    IN  BOOL    ManualReset
)
/*++

Routine Description:

    Support routine to create a waitable timer.

Arguments:

    ManualReset - TRUE if not synchronization timer

Return Value:

    Address of the created waitable timer handle.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateWaitableTimer:"
    HANDLE  Handle;

    Handle = CreateWaitableTimer(NULL, ManualReset, NULL);
    if (!HANDLE_IS_VALID(Handle)) {
        RaiseException(ERROR_INVALID_HANDLE, 0, 0, NULL);
    }
    return Handle;
}


ULONG
FrsUuidCreate(
    OUT GUID *Guid
    )
/*++

Routine Description:

    Frs wrapper on UuidCreate() to generate an exception if we fail
    to get correctly formed Guid.  In particular UuidCreate can have
    problems getting the network address.


        RPC_S_OK - The operation completed successfully.

        RPC_S_UUID_NO_ADDRESS - We were unable to obtain the ethernet or
            token ring address for this machine.

        RPC_S_UUID_LOCAL_ONLY - On NT & Chicago if we can't get a
            network address.  This is a warning to the user, the
            UUID is still valid, it just may not be unique on other machines.

        RPC_S_OUT_OF_MEMORY - Returned as needed.

Arguments:

    Guid - Pointer to returned guid.

Return Value:

    FrsStatus

--*/
{
#undef DEBSUB
#define DEBSUB "FrsUuidCreate:"
    DWORD       MsgBufSize;
    WCHAR       MsgBuf[MAX_PATH + 1];
    RPC_STATUS  RpcStatusFromUuidCreate;

    RpcStatusFromUuidCreate = UuidCreate(Guid);
    if (RpcStatusFromUuidCreate == RPC_S_OK) {
        return FrsErrorSuccess;
    }

    DPRINT_WS(0, "ERROR - Failed to get GUID.", RpcStatusFromUuidCreate);

    if (RpcStatusFromUuidCreate == RPC_S_UUID_NO_ADDRESS) {
        DPRINT(0, "++ UuidCreate() returned RPC_S_UUID_NO_ADDRESS.\n");
    } else
    if (RpcStatusFromUuidCreate == RPC_S_UUID_LOCAL_ONLY) {
        DPRINT(0, "++ UuidCreate() returned RPC_S_UUID_LOCAL_ONLY.\n");
    } else
    if (RpcStatusFromUuidCreate == RPC_S_OUT_OF_MEMORY) {
        DPRINT(0, "++ UuidCreate() returned RPC_S_OUT_OF_MEMORY.\n");
    }

    //
    // Format the error code
    //
    MsgBufSize = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK,
                               NULL,
                               RpcStatusFromUuidCreate,
                               0,
                               MsgBuf,
                               MAX_PATH + 1,
                               NULL);
    //
    // No message; use the status code
    //
    if (!MsgBufSize) {
        swprintf(MsgBuf, L"%d (0x%08x)", RpcStatusFromUuidCreate, RpcStatusFromUuidCreate);
    }

    //
    // This is very bad.  Any member that can't generate proper GUIDs is
    // busted.
    //
    // Shutdown with an event log message
    //
    EPRINT2(EVENT_FRS_CANNOT_CREATE_UUID, ComputerName, MsgBuf);

    //
    // EXIT BECAUSE THE CALLERS CANNOT HANDLE THIS ERROR.
    //
    DPRINT(0, ":S: NTFRS IS EXITING W/O CLEANUP! SERVICE CONTROLLER RESTART EXPECTED.\n");
    DEBUG_FLUSH();
    exit(RpcStatusFromUuidCreate);

    return FrsErrorInvalidGuid;
}


LONG
FrsGuidCompare (
    IN GUID *Guid1,
    IN GUID *Guid2
    )

/*++

Routine Description:

    Do a simple, straight unsigned compare of two GUIDs.
    UuidCompare doesn't do this.  I don't know what kind of comparison it
    does.

Arguments:

    Guid1 - The first Guid
    Guid2 - The second Guid.

Return Value:

    Result:  -1 if Guid1 < Guid2
              0 if Guid1 = Guid2
             +1 if Guid1 > Guid2
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsGuidCompare:"

    PULONG p1 = (PULONG) Guid1;
    PULONG p2 = (PULONG) Guid2;

    p1 += 4;
    p2 += 4;

    while (p1 != (PVOID) Guid1) {
        p1 -= 1;
        p2 -= 1;

        if (*p1 > *p2) {
            return 1;
        }

        if (*p1 < *p2) {
            return -1;
        }
    }

    return 0;
}


VOID
FrsNowAsFileTime(
    IN  PLONGLONG   Now
)
/*++

Routine Description:

    Return the current time as a filetime in longlong format.

Arguments:

    Now - address of longlong to receive current time.

Return Value:

    Fill in Now with current file time

--*/
{
#undef DEBSUB
#define DEBSUB "FrsNowAsFileTime:"
    FILETIME    FileTime;

    GetSystemTimeAsFileTime(&FileTime);
    COPY_TIME(Now, &FileTime);
}


char *Days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

char *Months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

VOID
FileTimeToString(
    IN FILETIME *FileTime,
    OUT PCHAR     Buffer
    )
/*++

Routine Description:

    Convert a FileTime (UTC time) to an ANSI date/time string in the
    local time zone.

Arguments:

    Time - ptr to a FILETIME
    Str  - a string of at least TIME_STRING_LENGTH bytes to receive the time.

Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "FileTimeToString:"

    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;

    Buffer[0] = '\0';

    if (FileTime->dwHighDateTime != 0 || FileTime->dwLowDateTime != 0) {
        if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
            !FileTimeToSystemTime(&LocalFileTime, &SystemTime)) {
            strcpy(Buffer, "Time???");
            return;
        }

        if (_snprintf(Buffer, TIME_STRING_LENGTH, "%s %s %2d, %4d %02d:%02d:%02d",
                      Days[SystemTime.wDayOfWeek],Months[SystemTime.wMonth - 1],
                      SystemTime.wDay,SystemTime.wYear,SystemTime.wHour,
                      SystemTime.wMinute,SystemTime.wSecond) < 0) {

            Buffer[TIME_STRING_LENGTH - 1] ='\0';
        }
    }

    return;
}


VOID
FileTimeToStringClockTime(
    IN FILETIME *FileTime,
    OUT PCHAR     Buffer
    )
/*++

Routine Description:

    Convert a FileTime (UTC time) to an ANSI time string in the
    local time zone.

Arguments:

    Time - ptr to a FILETIME
    Str  - a string to hold hh:mm:ss\0.  (9 bytes min.)

Return Value:

    None

--*/
{
#undef DEBSUB
#define DEBSUB  "FileTimeToStringClockTime:"

    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;

    Buffer[0] = '\0';

    if (FileTime->dwHighDateTime == 0 && FileTime->dwLowDateTime == 0) {
        strcpy(Buffer, "??:??:??");
        return;
    }
    if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
        !FileTimeToSystemTime(&LocalFileTime, &SystemTime)) {
        strcpy(Buffer, "??:??:??");
        return;
    }

    if (_snprintf(Buffer, 9, "%02d:%02d:%02d",
            SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond) < 0) {
        Buffer[9-1] = '\0';
    }
}


DWORD
GeneralizedTimeToSystemTime(
    IN PWCHAR        szTime,
    OUT PSYSTEMTIME  psysTime
    )
/*++

Routine Description:

    Converts a generalized time string to the equivalent system time.
    (Taken from the repadmin DS code.  converted to swscanf)

Parameters:
    szTime - [Supplies] This is string containing generalized time.
    psysTime - [Returns] This is the SYSTEMTIME struct to be returned.

Return Value:

    Win 32 Error code, note could only result from invalid parameter.

  --*/
{
   ULONG       len;
   ULONG       yr=0, mo=0, day=0, hr=0, min=0, sec=0;
   LONG        Fields;

    //
    // param sanity
    //
    if ((szTime == NULL) || (psysTime == NULL)) {
       return ERROR_INVALID_PARAMETER;
    }

    len = wcslen(szTime);

    if( len < 15 || szTime[14] != '.') {
       return ERROR_INVALID_PARAMETER;
    }

    // initialize
    memset(psysTime, 0, sizeof(SYSTEMTIME));

    //
    // yyyymmddhhmmss.
    //

    Fields = swscanf(szTime, L"%04d%02d%02d%02d%02d%02d",
                     &yr, &mo, &day, &hr, &min, &sec);

    psysTime->wYear   = (USHORT) yr;
    psysTime->wMonth  = (USHORT) mo;
    psysTime->wDay    = (USHORT) day;
    psysTime->wHour   = (USHORT) hr;
    psysTime->wMinute = (USHORT) min;
    psysTime->wSecond = (USHORT) sec;

    if (Fields != 6) {
        DPRINT2(1, "Time convert error on '%ws', Fields = %d\n", szTime, Fields);
        DPRINT6(1, "Time results: '%d' '%d' '%d' '%d' '%d' '%d' \n",
                                   yr,  mo,  day,  hr, min, sec);
    }

    return (Fields == 6 ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER);


}


VOID
FormatGeneralizedTime(
    IN PWCHAR  GTimeStr,
    IN ULONG   Length,
    OUT PCHAR  Buffer
    )
/*++

Routine Description:

    Convert a generalized time string to a printable form.
    (taken from the DS code)

Arguments:

    GTimeStr -- Generalized time string from DS.
    Length - Size of buffer in bytes.
    Buffer - buffer with returned string.

Return Value:

    Buffer containing printable string.

--*/
{
#undef DEBSUB
#define DEBSUB "FormatGeneralizedTime:"

    TIME_ZONE_INFORMATION tz;
    DWORD WStatus;
    BOOL bstatus;
    SYSTEMTIME sysTime, localTime;

    if ((Length < 12) || (Buffer == NULL) || (GTimeStr == NULL)) {
        return;
    }

    strcpy(Buffer, "<unknown>");

    GeneralizedTimeToSystemTime(GTimeStr, &sysTime);

    WStatus = GetTimeZoneInformation(&tz);
    if ( WStatus == TIME_ZONE_ID_INVALID ) {
        DPRINT_WS(1, "Cannot format time field. ", GetLastError());

    } else {

        bstatus = SystemTimeToTzSpecificLocalTime(
                        (WStatus == TIME_ZONE_ID_UNKNOWN) ? NULL : &tz,
                        &sysTime,
                        &localTime );

        if ( bstatus ) {
            if ( _snprintf(Buffer, Length, "%d/%d/%d %d:%d:%d %S %S [%d]",
                      localTime.wMonth, localTime.wDay, localTime.wYear,
                      localTime.wHour, localTime.wMinute, localTime.wSecond,
                      tz.StandardName, tz.DaylightName, tz.Bias) < 0) {
                Buffer[Length - 1]='\0';
            }
        } else {
            if (_snprintf(Buffer, Length, "%d/%d/%d %d:%d:%d UNC",
                      localTime.wMonth, localTime.wDay, localTime.wYear,
                      localTime.wHour, localTime.wMinute, localTime.wSecond) < 0) {
                Buffer[Length - 1]='\0';
            }
        }
    }
}






VOID
GuidToStr(
    IN GUID  *pGuid,
    OUT PCHAR  s
    )
/*++

Routine Description:

    Convert a GUID to a string.

    Based on code from Mac McLain.

Arguments:

    pGuid - ptr to the GUID.

    s - The output character buffer.
        Must be at least GUID_CHAR_LEN (36 bytes) long.

Function Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "GuidToStr:"

    if (pGuid != NULL) {
        sprintf(s, "%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
               pGuid->Data1,
               pGuid->Data2,
               pGuid->Data3,
               pGuid->Data4[0],
               pGuid->Data4[1],
               pGuid->Data4[2],
               pGuid->Data4[3],
               pGuid->Data4[4],
               pGuid->Data4[5],
               pGuid->Data4[6],
               pGuid->Data4[7]);
    } else {
        sprintf(s, "<ptr-null>");
    }
}


VOID
GuidToStrW(
    IN GUID  *pGuid,
    OUT PWCHAR  ws
    )
/*++

Routine Description:

    Convert a GUID to a wide string.
    Functions expects that the passed in string is large
    enough to hold the string form of a GUID.
    WCHAR ws[GUID_CHAR_LEN + 1];


Arguments:

    pGuid - ptr to the GUID.

    ws - The output character buffer.
        Must be at least GUID_CHAR_LEN (36 wchars) long.

Function Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "GuidToStrW:"

    if (pGuid) {
        swprintf(ws, L"%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
               pGuid->Data1,
               pGuid->Data2,
               pGuid->Data3,
               pGuid->Data4[0],
               pGuid->Data4[1],
               pGuid->Data4[2],
               pGuid->Data4[3],
               pGuid->Data4[4],
               pGuid->Data4[5],
               pGuid->Data4[6],
               pGuid->Data4[7]);
    } else {
        swprintf(ws, L"<ptr-null>");
    }
}


BOOL
StrWToGuid(
    IN  PWCHAR ws,
    OUT GUID  *pGuid
    )
/*++

Routine Description:

    Convert a wide string into a GUID. The wide string was created with
    GuidToStrW().

Arguments:

    pGuid - ptr to the output GUID.

    ws - The character buffer.

Function Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "StrWToGuid:"
    DWORD   Fields;
    UCHAR   Guid[sizeof(GUID) + sizeof(DWORD)]; // 3 byte overflow
    GUID    *lGuid = (GUID *)Guid;

    FRS_ASSERT(ws && pGuid);

    Fields = swscanf(ws, L"%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                     &lGuid->Data1,
                     &lGuid->Data2,
                     &lGuid->Data3,
                     &lGuid->Data4[0],
                     &lGuid->Data4[1],
                     &lGuid->Data4[2],
                     &lGuid->Data4[3],
                     &lGuid->Data4[4],
                     &lGuid->Data4[5],
                     &lGuid->Data4[6],
                     &lGuid->Data4[7]);
    COPY_GUID(pGuid, lGuid);
    return (Fields == 11);
}


VOID
StrToGuid(
    IN PCHAR  s,
    OUT GUID  *pGuid
    )
/*++

Routine Description:

    Convert a string in GUID display format to an object ID that
    can be used to lookup a file.

    based on a routine by Mac McLain

Arguments:

    pGuid - ptr to the output GUID.

    s - The input character buffer in display guid format.
        e.g.:  b81b486b-c338-11d0-ba4f0000f80007df

        Must be at least GUID_CHAR_LEN (35 bytes) long.

Function Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "StrToGuid:"
    UCHAR   Guid[sizeof(GUID) + sizeof(DWORD)]; // 3 byte overflow
    GUID    *lGuid = (GUID *)Guid;

    FRS_ASSERT(s && pGuid);

    sscanf(s, "%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
           &lGuid->Data1,
           &lGuid->Data2,
           &lGuid->Data3,
           &lGuid->Data4[0],
           &lGuid->Data4[1],
           &lGuid->Data4[2],
           &lGuid->Data4[3],
           &lGuid->Data4[4],
           &lGuid->Data4[5],
           &lGuid->Data4[6],
           &lGuid->Data4[7]);
    COPY_GUID(pGuid, lGuid);
}





NTSTATUS
SetupOnePrivilege (
    ULONG Privilege,
    PUCHAR PrivilegeName
    )
{

#undef DEBSUB
#define DEBSUB "SetupOnePrivilege:"

    BOOLEAN PreviousPrivilegeState = FALSE;
    NTSTATUS Status;

    Status = RtlAdjustPrivilege(Privilege, TRUE, FALSE, &PreviousPrivilegeState);

    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, ":S: Your login does not have `%s' privilege.\n", PrivilegeName);

        if (Status != STATUS_PRIVILEGE_NOT_HELD) {
            DPRINT_NT(0, ":S: RtlAdjustPrivilege failed :", Status);
        }
        DPRINT(0, ":S: Update your: User Manager -> Policies -> User Rights.\n");

    } else {
        DPRINT2(4, ":S: Added `%s' privilege (previous: %s)\n",
                PrivilegeName, (PreviousPrivilegeState ? "Enabled" : "Disabled"));
    }

    return Status;
}




PWCHAR
FrsGetResourceStr(
    LONG  Id
)
/*++

Routine Description:

    This routine Loads the specified resource string.
    It allocates a buffer and returns the ptr.

Arguments:

    Id - An FRS_IDS_xxx identifier.

Return Value:

    Ptr to allocated string.
    The caller must free the buffer with a call to FrsFree().

--*/
#undef DEBSUB
#define DEBSUB "FrsGetResourceStr:"
{

    LONG  N = 0;
    WCHAR WStr[200];
    HINSTANCE hInst = NULL;
    PWCHAR MessageFile = NULL;

    //
    // ID Must be Valid.
    //
    if ((Id <= IDS_TABLE_START) || (Id > IDS_TABLE_END)) {
      DPRINT1(0, "++ Resource string ID is out of range - %d\n", Id);
      Id = IDS_MISSING_STRING;
    }

    WStr[0] = UNICODE_NULL;

    CfgRegReadString(FKC_FRS_MESSAGE_FILE_PATH, NULL, 0, &MessageFile);

    hInst = LoadLibrary(MessageFile);

    if (hInst != NULL) {
        N = LoadString(hInst, Id, WStr, ARRAY_SZ(WStr));

        if (N == 0) {
          DPRINT_WS(0, "ERROR - Failed to get resource string.", GetLastError());
        }

       FreeLibrary(hInst);
    } else {

        DPRINT_WS(0, "ERROR - Failed to LoadLibrary.", GetLastError());
    }


    FrsFree(MessageFile);
    return FrsWcsDup(WStr);
}



DWORD
FrsOpenSourceFileW(
    OUT PHANDLE     Handle,
    IN  LPCWSTR     lpFileName,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG       CreateOptions
    )
/*++

Routine Description:

    This function opens the specified file with backup intent for
    reading all the files attributes, ...

Arguments:

    Handle - A pointer to a handle to return an open handle.

    lpFileName - Represents the name of the file or directory to be opened.

    DesiredAccess

    CreateOptions

Return Value:

    Win32 Error status.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenSourceFileW:"

    NTSTATUS            Status;
    DWORD               WStatus = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      FileName;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOLEAN             b;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID               FreeBuffer;
    ULONG               FileAttributes;
    ULONG               CreateDisposition;
    ULONG               ShareMode;

    //
    // Convert the Dos name to an NT name.
    //
    b = RtlDosPathNameToNtPathName_U(lpFileName, &FileName, NULL, &RelativeName);
    if ( !b ) {
        return ERROR_INVALID_NAME;
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    CreateDisposition = FILE_OPEN;               // Open existing file

    ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

    FileAttributes = FILE_ATTRIBUTE_NORMAL;

    Status = NtCreateFile(Handle,
                          DesiredAccess,
                          &Obja,
                          &IoStatusBlock,
                          NULL,              // Initial allocation size
                          FileAttributes,
                          ShareMode,
                          CreateDisposition,
                          CreateOptions,
                          NULL, 0);

    if (!NT_SUCCESS(Status)) {
        *Handle = INVALID_HANDLE_VALUE;
        //
        // Get a Win32 status.
        //
        WStatus = FrsSetLastNTError(Status);

        DPRINT_NT(0, "NtCreateFile failed :", Status);

        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            //
            // Standard Win32 mapping for this is ERROR_ALREADY_EXISTS.
            // Change it.
            //
            WStatus = ERROR_FILE_EXISTS;
            SetLastError(ERROR_FILE_EXISTS);
        }

        DPRINT1_WS(0, "++ CreateFile failed on file %ws;", FileName.Buffer, WStatus);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    return WStatus;
}



DWORD
FrsOpenSourceFile2W(
    OUT PHANDLE     Handle,
    IN  LPCWSTR     lpFileName,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG       CreateOptions,
    IN  ULONG       ShareMode
    )
/*++

Routine Description:

    This function opens the specified file with backup intent for
    reading all the files attributes, ...
    Like  FrsOpenSourceFileW but also accepts the sharing mode parameter.

Arguments:

    Handle - A pointer to a handle to return an open handle.

    lpFileName - Represents the name of the file or directory to be opened.

    DesiredAccess

    CreateOptions

    ShareMode -  File sharing mode for NtCreateFile.

Return Value:

    Win32 Error status.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenSourceFile2W:"

    NTSTATUS            Status;
    DWORD               WStatus = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      FileName;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOLEAN             b;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID               FreeBuffer;
    ULONG               FileAttributes;
    ULONG               CreateDisposition;

    //
    // Convert the Dos name to an NT name.
    //
    b = RtlDosPathNameToNtPathName_U(lpFileName, &FileName, NULL, &RelativeName);
    if ( !b ) {
        return ERROR_INVALID_NAME;
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    CreateDisposition = FILE_OPEN;               // Open existing file

    FileAttributes = FILE_ATTRIBUTE_NORMAL;

    Status = NtCreateFile(Handle,
                          DesiredAccess,
                          &Obja,
                          &IoStatusBlock,
                          NULL,              // Initial allocation size
                          FileAttributes,
                          ShareMode,
                          CreateDisposition,
                          CreateOptions,
                          NULL, 0);

    if (!NT_SUCCESS(Status)) {
        *Handle = INVALID_HANDLE_VALUE;
        //
        // Get a Win32 status.
        //
        WStatus = FrsSetLastNTError(Status);

        DPRINT_NT(0, "NtCreateFile failed :", Status);

        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            //
            // Standard Win32 mapping for this is ERROR_ALREADY_EXISTS.
            // Change it.
            //
            WStatus = ERROR_FILE_EXISTS;
            SetLastError(ERROR_FILE_EXISTS);
        }

        DPRINT1_WS(0, "++ CreateFile failed on file %ws;", FileName.Buffer, WStatus);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    return WStatus;
}


BOOL
FrsGetFileInfoByHandle(
    IN PWCHAR Name,
    IN HANDLE Handle,
    OUT PFILE_NETWORK_OPEN_INFORMATION  FileOpenInfo
    )
/*++

Routine Description:

    Return the network file info for the specified handle.

Arguments:

    Name - File's name for printing error messages

    Handle - Open file handle

    FileOpenInfo - Returns the file FILE_NETWORK_OPEN_INFORMATION data.

Return Value:

    TRUE  - FileOpenInfo contains the file's info
    FALSE - Contents of FileOpenInfo is undefined

--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetFileInfoByHandle:"
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Return some file info
    //
    Status = NtQueryInformationFile(Handle,
                                    &IoStatusBlock,
                                    FileOpenInfo,
                                    sizeof(FILE_NETWORK_OPEN_INFORMATION),
                                    FileNetworkOpenInformation);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "NtQueryInformationFile failed :", Status);
        return FALSE;
    }
    return TRUE;
}


DWORD
FrsGetFileInternalInfoByHandle(
    IN HANDLE Handle,
    OUT PFILE_INTERNAL_INFORMATION  InternalFileInfo
    )
/*++

Routine Description:

    Return the internal file info for the specified handle.

Arguments:

    Handle - Open file handle

    InternalFileInfo - Basically, file's reference number (fid)

Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetFileInternalInfoByHandle:"
    NTSTATUS        Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Return some file info
    //
    Status = NtQueryInformationFile(Handle,
                                    &IoStatusBlock,
                                    InternalFileInfo,
                                    sizeof(FILE_INTERNAL_INFORMATION),
                                    FileInternalInformation);
    return FrsSetLastNTError(Status);
}



DWORD
FrsReadFileDetails(
    IN     HANDLE                         Handle,
    IN     LPCWSTR                        FileName,
    OUT    PFILE_OBJECTID_BUFFER          ObjectIdBuffer,
    OUT    PLONGLONG                      FileIdBuffer,
    OUT    PFILE_NETWORK_OPEN_INFORMATION FileNetworkOpenInfo,
    IN OUT BOOL                           *ExistingOid
    )
/*++

Routine Description:

    This routine reads the object ID.  If there is no
    object ID on the file we put one on it.


Arguments:

    Handle -- The file handle of an opened file.

    FileName -- The name of the file.  For error messages only.

    ObjectIdBuffer -- The output buffer to hold the object ID.

    FileIdBuffer -- Returns the NTFS FileReference (FileId).

    FileNetworkOpenInfo -- returns FILE_NETWORK_OPEN_INFORMATION

    ExistingOid -- INPUT:  TRUE means use existing File OID if found.
                   RETURN:  TRUE means an existing File OID was used.

Return Value:

    Returns the Win Status of the last error found, or success.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsReadFileDetails:"


    FILE_INTERNAL_INFORMATION FileReference;

    NTSTATUS        Status;
    IO_STATUS_BLOCK Iosb;
    LONG            Loop;
    BOOL            CallerSupplied = FALSE;

    CHAR GuidStr[GUID_CHAR_LEN];

    //
    // Get the file ID.
    //
    Status = NtQueryInformationFile(Handle,
                                    &Iosb,
                                    FileIdBuffer,
                                    sizeof(FILE_INTERNAL_INFORMATION),
                                    FileInternalInformation);

    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "++ ERROR - QueryInfoFile FileID failed :", Status);
        FrsSetLastNTError(Status);
    }

    //
    // Get file times, size, attributes.
    //
    Status = NtQueryInformationFile(Handle,
                                    &Iosb,
                                    FileNetworkOpenInfo,
                                    sizeof(FILE_NETWORK_OPEN_INFORMATION),
                                    FileNetworkOpenInformation);

    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "++ ERROR - QueryInfoFile FileNetworkOpenInformation failed :", Status);
        FrsSetLastNTError(Status);
    }


    if (!*ExistingOid) {
        //
        // Set up to slam a new OID on the file.
        //
        CallerSupplied = TRUE;
        ZeroMemory(ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));
        FrsUuidCreate((GUID *)ObjectIdBuffer->ObjectId);
    }

    return FrsGetOrSetFileObjectId(Handle, FileName, CallerSupplied, ObjectIdBuffer);

}



#if 0
    // This may not be needed.

ULONG
FrsReadFileSecurity(
    IN HANDLE Handle,
    IN OUT PTABLE_CTX TableCtx,
    IN PWCHAR FileName
    )
/*++

Routine Description:

    This routine gets the security descriptor from the file.  The returned data
    is stored into the security descriptor field in the data record allocated
    with the table context.  If the default buffer is not large enough
    a larger buffer is allocated.

Arguments:

    Handle    -- Handle to open file from which to extract the security desc.
    TableCtx  -- The table context struct where the security descriptor is
                 to be written.  It must be an IDTable.
    FileName  -- The full filename.  For error messages only.

Return Value:

    Returns the WIN32 STATUS error status.

    Note: In the event that GetFileSecurity returns ERROR_NO_SECURITY_ON_OBJECT
    we release the buffer, setting the length to zero, and return ERROR_SUCCESS.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsReadFileSecurity:"

    ULONG WStatus;
    NTSTATUS Status;
    ULONG BufLen;
    PSECURITY_DESCRIPTOR Buffer;
    ULONG BufNeeded;
    ULONG ActualLen;
    JET_ERR             jerr;
    PJET_SETCOLUMN      JSetColumn;

    //
    // Check the table type is an IDTable.
    //
    if (TableCtx->TableType != IDTablex) {
        DPRINT1(0, "++ ERROR - Invalid Table Type: %d\n", TableCtx->TableType);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get ptrs to the Jet SetColumn array and the buffer address & length
    //
    JSetColumn = TableCtx->pJetSetCol;

    Buffer = (PSECURITY_DESCRIPTOR) JSetColumn[SecDescx].pvData;
    BufLen = JSetColumn[SecDescx].cbData;

    //
    // The security descriptor is a variable length binary field that
    // must have a type/size prefix.
    //
    ((PFRS_NODE_HEADER) Buffer)->Size = (USHORT) BufLen;
    ((PFRS_NODE_HEADER) Buffer)->Type = 0;
    BufNeeded = 0;

    //
    // Check that the security descriptor buffer looks reasonable.
    //
    if (Buffer == NULL) {
        DPRINT2(0, "++ ERROR - Invalid SD buffer. Buffer Addr: %08x, Len: %d\n",
                Buffer, BufLen);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Now go get all the security information.
    //
    while (TRUE) {
        BufLen -= sizeof(FRS_NODE_HEADER);  // for type / size prefix.
        (PCHAR)Buffer += sizeof(FRS_NODE_HEADER);

        Status = NtQuerySecurityObject(
            Handle,
            SACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
            Buffer,
            BufLen,
            &BufNeeded);

        if (NT_SUCCESS(Status)) {

            ActualLen = GetSecurityDescriptorLength(Buffer) + sizeof(FRS_NODE_HEADER);
            BufLen += sizeof(FRS_NODE_HEADER);

            DPRINT3(5, "++ GetFileSecurity-1 Buflen: %d, Bufneeded: %d, ActualLen: %d\n",
                    BufLen, BufNeeded, ActualLen);
            //
            // If current buffer size is more than 16 bytes larger than needed AND
            // also more than 5% greater than needed then shrink the buffer but
            // keep the data.
            //

            if (((BufLen-ActualLen) > 16) &&
                (BufLen > (ActualLen + ActualLen/20))) {

                DPRINT3(5, "++ GetFileSecurity-2 Reducing buffer, Buflen: %d, Bufneeded: %d, ActualLen: %d\n",
                        BufLen, BufNeeded, ActualLen);
                //
                // Unused space in field buffer is greater than 6%.
                // Reduce the buffer size but keep the data.
                //
                jerr = DbsReallocateFieldBuffer(TableCtx, SecDescx, ActualLen, TRUE);
                if (!JET_SUCCESS(jerr)) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                Buffer = (PSECURITY_DESCRIPTOR) JSetColumn[SecDescx].pvData;
                ((PFRS_NODE_HEADER) Buffer)->Size = (USHORT) ActualLen;
                ((PFRS_NODE_HEADER) Buffer)->Type = 0;
            }
            return ERROR_SUCCESS;
        }

        //
        // Set the win32 error code and message string.
        //
        WStatus = FrsSetLastNTError(Status);

        //
        // If not enough buffer reallocate larger buffer.
        //
        if (WStatus == ERROR_INSUFFICIENT_BUFFER) {

            //
            // Reallocate the buffer for the security descriptor.
            //
            jerr = DbsReallocateFieldBuffer(TableCtx, SecDescx, BufNeeded, FALSE);

            if (!JET_SUCCESS(jerr)) {
                DPRINT_JS(0, "++ ERROR - DbsReallocateFieldBuffer failed.", jerr);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            Buffer = (PSECURITY_DESCRIPTOR) JSetColumn[SecDescx].pvData;
            ((PFRS_NODE_HEADER) Buffer)->Size = (USHORT) BufNeeded;
            ((PFRS_NODE_HEADER) Buffer)->Type = 0;
            //
            // Get new buffer params and try again to get security information.
            //
            BufLen = BufNeeded;
            continue;
        }

        //
        // Check for ERROR_NO_SECURITY_ON_OBJECT and release the buffer so we
        // don't waste space in the database.
        //
        if (WStatus == ERROR_NO_SECURITY_ON_OBJECT) {
            DPRINT2(0, "++ ERROR - GetFileSecurity-3 (NO_SEC) Buflen: %d, Bufneeded: %d\n", BufLen, BufNeeded);

            //
            // Free the buffer and set the length to zero.
            //
            DbsReallocateFieldBuffer(TableCtx, SecDescx, 0, FALSE);

            return ERROR_SUCCESS;
        }

        //
        // Some other error.
        //
        DPRINT_WS(0, "++ ERROR - GetFileSecurity-4;", WStatus);
        return WStatus;
    }
}
#endif



PWCHAR
FrsGetFullPathByHandle(
    IN PWCHAR   Name,
    IN HANDLE   Handle
    )
/*++
Routine Description:
    Return a copy of the handle's full pathname. Free with FrsFree().

Arguments:
    Name
    Handle

Return Value:
    Return a copy of the handle's full pathname. Free with FrsFree().
--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetFullPathByHandle"

    NTSTATUS          Status;
    IO_STATUS_BLOCK   IoStatusBlock;
    DWORD             BufferSize;
    PCHAR             Buffer;
    PWCHAR            RetFileName = NULL;
    CHAR              NameBuffer[sizeof(ULONG) + (sizeof(WCHAR)*(MAX_PATH+1))];
    PFILE_NAME_INFORMATION    FileName;

    if (!HANDLE_IS_VALID(Handle)) {
        return NULL;
    }

    BufferSize = sizeof(NameBuffer);
    Buffer = NameBuffer;

again:
    FileName = (PFILE_NAME_INFORMATION) Buffer;
    FileName->FileNameLength = BufferSize - (sizeof(ULONG) + sizeof(WCHAR));
    Status = NtQueryInformationFile(Handle,
                                    &IoStatusBlock,
                                    FileName,
                                    BufferSize - sizeof(WCHAR),
                                    FileNameInformation);
    if (NT_SUCCESS(Status) ) {
        FileName->FileName[FileName->FileNameLength/2] = UNICODE_NULL;
        RetFileName = FrsWcsDup(FileName->FileName);
    } else {
        //
        // Try a larger buffer
        //
        if (Status == STATUS_BUFFER_OVERFLOW) {
            DPRINT2(4, "++ Buffer size %d was too small for %ws\n",
                    BufferSize, Name);
            BufferSize = FileName->FileNameLength + sizeof(ULONG) + sizeof(WCHAR);
            if (Buffer != NameBuffer) {
                FrsFree(Buffer);
            }
            Buffer = FrsAlloc(BufferSize);
            DPRINT2(4, "++ Retrying with buffer size %d for %ws\n",
                    BufferSize, Name);
            goto again;
        }
        DPRINT1_NT(0, "++ NtQueryInformationFile - FileNameInformation failed.",
                   Name, Status);
    }

    //
    // A large buffer was allocated if the file's full
    // name could not fit into MAX_PATH chars.
    //
    if (Buffer != NameBuffer) {
        FrsFree(Buffer);
    }
    return RetFileName;
}


PWCHAR
FrsGetTrueFileNameByHandle(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    OUT PLONGLONG DirFileID
    )
/*++
Routine Description:
    Return a copy of the filename part associated with this handle.
    Free with FrsFree().

Arguments:
    Name
    Handle
    DirFileID - If non-null, return the parent File ID.

Return Value:
    Return a copy of the filename part associated with this handle.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetTrueFileNameByHandle"
    PWCHAR  Path;
    PWCHAR  File;
    ULONG   Len;

    Path = FrsGetFullPathByHandle(Name, Handle);
    if (!Path) {
        return NULL;
    }
    for (Len = wcslen(Path); Len && Path[Len] != L'\\'; --Len);
    File = FrsWcsDup(&Path[Len + 1]);
    FrsFree(Path);


    if (DirFileID != NULL) {
        FrsReadFileParentFid(Handle, DirFileID);
    }

    return File;
}




DWORD
FrsOpenFileRelativeByName(
    IN  HANDLE     VolumeHandle,
    IN  PULONGLONG FileReferenceNumber,
    IN  PWCHAR     FileName,
    IN  GUID       *ParentGuid,
    IN  GUID       *FileGuid,
    OUT HANDLE     *Handle
    )
/*++
Routine Description:

    Open the file specified by its true name using the FID for either
    a rename or delete installation. If the FID is null then use the
    Filename as given.

    FrsOpenFileRelativeByName(Coe->NewReplica->pVme->VolumeHandle,
                              &Coe->FileReferenceNumber, // or NULL
                              Coc->FileName,
                              &Coc->OldParentGuid,
                              &Coc->FileGuid
                              &Handle);
Arguments:

    VolumeHandle,        - handle to root of the drive
    FileReferenceNumber  - FID for the file in question (NULL if supplied
                           filename is valid)
    FileName,            - Filename
    *ParentGuid,         - ptr to the object ID for the file's parent dir.
    *FileGuid,           - ptr to the object ID for the file (for checking,
                           NULL if no check needed).
    *Handle              - Returned handle for open file.

Return Value:

    Handle and win32 status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenFileRelativeByName"

    PWCHAR                  TrueFileName;
    DWORD                   WStatus;

    *Handle = INVALID_HANDLE_VALUE;

    if (FileReferenceNumber != NULL) {
        //
        // Open the source file and get the current "True" File name.
        //
        WStatus = FrsOpenSourceFileById(Handle,
                                        NULL,
                                        NULL,
                                        VolumeHandle,
                                        FileReferenceNumber,
                                        FILE_ID_LENGTH,
//                                        READ_ACCESS,
                                        READ_ATTRIB_ACCESS,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(4, "++ Couldn't open file %ws;", FileName, WStatus);
            return WStatus;
        }

        //
        // File's TrueFileName
        //
        TrueFileName = FrsGetTrueFileNameByHandle(FileName, *Handle, NULL);
        FRS_CLOSE(*Handle);

        if (TrueFileName == NULL) {
            DPRINT1(4, "++ Couldn't get base name for %ws\n", FileName);
            WIN_SET_FAIL(WStatus);
            return WStatus;
        }
    } else {
        TrueFileName = FileName;
    }

    //
    // Open the file relative to the parent using the true filename.
    //
    WStatus = FrsCreateFileRelativeById(Handle,
                                        VolumeHandle,
                                        ParentGuid,
                                        OBJECT_ID_LENGTH,
                                        FILE_ATTRIBUTE_NORMAL,
                                        TrueFileName,
                                        (USHORT)(wcslen(TrueFileName) * sizeof(WCHAR)),
                                        NULL,
                                        FILE_OPEN,
//                                        DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES);
                                        DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY);


    if (FileReferenceNumber != NULL) {
        FrsFree(TrueFileName);
    }

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ Couldn't open relative file %ws;", FileName, WStatus);
        return WStatus;
    }

    //
    // Get the file's oid and check it against the value supplied.
    //
    if (FileGuid != NULL) {
        WStatus = FrsCheckObjectId(FileName, *Handle, FileGuid);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, "++ Object id mismatch for file %ws;", FileName, WStatus);
            FRS_CLOSE(*Handle);
        }
    }

    return WStatus;
}


DWORD
FrsDeleteFileRelativeByName(
    IN  HANDLE       VolumeHandle,
    IN  GUID         *ParentGuid,
    IN  PWCHAR       FileName,
    IN  PQHASH_TABLE FrsWriteFilter
    )
/*++
Routine Description:

    Delete the file or dir subtree specified by its name relative to
    the parent dir specified by its object ID (guid).

Arguments:

    VolumeHandle,  - handle to root of the drive
    *ParentGuid,   - ptr to the object ID for the file's parent dir.
    FileName,      - Filename
    FrsWriteFilter - Write filter to use for dampening (NULL if undampened).
                     e.g. Coe->NewReplica->pVme->FrsWriteFilter

Return Value:

    Win32 status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteFileRelativeByName"

    DWORD   WStatus;
    HANDLE  Handle  = INVALID_HANDLE_VALUE;

    //
    // Open the file
    //
    WStatus = FrsOpenFileRelativeByName(VolumeHandle,
                                        NULL,
                                        FileName,
                                        ParentGuid,
                                        NULL,
                                        &Handle);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ Couldn't open file %ws for delete;", FileName, WStatus);
        //
        // File has already been deleted; done
        //
        if (WIN_NOT_FOUND(WStatus)) {
            DPRINT1(4, "++ %ws is already deleted\n", FileName);
            WStatus = ERROR_SUCCESS;
        }
        goto out;
    }
    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    if (FrsWriteFilter) {
        WStatus = FrsMarkHandle(VolumeHandle, Handle);
        DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%ws);", FileName, WStatus);
    }

    //
    // Reset the attributes that prevent deletion
    //
    WStatus = FrsResetAttributesForReplication(FileName, Handle);
    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }

    //
    // Mark the file for delete
    //
    WStatus = FrsDeleteByHandle(FileName, Handle);

    if (!WIN_SUCCESS(WStatus)) {
        //
        // If this was a non-empty dir then delete the subtree.
        //
        if (WStatus == ERROR_DIR_NOT_EMPTY) {

            WStatus = FrsEnumerateDirectory(Handle,
                                            FileName,
                                            0,
                                            ENUMERATE_DIRECTORY_FLAGS_NONE,
                                            NULL,
                                            FrsEnumerateDirectoryDeleteWorker);
        }

        WStatus = FrsDeleteByHandle(FileName, Handle);
    }

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ Could not delete %ws;", FileName, WStatus);
        goto out;
    }

out:
    DPRINT2(5, "++ %s deleting %ws\n", (WIN_SUCCESS(WStatus)) ? "Success" : "Failure",
           FileName);

    //
    // If the file was marked for delete, this close will delete it
    //
    if (HANDLE_IS_VALID(Handle)) {
        if (FrsWriteFilter != NULL) {
            FrsCloseWithUsnDampening(FileName, &Handle, FrsWriteFilter, NULL);
        } else {
            FRS_CLOSE(Handle);
        }
    }
    return WStatus;
}


DWORD
FrsDeletePath(
    IN  PWCHAR  Path,
    IN  DWORD   DirectoryFlags
    )
/*++
Routine Description:

    Delete the file or dir subtree specified by its path

    WARN: Does not dampen the operations. To be safe, the replica
    set should not exist or the directory should be filtered.
    Otherwise, the deletes might replicate.

Arguments:

    Path            - Path of file system object
    DirectoryFlags  - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_

Return Value:

    Win32 status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeletePath"
    DWORD       WStatus;
    HANDLE      Handle  = INVALID_HANDLE_VALUE;
    FILE_NETWORK_OPEN_INFORMATION FileInfo;

    //
    // Open the file
    //
    WStatus = FrsOpenSourceFileW(&Handle,
                                 Path,
//                                 DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES,
                                 DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY,
                                 OPEN_OPTIONS);
    if (WIN_NOT_FOUND(WStatus)) {
        CLEANUP1_WS(1, "++ WARN - FrsOpenSourceFile(%ws); (IGNORED);",
                   Path, WStatus, RETURN_SUCCESS);
    }

    CLEANUP1_WS(0, "++ ERROR - FrsOpenSourceFile(%ws);", Path, WStatus, CLEANUP);

    //
    // Get the file's attributes
    //
    if (!FrsGetFileInfoByHandle(Path, Handle, &FileInfo)) {
        DPRINT1(1, "++ WARN - Can't get attributes for %ws\n", Path);
        WIN_SET_FAIL(WStatus);
        goto CLEANUP;
    }

    //
    // Don't delete the file if DIRECTORIES_ONLY is set
    //
    if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_DIRECTORIES_ONLY &&
        !(FileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        WStatus = ERROR_DIRECTORY;
        goto CLEANUP;
    }

    //
    // Reset the attributes that prevent deletion
    //
    if (FileInfo.FileAttributes & NOREPL_ATTRIBUTES) {
        DPRINT1(5, "++ Reseting attributes for %ws for delete\n", Path);
        WStatus = FrsSetFileAttributes(Path, Handle,
                                       FileInfo.FileAttributes &
                                       ~NOREPL_ATTRIBUTES);
        CLEANUP1_WS(0, "++ ERROR: - Can't reset attributes for %ws for delete", Path, WStatus, CLEANUP);

        DPRINT1(5, "++ Attributes for %ws now allow deletion\n", Path);
    }

    //
    // Mark the file for delete
    //
    WStatus = FrsDeleteByHandle(Path, Handle);

    if (!WIN_SUCCESS(WStatus)) {
        //
        // If this was a non-empty dir then delete the subtree.
        //
        if (WStatus == ERROR_DIR_NOT_EMPTY) {
            WStatus = FrsEnumerateDirectory(Handle,
                                            Path,
                                            0,
                                            DirectoryFlags,
                                            NULL,
                                            FrsEnumerateDirectoryDeleteWorker);
        }

        WStatus = FrsDeleteByHandle(Path, Handle);
    }

    DPRINT1_WS(0, "++ ERROR - Could not delete %ws;", Path, WStatus);

CLEANUP:
    DPRINT2(5, "++ %s deleting %ws\n",
           (WIN_SUCCESS(WStatus)) ? "Success" : "Failure", Path);

    FRS_CLOSE(Handle);
    return WStatus;

RETURN_SUCCESS:
    WStatus = ERROR_SUCCESS;
    goto CLEANUP;
}


DWORD
FrsDeleteDirectoryContents(
    IN  PWCHAR  Path,
    IN DWORD    DirectoryFlags
    )
/*++
Routine Description:

    Delete the contents of the directory Path

Arguments:

    Path            - Path of file system object
    DirectoryFlags  - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_

Return Value:

    Win32 status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteDirectoryContents"
    DWORD       WStatus;
    HANDLE      Handle  = INVALID_HANDLE_VALUE;

    //
    // Open the file
    //
    WStatus = FrsOpenSourceFileW(&Handle, Path,
//                                 READ_ACCESS,
                                 READ_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                 OPEN_OPTIONS);
    if (WIN_NOT_FOUND(WStatus)) {
        CLEANUP1_WS(1, "++ WARN - FrsOpenSourceFile(%ws); (IGNORED);",
                   Path, WStatus, RETURN_SUCCESS);
    }
    CLEANUP1_WS(0, "++ ERROR - FrsOpenSourceFile(%ws);", Path, WStatus, CLEANUP);

    WStatus = FrsEnumerateDirectory(Handle,
                                    Path,
                                    0,
                                    DirectoryFlags,
                                    NULL,
                                    FrsEnumerateDirectoryDeleteWorker);

    CLEANUP1_WS(0, "++ ERROR - Could not delete contents of %ws;",
                Path, WStatus, CLEANUP);

CLEANUP:
    DPRINT2(5, "++ %s deleting contents of %ws\n",
           (WIN_SUCCESS(WStatus)) ? "Success" : "Failure", Path);

    FRS_CLOSE(Handle);
    return WStatus;

RETURN_SUCCESS:
    WStatus = ERROR_SUCCESS;
    goto CLEANUP;
}


DWORD
FrsOpenBaseNameForInstall(
    IN  PCHANGE_ORDER_ENTRY Coe,
    OUT HANDLE              *Handle
    )
/*++
Routine Description:

    Open the file specified by Coe by its relative name for either
    a rename or delete installation.

    Note that it is possible for the file to have been moved to a new parent
    dir by a previous remote CO or a local CO, making the OldParentGuid in the
    Change Order invalid.  First we try to find the file under the OldParentGuid
    in the CO and then we try by the parent Guid in the IDTable.  We check for
    a match by comparing with the file GUID in the change order.

    It is also possible that the file has been renamed to a point outside the
    replica tree so even if we find it by FID we still can't do anything to it.
    When we fail to find the file in either of the above directories we force this
    CO thru retry, expecting another CO behind us to get processed and update
    the parent guid in the IDTable or maybe mark the file as deleted.

Arguments:
    Coe
    Handle

Return Value:
    Handle and win status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenBaseNameForInstall"

    LONGLONG                ParentFid;
    PWCHAR                  FileName;
    DWORD                   WStatus;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;
    PIDTABLE_RECORD         IDTableRec;
    BOOLEAN                 UseActualLocation = FALSE;


    ParentFid = QUADZERO;
    *Handle = INVALID_HANDLE_VALUE;

    //
    // Open the source file
    //
    WStatus = FrsOpenSourceFileById(Handle,
                                    NULL,
                                    NULL,
                                    Coe->NewReplica->pVme->VolumeHandle,
                                    &Coe->FileReferenceNumber,
                                    FILE_ID_LENGTH,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "File open by FID failed", WStatus);
        return WStatus;
    }

    //
    // Get the File's true on-disk filename and the true parent FID.
    //
    FileName = FrsGetTrueFileNameByHandle(Coc->FileName, *Handle, &ParentFid);
    FRS_CLOSE(*Handle);

    if (FileName == NULL) {
        CHANGE_ORDER_TRACE(3, Coe, "Failed to get file base name");
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // Open the file relative to the parent using the true filename.
    //
    WStatus = FrsCreateFileRelativeById(Handle,
                                        Coe->NewReplica->pVme->VolumeHandle,
                                        &Coc->OldParentGuid,
                                        OBJECT_ID_LENGTH,
                                        FILE_ATTRIBUTE_NORMAL,
                                        FileName,
                                        (USHORT)(wcslen(FileName) * sizeof(WCHAR)),
                                        NULL,
                                        FILE_OPEN,
//                                        DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES);
                                        DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY);

    if (WIN_SUCCESS(WStatus)) {
        //
        // Get the file's oid and check it against the change order.  Need to
        // do this to cover the case of a rename of the file to a different
        // parent dir followed by a create of a file with the same name.
        // If this occurred the above open would succeed.
        //
        WStatus = FrsCheckObjectId(Coc->FileName, *Handle, &Coc->FileGuid);
        if (WIN_SUCCESS(WStatus)) {
            goto RETURN;
        }

        CHANGE_ORDER_TRACE(3, Coe, "File OID mismatch CO, after Coc->OldParentGuid open");

        FRS_CLOSE(*Handle);
    } else {
        CHANGE_ORDER_TRACEW(3, Coe, "File open failed under Coc->OldParentGuid", WStatus);
    }

    //
    // We did not find the file using the True Name from the file and the
    // Old parent Guid from the change order.  The file may have been moved
    // by a previous remote CO or a Local CO.  Try the Parent Guid in the
    // IDTable record.
    //
    FRS_ASSERT(Coe->RtCtx != NULL);
    FRS_ASSERT(IS_ID_TABLE(&Coe->RtCtx->IDTable));

    IDTableRec = Coe->RtCtx->IDTable.pDataRecord;
    FRS_ASSERT(IDTableRec != NULL);

    WStatus = FrsCreateFileRelativeById(Handle,
                                        Coe->NewReplica->pVme->VolumeHandle,
                                        &IDTableRec->ParentGuid,
                                        OBJECT_ID_LENGTH,
                                        FILE_ATTRIBUTE_NORMAL,
                                        FileName,
                                        (USHORT)(wcslen(FileName) * sizeof(WCHAR)),
                                        NULL,
                                        FILE_OPEN,
//                                        DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES);
                                        DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY);

    if (WIN_SUCCESS(WStatus)) {
        //
        // Get the file's oid and check it against the change order.
        //
        WStatus = FrsCheckObjectId(Coc->FileName, *Handle, &Coc->FileGuid);
        if (WIN_SUCCESS(WStatus)) {
            goto RETURN;
        }

        CHANGE_ORDER_TRACE(3, Coe, "File OID mismatch CO, after IDTableRec->ParentGuid");

        FRS_CLOSE(*Handle);
    } else {
        CHANGE_ORDER_TRACEW(3, Coe, "File open failed under IDTableRec->ParentGuid", WStatus);
    }

    //
    // If this is a delete change order then we may have a problem if the file
    // has been moved to a different parent dir by a local file operation.
    // The local change order that did this can be rejected if the remote
    // CO delete is processed first so the local co fails reconcile. But the
    // ondisk rename has been completed and when the remote CO delete tries to
    // delete the file it may not be in either the parent dir from the remote
    // CO or the parent dir from the IDTable.  To cover this case we find the
    // TRUE parent dir and check to see if the file is still in the replica tree.
    // If it is then we delete it using the TRUE parent dir.  IF it isn't then
    // return success since the file is already outside the tree.
    // Note that a sharing conflict on the target file can block the delete
    // for an extended period of time so the timing window in which this can
    // occur can be pretty wide.
    //

    //
    // We also need to deal with the case where a new file is still sitting in
    // the preinstall directory (and the CO is in install_rename_retry.)
    // In that case we will have failed to find the file under the old parent from
    // the CO or under the parent listed in the IDTable.
    //

    if (DOES_CO_DELETE_FILE_NAME(Coc)) {
        if (JrnlIsChangeOrderInReplica(Coe, &ParentFid)) {
            UseActualLocation = TRUE;
        } else {
            //
            // File not in the replica tree any more so tell the caller.
            //
            WStatus = ERROR_FILE_NOT_FOUND;
            goto RETURN;
        }
    }

    if((ULONGLONG)ParentFid == Coe->NewReplica->PreInstallFid) {
        UseActualLocation = TRUE;
    }

    if (UseActualLocation) {

        WStatus = FrsCreateFileRelativeById(Handle,
                                            Coe->NewReplica->pVme->VolumeHandle,
                                            &ParentFid,
                                            FILE_ID_LENGTH,
                                            FILE_ATTRIBUTE_NORMAL,
                                            FileName,
                                            (USHORT)(wcslen(FileName) * sizeof(WCHAR)),
                                            NULL,
                                            FILE_OPEN,
//                                                DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES);
                                            DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES | FILE_LIST_DIRECTORY);
        if (WIN_SUCCESS(WStatus)) {
            //
            // Get the file's oid and check it against the change order.
            //
            WStatus = FrsCheckObjectId(Coc->FileName, *Handle, &Coc->FileGuid);
            if (WIN_SUCCESS(WStatus)) {
                goto RETURN;
            }

            CHANGE_ORDER_TRACE(3, Coe, "File OID mismatch with CO after TRUE ParentFid open");

            FRS_CLOSE(*Handle);
        } else {
            CHANGE_ORDER_TRACEW(3, Coe, "File open failed under True Parent FID", WStatus);
        }
    }

    //
    // The file is there but not where we expected it to be so send this CO
    // through retry to let a subsequent Local CO get processed and update the
    // IDTable.
    //
    WStatus = ERROR_RETRY;


RETURN:


    CHANGE_ORDER_TRACEW(3, Coe, "Base File open", WStatus);

    FrsFree(FileName);

    return WStatus;
}


DWORD
FrsDeleteById(
    IN PWCHAR                   VolumeName,
    IN PWCHAR                   Name,
    IN PVOLUME_MONITOR_ENTRY    pVme,
    IN  PVOID                   Id,
    IN  DWORD                   IdLen
    )
/*++
Routine Description:
    Delete the file represented by Id

Arguments:
    VolumeName - corresponding to pVme

    Name - For error messages

    pVme - volume entry

    Id - Represents the name of the file or directory to be opened.

    IdLen - length of Id (Fid or Oid)

Return Value:
    Handle and win status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteById"
    DWORD   WStatus;
    HANDLE  Handle = INVALID_HANDLE_VALUE;
    PWCHAR  Path = NULL;
    PWCHAR  FullPath = NULL;

    DPRINT1(5, "++ Deleting %ws by id\n", Name);

    //
    // Open the source file
    //
    WStatus = FrsOpenSourceFileById(&Handle,
                                    NULL,
                                    NULL,
                                    pVme->VolumeHandle,
                                    Id,
                                    IdLen,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    CLEANUP1_WS(4, "++ ERROR - FrsOpenSourceFileById(%ws);", Name, WStatus, CLEANUP);

    //
    // File's relative pathname
    //
    Path = FrsGetFullPathByHandle(Name, Handle);
    if (Path) {
        FullPath = FrsWcsCat(VolumeName, Path);
    }
    FRS_CLOSE(Handle);

    if (FullPath == NULL) {
        DPRINT1(4, "++ ERROR - FrsGetFullPathByHandle(%ws)\n", Name);
        WIN_SET_FAIL(WStatus);
        goto CLEANUP;
    }

    //
    // Open the file relative to the parent using the true filename.
    //
    WStatus = FrsOpenSourceFileW(&Handle,
                                FullPath,
//                                DELETE | READ_ACCESS | FILE_WRITE_ATTRIBUTES,
                                DELETE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES,
                                OPEN_OPTIONS);
    CLEANUP2_WS(4, "++ ERROR - FrsOpenSourceFile(%ws -> %ws);",
                Name, FullPath, WStatus, CLEANUP);

    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    WStatus = FrsMarkHandle(pVme->VolumeHandle, Handle);
    CLEANUP1_WS(0, "++ WARN - FrsMarkHandle(%ws);", Name, WStatus, RETURN_SUCCESS);

    //
    // Get the file's oid and check it against the id
    //
    if (IdLen == OBJECT_ID_LENGTH) {
        WStatus = FrsCheckObjectId(Name, Handle, Id);
        CLEANUP1_WS(4, "++ ERROR - FrsCheckObjectId(%ws);", Name, WStatus, CLEANUP);
    }

    WStatus = FrsResetAttributesForReplication(FullPath, Handle);
    DPRINT1_WS(4, "++ ERROR - FrsResetAttributesForReplication(%ws):", FullPath, WStatus);

    WStatus = FrsDeleteByHandle(Name, Handle);
    FrsCloseWithUsnDampening(Name, &Handle, pVme->FrsWriteFilter, NULL);
    CLEANUP1_WS(4, "++ ERROR - FrsDeleteByHandle(%ws);", Name, WStatus, CLEANUP);


CLEANUP:
    FRS_CLOSE(Handle);

    FrsFree(Path);
    FrsFree(FullPath);

    return WStatus;

RETURN_SUCCESS:
    WStatus = ERROR_SUCCESS;
    goto CLEANUP;
}


BOOL
FrsCloseWithUsnDampening(
    IN     PWCHAR       Name,
    IN OUT PHANDLE      Handle,
    IN     PQHASH_TABLE FrsWriteFilter,
    OUT    USN          *RetUsn
    )
/*++

Routine Description:

    Close the handle after insuring that any modifications made to the
    file will not generate change orders.

Arguments:

    Name - File name for error messages.

    Handle - Handle to the replica set file file being closed. Nop if
             INVALID_HANDLE_VALUE.

    Replica - ptr to Replica struct where this file was written.
              This gets us to the volume write filter table to record the USN.

    RetUsn - ptr to return location for the close USN.  NULL if not requested.

Return Value:
    TRUE  - handle is closed and any changes where dampened
    FALSE - handle is closed but replication was *not* dampened
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCloseWithUsnDampening"

    DWORD   BytesReturned = 0;
    USN     Usn = 0;
    ULONG   GStatus;
    BOOL    RetStatus;

    RetStatus = TRUE;

    if (!HANDLE_IS_VALID(*Handle)) {
        return TRUE;
    }

    //
    // Get the lock on the Usn Write Filter table.
    // We have to get this before the FSCTL_WRITE_USN_CLOSE_RECORD call
    // which will generate the journal close record. THis closes the
    // race between our subsequent update of the WriteFilter below
    // and the journal thread that processes the USN close record.
    //
    QHashAcquireLock(FrsWriteFilter);

    //
    // Close the file and force out the journal close record now.  This
    // call returns the USN of the generated close record so we can filter
    // it out of the journal record stream.
    //
    if (!DeviceIoControl(*Handle,
                         FSCTL_WRITE_USN_CLOSE_RECORD,
                         NULL, 0,
                         &Usn, sizeof(USN),
                         &BytesReturned, NULL)) {
        //
        // Access denied is returned if there is another open
        //
        if (GetLastError() != ERROR_ACCESS_DENIED) {
            DPRINT1_WS(0, "++ Can't dampen replication on %ws;", Name, GetLastError());
        } else {
            DPRINT1(0, "++ Can't dampen %ws; access denied\n", Name);
        }
        RetStatus = FALSE;
    }

    RetStatus = RetStatus && (BytesReturned == sizeof(USN));

    if (RetStatus) {
        //
        // Put the USN in the FrsWriteFilter table for the replica so we
        // can ignore it and the drop the lock on the table.
        //
        GStatus = QHashInsert(FrsWriteFilter, &Usn, &Usn, 0, TRUE);
        QHashReleaseLock(FrsWriteFilter);

        if (GStatus != GHT_STATUS_SUCCESS ) {
            DPRINT1(0, "++ QHashInsert error: %d\n", GStatus);
            RetStatus = FALSE;
        }

    } else {
        QHashReleaseLock(FrsWriteFilter);
    }

    //
    // Return the close USN.
    //
    if (RetUsn != NULL) {
        *RetUsn = Usn;
    }

    //
    // Now do the normal close to release the handle.  NTFS completed its
    // close work above.
    //
    FRS_CLOSE(*Handle);

    DPRINT2(5, "++ Dampening %s on %ws\n", (RetStatus) ? "Succeeded" : "Failed", Name);

    return RetStatus;
}


VOID
ProcessOpenByIdStatus(
    IN HANDLE   Handle,
    IN ULONG    NtStatus,
    IN PVOID    ObjectId,
    IN ULONG    Length
    )
/*++

Routine Description:

    Print the results of an open-by-id.

Arguments:

    NtStatus
    ObjectId
    Length

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "ProcessOpenByIdStatus:"

    CHAR              GuidStr[GUID_CHAR_LEN];
    PWCHAR            Path;

    if (!NT_SUCCESS(NtStatus)) {
        //
        // Note:  The following call seems to generate intermittant AVs in the
        // symbol lookup code.  Only include it for testing.
        //
        //STACK_TRACE_AND_PRINT(2);

        if (Length == FILE_ID_LENGTH) {
            DPRINT2_NT(1, "++ %08X %08X Fid Open failed;",
                       *((PULONG)ObjectId+1), *(PULONG)ObjectId, NtStatus);
        } else {
            GuidToStr((GUID *) ObjectId, GuidStr);
            DPRINT1_NT(1, "++ %s ObjectId Open failed;", GuidStr, NtStatus);
        }

        return;
    }

    //
    // Open succeeded.
    //
    if (Length == FILE_ID_LENGTH) {
        DPRINT2(4,"++ %08X %08X Fid Opened succesfully\n",
                *((PULONG)ObjectId+1), *((PULONG)ObjectId));
    } else {
        GuidToStr((GUID *) ObjectId, GuidStr);
        DPRINT1(4, "++ %s ObjectId Opened succesfully\n", GuidStr);
    }

    if (DoDebug(4, DEBSUB)) {
        Path = FrsGetFullPathByHandle(L"Unknown", Handle);
        if (Path) {
            DPRINT1(4, "++ Filename is: %ws\n", Path);
        }
        FrsFree(Path);
    }
}


DWORD
FrsForceOpenId(
    OUT PHANDLE                 Handle,
    IN OUT OVERLAPPED           *OpLock, OPTIONAL
    IN  PVOLUME_MONITOR_ENTRY   pVme,
    IN  PVOID                   Id,
    IN  DWORD                   IdLen,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  ULONG                   ShareMode,
    IN  ULONG                   CreateDisposition
    )
/*++

Routine Description:

    Open the file for the desired access. If the open fails, reset
    the readonly/system/hidden attributes and retry. In any case,
    make sure the attributes are reset to their original value
    before returning.

Arguments:

    Handle - Returns the file handle.

    OpLock - Overlapped struct for an oplock (optional).

    pVme - volume entry

    Id - Represents the name of the file or directory to be opened.

    IdLen - length of Id (Fid or Oid)

    DesiredAccess - see replutil.h for defined access modes (xxx_ACCESS)

    CreateOptions - see replutil.h for defined options (xxx_OPTIONS

    ShareMode   - standard share modes defined in sdk

    CreateDisposition - E.g., FILE_OPEN or FILE_OVERWRITE

Return Value:

    Win error status.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsForceOpenId:"

    HANDLE      AttrHandle;
    ULONG       WStatus, WStatus1;
    ULONG       AttrWStatus;
    FILE_NETWORK_OPEN_INFORMATION  FileNetworkOpenInfo;

    DPRINT2(5, "++ Attempting to force open Id %08x %08x (%d bytes)\n",
            PRINTQUAD((*(PULONGLONG)Id)), IdLen);

    //
    // Open the file
    //
    WStatus = FrsOpenSourceFileById(Handle,
                                    NULL,
                                    OpLock,
                                    pVme->VolumeHandle,
                                    Id,
                                    IdLen,
                                    DesiredAccess,
                                    CreateOptions,
                                    ShareMode,
                                    CreateDisposition);
    //
    // File has been opened successfully
    //
    if (WIN_SUCCESS(WStatus)) {
        DPRINT2(5, "++ Successfully opened Id %08x %08x (%d)\n",
                PRINTQUAD((*(PULONGLONG)Id)), IdLen);
        return WStatus;
    }

    //
    // File has been deleted; done
    //
    if (WIN_NOT_FOUND(WStatus)) {
        DPRINT2(4, "++ Id %08x %08x (%d) not found\n",
                PRINTQUAD((*(PULONGLONG)Id)), IdLen);
        return WStatus;
    }

    //
    // Not an attribute problem
    //
    if (!WIN_ACCESS_DENIED(WStatus)) {
        DPRINT2_WS(4, "++ Open Id %08x %08x (%d) failed;",
               PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus);
        return WStatus;
    }

    //
    // Attempt to reset attributes (e.g., reset readonly)
    //
    AttrWStatus = FrsOpenSourceFileById(&AttrHandle,
                                        &FileNetworkOpenInfo,
                                        NULL,
                                        pVme->VolumeHandle,
                                        Id,
                                        IdLen,
//                                        READ_ACCESS | FILE_WRITE_ATTRIBUTES,
//                                        STANDARD_RIGHTS_READ | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | ACCESS_SYSTEM_SECURITY | SYNCHRONIZE,
                                        READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS,
                                        CreateOptions,
                                        SHARE_ALL,
                                        FILE_OPEN);
    //
    // Couldn't open the file for write-attribute access
    //
    if (!WIN_SUCCESS(AttrWStatus)) {
        DPRINT2_WS(4, "++ Open Id %08x %08x (%d) for minimal access failed;",
                   PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus);
        return WStatus;
    }
    //
    // Handles can be marked so that any usn records resulting from
    // operations on the handle will have the same "mark". In this
    // case, the mark is a bit in the SourceInfo field of the usn
    // record. The mark tells NtFrs to ignore the usn record during
    // recovery because this was a NtFrs generated change.
    //
    WStatus1 = FrsMarkHandle(pVme->VolumeHandle, AttrHandle);
    DPRINT1_WS(0, "++ WARN - FrsMarkHandle(%08x %08x);",
               PRINTQUAD((*(PULONGLONG)Id)), WStatus1);

    //
    // The file's attributes are not preventing the open; done
    //
    if (!(FileNetworkOpenInfo.FileAttributes & NOREPL_ATTRIBUTES)) {
        DPRINT2_WS(4, "++ Id %08x %08x (%d)attributes not preventing open;",
                   PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus);
        FRS_CLOSE(AttrHandle);
        return WStatus;
    }

    //
    // Reset the attributes
    //
    WStatus1 = FrsSetFileAttributes(L"<unknown>",
                              AttrHandle,
                              FileNetworkOpenInfo.FileAttributes &
                              ~NOREPL_ATTRIBUTES);
    if (!WIN_SUCCESS(WStatus1)) {
        DPRINT2_WS(4, "++ Can't reset attributes for Id %08x %08x (%d);",
                   PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus1);
        FRS_CLOSE(AttrHandle);
        return WStatus1;
    }
    //
    // Try to open the file again
    //
    WStatus = FrsOpenSourceFileById(Handle,
                                    NULL,
                                    NULL,
                                    pVme->VolumeHandle,
                                    Id,
                                    IdLen,
                                    DesiredAccess,
                                    CreateOptions,
                                    SHARE_ALL,
                                    CreateDisposition);
    //
    // Reset the original attributes
    //
    WStatus1 = FrsSetFileAttributes(L"<unknown>",
                              AttrHandle,
                              FileNetworkOpenInfo.FileAttributes);
    if (!WIN_SUCCESS(WStatus1)) {
        DPRINT2_WS(0, "++ ERROR - Can't set attributes for Id %08x %08x (%d);",
                   PRINTQUAD((*(PULONGLONG)Id)), IdLen, WStatus1);
    }
    //
    // Close the handle that we used to set and reset attributes
    //

    FRS_CLOSE(AttrHandle);


    DPRINT3(4, "++ Force open %08x %08x (%d) %s WITH SHARE ALL!\n",
            PRINTQUAD((*(PULONGLONG)Id)), IdLen,
            WIN_SUCCESS(WStatus) ? "Succeeded" : "Failed");

    return (WStatus);
}


DWORD
FrsOpenSourceFileById(
    OUT PHANDLE Handle,
    OUT PFILE_NETWORK_OPEN_INFORMATION  FileOpenInfo,
    OUT OVERLAPPED  *OpLock,
    IN  HANDLE      VolumeHandle,
    IN  PVOID       ObjectId,
    IN  ULONG       Length,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG       CreateOptions,
    IN  ULONG       ShareMode,
    IN  ULONG       CreateDisposition
    )
/*++

Routine Description:

    This function opens the specified file by File ID or Object ID.
    If the length is 8 perform a relative open using the file ID and the
    volume handle passed in the VolumeHandle arg.  If the length is 16
    perform an object ID relative open using the volume handle.

Arguments:

    Handle - Returns the file handle.

    FileOpenInfo - If non-NULL, returns the FILE_NETWORK_OPEN_INFORMATION data.

    OpLock - If non-NULL, the caller desires an oplock

    VolumeHandle - The handle for a FileID based relative open.

    ObjectId - Represents the name of the file or directory to be opened.

    Length -  8 for file IDs and 16 for object IDs.

    DesiredAccess - see replutil.h for defined access modes (xxx_ACCESS)

    CreateOptions - see replutil.h for defined options (xxx_OPTIONS

    ShareMode   - standard share modes defined in sdk

    CreateDisposition - E.g., FILE_OPEN or FILE_OVERWRITE

Return Value:

    Win error status.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsOpenSourceFileById:"

    ULONG               Ignored;
    NTSTATUS            NtStatus;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      str;

    FRS_ASSERT(HANDLE_IS_VALID(VolumeHandle));
    FRS_ASSERT(Length == OBJECT_ID_LENGTH || Length == FILE_ID_LENGTH);

    *Handle = INVALID_HANDLE_VALUE;

    //
    // Object attributes (e.g., the file's fid or oid
    //
    str.Length = (USHORT)Length;
    str.MaximumLength = (USHORT)Length;
    str.Buffer = ObjectId;
    InitializeObjectAttributes(&ObjectAttributes,
                               &str,
                               OBJ_CASE_INSENSITIVE,
                               VolumeHandle,
                               NULL);
    //
    // Optional oplock
    //
    if (OpLock != NULL) {
        ZeroMemory(OpLock, sizeof(OVERLAPPED));
        OpLock->hEvent = FrsCreateEvent(TRUE, FALSE);
        CreateOptions &= ~FILE_SYNCHRONOUS_IO_NONALERT;
    }

    NtStatus = NtCreateFile(Handle,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            NULL,
                            0);
    //
    // Apply oplock if requested
    //
    if (NT_SUCCESS(NtStatus) && OpLock) {
        if (!DeviceIoControl(*Handle,
                             FSCTL_REQUEST_FILTER_OPLOCK,
                             NULL,
                             0,
                             NULL,
                             0,
                             &Ignored,
                             OpLock)) {
            if (GetLastError() != ERROR_IO_PENDING) {
                DPRINT_WS(3, "++ WARN: Can't get oplock;", GetLastError());
                //
                // Cleanup the handles
                //
                FRS_CLOSE(OpLock->hEvent);
            }
        }
    }

    //
    // Report status
    //
    ProcessOpenByIdStatus(*Handle, NtStatus, ObjectId, Length);

    //
    // Couldn't open; return status
    //
    if (!NT_SUCCESS(NtStatus) ) {
        *Handle = INVALID_HANDLE_VALUE;
        DPRINT_NT(0, "++ ERROR - NtCreateFile failed :", NtStatus);
        return FrsSetLastNTError(NtStatus);
    }

    //
    // Return some file info and the file handle.
    //
    if (FileOpenInfo) {
        NtStatus = NtQueryInformationFile(*Handle,
                                          &IoStatusBlock,
                                          FileOpenInfo,
                                          sizeof(FILE_NETWORK_OPEN_INFORMATION),
                                          FileNetworkOpenInformation);
        if (!NT_SUCCESS(NtStatus) ) {
            //
            // Cleanup the handles
            //
            DPRINT_NT(0, "++ NtQueryInformationFile - FileNetworkOpenInformation failed:", NtStatus);
            FRS_CLOSE(*Handle);
            if (OpLock != NULL) {
                FRS_CLOSE(OpLock->hEvent);
            }

            return FrsSetLastNTError(NtStatus);
        }
    }
    return FrsSetLastNTError(NtStatus);
}



DWORD
FrsCreateFileRelativeById(
    OUT PHANDLE         Handle,
    IN  HANDLE          VolumeHandle,
    IN  PVOID           ParentObjectId,
    IN  ULONG           OidLength,
    IN  ULONG           FileCreateAttributes,
    IN  PWCHAR          BaseFileName,
    IN  USHORT          FileNameLen,
    IN  PLARGE_INTEGER  AllocationSize,
    IN  ULONG           CreateDisposition,
    IN  ACCESS_MASK     DesiredAccess
    )
/*++

Routine Description:

    This function creates a new file in the directory specified by the parent
    file object ID. It does a replative open of the parent using the volume
    handle provided.  Then it does a relative open of the target file using
    the parent handle and the file name.

    If the length is 8 perform a relative open using the file ID and the
    volume handle passed in the VolumeHandle arg.  If the length is 16
    perform an object ID relative open using the volume handle.

    The file attributes parameter is used to decide if the create is a
    file or a directory.

Arguments:

    Handle - Returns the file handle.

    VolumeHandle - The handle for a ID based relative open.

    ParentObjectId - The object or file id of the parent directory.  If NULL
                     open the file relative to the Volume Handle.

    OidLength -  8 for file IDs and 16 for object IDs. (len of parent oid)

    FileCreateAttributes - Initial File Create Attributes

    BaseFileName - ptr to NULL terminated file name

    FileNameLen - File name length (not incl the null) in bytes.

    AllocationSize - The allocation size for the file.

    CreateDisposition - E.g., FILE_CREATE or FILE_OPEN

    DesiredAccess - Access rights

Return Value:

    WIN32 error status.  Use GetLastError() to get the win32 error code.


    If the file already exsists the Win32 error return is ERROR_ALREADY_EXISTS.
    The NT error status is STATUS_OBJECT_NAME_COLLISION.


--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateFileRelativeById:"


    UNICODE_STRING    UStr;

    DWORD             WStatus;
    NTSTATUS          NtStatus;
    NTSTATUS          NtStatus2;
    HANDLE            File, DirHandle;
    ULONG             ShareMode;
    ULONG             CreateOptions;
    ULONG             EaSize;

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;

    PFILE_FULL_EA_INFORMATION EaBuffer;
    PFILE_NAME_INFORMATION    FileName;

    CHAR              GuidStr[GUID_CHAR_LEN];
    CHAR              NameBuffer[sizeof(ULONG) + (sizeof(WCHAR)*(MAX_PATH+1))];

    *Handle = INVALID_HANDLE_VALUE;

    //
    // Open the parent directory using the object ID provided.
    //
    if (ParentObjectId != NULL) {
        WStatus = FrsOpenSourceFileById(&DirHandle,
                                        NULL,
                                        NULL,
                                        VolumeHandle,
                                        ParentObjectId,
                                        OidLength,
//                                        READ_ACCESS,
                                        READ_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(1, "++ ERROR - Open on parent dir failed;", WStatus);
            return WStatus;
        }
    } else {
        DirHandle = VolumeHandle;
        OidLength = 0;
    }

    //
    // Create the target file.
    //
    FrsSetUnicodeStringFromRawString(&UStr, FileNameLen, BaseFileName, FileNameLen);

    InitializeObjectAttributes( &ObjectAttributes,
                                &UStr,
                                OBJ_CASE_INSENSITIVE,
                                DirHandle,
                                NULL );
    //
    // Mask off the junk that may have come in from the journal
    //
    FileCreateAttributes &= FILE_ATTRIBUTE_VALID_FLAGS;

    //
    // Set create options depending on file or dir.
    //
    CreateOptions = FILE_OPEN_FOR_BACKUP_INTENT     // FILE_FLAG_BACKUP_SEMANTICS
                  | FILE_OPEN_REPARSE_POINT
                  | FILE_OPEN_NO_RECALL             // Don't migrate data for HSM
                  | FILE_SEQUENTIAL_ONLY
                  | FILE_SYNCHRONOUS_IO_NONALERT;

    if (CreateDisposition == FILE_CREATE || CreateDisposition == FILE_OPEN_IF) {
        if (FileCreateAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            CreateOptions |= FILE_DIRECTORY_FILE;
            CreateOptions &= ~(FILE_SEQUENTIAL_ONLY | FILE_OPEN_NO_RECALL);
        } else {
            CreateOptions |= FILE_NON_DIRECTORY_FILE;
        }
    }

    EaBuffer = NULL;
    EaSize = 0;
//    ShareMode = 0;                               // no sharing
    //
    // Fix for Bug 186880
    //
    ShareMode = FILE_SHARE_READ;                   // share for read.

    //
    // Do the relative open.
    //

    DPRINT1(5, "++ DesiredAccess:         %08x\n", DesiredAccess);
    if (AllocationSize != NULL) {
        DPRINT2(5, "++ AllocationSize:        %08x %08x\n", AllocationSize->HighPart, AllocationSize->LowPart);
    }
    DPRINT1(5, "++ FileCreateAttributes:  %08x\n", FileCreateAttributes);
    DPRINT1(5, "++ ShareMode:             %08x\n", ShareMode);
    DPRINT1(5, "++ CreateDisposition:     %08x\n", CreateDisposition);
    DPRINT1(5, "++ CreateOptions:         %08x\n", CreateOptions);
    if (OidLength == 16) {
        GuidToStr((GUID *) ParentObjectId, GuidStr);
        DPRINT1(5, "++ Parent ObjectId:       %s\n", GuidStr);
    }

    NtStatus = NtCreateFile(&File,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            AllocationSize,        // Initial allocation size
                            FileCreateAttributes,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            EaBuffer,
                            EaSize);

    if (ParentObjectId != NULL) {
        FRS_CLOSE(DirHandle);
    }

    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(5, "++ ERROR - CreateFile failed on %ws.", BaseFileName, NtStatus);
        DPRINT1(5, "++ DesiredAccess:         %08x\n", DesiredAccess);
        if (AllocationSize != NULL) {
            DPRINT2(5, "++ AllocationSize:        %08x %08x\n", AllocationSize->HighPart, AllocationSize->LowPart);
        }
        DPRINT1(5, "++ FileCreateAttributes:  %08x\n", FileCreateAttributes);
        DPRINT1(5, "++ ShareMode:             %08x\n", ShareMode);
        DPRINT1(5, "++ CreateDisposition:     %08x\n", CreateDisposition);
        DPRINT1(5, "++ CreateOptions:         %08x\n", CreateOptions);
        if (OidLength == 16) {
            GuidToStr((GUID *) ParentObjectId, GuidStr);
            DPRINT1(5, "++ Parent ObjectId:       %s\n", GuidStr);
        }

        if (NtStatus == STATUS_INVALID_PARAMETER) {
            DPRINT(5, "++ Invalid parameter on open by ID likely means file not found.\n");
            return ERROR_FILE_NOT_FOUND;
        }

        return FrsSetLastNTError(NtStatus);
    }


    if (DoDebug(5, DEBSUB)) {
        FileName = (PFILE_NAME_INFORMATION) &NameBuffer[0];
        FileName->FileNameLength = sizeof(NameBuffer) - sizeof(ULONG);

        NtStatus2 = NtQueryInformationFile(File,
                                           &IoStatusBlock,
                                           FileName,
                                           sizeof(NameBuffer),
                                           FileNameInformation );


        if (!NT_SUCCESS(NtStatus2)) {
            DPRINT_NT(1, "++ NtQueryInformationFile - FileNameInformation failed:",
                      NtStatus2);
        } else {
            FileName->FileName[FileName->FileNameLength/2] = UNICODE_NULL;
            DPRINT1(5, "++ Name of created file is: %ws\n", FileName->FileName);               //
        }
    }

    //
    // Return the file handle.
    //
    *Handle = File;

    return FrsSetLastNTError(NtStatus);
}



DWORD
FrsCreateFileRelativeById2(
    OUT PHANDLE         Handle,
    IN  HANDLE          VolumeHandle,
    IN  PVOID           ParentObjectId,
    IN  ULONG           OidLength,
    IN  ULONG           FileCreateAttributes,
    IN  PWCHAR          BaseFileName,
    IN  USHORT          FileNameLen,
    IN  PLARGE_INTEGER  AllocationSize,
    IN  ULONG           CreateDisposition,
    IN  ACCESS_MASK     DesiredAccess,
    IN  ULONG           ShareMode
    )
/*++

Routine Description:

    This function creates a new file in the directory specified by the parent
    file object ID. It does a replative open of the parent using the volume
    handle provided.  Then it does a relative open of the target file using
    the parent handle and the file name.

    If the length is 8 perform a relative open using the file ID and the
    volume handle passed in the VolumeHandle arg.  If the length is 16
    perform an object ID relative open using the volume handle.

    The file attributes parameter is used to decide if the create is a
    file or a directory.

Arguments:

    Handle - Returns the file handle.

    VolumeHandle - The handle for a ID based relative open.

    ParentObjectId - The object or file id of the parent directory.  If NULL
                     open the file relative to the Volume Handle.

    OidLength -  8 for file IDs and 16 for object IDs. (len of parent oid)

    FileCreateAttributes - Initial File Create Attributes

    BaseFileName - ptr to NULL terminated file name

    FileNameLen - File name length (not incl the null) in bytes.

    AllocationSize - The allocation size for the file.

    CreateDisposition - E.g., FILE_CREATE or FILE_OPEN

    DesiredAccess - Access rights

    ShareMode - The sharing mode.

Return Value:

    WIN32 error status.  Use GetLastError() to get the win32 error code.


    If the file already exsists the Win32 error return is ERROR_ALREADY_EXISTS.
    The NT error status is STATUS_OBJECT_NAME_COLLISION.


--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateFileRelativeById2:"


    UNICODE_STRING    UStr;

    DWORD             WStatus;
    NTSTATUS          NtStatus;
    NTSTATUS          NtStatus2;
    HANDLE            File, DirHandle;
    ULONG             CreateOptions;
    ULONG             EaSize;

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;

    PFILE_FULL_EA_INFORMATION EaBuffer;
    PFILE_NAME_INFORMATION    FileName;

    CHAR              GuidStr[GUID_CHAR_LEN];
    CHAR              NameBuffer[sizeof(ULONG) + (sizeof(WCHAR)*(MAX_PATH+1))];

    *Handle = INVALID_HANDLE_VALUE;

    //
    // Open the parent directory using the object ID provided.
    //
    if (ParentObjectId != NULL) {
        WStatus = FrsOpenSourceFileById(&DirHandle,
                                        NULL,
                                        NULL,
                                        VolumeHandle,
                                        ParentObjectId,
                                        OidLength,
//                                        READ_ACCESS,
                                        READ_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                        ID_OPTIONS,
                                        SHARE_ALL,
                                        FILE_OPEN);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(1, "++ ERROR - Open on parent dir failed;", WStatus);
            return WStatus;
        }
    } else {
        DirHandle = VolumeHandle;
        OidLength = 0;
    }

    //
    // Create the target file.
    //
    FrsSetUnicodeStringFromRawString(&UStr, FileNameLen, BaseFileName, FileNameLen);

    InitializeObjectAttributes( &ObjectAttributes,
                                &UStr,
                                OBJ_CASE_INSENSITIVE,
                                DirHandle,
                                NULL );
    //
    // Mask off the junk that may have come in from the journal
    //
    FileCreateAttributes &= FILE_ATTRIBUTE_VALID_FLAGS;

    //
    // Set create options depending on file or dir.
    //
    CreateOptions = FILE_OPEN_FOR_BACKUP_INTENT     // FILE_FLAG_BACKUP_SEMANTICS
                  | FILE_OPEN_REPARSE_POINT
                  | FILE_OPEN_NO_RECALL             // Don't migrate data for HSM
                  | FILE_SEQUENTIAL_ONLY
                  | FILE_SYNCHRONOUS_IO_NONALERT;

    if (CreateDisposition == FILE_CREATE || CreateDisposition == FILE_OPEN_IF) {
        if (FileCreateAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            CreateOptions |= FILE_DIRECTORY_FILE;
            CreateOptions &= ~(FILE_SEQUENTIAL_ONLY | FILE_OPEN_NO_RECALL);
        } else {
            CreateOptions |= FILE_NON_DIRECTORY_FILE;
        }
    }

    EaBuffer = NULL;
    EaSize = 0;

    //
    // Do the relative open.
    //

    DPRINT1(5, "++ DesiredAccess:         %08x\n", DesiredAccess);
    if (AllocationSize != NULL) {
        DPRINT2(5, "++ AllocationSize:        %08x %08x\n", AllocationSize->HighPart, AllocationSize->LowPart);
    }
    DPRINT1(5, "++ FileCreateAttributes:  %08x\n", FileCreateAttributes);
    DPRINT1(5, "++ ShareMode:             %08x\n", ShareMode);
    DPRINT1(5, "++ CreateDisposition:     %08x\n", CreateDisposition);
    DPRINT1(5, "++ CreateOptions:         %08x\n", CreateOptions);
    if (OidLength == 16) {
        GuidToStr((GUID *) ParentObjectId, GuidStr);
        DPRINT1(5, "++ Parent ObjectId:       %s\n", GuidStr);
    }

    NtStatus = NtCreateFile(&File,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            AllocationSize,        // Initial allocation size
                            FileCreateAttributes,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            EaBuffer,
                            EaSize);

    if (ParentObjectId != NULL) {
        FRS_CLOSE(DirHandle);
    }

    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(5, "++ ERROR - CreateFile failed on %ws.", BaseFileName, NtStatus);
        DPRINT1(5, "++ DesiredAccess:         %08x\n", DesiredAccess);
        if (AllocationSize != NULL) {
            DPRINT2(5, "++ AllocationSize:        %08x %08x\n", AllocationSize->HighPart, AllocationSize->LowPart);
        }
        DPRINT1(5, "++ FileCreateAttributes:  %08x\n", FileCreateAttributes);
        DPRINT1(5, "++ ShareMode:             %08x\n", ShareMode);
        DPRINT1(5, "++ CreateDisposition:     %08x\n", CreateDisposition);
        DPRINT1(5, "++ CreateOptions:         %08x\n", CreateOptions);
        if (OidLength == 16) {
            GuidToStr((GUID *) ParentObjectId, GuidStr);
            DPRINT1(5, "++ Parent ObjectId:       %s\n", GuidStr);
        }

        if (NtStatus == STATUS_INVALID_PARAMETER) {
            DPRINT(5, "++ Invalid parameter on open by ID likely means file not found.\n");
            return ERROR_FILE_NOT_FOUND;
        }

        return FrsSetLastNTError(NtStatus);
    }


    if (DoDebug(5, DEBSUB)) {
        FileName = (PFILE_NAME_INFORMATION) &NameBuffer[0];
        FileName->FileNameLength = sizeof(NameBuffer) - sizeof(ULONG);

        NtStatus2 = NtQueryInformationFile(File,
                                           &IoStatusBlock,
                                           FileName,
                                           sizeof(NameBuffer),
                                           FileNameInformation );


        if (!NT_SUCCESS(NtStatus2)) {
            DPRINT_NT(1, "++ NtQueryInformationFile - FileNameInformation failed:",
                      NtStatus2);
        } else {
            FileName->FileName[FileName->FileNameLength/2] = UNICODE_NULL;
            DPRINT1(5, "++ Name of created file is: %ws\n", FileName->FileName);               //
        }
    }

    //
    // Return the file handle.
    //
    *Handle = File;

    return FrsSetLastNTError(NtStatus);
}





DWORD
FrsDeleteFile(
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Delete the file

Arguments:
    Name

Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsDeleteFile:"

    DWORD  WStatus = ERROR_SUCCESS;
    //
    // Delete file
    //
    DPRINT1(4, "++ Deleting %ws\n", Name);

    if (!DeleteFile(Name)) {
        WStatus = GetLastError();
        if (WStatus != ERROR_FILE_NOT_FOUND &&
            WStatus != ERROR_PATH_NOT_FOUND) {
            DPRINT1_WS(0, "++ Can't delete file %ws;", Name, WStatus);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }

    return WStatus;
}










DWORD
FrsCreateDirectory(
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Create a directory

Arguments:
    Name

Return Value:
    Win32 Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsCreateDirectory:"
    ULONG   WStatus;

    //
    // Create the directory
    //
    if (!CreateDirectory(Name, NULL)) {
        WStatus = GetLastError();
        if (!WIN_ALREADY_EXISTS(WStatus)) {
            DPRINT1_WS(0, "Can't create directory %ws;", Name, WStatus);
            return WStatus;
        }
    }
    return ERROR_SUCCESS;
}


DWORD
FrsVerifyVolume(
    IN PWCHAR   Path,
    IN PWCHAR   SetName,
    IN ULONG    Flags
    )
/*++
Routine Description:
    Does the volume exist and is it NTFS?  If not generate an event log entry
    and return non success.
    Also if we are checking the volume for object id support then check
    that the volume does not share the same Volume Serial Number with
    other volumes in VolSerialNumberToDriveTable.

Arguments:
    Path  --  A path string with a volume component.
    SetName -- the Replica set name for event log messages.
    Flags  -- The file system flags that must be set.  The currently valid
           set are:
            FILE_CASE_SENSITIVE_SEARCH
            FILE_CASE_PRESERVED_NAMES
            FILE_UNICODE_ON_DISK
            FILE_PERSISTENT_ACLS
            FILE_FILE_COMPRESSION
            FILE_VOLUME_QUOTAS
            FILE_SUPPORTS_SPARSE_FILES
            FILE_SUPPORTS_REPARSE_POINTS
            FILE_SUPPORTS_REMOTE_STORAGE
            FILE_VOLUME_IS_COMPRESSED
            FILE_SUPPORTS_OBJECT_IDS
            FILE_SUPPORTS_ENCRYPTION
            FILE_NAMED_STREAMS

Return Value:
    WIN32 Status
--*/

{
#undef DEBSUB
#define DEBSUB  "FrsVerifyVolume:"

    DWORD                          WStatus                = ERROR_SUCCESS;
    PWCHAR                         VolumeName             = NULL;
    ULONG                          FsAttributeInfoLength;
    IO_STATUS_BLOCK                Iosb;
    NTSTATUS                       Status;
    PFILE_FS_ATTRIBUTE_INFORMATION FsAttributeInfo        = NULL;
    HANDLE                         PathHandle             = INVALID_HANDLE_VALUE;
    DWORD                          VolumeInfoLength;
    PFILE_FS_VOLUME_INFORMATION    VolumeInfo             = NULL;
    PVOLUME_INFO_NODE              VolumeInfoNode         = NULL;
    ULONG                          Colon = 0;
    WCHAR                          LogicalDrive[5]; // "D:\<null><null>"
    PGEN_ENTRY                     VolumeInfoNodeEntry    = NULL;
    PWCHAR                         ListOfVolumes          = NULL;
    PWCHAR                         TempListOfVolumes      = NULL;
    WCHAR                          VSNStr[MAX_PATH];// "%04x-%04x"
    BOOL                           DuplicateVSNFound      = FALSE;


    if ((Path == NULL) || (wcslen(Path) == 0)) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto RETURN;
    }

    //
    // Always open the path by masking off the FILE_OPEN_REPARSE_POINT flag
    // because we want to open the destination dir not the junction if the root
    // happens to be a mount point.
    //
    WStatus = FrsOpenSourceFileW(&PathHandle,
                                 Path,
                                 GENERIC_READ,
                                 FILE_OPEN_FOR_BACKUP_INTENT);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "ERROR - Unable to open root path %ws. Retry at next poll.",
                   Path, WStatus);
        goto RETURN;
    }

    //
    // Get the volume information.
    //
    FsAttributeInfoLength = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    FsAttributeInfo = FrsAlloc(FsAttributeInfoLength);

    Status = NtQueryVolumeInformationFile(PathHandle,
                                          &Iosb,
                                          FsAttributeInfo,
                                          FsAttributeInfoLength,
                                          FileFsAttributeInformation);
    if (!NT_SUCCESS(Status)) {

        DPRINT2(0,"ERROR - Getting  NtQueryVolumeInformationFile for %ws. NtStatus = %08x\n",
                Path, Status);

        goto RETURN;
    }

    if ((FsAttributeInfo->FileSystemAttributes & Flags) != Flags) {
        DPRINT3(0, "++ Error - Required filesystem not present for %ws.  Needed %08x,  Found %08x\n",
                Path, Flags, FsAttributeInfo->FileSystemAttributes);
        WStatus = ERROR_INVALID_PARAMETER;
        goto RETURN;
    }

    WStatus = ERROR_SUCCESS;

    //
    // If we are checking for object ids then we must be
    // verifying the root volume. Also check that this volume
    // does not share volumeserialnumber with any other volume
    // on this computer. Currently (05/18/2002) we rely on
    // VolumeSerialNumber being unique. We use it to find out
    // which volume to open the journal on. If there are mutiple
    // volumes on a machine with the same VSN then we could open
    // the journal on the wrong volume. Print a eventlog message
    // and return error.
    //
    if (Flags & FILE_SUPPORTS_OBJECT_IDS) {
        VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                           MAXIMUM_VOLUME_LABEL_LENGTH;

        VolumeInfo = FrsAlloc(VolumeInfoLength);

        Status = NtQueryVolumeInformationFile(PathHandle,
                                              &Iosb,
                                              VolumeInfo,
                                              VolumeInfoLength,
                                              FileFsVolumeInformation);

        if (NT_SUCCESS(Status)) {
            //
            // Look for the volume if the mapping table exists.
            //
            if (VolSerialNumberToDriveTable != NULL) {

                VolumeInfoNode = GTabLookup(VolSerialNumberToDriveTable,
                                            &(VolumeInfo->VolumeSerialNumber),
                                            NULL);
            }

            //
            // If the volume is not found in the table or if the table is not yet
            // initialized then initialize the table and add the drive taken from
            // this path to the list of drives in the table. In most cases the
            // drive extracted from the path will be same as the volume that hosts the
            // path. If that is not the case then we re-build the table by
            // enumerating all the drives on the computer below.
            //
            if (VolumeInfoNode == NULL) {
                //
                // Create the table and add the prefix drive to the table of drives.
                // Find the position of colon in the path to extract the drive letter.
                // The path may be of the form "d:\replicaroot" or "\\?\d:\replicaroot"
                //
                Colon = wcscspn(Path, L":");

                if (Path[Colon] == L':') {
                    CopyMemory(LogicalDrive, &Path[Colon - 1], 3 * sizeof(WCHAR)); // "D:\"
                    LogicalDrive[3] = L'\0';
                    LogicalDrive[4] = L'\0';
                } // else LogicalDrive remains NULL

                //
                // Add the drive and do not empty the table.
                //
                FrsBuildVolSerialNumberToDriveTable(LogicalDrive, FALSE);

                VolumeInfoNode = GTabLookup(VolSerialNumberToDriveTable, &(VolumeInfo->VolumeSerialNumber), NULL);
            }

            //
            // If the volume is still not found in the mapping table then it means that
            // the prefix of the path (E.g. "D:\" if the path is "D:\replicaroot" ) is not the
            // volume that hosts the path. In this case load the mapping table with all
            // the drives on the computer and look for the volume again.
            //
            if (VolumeInfoNode == NULL) {

                //
                // Could not find the drive in the table. Rebuild the table by enumerating
                // all the drives on the computer and try again.
                //

                DPRINT1(2, "WARN - Enumerating all drives on the computer to find the volume for path %ws\n", Path);

                //
                // Enumerate and add all drives to the table. Empty the table before starting.
                //
                FrsBuildVolSerialNumberToDriveTable(NULL, TRUE);

                VolumeInfoNode = GTabLookup(VolSerialNumberToDriveTable, &(VolumeInfo->VolumeSerialNumber), NULL);
            }


            if (VolumeInfoNode) {
                //
                // Check if there are duplicates.
                //
                LOCK_GEN_TABLE(VolSerialNumberToDriveTable);
                VolumeInfoNodeEntry = GTabLookupEntryNoLock(VolSerialNumberToDriveTable, &(VolumeInfo->VolumeSerialNumber), NULL);
                if ((VolumeInfoNodeEntry != NULL) && (VolumeInfoNodeEntry->Dups != NULL)) {
                    //
                    // The volume we are verifying shares VSN with
                    // one or more other volumes. Collect data for the
                    // eventlog message.
                    //
                    wsprintf(VSNStr, L"%04x-%04x",
                     ((VolumeInfo->VolumeSerialNumber >> 16) & 0x0000ffff),
                     (VolumeInfo->VolumeSerialNumber & 0x0000ffff));
                    do {
                        VolumeInfoNode = VolumeInfoNodeEntry->Data;
                        if (ListOfVolumes != NULL) {
                            //
                            // DriveName is of the form \\.\D:
                            //
                            if (wcslen(VolumeInfoNode->DriveName) >= 6) {
                                TempListOfVolumes = FrsWcsCat3(ListOfVolumes,L", ",&VolumeInfoNode->DriveName[4]);
                            } else {
                                TempListOfVolumes = FrsWcsCat3(ListOfVolumes,L", ",VolumeInfoNode->DriveName);
                            }
                            FrsFree(ListOfVolumes);
                        } else {
                            if (wcslen(VolumeInfoNode->DriveName) >= 6) {
                                TempListOfVolumes = FrsWcsDup(&VolumeInfoNode->DriveName[4]);
                            }else{
                                TempListOfVolumes = FrsWcsDup(VolumeInfoNode->DriveName);
                            }
                        }
                        ListOfVolumes = TempListOfVolumes;
                        VolumeInfoNodeEntry = VolumeInfoNodeEntry->Dups;
                    } while ( VolumeInfoNodeEntry != NULL );

                    EPRINT2(EVENT_FRS_DUPLICATE_VSN,VSNStr,ListOfVolumes);
                    FrsFree(ListOfVolumes);
                    DuplicateVSNFound = TRUE;
                }
                UNLOCK_GEN_TABLE(VolSerialNumberToDriveTable);
            } else {
                DPRINT1(0, "ERROR - Volume not found for path %ws\n", Path);
                WStatus = ERROR_FILE_NOT_FOUND;
            }
        } else {
            DPRINT1_NT(1,"WARN - NtQueryVolumeInformationFile failed for %ws;", Path, Status);
            WStatus = FrsSetLastNTError(Status);
        }
    }

RETURN:

    if (!WIN_SUCCESS(WStatus)) {
        if (WStatus == ERROR_INVALID_PARAMETER) {
            //
            // Generate an event log message.
            //
            VolumeName = FrsWcsVolume(Path);
            EPRINT4(EVENT_FRS_VOLUME_NOT_SUPPORTED,
                    SetName,
                    ComputerName,
                    ((Path == NULL)       ? L"<null>" : Path),
                    ((VolumeName == NULL) ? L"<null>" : VolumeName));
        } else if (DuplicateVSNFound == FALSE){
            //
            // Something else is wrong. Print generic root
            // invalid message.
            //
            EPRINT1(EVENT_FRS_ROOT_NOT_VALID, Path);
        }
    }

    FrsFree(FsAttributeInfo);
    FrsFree(VolumeInfo);
    FRS_CLOSE(PathHandle);
    FrsFree(VolumeName);

    return WStatus;

}


DWORD
FrsCheckForNoReparsePoint(
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Does the path reside on the same volume at the prefix drive name?
    It won't exist on the same volume if any element of the path
    is a reparse point pointing to a directory on another volume.

Arguments:
    Name

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsCheckForNoReparsePoint:"
    DWORD                        WStatus;
    NTSTATUS                     Status;
    PWCHAR                       Volume            = NULL;
    PWCHAR                       Temp              = NULL;
    HANDLE                       FileHandlePath;
    HANDLE                       FileHandleDrive;
    IO_STATUS_BLOCK              Iosb;
    PFILE_FS_VOLUME_INFORMATION  VolumeInfoPath    = NULL;
    PFILE_FS_VOLUME_INFORMATION  VolumeInfoDrive   = NULL;
    ULONG                        VolumeInfoLength;

    if (!Name) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the handle to the path passed in.
    //
    WStatus = FrsOpenSourceFileW(&FileHandlePath,
                                 Name,
//                                 READ_ACCESS,
                                 READ_ATTRIB_ACCESS,
                                 OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);
    CLEANUP1_WS(4, "++ ERROR - FrsOpenSourceFile(%ws);", Name, WStatus, CLEANUP);

    //
    // Get the volume information for this handle.
    //
    VolumeInfoPath = FrsAlloc(sizeof(FILE_FS_VOLUME_INFORMATION) + MAXIMUM_VOLUME_LABEL_LENGTH);
    VolumeInfoLength = sizeof(*VolumeInfoPath) + MAXIMUM_VOLUME_LABEL_LENGTH;

    Status = NtQueryVolumeInformationFile(FileHandlePath,
                                          &Iosb,
                                          VolumeInfoPath,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    NtClose(FileHandlePath);
    if (!NT_SUCCESS(Status)) {
        WStatus = FrsSetLastNTError(Status);
        CLEANUP1_NT(4, "++ ERROR - NtQueryVolumeInformationFile(%ws);",
                    Name, Status, CLEANUP);
    }

    //
    // Get the volume part of the absolute path.
    //
    Temp = FrsWcsVolume(Name);

    if (!Temp || (wcslen(Temp) == 0)) {
        WStatus = ERROR_FILE_NOT_FOUND;
        goto CLEANUP;
    }

    Volume = FrsWcsCat(Temp, L"\\");

    //
    // Get the handle to the prefix drive of the path passed in.
    //
    WStatus = FrsOpenSourceFileW(&FileHandleDrive, Volume,
//                                 READ_ACCESS,
                                 READ_ATTRIB_ACCESS,
                                 OPEN_OPTIONS);
    CLEANUP1_WS(4, "++ ERROR - opening volume %ws ;", Volume, WStatus, CLEANUP);

    //
    // Get the volume information for this handle.
    //
    VolumeInfoDrive = FrsAlloc(sizeof(FILE_FS_VOLUME_INFORMATION) + MAXIMUM_VOLUME_LABEL_LENGTH);
    VolumeInfoLength = sizeof(*VolumeInfoDrive) + MAXIMUM_VOLUME_LABEL_LENGTH;

    Status = NtQueryVolumeInformationFile(FileHandleDrive,
                                          &Iosb,
                                          VolumeInfoDrive,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    NtClose(FileHandleDrive);
    if (!NT_SUCCESS(Status)) {
        WStatus = FrsSetLastNTError(Status);
        CLEANUP1_NT(4, "++ ERROR - NtQueryVolumeInformationFile(%ws);",
                    Volume, Status, CLEANUP);
    }

    //
    // Now compare the VolumeSerialNumber acquired from the above two queries.
    // If it is the same then there are no reparse points in the path that
    // redirect the path to a different volume.
    //
    if (VolumeInfoPath->VolumeSerialNumber != VolumeInfoDrive->VolumeSerialNumber) {
        WStatus = ERROR_GEN_FAILURE;
        DPRINT2(0, "++ Error - VolumeSerialNumber mismatch %x != %x\n",
                VolumeInfoPath->VolumeSerialNumber,
                VolumeInfoDrive->VolumeSerialNumber);
        DPRINT2(0, "++ Error - Root path (%ws) is not on %ws. Invalid replica root path.\n",
                Name,Volume);
        goto CLEANUP;
    }

CLEANUP:
    //
    // Cleanup
    //
    FrsFree(VolumeInfoPath);
    FrsFree(Volume);
    FrsFree(Temp);
    FrsFree(VolumeInfoDrive);
    return WStatus;
}


DWORD
FrsDoesDirectoryExist(
    IN  PWCHAR   Name,
    OUT PDWORD   pAttributes
    )
/*++
Routine Description:
    Does the directory Name exist?

Arguments:
    Name
    pAttributes - return the attributes on the file/dir if it exits.

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsDoesDirectoryExist:"
    DWORD   WStatus;

    //
    // Can't get attributes
    //
    *pAttributes = GetFileAttributes(Name);

    if (*pAttributes == 0xFFFFFFFF) {
        WStatus = GetLastError();
        DPRINT1_WS(4, "++ GetFileAttributes(%ws); ", Name, WStatus);
        return WStatus;
    }

    //
    // Not a directory
    //
    if (!(*pAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        DPRINT1(4, "++ %ws is not a directory\n", Name);
        return ERROR_DIRECTORY;
    }


    return ERROR_SUCCESS;

}







DWORD
FrsDoesFileExist(
    IN PWCHAR   Name
    )
/*++
Routine Description:
    Does the file Name exist?

Arguments:
    Name

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsDoesFileExist:"
    DWORD   WStatus;
    DWORD   Attributes;

    //
    // Can't get attributes
    //
    Attributes = GetFileAttributes(Name);
    if (Attributes == 0xFFFFFFFF) {
        WStatus = GetLastError();
        DPRINT1_WS(4, "++ GetFileAttributes(%ws); ", Name, WStatus);
        return WStatus;
    }
    //
    // Not a directory
    //
    if (Attributes & FILE_ATTRIBUTE_DIRECTORY) {
        DPRINT1(4, "++ %ws is not a file\n", Name);
        return ERROR_DIRECTORY;
    }
    return ERROR_SUCCESS;
}



DWORD
FrsSetFilePointer(
    IN PWCHAR       Name,
    IN HANDLE       Handle,
    IN ULONG        High,
    IN ULONG        Low
    )
/*++
Routine Description:
    Position file pointer

Arguments:
    Handle
    Name
    High
    Low

Return Value:
    Win32 Error Status

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetFilePointer:"

    DWORD WStatus  = ERROR_SUCCESS;

    Low = SetFilePointer(Handle, Low, &High, FILE_BEGIN);

    if (Low == INVALID_SET_FILE_POINTER) {
        WStatus = GetLastError();
        if (WStatus != NO_ERROR) {
            DPRINT1_WS(0, "++ Can't set file pointer for %ws;", Name, WStatus);
        }
    }

    return WStatus;
}







DWORD
FrsSetFileTime(
    IN PWCHAR       Name,
    IN HANDLE       Handle,
    IN FILETIME     *CreateTime,
    IN FILETIME     *AccessTime,
    IN FILETIME     *WriteTime
    )
/*++
Routine Description:
    Position file pointer

Arguments:
    Name
    Handle
    Attributes
    CreateTime
    AccessTime
    WriteTime

Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetFileTime:"

   DWORD    WStatus  = ERROR_SUCCESS;

   if (!SetFileTime(Handle, CreateTime, AccessTime, WriteTime)) {
       WStatus = GetLastError();
       DPRINT1_WS(0, "++ Can't set file times for %ws;", Name, WStatus);
   }
   return WStatus;
}


DWORD
FrsSetEndOfFile(
    IN PWCHAR       Name,
    IN HANDLE       Handle
    )
/*++
Routine Description:
    Set end of file at current file position

Arguments:
    Handle
    Name

Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetEndOfFile:"

   DWORD    WStatus  = ERROR_SUCCESS;

   if (!SetEndOfFile(Handle)) {
       WStatus = GetLastError();
       DPRINT1_WS(0, "++ ERROR - Setting EOF for %ws;", Name, WStatus);
   }

   return WStatus;
}









DWORD
FrsFlushFile(
    IN PWCHAR   Name,
    IN HANDLE   Handle
    )
/*++
Routine Description:
    Flush the file's data to disk

    Assumes that the debug lock is already held.

Arguments:
    Handle
    Name

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsFlushFile:"

    DWORD    WStatus  = ERROR_SUCCESS;

    if (HANDLE_IS_VALID(Handle)) {
        if (!FlushFileBuffers(Handle)) {
            WStatus = GetLastError();
            DPRINT1_WS_NOLOCK(0, "++ Can't flush file for %ws;", Name, WStatus);
        }
    }

    return WStatus;
}



DWORD
FrsSetCompression(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    IN USHORT   TypeOfCompression
    )
/*++
Routine Description:
    Enable compression on Handle.

Arguments:
    Name
    Handle
    TypeOfCompression

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetCompression:"
    DWORD   BytesReturned;
    DWORD   WStatus  = ERROR_SUCCESS;

    if (!DeviceIoControl(Handle,
                         FSCTL_SET_COMPRESSION,
                         &TypeOfCompression, sizeof(TypeOfCompression),
                         NULL, 0, &BytesReturned, NULL)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ Can't set compression on %ws;", Name, WStatus);
    }
    return WStatus;
}






DWORD
FrsGetCompression(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    IN PUSHORT  TypeOfCompression
    )
/*++
Routine Description:
    Enable compression on Handle.

Arguments:
    Handle
    Name
    TypeOfCompression

Return Value:
    WStatus
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsGetCompression:"
    DWORD   BytesReturned;
    DWORD   WStatus  = ERROR_SUCCESS;

    if (!DeviceIoControl(Handle,
                         FSCTL_GET_COMPRESSION,
                         NULL, 0,
                         TypeOfCompression, sizeof(TypeOfCompression),
                         &BytesReturned, NULL)) {
        WStatus = GetLastError();
        DPRINT1_WS(0, "++ Can't get compression for %ws;", Name, WStatus);
    }
    return WStatus;
}



DWORD
FrsRenameByHandle(
    IN PWCHAR  Name,
    IN ULONG   NameLen,
    IN HANDLE  Handle,
    IN HANDLE  TargetHandle,
    IN BOOL    ReplaceIfExists
    )
/*++
Routine Description:
    Rename the file

Arguments:
    Name - New name
    NameLen - length of Name
    Handle - file handle
    TargetHandle - Target directory
    ReplaceIfExists

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsRenameByHandle:"
    PFILE_RENAME_INFORMATION RenameInfo;
    IO_STATUS_BLOCK          IoStatus;
    ULONG                    NtStatus;

    //
    // Rename the file; deleting any destination file if requested
    //
    RenameInfo = FrsAlloc(sizeof(FILE_RENAME_INFORMATION) + NameLen);
    RenameInfo->ReplaceIfExists = (ReplaceIfExists != 0);
    RenameInfo->RootDirectory = TargetHandle;
    RenameInfo->FileNameLength = NameLen;
    CopyMemory(RenameInfo->FileName, Name, NameLen);
    NtStatus = NtSetInformationFile(Handle,
                                    &IoStatus,
                                    RenameInfo,
                                        sizeof(FILE_RENAME_INFORMATION)
                                        + NameLen,
                                    FileRenameInformation);
    FrsFree(RenameInfo);

    DPRINT1_NT(5, "++ INFO - Renaming %ws failed; ", Name, NtStatus);
    return FrsSetLastNTError(NtStatus);
}



DWORD
FrsCheckObjectId(
    IN PWCHAR   Name,
    IN HANDLE   Handle,
    IN GUID     *Guid
    )
/*++
Routine Description:
    Check that the GUID on the file is the same.

Arguments:
    Name    - for error messages
    Handle  - Supplies a handle to the file
    Guid    - guid to check

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCheckObjectId:"
    DWORD                 WStatus;
    FILE_OBJECTID_BUFFER  ObjectIdBuffer;

    //
    // Get the file's object id and check it
    //
    WStatus = FrsGetObjectId(Handle, &ObjectIdBuffer);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ No object id for file %ws;", Name, WStatus);
    } else {
        //
        // Same file, no morph needed. (must have been renamed sometime before)
        //
        if (memcmp(ObjectIdBuffer.ObjectId, Guid, sizeof(GUID))) {
            DPRINT1(4, "++ Object ids don't match for file %ws\n", Name);
            WStatus = ERROR_FILE_NOT_FOUND;
        }
    }
    return WStatus;
}


PWCHAR
FrsCreateGuidName(
    IN GUID     *Guid,
    IN PWCHAR   Prefix
    )
/*++
Routine Description:
    Convert the guid into a file name

Arguments:
    Guid
    Prefix

Return Value:
    Character string
--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateGuidName:"
    WCHAR       WGuid[GUID_CHAR_LEN + 1];

    //
    // Translate the guid into a string
    //
    GuidToStrW(Guid, WGuid);

    //
    // Create the file name <prefix>Guid
    //
    return FrsWcsCat(Prefix, WGuid);
}


DWORD
FrsGetObjectId(
    IN  HANDLE Handle,
    OUT PFILE_OBJECTID_BUFFER ObjectIdBuffer
    )
/*++

Routine Description:

    This routine reads the object ID.

Arguments:

    Handle -- The file handle of an opened file.

    ObjectIdBuffer -- The output buffer to hold the object ID.

Return Value:

    Returns the Win Status of the last error found, or success.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetObjectId:"

    NTSTATUS        NtStatus;
    IO_STATUS_BLOCK Iosb;
    CHAR            GuidStr[GUID_CHAR_LEN];

    //
    // zero the buffer in case the data that comes back is short.
    //
    ZeroMemory(ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));

    //
    // Get the Object ID
    //
    NtStatus = NtFsControlFile(Handle,                          // file handle
                               NULL,                            // event
                               NULL,                            // apc routine
                               NULL,                            // apc context
                               &Iosb,                           // iosb
                               FSCTL_GET_OBJECT_ID,             // FsControlCode
                               &Handle,                         // input buffer
                               sizeof(HANDLE),                  // input buffer length
                               ObjectIdBuffer,                  // OutputBuffer for data from the FS
                               sizeof(FILE_OBJECTID_BUFFER));   // OutputBuffer Length

    if (NT_SUCCESS(NtStatus)) {
        GuidToStr((GUID *)ObjectIdBuffer->ObjectId, GuidStr);
        DPRINT1(4, "++ Existing oid for this file is %s\n", GuidStr );
    }
    return FrsSetLastNTError(NtStatus);
}


DWORD
FrsGetOrSetFileObjectId(
    IN  HANDLE Handle,
    IN  LPCWSTR FileName,
    IN  BOOL CallerSupplied,
    OUT PFILE_OBJECTID_BUFFER ObjectIdBuffer
    )
/*++

Routine Description:

    This routine reads the object ID.  If there is no
    object ID on the file we put one on it.  If the CallerSupplied flag is
    TRUE then we delete the current object ID on the file (if any) and
    stamp the object ID provided on the file.

    Note:  This function does not preserve the 48 byte extended info in the
    object ID.  Currently this is not a problem but could be a link tracking
    issue in the future.

Arguments:

    Handle -- The file handle of an opened file.

    FileName -- The name of the file.  For error messages only.

    CallerSupplied -- TRUE if caller supplies new OID to override ANY
                      OID currently on the file.

    ObjectIdBuffer -- The output buffer to hold the object ID.

Return Value:

    Returns the Win Status of the last error found, or success.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsGetOrSetFileObjectId:"

    DWORD           WStatus = ERROR_SUCCESS;
    NTSTATUS        NtStatus;
    ULONG           ObjectIdBufferSize;
    IO_STATUS_BLOCK Iosb;
    CHAR            GuidStr[GUID_CHAR_LEN];
    LONG            Loop;

    ObjectIdBufferSize = sizeof(FILE_OBJECTID_BUFFER);

    if (!CallerSupplied) {
        WStatus = FrsGetObjectId(Handle, ObjectIdBuffer);
        if (WIN_SUCCESS(WStatus)) {
            return WStatus;
        }
        //
        // Clear the extra bits past the object id
        //
        ZeroMemory(ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));
    }

    if (WIN_OID_NOT_PRESENT(WStatus) || CallerSupplied) {
        //
        // No object ID on the file. Create one.  Just in case, try 15 times
        // to get a unique one. Don't let the kernel create the object ID
        // using FSCTL_CREATE_OR_GET_OBJECT_ID since it currently (April 97)
        // doesn't add the net card address.
        //
        Loop = 0;

        do {
            if (!CallerSupplied) {
                FrsUuidCreate((GUID *)ObjectIdBuffer->ObjectId);
            }

            if (Loop > 0) {
                DPRINT2(1, "++ Failed to assign Object ID %s (dup_name, retrying) to the file: %ws\n",
                        GuidStr, FileName);
            }
            GuidToStr((GUID *)ObjectIdBuffer->ObjectId, GuidStr);

            //
            // If this object ID is caller supplied then there might already
            // be one on the file so delete it first.
            //
            NtStatus = NtFsControlFile(
                Handle,                      // file handle
                NULL,                        // event
                NULL,                        // apc routine
                NULL,                        // apc context
                &Iosb,                       // iosb
                FSCTL_DELETE_OBJECT_ID,      // FsControlCode
                NULL,                        // input buffer
                0,                           // input buffer length
                NULL,                        // OutputBuffer for data from the FS
                0);                          // OutputBuffer Length


            NtStatus = NtFsControlFile(
                Handle,                      // file handle
                NULL,                        // event
                NULL,                        // apc routine
                NULL,                        // apc context
                &Iosb,                       // iosb
                FSCTL_SET_OBJECT_ID,         // FsControlCode
                ObjectIdBuffer,              // input buffer
                ObjectIdBufferSize,          // input buffer length
                NULL,                        // OutputBuffer for data from the FS
                0);                          // OutputBuffer Length

        } while ((NtStatus == STATUS_DUPLICATE_NAME) &&
                 (++Loop < 16) &&
                 (!CallerSupplied));

        if (!NT_SUCCESS(NtStatus)) {
            DPRINT1_NT(1, "++ ERROR - Set oid failed on file %ws;", FileName, NtStatus);
        } else {
            GuidToStr((GUID *)ObjectIdBuffer->ObjectId, GuidStr);
            DPRINT2(4, "++ Assigned Object ID %s (success) to the file: %ws\n",
                    GuidStr, FileName);
        }

        return FrsSetLastNTError(NtStatus);
    }
    return WStatus;
}


DWORD
FrsDeleteFileObjectId(
    IN  HANDLE Handle,
    IN  LPCWSTR FileName
    )
/*++

Routine Description:

    Delete object id (if it exists)

Arguments:

    Handle -- The file handle of an opened file.

    FileName -- The name of the file.  For error messages only.

Return Value:

    Returns the Win Status of the last error found, or success.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteFileObjectId:"

    NTSTATUS NtStatus;
    DWORD    WStatus;
    IO_STATUS_BLOCK Iosb;

    //
    // Remove the object id from the file
    //
    NtStatus = NtFsControlFile(Handle,                      // file handle
                               NULL,                        // event
                               NULL,                        // apc routine
                               NULL,                        // apc context
                               &Iosb,                       // iosb
                               FSCTL_DELETE_OBJECT_ID,      // FsControlCode
                               NULL,                        // input buffer
                               0,                           // input buffer length
                               NULL,                        // OutputBuffer for data from the FS
                               0);                          // OutputBuffer Length

    WStatus = FrsSetLastNTError(NtStatus);

    if (WIN_NOT_IMPLEMENTED(WStatus)) {
        DPRINT1_WS(0, "++ Could not delete object id for %ws (not implemented);", FileName, WStatus);
    } else

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "++ Could not delete object id for %ws;", FileName, WStatus);
    } else {
        DPRINT1(4, "++ Deleted object id from %ws.\n", FileName);
    }

    return WStatus;
}



DWORD
FrsReadFileUsnData(
    IN  HANDLE Handle,
    OUT USN *UsnBuffer
    )
/*++

Routine Description:

    This routine reads the USN of the last modify operation to a file.

Arguments:

    Handle -- The file handle of an opened file.

    UsnBuffer -- The output buffer to hold the object ID.

Return Value:

    Returns the NTSTATUS of the last error found, or success.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsReadFileUsnData:"

    ULONG           NtStatus;
    IO_STATUS_BLOCK Iosb;

    ULONGLONG Buffer[(sizeof(USN_RECORD) + MAX_PATH*2 + 7)/8];


    //
    // Go get the USN record for the file.
    //
    NtStatus = NtFsControlFile(
        Handle,                          // file handle
        NULL,                            // event
        NULL,                            // apc routine
        NULL,                            // apc context
        &Iosb,                           // iosb
        FSCTL_READ_FILE_USN_DATA,        // FsControlCode
        &Handle,                         // input buffer
        sizeof(HANDLE),                  // input buffer length
        Buffer,                          // OutputBuffer for USNRecord
        sizeof(Buffer));                 // OutputBuffer Length


    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_INVALID_DEVICE_STATE) {
            DPRINT(0, "++ FSCTL_READ_FILE_USN_DATA failed.  No journal on volume\n");
        }
        DPRINT_NT(0, "++ FSCTL_READ_FILE_USN_DATA failed. ", NtStatus);
        return FrsSetLastNTError(NtStatus);
    }
    //
    // Return the last USN on the file.
    //
    *UsnBuffer = ((PUSN_RECORD) (Buffer))->Usn;

    DUMP_USN_RECORD(4, (PUSN_RECORD)(Buffer));

    return ERROR_SUCCESS;
}



DWORD
FrsReadFileParentFid(
    IN  HANDLE Handle,
    OUT ULONGLONG *ParentFid
    )
/*++

Routine Description:

    This routine reads the parent FID for the file.

    *** WARNING ***
    Note with multiple links to a file there could be multiple parents.
    NTFS gives us one of them.

Arguments:

    Handle -- The file handle of an opened file.

    ParentFid -- The output buffer to hold the parent file ID.

Return Value:

    Returns the NTSTATUS of the last error found, or success.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsReadFileParentFid:"

    ULONG           NtStatus;
    IO_STATUS_BLOCK Iosb;


    ULONGLONG Buffer[(sizeof(USN_RECORD) + MAX_PATH*2 + 7)/8];



    //
    // Go get the USN record for the file.
    //
    NtStatus = NtFsControlFile(
        Handle,                          // file handle
        NULL,                            // event
        NULL,                            // apc routine
        NULL,                            // apc context
        &Iosb,                           // iosb
        FSCTL_READ_FILE_USN_DATA,        // FsControlCode
        &Handle,                         // input buffer
        sizeof(HANDLE),                  // input buffer length
        Buffer,                          // OutputBuffer for USNRecord
        sizeof(Buffer));                 // OutputBuffer Length


    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_INVALID_DEVICE_STATE) {
            DPRINT(0, "++ FSCTL_READ_FILE_USN_DATA failed.  No journal on volume\n");
        }
        DPRINT_NT(0, "++ FSCTL_READ_FILE_USN_DATA failed.", NtStatus);
        *ParentFid = ZERO_FID;

        return FrsSetLastNTError(NtStatus);
    }
    //
    // Return a parent FID for the file.  (could be more than one with links)
    //
    *ParentFid = ((PUSN_RECORD) (Buffer))->ParentFileReferenceNumber;

    DUMP_USN_RECORD(4, (PUSN_RECORD)(Buffer));

    return ERROR_SUCCESS;
}


DWORD
FrsGetReparseTag(
    IN  HANDLE  Handle,
    OUT ULONG   *ReparseTag
    )
/*++

Routine Description:

    Return the value of the reparse tag.

Arguments:

    Handle - Handle for a reparse point

    ReparseTag - returned reparse tag if ERROR_SUCCESS

Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetReparseTag:"
    NTSTATUS    NtStatus;
    DWORD       ReparseDataLength;
    PCHAR       ReparseBuffer;
    IO_STATUS_BLOCK         IoStatusBlock;
    PREPARSE_DATA_BUFFER    ReparseBufferHeader;

    //
    //  Allocate a buffer and get the information.
    //
    ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
    ReparseBuffer = FrsAlloc(ReparseDataLength);

    //
    //  Query the reparse point.
    //
    NtStatus = NtFsControlFile(Handle,
                               NULL,
                               NULL,
                               NULL,
                               &IoStatusBlock,
                               FSCTL_GET_REPARSE_POINT,
                               NULL,
                               0,
                               (PVOID)ReparseBuffer,
                               ReparseDataLength
                               );

    if (!NT_SUCCESS(NtStatus)) {
        DPRINT_NT(4, "++ Could not get reparse point;", NtStatus);
        FrsFree(ReparseBuffer);
        return FrsSetLastNTError(NtStatus);
    }
    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    *ReparseTag = ReparseBufferHeader->ReparseTag;
    FrsFree(ReparseBuffer);
    return ERROR_SUCCESS;
}


DWORD
FrsGetReparseData(
    IN  HANDLE  Handle,
    OUT PREPARSE_GUID_DATA_BUFFER   *ReparseData,
    OUT ULONG       *ReparseTag
    )
/*++

Routine Description:

    Return the value of the reparse tag.

Arguments:

    Handle - Handle for a reparse point

    ReparseData - returned reparse data buffer if ERROR_SUCCESS
                NOTE: ReparseData can be NULL on success.

Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsGetReparseData:"
    NTSTATUS    NtStatus;
    DWORD       ReparseDataLength;
    IO_STATUS_BLOCK         IoStatusBlock;


    //
    //  Allocate a buffer and get the information.
    //
    ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
    *ReparseData = FrsAlloc(ReparseDataLength);

    //
    //  Query the reparse point.
    //
    NtStatus = NtFsControlFile(Handle,
                               NULL,
                               NULL,
                               NULL,
                               &IoStatusBlock,
                               FSCTL_GET_REPARSE_POINT,
                               NULL,
                               0,
                               (PVOID)*ReparseData,
                               ReparseDataLength
                               );

    if (!NT_SUCCESS(NtStatus)) {
        DPRINT_NT(4, "++ Could not get reparse point;", NtStatus);
        FrsFree(*ReparseData);
        return FrsSetLastNTError(NtStatus);
    }

    *ReparseTag = (*ReparseData)->ReparseTag;


    //
    // We only accept operations on files with certain reparse points.
    // For example a rename of a SIS file into a replica tree needs to prop
    // a create CO.
    //
    if (!ReparseTagReplicate(*ReparseTag)) {
        DPRINT1(4, "++ Reparse tag %08x is unsupported.\n", *ReparseTag);

        FrsFree(*ReparseData);
        *ReparseData = NULL;
        return ERROR_GEN_FAILURE;
    }


    //
    // If we are replicating the file data we will
    // not replicate the reparse poiont.
    //
    if(ReparseTagReplicateFileData(*ReparseTag)) {
        DPRINT1(4, "++ Reparse tag %08x. Will not replicate reparse point.\n", *ReparseTag);
        FrsFree(*ReparseData);
        *ReparseData = NULL;
    }

    return ERROR_SUCCESS;
}


DWORD
FrsCheckReparse(
    IN     PWCHAR Name,
    IN     PVOID  Id,
    IN     DWORD  IdLen,
    IN     HANDLE VolumeHandle
    )
/*++
Routine Description:

    Check that the reparse point is allowed

Arguments:
    Name            - File name for error messages
    Id              - Fid or Oid
    VolumeHandle    - open handle to the volume root.

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsCheckReparse:"
    DWORD       WStatus;
    HANDLE      Handle;
    ULONG       ReparseTag;

    //
    // For proper cleanup in the event of failure
    //
    Handle = INVALID_HANDLE_VALUE;

    //
    // Open the file for read access
    WStatus = FrsOpenSourceFileById(&Handle,
                                    NULL,
                                    NULL,
                                    VolumeHandle,
                                    Id,
                                    IdLen,
//                                    READ_ACCESS,
                                    READ_ATTRIB_ACCESS,
                                    ID_OPTIONS,
                                    SHARE_ALL,
                                    FILE_OPEN);
    //
    // File has been deleted; done
    //
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(4, "++ %ws (Id %08x %08x) could not open for reparse;",
                   Name, PRINTQUAD(*((PULONGLONG)Id)), WStatus);
        return WStatus;
    }
    //
    // What type of reparse is it?
    //
    WStatus = FrsGetReparseTag(Handle, &ReparseTag);
    FRS_CLOSE(Handle);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(4, "++ %ws (Id %08x %08x) could not get reparse tag;",
                   Name, PRINTQUAD(*((PULONGLONG)Id)), WStatus);
        return WStatus;
    }

    //
    // We only accept operations on files with certain reparse points.
    // For example a rename of a SIS file into a replica tree needs to prop
    // a create CO.
    //
    if (!ReparseTagReplicate(ReparseTag)) {
        DPRINT3(4, "++ %ws (Id %08x %08x) is reparse tag %08x is unsupported.\n",
                Name, PRINTQUAD(*((PULONGLONG)Id)), ReparseTag);

        return ERROR_OPERATION_ABORTED;
    }

    return ERROR_SUCCESS;
}



DWORD
FrsDeleteReparsePoint(
    IN  HANDLE  Handle
    )
/*++

Routine Description:

    Delete the reparse point on the opened file.

Arguments:

    Handle - Handle for a reparse point

Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteReparsePoint:"

    ULONG       WStatus = ERROR_SUCCESS;
    DWORD       ReparseDataLength;
    ULONG       ReparseTag;
    PCHAR       ReparseData;
    PREPARSE_DATA_BUFFER    ReparseBufferHeader;
    ULONG       ActualSize;

    //
    //  Allocate a buffer and get the information.
    //
    ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
    ReparseData = FrsAlloc(ReparseDataLength);

    //
    //  Need the reparse tag in order to do the delete.
    //
    if (!DeviceIoControl(Handle,
                         FSCTL_GET_REPARSE_POINT,
                         (LPVOID) NULL,
                         (DWORD)  0,
                         (LPVOID) ReparseData,
                         ReparseDataLength,
                         &ActualSize,
                         (LPOVERLAPPED) NULL )) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ FrsDeleteReparsePoint - FSCTL_GET_REPARSE_POINT failed,",
                   WStatus, RETURN);
    }

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseData;
    ReparseTag = ReparseBufferHeader->ReparseTag;

    DPRINT1(3, "++ FrsDeleteReparsePoint - Tag: 08x\n", ReparseTag);

    //
    // Delete the reparse point.
    //
    ZeroMemory(ReparseBufferHeader, sizeof(REPARSE_DATA_BUFFER_HEADER_SIZE));
    ReparseBufferHeader->ReparseTag = ReparseTag;
    ReparseBufferHeader->ReparseDataLength = 0;

    if (!DeviceIoControl(Handle,
                         FSCTL_DELETE_REPARSE_POINT,
                         (LPVOID) ReparseData,
                         REPARSE_DATA_BUFFER_HEADER_SIZE,
                         (LPVOID) NULL,
                         (DWORD)  0,
                         &ActualSize,
                         (LPOVERLAPPED) NULL )) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ FrsDeleteReparsePoint - FSCTL_DELETE_REPARSE_POINT failed,",
                   WStatus, RETURN);
    }


RETURN:

    FrsFree(ReparseData);

    return WStatus;
}


DWORD
FrsChaseSymbolicLink(
    IN  PWCHAR  SymLink,
    OUT PWCHAR  *OutPrintName,
    OUT PWCHAR  *OutSubstituteName
    )
/*++

Routine Description:

    This function opens the specified file with backup intent for
    reading all the files attributes, ...

Arguments:

    Handle - A pointer to a handle to return an open handle.

    lpFileName - Represents the name of the file or directory to be opened.

    DesiredAccess

    CreateOptions

Return Value:

    Winstatus.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsChaseSymbolicLink:"
    NTSTATUS    NtStatus;
    DWORD       WStatus;
    HANDLE      Handle = INVALID_HANDLE_VALUE;
    DWORD       ReparseDataLength;
    PCHAR       ReparseBuffer;
    DWORD       SubLen;
    DWORD       PrintLen;
    PWCHAR      SubName;
    PWCHAR      PrintName;
    IO_STATUS_BLOCK         IoStatusBlock;
    PREPARSE_DATA_BUFFER    ReparseBufferHeader;
    OBJECT_ATTRIBUTES       Obja;
    UNICODE_STRING          FileName;
    ULONG             FileAttributes;
    ULONG             CreateDisposition;
    ULONG             ShareMode;
    ULONG             Colon;

    if ((OutPrintName == NULL) || (OutSubstituteName == NULL)) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Assume no symlink
    //
    *OutPrintName = FrsWcsDup(SymLink);
    *OutSubstituteName = FrsWcsDup(SymLink);

    //
    //  Allocate a buffer and get the information.
    //
    ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
    ReparseBuffer = FrsAlloc(ReparseDataLength);

NEXT_LINK:
    //
    // Open the target symlink. If this is a dos type path name then
    // convert it to NtPathName or else use it as it is.
    //
    Colon = wcscspn(*OutSubstituteName, L":");

    if (Colon == 1 ||
        (wcsncmp(*OutSubstituteName, L"\\\\?\\", wcslen(L"\\\\?\\")) == 0 )) {
        WStatus = FrsOpenSourceFileW(&Handle,
                                     *OutSubstituteName,
                                     GENERIC_READ,
                                     FILE_OPEN_FOR_BACKUP_INTENT |
                                     FILE_OPEN_REPARSE_POINT);
        CLEANUP1_WS(4, "++ Could not open %ws; ", *OutSubstituteName, WStatus, CLEANUP);

    } else {
        //
        // The path already in Nt style. Use it as it is.
        //
        FileName.Buffer = *OutSubstituteName;
        FileName.Length = (USHORT)(wcslen(*OutSubstituteName) * sizeof(WCHAR));
        FileName.MaximumLength = (USHORT)(wcslen(*OutSubstituteName) * sizeof(WCHAR));

        InitializeObjectAttributes(&Obja,
                                   &FileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        CreateDisposition = FILE_OPEN;               // Open existing file

        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

        FileAttributes = FILE_ATTRIBUTE_NORMAL;

        NtStatus = NtCreateFile(&Handle,
                              GENERIC_READ,
                              &Obja,
                              &IoStatusBlock,
                              NULL,              // Initial allocation size
                              FileAttributes,
                              ShareMode,
                              CreateDisposition,
                              FILE_OPEN_FOR_BACKUP_INTENT |
                              FILE_OPEN_REPARSE_POINT,
                              NULL, 0);

        WStatus = FrsSetLastNTError(NtStatus);
        CLEANUP1_WS(4, "++ Could not open %ws;", *OutSubstituteName, WStatus, CLEANUP);
    }

    //
    //  Query the reparse point.
    //
    //  Now go and get the data.
    //
    NtStatus = NtFsControlFile(Handle,
                               NULL,
                               NULL,
                               NULL,
                               &IoStatusBlock,
                               FSCTL_GET_REPARSE_POINT,
                               NULL,
                               0,
                               (PVOID)ReparseBuffer,
                               ReparseDataLength
                               );

    FRS_CLOSE(Handle);
    if (NtStatus == STATUS_NOT_A_REPARSE_POINT) {
        FrsFree(ReparseBuffer);
        return ERROR_SUCCESS;
    }

    WStatus = FrsSetLastNTError(NtStatus);
    CLEANUP1_WS(4, "++ Could not fsctl %ws;", *OutSubstituteName, WStatus, CLEANUP);

    //
    //  Display the buffer.
    //

    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    if ((ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) ||
        (ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_SYMBOLIC_LINK)) {

        SubName   = &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[0];
        SubLen    = ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength;
        PrintName = &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[(SubLen + sizeof(UNICODE_NULL))/sizeof(WCHAR)];
        PrintLen  = ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength;
        SubName[SubLen / sizeof(WCHAR)] = L'\0';
        PrintName[PrintLen / sizeof(WCHAR)] = L'\0';

        DPRINT2(4, "++ %ws -> (print) %ws\n", *OutPrintName, PrintName);
        DPRINT2(4, "++ %ws -> (substitute) %ws\n", *OutSubstituteName, SubName);

        FrsFree(*OutPrintName);
        FrsFree(*OutSubstituteName);

        //
        // We need to return both print name and substitute name.
        //
        *OutPrintName = FrsWcsDup(PrintName);
        *OutSubstituteName = FrsWcsDup(SubName);
        goto NEXT_LINK;
    }

    return ERROR_SUCCESS;

CLEANUP:
    FRS_CLOSE(Handle);
    FrsFree(ReparseBuffer);
    *OutPrintName = FrsFree(*OutPrintName);
    *OutSubstituteName = FrsFree(*OutSubstituteName);
    return WStatus;
}


DWORD
FrsTraverseReparsePoints(
    IN  PWCHAR  SuppliedPath,
    OUT PWCHAR  *RealPath
    )
/*++

Routine Description:

    This function steps through each element of the path
    and maps all reparse points to actual paths. In the end the
    path returned has no reparse points of the form
    IO_REPARSE_TAG_MOUNT_POINT and IO_REPARSE_TAG_SYMBOLIC_LINK.

Arguments:

    Supplied - Input path. May or may not have any reparse points.

    RealPath - Path without any reparse points or NULL if there is an error
               reading reparse data.

Return Value:

    Winstatus.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsTraverseReparsePoints:"
    PWCHAR  TempStr           = NULL;
    PWCHAR  IndexPtr          = NULL;
    PWCHAR  BackSlashPtr      = NULL;
    PWCHAR  TempPath          = NULL;
    PWCHAR  PrintablePath     = NULL;
    DWORD   Colon             = 0;
    DWORD   CloseBrace        = 0;
    DWORD   LoopBreaker       = 0;
    DWORD   WStatus           = ERROR_SUCCESS;
    ULONG   FileAttributes    = 0;
    BOOL    ReparsePointFound = FALSE;

    if (!SuppliedPath) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }
    TempStr = FrsAlloc((wcslen(SuppliedPath) + 1) * sizeof(WCHAR));
    wcscpy(TempStr,SuppliedPath);


    //
    // Repeat the procedure until you have a clean path without any
    // reparse points.
    // e.g.
    // f:\c -> d:\destination
    // e:\a\b -> f:\c\d (which is actually d:\destination\d)
    // Given path is e:\a\b\c
    // FIrst time through the loop we will have f:\c\d\c
    // Second time we will translate the reparse point at f:\c
    // and get the correct answer d:\destination\d\c
    //
    do {
        *RealPath = NULL;
        ReparsePointFound = FALSE;
        //
        // Find the colon. Every path has to either have a colon followed by a '\'
        // or it should be of the form. "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
        //
        Colon = wcscspn(TempStr, L":");

        if (Colon == wcslen(TempStr)) {
            //
            // Path does not have a colon. It can be of the form
            // "\??\Volume{60430005-ab47-11d3-8973-806d6172696f}\"
            //
            CloseBrace = wcscspn(TempStr, L"}");
            if (TempStr[CloseBrace] != L'}' ||
                TempStr[CloseBrace + 1] != L'\\') {
                WStatus = ERROR_INVALID_PARAMETER;
                goto CLEANUP;
            }
            //
            // Copy the path up to 1 past the closing brace as it is. It could be \??\Volume...
            // or \\.\Volume... or \\?\Volume.. or some other complex form.
            // Start looking for reparse points past the closing brace.
            //

            *RealPath = FrsAlloc((CloseBrace + 3)* sizeof(WCHAR));
            wcsncpy(*RealPath,TempStr,CloseBrace + 2);
            (*RealPath)[CloseBrace + 2] = L'\0';
            IndexPtr = &TempStr[CloseBrace + 1];

        } else {
            if (TempStr[Colon] != L':' ||
                TempStr[Colon + 1] != L'\\') {
                WStatus = ERROR_INVALID_PARAMETER;
                goto CLEANUP;
            }
            //
            // Copy the path up to 1 past the colon as it is. It could be d:\
            // or \\.\d:\ or \??\d:\ or some other complex form.
            // Start looking for reparse points past the colon.
            //

            *RealPath = FrsAlloc((Colon + 3)* sizeof(WCHAR));
            wcsncpy(*RealPath,TempStr,Colon + 2);
            (*RealPath)[Colon + 2] = L'\0';
            IndexPtr = &TempStr[Colon + 1];

        }

        BackSlashPtr = wcstok(IndexPtr,L"\\");
        if (BackSlashPtr == NULL) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto CLEANUP;
        }

        do {
            if ((*RealPath)[wcslen(*RealPath) - 1] == L'\\') {
                TempPath = FrsAlloc((wcslen(*RealPath) + wcslen(BackSlashPtr) + 1)* sizeof(WCHAR));
                wcscpy(TempPath,*RealPath);
            } else {
                TempPath = FrsAlloc((wcslen(*RealPath) + wcslen(BackSlashPtr) + wcslen(L"\\") + 1)* sizeof(WCHAR));
                wcscpy(TempPath,*RealPath);
                wcscat(TempPath,L"\\");
            }
            wcscat(TempPath,BackSlashPtr);
            FrsFree(*RealPath);
            *RealPath = TempPath;
            TempPath = NULL;

            //
            //
            //
            //
            // FrsChaseSymbolicLink returns both then PrintName and the SubstituteName.
            // We use the SubstituteName as it is always guaranteed to be there.
            // PrintName is ignored.
            //
            WStatus = FrsChaseSymbolicLink(*RealPath, &PrintablePath, &TempPath);
            PrintablePath = FrsFree(PrintablePath);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1(0,"ERROR reading reparse point data WStatus = %d\n",WStatus);
                FrsFree(TempPath);
                goto CLEANUP;

            //
            // We are only looking for reparse points that are
            // either IO_REPARSE_TAG_MOUNT_POINT or IO_REPARSE_TAG_SYMBOLIC_LINK.
            // Check if the path returned by FrsChaseSymbolicLink is same as the
            // path passed to it. If it is then we haven't hit a reparse point.
            //
            } else if (wcscmp(*RealPath,TempPath)) {
                ReparsePointFound = TRUE;
                FrsFree(*RealPath);
                *RealPath = TempPath;
                TempPath = NULL;
            } else {
                TempPath = FrsFree(TempPath);
            }
        } while ( (BackSlashPtr = wcstok(NULL,L"\\")) != NULL);

        if (SuppliedPath[wcslen(SuppliedPath) - 1] == L'\\') {
            TempPath = FrsAlloc((wcslen(*RealPath) + wcslen(L"\\") + 1)* sizeof(WCHAR));
            wcscpy(TempPath,*RealPath);
            wcscat(TempPath,L"\\");
            FrsFree(*RealPath);
            *RealPath = TempPath;
            TempPath = NULL;
        }
        FrsFree(TempStr);
        TempStr = *RealPath;
        //
        // Break out of the loop if there is a junction point loop.
        // If we have traversed the path 100 times and still can't
        // get to the destination then we probably have a loop
        // in the path.
        //
        ++LoopBreaker;
    } while ( ReparsePointFound && LoopBreaker < 100);

    //
    // Path has loops in it. Return error.
    //
    if (LoopBreaker >= 100) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }
CLEANUP:
    DPRINT2(5,"Supplied Path = %ws, Traversed Path = %ws\n",SuppliedPath,(*RealPath)?*RealPath:L"<null>");

    //
    // If we are returning error then return NULL as the real path.
    //
    if (!WIN_SUCCESS(WStatus)) {
        FrsFree(TempStr);
        *RealPath = FrsFree(*RealPath);
    }
    return WStatus;
}


BOOL
FrsSearchArgv(
    IN LONG     ArgC,
    IN PWCHAR  *ArgV,
    IN PWCHAR   ArgKey,
    OUT PWCHAR *ArgValue
    )

/*++

Routine Description:

    This routine searches an ArgV vector for the keyword in ArgKey.
    If found it looks for an equals sign and returns a copy of the right
    hand side in ArgValue.  The caller must free the returned string.

Arguments:

    ArgC - The number of entries in the ArgV vector.

    ArgV - The vector of PWCHARS to search.

    ArgKey - The key to search for.  MUST BE LOWERCASE TO MATCH.

    ArgValue - return location for the buffer ptr.  Caller must free.
               if NULL no right hand side is returned.

Return Value:

    TRUE if ArgKey is found.

--*/

{

#undef DEBSUB
#define DEBSUB "FrsSearchArgv:"
    LONG    i, n, Len;
    PWCHAR  TestStr;
    PWCHAR  Wcs;

    if (ArgValue != NULL) {
        *ArgValue = NULL;
    }

    //
    // Are we running as a service? We need to know prior
    // to calling the first DPRINT.
    //
    for (n = 0; n < ArgC; ++n) {
        TestStr = ArgV[n];
        Len = wcslen(TestStr);

        if (Len <= 0) {
            continue;
        }

        //
        // Skip -,/
        //
        if (TestStr[0] == L'-' || TestStr[0] == L'/') {
            TestStr++;
            Len--;
        }

        //
        //  Skip over leading spaces and tabs.
        //
        while ((TestStr[0] == UNICODE_SPACE) || (TestStr[0] == UNICODE_TAB) ) {
            TestStr++;
            Len--;
        }


        if (Len <= 0) {
            continue;
        }


        _wcslwr(TestStr);

        if (wcsstr(TestStr, ArgKey) != TestStr) {
            continue;
        }

        //
        // Found a match.  Look for a value.
        //
        if (ArgValue != NULL) {

            DPRINT2(5, "match on ArgV[%d] = %ws\n", n, TestStr);
            Wcs = wcschr(TestStr, L'=');
            if (Wcs) {

                //
                //  Trim trailing leading spaces and tabs.
                //
                while ((TestStr[Len-1] == UNICODE_SPACE) ||
                       (TestStr[Len-1] == UNICODE_TAB  )) {
                    Len--;
                }

                FRS_ASSERT(&TestStr[Len-1] >= Wcs);

                TestStr[Len] = UNICODE_NULL;

                *ArgValue = FrsWcsDup(Wcs+1);
                DPRINT1(5, "++ return value = %ws\n", *ArgValue);
            }
        }

        return TRUE;

    }

    DPRINT1(5, "++ No match for ArgKey = %ws\n", ArgKey);
    return FALSE;

}


BOOL
FrsSearchArgvDWord(
    IN LONG     ArgC,
    IN PWCHAR  *ArgV,
    IN PWCHAR   ArgKey,
    OUT PDWORD  ArgValue
    )

/*++

Routine Description:

    This routine searches an ArgV vector for the keyword in ArgKey.
    If found it looks for an equals sign and returns the right
    hand side in ArgValue as a base 10 number.

Arguments:

    ArgC - The number of entries in the ArgV vector.

    ArgV - The vector of PWCHARS to search.

    ArgKey - The key to search for.  MUST BE LOWERCASE TO MATCH.

    ArgValue - return location for the DWORD right hand side.
               if ArgKey not found no right hand side is returned.

Return Value:

    TRUE if ArgKey is found.

--*/

{

#undef DEBSUB
#define DEBSUB "FrsSearchArgvDWord:"
    ULONG    Len;
    PWCHAR  WStr;


    if (FrsSearchArgv(ArgC, ArgV, ArgKey, &WStr)) {
        //
        // Found ArgKey
        //
        if (WStr != NULL) {
            //
            // Found rhs.
            //
            Len = wcslen(WStr);
            if ((Len > 0) && (wcsspn(WStr, L"0123456789") == Len)){
                *ArgValue = wcstoul(WStr, NULL, 10);
                FrsFree(WStr);
                return TRUE;
            } else {
                DPRINT2(0, "++ ERROR - Invalid decimal string '%ws' for %ws\n",
                        WStr, ArgKey);
                FrsFree(WStr);
            }
        }
    }

    return FALSE;
}


BOOL
FrsDissectCommaList (
    IN UNICODE_STRING RawArg,
    OUT PUNICODE_STRING FirstArg,
    OUT PUNICODE_STRING RemainingArg
    )
/*++

Routine Description:

    This routine parses a comma (or semicolon) separated string.
    It picks off the first element in the given RawArg and provides both it and
    the remaining part.  Leading blanks and tabs are ignored.  FirstArg is
    returned zero length when there is either a leading comma or embedded
    double comma.  However the buffer address in FirstArg still points to where
    the arg started so the caller can tell how much of the string has been
    processed.  The function returns FALSE when the input string is empty.  It
    returns TRUE when the FirstArg is valid, even if it is null.

    Here are some examples:

        RawArg         FirstArg     RemainingArg       Result
        ----           ---------    -------------      ------
        empty          empty        empty              FALSE

        ,              empty        empty              TRUE

        ,,             empty        ,                  TRUE

        A              A            empty              TRUE

        A,             A            empty              TRUE

        ,A             empty        A                  TRUE

        "A  ,B,C,D"    A            "  B,C,D"          TRUE

        *A?            *A?          empty              TRUE


    Note that both output strings use the same string buffer memory of the
    input string, and are not necessarily null terminated.

    Based on FsRtlDissectName.

Arguments:

    RawArg - The full string to parse.

    FirstArg - The first name in the RawArg.
               Don't allocate a buffer for this string.

    RemainingArg - The rest of the RawArg after the first comma (if any).
                   Don't allocate a buffer for this string.

Return Value:

    FALSE if the RawArg is empty else TRUE (meaning FirstArg is valid).

--*/

{

#undef DEBSUB
#define DEBSUB "FrsDissectCommaList:"

    ULONG i = 0;
    ULONG RawArgLength;
    ULONG FirstArgStart;


    //
    //  Make both output strings empty for now
    //
    FirstArg->Length = 0;
    FirstArg->MaximumLength = 0;
    FirstArg->Buffer = NULL;

    RemainingArg->Length = 0;
    RemainingArg->MaximumLength = 0;
    RemainingArg->Buffer = NULL;

    RawArgLength = RawArg.Length / sizeof(WCHAR);

    //DPRINT2(5, "RawArg string: %ws {%d)\n",
    //        (RawArg.Buffer != NULL) ? RawArg.Buffer : L"<NULL>", RawArg.Length);
    //
    //  Skip over leading spaces and tabs.
    //
    while (i < RawArgLength) {
        if (( RawArg.Buffer[i] != UNICODE_SPACE ) &&
            ( RawArg.Buffer[i] != UNICODE_TAB )){
            break;
        }
        i += 1;
    }

    //
    //  Check for an empty input string
    //
    if (i == RawArgLength) {
        return FALSE;
    }

    //
    //  Now run down the input string until we hit a comma or a semicolon or
    //  the end of the string, remembering where we started.
    //
    FirstArgStart = i;
    while (i < RawArgLength) {
        if ((RawArg.Buffer[i] == L',') || (RawArg.Buffer[i] == L';')) {
            break;
        }
        i += 1;
    }

    //
    // At this point all characters up to (but not including) i are
    // in the first part.   So setup the first arg.  A leading comma returns
    // a zero length string.
    //
    FirstArg->Length = (USHORT)((i - FirstArgStart) * sizeof(WCHAR));
    FirstArg->MaximumLength = FirstArg->Length;
    FirstArg->Buffer = &RawArg.Buffer[FirstArgStart];

    //
    // If no more string is left then return zero length.  Else eat the comma and
    // return the remaining part (could be null if string ends with comma).
    //
    if (i < RawArgLength) {
        RemainingArg->Length = (USHORT)((RawArgLength - (i+1)) * sizeof(WCHAR));
        RemainingArg->MaximumLength = RemainingArg->Length;
        RemainingArg->Buffer = &RawArg.Buffer[i+1];
    }

    //DPRINT2(5, "FirstArg string: %ws {%d)\n",
    //        (FirstArg->Buffer != NULL) ? FirstArg->Buffer : L"<NULL>", FirstArg->Length);

    //DPRINT2(5, "RemainingArg string: %ws {%d)\n",
    //        (RemainingArg->Buffer != NULL) ? RemainingArg->Buffer : L"<NULL>", RemainingArg->Length);


    return TRUE;
}


BOOL
FrsCheckNameFilter(
    IN  PUNICODE_STRING Name,
    IN  PLIST_ENTRY FilterListHead
    )
/*++

Routine Description:

    Check the file name against each entry in the specified filter list.

Arguments:

    Name - The file name to check (no slashes, spaces, etc.)

    FilterListHead - The head of the filter list.

Return Value:

    TRUE if Name is found in the FilterList.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsCheckNameFilter:"
    NTSTATUS Status;
    ULONG Length;
    BOOL  Found = FALSE;
    UNICODE_STRING UpcaseName;
    WCHAR  LocalBuffer[64];


    if (IsListEmpty(FilterListHead)) {
        return FALSE;
    }

    //
    // Upper case the name string.
    //
    Length = Name->Length;
    UpcaseName.Length = (USHORT) Length;
    UpcaseName.MaximumLength = (USHORT) Length;
    UpcaseName.Buffer = (Length > sizeof(LocalBuffer)) ? FrsAlloc(Length) : LocalBuffer;

    Status = RtlUpcaseUnicodeString(&UpcaseName, Name, FALSE);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "++ RtlUpcaseUnicodeString failed;", Status);
        FRS_ASSERT(!"RtlUpcaseUnicodeString failed");
        goto RETURN;
    }

    //
    // Walk the filter list, checking the name against each entry.
    //
    ForEachSimpleListEntry( FilterListHead, WILDCARD_FILTER_ENTRY, ListEntry,
        //
        // iterator pE is of type *WILDCARD_FILTER_ENTRY.
        //
        if (BooleanFlagOn(pE->Flags, WILDCARD_FILTER_ENTRY_IS_WILD)) {
            Found = FrsIsNameInExpression(&pE->UFileName, &UpcaseName, FALSE, NULL);
        } else {
            Found = RtlEqualUnicodeString(&pE->UFileName, &UpcaseName, FALSE);
        }

        if (Found) {
            break;
        }
    );

RETURN:

    //
    // Free the upcase buffer if we could not use the local one.
    //
    if (UpcaseName.Buffer != LocalBuffer) {
        FrsFree(UpcaseName.Buffer);
    }

    UpcaseName.Buffer = NULL;

    return Found;

}


VOID
FrsEmptyNameFilter(
    IN PLIST_ENTRY FilterListHead
)
/*++

Routine Description:

    Empty the filter list.

Arguments:

    FilterListHead - The list head to empty.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsEmptyNameFilter:"

    ForEachSimpleListEntry( FilterListHead, WILDCARD_FILTER_ENTRY, ListEntry,
        //
        // iterator pE is of type *WILDCARD_FILTER_ENTRY.
        //
        RemoveEntryList(&pE->ListEntry);
        FrsFreeType(pE);
    );

}


VOID
FrsLoadNameFilter(
    IN PUNICODE_STRING FilterString,
    IN PLIST_ENTRY FilterListHead
)
/*++

Routine Description:

    Parse the input filter string and create a new filter list.
    If the filter list passed in is not empty then it is emptied first.

Arguments:

    FilterString - The comma separated filter list.

    FilterListHead - The list head on which to create the filter entries.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsLoadNameFilter:"

    NTSTATUS Status;
    ULONG Length;
    PWILDCARD_FILTER_ENTRY  FilterEntry;
    UNICODE_STRING UpcaseFilter, FirstArg;
    WCHAR  LocalBuffer[128];

    //
    // Empty the filter list if neessary.
    //
    FrsEmptyNameFilter(FilterListHead);

    //
    // Uppercase the new filter string.
    //
    DPRINT2(5, "++ filter string: %ws (%d)\n",
            (FilterString->Buffer != NULL) ? FilterString->Buffer : L"<NULL>",
            FilterString->Length);

    Length = FilterString->Length;
    UpcaseFilter.Length = (USHORT) Length;
    UpcaseFilter.MaximumLength = (USHORT) Length;
    UpcaseFilter.Buffer = (Length > sizeof(LocalBuffer)) ? FrsAlloc(Length) : LocalBuffer;

    Status = RtlUpcaseUnicodeString(&UpcaseFilter, FilterString, FALSE);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "++ RtlUpcaseUnicodeString failed;", Status);
        FRS_ASSERT(!"RtlUpcaseUnicodeString failed");
        goto RETURN;
    }

    //
    // Parse the comma list (skipping null entries) and create filter
    // entries for each one.
    //
    while (FrsDissectCommaList (UpcaseFilter, &FirstArg, &UpcaseFilter)) {

        Length = (ULONG) FirstArg.Length;

        if (Length == 0) {
            continue;
        }

//        DPRINT2(5, "++ FirstArg string: %ws {%d)\n",
//                (FirstArg.Buffer != NULL) ? FirstArg.Buffer : L"<NULL>",
//                FirstArg.Length);
        //
        // Allocate and init a wildcard filter entry.
        //
        FilterEntry = FrsAllocTypeSize(WILDCARD_FILTER_ENTRY_TYPE, Length);

        FilterEntry->UFileName.Length = FirstArg.Length;
        FilterEntry->UFileName.MaximumLength = FirstArg.MaximumLength;
        CopyMemory(FilterEntry->UFileName.Buffer, FirstArg.Buffer, Length);

        FilterEntry->UFileName.Buffer[Length/2] = UNICODE_NULL;

        //
        // Check for any wild card characters in the name.
        //
        if (FrsDoesNameContainWildCards(&FilterEntry->UFileName)) {
            SetFlag(FilterEntry->Flags, WILDCARD_FILTER_ENTRY_IS_WILD);
            //DPRINT1(5, "++ Wildcards found in %ws\n", FilterEntry->UFileName.Buffer);
        }

        //
        // Add the entry to the end of the filter list.
        //
        InsertTailList(FilterListHead, &FilterEntry->ListEntry);
    }

RETURN:

    //
    // Free the upcase buffer if we could not use the local one.
    //
    if (UpcaseFilter.Buffer != LocalBuffer) {
        FrsFree(UpcaseFilter.Buffer);
    }

    UpcaseFilter.Buffer = NULL;

    return;

}



ULONG
FrsParseIntegerCommaList(
    IN PWCHAR ArgString,
    IN ULONG MaxResults,
    OUT PLONG Results,
    OUT PULONG NumberResults,
    OUT PULONG Offset
)
/*++

Routine Description:

    Parse a list of integers separated by commas.
    The integers are returned in successive locations of the Results array.
    Null entries (e.g. ",,") return zero for the value.

Arguments:

    ArgString - The comma separated NULL terminated string with integer values.

    MaxResults - The maximum number of results that can be returned.

    Results - An array of the integer results.

    NumberResults - The number of results returned.

    Offset - The offset to the next byte to process in ArgString if there
             were not enough entries to return all the results.

Return Value:

    FrsErrorStatus.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsParseIntegerCommaList:"

    NTSTATUS Status;
    ULONG Length, i = 0;
    ULONG FStatus = FrsErrorSuccess;
    BOOL More;
    PWILDCARD_FILTER_ENTRY  FilterEntry;
    UNICODE_STRING TempUStr, FirstArg;


    RtlInitUnicodeString(&TempUStr, ArgString);
    //
    // Parse the comma list and convert each entry to a LONG.
    //
    while (More = FrsDissectCommaList (TempUStr, &FirstArg, &TempUStr) &&
           (i < MaxResults)) {

        Length = (ULONG) FirstArg.Length;
        Results[i] = 0;

        if (Length == 0) {
            i += 1;
            continue;
        }

        Status = RtlUnicodeStringToInteger (&FirstArg, 10, &Results[i]);
        if (!NT_SUCCESS(Status)) {
            DPRINT2_NT(1, "++ RtlUnicodeStringToInteger failed on arg %d of %ws :",
                    i, ArgString, Status);
            FStatus = FrsErrorBadParam;
        }

        i += 1;
    }

    *NumberResults = i;

    if (More) {
        //
        // There are more arguments to parse but we are out of the loop so
        // return MoreWork status along with the offset into ArgString where
        // we left off.
        //
        if (FStatus == FrsErrorSuccess) {
            FStatus = FrsErrorMoreWork;
        }

        *Offset = (ULONG)(FirstArg.Buffer - ArgString);
    }

    return FStatus;
}


DWORD
FrsSetFileAttributes(
    PWCHAR  Name,
    HANDLE  Handle,
    ULONG   FileAttributes
    )
/*++
Routine Description:
    This routine sets the file's attributes

Arguments:
    Name        - for error messages
    Handle      - Supplies a handle to the file that is to be marked for delete.
    Attributes  - Attributes for the file
Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetFileAttributes:"
    IO_STATUS_BLOCK         IoStatus;
    FILE_BASIC_INFORMATION  BasicInformation;
    NTSTATUS                Status;
    DWORD                   WStatus = ERROR_SUCCESS;

    //
    // Set the attributes
    //
    ZeroMemory(&BasicInformation, sizeof(BasicInformation));
    BasicInformation.FileAttributes = FileAttributes | FILE_ATTRIBUTE_NORMAL;
    Status = NtSetInformationFile(Handle,
                                  &IoStatus,
                                  &BasicInformation,
                                  sizeof(BasicInformation),
                                  FileBasicInformation);
    if (!NT_SUCCESS(Status)) {
        WStatus = FrsSetLastNTError(Status);

        DPRINT1_NT(0, " ERROR - NtSetInformationFile(BasicInformation) failed on %ws :",
                    Name, Status);
    }
    return WStatus;
}


DWORD
FrsResetAttributesForReplication(
    PWCHAR  Name,
    HANDLE  Handle
    )
/*++
Routine Description:
    This routine turns off the attributes that prevent deletion and write

Arguments:
    Name    - for error messages
    Handle  - Supplies a handle to the file that is to be marked for delete.

Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsResetAttributesForReplication:"

    FILE_NETWORK_OPEN_INFORMATION FileInfo;
    DWORD   WStatus = ERROR_SUCCESS;

    //
    // Get the file's attributes
    //
    if (!FrsGetFileInfoByHandle(Name, Handle, &FileInfo)) {
        DPRINT1(4, "++ Can't get attributes for %ws\n", Name);
        WIN_SET_FAIL(WStatus);
        return WStatus;
    }

    //
    // Turn off the access attributes that prevent deletion and write
    //
    if (FileInfo.FileAttributes & NOREPL_ATTRIBUTES) {
        DPRINT1(4, "++ Reseting attributes for %ws\n", Name);
        WStatus = FrsSetFileAttributes(Name, Handle,
                                       FileInfo.FileAttributes &
                                       ~NOREPL_ATTRIBUTES);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1(4, "++ Can't reset attributes for %ws\n", Name);
            return WStatus;
        }
        DPRINT1(4, "++ Attributes for %ws now allow replication\n", Name);
    } else {
        DPRINT1(4, "++ Attributes for %ws allow replication\n", Name);
    }

    return WStatus;
}


DWORD
FrsEnumerateDirectoryDeleteWorker(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PVOID                       Ignored
    )
/*++
Routine Description:
    Empty a directory of non-replicating files and dirs if this is
    an ERROR_DIR_NOT_EMPTY and this is a retry change order for a
    directory delete.

Arguments:
    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    Ignored             - Context is ignored

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsEnumerateDirectoryDeleteWorker:"
    DWORD                   WStatus;
    NTSTATUS                NtStatus;
    HANDLE                  Handle = INVALID_HANDLE_VALUE;
    UNICODE_STRING          ObjectName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;

    //
    // Depth first
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        WStatus = FrsEnumerateDirectoryRecurse(DirectoryHandle,
                                               DirectoryName,
                                               DirectoryLevel,
                                               DirectoryRecord,
                                               DirectoryFlags,
                                               FileName,
                                               INVALID_HANDLE_VALUE,
                                               Ignored,
                                               FrsEnumerateDirectoryDeleteWorker);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
    }

    //
    // Relative open
    //
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.Buffer = DirectoryRecord->FileName;
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;
    NtStatus = NtCreateFile(&Handle,
//                            GENERIC_READ | SYNCHRONIZE | DELETE | FILE_WRITE_ATTRIBUTES,
                            DELETE | SYNCHRONIZE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,                  // AllocationSize
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            FILE_OPEN,
                                FILE_OPEN_FOR_BACKUP_INTENT |
                                FILE_OPEN_REPARSE_POINT |
                                FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,                  // EA buffer
                            0                      // EA buffer size
                            );

    //
    // Error opening file or directory
    //
    WStatus = FrsSetLastNTError(NtStatus);
    CLEANUP1_WS(0, "++ ERROR - NtCreateFile(%ws) failed :", FileName, WStatus, CLEANUP);

    //
    // Turn off readonly, system, and hidden
    //
    FrsResetAttributesForReplication(FileName, Handle);

    //
    // Delete the file
    //
    WStatus = FrsDeleteByHandle(FileName, Handle);
    DPRINT2(4, "++ Deleted file %ws\\%ws\n", DirectoryName, FileName);

CLEANUP:
    FRS_CLOSE(Handle);
    return WStatus;
}


DWORD
FrsEnumerateDirectoryRecurse(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  HANDLE                      FileHandle,
    IN  PVOID                       Context,
    IN PENUMERATE_DIRECTORY_ROUTINE Function
    )
/*++

Routine Description:

    Open the directory identified by FileName in the directory
    identified by DirectoryHandle and call FrsEnumerateDirectory().

Arguments:

    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level
    DirectoryRecord     - From FrsEnumerateRecord()
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    FileName            - Open this directory and recurse
    FileHandle          - Use for FileName if not INVALID_HANDLE_VALUE
    Context             - Passes global info from the caller to Function
    Function            - Called for every record

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsEnumerateDirectoryRecurse:"

    DWORD               WStatus;
    NTSTATUS            NtStatus;
    HANDLE              LocalHandle   = INVALID_HANDLE_VALUE;
    UNICODE_STRING      ObjectName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;


    //
    // Relative open
    //
    if (!HANDLE_IS_VALID(FileHandle)) {
        ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
        ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
        ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
        ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
        ObjectName.Buffer = DirectoryRecord->FileName;
        ObjectAttributes.ObjectName = &ObjectName;
        ObjectAttributes.RootDirectory = DirectoryHandle;
        NtStatus = NtCreateFile(&LocalHandle,
//                                READ_ACCESS,
                                READ_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,                  // AllocationSize
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_OPEN,
                                    FILE_OPEN_FOR_BACKUP_INTENT |
                                    FILE_OPEN_REPARSE_POINT |
                                    FILE_SEQUENTIAL_ONLY |
                                    FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL,                  // EA buffer
                                0                      // EA buffer size
                                );

        //
        // Error opening directory
        //
        if (!NT_SUCCESS(NtStatus)) {
            DPRINT1_NT(0, "++ ERROR - NtCreateFile(%ws) :", FileName, NtStatus);
            if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
                //
                // Skip this directory tree
                //
                WStatus = ERROR_SUCCESS;
            } else {
                //
                // Abort the entire enumeration
                //
                WStatus = FrsSetLastNTError(NtStatus);
            }
            goto CLEANUP;
        }
        FileHandle = LocalHandle;
    }
    //
    // RECURSE
    //
    WStatus = FrsEnumerateDirectory(FileHandle,
                                    FileName,
                                    DirectoryLevel + 1,
                                    DirectoryFlags,
                                    Context,
                                    Function);
CLEANUP:
    FRS_CLOSE(LocalHandle);

    return WStatus;
}


DWORD
FrsEnumerateDirectory(
    IN HANDLE   DirectoryHandle,
    IN PWCHAR   DirectoryName,
    IN DWORD    DirectoryLevel,
    IN DWORD    DirectoryFlags,
    IN PVOID    Context,
    IN PENUMERATE_DIRECTORY_ROUTINE Function
    )
/*++

Routine Description:

    Enumerate the directory identified by DirectoryHandle, passing each
    directory record to Function. If the record is for a directory,
    call Function before recursing if ProcessBeforeCallingFunction
    is TRUE.

    Function controls the enumeration of the CURRENT directory
    by setting ContinueEnumeration to TRUE (continue) or
    FALSE (terminate).

    Function controls the enumeration of the entire directory
    tree by returning a WIN32 STATUS that is not ERROR_SUCCESS.

    FrsEnumerateDirectory() will terminate the entire directory
    enumeration by returning a WIN32 STATUS other than ERROR_SUCCESS
    when encountering an error.

    Context passes global info from the caller to Function.

Arguments:

    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    Context             - Passes global info from the caller to Function
    Function            - Called for every record

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsEnumerateDirectory:"

    DWORD                       WStatus;
    NTSTATUS                    NtStatus;
    BOOL                        Recurse;
    PFILE_DIRECTORY_INFORMATION DirectoryRecord;
    PFILE_DIRECTORY_INFORMATION DirectoryBuffer = NULL;
    BOOLEAN                     RestartScan     = TRUE;
    PWCHAR                      FileName        = NULL;
    DWORD                       FileNameLength  = 0;
    DWORD                       NumBuffers      = 0;
    DWORD                       NumRecords      = 0;
    UNICODE_STRING              ObjectName;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    extern LONG                 EnumerateDirectorySizeInBytes;

    DPRINT3(4, "++ Enumerating %ws at level %d using buffer size %d\n",
            DirectoryName, DirectoryLevel, EnumerateDirectorySizeInBytes);

    //
    // The buffer size is configurable with registry value
    // ENUMERATE_DIRECTORY_SIZE
    //
    DirectoryBuffer = FrsAlloc(EnumerateDirectorySizeInBytes);

NEXT_BUFFER:

    if (FrsIsShuttingDown) {
        DPRINT(0, "WARN - IDTable Load aborted; service shutting down\n");
        WStatus = ERROR_PROCESS_ABORTED;
        goto CLEANUP;
    }

    //
    // READ A BUFFER FULL OF DIRECTORY INFORMATION
    //

    NtStatus = NtQueryDirectoryFile(DirectoryHandle,   // Directory Handle
                                    NULL,              // Event
                                    NULL,              // ApcRoutine
                                    NULL,              // ApcContext
                                    &IoStatusBlock,
                                    DirectoryBuffer,
                                    EnumerateDirectorySizeInBytes,
                                    FileDirectoryInformation,
                                    FALSE,             // return single entry
                                    NULL,              // FileName
                                    RestartScan        // restart scan
                                    );
    //
    // Enumeration Complete
    //
    if (NtStatus == STATUS_NO_MORE_FILES) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    //
    // Error enumerating directory; return to caller
    //
    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(0, "++ ERROR - NtQueryDirectoryFile(%ws) : ", DirectoryName, NtStatus);
        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            //
            // Don't abort the entire enumeration; just this directory
            //
            WStatus = ERROR_SUCCESS;
        } else {
            //
            // Abort the entire enumeration
            //
            WStatus = FrsSetLastNTError(NtStatus);
        }
        goto CLEANUP;
    }
    ++NumBuffers;

    //
    // PROCESS DIRECTORY RECORDS
    //
    DirectoryRecord = DirectoryBuffer;
NEXT_RECORD:

    if (FrsIsShuttingDown) {
        DPRINT(0, "WARN - IDTable Load aborted; service shutting down\n");
        WStatus = ERROR_PROCESS_ABORTED;
        goto CLEANUP;
    }

    ++NumRecords;

    //
    // Filter . and ..
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        //
        // Skip .
        //
        if (DirectoryRecord->FileNameLength == 2 &&
            DirectoryRecord->FileName[0] == L'.') {
            goto ADVANCE_TO_NEXT_RECORD;
        }

        //
        // Skip ..
        //
        if (DirectoryRecord->FileNameLength == 4 &&
            DirectoryRecord->FileName[0] == L'.' &&
            DirectoryRecord->FileName[1] == L'.') {
            goto ADVANCE_TO_NEXT_RECORD;
        }
    } else if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_DIRECTORIES_ONLY) {
        goto ADVANCE_TO_NEXT_RECORD;
    }

    //
    // Add a terminating NULL to the FileName (painful)
    //
    if (FileNameLength < DirectoryRecord->FileNameLength + sizeof(WCHAR)) {
        FrsFree(FileName);
        FileNameLength = DirectoryRecord->FileNameLength + sizeof(WCHAR);
        FileName = FrsAlloc(FileNameLength);
    }
    CopyMemory(FileName, DirectoryRecord->FileName, DirectoryRecord->FileNameLength);
    FileName[DirectoryRecord->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Process the record
    //
    WStatus = (*Function)(DirectoryHandle,
                          DirectoryName,
                          DirectoryLevel,
                          DirectoryRecord,
                          DirectoryFlags,
                          FileName,
                          Context);
    if (!WIN_SUCCESS(WStatus)) {
        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            //
            // Don't abort the entire enumeration; just this entry
            //
            WStatus = ERROR_SUCCESS;
        } else {
            //
            // Abort the entire enumeration
            //
            goto CLEANUP;
        }
    }

ADVANCE_TO_NEXT_RECORD:
    //
    // Next record
    //
    if (DirectoryRecord->NextEntryOffset) {
        DirectoryRecord = (PVOID)(((PCHAR)DirectoryRecord) +
                                      DirectoryRecord->NextEntryOffset);
        goto NEXT_RECORD;
    }

    //
    // Done with this buffer; go get another one
    // But don't restart the scan for every loop!
    //
    RestartScan = FALSE;
    goto NEXT_BUFFER;

CLEANUP:
    FrsFree(FileName);
    FrsFree(DirectoryBuffer);

    DPRINT5(4, "++ Enumerating %ws at level %d has finished "
            "(%d buffers, %d records) with WStatus %s\n",
            DirectoryName, DirectoryLevel, NumBuffers, NumRecords, ErrLabelW32(WStatus));

    return WStatus;
}


DWORD
FrsFillDisk(
    IN PWCHAR   DirectoryName,
    IN BOOL     Cleanup
    )
/*++

Routine Description:

    Use all the disk space by creating a file in DirectoryName and
    allocating space down to the last byte.

    Delete the fill file if Cleanup is TRUE;

Arguments:

    DirectoryName       - Full pathname to the directory
    Cleanup             - Delete file if TRUE

Return Value:

    WIN32 STATUS (ERROR_DISK_FULL is mapped to ERROR_SUCCESS)

--*/
{
#undef DEBSUB
#define DEBSUB "FrsFillDisk:"

    DWORD               WStatus;
    NTSTATUS            NtStatus;
    DWORD               Tid;
    ULONGLONG           Eof;
    ULONGLONG           NewEof;
    ULONGLONG           IncEof;
    LARGE_INTEGER       LargeInteger;
    HANDLE              FileHandle      = INVALID_HANDLE_VALUE;
    HANDLE              DirectoryHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING      ObjectName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    WCHAR               TidW[9];

    //
    // Open parent directory
    //
    WStatus = FrsOpenSourceFileW(&DirectoryHandle, DirectoryName, READ_ACCESS, OPEN_OPTIONS);
    CLEANUP1_WS(0, "++ DBG ERROR - Cannot open fill directory %ws;",
                DirectoryName, WStatus, CLEANUP);

    //
    // Relative open
    //
    Tid = GetCurrentThreadId();
    swprintf(TidW, L"%08x", Tid);
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectName.Length = (USHORT)(wcslen(TidW) * sizeof(WCHAR));
    ObjectName.MaximumLength = (USHORT)(wcslen(TidW) * sizeof(WCHAR));
    ObjectName.Buffer = TidW;
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;
    NtStatus = NtCreateFile(
        &FileHandle,
        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE | FILE_WRITE_ATTRIBUTES,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,                  // AllocationSize
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
            FILE_OPEN_FOR_BACKUP_INTENT |
            FILE_OPEN_REPARSE_POINT |
            FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,                  // EA buffer
        0                      // EA buffer size
        );

    //
    // Error opening file or directory
    //
    if (!NT_SUCCESS(NtStatus)) {
        WStatus = FrsSetLastNTError(NtStatus);
        CLEANUP1_NT(0, "++ DBG ERROR - NtCreateFile(%ws) : ", TidW, NtStatus, CLEANUP);
    }
    //
    // Remove fill file
    //
    if (Cleanup) {
        //
        // Turn off readonly, system, and hidden
        //
        FrsResetAttributesForReplication(TidW, FileHandle);

        //
        // Delete the file
        //
        WStatus = FrsDeleteByHandle(TidW, FileHandle);
        DPRINT2(4, "++ DBG - Deleted file %ws\\%ws\n", DirectoryName, TidW);

        LeaveCriticalSection(&DebugInfo.DbsOutOfSpaceLock);
        goto CLEANUP;
    }
    //
    // WARN: Hold the lock until the file is deleted
    //
    EnterCriticalSection(&DebugInfo.DbsOutOfSpaceLock);

    //
    // Create fill file
    //
    NewEof = 0;
    Eof = 0;
    for (IncEof = (LONGLONG)-1; IncEof; IncEof >>= 1) {
        NewEof = Eof;
        do {
            NewEof += IncEof;
            LargeInteger.QuadPart = NewEof;

            WStatus = FrsSetFilePointer(TidW, FileHandle, LargeInteger.HighPart,
                                                          LargeInteger.LowPart);
            if (!WIN_SUCCESS(WStatus)) {
                continue;
            }

            if (!SetEndOfFile(FileHandle)) {
                WStatus = GetLastError();
                continue;
            }

            DPRINT2(4, "++ DBG %ws: Allocated Eof is %08x %08x\n",
                        TidW, PRINTQUAD(NewEof));
            Eof = NewEof;
            WStatus = ERROR_SUCCESS;

        } while (WIN_SUCCESS(WStatus) && !FrsIsShuttingDown);
    }
    DPRINT3(4, "++ DBG - Allocated %d MB in %ws\\%ws\n",
            (DWORD)(Eof / (1024 * 1024)), DirectoryName, TidW);

CLEANUP:

    FRS_CLOSE(DirectoryHandle);
    FRS_CLOSE(FileHandle);

    return WStatus;
}


#define THIRTY_SECONDS      (30 * 1000)
ULONG
FrsRunProcess(
    IN PWCHAR   AppPathAndName,
    IN PWCHAR   CommandLine,
    IN HANDLE   StandardIn,
    IN HANDLE   StandardOut,
    IN HANDLE   StandardError
    )
/*++

Routine Description:

    Run the specified command in a separate process.
    Wait for the process to complete.

Arguments:

    AppPathAndName  - Application to launch. Full path.
    CommandLine     - Unicode, null terminated command line string.
    StandardIn      - Handle to use for standard in.
    StandardOut     - Handle to use for Standard Out.  NULL means use Debug log.
    StandardError   - Handle to use for Standard Error.  NULL means use Debug log.

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsRunProcess:"


#define MAX_CMD_LINE 1024

    ULONG               WStatus;
    LONG                WaitCount=20;
    BOOL                NeedDbgLock = FALSE;
    BOOL                CloseStandardIn = FALSE;
    BOOL                BStatus = TRUE;
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;

    DWORD   Len;
    DWORD   TLen;
    WCHAR   ExpandedApp[MAX_CMD_LINE+1];
    WCHAR   ExpandedCmd[MAX_CMD_LINE+1];
    SECURITY_ATTRIBUTES SecurityAttributes;

    TLen = ARRAY_SZ(ExpandedApp);

    //
    // Setup the process I/O Handles.
    //
    if (!HANDLE_IS_VALID(StandardIn)) {
        //
        // Provide a handle to the NUL device for input.
        //
        // Set this handle to be inheritable as it is being passed
        // to a child process that will inherit the handle.
        //
        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttributes.bInheritHandle = TRUE;
        SecurityAttributes.lpSecurityDescriptor = NULL; // not same as NULL DACL

        StandardIn = CreateFileW(
            L"NUL",                                     //  lpszName
            GENERIC_READ | GENERIC_WRITE,               //  fdwAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE,         //  fdwShareMode
            &SecurityAttributes,                        //  lpsa
            OPEN_ALWAYS,                                //  fdwCreate
            FILE_ATTRIBUTE_NORMAL,                      //  fdwAttrAndFlags
            NULL                                        //  hTemplateFile
            );

        if (!HANDLE_IS_VALID(StandardIn)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "++ CreateFileW(NUL) failed;", WStatus);
            goto RETURN;
        }

        CloseStandardIn = TRUE;
    }

    if (!HANDLE_IS_VALID(StandardOut)) {
        StandardOut = DebugInfo.LogFILE;
        NeedDbgLock = TRUE;
    }

    if (!HANDLE_IS_VALID(StandardError)) {
        StandardError = DebugInfo.LogFILE;
        NeedDbgLock = TRUE;
    }



    memset(&StartupInfo, 0, sizeof(STARTUPINFO));

    StartupInfo.cb = sizeof(STARTUPINFO);

    StartupInfo.dwFlags = STARTF_USESTDHANDLES;
    StartupInfo.hStdInput = StandardIn;
    StartupInfo.hStdOutput = StandardOut;
    StartupInfo.hStdError = StandardError;

    //
    // Look for environment vars in command line and expand them.
    //
    Len = ExpandEnvironmentStrings(AppPathAndName, ExpandedApp, TLen);
    if (Len == 0) {
        WStatus = GetLastError();
        DPRINT1_WS(1, "++ ws command not expanded.", AppPathAndName, WStatus);
        goto RETURN;
    }

    Len = ExpandEnvironmentStrings(CommandLine, ExpandedCmd, TLen);
    if (Len == 0) {
        WStatus = GetLastError();
        DPRINT1_WS(1, "++ ws command not expanded.", CommandLine, WStatus);
        goto RETURN;
    }

    DPRINT2(0,"++ Running: %ws, CommandLine: %ws\n", ExpandedApp, ExpandedCmd);

    //
    // Get debug lock so our output stays in one piece.
    //
    if (NeedDbgLock) {DebLock();}


    try {

        BStatus = CreateProcessW(
                     ExpandedApp,                         // lpApplicationName,
                     ExpandedCmd,                         // lpCommandLine,
                     NULL,                                // lpProcessAttributes,
                     NULL,                                // lpThreadAttributes,
                     TRUE,                                // bInheritHandles,
                     DETACHED_PROCESS | CREATE_NO_WINDOW, // dwCreationFlags,
                     NULL,                                // lpEnvironment,
                     NULL,                                // lpCurrentDirectory,
                     &StartupInfo,                        // lpStartupInfo,
                     &ProcessInfo);                       // lpProcessInformation

        //
        // Close the process and thread handles
        //

        if ( !BStatus ) {
            WStatus = GetLastError();
            DPRINT_NOLOCK3(0, "++ CreateProcessW Failed to run: '%ws', CommandLine: '%ws' WStatus: %s",
                           ExpandedApp, ExpandedCmd, ErrLabelW32(WStatus));
            __leave;
        }


        WStatus = WAIT_FAILED;
        while (--WaitCount > 0) {
            WStatus = WaitForSingleObject( ProcessInfo.hProcess, THIRTY_SECONDS);
            if (WStatus == WAIT_OBJECT_0) {
                break;
            }
            DPRINT_NOLOCK1(0, "++ Waiting for process complete -- Time remaining: %d seconds\n",
                    WaitCount * (THIRTY_SECONDS / 1000));
        }

    } finally {
        //
        // If the above took an exception make sure we drop the lock.
        //
        if (NeedDbgLock) {DebUnLock();}
    }

    if ( !BStatus ) {
        //
        // Create process failed.  We're done.
        //
        return WStatus;
    }

    GetExitCodeProcess( ProcessInfo.hProcess, &WStatus );

    if ( BStatus ) {
        DPRINT2(0, "++ CreateProcess( %ws, %ws) succeeds\n", ExpandedApp, ExpandedCmd);
        DPRINT4(0, "++   ProcessInformation = hProcess %08x  hThread %08x"
                   "  ProcessId %08x  ThreadId %08x\n",
            ProcessInfo.hProcess, ProcessInfo.hThread, ProcessInfo.dwProcessId,
            ProcessInfo.dwThreadId);
    }

    if (WStatus == STILL_ACTIVE) {
        //
        // Didn't finish.  Bag it.
        //
        DPRINT(0, "++ Process failed to complete.  Terminating\n");

        WStatus = ERROR_PROCESS_ABORTED;

        if (!TerminateProcess(ProcessInfo.hProcess, WStatus)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "++ Process termination request failed :", WStatus);
        }
    }  else {
        DPRINT1(0, "++ Process completed with status: %d\n", WStatus);
    }

    FRS_CLOSE( ProcessInfo.hThread  );
    FRS_CLOSE( ProcessInfo.hProcess );

RETURN:

    //
    // close stdin handle.
    //
    if (CloseStandardIn) {
        FRS_CLOSE(StandardIn);
    }

    return WStatus;

}

DWORD
FrsSetDacl(
    PWCHAR  RegName
    )
/*++

Routine Description:

    Add backup operators to the dacl for the specified registry key.

Arguments:

    RegName  - registry key (note HKEY_LOCAL_MACHINE becomes MACHINE)

Return Value:

    WIN32 STATUS


API-UPDATE  ...  API-UPDATE  ...  API-UPDATE  ...  API-UPDATE  ...  API-UPDATE  ...

From:   Anne Hopkins
Sent:   Tuesday, May 23, 2000 2:21 PM
To: Windows NT Development Announcements
Cc: Win32 API Changes Notification
Subject:    RE:  NT4 ACL API users should move to Win2K APIs

Sorry, the spec (and sample excerpt) referenced below is out-of-date

For Win2k security apis, use:
- public/sdk/inc/aclapi.h
- Platform SDK documentation (in MSDN) for reference and dev model

The reason to move to Win2k security APIs is to get the win2k Inheritance model,
with automatic propagation for File System and RGY ACLs.  (DS does its own ACL
propagation).  These APIs are also easier to use than the NT4 apis.


From:    Anne Hopkins
Sent:    Tuesday, May 23, 2000 10:49 AM
To:      Win32 API Changes Notification
Subject: NT4 ACL API users should move to Win2K APIs

If you use old NT 4 or prior ACL APIs, you should plan on updating them
to win2k APIs as described in the New Win32 Access Control API spec:

\\cpntserver\areas\Security\Authorization\Specs\access5.doc

If you can't do this for Whistler, be sure to plan for it in Blackcomb.

NT 4 API EXAMPLE:
GetNamedSecurityInfo([in]object, [out]ACL...)                                   // get the ACL from the file
BuildExplicitAccessWithName([out]ExplicitAccess, [in]TrusteeName, [in]Mask, )  // Build the new Explicit Access
SetEntriesInAcl([in]ExplicitAccess, [in]OldAcl, [out]NewAcl)                    // Add the new entry to the ACL
SetNameSecurityInfo([in]object, [in]NewACL...)                                  // write the ACL back onto the file

NT 5.0 EXAMPLE:
GetNamedSecurityInfoEx([in]object, [in] provider, [out] pAccessList)                // Get the access list from the file
BuildExplicitAccessWithName([out]ExplicitAccess, [in]TrusteeName, [in]Mask, )      // Build the access request
SetEntriesInAccessList([in]ExplicitAccess, [in] OldAccessList, [out]NewAccessList)  // Add it to the list
SetNameSecurityInfoEx([in]object, [in[ NewAccessList)                              // Write the access list back to the file


--*/
{
#undef DEBSUB
#define DEBSUB "FrsSetDacl"
    DWORD                   WStatus;
    PACL                    OldDACL;
    PACL                    NewDACL = NULL;
    PSECURITY_DESCRIPTOR    SD = NULL;
    PSID                    SystemSid = NULL;
    PSID                    AdminsSid = NULL;
    PSID                    EverySid = NULL;
    PSID                    BackupSid = NULL;
    EXPLICIT_ACCESS         ExplicitAccess[4];
    SID_IDENTIFIER_AUTHORITY SidNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // No registry key to process
    //
    if (!RegName) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get existing DACL
    //
    WStatus = GetNamedSecurityInfo(RegName,
                                   SE_REGISTRY_KEY,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   NULL,
                                   &OldDACL,
                                   NULL,
                                   &SD);
    CLEANUP1_WS(0, "++ ERROR - GetNamedSecurityInfo(%ws);", RegName, WStatus, CLEANUP);

    //
    // Allocate the admins sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &AdminsSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(ADMINS);", WStatus, CLEANUP);
    }

    //
    // Allocate the system sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &SystemSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(SYSTEM);", WStatus, CLEANUP);
    }

    //
    // Allocate the backup operators sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_BACKUP_OPS,
                                  0, 0, 0, 0, 0, 0,
                                  &BackupSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(BACKUP OPS);", WStatus, CLEANUP);
    }

    //
    // Allocate the everyone sid
    //
    if (!AllocateAndInitializeSid(&SidWorldAuthority,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &EverySid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(EVERYONE);", WStatus, CLEANUP);
    }

    //
    // Initialize an EXPLICIT_ACCESS structure to allow access
    //
    ZeroMemory(ExplicitAccess, sizeof(ExplicitAccess));
    //
    // Admins
    //
    ExplicitAccess[0].grfAccessPermissions = GENERIC_ALL;
    ExplicitAccess[0].grfAccessMode = SET_ACCESS;
    ExplicitAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[0].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[0].Trustee.ptstrName = AdminsSid;

    //
    // System
    //
    ExplicitAccess[1].grfAccessPermissions = GENERIC_ALL;
    ExplicitAccess[1].grfAccessMode = SET_ACCESS;
    ExplicitAccess[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[1].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[1].Trustee.ptstrName = SystemSid;

    //
    // Backup
    //
    ExplicitAccess[2].grfAccessPermissions = GENERIC_ALL;
    ExplicitAccess[2].grfAccessMode = SET_ACCESS;
    ExplicitAccess[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[2].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[2].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[2].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[2].Trustee.ptstrName = BackupSid;

    //
    // Everyone
    //
    ExplicitAccess[3].grfAccessPermissions = GENERIC_READ;
    ExplicitAccess[3].grfAccessMode = SET_ACCESS;
    ExplicitAccess[3].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[3].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[3].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[3].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[3].Trustee.ptstrName = EverySid;

    //
    // Create an new ACL by merging the EXPLICIT_ACCESS structure
    // with the existing DACL
    //
    WStatus = SetEntriesInAcl(4, ExplicitAccess, OldDACL, &NewDACL);
    CLEANUP1_WS(0, "++ ERROR - SetEntriesInAcl(%ws);", RegName, WStatus, CLEANUP);

    //
    // attach the new ACL as the object's DACL
    //
    WStatus = SetNamedSecurityInfo(RegName,
                                   SE_REGISTRY_KEY,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   NULL,
                                   NewDACL,
                                   NULL);
    CLEANUP1_WS(0, "++ ERROR - SetNamedSecurityInfo(%ws);", RegName, WStatus, CLEANUP);

CLEANUP:
    if (SD) {
        LocalFree((HLOCAL)SD);
    }
    if(NewDACL) {
        LocalFree((HLOCAL)NewDACL);
    }
    if (AdminsSid) {
        FreeSid(AdminsSid);
    }
    if (SystemSid) {
        FreeSid(SystemSid);
    }
    if (BackupSid) {
        FreeSid(BackupSid);
    }
    if (EverySid) {
        FreeSid(EverySid);
    }

    return WStatus;
}


#define FRS_FULL_ACCESS ( STANDARD_RIGHTS_ALL        | \
                          FILE_READ_DATA             | \
                          FILE_WRITE_DATA            | \
                          FILE_APPEND_DATA           | \
                          FILE_READ_EA               | \
                          FILE_WRITE_EA              | \
                          FILE_EXECUTE               | \
                          FILE_READ_ATTRIBUTES       | \
                          FILE_WRITE_ATTRIBUTES      | \
                          FILE_CREATE_PIPE_INSTANCE  | \
                          FILE_LIST_DIRECTORY        | \
                          FILE_ADD_FILE              | \
                          FILE_ADD_SUBDIRECTORY      | \
                          FILE_DELETE_CHILD          | \
                          FILE_TRAVERSE      )

DWORD
FrsRestrictAccessToFileOrDirectory(
    PWCHAR  Name,
    HANDLE  Handle,
    BOOL    InheritFromParent,
    BOOL    PushToChildren
    )
/*++

Routine Description:

    Restrict access to administrators and local system.

Arguments:

    Name    - File or directory name for error messages
    Handle  - opened handle for name.  If handle is NULL then open 'Name'.
    InheritFromParent - FALSE : Protects the DACL from inheriting ACEs.
                        TRUE  : Inherits ACEs from the parent whenever applicable.
    PushToChildren    - FALSE : No ineritance.
                        TRUE  : Both containers and noncontainer objects that are
                                contained by the primary object inherit the ACE.
                                This flag corresponds to the combination of
                                the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE flags.

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsRestrictAccessToFileOrDirectory"

    DWORD                   WStatus = ERROR_SUCCESS;
    HANDLE                  LocalHandle = NULL;

    SECURITY_INFORMATION    SecurityInfo;

    EXPLICIT_ACCESS         ExplicitAccess[2];
    PACL                    NewDACL = NULL;
    SID_IDENTIFIER_AUTHORITY SidNtAuthority = SECURITY_NT_AUTHORITY;
    PSID                    SystemSid = NULL;
    PSID                    AdminsSid = NULL;

    //
    // No file or directory handle?
    //
    if (!HANDLE_IS_VALID(Handle)) {
        //
        // Open the directory
        //
        if (Name == NULL) {
            return ERROR_INVALID_PARAMETER;
        }

        LocalHandle = CreateFile(
            Name,
            GENERIC_WRITE | WRITE_DAC | FILE_READ_ATTRIBUTES | FILE_TRAVERSE,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS,
            NULL);

        if (!HANDLE_IS_VALID(LocalHandle)) {
            return GetLastError();
        }

        Handle = LocalHandle;
    }

    //
    // Allocate the admins sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &AdminsSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(ADMINS);", WStatus, CLEANUP);
    }

    //
    // Allocate the system sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &SystemSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(SYSTEM);", WStatus, CLEANUP);
    }


    ZeroMemory(ExplicitAccess, sizeof(ExplicitAccess));
    ExplicitAccess[0].grfAccessPermissions = FRS_FULL_ACCESS;
    ExplicitAccess[0].grfAccessMode = SET_ACCESS;
    if (PushToChildren == TRUE) {
        ExplicitAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    } else {
        ExplicitAccess[0].grfInheritance = NO_INHERITANCE;
    }
    ExplicitAccess[0].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[0].Trustee.ptstrName = AdminsSid;


    ExplicitAccess[1].grfAccessPermissions = FRS_FULL_ACCESS;
    ExplicitAccess[1].grfAccessMode = SET_ACCESS;
    if (PushToChildren == TRUE) {
        ExplicitAccess[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    } else {
        ExplicitAccess[1].grfInheritance = NO_INHERITANCE;
    }
    ExplicitAccess[1].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[1].Trustee.ptstrName = SystemSid;


    //
    // Create new ACL.
    //
    WStatus = SetEntriesInAcl(2, ExplicitAccess, NULL, &NewDACL);
    CLEANUP1_WS(0, "++ ERROR - SetEntriesInAcl(%ws);", Name, WStatus, CLEANUP);

    //
    // attach the new ACL as the object's DACL
    //   PROTECTED_DACL_SECURITY_INFORMATION - Means don't inherit ACLs from parent
    //
    SecurityInfo = DACL_SECURITY_INFORMATION;
    if (InheritFromParent == TRUE) {
        SecurityInfo |= UNPROTECTED_DACL_SECURITY_INFORMATION;
    } else {
        SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;
    }

    WStatus = SetSecurityInfo(Handle,
                              SE_FILE_OBJECT,
                              SecurityInfo,
                              NULL,
                              NULL,
                              NewDACL,
                              NULL);

    CLEANUP1_WS(0, "++ ERROR - SetSecurityInfo(%ws);", Name, WStatus, CLEANUP);

CLEANUP:

    if(NewDACL) {
        LocalFree((HLOCAL)NewDACL);
    }
    if (SystemSid) {
        FreeSid(SystemSid);
    }
    if (AdminsSid) {
        FreeSid(AdminsSid);
    }
    FRS_CLOSE(LocalHandle);

    return WStatus;
}



ULONG
FrsProcessBackupRestore(
    VOID
    )
/*++

Routine Description:

    Check the registry to see if a restore has transpired.
    If so, delete the database and reset the registry as needed.

Arguments:

    None.

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsProcessBackupRestore:"
    ULONG   WStatus;
    DWORD   KeyIdx;
    HKEY    hKey     = INVALID_HANDLE_VALUE;

    HKEY    HBurKey  = INVALID_HANDLE_VALUE;
    HKEY    HCumuKey = INVALID_HANDLE_VALUE;

    DWORD   GblBurFlags;
    DWORD   BurSetFlags;

    WCHAR   RegBuf[MAX_PATH + 1];

    //
    // Check for backup/restore in progress
    //    FRS_CONFIG_SECTION\backup/restore\Stop NtFrs from Starting
    //
    WStatus = CfgRegOpenKey(FKC_BKUP_STOP_SECTION_KEY, NULL, 0, &hKey);
    if (WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":S: WARN - Backup/Restore in progress; retry later.", WStatus);
        EPRINT1(EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS, ComputerName);
        FRS_REG_CLOSE(hKey);
        return ERROR_BUSY;
    }

    //
    // Open FRS_CONFIG_SECTION\backup/restore
    // Create it if it doesn't exist and put an ACL on it.
    //

    WStatus = CfgRegOpenKey(FKC_BKUP_SECTION_KEY, NULL, 0, &HBurKey);
    if (!WIN_SUCCESS(WStatus)) {

        WStatus = CfgRegOpenKey(FKC_BKUP_SECTION_KEY, NULL, FRS_RKF_CREATE_KEY, &HBurKey);
        CLEANUP_WS(0, "ERROR - Failed to create backup/restore key.", WStatus, CLEANUP_OK);

        //
        // New key; Ensure backup operators have access.
        //
        WStatus = FrsSetDacl(L"MACHINE\\" FRS_BACKUP_RESTORE_SECTION);
        DPRINT_WS(0, "WARN - FrsSetDacl failed on backup/restore key.", WStatus);

        //
        // Ignore errors
        //
        WStatus = ERROR_SUCCESS;
    }



    //
    // Move the Bur cumulative replica sets to the standard location
    //
    //     Open FRS_CONFIG_SECTION\backup/restore\Process at Startup\Cumulative Replica Sets
    //     Enumerate the Replica Sets.
    //
    CfgRegOpenKey(FKC_BKUP_MV_CUMSETS_SECTION_KEY, NULL,  FRS_RKF_CREATE_KEY,  &hKey);

    KeyIdx = 0;
    HCumuKey = 0;

    while (hKey) {

        WStatus = RegEnumKey(hKey, KeyIdx, RegBuf, MAX_PATH + 1);
        if (!WIN_SUCCESS(WStatus)) {
            if (WStatus != ERROR_NO_MORE_ITEMS) {
                DPRINT_WS(0, "WARN - Backup/restore enum.", WStatus);
            }
            break;
        }

        //
        //  Create the corresponding key in the standard location.
        //
        //      FRS_CONFIG_SECTION\Cumulative Replica Sets\<RegBuf>
        //
        CfgRegOpenKey(FKC_CUMSET_N_BURFLAGS, RegBuf,  FRS_RKF_CREATE_KEY,  &HCumuKey);

        FRS_REG_CLOSE(HCumuKey);

        //
        // Delete key from Backup/Restore section.
        //
        //     FRS_CONFIG_SECTION\backup/restore\Process at Startup\Cumulative Replica Sets\<RegBuf>
        //
        WStatus = RegDeleteKey(hKey, RegBuf);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(0, ":S: WARN - RegDeleteKey(%ws\\%ws);",
                    FRS_BACKUP_RESTORE_MV_CUMULATIVE_SETS_SECTION, RegBuf, WStatus);
            ++KeyIdx;
        }
    }

    FRS_REG_CLOSE(hKey);

    //
    // PROCESS Global Backup/Restore BURFLAGS
    //
    //      FRS_CONFIG_SECTION\backup/restore\Process at Startup\BurFlags
    //
    WStatus = CfgRegReadDWord(FKC_BKUP_STARTUP_GLOBAL_BURFLAGS, NULL, 0, &GblBurFlags);
    CLEANUP_WS(0, "ERROR - Failed to read Global BurFlags.", WStatus, CLEANUP_OK);

    //
    // Do we need to delete the database?
    //
    if ((GblBurFlags & NTFRSAPI_BUR_FLAGS_RESTORE) &&
        (GblBurFlags & NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES)) {

        DPRINT(4, ":S: Deleting database after full non-auth restore\n");

        WStatus = FrsDeletePath(JetPath, ENUMERATE_DIRECTORY_FLAGS_NONE);
        CLEANUP1_WS(0, ":S: ERROR - FrsDeletePath(%ws);", JetPath, WStatus, CLEANUP);

        DPRINT(4, ":S: Recreating database after full non-auth restore\n");
        //
        // Create the database directories
        //
        if (!CreateDirectory(JetPath, NULL)) {
            WStatus = GetLastError();
            if (!WIN_ALREADY_EXISTS(WStatus)) {
                CLEANUP1_WS(0, ":S: ERROR - CreateDirecotry(%ws);", JetPath, WStatus, CLEANUP);
            }
        }
        if (!CreateDirectory(JetSys, NULL)) {
            WStatus = GetLastError();
            if (!WIN_ALREADY_EXISTS(WStatus)) {
                CLEANUP1_WS(0, ":S: ERROR - CreateDirecotry(%ws);", JetSys, WStatus, CLEANUP);
            }
        }
        if (!CreateDirectory(JetTemp, NULL)) {
            WStatus = GetLastError();
            if (!WIN_ALREADY_EXISTS(WStatus)) {
                CLEANUP1_WS(0, ":S: ERROR - CreateDirecotry(%ws);", JetTemp, WStatus, CLEANUP);
            }
        }
        if (!CreateDirectory(JetLog, NULL)) {
            WStatus = GetLastError();
            if (!WIN_ALREADY_EXISTS(WStatus)) {
                CLEANUP1_WS(0, ":S: ERROR - CreateDirecotry(%ws);", JetLog, WStatus, CLEANUP);
            }
        }

        //
        // Enumerate the sets under "Cumulative Replica Sets" and mark them as not/primary
        //      FRS_CONFIG_SECTION\Cumulative Replica Sets
        //
        CfgRegOpenKey(FKC_CUMSET_SECTION_KEY, NULL,  FRS_RKF_CREATE_KEY,  &hKey);
        CLEANUP_WS(0, "ERROR - Failed to open Cumulative Replica Sets.", WStatus, CLEANUP);

        //
        // Enumerate the Replica Sets
        //
        KeyIdx = 0;

        while (TRUE) {
            WStatus = RegEnumKey(hKey, KeyIdx, RegBuf, MAX_PATH + 1);
            if (WStatus == ERROR_NO_MORE_ITEMS) {
                break;
            }
            CLEANUP_WS(0, "WARN - Cumulative Replica Sets enum.", WStatus, CLEANUP);

            //
            // Save type of restore in BurFlags for this replica set.
            //     FRS_CONFIG_SECTION\Cumulative Replica Sets\<RegBuf>\BurFlags
            //
            WStatus = CfgRegWriteDWord(FKC_CUMSET_N_BURFLAGS, RegBuf, 0, GblBurFlags);
            DPRINT_WS(0, "WARN - Cumulative Replica Sets BurFlags Write.", WStatus);

            ++KeyIdx;
        }

        FRS_REG_CLOSE(hKey);
    }  // End of Delete Data Base

    //
    // Move individual BurFlags into Cumulative Replica Sets
    //     Open FRS_CONFIG_SECTION\backup/restore\Process at Startup\Replica Sets
    //     Enumerate the Replica Sets
    //
    CfgRegOpenKey(FKC_BKUP_MV_SETS_SECTION_KEY, NULL,  FRS_RKF_CREATE_KEY,  &hKey);

    KeyIdx = 0;

    while (hKey) {
        WStatus = RegEnumKey(hKey, KeyIdx, RegBuf, MAX_PATH + 1);
        if (!WIN_SUCCESS(WStatus)) {
            if (WStatus != ERROR_NO_MORE_ITEMS) {
                DPRINT_WS(0, "WARN - Backup/restore enum.", WStatus);
            }
            break;
        }

        //
        // Get BurFlags
        //   FRS_CONFIG_SECTION\backup/restore\Process at Startup\Replica Sets\<RegBuf>\BurFlags
        //
        WStatus = CfgRegReadDWord(FKC_BKUP_STARTUP_SET_N_BURFLAGS,
                                  RegBuf,
                                  FRS_RKF_CREATE_KEY,
                                  &BurSetFlags);

        if (WIN_SUCCESS(WStatus)) {
            //
            // Write BurFlags
            //  FRS_CONFIG_SECTION\Cumulative Replica Sets\<RegBuf>\BurFlags
            //
            CfgRegWriteDWord(FKC_CUMSET_N_BURFLAGS,
                             RegBuf,
                             FRS_RKF_CREATE_KEY,
                             BurSetFlags);
        }

        //
        // Delete source data key.
        //   FRS_CONFIG_SECTION\backup/restore\Process at Startup\Replica Sets\<RegBuf>
        //
        WStatus = RegDeleteKey(hKey, RegBuf);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(0, ":S: WARN - RegDeleteKey(%ws\\%ws);",
                    FRS_BACKUP_RESTORE_MV_SETS_SECTION, RegBuf, WStatus);
            ++KeyIdx;
        }
    }

    FRS_REG_CLOSE(hKey);

    //
    // Set backup/restore flags to 0
    //
    //      FRS_CONFIG_SECTION\backup/restore\Process at Startup\BurFlags
    //
    GblBurFlags = NTFRSAPI_BUR_FLAGS_NONE;

    WStatus = CfgRegWriteDWord(FKC_BKUP_STARTUP_GLOBAL_BURFLAGS, NULL, 0, GblBurFlags);
    CLEANUP_WS(0, "ERROR - Failed to clear Global BurFlags.", WStatus, CLEANUP);

    goto CLEANUP;

CLEANUP_OK:
    WStatus = ERROR_SUCCESS;

CLEANUP:

    FRS_REG_CLOSE(HBurKey);

    return WStatus;
}


#define DEFAULT_MULTI_STRING_WCHARS (4)  // at least 8
VOID
FrsCatToMultiString(
    IN     PWCHAR   CatStr,
    IN OUT DWORD    *IOSize,
    IN OUT DWORD    *IOIdx,
    IN OUT PWCHAR   *IOStr
    )
/*++

Routine Description:

    Add a string + Catenation (if present) to the multi-string value

Arguments:

    CatStr   - string to concatenate
    IOSize   - Total size in wide chars of WStr
    IOIdx    - Current index to terminating \0 following \0 of last string
    IOStr    - Current string

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsCatToMultiString:"
    DWORD   NewSize;
    DWORD   CatSize;
    PWCHAR  Str;

    //
    // NOP
    //
    if (!CatStr) {
        return;
    }

    //
    // allocate initial buffer
    //
    if (!*IOStr) {
        *IOSize = DEFAULT_MULTI_STRING_WCHARS;
        *IOStr = FrsAlloc(*IOSize * sizeof(WCHAR));
        (*IOStr)[0] = L'\0';
        (*IOStr)[1] = L'\0';
        *IOIdx = 1;
    }

    //
    // Extend buffer when needed (note that CatStr overwrites first
    // \0 in the terminating \0\0. Hence, CatSize - 1 + 2 == CatSize + 1
    //
    CatSize = wcslen(CatStr);
    while ((CatSize + 1 + *IOIdx) >= *IOSize) {
        NewSize = *IOSize << 1;
        Str = FrsAlloc(NewSize * sizeof(WCHAR));
        CopyMemory(Str, *IOStr, *IOSize * sizeof(WCHAR));
        FrsFree(*IOStr);
        *IOStr = Str;
        *IOSize = NewSize;
    }
    //
    // Concatenate CatStr
    //
    *IOIdx -= 1;
    CopyMemory(&(*IOStr)[*IOIdx], CatStr, CatSize * sizeof(WCHAR));
    *IOIdx += CatSize;

    //
    // Append \0\0 and leave the index addressing the second \0.
    //
    (*IOStr)[*IOIdx] = L'\0';
    *IOIdx += 1;
    (*IOStr)[*IOIdx] = L'\0';

    FRS_ASSERT(*IOIdx < *IOSize);
}


VOID
FrsAddToMultiString(
    IN     PWCHAR   AddStr,
    IN OUT DWORD    *IOSize,
    IN OUT DWORD    *IOIdx,
    IN OUT PWCHAR   *IOStr
    )
/*++

Routine Description:

    Add a string + Catenation (if present) to the multi-string value

Arguments:

    AddStr   - string to add
    IOSize   - Total size in wide chars of WStr
    IOIdx    - Current index to terminating \0 following \0 of last string
    IOStr    - Current string

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsAddToMultiString:"
    DWORD   NewSize;
    DWORD   StrSize;
    PWCHAR  Str;

    //
    // NOP
    //
    if (!AddStr) {
        return;
    }

    //
    // allocate initial buffer
    //
    if (!*IOStr) {
        *IOSize = DEFAULT_MULTI_STRING_WCHARS;
        *IOStr = FrsAlloc(*IOSize * sizeof(WCHAR));
        *IOIdx = 0;
    }

    //
    // Extend buffer when needed
    //
    StrSize = wcslen(AddStr);
    while ((StrSize + 2 + *IOIdx) >= *IOSize) {
        NewSize = *IOSize << 1;
        Str = FrsAlloc(NewSize * sizeof(WCHAR));
        CopyMemory(Str, *IOStr, *IOSize * sizeof(WCHAR));
        FrsFree(*IOStr);
        *IOStr = Str;
        *IOSize = NewSize;
    }
    //
    // Append AddStr
    //
    CopyMemory(&(*IOStr)[*IOIdx], AddStr, StrSize * sizeof(WCHAR));
    *IOIdx += StrSize;

    //
    // Append \0\0 and leave the index addressing the second \0.
    //
    (*IOStr)[*IOIdx] = L'\0';
    *IOIdx += 1;
    (*IOStr)[*IOIdx] = L'\0';

    FRS_ASSERT(*IOIdx < *IOSize);
}




DWORD
UtilTranslateName(
    IN  PWCHAR              FromName,
    IN EXTENDED_NAME_FORMAT FromNameFormat,
    IN EXTENDED_NAME_FORMAT ToNameFormat,
    OUT PWCHAR              *OutToName
    )
/*++

Routine Description:

    Translate one name format into another

Arguments:

    FromName - Input, or source, name
    FromNameFormat - Format of FromName
    ToNameFormat - Desired format of *OutToName,
    OutToName - converted string; free with FrsFree()

Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "UtilTranslateName:"
    DWORD   WStatus;
    WCHAR   ToNameBuffer[MAX_PATH + 1];
    DWORD   ToNameSize = MAX_PATH + 1;
    PWCHAR  ToName = ToNameBuffer;

    *OutToName = NULL;

    if (!FromName) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Name -> Name (using stack buffer)
    //
    if (!TranslateName(FromName, FromNameFormat, ToNameFormat, ToName, &ToNameSize)) {
        WStatus = GetLastError();
    } else {
        WStatus = ERROR_SUCCESS;
    }
    //
    // Name -> Name (using FrsAlloc'ed buffer)
    //
    while (WIN_BUF_TOO_SMALL(WStatus)) {
        ToName = FrsAlloc((ToNameSize + 1) * sizeof(WCHAR));
        if (!TranslateName(FromName, FromNameFormat, ToNameFormat, ToName, &ToNameSize)) {
            WStatus = GetLastError();
            ToName = FrsFree(ToName);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ WARN - TranslateName(%ws);", FromName, WStatus);
        goto CLEANUP;
    }

    DPRINT2(5, "++ From -> To: %ws -> %ws\n",
            FromName, ToName);

    *OutToName = FrsWcsDup(ToName);

CLEANUP:
    if (ToName != ToNameBuffer) {
        FrsFree(ToName);
    }
    return WStatus;
}


DWORD
UtilConvertDnToStringSid(
    IN  PWCHAR  Dn,
    OUT PWCHAR  *OutStringSid
    )
/*++

Routine Description:

    Retries GetTokenInformation() with larger buffers.

Arguments:

    Dn - Dn of computer or user object
    OutStringSid - String'ized sid. Free with FrsFree();


Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "UtilConvertDnToStringSid:"
    DWORD   WStatus;
    WCHAR   SamCompatibleBuffer[MAX_PATH + 1];
    DWORD   SamCompatibleSize = MAX_PATH + 1;
    PWCHAR  SamCompatible = SamCompatibleBuffer;

    if (OutStringSid) {
        *OutStringSid = NULL;
    }

    if (!Dn) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Dn -> Account (using stack buffer)
    //
    if (!TranslateName(Dn,
                       NameFullyQualifiedDN,
                       NameSamCompatible,
                       SamCompatible,
                       &SamCompatibleSize)) {
        WStatus = GetLastError();
    } else {
        WStatus = ERROR_SUCCESS;
    }
    //
    // Dn -> Account (using FrsAlloc'ed buffer)
    //
    while (WIN_BUF_TOO_SMALL(WStatus)) {
        SamCompatible = FrsAlloc((SamCompatibleSize + 1) * sizeof(WCHAR));
        if (!TranslateName(Dn,
                           NameFullyQualifiedDN,
                           NameSamCompatible,
                           SamCompatible,
                           &SamCompatibleSize)) {
            WStatus = GetLastError();
            SamCompatible = FrsFree(SamCompatible);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }
    CLEANUP1_WS(4, "++ WARN - TranslateName(%ws);", Dn, WStatus, CLEANUP);

    DPRINT2(5, "++ Dn -> Account: %ws -> %ws\n", Dn, SamCompatible);

CLEANUP:
    if (SamCompatible != SamCompatibleBuffer) {
        FrsFree(SamCompatible);
    }
    return WStatus;
}


DWORD
UtilGetTokenInformation(
    IN HANDLE                   TokenHandle,
    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
    IN DWORD                    InitialTokenBufSize,
    OUT DWORD                   *OutTokenBufSize,
    OUT PVOID                   *OutTokenBuf
    )
/*++

Routine Description:

    Retries GetTokenInformation() with larger buffers.

Arguments:
    TokenHandle             - From OpenCurrentProcess/Thread()
    TokenInformationClass   - E.g., TokenUser
    InitialTokenBufSize     - Initial buffer size; 0 = default
    OutTokenBufSize         - Resultant returned buf size
    OutTokenBuf             - free with with FrsFree()


Return Value:

    OutTokenBufSize - Size of returned info (NOT THE BUFFER SIZE!)
    OutTokenBuf - info of type TokenInformationClass. Free with FrsFree().

--*/
{
#undef DEBSUB
#define DEBSUB "UtilGetTokenInformation:"
    DWORD               WStatus;

    *OutTokenBuf = NULL;
    *OutTokenBufSize = 0;

    //
    // Check inputs
    //
    if (!HANDLE_IS_VALID(TokenHandle)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (InitialTokenBufSize == 0 ||
        InitialTokenBufSize > (1024 * 1024)) {
        InitialTokenBufSize = 1024;
    }

    //
    // Retry if buffer is too small
    //
    *OutTokenBufSize = InitialTokenBufSize;
AGAIN:
    //
    // Need to check if *OutTokenBufSize == 0 as FrsAlloc asserts if called with 0 as the first parameter (prefix fix).
    //
    *OutTokenBuf = (*OutTokenBufSize == 0)? NULL : FrsAlloc(*OutTokenBufSize);
    WStatus = ERROR_SUCCESS;
    if (!GetTokenInformation(TokenHandle,
                             TokenInformationClass,
                             *OutTokenBuf,
                             *OutTokenBufSize,
                             OutTokenBufSize)) {
        WStatus = GetLastError();
        DPRINT2_WS(4, "++ WARN -  GetTokenInformation(Info %d, Size %d);",
                   TokenInformationClass, *OutTokenBufSize, WStatus);
        *OutTokenBuf = FrsFree(*OutTokenBuf);
        if (WIN_BUF_TOO_SMALL(WStatus)) {
            goto AGAIN;
        }
    }
    return WStatus;
}


VOID
UtilPrintUser(
    IN DWORD  Severity
    )
/*++

Routine Description:

    Print info about the user (privs, user sid).

Arguments:

    Severity    - for dprint

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "UtilPrintUser:"
    DWORD               WStatus;
    DWORD               TokenBufSize;
    PVOID               TokenBuf = NULL;
    HANDLE              TokenHandle = NULL;
    PWCHAR              SidStr;
    DWORD               i;
    TOKEN_PRIVILEGES    *Tp;
    TOKEN_USER          *Tu;
    DWORD               PrivLen;
    WCHAR               PrivName[MAX_PATH + 1];

    //
    // For this process/thread
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &TokenHandle)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - OpenProcessToken();", WStatus, CLEANUP);
    }

    //
    // Get the Token privileges from the access token for this thread or process
    //
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenPrivileges,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    CLEANUP_WS(4, "++ UtilGetTokenInformation(TokenPrivileges);", WStatus, USER);

    //
    // Print token privileges
    //
    Tp = (TOKEN_PRIVILEGES *)TokenBuf;
    for (i = 0; i < Tp->PrivilegeCount; ++i) {
        PrivLen = MAX_PATH + 1;
        if (!LookupPrivilegeName(NULL, &Tp->Privileges[i].Luid, PrivName, &PrivLen)) {
            DPRINT_WS(0, "++ WARN -  LookupPrivilegeName();", WStatus);
            continue;
        }
        DPRINT5(Severity, "++ Priv %2d is %ws :%s:%s:%s:\n",
                i,
                PrivName,
                (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_ENABLED_BY_DEFAULT) ? "Enabled by default" : "",
                (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_ENABLED) ? "Enabled" : "",
                (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_USED_FOR_ACCESS) ? "Used" : "");
    }
    TokenBuf = FrsFree(TokenBuf);

    //
    // Get the TokenUser from the access token for this process
    //
USER:
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenUser,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    CLEANUP_WS(4, "++ UtilGetTokenInformation(TokenUser);", WStatus, CLEANUP);

    Tu = (TOKEN_USER *)TokenBuf;
    if (!ConvertSidToStringSid(Tu->User.Sid, &SidStr)) {
        WStatus = GetLastError();
        DPRINT_WS(4, "++ WARN - ConvertSidToStringSid();", WStatus);
    } else {
        DPRINT1(Severity, "++ User Sid: %ws\n", SidStr);
        LocalFree(SidStr);
    }
    TokenBuf = FrsFree(TokenBuf);

CLEANUP:
    FRS_CLOSE(TokenHandle);
    FrsFree(TokenBuf);
}


DWORD
UtilRpcServerHandleToAuthSidString(
    IN  handle_t    ServerHandle,
    IN  PWCHAR      AuthClient,
    OUT PWCHAR      *AuthSid
    )
/*++

Routine Description:

    Extract a the string'ized user sid from the rpc server handle
    by impersonating the caller and extracting the token info.

Arguments:

    ServerHandle - from the rpc serve call
    AuthClient - From the rpc server handle; for messages
    ClientSid - stringized user sid; free with FrsFree()

Return Value:

    Win32 Status.

--*/
{
#undef DEBSUB
#define DEBSUB "UtilRpcServerHandleToAuthSidString:"
    DWORD       WStatus;
    DWORD       WStatus2;
    DWORD       TokenBufSize;
    PWCHAR      SidStr;
    TOKEN_USER  *Tu;
    PVOID       TokenBuf = NULL;
    BOOL        Impersonated = FALSE;
    HANDLE      TokenHandle = NULL;

    //
    // Initialize return value
    //
    *AuthSid = NULL;

    //
    // Impersonate the rpc caller
    //
    WStatus = RpcImpersonateClient(ServerHandle);
    CLEANUP1_WS(0, "++ ERROR - RpcImpersonateClient(%ws);", AuthClient, WStatus, CLEANUP);

    Impersonated = TRUE;

    //
    // Open the impersonated thread token
    //
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &TokenHandle)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - OpenProcessToken();", WStatus, CLEANUP);
    }

    //
    // Get the user sid
    //
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenUser,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    CLEANUP_WS(4, "++ UtilGetTokenInformation(TokenUser);", WStatus, CLEANUP);

    //
    // Convert the sid into a string
    //
    Tu = (TOKEN_USER *)TokenBuf;
    if (!ConvertSidToStringSid(Tu->User.Sid, &SidStr)) {
        WStatus = GetLastError();
        CLEANUP_WS(4, "++ WARN - ConvertSidToStringSid();", WStatus, CLEANUP);
    } else {
        DPRINT1(5, "++ Client Sid is %ws\n", SidStr);
        *AuthSid = FrsWcsDup(SidStr);
        LocalFree(SidStr);
    }

    //
    // Done
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:
    TokenBuf = FrsFree(TokenBuf);
    FRS_CLOSE(TokenHandle);

    if (Impersonated) {
        WStatus2 = RpcRevertToSelf();
        DPRINT1_WS(0, "++ ERROR IGNORED - RpcRevertToSelf(%ws);", AuthClient, WStatus2);
    }
    return WStatus;
}

BOOL
FrsRemoveDisabledPrivileges (
    VOID
    )
/*++

Routine Description:

    Remove all disabled privileges from our token.

    NOTE: THis capability is not available in WIN2K.

Arguments:

    None.

Return Value:

    TRUE if all disabled privileges were successfully removed.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsRemoveDisabledPrivileges:"

    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD WStatus = ERROR_SUCCESS;
    DWORD BufferSize = 0;
    HANDLE   hProcessToken = INVALID_HANDLE_VALUE;
    PTOKEN_PRIVILEGES pTokenPrivs = NULL;
    DWORD i = 0;
    #define PRIVILEGE_NAME_LENGTH MAX_PATH
    WCHAR PrivilegeName[PRIVILEGE_NAME_LENGTH];
    DWORD PrivilegeNameLength = PRIVILEGE_NAME_LENGTH;

    //
    // Open the token.
    //
    NtStatus = NtOpenProcessToken(NtCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &hProcessToken);

    if (!NT_SUCCESS(NtStatus))
    {
        DPRINT1(0, "Unable to open process token. NtStatus = 0x%08x\n", NtStatus);
        WStatus = FrsTranslateNtError(NtStatus, FALSE);
        goto Cleanup;
    }

    //
    // Read the priveleges.
    //

    //
    // First find out the buffer size we need.
    //

    GetTokenInformation(hProcessToken,
                        TokenPrivileges,
                        NULL,
                        0,
                        &BufferSize
                        );

    //
    // Allocate the buffer and get the info
    //

    pTokenPrivs = FrsAlloc(BufferSize);

    if(!GetTokenInformation(hProcessToken,
                            TokenPrivileges,
                            pTokenPrivs,
                            BufferSize,
                            &BufferSize
                            )) {

        WStatus = GetLastError();
        DPRINT1(0, "Unable to get token information. WStatus = %d\n", WStatus);
        goto Cleanup;
    }

    //
    // Find all non-enabled privileges and mark them for removal
    //

    for(i=0; i < pTokenPrivs->PrivilegeCount; i++) {
        if(!(pTokenPrivs->Privileges[i].Attributes &
             SE_PRIVILEGE_ENABLED)) {

            pTokenPrivs->Privileges[i].Attributes = SE_PRIVILEGE_REMOVED;

            if(!LookupPrivilegeName(NULL,
                                    &(pTokenPrivs->Privileges[i].Luid),
                                    PrivilegeName,
                                    &PrivilegeNameLength
                                    )) {
                DPRINT2(0, "Marking privilege %d-%d for removal.\n",
                        pTokenPrivs->Privileges[i].Luid.HighPart,
                        pTokenPrivs->Privileges[i].Luid.LowPart
                        );
            } else {
                DPRINT1(0, "Marking privilege %ws for removal.\n",
                        PrivilegeName);
            }

        }
    }


    //
    // Now, actually remove the privileges
    //

    if(!AdjustTokenPrivileges(hProcessToken,
                              FALSE,
                              pTokenPrivs,
                              BufferSize,
                              NULL,
                              NULL)) {
        WStatus = GetLastError();
        DPRINT1(0, "Unable to adjust token privileges. WStatus = %d\n", WStatus);
        goto Cleanup;
    }

    DPRINT(0, "Privileges successfully updated.\n");


Cleanup:

    FRS_CLOSE(hProcessToken);
    FrsFree(pTokenPrivs);

    return WIN_SUCCESS(WStatus);
}


BOOL
FrsSetupPrivileges (
    VOID
    )
/*++

Routine Description:

    Enable the privileges we need to replicate files.

Arguments:

    None.

Return Value:

    TRUE if got all privileges.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsSetupPrivileges:"

    NTSTATUS Status;

    //
    // Get the SE_SECURITY_PRIVILEGE to read/write SACLs on files.
    //
    Status = SetupOnePrivilege(SE_SECURITY_PRIVILEGE, "Security");
    if (!NT_SUCCESS(Status)) {
        DPRINT_WS(0, "ERROR - Failed to get Security privilege.",
                              FrsSetLastNTError(Status));
        return FALSE;
    }
    //
    // Get backup/restore privilege to bypass ACL checks.
    //
    Status = SetupOnePrivilege(SE_BACKUP_PRIVILEGE, "Backup");
    if (!NT_SUCCESS(Status)) {
        DPRINT_WS(0, "ERROR - Failed to get Backup privilege.",
                              FrsSetLastNTError(Status));
        return FALSE;
    }

    Status = SetupOnePrivilege(SE_RESTORE_PRIVILEGE, "Restore");
    if (!NT_SUCCESS(Status)) {
        DPRINT_WS(0, "ERROR - Failed to get Restore privilege.",
                              FrsSetLastNTError(Status));
        return FALSE;
    }

    return FrsRemoveDisabledPrivileges();

#if 0

    //
    // Set priority privilege in order to raise our base priority.
    //

    SetupOnePrivilege(SE_INC_BASE_PRIORITY_PRIVILEGE,
                      "Increase base priority");

    //
    // Set quota privilege in order to accommodate large profile buffers.
    //

    SetupOnePrivilege(SE_INCREASE_QUOTA_PRIVILEGE,
                      "Increase quotas");
#endif
}


DWORD
FrsMarkHandle(
    IN HANDLE   VolumeHandle,
    IN HANDLE   Handle
    )
/*++

Routine Description:

    Mark the handle as so that the journal record records
    a flag that indicates "replication service is altering the file; ignore".

Arguments:

    VolumeHandle    - Used to check access
    Handle          - Handle to mark

Return Value:

    Win32 Status

--*/
{

#undef DEBSUB
#define DEBSUB "FrsMarkHandle:"

    DWORD               WStatus;
    DWORD               BytesReturned;
    MARK_HANDLE_INFO    MarkHandleInfo;


    //
    // Mark the handle as one of ours so that the journal thread
    // knows to ignore the usn records.
    //
    MarkHandleInfo.UsnSourceInfo = USN_SOURCE_REPLICATION_MANAGEMENT;
    MarkHandleInfo.VolumeHandle = VolumeHandle;
    MarkHandleInfo.HandleInfo = 0;

    if (!DeviceIoControl(Handle,
                         FSCTL_MARK_HANDLE,
                         (LPVOID)&MarkHandleInfo,
                         (DWORD)sizeof(MarkHandleInfo),
                         NULL,
                         0,
                         (LPDWORD)&BytesReturned,
                         NULL)) {

        WStatus = GetLastError();
        DPRINT_WS(0, "++ WARN - DeviceIoControl(MarkHandle);", WStatus);
    } else {
        WStatus = ERROR_SUCCESS;
        //DPRINT(0, "++ TEMP - DeviceIoControl(MarkHandle) Success\n");
    }

    return WStatus;
}


VOID
FrsCreateJoinGuid(
    OUT GUID *OutGuid
    )
/*++

Routine Description:

    Generate a random session id that is sizeof(GUID) in length.
    The session id must be very random becuase it is used to
    authenticate packets from our partners after a join.
    The join was authenticated using impersonation.

Arguments:

    Guid - Address of a guid

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateJoinGuid:"
    DWORD       WStatus;
    HCRYPTPROV  hProv;

    //
    // Acquire the context.
    // Consider caching the context if this function is called often.
    //
    if (!CryptAcquireContext(&hProv,
                             NULL,
                             NULL,
                             PROV_RSA_FULL,
                             CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {
        WStatus = GetLastError();
        DPRINT_WS(0, "++ WARN - CryptAcquireContext();", WStatus);
        //
        // Can't use CryptGenRandom(); try using a guid
        //
        FrsUuidCreate(OutGuid);
    } else {
        //
        // Generate a random number
        //
        if (!CryptGenRandom(hProv, sizeof(GUID), (PBYTE)OutGuid)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "++ WARN - CryptGenRandom();", WStatus);
            //
            // Can't use CryptGenRandom(); try using a guid
            //
            FrsUuidCreate(OutGuid);
        } else {
            DPRINT(5, "++ Created join guid\n");
        }

        //
        // Release the context
        //
        if (!CryptReleaseContext(hProv, 0)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "++ ERROR - CryptReleaseContext();", WStatus);
        }
    }
}




VOID
FrsFlagsToStr(
    IN DWORD            Flags,
    IN PFLAG_NAME_TABLE NameTable,
    IN ULONG            Length,
    OUT PSTR            Buffer
    )
/*++

Routine Description:

    Routine to convert a Flags word to a descriptor string using the
    supplied NameTable.

Arguments:

    Flags - flags to convert.

    NameTable - An array of FLAG_NAME_TABLE structs.

    Length - Size of buffer in bytes.

    Buffer - buffer with returned string.

Return Value:

    Buffer containing printable string.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsFlagsToStr:"

    PFLAG_NAME_TABLE pNT = NameTable;
    LONG Remaining = Length-1;


    FRS_ASSERT((Length > 4) && (Buffer != NULL));

    *Buffer = '\0';
    if (Flags == 0) {
        strncpy(Buffer, "<Flags Clear>", Length);
        return;
    }


    //
    // Build a string for each bit set in the Flag name table.
    //
    while ((Flags != 0) && (pNT->Flag != 0)) {

        if ((pNT->Flag & Flags) != 0) {
            Remaining -= strlen(pNT->Name);

            if (Remaining < 0) {
                //
                // Out of string buffer.  Tack a "..." at the end.
                //
                Remaining += strlen(pNT->Name);
                if (Remaining > 3) {
                    strcat(Buffer, "..." );
                } else {
                    strcpy(&Buffer[Length-4], "...");
                }
                return;
            }

            //
            // Tack the name onto the buffer and clear the flag bit so we
            // know what is left set when we run out of table.
            //
            strcat(Buffer, pNT->Name);
            ClearFlag(Flags, pNT->Flag);
        }

        pNT += 1;
    }

    if (Flags != 0) {
        //
        // If any flags are still set give them back in hex if there is
        // enough room in the buffer. "0xFFFFFFFF " needs 12 characters
        // including the null.
        //
        if ((Length - strlen(Buffer)) >= 12) {
            sprintf( &Buffer[strlen(Buffer)], "0x%08x ", Flags );
        }
    }

    return;
}




DWORD
FrsDeleteByHandle(
    IN PWCHAR  Name,
    IN HANDLE  Handle
    )
/*++
Routine Description:
    This routine marks a file for delete, so that when the supplied handle
    is closed, the file will actually be deleted.

Arguments:
    Name    - for error messages
    Handle  - Supplies a handle to the file that is to be marked for delete.

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteByHandle:"

//
// NOTE:  This function is at the end of the module because we have to
// undefine DeleteFile to set the flag in the DispositionInfo struct.
//
#undef DeleteFile

    FILE_DISPOSITION_INFORMATION    DispositionInformation;
    IO_STATUS_BLOCK                 IoStatus;
    NTSTATUS                        NtStatus;

    if (!HANDLE_IS_VALID(Handle)) {
        return ERROR_SUCCESS;
    }

    //
    // Mark the file for delete. The delete happens when the handle is closed.
    //
    DispositionInformation.DeleteFile = TRUE;
    NtStatus = NtSetInformationFile(Handle,
                                    &IoStatus,
                                    &DispositionInformation,
                                    sizeof(DispositionInformation),
                                    FileDispositionInformation);
    DPRINT1_NT(4, "++ Could not delete %ws;", Name, NtStatus);

    return FrsSetLastNTError(NtStatus);
}

VOID
FrsForceDeleteFileByWildCard(
    PWCHAR      DirPath,
    PWCHAR      WildCard
    )
/*++
Routine Description:
    Delete all files that match the wildcard. The Path and wildcard are combined.
    to form the search path.

Arguments:

Return Value:
    None
--*/
{
#undef DEBSUB
#define DEBSUB "FrsForceDeleteFileByWildCard:"

    PWCHAR      SearchPath   = NULL;
    HANDLE      SearchHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    PWCHAR      FilePath     = NULL;
    DWORD       WStatus;

    if ((DirPath == NULL) || (wcslen(DirPath) == 0)) {
        return;
    }

    SearchPath = FrsWcsPath(DirPath, WildCard);

    SearchHandle = FindFirstFile(SearchPath, &FindData);

    if (!HANDLE_IS_VALID(SearchHandle)) {
        WStatus = GetLastError();
        if (WStatus != ERROR_FILE_NOT_FOUND) {
            DPRINT1_WS(1, "++ ERROR - FindFirstFile(%ws);", SearchPath, WStatus);
        }
        goto CLEANUP;
    }

    do {
        DPRINT1(4, "++ Deleting file %ws\n", FindData.cFileName);

        FilePath = FrsWcsPath(DirPath, FindData.cFileName);
        FrsForceDeleteFile(FilePath);
        FilePath = FrsFree(FilePath);

    } while (FindNextFile(SearchHandle, &FindData));

CLEANUP:

    FRS_FIND_CLOSE(SearchHandle);
    SearchPath = FrsFree(SearchPath);
}

VOID
FrsDeleteAllTempFiles(
    )
/*++
Routine Description:
    This routine enumerates the registry and deletes the preinstall directory
    and all staging files for all the replica sets. Call this only when we
    do not intent to use any state in the database. Calling this function
    while a replica set is in use can cause unexpected results.

Arguments:

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteAllTempFiles:"

    HKEY        hKey = INVALID_HANDLE_VALUE;
    DWORD       WStatus = ERROR_SUCCESS;
    DWORD       KeyIdx;
    WCHAR       RegBuf[MAX_PATH + 1];
    PWCHAR      RootPath = NULL;
    PWCHAR      PreInstallPath = NULL;
    PWCHAR      StagePath = NULL;
    PWCHAR      WildCard = NULL;

    //
    // Open the key "System\\CurrentControlSet\\Services\\NtFrs\\Parameters\\Replica Sets"
    // We will enumerate through all the subkeys under it and cleanup every
    // replica set.
    //
    WStatus = CfgRegOpenKey(FKC_SET_SECTION_KEY, NULL, 0, &hKey);

    if (!WIN_SUCCESS(WStatus)) {
        //
        // No replica sets to cleanup.
        //
        return;
    }

    KeyIdx = 0;

    while (TRUE) {
        WStatus = RegEnumKey(hKey, KeyIdx, RegBuf, MAX_PATH + 1);
        if (!WIN_SUCCESS(WStatus)) {
            if (WStatus != ERROR_NO_MORE_ITEMS) {
                DPRINT_WS(0, "WARN - Replica Sets enum.", WStatus);
            }
            break;
        }
        ++KeyIdx;
        WStatus = CfgRegReadString(FKC_SET_N_REPLICA_SET_ROOT, RegBuf, 0, &RootPath);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // Failure reading reg key.
            //
            DPRINT2_WS(0, "WARN - Failed to read key %ws for %ws\n", FKC_SET_N_REPLICA_SET_ROOT, RegBuf, WStatus);
            continue;
        }

        PreInstallPath = FrsWcsPath(RootPath,NTFRS_PREINSTALL_DIRECTORY);
        DPRINT1(4,"++ Deleting Preinstall directory %ws\n", PreInstallPath);
        FrsDeletePath(PreInstallPath, ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);

        RootPath = FrsFree(RootPath);
        PreInstallPath = FrsFree(PreInstallPath);

        WStatus = CfgRegReadString(FKC_SET_N_REPLICA_SET_STAGE, RegBuf, 0, &StagePath);
        if (!WIN_SUCCESS(WStatus)) {
            //
            // Failure reading reg key.
            //
            DPRINT2_WS(0, "WARN - Failed to read key %ws for %ws\n", FKC_SET_N_REPLICA_SET_ROOT, RegBuf, WStatus);
            continue;
        }

        //
        // Delete all the staging files in the staging area.
        //
        WildCard = FrsWcsCat(GENERIC_PREFIX, L"*.*");
        FrsForceDeleteFileByWildCard(StagePath, WildCard);
        WildCard = FrsFree(WildCard);

        RootPath = FrsFree(RootPath);
        PreInstallPath = FrsFree(PreInstallPath);
        StagePath = FrsFree(StagePath);
    }

    RootPath = FrsFree(RootPath);
    PreInstallPath = FrsFree(PreInstallPath);
    StagePath = FrsFree(StagePath);
    FRS_REG_CLOSE(hKey);

}

BOOL
ReparseTagReplicateFileData(
    DWORD ReparseTag
    )
{
    PREPARSE_TAG_TABLE_ENTRY ReparseTagTableEntry = NULL;

    ReparseTagTableEntry = GTabLookup(ReparseTagTable, &ReparseTag, NULL);

    if(ReparseTagTableEntry &&
       (0 == _wcsicmp(ReparseTagTableEntry->ReplicationType,
                      REPARSE_TAG_REPLICATION_TYPE_FILE_DATA))) {
        return TRUE;
    }

    return FALSE;
}

BOOL
ReparseTagReplicateReparsePoint(
    DWORD ReparseTag
    )
{

    PREPARSE_TAG_TABLE_ENTRY ReparseTagTableEntry = NULL;

    ReparseTagTableEntry = GTabLookup(ReparseTagTable, &ReparseTag, NULL);

    if(ReparseTagTableEntry &&
       (0 == _wcsicmp(ReparseTagTableEntry->ReplicationType,
                      REPARSE_TAG_REPLICATION_TYPE_REPARSE_POINT))) {
        return TRUE;
    }

    return FALSE;
}


VOID
FrsCheckLocalResources()
/*++

Routine Description:
    Checks the available disk space on the database volume and
    the root and staging volume for each active replica set.
    Uses the ReplicasByGuid table to enumerte the replicas.
    If the available disk space is less than 1% of the total
    disk space it prints the eventlog message EVENT_FRS_OUT_OF_DISK_SPACE.
Arguments:
    None.

Return Value:
    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsCheckLocalResources:"

    PREPLICA              Replica;
    PVOID                 Key;
    ULARGE_INTEGER        FreeBytesAvailableToCaller;
    ULARGE_INTEGER        TotalNumberOfBytes;
    PWCHAR                Volume;

    if (GetDiskFreeSpaceEx(WorkingPath,&FreeBytesAvailableToCaller,&TotalNumberOfBytes,NULL)) {
        //
        // Check space for database.
        // Print the event log message if the available free space is
        // less than 1%.
        //
        if ((FreeBytesAvailableToCaller.QuadPart*100) < TotalNumberOfBytes.QuadPart) {
            Volume = FrsWcsVolume(WorkingPath);
            if ((Volume != NULL) && (wcslen(Volume) >= wcslen(L"\\\\.\\D:"))) {
                //
                // If we are able to get the volume in the form
                // \\.\D: then use the volume in the event log so
                // that we don't print more than one event log
                // message per volume. If we can't get the
                // volume then we print the path.
                //
                EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, &Volume[4]);
            }else{
                EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, WorkingPath);
            }
            FrsFree(Volume);
        }
        DPRINT3(5, "Disk space check for database. %ws FreeSpace = %08x %08x bytes,TotalDiskSpace = %08x %08x bytes\n",
                WorkingPath,
                PRINTQUAD(FreeBytesAvailableToCaller.QuadPart),
                PRINTQUAD(TotalNumberOfBytes.QuadPart));

        FreeBytesAvailableToCaller.QuadPart = FreeBytesAvailableToCaller.QuadPart/(1024*1024);
        TotalNumberOfBytes.QuadPart = TotalNumberOfBytes.QuadPart/(1024*1024);

        DPRINT3(4, "Disk space check for database. %ws FreeSpace = %d MB,TotalDiskSpace = %d MB\n",
                WorkingPath,
                FreeBytesAvailableToCaller.LowPart,
                TotalNumberOfBytes.LowPart);
    }

    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        if (GetDiskFreeSpaceEx(Replica->Root,&FreeBytesAvailableToCaller,&TotalNumberOfBytes,NULL)) {
            //
            // For each replica check free disk space on the
            // volume hosting the root path.
            // Print the event log message if the available free space is
            // less than 1%.
            //
            if ((FreeBytesAvailableToCaller.QuadPart*100) < TotalNumberOfBytes.QuadPart) {
                if ((Replica->Volume != NULL) && (wcslen(Replica->Volume) >= wcslen(L"\\\\.\\D:"))) {
                    //
                    // If we are able to get the volume in the form
                    // \\.\D: then use the volume in the event log so
                    // that we don't print more than one event log
                    // message per volume. If we can't get the
                    // volume then we print the path.
                    //
                    EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, &Replica->Volume[4]);
                }else{
                    EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, Replica->Root);
                }
            }
            DPRINT3(5, "Disk space check for replica root. %ws FreeSpace = %08x %08x bytes,TotalDiskSpace = %08x %08x bytes\n",
                    Replica->Root,
                    PRINTQUAD(FreeBytesAvailableToCaller.QuadPart),
                    PRINTQUAD(TotalNumberOfBytes.QuadPart));

            FreeBytesAvailableToCaller.QuadPart = FreeBytesAvailableToCaller.QuadPart/(1024*1024);
            TotalNumberOfBytes.QuadPart = TotalNumberOfBytes.QuadPart/(1024*1024);

            DPRINT3(4, "Disk space check for replica root. %ws FreeSpace = %d MB,TotalDiskSpace = %d MB\n",
                    Replica->Root,
                    FreeBytesAvailableToCaller.LowPart,
                    TotalNumberOfBytes.LowPart);
        }

        if (GetDiskFreeSpaceEx(Replica->Stage,&FreeBytesAvailableToCaller,&TotalNumberOfBytes,NULL)) {
            //
            // For each replica check free disk space on the
            // volume hosting the staging path.
            // Print the event log message if the available free space is
            // less than 1%.
            //
            if ((FreeBytesAvailableToCaller.QuadPart*100) < TotalNumberOfBytes.QuadPart) {
                Volume = FrsWcsVolume(Replica->Stage);
                if ((Volume != NULL) && (wcslen(Volume) >= wcslen(L"\\\\.\\D:"))) {
                    //
                    // If we are able to get the volume in the form
                    // \\.\D: then use the volume in the event log so
                    // that we don't print more than one event log
                    // message per volume. If we can't get the
                    // volume then we print the path.
                    //
                    EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, &Volume[4]);
                }else{
                    EPRINT1(EVENT_FRS_OUT_OF_DISK_SPACE, Replica->Stage);
                }
                FrsFree(Volume);
            }

            DPRINT3(5, "Disk space check for replica stage. %ws FreeSpace = %08x %08x bytes,TotalDiskSpace = %08x %08x bytes\n",
                    Replica->Stage,
                    PRINTQUAD(FreeBytesAvailableToCaller.QuadPart),
                    PRINTQUAD(TotalNumberOfBytes.QuadPart));

            FreeBytesAvailableToCaller.QuadPart = FreeBytesAvailableToCaller.QuadPart/(1024*1024);
            TotalNumberOfBytes.QuadPart = TotalNumberOfBytes.QuadPart/(1024*1024);

            DPRINT3(4, "Disk space check for replica stage. %ws FreeSpace = %d MB,TotalDiskSpace = %d MB\n",
                    Replica->Stage,
                    FreeBytesAvailableToCaller.LowPart,
                    TotalNumberOfBytes.LowPart);
        }
    }
}

DWORD
FrsFreezeForBackup()
/*++

Routine Description:
    This API is called by the FRS writer component.
    This API sets the FrsFrozenForBackup flag and then
    waits for the install command server to finish
    processing all install that are currently in
    progress. When the install command server completes
    all currently active installs it sets the 
    FrsNoInstallsInProgressEvent event.

    This is an synchronous API that does not return
    until the install command server has drained all
    currently active installs. Once this API returns
    it is guaranteed that FRS will not install
    any more files until the FrsThawAfterBackup API
    is called at which point it resumes installs.

    Try not to leave FRS in frozen state for a long time.
    While FRS is in frozen state no files are installed and
    staging files can keep increasing. Since the staging
    reclaim logic does not delete staging files that are
    marked install-incomplete this can lead to staging full
    errors.

    Frozen state is not persistent across service shutdown
    and startup.

    There is no reference count on the number of times
    freeze is called. One call to thaw will cause the
    service to resume installs even if freeze was called
    multiple times.

Arguments:
    None.

Return Value:
    WStatus.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsFreezeForBackup:"

    DPRINT2(4,"Before: FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);
    if (FrsFrozenForBackup) {
        DPRINT2(4,"Already in frozen state: FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);
        return ERROR_SUCCESS;
    }

    ResetEvent(FrsThawEvent);
    FrsFrozenForBackup = TRUE;

    ResetEvent(FrsNoInstallsInProgressEvent);
    if (FrsFilesInInstall >= 0) {
        DPRINT2(4,"Waiting to freeze: FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);
        WaitForSingleObject(FrsNoInstallsInProgressEvent, INFINITE);
    }
    DPRINT2(4,"After: FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);

    return ERROR_SUCCESS;
}

DWORD
FrsThawAfterBackup()
/*++

Routine Description:
    This API is used to take the service out of frozen state.
    This API sets the FrsThawEvent event. The 
    install command server threads are waiting for this
    event.

    See the description of FrsFreezeForBackup for more details.

Arguments:
    None.

Return Value:
    WStatus.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsThawAfterBackup:"

    DPRINT2(4,"Before: FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);
    if (FrsFrozenForBackup == FALSE) {
        DPRINT2(4,"Already in thaw state: FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);
        return ERROR_SUCCESS;
    }

    FrsFrozenForBackup = FALSE;
    SetEvent(FrsThawEvent);

    DPRINT2(4,"After: FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\vvector.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    vvector.c

Abstract:
    The version vector is a dampening mechanism that prevents replicating
    the same change to the same machine more than once.

    The version keeps track of the last change that has been received
    by a machine or the last change that was sent to a machine.

    A new change order is checked against the version vector before
    it is given to the change order accept thread. If dampened, the
    sender receives an ACK. Along with the ACK is the current
    version for the specified originator. This allows the sender
    to update its outbound cxtion version vector and dampen
    change orders before they are sent.

Author:
    Billy J. Fuller 18-Apr-1997

    David A. Orbits 15-Oct-97 :
        Revise to retire CO's in order so all COs coming from the same
        originator propagate in order.  Integrate with ChgOrdIssueCleanup()
        and restructure locking.

Environment
    User mode winnt

--*/


#include <ntreppch.h>
#pragma  hdrstop

#undef DEBSUB
#define DEBSUB  "VVECTOR:"

#include <frs.h>
#include <tablefcn.h>

ULONG
ChgOrdIssueCleanup(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    ULONG                 CleanUpFlags
    );



ULONG
VVReserveRetireSlot(
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++
Routine Description:
    A replica can have many outstanding change orders from any given
    originator. The change orders can complete out of sequence but
    we don't want to update the version vector with a later version
    if a earlier version is still in progress. The pending versions
    are kept on the duplicate list.

    A pending version transitions to "retired" when its change
    order is retired. After the database is updated, the version
    is committed.

    The incore version vector is then updated with the youngest
    version (largest VSN) in the list that has been committed.

    Change orders always issue in order by orginator VSN (except for retries)
    so the version vector update and propagation to the outbound log also
    occur in order.


    PERF - We should be using the existing table lock.

Arguments:

    Replica -- ptr to the replica struct for the version vector.

    Coe -- ptr to the change order entry.

Return Value:
    FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB  "VVReserveRetireSlot:"
    PVV_RETIRE_SLOT         RetireSlot;
    PVV_ENTRY               MasterVVEntry;
    PGEN_TABLE              VV = Replica->VVector;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;
    PLIST_ENTRY             InsertBeforeEntry = NULL;

    //
    // If this CO has already done the VV update or had it executed then done.
    //
    if (CO_IFLAG_ON(Coe, CO_IFLAG_VVRETIRE_EXEC) ||
        CO_FLAG_ON(Coe, CO_FLAG_VV_ACTIVATED)) {
            return FrsErrorSuccess;
    }

    //
    // If this is a out of order CO then it should not update out VV.
    // The CO_FLAG_SKIP_VV_UPDATE flag is preserved and also sent to our
    // downstream.
    //
    if (CO_FLAG_ON(Coe, CO_FLAG_OUT_OF_ORDER)) {
        SET_CO_FLAG(Coe, CO_FLAG_SKIP_VV_UPDATE);
    }

    //
    // A call to reserve must be matched with a call to retire before
    // another call to reserve can be made for the same change order.
    // The only exception is that once a slot is activated it can stay on the
    // list after the CO has retired or has been marked for retry.  In this case
    // a duplicate remote CO could arrive and be issued.
    //
    LOCK_GEN_TABLE(VV);

    MasterVVEntry = GTabLookupNoLock(VV, &Coc->OriginatorGuid, NULL);

    if (MasterVVEntry) {


        DPRINT1(4, "Coc->FrsVsn             : %08x %08x\n",
                PRINTQUAD(Coc->FrsVsn));

        DPRINT1(4, "MasterVVEntry->GVsn.Vsn : %08x %08x\n",
                PRINTQUAD(MasterVVEntry->GVsn.Vsn));

        //
        // If we are trying to reserve a slot for a CO with a lower VSN then
        // mark the CO as out of order and do not reserve a slot.
        //
        if (MasterVVEntry->GVsn.Vsn >= Coc->FrsVsn) {
            SET_CO_FLAG(Coe, CO_FLAG_OUT_OF_ORDER);
            SET_CO_FLAG(Coe, CO_FLAG_SKIP_VV_UPDATE);
            DPRINT(4, "CO with older VSN received.\n");
            UNLOCK_GEN_TABLE(VV);
            return FrsErrorSuccess;
        }

        ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
            // The iterator pE is of type PVV_RETIRE_SLOT.

            DPRINT1(4, "pE->Vsn             : %08x %08x\n",
                    PRINTQUAD(pE->Vsn));

            if (pE->Vsn > Coc->FrsVsn) {
                SET_CO_FLAG(Coe, CO_FLAG_OUT_OF_ORDER);
                SET_CO_FLAG(Coe, CO_FLAG_SKIP_VV_UPDATE);
                InsertBeforeEntry = &pE->Link;
                break;

            } else if (pE->Vsn == Coc->FrsVsn) {
                //
                // Slot exists. Check if it is activated.
                //
                if (pE->ChangeOrder != NULL) {
                    //
                    // This is probably a duplicate CO.
                    //
                    CHANGE_ORDER_TRACE(3, Coe, "VVResrv Activated Retire Slot Exists");
                    UNLOCK_GEN_TABLE(VV);
                    return FrsErrorKeyDuplicate;
                } else {
                    CHANGE_ORDER_TRACE(3, Coe, "VVResrv Retire Slot Exists");
                    UNLOCK_GEN_TABLE(VV);
                    return FrsErrorSuccess;
                }
            }
        );
    }

    //
    // This change order does not have a reserved slot
    //
    // If new originator; create a new version vector entry.
    //
    if (!MasterVVEntry) {
        //
        // New version vector entry.  We don't have to hold locks because the
        // only time a new version vector entry is created is when change
        // order accept is processing a change order.
        //
        MasterVVEntry = FrsAlloc(sizeof(VV_ENTRY));
        InitializeListHead(&MasterVVEntry->ListHead);
        COPY_GUID(&MasterVVEntry->GVsn.Guid, &Coc->OriginatorGuid);
        MasterVVEntry->GVsn.Vsn = QUADZERO;

        //
        // Add it to the version vector table.
        //
        GTabInsertEntryNoLock(VV, MasterVVEntry, &MasterVVEntry->GVsn.Guid, NULL);
    }

    CHANGE_ORDER_TRACE(3, Coe, "VVReserve Slot");

    //
    // Allocate a version vector retire slot.
    //
    RetireSlot = FrsAlloc(sizeof(VV_RETIRE_SLOT));
    RetireSlot->Vsn = Coc->FrsVsn;
    RetireSlot->RetireSlotFlags = 0;

    if (COC_FLAG_ON(Coc, CO_FLAG_OUT_OF_ORDER)) {
        RetireSlot->RetireSlotFlags |= VV_RETIRE_SLOT_FLAG_OUT_OF_ORDER;
    }

    if (InsertBeforeEntry != NULL) {
        InsertTailList(InsertBeforeEntry, &RetireSlot->Link);
    } else {
        //
        // The retire slot is linked to the list tail to maintain Issue order.
        //
        InsertTailList(&MasterVVEntry->ListHead, &RetireSlot->Link);
    }

    VV_PRINT(4, L"End of Reserve Retire Slot", VV);
    UNLOCK_GEN_TABLE(VV);

    return FrsErrorSuccess;
}


ULONG
VVRetireChangeOrder(
    IN PTHREAD_CTX          ThreadCtx,
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN ULONG                CleanUpFlags
    )
/*++
Routine Description:

    Activate or discard the retire slot reserved for this change order.
    The ChangeOrder pointer and the CleanUpFlags are saved in the slot entry.
    If the retire slot is now at the head of the list the version vector
    can be updated, the change order propagated to the outbound log and the
    slot entry is freed.  The update process continues with the new head
    entry if that slot is activated.

    The incore version vector is updated after the database is updated.
    Both are updated with the VSN of the most recent entry that is processed.

    * NOTE * -- A remote CO that is discarded still needs to Ack the inbound
    partner.  The caller must handle this since a discard request
    to an entry that is not activated just causes the entry to be removed
    from the list and freed.  The version vector should NOT be updated by
    the caller in this case since the update may be out of order.  If it
    is necessary to update the VV then you must activate the retire slot
    (not setting the ISCU_INS_OUTLOG cleanup flag).  The caller can still
    trigger the inbound partner ACK out of order since that does not affect
    the version vector.  Or you can pass in the ISCU_ACK_INBOUND cleanup flag
    when you activate the entry.

Arguments:

    ThreadCtx -- Ptr to the DB thread context to use for calls to Issue cleanup.
    Replica -- Replica set context.
    ChangeOrder -- Change order to activate or discard.
    CleanUpFlags -- Cleanup flags saved in the slot entry for use when
                    VV is updated and CO is propagated.

Return Value:

    FRS STATUS
    FrsErrorVVSlotNotFound -- Returned when no VVSlot is found for an out of order
                              change order.  This means that no Issue Cleanup
                              actions will be initiated here on behalf of the=is
                              CO.  So the caller better take care of it.

--*/
{
#undef DEBSUB
#define DEBSUB  "VVRetireChangeOrder:"
#define FlagChk(_flag_) BooleanFlagOn(CleanUpFlags, _flag_)

    ULONG                   FStatus;
    PVV_RETIRE_SLOT         RetireSlot;
    PVV_RETIRE_SLOT         NextRetireSlot;
    PVV_ENTRY               MasterVVEntry;
    PCHANGE_ORDER_COMMAND   Coc = &ChangeOrder->Cmd;
    PGEN_TABLE              VV = Replica->VVector;
    BOOL                    First;
    ULONG                   Flags;
    ULONGLONG               UpdateVsn;
    PLIST_ENTRY             Entry;
    PLIST_ENTRY             pNext;
    GUID                    OriginatorGuid;
    BOOL                    SkipVVUpdate;
    BOOL                    Blocking;
    PIDTABLE_RECORD         IDTableRec;

    //
    // Find the originator's entry in the version vector
    //
    LOCK_GEN_TABLE(VV);
    VV_PRINT(5, L"Start of Retire Change Order", VV);

    //
    // Nothing to do if CO says we are VV Retired.
    //
    if (CO_IFLAG_ON(ChangeOrder, CO_IFLAG_VVRETIRE_EXEC)) {
        UNLOCK_GEN_TABLE(VV);
        CHANGE_ORDER_TRACE(3, ChangeOrder, "VVRetire Err SAR");
        return FrsErrorSuccess;
    }

    //
    // Make a copy of the Guid.  May need it after CO is deleted.
    //
    OriginatorGuid = Coc->OriginatorGuid;
    MasterVVEntry = GTabLookupNoLock(VV, &OriginatorGuid, NULL);

    if (MasterVVEntry == NULL) {
        //
        // Out of order change orders now participate in vv reitre logic.
        //
        if (FlagChk(ISCU_ACTIVATE_VV_DISCARD)) {

            UNLOCK_GEN_TABLE(VV);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "VVRetire OK");
            return FrsErrorVVSlotNotFound;
        }
    }
    FRS_ASSERT(MasterVVEntry);

    //
    // Find the retire slot for this change order.
    //
    RetireSlot = NULL;
    First = TRUE;
    ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
        // The iterator pE is of type PVV_RETIRE_SLOT.
        if (pE->Vsn == Coc->FrsVsn) {
            RetireSlot = pE;
            break;
        }

        if (!BooleanFlagOn(pE->RetireSlotFlags, VV_RETIRE_SLOT_FLAG_OUT_OF_ORDER)) {
            First = FALSE;
        }
    );

    if (RetireSlot == NULL) {
        //
        //
        // Out of order change orders now participate in vv reitre logic.
        //
        //
        if (FlagChk(ISCU_ACTIVATE_VV_DISCARD) || (MasterVVEntry->GVsn.Vsn >= Coc->FrsVsn)) {
            UNLOCK_GEN_TABLE(VV);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "VVRetire OK (not found)");
            return FrsErrorVVSlotNotFound;
        }
    }

    FRS_ASSERT(RetireSlot != NULL);

    // if the CO is aborted and the CO is not activated then free the slot.
    // if the CO is aborted and the CO is activated AND the VSN would have
    // moved the master VSN backwards then suppress the update.
    //

    //
    // This change order might have been marked out of order after
    // a slot was reserved.
    //
    if (CO_FLAG_ON(ChangeOrder, CO_FLAG_OUT_OF_ORDER)) {
        SET_CO_FLAG(ChangeOrder, CO_FLAG_SKIP_VV_UPDATE);
        RetireSlot->RetireSlotFlags |= VV_RETIRE_SLOT_FLAG_OUT_OF_ORDER;
    }

    FRS_PRINT_TYPE(5, ChangeOrder);

    //
    // Activate or discard the affected slot
    //
    if (!FlagChk(ISCU_ACTIVATE_VV_DISCARD)) {

        //
        // The change order has passsed the point of initial retire.
        // Activate the slot by saving the pointer and bumping the ref count.
        //
        // Note: The change order can still be aborted or retried (e.g. Install
        //       fails).
        //
        FRS_ASSERT(RetireSlot->ChangeOrder == NULL);
        INCREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);
        RetireSlot->ChangeOrder = ChangeOrder;
        RetireSlot->CleanUpFlags = CleanUpFlags;

        CHANGE_ORDER_TRACE(3, ChangeOrder, "VV Slot Activated");

    } else {

        //
        // Discard the slot only if it is a non activated abort co. For
        // all other cos we keep the slot around.
        //
        if ((RetireSlot->ChangeOrder == NULL) &&
            (CO_FLAG_ON(ChangeOrder, CO_FLAG_ABORT_CO) ||
             COE_FLAG_ON(ChangeOrder, COE_FLAG_STAGE_ABORTED) ||
             CO_STATE_IS(ChangeOrder, IBCO_ABORTING))) {
            FrsRemoveEntryList(&RetireSlot->Link);
            FrsFree(RetireSlot);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "VV ActSlot Discarded");
            goto PROCESS_LIST;
        } else if (CO_FLAG_ON(ChangeOrder, CO_FLAG_RETRY) || CO_FLAG_ON(ChangeOrder, CO_FLAG_OUT_OF_ORDER)){
            SET_CO_FLAG(ChangeOrder, CO_FLAG_OUT_OF_ORDER);
            SET_CO_FLAG(ChangeOrder, CO_FLAG_SKIP_VV_UPDATE);
            RetireSlot->RetireSlotFlags |= VV_RETIRE_SLOT_FLAG_OUT_OF_ORDER;
        }

        if (RetireSlot->ChangeOrder != NULL) {
            CHANGE_ORDER_TRACE(3, ChangeOrder, "VV ActSlot Do not Discard");
            RetireSlot->CleanUpFlags |= CleanUpFlags;
            ClearFlag(RetireSlot->CleanUpFlags, (ISCU_INS_OUTLOG |
                                                 ISCU_INS_OUTLOG_NEW_GUID));
        }

        //
        // We were trying to discard the slot.
        // If this CO is a local CO and it is occupying the first non out of order
        // slot and if there is a activated CO following it in the retire list then mark
        // this CO to be out of order so we can make progress.
        //

        if ((First == TRUE) && CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO) &&
        !BooleanFlagOn(RetireSlot->RetireSlotFlags, VV_RETIRE_SLOT_FLAG_OUT_OF_ORDER)) {

            Entry = GetListNext(&RetireSlot->Link);
            Blocking = FALSE;
            while (Entry != &MasterVVEntry->ListHead) {

                NextRetireSlot = CONTAINING_RECORD(Entry, VV_RETIRE_SLOT, Link);
                if (NextRetireSlot->ChangeOrder != NULL) {
                    Blocking = TRUE;
                    break;
                } else if (!BooleanFlagOn(NextRetireSlot->RetireSlotFlags, VV_RETIRE_SLOT_FLAG_OUT_OF_ORDER)) {
                    break;
                }

                Entry = GetListNext(Entry);
            }

            //
            // This local CO is blocking other COs so mark it out of order and move on.
            // We go through all the trouble above to minimize the number of COs
            // marked Out of Order.
            //
            if (Blocking == TRUE) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "Set CO OofO");
                SET_CO_FLAG(ChangeOrder, CO_FLAG_OUT_OF_ORDER);
                SET_CO_FLAG(ChangeOrder, CO_FLAG_SKIP_VV_UPDATE);
                RetireSlot->RetireSlotFlags |= VV_RETIRE_SLOT_FLAG_OUT_OF_ORDER;
            } else {
                DPRINT(5, "Non blocking local co.\n");
            }
        }
    }

PROCESS_LIST:

    //
    // If this change order is not or was not next in line to propagate then
    // it waits for the prior change orders to finish before updating
    // the version vector with this VSN.
    //
    if (!First) {
        VV_PRINT(4, L"End of Retire Change Order", VV);
        UNLOCK_GEN_TABLE(VV);
        return FrsErrorSuccess;
    }


    //
    // If we are already doing retires on this originator then the thread doing
    // it will pick up our entry next.  Otherwise we do it.
    // This Flag is used by the VV code to serialize database updates with
    // respect to a given originator. It avoids holding the GEN_TABLE lock
    // across database disk operations but keeps another thread from racing
    // with us to do a VV update on the same originator record.
    //
    if (BooleanFlagOn(MasterVVEntry->CleanUpFlags, VV_ENTRY_RETIRE_ACTIVE)) {
        UNLOCK_GEN_TABLE(VV);
        return FrsErrorSuccess;
    }

    SetFlag(MasterVVEntry->CleanUpFlags, VV_ENTRY_RETIRE_ACTIVE);

    //
    // Propagate Change Orders for all activated retire slots at front of list.
    //

    SkipVVUpdate = FALSE;

    Entry = &MasterVVEntry->ListHead;

    while (!IsListEmpty(&MasterVVEntry->ListHead) && (Entry != GetListTail(&MasterVVEntry->ListHead))) {

        Entry = GetListNext(Entry);
        RetireSlot = CONTAINING_RECORD(Entry, VV_RETIRE_SLOT, Link);

        //
        // If not retired then done.
        //
        if (RetireSlot->ChangeOrder == NULL) {

            if (!BooleanFlagOn(RetireSlot->RetireSlotFlags, VV_RETIRE_SLOT_FLAG_OUT_OF_ORDER)) {
                break;
            }

            SkipVVUpdate = TRUE;
            continue;
        }

        CHANGE_ORDER_TRACE(3, RetireSlot->ChangeOrder, "VV RetireSlot & Update");
        //
        // If this is the last entry to retire, update the VV table in database.
        // If we crash during processing of a series of retiring VV slots the
        // worst that can happen is that our VV entry for this originator is
        // a little old.  When we join we will request files based on this
        // Version Vector entry that we already have.  These COs will be
        // rejected so the actual files are not fetched.
        //
        Flags = 0;
        IDTableRec = (PIDTABLE_RECORD)(RetireSlot->ChangeOrder->RtCtx->IDTable.pDataRecord);
        if ((SkipVVUpdate == TRUE) || CO_FLAG_ON(RetireSlot->ChangeOrder, CO_FLAG_SKIP_VV_UPDATE)) {
            SET_CO_FLAG(RetireSlot->ChangeOrder, CO_FLAG_SKIP_VV_UPDATE);
            SetIdRecVVFlag(IDTableRec, IDREC_VVFLAGS_SKIP_VV_UPDATE);
            Flags = ISCU_UPDATE_IDT_VVFLAGS;
        } else if (IsIdRecVVFlagSet(IDTableRec,IDREC_VVFLAGS_SKIP_VV_UPDATE)) {
            ClearIdRecVVFlag(IDTableRec, IDREC_VVFLAGS_SKIP_VV_UPDATE);
            Flags = ISCU_UPDATE_IDT_VVFLAGS;
        }

        if (!CO_FLAG_ON(RetireSlot->ChangeOrder, CO_FLAG_SKIP_VV_UPDATE)) {
            pNext = GetListNext(&RetireSlot->Link);
            if ((pNext == &MasterVVEntry->ListHead) ||
                (CONTAINING_RECORD(pNext, VV_RETIRE_SLOT, Link)->ChangeOrder == NULL)){
                Flags |= ISCU_UPDATEVV_DB;
            }
        }

        //
        // Reset the entry to the first entry on list so that after removing current entry
        // we can rescan the list. We can not continue scanning form where we left
        // off because below we drop the VV lock and so another thread could come in and
        // change the entries on the list.
        //
        Entry = &MasterVVEntry->ListHead;
        SkipVVUpdate = FALSE;
//        Entry = GetListTail(Entry);
        FrsRemoveEntryList(&RetireSlot->Link);

        //
        // Complete the propagation of the postponed change order, drop our
        // reference and clear ISCU_ACTIVATE_VV so we don't come back here
        // recursively.  The dropped ref could free the CO so don't try to
        // deref it.
        //
        Flags |= RetireSlot->CleanUpFlags | ISCU_FREEMEM_CLEANUP;
        ClearFlag(Flags, ISCU_ACTIVATE_VV);

        //
        // If this CO has been aborted then don't insert it into the Outbound
        // log.  Partner ack (if remote) and other cleanup is still needed.
        //
        if (CO_IFLAG_ON(RetireSlot->ChangeOrder, CO_IFLAG_CO_ABORT)) {
            ClearFlag(Flags, (ISCU_INS_OUTLOG |
                              ISCU_INS_OUTLOG_NEW_GUID));
        }

        //
        // This is to deal with the case of a crash after a remote CO has
        // installed or after a local CO has gened the staging file but the
        // VV prop is blocked by another CO.  In the latter case the CO would
        // be marked activated but not executed.  Or the remote CO could still be in
        // retry because of rename deferred, etc, but the vvretire is already done.
        // Code at startup uses this to sort things out.
        //
        SET_CO_IFLAG(RetireSlot->ChangeOrder, CO_IFLAG_VVRETIRE_EXEC);

        //
        // Update the master version vector before we drop the lock so reserve
        // can filter out of order remote COs from a different inbound partner
        // correctly.  These could come straight in or be retry COs.
        //
        if (!CO_FLAG_ON(RetireSlot->ChangeOrder, CO_FLAG_SKIP_VV_UPDATE)) {
            UpdateVsn = RetireSlot->Vsn;
            DPRINT2(5, "Updating MasterVVEntry from %08x %08x  to  %08x %08x\n",
                    PRINTQUAD(MasterVVEntry->GVsn.Vsn), PRINTQUAD(UpdateVsn));
            FRS_ASSERT(UpdateVsn >= MasterVVEntry->GVsn.Vsn);
            MasterVVEntry->GVsn.Vsn = UpdateVsn;
        }

        //
        // Drop the table lock so others can do lookups, reserve slots or do
        // retires while we are doing database operations.
        // We still have the Dbs VV lock so another thread can't
        // get into this loop and cause a race to update the database VV table.
        // And since the RetireSlot is already off the list the retry thread
        // can't get a reference to it.
        //
        UNLOCK_GEN_TABLE(VV);

        FStatus = ChgOrdIssueCleanup(ThreadCtx,
                                     Replica,
                                     RetireSlot->ChangeOrder,
                                     Flags);
        DPRINT_FS(0,"ERROR - ChgOrdIssueCleanup failed.", FStatus);
        FRS_ASSERT(FStatus == FrsErrorSuccess);

        //
        // Free up the memory of the retire slot.
        //
        FrsFree(RetireSlot);
        LOCK_GEN_TABLE(VV);
    }


    //
    // Clear the retire active flag so the next thread that activates the
    // first entry on the list can enter the retire loop.
    //
    ClearFlag(MasterVVEntry->CleanUpFlags, VV_ENTRY_RETIRE_ACTIVE);

    VV_PRINT(4, L"End of Retire Change Order", VV);
    UNLOCK_GEN_TABLE(VV);

    return FrsErrorSuccess;
}



PCHANGE_ORDER_ENTRY
VVReferenceRetireSlot(
    IN PREPLICA  Replica,
    IN PCHANGE_ORDER_COMMAND CoCmd
    )
/*++
Routine Description:
    Look for an activated retire slot for this Guid/Vsn pair.
    If found and the connection guid in the change order matches then
    increment the reference count and return the Change order pointer.

Arguments:

    Replica -- ptr to the replica struct for the version vector.

    CoCmd -- ptr to change order command that we are trying to match.

Return Value:
    A ptr to the change order if found or NULL.

--*/
{
#undef DEBSUB
#define DEBSUB  "VVReferenceRetireSlot:"

    ULONGLONG            FrsVsn;
    PVV_ENTRY            MasterVVEntry;
    PGEN_TABLE           VV = Replica->VVector;
    PCHANGE_ORDER_ENTRY  ChangeOrder = NULL;
    GUID                *OriginatorGuid;
    GUID                *CxtionGuid;
    GUID                *CoGuid;


    FrsVsn = CoCmd->FrsVsn;
    OriginatorGuid = &CoCmd->OriginatorGuid;
    CxtionGuid = &CoCmd->CxtionGuid;

    LOCK_GEN_TABLE(VV);

    MasterVVEntry = GTabLookupNoLock(VV, OriginatorGuid, NULL);

    if (MasterVVEntry) {
        ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
            // The iterator pE is of type PVV_RETIRE_SLOT.
            if (pE->Vsn == FrsVsn) {

                if ((pE->ChangeOrder != NULL) &&
                     GUIDS_EQUAL(&pE->ChangeOrder->Cmd.CxtionGuid, CxtionGuid)) {

                    //
                    // Found a match.  But need to also check for a CO Guid match.
                    //
                    CoGuid = &CoCmd->ChangeOrderGuid;
                    if (!GUIDS_EQUAL(CoGuid, &pE->ChangeOrder->Cmd.ChangeOrderGuid)) {
                        //
                        // The CO Guid's do not match.  The CO on the VV Retire
                        // chain has a matching OriginatorGuid, a matching VSN
                        // and a matching CxtionGuid so it is the same CO but
                        // we got a duplicate with a new CO Guid.  One way this
                        // can happen is if M1 was doing a VVJOIN from M2 and
                        // M2 had a CO for file X in the retry install state.
                        // When the CO on M2 finally finishes it must re-insert
                        // the CO into the outbound log, assigning the CO a new
                        // CO Guid.  The CO that was sent as part of the VVJoin
                        // operation could have the same OriginatorGuid, FrsVsn
                        // and Cxtion Guid, causing a match above.  In addition
                        // since M2 proped the incomming CO into the outlog
                        // after it fetched the staging file from its upstream
                        // partner it will have to re-insert the CO a second
                        // time if it was forced to go thru the retry install
                        // loop.  This is because it can't know how the propped
                        // CO was ordered relative to the VVJoin generated CO.
                        // This bites.  (313427)
                        //
                        DPRINT(0, "WARN - COGuid Mismatch on VVretireSlot hit\n");

                        CHANGE_ORDER_TRACE(0, pE->ChangeOrder, "No VVRef COGuid Mismatch-1");
                        CHANGE_ORDER_COMMAND_TRACE(0, CoCmd, "No VVRef COGuid Mismatch-2");
                    } else {

                        //
                        // Match is OK.
                        //
                        ChangeOrder = pE->ChangeOrder;
                        INCREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);
                        CHANGE_ORDER_TRACE(3, ChangeOrder, "VV Ref CO");
                    }
                }
                break;
            }
        );
    }


    UNLOCK_GEN_TABLE(VV);

    return ChangeOrder;
}


VOID
VVUpdate(
    IN PGEN_TABLE   VV,
    IN ULONGLONG    Vsn,
    IN GUID         *Guid
    )
/*++
Routine Description:
    Update the version vector if the new vsn is greater than
    the current version. Or if the entry does not yet exist in VV.

Arguments:
    VV
    Vsn
    Guid

Return Value:
    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "VVUpdate:"
    PVV_ENTRY VVEntry;

    //
    // Locate the originator's entry in the version vector
    //
    LOCK_GEN_TABLE(VV);

    VVEntry = GTabLookupNoLock(VV, Guid, NULL);
    if (VVEntry) {
        if (Vsn > VVEntry->GVsn.Vsn) {

            //
            // Update the existing entry's vsn
            //
            VVEntry->GVsn.Vsn = Vsn;
        }
    } else {

        //
        // Insert the new entry
        //
        VVEntry = FrsAlloc(sizeof(VV_ENTRY));
        VVEntry->GVsn.Vsn = Vsn;
        COPY_GUID(&VVEntry->GVsn.Guid, Guid);
        InitializeListHead(&VVEntry->ListHead);
        GTabInsertEntryNoLock(VV, VVEntry, &VVEntry->GVsn.Guid, NULL);
    }

    UNLOCK_GEN_TABLE(VV);
}


VOID
VVInsertOutbound(
    IN PGEN_TABLE   VV,
    IN PGVSN        GVsn
    )
/*++
Routine Description:
    Insert the given gvsn (guid, vsn) into the version vector.
    The GVsn is addressed by the gen table, don't delete it or
    change its guid!

    WARN - This function should only be used when creating
    the outbound version vector.

Arguments:
    VV   - version vector to update
    GVsn - record to insert

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVInsertOutbound:"
    GTabInsertEntry(VV, GVsn, &GVsn->Guid, NULL);
}


VOID
VVUpdateOutbound(
    IN PGEN_TABLE   VV,
    IN PGVSN        GVsn
    )
/*++
Routine Description:
    Update the version vector if the new vsn is greater than
    the current version. Or if the entry does not yet exist in VV.

    This function is intended for use only with the version vector
    associated with an outbound cxtion because that version vector
    uses GVSN's as the version vector entry. This saves memory.

Arguments:
    VV
    GVsn

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVUpdateOutbound:"
    PGVSN       OldGVsn;

    //
    // Probably a command packet without a RsGVsn()
    //
    if (!GVsn) {
        return;
    }
    //
    // Find the originator's entry in the version vector
    //
    LOCK_GEN_TABLE(VV);
    OldGVsn = GTabLookupNoLock(VV, &GVsn->Guid, NULL);
    if (OldGVsn) {
        //
        // Update the version if it is greater
        //
        if (GVsn->Vsn > OldGVsn->Vsn) {
            OldGVsn->Vsn = GVsn->Vsn;
        }
        FrsFree(GVsn);
    }
    UNLOCK_GEN_TABLE(VV);
    if (!OldGVsn) {
        //
        // Create a new entry
        //
        VVInsertOutbound(VV, GVsn);
    }
}


BOOL
VVHasVsnNoLock(
    IN PGEN_TABLE   VV,
    IN GUID         *OriginatorGuid,
    IN ULONGLONG    Vsn
    )
/*++
Routine Description:
    Check if the change order's Vsn is "in" the VV

Arguments:
    VV
    OriginatorGuid
    Vsn

Return Value:
    TRUE    - Vsn is in version vector
    FALSE   - Not
--*/
{
#undef DEBSUB
#define DEBSUB  "VVHasVsnNoLock:"
    BOOL        Ret = FALSE;
    PGVSN       GVsn;
    PGEN_ENTRY  Entry;

    //
    // Locate the originator's entry in the version vector
    //      The caller holds the table lock across the compare because
    //      the 64-bit vsn is not updated atomically. Don't
    //      hold the VV lock because that lock is held
    //      across db updates.
    //
    Entry = GTabLookupEntryNoLock(VV, OriginatorGuid, NULL);
    if (Entry) {
        FRS_ASSERT(!Entry->Dups);
        GVsn = Entry->Data;
        Ret = (Vsn <= (ULONGLONG)GVsn->Vsn);
    }
    return Ret;
}





BOOL
VVHasOriginatorNoLock(
    IN PGEN_TABLE   VV,
    IN GUID         *OriginatorGuid
    )
/*++
Routine Description:
    Check if the supplied originator guid is present in the version vector.

Arguments:
    VV
    OriginatorGuid

Return Value:
    TRUE    - Originator guid is present in version vector

--*/
{
#undef DEBSUB
#define DEBSUB  "VVHasOriginatorNoLock:"

    //
    // Locate the originator's entry in the version vector
    //      The caller holds the table lock across the compare because
    //      the 64-bit vsn is not updated atomically. Don't
    //      hold the VV lock because that lock is held
    //      across db updates.
    //

    return (GTabLookupEntryNoLock(VV, OriginatorGuid, NULL) != NULL);

}


BOOL
VVHasVsn(
    IN PGEN_TABLE            VV,
    IN PCHANGE_ORDER_COMMAND Coc
    )
/*++
Routine Description:
    Check if the change order's Vsn is "in" the VV

Arguments:
    VV
    Coc

Return Value:
    TRUE    - Vsn is in version vector
    FALSE   - Not
--*/
{
#undef DEBSUB
#define DEBSUB  "VVHasVsn:"
    BOOL        Ret = FALSE;

    //
    // This change order is out of order and hence its vsn
    // cannot be compared with the vsn in the version vector.
    //
    if (BooleanFlagOn(Coc->Flags, CO_FLAG_OUT_OF_ORDER)) {
        return FALSE;
    }

    //
    // Locate the originator's entry in the version vector
    //      Hold the table lock across the compare because
    //      the 64-bit vsn is not updated atomically. Don't
    //      hold the VV lock because that lock is held
    //      across db updates.
    //
    LOCK_GEN_TABLE(VV);
    Ret = VVHasVsnNoLock(VV, &Coc->OriginatorGuid, Coc->FrsVsn);
    UNLOCK_GEN_TABLE(VV);

    return Ret;
}


PGVSN
VVGetGVsn(
    IN PGEN_TABLE VV,
    IN GUID       *Guid
    )
/*++
Routine Description:
    Lookup the Vsn for Guid in VV.

Arguments:
    VV
    Guid

Return Value:
    Copy of the GVsn or NULL
--*/
{
#undef DEBSUB
#define DEBSUB  "VVGetGVsn:"
    PGVSN       GVsn = NULL;
    PGEN_ENTRY  Entry;

    //
    // Locate the originator's entry in the version vector
    //      Hold the table lock across the compare because
    //      the 64-bit vsn is not updated atomically. Don't
    //      hold the VV lock because that lock is held
    //      across db updates.
    //
    LOCK_GEN_TABLE(VV);

    Entry = GTabLookupEntryNoLock(VV, Guid, NULL);
    if (Entry) {
        FRS_ASSERT(!Entry->Dups);
        GVsn = Entry->Data;
        GVsn = FrsBuildGVsn(&GVsn->Guid, GVsn->Vsn);
    }

    UNLOCK_GEN_TABLE(VV);
    return (GVsn);
}


PGEN_TABLE
VVDupOutbound(
    IN PGEN_TABLE   VV
    )
/*++
Routine Description:
    Duplicate the version vector as an outbound version vector.
    An outbound version vector is composed of GVSNs instead of
    VV_ENTRYs to save space. BUT, since the first entry in a
    VV_ENTRY is a GVSN, this routin can duplicate any version
    vector.

Arguments:
    Outbound    - version vector to duplicate as an outbound version vector

Return Value:
    Outbound version vector
--*/
{
#undef DEBSUB
#define DEBSUB  "VVDupOutbound:"
    PVOID       Key;
    PGVSN       GVsn;
    PGEN_TABLE  NewVV;

    //
    // No vv, nothing to do
    //
    if (!VV) {
        return NULL;
    }

    //
    // Allocate duplicate version vector
    //
    NewVV = GTabAllocTable();

    //
    // Fill it up
    //
    LOCK_GEN_TABLE(VV);
    Key = NULL;
    while (GVsn = GTabNextDatumNoLock(VV, &Key)) {
        GVsn = FrsBuildGVsn(&GVsn->Guid, GVsn->Vsn);
        GTabInsertEntryNoLock(NewVV, GVsn, &GVsn->Guid, NULL);
    }
    UNLOCK_GEN_TABLE(VV);

    //
    // Done
    //
    return NewVV;
}


PVOID
VVFreeOutbound(
    IN PGEN_TABLE VV
    )
/*++
Routine Description:
    Delete the version vector for an outbound cxtion

Arguments:
    VV      - version vector to update

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVFreeOutbound:"
    return GTabFreeTable(VV, FrsFree);
}


VOID
VVFree(
    IN PGEN_TABLE VV
    )
/*++
Routine Description:
    Delete the version vector for the replica

Arguments:
    VV      - version vector to update

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVFree:"
    PVOID       Key;
    PVV_ENTRY   MasterVVEntry;

    Key = NULL;
    if (VV) while (MasterVVEntry = GTabNextDatum(VV, &Key)) {
        ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
            // The iterator pE is of type PVV_RETIRE_SLOT.
            FrsFree(pE);
        );
    }

    GTabFreeTable(VV, FrsFree);
}


#if DBG
VOID
VVPrint(
    IN ULONG        Severity,
    IN PWCHAR       Header,
    IN PGEN_TABLE   VV,
    IN BOOL         IsOutbound
    )
/*++
Routine Description:
    Print a version vector

    Caller must have acquired the VV table lock so se can safely enumerate
    the list. i.e.  LOCK_GEN_TABLE(VV).

Arguments:
    Severity
    Header
    VV
    IsOutbound

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVPrint:"
    PVOID       Key;
    PVV_ENTRY   MasterVVEntry;
    CHAR        Guid[GUID_CHAR_LEN + 1];

    DPRINT2(Severity, "VV for %ws: %08x\n", Header, VV);
    Key = NULL;
    if (VV) while (MasterVVEntry = GTabNextDatumNoLock(VV, &Key)) {
        GuidToStr(&MasterVVEntry->GVsn.Guid, Guid);
        DPRINT2(Severity, "\t%s = %08x %08x\n", Guid, PRINTQUAD(MasterVVEntry->GVsn.Vsn));

        if (!IsOutbound) {
            ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
                // The iterator pE is of type PVV_RETIRE_SLOT.
                DPRINT3(Severity, "\t\t%08x %08x  CO: %08x  RetireSlotFlags: %08x\n",
                        PRINTQUAD(pE->Vsn), pE->ChangeOrder, pE->RetireSlotFlags);
            );

        } else {
            DPRINT1(Severity, "\t\t%08x %08x\n", PRINTQUAD(MasterVVEntry->GVsn.Vsn));
        }
    }
}
#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\queue.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    queue.c

Abstract:

    Generic efficient queue package.

Author:

    John Vert (jvert) 12-Jan-1996

Revision History:

    David Orbits (davidor) 23-Apr-1997
        Added command packet routines.
        Added interlocked list routines.

Introduction
A striped queue is really just a list of queues that are managed as a single
queue.  When a caller request a queue entry, the first entry for the queue at
the head of the list is returned and that queue is moved to the tail of the
list to prevent starvation of the other queues on the list.  Callers sleep when
none of the queues have entries.  The caller must be ready to accept an entry
from any queue.  Striped queues allow a caller to serialize access to a
sub-queue.

Structures
The same structure is used for both the queue and the controlling queue.
A controlling queue plus its component queues are termed a striped queue.
There is no striped queue structure. The struct contains the following:

-   critical section for locking
-   List head for entries
-   Address of the controlling queue
-   List head for Full queues
-   List head for Empty queues
-   List head for Idled queues
-   Count of the number of entries on a queue
-   Count of the number of entries on all controlled queues

Initializing
A non-striped (regular) queue is created with:
    FrsRtlInitializeQueue(Queue, Queue)

A striped queue controlled by ControlQueue and composed of QueueA and QueueB
is created with:
    FrsRtlInitializeQueue(ControlQueue, ControlQueue)
    FrsRtlInitializeQueue(QueueA, ControlQueue)
    FrsRtlInitializeQueue(QueueB, ControlQueue)

Queues can be added and deleted from the stripe at any time.

Idling Queues
The controlling queue for a striped queue maintains a list of Full queues,
Empty queues, and Idled queues. A striped queue allows a caller to serialize
access to a queue by "idling" the queue. No other thread is allowed to pull
an entry from the queue until the caller "UnIdles" the queue:

Entry = FrsRtlRemoveHeadTimeoutIdled(Queue, 0, &IdledQueue)
        Process Entry
    FrsRtlUnIdledQueue(IdledQueue);

Entries can be inserted to an idled queue and they can be removed with
FrsRtlRemoveQueueEntry().

Non-Striped queues do not support the serializing "idling" feature. The
IdledQueue parameter is ignored.

Inserting Entries
Use the normal queue insertion routines for queues, striped queues, and idled
queues. DO NOT insert into the controlling queue if this is a striped queue.

Removing Entries
Use the normal queue removal routines for queues, striped queues, and idled
queues. Removals from a striped queue will return an entry from any of the
sub-queues except for idled sub-queues. The FrsRtlRemoveQueueEntry() function
will remove an entry from even an idled queue.

Functions
DbgCheckLinkage                    - Checks all of the linkage in a queue
FrsRtlInitializeQueue              - Initializes any queue
FrsRtlDeleteQueue                  - Cleans up any queue
FrsRtlRundownQueue                 - Aborts the queue and returns a list of entries
FrsRtlUnIdledQueue                 - Moves a queue from the idle to one of the active lists
FrsRtlRemoveHeadQueue              - Remove the head of the queue
FrsRtlRemoveHeadQueueTimeout       - Remove the head of the queue
FrsRtlRemoveHeadQueueTimeoutIdled  - Remove the head of the queue
FrsRtlRemoveEntryQueueLock         - Remove entry from locked queue
FrsRtlInsertTailQueue              - Insert entry into queue at tail
FrsRtlInsertTailQueueLock          - Insert entry into locked queue at head
FrsRtlInsertHeadQueue              - Insert entry into queue at tail
FrsRtlInsertHeadQueueLock          - Insert entry into locked queue at head
FrsRtlWaitForQueueFull             - wait for an entry to appear on the queue

Rundown
Calling rundown on the controlling queue is NOT supported. Don't do that
Running down a component queue does not rundown the controlling queue.
The abort event is set in the controlling queue when the last component
queue is rundown.

--*/
#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>

VOID
FrsCompleteSynchronousCmdPkt(
    IN PCOMMAND_PACKET CmdPkt,
    IN PVOID           CompletionArg
    );

//
// This is the command packet schedule queue. It is used when you need to
// queue a command packet to be processed in the future.
//
FRS_QUEUE FrsScheduleQueue;



// #define PRINT_QUEUE(_S_, _Q_)   PrintQueue(_S_, _Q_)
#define PRINT_QUEUE(_S_, _Q_)
VOID
PrintQueue(
    IN ULONG        Sev,
    IN PFRS_QUEUE  Queue
    )
/*++

Routine Description:

    Print the queue

Arguments:

    Sev     - dprint severity
    Queue   - Supplies a pointer to a queue structure to check

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "PrintQueue:"
    DWORD       Count;
    DWORD       ControlCount;
    BOOL        FoundFull;
    BOOL        FoundEmpty;
    BOOL        FoundIdled;
    PLIST_ENTRY Entry;
    PLIST_ENTRY OtherEntry;
    PFRS_QUEUE  OtherQueue;
    PFRS_QUEUE  Control;

    DPRINT1(0, "***** Print Queue %08x *****\n", Queue);

    Control = Queue->Control;
    if (Queue == Control) {
        DPRINT1(Sev, "\tQueue       : %08x\n", Queue);
        DPRINT1(Sev, "\tCount       : %8d\n", Queue->Count);
        DPRINT1(Sev, "\tControlCount: %8d\n", Queue->ControlCount);
        DPRINT1(Sev, "\tRundown     : %s\n", (Queue->IsRunDown) ? "TRUE" : "FALSE");
        DPRINT1(Sev, "\tIdled       : %s\n", (Queue->IsIdled) ? "TRUE" : "FALSE");
        return;
    }
    DPRINT2(Sev, "\tControl     : %08x for %08x\n", Control, Queue);
    DPRINT1(Sev, "\tCount       : %8d\n", Control->Count);
    DPRINT1(Sev, "\tControlCount: %8d\n", Control->ControlCount);
    DPRINT1(Sev, "\tRundown     : %s\n", (Control->IsRunDown) ? "TRUE" : "FALSE");
    DPRINT1(Sev, "\tIdled       : %s\n", (Control->IsIdled) ? "TRUE" : "FALSE");

    //
    // Full list
    //
    DPRINT(Sev, "\tFULL\n");
    for (Entry = GetListNext(&Control->Full);
         Entry != &Control->Full;
         Entry = GetListNext(Entry)) {
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Full);
        if (OtherQueue == Queue) {
            DPRINT(Sev, "\t\tTHIS QUEUE\n");
        }
        DPRINT1(Sev, "\t\tQueue       : %08x\n", OtherQueue);
        DPRINT1(Sev, "\t\tCount       : %8d\n", OtherQueue->Count);
        DPRINT1(Sev, "\t\tControlCount: %8d\n", OtherQueue->ControlCount);
        DPRINT1(Sev, "\t\tRundown     : %s\n", (OtherQueue->IsRunDown) ? "TRUE" : "FALSE");
        DPRINT1(Sev, "\t\tIdled       : %s\n", (OtherQueue->IsIdled) ? "TRUE" : "FALSE");
    }

    //
    // Empty list
    //
    DPRINT(Sev, "\tEMPTY\n");
    for (Entry = GetListNext(&Control->Empty);
         Entry != &Control->Empty;
         Entry = GetListNext(Entry)) {
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Empty);
        if (OtherQueue == Queue) {
            DPRINT(Sev, "\t\tTHIS QUEUE\n");
        }
        DPRINT1(Sev, "\t\tQueue       : %08x\n", OtherQueue);
        DPRINT1(Sev, "\t\tCount       : %8d\n", OtherQueue->Count);
        DPRINT1(Sev, "\t\tControlCount: %8d\n", OtherQueue->ControlCount);
        DPRINT1(Sev, "\t\tRundown     : %s\n", (OtherQueue->IsRunDown) ? "TRUE" : "FALSE");
        DPRINT1(Sev, "\t\tIdled       : %s\n", (OtherQueue->IsIdled) ? "TRUE" : "FALSE");
    }

    //
    // Idle list
    //
    DPRINT(Sev, "\tIDLE\n");
    for (Entry = GetListNext(&Control->Idled);
         Entry != &Control->Idled;
         Entry = GetListNext(Entry)) {
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Idled);
        if (OtherQueue == Queue) {
            DPRINT(Sev, "\t\tTHIS QUEUE\n");
        }
        DPRINT1(Sev, "\t\tQueue       : %08x\n", OtherQueue);
        DPRINT1(Sev, "\t\tCount       : %8d\n", OtherQueue->Count);
        DPRINT1(Sev, "\t\tControlCount: %8d\n", OtherQueue->ControlCount);
        DPRINT1(Sev, "\t\tRundown     : %s\n", (OtherQueue->IsRunDown) ? "TRUE" : "FALSE");
        DPRINT1(Sev, "\t\tIdled       : %s\n", (OtherQueue->IsIdled) ? "TRUE" : "FALSE");
    }
}


BOOL
DbgCheckQueue(
    PFRS_QUEUE  Queue
    )
/*++

Routine Description:

    Check the consistency of the queue

Arguments:

    Queue   - Supplies a pointer to a queue structure to check

Return Value:
    TRUE    - everything is okay
    Assert  - assert error
--*/
{
#undef DEBSUB
#define DEBSUB  "DbgCheckQueue:"
    DWORD       Count;
    DWORD       ControlCount;
    BOOL        FoundFull;
    BOOL        FoundEmpty;
    BOOL        FoundIdled;
    PLIST_ENTRY Entry;
    PLIST_ENTRY OtherEntry;
    PFRS_QUEUE  OtherQueue;
    PFRS_QUEUE  Control;

    if (!DebugInfo.Queues) {
        return TRUE;
    }

    FRS_ASSERT(Queue);
    Control = Queue->Control;
    FRS_ASSERT(Control);

    if (Control->IsRunDown) {
        FRS_ASSERT(Control->ControlCount == 0);
        FRS_ASSERT(Queue->IsRunDown);
        FRS_ASSERT(IsListEmpty(&Control->Full));
        FRS_ASSERT(IsListEmpty(&Control->Empty));
        FRS_ASSERT(IsListEmpty(&Control->Idled));
    }
    if (Queue->IsRunDown) {
        FRS_ASSERT(Queue->Count == 0);
        FRS_ASSERT(IsListEmpty(&Queue->Full));
        FRS_ASSERT(IsListEmpty(&Queue->Empty));
        FRS_ASSERT(IsListEmpty(&Queue->Idled));
    }

    FRS_ASSERT(!Control->IsIdled);

    //
    // Check Full list
    //
    ControlCount = 0;
    FoundFull = FALSE;
    Entry = &Control->Full;
    do {
        Entry = GetListNext(Entry);
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Full);
        if (OtherQueue == Queue) {
            FoundFull = TRUE;
        }
        FRS_ASSERT(Control == OtherQueue ||
               (!OtherQueue->IsRunDown && !OtherQueue->IsIdled));
        Count = 0;
        if (!IsListEmpty(&OtherQueue->ListHead)) {
            OtherEntry = GetListNext(&OtherQueue->ListHead);
            do {
                ++Count;
                ++ControlCount;
                OtherEntry = GetListNext(OtherEntry);
            } while (OtherEntry != &OtherQueue->ListHead);
        }
        FRS_ASSERT(Count == OtherQueue->Count);
    } while (OtherQueue != Control);
    FRS_ASSERT(ControlCount == Control->ControlCount ||
           (Control == Queue && Control->ControlCount == 0));

    //
    // Check Empty list
    //
    ControlCount = 0;
    FoundEmpty = FALSE;
    Entry = &Control->Empty;
    do {
        Entry = GetListNext(Entry);
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Empty);
        if (OtherQueue == Queue) {
            FoundEmpty = TRUE;
        }
        FRS_ASSERT(Control == OtherQueue ||
               (!OtherQueue->IsRunDown && !OtherQueue->IsIdled));
        Count = 0;
        if (!IsListEmpty(&OtherQueue->ListHead)) {
            OtherEntry = GetListNext(&OtherQueue->ListHead);
            do {
                ++Count;
                ++ControlCount;
                OtherEntry = GetListNext(OtherEntry);
            } while (OtherEntry != &OtherQueue->ListHead);
        }
        FRS_ASSERT(Count == OtherQueue->Count);
    } while (OtherQueue != Control);

    //
    // Check Idled list
    //
    FoundIdled = FALSE;
    Entry = &Control->Idled;
    do {
        Entry = GetListNext(Entry);
        OtherQueue = CONTAINING_RECORD(Entry, FRS_QUEUE, Idled);
        if (OtherQueue == Queue) {
            FoundIdled = TRUE;
        }
        FRS_ASSERT(Control == OtherQueue || OtherQueue->IsIdled);
        Count = 0;
        if (!IsListEmpty(&OtherQueue->ListHead)) {
            OtherEntry = GetListNext(&OtherQueue->ListHead);
            do {
                ++Count;
                OtherEntry = GetListNext(OtherEntry);
            } while (OtherEntry != &OtherQueue->ListHead);
        }
        FRS_ASSERT(Count == OtherQueue->Count);
    } while (OtherQueue != Control);

    //
    // Verify state
    //
    FRS_ASSERT((Queue->Count && !IsListEmpty(&Queue->ListHead)) ||
           (!Queue->Count && IsListEmpty(&Queue->ListHead)));
    if (Control == Queue) {
        //
        // We are our own controlling queue
        //
        FRS_ASSERT(FoundFull && FoundEmpty && FoundIdled);
    } else {
        //
        // Controlled by a separate queue
        //
        if (Queue->IsRunDown) {
            FRS_ASSERT(!FoundFull && !FoundEmpty && !FoundIdled && !Queue->Count);
        } else {
            FRS_ASSERT(FoundFull || FoundEmpty || FoundIdled);
        }

        if (FoundFull) {
            FRS_ASSERT(!FoundEmpty && !FoundIdled && Queue->Count);
        } else if (FoundEmpty) {
            FRS_ASSERT(!FoundFull && !FoundIdled && !Queue->Count);
        } else if (FoundIdled) {
            FRS_ASSERT(!FoundFull && !FoundEmpty);
        }
    }

    return TRUE;
}


VOID
FrsInitializeQueue(
    PFRS_QUEUE Queue,
    PFRS_QUEUE Control
    )
/*++

Routine Description:

    Initializes a queue for use.

Arguments:

    Queue - Supplies a pointer to a queue structure to initialize

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsInitializeQueue:"

    ZeroMemory(Queue, sizeof(FRS_QUEUE));

    InitializeListHead(&Queue->ListHead);
    InitializeListHead(&Queue->Full);
    InitializeListHead(&Queue->Empty);
    InitializeListHead(&Queue->Idled);

    INITIALIZE_CRITICAL_SECTION(&Queue->Lock);

    Queue->IsRunDown = FALSE;
    Queue->IsIdled = FALSE;
    Queue->Control = Control;
    Queue->InitTime = GetTickCount();

    if (Control->IsRunDown) {
        Queue->IsRunDown = TRUE;
        return;
    }

    //
    // Begin life on the empty queue
    //
    FrsRtlAcquireQueueLock(Queue);

    InsertTailList(&Control->Empty, &Queue->Empty);
    FRS_ASSERT(DbgCheckQueue(Queue));

    FrsRtlReleaseQueueLock(Queue);


    //
    // The controlling queue supplies the events so there is no
    // need to create extraneous events.
    //
    if (Queue == Control) {
        Queue->Event = FrsCreateEvent(TRUE, FALSE);
        Queue->RunDown = FrsCreateEvent(TRUE, FALSE);
    }
}


VOID
FrsRtlDeleteQueue(
    IN PFRS_QUEUE Queue
    )
/*++

Routine Description:

    Releases all resources used by a queue.

Arguments:

    Queue - supplies the queue to be deleted

Return Value:

    None.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlDeleteQueue:"

    PFRS_QUEUE  Control;

    Control = Queue->Control;

    if (Queue == Control) {
        FRS_ASSERT(IsListEmpty(&Queue->Full)  &&
                   IsListEmpty(&Queue->Empty) &&
                   IsListEmpty(&Queue->Idled));
    } else {
        FRS_ASSERT(IsListEmpty(&Queue->ListHead));
    }

    EnterCriticalSection(&Control->Lock);

    FRS_ASSERT(DbgCheckQueue(Queue));
    RemoveEntryListB(&Queue->Full);
    RemoveEntryListB(&Queue->Empty);
    RemoveEntryListB(&Queue->Idled);
    Control->ControlCount -= Queue->Count;
    FRS_ASSERT(DbgCheckQueue(Queue));

    LeaveCriticalSection(&Control->Lock);

    DeleteCriticalSection(&Queue->Lock);

    //
    // Only the controlling queue has valid handles
    //
    if (Queue == Control) {
        FRS_CLOSE(Queue->Event);
        FRS_CLOSE(Queue->RunDown);
    }

    //
    // Zero the memory in order to cause grief for those who
    // use a deleted queue.
    //
    ZeroMemory(Queue, sizeof(FRS_QUEUE));
}


VOID
FrsRtlRunDownQueue(
    IN PFRS_QUEUE Queue,
    OUT PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Runs down a queue that is about to be destroyed. Any threads currently
    waiting on the queue are unwaited (FrsRtlRemoveHeadQueue will return NULL)
    and the contents of the queue (if any) are returned to the caller for
    cleanup.

Arguments:

    Queue - supplies the queue to be rundown

    ListHead - returns the list of items currently in the queue.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlRunDownQueue:"

    PFRS_QUEUE  Control = Queue->Control;
    PLIST_ENTRY Entry;
    PLIST_ENTRY First;
    PLIST_ENTRY Last;

    EnterCriticalSection(&Control->Lock);

    //
    // Running down a controlling queue is not allowed unless they
    // are the same queue.
    //
    if (Control == Queue) {
        FRS_ASSERT(IsListEmpty(&Control->Full)  &&
                   IsListEmpty(&Control->Empty) &&
                   IsListEmpty(&Control->Idled));
    } else {
        FRS_ASSERT(!IsListEmpty(&Control->Full)  ||
                   !IsListEmpty(&Control->Empty) ||
                   !IsListEmpty(&Control->Idled) ||
                   Control->IsRunDown);
    }

/*
    FRS_ASSERT((Control == Queue &&
                IsListEmpty(&Control->Full) &&
                IsListEmpty(&Control->Empty) &&
                IsListEmpty(&Control->Idled)
               )
               ||
               (Control != Queue &&
                   (!IsListEmpty(&Control->Full) ||
                    !IsListEmpty(&Control->Empty) ||
                    !IsListEmpty(&Control->Idled) ||
                    Control->IsRunDown
                   )
               )
              )
*/

    FRS_ASSERT(DbgCheckQueue(Queue));

    Queue->IsRunDown = TRUE;

    //
    // return the list of entries
    //
    if (IsListEmpty(&Queue->ListHead)) {
        InitializeListHead(ListHead);
    } else {
        *ListHead = Queue->ListHead;
        ListHead->Flink->Blink = ListHead;
        ListHead->Blink->Flink = ListHead;
    }
    InitializeListHead(&Queue->ListHead);
    //
    // Don't update counters if the queue is idled
    //
    if (!Queue->IsIdled) {
        Control->ControlCount -= Queue->Count;
        if (Control->ControlCount == 0) {
            ResetEvent(Control->Event);
        }
    }
    Queue->Count = 0;
    RemoveEntryListB(&Queue->Full);
    RemoveEntryListB(&Queue->Empty);
    RemoveEntryListB(&Queue->Idled);
    FRS_ASSERT(DbgCheckQueue(Queue));

    //
    // Set the aborted event to awaken any threads currently
    // blocked on the queue if the controlling queue has no
    // more queues.
    //
    DPRINT2(4, "Rundown for queue - %08x,  Control - %08x\n", Queue, Control);
    DPRINT1(4, "Control->Full queue %s empty.\n",
            IsListEmpty(&Control->Full) ? "is" : "is not");

    DPRINT1(4, "Control->Empty queue %s empty.\n",
            IsListEmpty(&Control->Empty) ? "is" : "is not");

    DPRINT1(4, "Control->Idled queue %s empty.\n",
            IsListEmpty(&Control->Idled) ? "is" : "is not");


    if (IsListEmpty(&Control->Full)  &&
        IsListEmpty(&Control->Empty) &&
        IsListEmpty(&Control->Idled)) {
        Control->IsRunDown = TRUE;
        SetEvent(Control->RunDown);
        DPRINT(4, "Setting Control->RunDown event.\n");
    }

    FRS_ASSERT(DbgCheckQueue(Control));
    LeaveCriticalSection(&Control->Lock);
}


VOID
FrsRtlCancelQueue(
    IN PFRS_QUEUE   Queue,
    OUT PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Returns the entries on Queue for cancelling.

Arguments:

    Queue - supplies the queue to be rundown
    ListHead - returns the list of items currently in the queue.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlCancelQueue:"

    PFRS_QUEUE  Control = Queue->Control;
    PLIST_ENTRY Entry;
    PLIST_ENTRY First;
    PLIST_ENTRY Last;

    EnterCriticalSection(&Control->Lock);

    FRS_ASSERT(DbgCheckQueue(Queue));
    //
    // return the list of entries
    //
    if (IsListEmpty(&Queue->ListHead)) {
        InitializeListHead(ListHead);
    } else {
        *ListHead = Queue->ListHead;
        ListHead->Flink->Blink = ListHead;
        ListHead->Blink->Flink = ListHead;
    }
    InitializeListHead(&Queue->ListHead);
    //
    // Don't update counters if the queue is idled
    //
    if (!Queue->IsIdled) {
        Control->ControlCount -= Queue->Count;
        if (Control->ControlCount == 0) {
            ResetEvent(Control->Event);
        }
    }
    Queue->Count = 0;

    RemoveEntryListB(&Queue->Full);
    RemoveEntryListB(&Queue->Empty);
    RemoveEntryListB(&Queue->Idled);

    FRS_ASSERT(DbgCheckQueue(Queue));
    FRS_ASSERT(DbgCheckQueue(Control));

    LeaveCriticalSection(&Control->Lock);
}



VOID
FrsRtlIdleQueue(
    IN PFRS_QUEUE Queue
    )
{
#undef DEBSUB
#define DEBSUB  "FrsRtlIdleQueue:"

/*++

Routine Description:

    Idle a queue

Arguments:

    Queue - queue to idle

Return Value:
    None.

--*/

    PFRS_QUEUE  Control = Queue->Control;

    //
    // Queues that don't have a separate controlling queue can't
    // support "idling" themselves
    //
    if (Control == Queue) {
        return;
    }

    //
    // Lock the controlling queue
    //
    EnterCriticalSection(&Control->Lock);

    FrsRtlIdleQueueLock(Queue);

    LeaveCriticalSection(&Control->Lock);
}




VOID
FrsRtlIdleQueueLock(
    IN PFRS_QUEUE Queue
    )
{
#undef DEBSUB
#define DEBSUB  "FrsRtlIdleQueueLock:"

/*++

Routine Description:

    Idle a queue.  Caller has the lock already.

Arguments:

    Queue - queue to idle

Return Value:
    None.

--*/

    PFRS_QUEUE  Control = Queue->Control;

    //
    // Queues that don't have a separate controlling queue can't
    // support "idling" themselves
    //
    if (Control == Queue) {
        return;
    }
    PRINT_QUEUE(5, Queue);

    FRS_ASSERT(DbgCheckQueue(Queue));

    //
    // Stop, this queue has been aborted (rundown)
    //
    if (Queue->IsRunDown || Queue->IsIdled) {
        goto out;
    }

    if (Queue->Count == 0) {
        RemoveEntryListB(&Queue->Empty);
    } else {
        RemoveEntryListB(&Queue->Full);
    }

    FRS_ASSERT(IsListEmpty(&Queue->Idled));

    InsertTailList(&Control->Idled, &Queue->Idled);
    Queue->IsIdled = TRUE;
    Control->ControlCount -= Queue->Count;

    FRS_ASSERT(DbgCheckQueue(Queue));

    if (Control->ControlCount == 0) {
        ResetEvent(Control->Event);
    }
out:
    //
    // Done
    //
    FRS_ASSERT(DbgCheckQueue(Queue));
}




VOID
FrsRtlUnIdledQueue(
    IN PFRS_QUEUE   IdledQueue
    )
{
#undef DEBSUB
#define DEBSUB  "FrsRtlUnIdledQueue:"

/*++

Routine Description:

    Removes the queue from the "idled" list and puts it back on the
    full or empty lists. The controlling queue is updated accordingly.

Arguments:

    IdledQueue - Supplies the queue to remove an item from.

Return Value:
    None.

--*/

    DWORD       OldControlCount;
    PFRS_QUEUE  Control = IdledQueue->Control;

    //
    // Queues that don't have a separate controlling queue can't
    // support "idling" themselves
    //
    if (Control == IdledQueue) {
        return;
    }

    //
    // Lock the controlling queue
    //
    EnterCriticalSection(&Control->Lock);

    FrsRtlUnIdledQueueLock(IdledQueue);

    LeaveCriticalSection(&Control->Lock);
}



VOID
FrsRtlUnIdledQueueLock(
    IN PFRS_QUEUE   IdledQueue
    )
{
#undef DEBSUB
#define DEBSUB  "FrsRtlUnIdledQueueLock:"

/*++

Routine Description:

    Removes the queue from the "idled" list and puts it back on the
    full or empty lists. The controlling queue is updated accordingly.

    Caller has lock on controlling queue.

Arguments:

    IdledQueue - Supplies the queue to remove an item from.

Return Value:
    None.

--*/

    DWORD       OldControlCount;
    PFRS_QUEUE  Control = IdledQueue->Control;

    //
    // Queues that don't have a separate controlling queue can't
    // support "idling" themselves
    //
    if (Control == IdledQueue) {
        return;
    }

    PRINT_QUEUE(5, IdledQueue);

    FRS_ASSERT(DbgCheckQueue(IdledQueue));

    //
    // Stop, this queue has been aborted (rundown)
    //
    if (IdledQueue->IsRunDown) {
        goto out;
    }

    //
    // Remove from idled list
    //
    FRS_ASSERT(IdledQueue->IsIdled);
    RemoveEntryListB(&IdledQueue->Idled);
    IdledQueue->IsIdled = FALSE;

    //
    // Put onto full or empty list
    //
    if (IdledQueue->Count) {
        InsertTailList(&Control->Full, &IdledQueue->Full);
    } else {
        InsertTailList(&Control->Empty, &IdledQueue->Empty);
    }

    //
    // Wakeup sleepers if count is now > 0
    //
    OldControlCount = Control->ControlCount;
    Control->ControlCount += IdledQueue->Count;
    if (Control->ControlCount && OldControlCount == 0) {
        SetEvent(Control->Event);
    }

    //
    // Done
    //
out:
    FRS_ASSERT(DbgCheckQueue(IdledQueue));
}


PLIST_ENTRY
FrsRtlRemoveHeadQueueTimeoutIdled(
    IN PFRS_QUEUE   Queue,
    IN DWORD        dwMilliseconds,
    OUT PFRS_QUEUE  *IdledQueue
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Timeout - Supplies a timeout value that specifies the relative
        time, in milliseconds, over which the wait is to be completed.

    IdledQueue - If non-NULL then on return this will be the address
        of the queue from which the entry was retrieved. Or NULL if
        the returned entry is NULL. No other thread will be allowed
        to pull an entry from the returned queue until that queue is
        released with FrsRtlUnIdledQueue(*IdledQueue).

Return Value:

    Pointer to list entry removed from the head of the queue.

    NULL if the wait times out or the queue is run down. If this
        routine returns NULL, GetLastError will return either
        ERROR_INVALID_HANDLE (if the queue has been rundown) or
        WAIT_TIMEOUT (to indicate a timeout has occurred)

    IdledQueue - If non-NULL then on return this will be the address
        of the queue from which the entry was retrieved. Or NULL if
        the returned entry is NULL. No other thread will be allowed
        to pull an entry from the returned queue until that queue is
        released with FrsRtlUnIdledQueue(*IdledQueue).

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlRemoveHeadQueueTimeoutIdled:"

    DWORD       Status;
    PLIST_ENTRY Entry;
    HANDLE      WaitArray[2];
    PFRS_QUEUE  Control = Queue->Control;

    //
    // No idled queue at this time
    //
    if (IdledQueue) {
        *IdledQueue = NULL;
    }

Retry:
    if (Control->ControlCount == 0) {
        //
        // Block until something is inserted on the queue
        //
        WaitArray[0] = Control->RunDown;
        WaitArray[1] = Control->Event;
        Status = WaitForMultipleObjects(2, WaitArray, FALSE, dwMilliseconds);
        if (Status == 0) {
            //
            // The queue has been rundown, return NULL immediately.
            //
            SetLastError(ERROR_INVALID_HANDLE);
            return(NULL);
        } else if (Status == WAIT_TIMEOUT) {
            SetLastError(WAIT_TIMEOUT);
            return(NULL);
        }
        FRS_ASSERT(Status == 1);
    }

    //
    // Lock the queue and try to remove something
    //
    EnterCriticalSection(&Control->Lock);

    PRINT_QUEUE(5, Queue);

    if (Control->ControlCount == 0) {
        //
        // Somebody got here before we did, drop the lock and retry
        //
        LeaveCriticalSection(&Control->Lock);
        goto Retry;
    }
    FRS_ASSERT(DbgCheckQueue(Queue));

    Entry = GetListNext(&Control->Full);
    RemoveEntryListB(Entry);
    Queue = CONTAINING_RECORD(Entry, FRS_QUEUE, Full);
    Entry = RemoveHeadList(&Queue->ListHead);

    //
    // update counters
    //
    --Queue->Count;
    --Control->ControlCount;

    //
    // A separate controlling queue is required for idling
    //
    if (IdledQueue && Queue != Control) {
        //
        // Idle the queue
        //
        FRS_ASSERT(IsListEmpty(&Queue->Idled));
        FRS_ASSERT(!Queue->IsIdled);
        InsertTailList(&Control->Idled, &Queue->Idled);
        Queue->IsIdled = TRUE;
        Control->ControlCount -= Queue->Count;
        *IdledQueue = Queue;
    } else if (Queue->Count) {
        //
        // Queue still has entries
        //
        InsertTailList(&Control->Full, &Queue->Full);
    } else {
        //
        // Queue is empty
        //
        InsertTailList(&Control->Empty, &Queue->Empty);
    }

    //
    // Queues are empty (or idled)
    //
    if (Control->ControlCount == 0) {
        ResetEvent(Control->Event);
    }

    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    LeaveCriticalSection(&Control->Lock);

    return(Entry);
}


PLIST_ENTRY
FrsRtlRemoveHeadQueue(
    IN PFRS_QUEUE Queue
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

Return Value:

    Pointer to list entry removed from the head of the queue.

--*/

{
    return(FrsRtlRemoveHeadQueueTimeoutIdled(Queue, INFINITE, NULL));
}


PLIST_ENTRY
FrsRtlRemoveHeadQueueTimeout(
    IN PFRS_QUEUE Queue,
    IN DWORD dwMilliseconds
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Timeout - Supplies a timeout value that specifies the relative
        time, in milliseconds, over which the wait is to be completed.

Return Value:

    Pointer to list entry removed from the head of the queue.

    NULL if the wait times out or the queue is run down. If this
        routine returns NULL, GetLastError will return either
        ERROR_INVALID_HANDLE (if the queue has been rundown) or
        WAIT_TIMEOUT (to indicate a timeout has occurred)


--*/

{
    return(FrsRtlRemoveHeadQueueTimeoutIdled(Queue, dwMilliseconds, NULL));
}



VOID
FrsRtlRemoveEntryQueue(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes the entry from the queue. The entry is assumed to be on the
    queue since we derement the queue count.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Entry - pointer to the entry to remove.

Return Value:

    none.

--*/

{
    FrsRtlAcquireQueueLock(Queue);
    FrsRtlRemoveEntryQueueLock(Queue, Entry);
    FrsRtlReleaseQueueLock(Queue);
}


VOID
FrsRtlRemoveEntryQueueLock(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes the entry from the queue. The entry is assumed to be on the
    queue since we derement the queue count.  We also assume the caller
    has acquired the queue lock since this was needed to scan the queue
    in the first place to find the entry in question.

    The LOCK suffix means the caller has already acquired the lock.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Entry - pointer to the entry to remove.

Return Value:

    none.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlRemoveEntryQueueLock:"

    PFRS_QUEUE  Control = Queue->Control;

    FRS_ASSERT(Queue->Count != 0);
    FRS_ASSERT(!IsListEmpty(&Queue->ListHead));

    PRINT_QUEUE(5, Queue);

    FRS_ASSERT(DbgCheckQueue(Queue));

    RemoveEntryListB(Entry);

    //
    // If the queue is idled then just update the count
    //
    --Queue->Count;
    if (!Queue->IsIdled) {
        //
        // Queue is empty; remove from full list
        //
        if (Queue->Count == 0) {
            RemoveEntryListB(&Queue->Full);
            InsertTailList(&Control->Empty, &Queue->Empty);
        }
        //
        // Control queue is empty
        //
        if (--Control->ControlCount == 0) {
            ResetEvent(Control->Event);
        }
    }

    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));

    return;
}


DWORD
FrsRtlInsertTailQueue(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    )
/*++
Routine Description:
    Inserts a new entry on the tail of the queue.

Arguments:
    Queue - Supplies the queue to add the entry to.
    Item - Supplies the entry to be added to the queue.

Return Value:
    ERROR_SUCCESS and the item is queueed. Otherwise, the item
    is not queued.
--*/
{
    DWORD   Status;

    FrsRtlAcquireQueueLock(Queue);
    Status = FrsRtlInsertTailQueueLock(Queue, Item);
    FrsRtlReleaseQueueLock(Queue);
    return Status;
}

DWORD
FrsRtlInsertTailQueueLock(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    )
/*++
Routine Description:
    Inserts a new entry on the tail of the queue.  Caller already has the
    queue lock.

Arguments:
    Queue - Supplies the queue to add the entry to.
    Item - Supplies the entry to be added to the queue.

Return Value:
    ERROR_SUCCESS and the item is queueed. Otherwise, the item
    is not queued.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlInsertTailQueueLock:"

    PFRS_QUEUE  Control = Queue->Control;

    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    if (Queue->IsRunDown) {
        return ERROR_ACCESS_DENIED;
    }
    InsertTailList(&Queue->ListHead, Item);

    //
    // If the queue is idled then just update the count
    //
    if (Queue->IsIdled) {
        ++Queue->Count;
    } else {
        //
        // Queue is transitioning from empty to full
        //
        if (++Queue->Count == 1) {
            RemoveEntryListB(&Queue->Empty);
            InsertTailList(&Control->Full, &Queue->Full);
        }
        //
        // Controlling queue is transitioning from empty to full
        //
        if (++Control->ControlCount == 1) {
            SetEvent(Control->Event);
        }
    }
    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    return ERROR_SUCCESS;
}


DWORD
FrsRtlInsertHeadQueue(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    )
/*++
Routine Description:
    Inserts a new entry on the tail of the queue.

Arguments:
    Queue - Supplies the queue to add the entry to.
    Item - Supplies the entry to be added to the queue.

Return Value:
    ERROR_SUCCESS and the item is queueed. Otherwise, the item
    is not queued.
--*/
{
    DWORD   Status;

    FrsRtlAcquireQueueLock(Queue);
    Status = FrsRtlInsertHeadQueueLock(Queue, Item);
    FrsRtlReleaseQueueLock(Queue);
    return Status;
}


DWORD
FrsRtlInsertHeadQueueLock(
    IN PFRS_QUEUE Queue,
    IN PLIST_ENTRY Item
    )
/*++
Routine Description:
    Inserts a new entry on the head of the queue.
    Caller already has the queue lock.

Arguments:
    Queue - Supplies the queue to add the entry to.
    Item - Supplies the entry to be added to the queue.

Return Value:
    ERROR_SUCCESS and the item is queueed. Otherwise, the item
    is not queued.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlInsertHeadQueueLock:"

    PFRS_QUEUE  Control = Queue->Control;

    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    if (Queue->IsRunDown) {
        return ERROR_ACCESS_DENIED;
    }
    InsertHeadList(&Queue->ListHead, Item);

    //
    // If the queue is idled then just update the count
    //
    if (Queue->IsIdled) {
        ++Queue->Count;
    } else {
        //
        // Queue is transitioning from empty to full
        //
        if (++Queue->Count == 1) {
            RemoveEntryListB(&Queue->Empty);
            InsertTailList(&Control->Full, &Queue->Full);
        }
        //
        // Controlling queue is transitioning from empty to full
        //
        if (++Control->ControlCount == 1) {
            SetEvent(Control->Event);
        }
    }
    PRINT_QUEUE(5, Queue);
    FRS_ASSERT(DbgCheckQueue(Queue));
    return ERROR_SUCCESS;
}


DWORD
FrsRtlWaitForQueueFull(
    IN PFRS_QUEUE Queue,
    IN DWORD dwMilliseconds
    )
/*++
Routine Description:
    Waits until the queue is non-empty.  Returns immediately if queue is
    non-empty else wait on insert or timeout.

Arguments:
    Queue - Supplies the queue to wait on.
    Timeout - Supplies a timeout value that specifies the relative
        time, in milliseconds, over which the wait is to be completed.

Return Value:
    Win32 Status:
        ERROR_SUCCESS if queue is now non-empty.
        ERROR_INVALID_HANDLE if the queue has been rundown.
        WAIT_TIMEOUT to indicate a timeout has occurred.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsRtlWaitForQueueFull:"

    DWORD Status;
    HANDLE WaitArray[2];
    PFRS_QUEUE Control = Queue->Control;

Retry:
    if (Control->ControlCount == 0) {
        //
        // Block until something is inserted on the queue
        //
        WaitArray[0] = Control->RunDown;
        WaitArray[1] = Control->Event;
        Status = WaitForMultipleObjects(2, WaitArray, FALSE, dwMilliseconds);

        if (Status == 0) {
            //
            // The queue has been rundown, return immediately.
            //
            return(ERROR_INVALID_HANDLE);
        }

        if (Status == WAIT_TIMEOUT) {
            return(WAIT_TIMEOUT);
        }

        FRS_ASSERT(Status == 1);
    }

    //
    // Lock the queue and check again.
    //
    EnterCriticalSection(&Control->Lock);
    if (Control->ControlCount == 0) {
        //
        // Somebody got here before we did, drop the lock and retry
        //
        LeaveCriticalSection(&Control->Lock);
        goto Retry;
    }

    LeaveCriticalSection(&Control->Lock);

    return(ERROR_SUCCESS);
}


VOID
FrsSubmitCommand(
    IN PCOMMAND_PACKET  CmdPkt,
    IN BOOL             Headwise
    )
/*++
Routine Description:
    Insert the command packet on the command's target queue.
    If the time delay parameter is non-zero the command is instead
    queued to the scheduler thread to initiate at the specified time.
    FrsCompleteCommand(Status) is called if the packet could not be
    queued.

Arguments:
    CmdPkt
    Headwise    - Queue at the head (high priority)

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSubmitCommand:"

    DWORD           WStatus;

    //
    // Queue to the target
    //
    if (Headwise) {
        WStatus = FrsRtlInsertHeadQueue(CmdPkt->TargetQueue, &CmdPkt->ListEntry);
    } else {
        WStatus = FrsRtlInsertTailQueue(CmdPkt->TargetQueue, &CmdPkt->ListEntry);
    }

    if (!WIN_SUCCESS(WStatus)) {
        FrsCompleteCommand(CmdPkt, WStatus);
    }
}


ULONG
FrsSubmitCommandAndWait(
    IN PCOMMAND_PACKET  Cmd,
    IN BOOL             Headwise,
    IN ULONG            Timeout
    )
/*++
Routine Description:
    Create or Reset the event, Submit the command and wait for the return.

Arguments:
    Cmd - command packet to queue
    Timeout - Wait Timeout
    Headwise - if True, insert to head.

Return Value:
    Win32 status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSubmitCommandAndWait:"

    DWORD WStatus;

    //
    // Set the synchronous flag in the command packet.
    //
    FrsSetCommandSynchronous(Cmd);

    if (!HANDLE_IS_VALID(Cmd->WaitEvent)){
        Cmd->WaitEvent = FrsCreateEvent(TRUE, FALSE);
    } else {
        ResetEvent(Cmd->WaitEvent);
    }

    //
    // Save the callers completion routine and replace it with a function
    // that signals the event.  It does not delete the packet so we can
    // return the command status to the caller.
    //
    Cmd->SavedCompletionRoutine = Cmd->CompletionRoutine;
    Cmd->CompletionRoutine = FrsCompleteSynchronousCmdPkt;

    //
    // Queue the command and create a thread if needed.
    //
    FrsSubmitCommand(Cmd, Headwise);

    //
    // Wait for the command to complete.
    //
    WStatus = WaitForSingleObject(Cmd->WaitEvent, Timeout);

    CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);

    //
    // Return the command error status.
    //
    WStatus = Cmd->ErrorStatus;

    //
    // Restore and call the caller's completion routine.  This may free the
    // the packet.  We don't call FrsCompleteCommand() here because it was
    // already called when the server finished the packet and there is no
    // point in setting the wait event twice.
    //
    Cmd->CompletionRoutine = Cmd->SavedCompletionRoutine;

    FRS_ASSERT(Cmd->CompletionRoutine != NULL);

    (Cmd->CompletionRoutine)(Cmd, Cmd->CompletionArg);

    return WStatus;

}


#define HEADWISE    TRUE
VOID
FrsUnSubmitCommand(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Put the entry back on the head of the queue.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
    FrsSubmitCommand(Cmd, HEADWISE);
}


VOID
FrsCompleteCommand(
    IN PCOMMAND_PACKET CmdPkt,
    IN DWORD           ErrorStatus
    )
/*++
Routine Description:
     Retire the command packet based on what the original requestor specified
     in the packet.  The ErrorStatus is returned in the packet.

     The completion routine is called for clean up and propagation.

Arguments:
    CmdPkt  -- A ptr to the command packet.
    ErrorStatus -- Status to store in returned command packet.

Return Value:
    None.
--*/
{
    //
    // Set the error status and call the completion routine
    //
    CmdPkt->ErrorStatus = ErrorStatus;

    FRS_ASSERT(CmdPkt->CompletionRoutine != NULL);

    (CmdPkt->CompletionRoutine)(CmdPkt, CmdPkt->CompletionArg);
}


VOID
FrsInitializeCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN DWORD            MaxThreads,
    IN PWCHAR           Name,
    IN DWORD            (*Main)(PVOID)
    )
/*++
Routine Description:
    Initialize a command server

Arguments:
    Cs          - command server
    MaxThreads  - Max # of threads to kick off
    Name        - Printable name for thread
    Main        - Thread starts here

Return Value:
    None.
--*/
{
    ZeroMemory(Cs, sizeof(COMMAND_SERVER));
    FrsInitializeQueue(&Cs->Control, &Cs->Control);
    FrsInitializeQueue(&Cs->Queue, &Cs->Control);
    Cs->Main = Main;
    Cs->Name = Name;
    Cs->MaxThreads = MaxThreads;
    Cs->Idle = FrsCreateEvent(TRUE, TRUE);
}


VOID
FrsDeleteCommandServer(
    IN PCOMMAND_SERVER  Cs
    )
/*++
Routine Description:
    Undo the work of FrsInitializeCommandServer(). This function
    assumes the queue and its control queue are inactive (whatever
    that means). Queues and command servers are normally only
    deleted at the very end of MainFrsShutDown() when all other threads
    have exited and the RPC servers aren't listening for new requests.

    The caller is responsible for handling all of the other queues
    that may be being controlled by the control queue in the command
    server struct, Cs.

Arguments:
    Cs          - command server

Return Value:
    None.
--*/
{
    if (Cs) {
        FrsRtlDeleteQueue(&Cs->Queue);
        FrsRtlDeleteQueue(&Cs->Control);
        ZeroMemory(Cs, sizeof(COMMAND_SERVER));
    }
}


PCOMMAND_PACKET
FrsAllocCommand(
    IN PFRS_QUEUE   TargetQueue,
    IN USHORT       Command
    )
/*++
Routine Description:
     Allocate a command packet and initialize the most common fields.

Arguments:
    TargetQueue
    Command

Return Value:
    Address of allocated, initialized COMMAND_PACKET. Call
    FrsCompleteCommand() when done.

--*/
{
    PCOMMAND_PACKET Cmd;

    Cmd = FrsAllocType(COMMAND_PACKET_TYPE);
    Cmd->TargetQueue = TargetQueue;
    FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
    Cmd->Command = Command;

    return Cmd;
}


PCOMMAND_PACKET
FrsAllocCommandEx(
    IN PFRS_QUEUE   TargetQueue,
    IN USHORT       Command,
    IN ULONG        Size
    )
/*++
Routine Description:
     Allocate a command packet with some extra space
     and initialize the most common fields.

Arguments:
    TargetQueue
    Command

Return Value:
    Address of allocated, initialized COMMAND_PACKET. Call
    FrsCompleteCommand() when done.

--*/
{
    PCOMMAND_PACKET Cmd;

    Cmd = FrsAllocTypeSize(COMMAND_PACKET_TYPE, Size);
    Cmd->TargetQueue = TargetQueue;
    Cmd->CompletionRoutine = FrsFreeCommand;
    Cmd->Command = Command;



    return Cmd;
}


VOID
FrsFreeCommand(
    IN PCOMMAND_PACKET  Cmd,
    IN PVOID            CompletionArg
    )
/*++
Routine Description:
     Free a command packet

Arguments:
    Cmd - command packet allocated with FrsAllocCommand().

Return Value:
    NULL
--*/
{
    ULONG                   WStatus;

    if (((Cmd->Flags & CMD_PKT_FLAGS_SYNC) != 0) &&
         (HANDLE_IS_VALID(Cmd->WaitEvent))){

        //
        // Close the event handle.  The command complete function should have
        // already set the event.
        //
        if (!CloseHandle(Cmd->WaitEvent)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "ERROR: Close event handle failed", WStatus);
            // Don't free the packet if the close handle failed.
            return;
        }
        Cmd->WaitEvent = NULL;
    }

    FrsFreeType(Cmd);
}


VOID
FrsExitCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_THREAD      FrsThread
    )
/*++
Routine Description:
    Exit the calling command server thread.

Arguments:
    Cs      - command server
    Thread  - calling thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsExitCommandServer:"

    PFRS_QUEUE  Queue = &Cs->Queue;

    //
    // If there is work to be done
    //
    FrsRtlAcquireQueueLock(Queue);
    --Cs->FrsThreads;
    if (FrsRtlCountQueue(Queue) && Cs->Waiters == 0 && Cs->FrsThreads == 0) {
        //
        // and no one to do it; don't exit
        //
        ++Cs->FrsThreads;
        FrsRtlReleaseQueueLock(Queue);
        return;
    }
    //
    // Set the idle event if all threads are waiting, there are no entries
    // on the queue, and there are no idled queues
    //
    if (Cs->Waiters == Cs->FrsThreads) {
        if (FrsRtlCountQueue(&Cs->Queue) == 0) {
            if (FrsRtlNoIdledQueues(&Cs->Queue)) {
                SetEvent(Cs->Idle);
            }
        }
    }
    FrsRtlReleaseQueueLock(Queue);
    //
    // The thread command server (ThQs) will "wait" on this thread's exit
    // and drop the reference on its thread struct.
    //
    ThSupSubmitThreadExitCleanup(FrsThread);

    //
    // Exit
    //
    ExitThread(ERROR_SUCCESS);
}


#define TAILWISE    FALSE
VOID
FrsSubmitCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    If needed, create a thread for the command queue

Arguments:
    Cs  - command server

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSubmitCommandServer:"
    //
    // Enqueue the command and make sure there are threads running
    //
    FRS_ASSERT(Cmd && Cmd->TargetQueue && Cs &&
               Cmd->TargetQueue->Control == &Cs->Control);
    FrsSubmitCommand(Cmd, TAILWISE);
    FrsKickCommandServer(Cs);
}


ULONG
FrsSubmitCommandServerAndWait(
    IN PCOMMAND_SERVER  Cs,
    IN PCOMMAND_PACKET  Cmd,
    IN ULONG            Timeout
    )
/*++
Routine Description:
    Create or Reset the event, Submit the command and wait for the return.
    If needed, create a thread for the command queue.

Arguments:
    Cs  - command server
    Cmd - command packet to queue
    Timeout - Wait Timeout

Return Value:
    Win32 status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSubmitCommandServerAndWait:"
    DWORD WStatus;

    //
    // Enqueue the command and make sure there are threads running
    //
    FRS_ASSERT(Cmd && Cmd->TargetQueue && Cs &&
               Cmd->TargetQueue->Control == &Cs->Control);

    //
    // Set the synchronous flag in the command packet.
    //
    FrsSetCommandSynchronous(Cmd);

    if (!HANDLE_IS_VALID(Cmd->WaitEvent)){
        Cmd->WaitEvent = FrsCreateEvent(TRUE, FALSE);
    } else {
        ResetEvent(Cmd->WaitEvent);
    }

    //
    // Save the callers completion routine and replace it with a function
    // that signals the event.  It does not delete the packet so we can
    // return the command status to the caller.
    //
    Cmd->SavedCompletionRoutine = Cmd->CompletionRoutine;
    Cmd->CompletionRoutine = FrsCompleteSynchronousCmdPkt;

    //
    // Queue the command and create a thread if needed.
    //
    FrsSubmitCommand(Cmd, TAILWISE);
    FrsKickCommandServer(Cs);

    //
    // Wait for the command to complete.
    //
    WStatus = WaitForSingleObject(Cmd->WaitEvent, Timeout);

    CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);

    //
    // Return the command error status.
    //
    WStatus = Cmd->ErrorStatus;

    //
    // Restore and call the caller's completion routine.  This may free the
    // the packet.  We don't call FrsCompleteCommand() here because it was
    // already called when the server finished the packet and there is no
    // point in setting the wait event twice.
    //
    Cmd->CompletionRoutine = Cmd->SavedCompletionRoutine;

    FRS_ASSERT(Cmd->CompletionRoutine != NULL);

    (Cmd->CompletionRoutine)(Cmd, Cmd->CompletionArg);

    return WStatus;

}



#define THREAD_CREATE_RETRY (10 * 1000) // 10 seconds
VOID
FrsKickCommandServer(
    IN PCOMMAND_SERVER  Cs
    )
/*++
Routine Description:
    If needed, create a thread for the command queue

Arguments:
    Cs  - command server

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsKickCommandServer:"

    PFRS_QUEUE  Queue   = &Cs->Queue;

    //
    // Kick off more threads if no one is waiting for this command
    // and the number of threads serving this command queue is less
    // than the maximum.
    //
    // If the thread cannot be created and there are no threads
    // processing the command queue then put this command on the
    // delayed queue and try again later
    //
    FrsRtlAcquireQueueLock(Queue);
    //
    // There are entries on the queue
    //
    if (FrsRtlCountQueue(Queue)) {
        //
        // But there are no threads to process the entries
        //
        if (Cs->Waiters == 0 && Cs->FrsThreads < Cs->MaxThreads) {
            //
            // First thread; reset idle
            //
            if (Cs->FrsThreads == 0) {
                ResetEvent(Cs->Idle);
            }
            if (ThSupCreateThread(Cs->Name, Cs, Cs->Main, ThSupExitThreadNOP)) {
                //
                // Created a new thread
                //
                ++Cs->FrsThreads;
            } else if (Cs->FrsThreads == 0) {
                //
                // Thread could not be created and there are no other
                // threads to process this entry. Put it on the delayed
                // queue and try again in a few seconds.
                //
                FrsDelCsSubmitKick(Cs, &Cs->Queue, THREAD_CREATE_RETRY);
            }
        }
    }
    FrsRtlReleaseQueueLock(Queue);
}


PCOMMAND_PACKET
FrsGetCommandIdled(
    IN PFRS_QUEUE   Queue,
    IN DWORD        MilliSeconds,
    IN PFRS_QUEUE   *IdledQueue
    )
/*++
Routine Description:
    Get the next command from the queue; idling the queue if requested.

Arguments:
    Queue
    MilliSeconds
    IdledQueue

Return Value:
    COMMAND_PACKET or NULL.
    If non-NULL, IdledQueue is set
--*/
{
    PLIST_ENTRY Entry;

    Entry = FrsRtlRemoveHeadQueueTimeoutIdled(Queue, MilliSeconds, IdledQueue);
    if (Entry == NULL) {
        return NULL;
    }
    //
    // Return the command packet
    //
    return CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
}


PCOMMAND_PACKET
FrsGetCommand(
    IN PFRS_QUEUE   Queue,
    IN DWORD        MilliSeconds
    )
/*++
Routine Description:
    Get the next command from the queue.

Arguments:
    Queue
    MilliSeconds

Return Value:
    COMMAND_PACKET or NULL.
--*/
{
    return FrsGetCommandIdled(Queue, MilliSeconds, NULL);
}


PCOMMAND_PACKET
FrsGetCommandServerTimeoutIdled(
    IN  PCOMMAND_SERVER  Cs,
    IN  ULONG            Timeout,
    OUT PFRS_QUEUE       *IdledQueue,
    OUT PBOOL            IsRunDown
    )
/*++
Routine Description:
    Get the next command from the queue for the command server.
    If nothing appears on the queue in the specified time, then
    return NULL and set IsRunDown.

Arguments:
    Cs          - command server
    Timeout
    IdledQueue  - Idled queue
    IsRunDown

Return Value:
    COMMAND_PACKET or NULL. If NULL, IsRunDown indicates whether
    the NULL was caused by a rundown queue or a simple timeout.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsGetCommandServerTimeoutIdled:"

    PCOMMAND_PACKET Cmd;

    //
    // Pull off the next entry (wait at most 5 minutes)
    //
    FrsRtlAcquireQueueLock(&Cs->Queue);
    ++Cs->Waiters;
    //
    // Set the idle event if all threads are waiting, there are no entries
    // on the queue, and there are no idled queues
    //
    if (Cs->Waiters == Cs->FrsThreads) {
        if (FrsRtlCountQueue(&Cs->Queue) == 0) {
            if (FrsRtlNoIdledQueues(&Cs->Queue)) {
                SetEvent(Cs->Idle);
            }
        }
    }
    FrsRtlReleaseQueueLock(&Cs->Queue);
    //
    // Get the next command
    //
    Cmd = FrsGetCommandIdled(&Cs->Control, Timeout, IdledQueue);

    FrsRtlAcquireQueueLock(&Cs->Queue);
    //
    // Reset the Idle event if there is any chance it might have been set
    //
    if (Cs->Waiters == Cs->FrsThreads) {
        ResetEvent(Cs->Idle);
    }
    --Cs->Waiters;
    if (IsRunDown) {
        *IsRunDown = Cs->Queue.IsRunDown;
    }
    FrsRtlReleaseQueueLock(&Cs->Queue);
    return Cmd;
}


#define COMMAND_SERVER_TIMEOUT  (5 * 60 * 1000) // 5 minutes
DWORD   FrsCommandServerTimeout = COMMAND_SERVER_TIMEOUT;

PCOMMAND_PACKET
FrsGetCommandServerIdled(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_QUEUE       *IdledQueue
    )
/*++
Routine Description:
    Get the next command from the queue. If nothing appears on the queue
    for 5 minutes, return NULL. The caller will exit. Idle the queue.

Arguments:
    Cs          - command server
    IdledQueue  - Idled queue

Return Value:
    COMMAND_PACKET or NULL. Caller should exit on NULL.
    If non-NULL, IdledQueue is set
--*/
{
    return FrsGetCommandServerTimeoutIdled(Cs,
                                           FrsCommandServerTimeout,
                                           IdledQueue,
                                           NULL);
}


PCOMMAND_PACKET
FrsGetCommandServerTimeout(
    IN  PCOMMAND_SERVER  Cs,
    IN  ULONG            Timeout,
    OUT PBOOL            IsRunDown
    )
/*++
Routine Description:
    Get the next command from the queue. If nothing appears on the queue
    in the specified timeout, return NULL and an indication of the
    queue's rundown status.

Arguments:
    Cs          - command server
    Timeout
    IsRunDown

Return Value:
    COMMAND_PACKET or NULL. IsRunDown is only valid if COMMAND_PACKET
    is NULL. Use IsRunDown to check if the NULL return is because of
    a rundown'ed queue or simply a timeout.
--*/
{
    return FrsGetCommandServerTimeoutIdled(Cs, Timeout, NULL, IsRunDown);
}


DWORD
FrsWaitForCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN DWORD            MilliSeconds
    )
/*++
Routine Description:
    Wait until all of the threads are idle, there are no entries on the
    queue, and there are no idled queues.

Arguments:
    Cs              - command server
    MilliSeconds    - Timeout

Return Value:
    Status from WaitForSingleObject()
--*/
{
    return WaitForSingleObject(Cs->Idle, MilliSeconds);
}


PCOMMAND_PACKET
FrsGetCommandServer(
    IN PCOMMAND_SERVER  Cs
    )
/*++
Routine Description:
    Get the next command from the queue. If nothing appears on the queue
    for 5 minutes, return NULL. The caller will exit.

Arguments:
    Cs  - command server

Return Value:
    COMMAND_PACKET or NULL. Caller should exit on NULL.
--*/
{
    //
    // Pull off the next entry (wait at most 5 minutes)
    //
    return FrsGetCommandServerIdled(Cs, NULL);
}


VOID
FrsRunDownCommand(
    IN PFRS_QUEUE Queue
    )
/*++
Routine Description:
    Rundown a queue of command packets

Arguments:
    Queue   - queue to rundown

Return Value:
    None.
--*/
{
    LIST_ENTRY      RunDown;
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;

    if (!Queue) {
        return;
    }

    //
    // RunDown the queue and retrieve the current entries
    //
    FrsRtlRunDownQueue(Queue, &RunDown);

    //
    // Free up the commands
    //
    while (!IsListEmpty(&RunDown)) {
        Entry = RemoveHeadList(&RunDown);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        FrsCompleteCommand(Cmd, ERROR_ACCESS_DENIED);
    }
}


VOID
FrsRunDownCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_QUEUE       Queue
    )
/*++
Routine Description:
    Rundown a queue of a command server

Arguments:
    Cs      - command server
    Queue   - queue to abort

Return Value:
    None.
--*/
{
    FrsRunDownCommand(Queue);
}


VOID
FrsCancelCommandServer(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_QUEUE       Queue
    )
/*++
Routine Description:
    Cancels the current commands on Queue.

Arguments:
    Cs      - command server
    Queue   - queue to abort

Return Value:
    None.
--*/
{
    LIST_ENTRY      Cancel;
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;

    //
    // RunDown the queue and retrieve the current entries
    //
    FrsRtlCancelQueue(Queue, &Cancel);

    //
    // Free up the commands
    //
    while (!IsListEmpty(&Cancel)) {
        Entry = RemoveHeadList(&Cancel);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        FrsCompleteCommand(Cmd, ERROR_CANCELLED);
    }
}



VOID
FrsCompleteRequestCount(
    IN PCOMMAND_PACKET CmdPkt,
    IN PFRS_REQUEST_COUNT RequestCount
    )
/*++

Routine Description:

     This is an Frs Command packet completion routine that takes
     an FRS_REQUEST_COUNT struct.  It decrements the count and signals
     the event when the count goes to zero. The ErrorStatus is
     merged into the Status field of the request count struct.

     It then frees the command packet.

Arguments:

    CmdPkt  -- A ptr to the command packet.
    RequestCount - Supplies a pointer to a RequestCount structure to initialize

Return Value:

    None.
--*/
{
    //
    // Decrement count and signal waiter.  merge error status from packet
    // into RequestCount->Status.
    //
    FrsDecrementRequestCount(RequestCount, CmdPkt->ErrorStatus);
    FrsSetCompletionRoutine(CmdPkt, FrsFreeCommand, NULL);
    FrsCompleteCommand(CmdPkt, CmdPkt->ErrorStatus);
}



VOID
FrsCompleteRequestCountKeepPkt(
    IN PCOMMAND_PACKET CmdPkt,
    IN PFRS_REQUEST_COUNT RequestCount
    )
/*++

Routine Description:

     This is an Frs Command packet completion routine that takes
     an FRS_REQUEST_COUNT struct.  It decrements the count and signals
     the event when the count goes to zero. The ErrorStatus is
     merged into the Status field of the request count struct.

     It does not free the command packet so the caller can retreive results
     or reuse it.

Arguments:

    CmdPkt  -- A ptr to the command packet.
    RequestCount - Supplies a pointer to a RequestCount structure to initialize

Return Value:

    None.
--*/
{
    // Decrement count and signal waiter.  merge error status from packet
    // into RequestCount->Status.
    //
    FrsDecrementRequestCount(RequestCount, CmdPkt->ErrorStatus);
}


VOID
FrsCompleteKeepPkt(
    IN PCOMMAND_PACKET CmdPkt,
    IN PVOID           CompletionArg
    )
/*++

Routine Description:

     This is an Frs Command packet completion routine that
     leaves the CmdPkt alone so the caller can reuse it.

Arguments:

    CmdPkt  -- A ptr to the command packet.
    CompletionArg - Unused.

Return Value:

    None.
--*/
{
    return;
}


VOID
FrsCompleteSynchronousCmdPkt(
    IN PCOMMAND_PACKET CmdPkt,
    IN PVOID           CompletionArg
    )
/*++

Routine Description:

     This is an Frs Command packet completion routine that
     Signals the Wait Event for a synchronous cmd request.
     It leaves the CmdPkt alone so the caller can reuse it.

Arguments:

    CmdPkt  -- A ptr to the command packet.
    CompletionArg - Unused.

Return Value:

    None.
--*/
{

    FRS_ASSERT(HANDLE_IS_VALID(CmdPkt->WaitEvent));

    SetEvent(CmdPkt->WaitEvent);
    //
    // A ctx switch to the waiter could occur at this point.  The waiter could
    // free the packet.  So no further refs to the packet are allowed.
    //
    return;
}



VOID
FrsInitializeRequestCount(
    IN PFRS_REQUEST_COUNT RequestCount
    )
/*++

Routine Description:

    Initializes a RequestCount for use.

Arguments:

    RequestCount - Supplies a pointer to a RequestCount structure to initialize

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/
{
    ULONG Status;

    RequestCount->Count = 0;
    RequestCount->Status = 0;

    INITIALIZE_CRITICAL_SECTION(&RequestCount->Lock);

    RequestCount->Event = FrsCreateEvent(TRUE, FALSE);
}


VOID
FrsDeleteRequestCount(
    IN PFRS_REQUEST_COUNT RequestCount
    )
/*++

Routine Description:

    Releases resources used by a RequestCount.

Arguments:

    RequestCount - Supplies a pointer to a RequestCount structure to delete

Return Value:

    None.

--*/
{
    ULONG WStatus;

    if (RequestCount != NULL) {
        if (HANDLE_IS_VALID(RequestCount->Event)) {
            if (!CloseHandle(RequestCount->Event)) {
                WStatus = GetLastError();
                DPRINT_WS(0, "ERROR: Close event handle failed", WStatus);
                DeleteCriticalSection(&RequestCount->Lock);
                return;
            }

            DeleteCriticalSection(&RequestCount->Lock);
        }
        //
        // Zero memory to catch errors.
        //
        ZeroMemory(RequestCount, sizeof(FRS_REQUEST_COUNT));
    }
}



ULONG
FrsWaitOnRequestCount(
    IN PFRS_REQUEST_COUNT RequestCount,
    IN ULONG Timeout
    )
{
    DWORD WStatus;

Retry:

    if (RequestCount->Count > 0) {

        WStatus = WaitForSingleObject(RequestCount->Event, Timeout);

        CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);
    }

    //
    // Lock the queue and check again.
    //
    EnterCriticalSection(&RequestCount->Lock);
    if (RequestCount->Count > 0) {
        //
        // Somebody got here before we did, drop the lock and retry
        //
        LeaveCriticalSection(&RequestCount->Lock);
        goto Retry;
    }

    LeaveCriticalSection(&RequestCount->Lock);

    return(ERROR_SUCCESS);

}




DWORD
FrsRtlInitializeList(
    PFRS_LIST List
    )
/*++

Routine Description:

    Initializes an interlocked list for use.

Arguments:

    List - Supplies a pointer to an FRS_LIST structure to initialize

Return Value:

    ERROR_SUCCESS if successful

--*/

{
    DWORD Status;

    InitializeListHead(&List->ListHead);
    INITIALIZE_CRITICAL_SECTION(&List->Lock);
    List->Count = 0;
    List->ControlCount = 0;
    List->Control = List;

    return(ERROR_SUCCESS);

}



VOID
FrsRtlDeleteList(
    PFRS_LIST List
    )
/*++

Routine Description:

    Releases all resources used by an interlocked list.

Arguments:

    List - supplies the List to be deleted

Return Value:

    None.

--*/

{

    DeleteCriticalSection(&List->Lock);

    //
    // Zero the memory in order to cause grief to people who try
    // and use a deleted list.
    //
    ZeroMemory(List, sizeof(FRS_LIST));
}



PLIST_ENTRY
FrsRtlRemoveHeadList(
    IN PFRS_LIST List
    )
/*++

Routine Description:

    Removes the item at the head of the interlocked list.

Arguments:

    List - Supplies the list to remove an item from.

Return Value:

    Pointer to list entry removed from the head of the list.

    NULL if the list is empty.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlRemoveHeadList:"

    PLIST_ENTRY Entry;
    PFRS_LIST Control = List->Control;

    if (List->ControlCount == 0) {
        return NULL;
    }

    //
    // Lock the list and try to remove something
    //
    EnterCriticalSection(&Control->Lock);
    if (Control->ControlCount == 0) {
        //
        // Somebody got here before we did, drop the lock and return null
        //
        LeaveCriticalSection(&Control->Lock);
        return NULL;
    }

    FRS_ASSERT(!IsListEmpty(&List->ListHead));
    Entry = RemoveHeadList(&List->ListHead);

    //
    // Decrement count.
    //
    List->Count--;
    Control->ControlCount--;

    LeaveCriticalSection(&Control->Lock);

    return(Entry);
}



VOID
FrsRtlInsertHeadList(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Inserts the item at the head of the interlocked list.

Arguments:

    List - Supplies the list to insert the item on.

    Entry - The entry to insert.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    //
    // Lock the list and insert at head.
    //
    EnterCriticalSection(&Control->Lock);
    FrsRtlInsertHeadListLock(List, Entry);
    LeaveCriticalSection(&Control->Lock);

    return;
}

PLIST_ENTRY
FrsRtlRemoveTailList(
    IN PFRS_LIST List
    )
/*++

Routine Description:

    Removes the item at the tail of the interlocked list.

Arguments:

    List - Supplies the list to remove an item from.

Return Value:

    Pointer to list entry removed from the tail of the list.

    NULL if the list is empty.

--*/

{
#undef DEBSUB
#define DEBSUB  "FrsRtlRemoveTailList:"

    PLIST_ENTRY Entry;
    PFRS_LIST Control = List->Control;

    if (Control->ControlCount == 0) {
        return NULL;
    }

    //
    // Lock the list and try to remove something
    //
    EnterCriticalSection(&Control->Lock);
    if (Control->ControlCount == 0) {
        //
        // Somebody got here before we did, drop the lock and return null
        //
        LeaveCriticalSection(&Control->Lock);
        return NULL;
    }

    FRS_ASSERT(!IsListEmpty(&List->ListHead));
    Entry = RemoveTailList(&List->ListHead);

    //
    // Decrement count.
    //
    List->Count--;
    Control->ControlCount--;

    LeaveCriticalSection(&Control->Lock);

    return(Entry);
}


VOID
FrsRtlInsertTailList(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Inserts the item at the tail of the interlocked list.

Arguments:

    List - Supplies the list to insert the item on.

    Entry - The entry to insert.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    //
    // Lock the list and insert at tail.
    //
    EnterCriticalSection(&Control->Lock);
    FrsRtlInsertTailListLock(List, Entry);
    LeaveCriticalSection(&Control->Lock);

    return;
}


VOID
FrsRtlRemoveEntryList(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes the entry from the interlocked list.  The entry must be on the
    given list since we use the lock in the FRS_LIST to synchronize access.

Arguments:

    List - Supplies the list to remove an item from.

    Entry - The entry to remove.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    //
    // Lock the list and try to remove entry
    //
    EnterCriticalSection(&Control->Lock);
    FrsRtlRemoveEntryListLock(List, Entry);
    LeaveCriticalSection(&Control->Lock);

    return;
}


VOID
FrsRtlRemoveEntryListLock(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes the entry from the interlocked list.  The entry must be on the
    given list.

    The caller already has the list lock.

Arguments:

    List - Supplies the list to remove an item from.

    Entry - The entry to remove.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    //
    // List better not be empty.
    //
    FRS_ASSERT(!IsListEmpty(&List->ListHead));
    RemoveEntryListB(Entry);

    //
    // Decrement count.
    //
    List->Count--;
    Control->ControlCount--;

    return;
}


VOID
FrsRtlInsertHeadListLock(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Inserts the item at the head of the interlocked list.
    The caller has acquired the lock.

Arguments:

    List - Supplies the list to insert the item on.

    Entry - The entry to insert.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    InsertHeadList(&List->ListHead, Entry);

    List->Count++;
    Control->ControlCount++;

    return;
}


VOID
FrsRtlInsertTailListLock(
    IN PFRS_LIST List,
    IN PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Inserts the item at the tail of the interlocked list.
    The caller has acquired the lock.

Arguments:

    List - Supplies the list to insert the item on.

    Entry - The entry to insert.

Return Value:

    None.

--*/

{
    PFRS_LIST Control = List->Control;

    InsertTailList(&List->ListHead, Entry);

    List->Count++;
    Control->ControlCount++;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\writer\writer.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:
    writer.h

Abstract:
    Implementation file for FRS writer

Author:
    Reuven Lax     17-Sep-2002
    
--*/

#include "writer.h"

CFrsWriter* CFrsWriter::m_pWriterInstance = NULL;

DWORD InitializeFrsWriter()
/*++
Routine Description:
    This routine is called by the FRS service to initialize the writer.    

Return Value:
    DWORD
--*/
{
    #undef DEBSUB
    #define DEBSUB  "InitializeFrsWriter:"

    DPRINT(4, "Initializing the FRS Writer\n");

    // initialize COM
    HRESULT hr = S_OK;
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))     {
        DPRINT1(1, "CoInitializeEx failed with hresult 0x%08lx\n", hr);
        return HRESULT_CODE(hr);
    }

    // create the writer
    hr = CFrsWriter::CreateWriter();
    if (FAILED(hr))     
        DPRINT1(1, "CFrsWriter::CreateWriter failed with hresult 0x%08lx\n", hr);

    CoUninitialize();
    return HRESULT_CODE(hr);
}


void ShutDownFrsWriter()
/*++
Routine Description:
    This routine is called by the FRS service to shutdown the writer.    
--*/
{
    #undef DEBSUB
    #define DEBSUB  "ShutDownFrsWriter:"

    DPRINT(4, "Shutting down the FRS writer\n");

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))     
        DPRINT1(1, "CoInitializeEx failed with hresult 0x%08lx\n", hr);

    CFrsWriter::DestroyWriter();

    if (SUCCEEDED(hr))
        CoUninitialize();
}

bool STDMETHODCALLTYPE CFrsWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
/*++
Routine Description:
    This routine is called in response to an Identify event being sent to this writer.  The writer
    is responsible for reporting on all of its metadata in this routine.
    
Arguments:
    pMetadata     - Interface used to report on metadata

Return Value:
    boolean
--*/
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::OnIdentify:"
    
    DPRINT(4, "Writer received OnIdentify event\n");
    
    HRESULT hr = S_OK;

    // set the restore method
    hr = pMetadata->SetRestoreMethod(VSS_RME_CUSTOM,        // method
                                                            NULL,                             // wszService
                                                            NULL,                             // wszUserProcedure
                                                            VSS_WRE_NEVER,        // writerRestore
                                                            false                             // bRebootRequired
                                                            );
    if (FAILED(hr)) {
        DPRINT1(1, "IVssCreateWriterMetadata::SetRestoreMethod failed with hresult 0x%08lx\n", hr);
        return false;
    }

    // initialize FRS backup API
    DWORD winStatus = 0;    
    void* context = NULL;
    winStatus = ::NtFrsApiInitializeBackupRestore(NULL, 
                                        NTFRSAPI_BUR_FLAGS_BACKUP | NTFRSAPI_BUR_FLAGS_NORMAL,
                                        &context);
    if (!WIN_SUCCESS(winStatus))    {
        DPRINT1(1, "NtFrsApiInitializeBackupRestore failed with status 0x%08lx\n", winStatus);
        return false;
    }
    FRS_ASSERT(context != NULL);

    // stick the backup context into an auto object to ensure that it's always destroyed
    CAutoFrsBackupRestore autoContext(context);
    
    // get an enumeration for all the replica sets
    winStatus = ::NtFrsApiGetBackupRestoreSets(autoContext.m_context);
    if (!WIN_SUCCESS(winStatus))    {
        DPRINT1(1, "NtFrsApiGetBackupRestoreSets failed with status 0x%08lx\n", winStatus);
        return false;
    }

   // process each replica set
    DWORD index = 0;
    void* replicaSet = NULL;
    winStatus = ::NtFrsApiEnumBackupRestoreSets(autoContext.m_context, index, &replicaSet);    
    while (WIN_SUCCESS(winStatus))  {
        FRS_ASSERT(replicaSet != NULL);
        
        // each replica set reports the same excludes.  only add them once.
        CAutoFrsPointer<WCHAR> filters = NULL;
        if (!ProcessReplicaSet(autoContext.m_context, replicaSet, pMetadata, filters.GetAddress()))
            return false;
        if (filters != NULL && index == 0)  {
            if (!AddExcludes(pMetadata, filters))   {
                DPRINT(1, "failed to add filtered exclude files\n");
                return false;
            }
        }

        
        ++index;
        winStatus = ::NtFrsApiEnumBackupRestoreSets(autoContext.m_context, index, &replicaSet);            
    }

    if (winStatus != ERROR_NO_MORE_ITEMS)   {
        DPRINT1(1, "NtFrsApiEnumBackupRestoreSets failed with status 0x%08lx\n", winStatus);
        return false;        
    }

    return true;
}

bool CFrsWriter::AddExcludes(IVssCreateWriterMetadata* pMetadata, WCHAR* filters)
/*++
Routine Description:
  This is a helper routine used by ProcessReplicaSet to create the exclude-file list.    
Arguments:
    pMetadata     - Interface used to report on metadata
    filters            - list of exclude files
Return Value:
    boolean
--*/
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::AddExcludes:"
    
    WCHAR* currentFilter = filters;
    // for each filtered filespec, add an exclude specification to the writer metadata
    while (*currentFilter)    {
        WCHAR* path = NULL;
        WCHAR* filespec = NULL;
        bool recursive = false;

        size_t excludeLength = wcslen(currentFilter); // --- grab size before we modify the string
        
        if (!ParseExclude(currentFilter, &path, &filespec, &recursive))   {
            DPRINT(1, "filtered exclude file has an incorrect format\n");
            return false;
        }
        
        HRESULT hr = pMetadata->AddExcludeFiles(path, filespec, recursive);
        if (FAILED(hr)) {
            DPRINT1(1, "IVssBackupComponents::AddExcludeFiles failed with hresult 0x%08lx\n", hr);
            return false;
        }
        
        currentFilter += excludeLength + 1;
    }

    return true;
}

bool CFrsWriter::ParseExclude(WCHAR* exclude, WCHAR** path, WCHAR** filespec, bool* recursive)
/*++
Routine Description:
  This is a helper routine used to parse an exclude specification.
Arguments:
    exclude     - the specification for the exclude file
    path          -OUT  the root path of the exclude file
    filespec     - OUT the exclude filespec
    recursive   - OUT whether this is a recursive specification or not

Return Value:
    boolean
--*/
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::ParseExclude:"
    
    const WCHAR* RecursionSpec = L" /s";
    const WCHAR DirSeperator = L'\\';

    //verify parameters
    FRS_ASSERT(exclude && path && filespec && recursive);
    *path = *filespec = NULL;
    *recursive = false;

    // find the last wack in the path
    WCHAR* loc = wcsrchr(exclude, DirSeperator);
    if (loc == NULL)
        return false;

    // setup the return values
    *loc = L'\0';
    *path = exclude;
    *filespec = loc + 1;

    // check to see if this is a recursive specification
    loc = wcsstr(*filespec, RecursionSpec);
    if (loc != NULL)    {
        *loc = L'\0';
        *recursive = true;
    }

    return (wcslen(*path) > 0) && (wcslen(*filespec) > 0);
}

bool CFrsWriter::ProcessReplicaSet(void* context, void* replicaSet, IVssCreateWriterMetadata* pMetadata, WCHAR** retFilters)
/*++
Routine Description:
  This is a helper routine used by OnIdentify to create the writer metadata.
Arguments:
    context         -  The context that identifies us to FRS.
    replicaSet     -  The indentifier for the current replica set  
    pMetadata     - Interface used to report on metadata
    filters          - return the list of filtered files

Return Value:
    boolean
--*/
{   
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::ProcessReplicaSet:"

    FRS_ASSERT(retFilters);
    *retFilters = NULL;

    // constants that determine component names
    const WCHAR* SysvolLogicalPath = L"SYSVOL";
    
    DWORD winStatus = 0;

    // all of these need to be defined here, since otherwise destructors don't get called when
    // and SEH exception is thrown
    CAutoFrsPointer<WCHAR> setType;
    DWORD typeSize = 0;

    CAutoFrsPointer<WCHAR> setGuid;
    DWORD guidSize = 0;
    
    CAutoFrsPointer<WCHAR> directory;
    DWORD dirSize = 0;
    
    CAutoFrsPointer<WCHAR> paths;
    DWORD pathSize = 0;

    CAutoFrsPointer<WCHAR> filters;
    DWORD filterSize = 0;

    __try   {
        // figure out what type of replica set this is
        winStatus = ::NtFrsApiGetBackupRestoreSetType(context, replicaSet, NULL, &typeSize);
        FRS_ASSERT(winStatus == ERROR_MORE_DATA);

        setType = (WCHAR*)::FrsAlloc(typeSize);
        
        winStatus = ::NtFrsApiGetBackupRestoreSetType(context, replicaSet, setType, &typeSize);
        if (!WIN_SUCCESS(winStatus))    {
            DPRINT1(1, "NtFrsApiGetBackupRestoreSetType failed with status 0x%08lx\n", winStatus);
            return false;
        }

        // figure out what the name of this replica set is
        winStatus = ::NtFrsApiGetBackupRestoreSetGuid(context, replicaSet, NULL, &guidSize);
        FRS_ASSERT(winStatus == ERROR_MORE_DATA);

        setGuid = (WCHAR*)::FrsAlloc(guidSize);
    
        winStatus = ::NtFrsApiGetBackupRestoreSetGuid(context, replicaSet, setGuid, &guidSize);
        if (!WIN_SUCCESS(winStatus))    {
            DPRINT1(1, "NtFrsApiGetBackupRestoreSetGuid failed with status 0x%08lx\n", winStatus);
            return false;
        }
    
        const WCHAR* logicalPath = NULL;

        HRESULT hr = S_OK;    
        if (wcscmp(setType, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE) == 0 ||
             wcscmp(setType, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN) == 0) {
            // if this is a SYSVOL replica set, add a component with the SYSVOL logical path
            logicalPath = SysvolLogicalPath;
            hr = pMetadata->AddComponent(VSS_CT_FILEGROUP,                // type
                                                              logicalPath,                               // wszLogicalPath
                                                              setGuid,                                   // wszComponentName
                                                              NULL,                                       // wszCaption
                                                              NULL,                                       // pbIcon
                                                              0,                                            // cbIcon
                                                              false,                                       // bRestoreMetadata
                                                              true,                                       // bNotifyOnBackupComplete
                                                              true,                                       // bSelectable
                                                              true                                        // bSelectableForRestore
                                                              );
            if (FAILED(hr)) {
                DPRINT1(1, "IVssCreateWriterMetadata::AddComponent failed with hresult 0x%08lx\n", hr);
                return false;
            }
        }   else    {
            // otherwise, add a component a component with the generic logical path
            logicalPath = setType;
            hr = pMetadata->AddComponent(VSS_CT_FILEGROUP,                // type
                                                              logicalPath,                               // wszLogicalPath
                                                              setGuid,                                  // wszComponentName
                                                              NULL,                                       // wszCaption
                                                              NULL,                                       // pbIcon
                                                              0,                                            // cbIcon
                                                              false,                                       // bRestoreMetadata
                                                              true,                                       // bNotifyOnBackupComplete
                                                              true,                                       // bSelectable
                                                              true                                        // bSelectableForRestore
                                                              );
            if (FAILED(hr)) {
                DPRINT1(1, "IVssCreateWriterMetadata::AddComponent failed with hresult 0x%08lx\n", hr);
                return false;
            }

            // add the root replication directory to the filegroup.  This isn't necessary for SYSVOL since
            // that will be included in the call to NtFrsApiGetBackupRestoreSetPaths.
            winStatus = ::NtFrsApiGetBackupRestoreSetDirectory(context, replicaSet, &dirSize, NULL);
            FRS_ASSERT(winStatus == ERROR_INSUFFICIENT_BUFFER);

            directory = (WCHAR*)::FrsAlloc(dirSize);

            // I assume that the directory cannot change in this short windows.  If so, we must loop.
            winStatus = ::NtFrsApiGetBackupRestoreSetDirectory(context, replicaSet, &dirSize, directory);
            if (!WIN_SUCCESS(winStatus))    {
                DPRINT1(1, "NtFrsApiGetBackupRestoreSetDirectory failed with status 0x%08lx\n", winStatus);            
                return false;
            }

            hr = pMetadata->AddFilesToFileGroup(logicalPath,                // wszLogicalPath
                                                                    setGuid,                     // wszGroupName
                                                                    directory,                  // wszPath
                                                                    L"*",                         // wszFilespec
                                                                    true,                         // bRecursive
                                                                    NULL                        // wszAlternateLocation
                                                                    );
            if (FAILED(hr)) {
                DPRINT1(1, "IVssCreateWriterMetadata::AddFilesToFileGroup failed with hresult  0x%08lx\n", hr);
                return false;
            }
        }

        winStatus = ::NtFrsApiGetBackupRestoreSetPaths(context, 
                                                                                replicaSet, 
                                                                                &pathSize, 
                                                                                NULL, 
                                                                                &filterSize, 
                                                                                NULL
                                                                                );
        FRS_ASSERT(winStatus == ERROR_INSUFFICIENT_BUFFER);

        paths = (WCHAR*)::FrsAlloc(pathSize);
        filters = (WCHAR*)::FrsAlloc(filterSize);

        // once again, I assume that the sizes won't change in this window
        winStatus = ::NtFrsApiGetBackupRestoreSetPaths(context, 
                                                                                replicaSet, 
                                                                                &pathSize, 
                                                                                paths, 
                                                                                &filterSize, 
                                                                                filters
                                                                                );    
        if (!WIN_SUCCESS(winStatus))    {
                DPRINT1(1, "NtFrsApiGetBackupRestoreSetPaths failed with status 0x%08lx\n", winStatus);            
                return false;
        }

        // add all of the paths to the group
        WCHAR* currentPath = paths;
        while (*currentPath)    {
            hr = pMetadata->AddFilesToFileGroup(logicalPath,                // wszLogicalPath
                                                                      setGuid,                    // wszGroupName
                                                                      currentPath,               // wszPath
                                                                      L"*",                         // wszFilespec
                                                                      true,                         // bRecursive
                                                                      NULL                        // wszAlternateLocation
                                                                      );
            if (FAILED(hr)) {
                DPRINT1(1, "IVssCreateWriterMetadata::AddFilesToFileGroup failed with hresult  0x%08lx\n", hr);
                return false;
            }
            
            currentPath += wcslen(currentPath) + 1;
        }
        
        *retFilters = filters.Detach();
        return true;
        }   __except(GetExceptionCode() == ERROR_OUTOFMEMORY)   {
            DPRINT(1, "Out of memory\n");
            return false;
        }
}

bool STDMETHODCALLTYPE CFrsWriter::OnPrepareSnapshot()
/*++
Routine Description:
    This routine is called in response to an Identify event being sent to this writer.  The writer
    will freeze FRS in this event.
Arguments:

Return Value:
    boolean
--*/
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::OnPrepareSnapshot:"
    
    DPRINT(4, "Received OnPrepareSnapshot event\n");
    
    DWORD winStatus = ::FrsFreezeForBackup();
    if (!WIN_SUCCESS(winStatus))    {
        DPRINT1(1, "FrsFreezeForBackup failed with status 0x%08lx\n", winStatus);
        CVssWriter::SetWriterFailure(VSS_E_WRITERERROR_RETRYABLE);
        
        return false;
    }

    return true;
}   

bool STDMETHODCALLTYPE CFrsWriter::OnFreeze()
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::OnFreeze:"
    
    DPRINT(4, "Received OnFreeze event\n");

    return true;
}

bool STDMETHODCALLTYPE CFrsWriter::OnThaw()
/*++
Routine Description:
    This routine is called in response to a Thaw event being sent to this writer.  The writer
    will thaw FRS in this event.
Arguments:

Return Value:
    boolean
--*/
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::OnThaw:"

    DPRINT(4, "Received OnThaw event\n");
    
    DWORD winStatus = ::FrsThawAfterBackup();
    if (!WIN_SUCCESS(winStatus))    {
        DPRINT1(1, "FrsThawAfterBackup failed with status 0x%08lx\n", winStatus);
        CVssWriter::SetWriterFailure(VSS_E_WRITERERROR_RETRYABLE);
        
        return false;
    }

    return true;
}

bool STDMETHODCALLTYPE CFrsWriter::OnAbort()
/*++
Routine Description:
    This routine is called in response to an Abort event being sent to this writer.  The writer
    will thaw FRS in this event.
Arguments:

Return Value:
    boolean
--*/
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::OnAbort:"

    DPRINT(4, "Received OnAbort event\n");

    DWORD winStatus = ::FrsThawAfterBackup();
    if (!WIN_SUCCESS(winStatus))    {
        DPRINT1(1, "FrsThawAfterBackup failed with status 0x%08lx\n", winStatus);
        return false;
    }

    return true;
}


HRESULT CFrsWriter::CreateWriter()
/*++
Routine Description:
  This routine is called to create and initialize the FRS writer.  It must be called from
  a thread that has COM initialized with multi-threaded apartments.
Arguments:

Return Value:
    HRESULT
--*/
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::CreateWriter:"

    // initialization is idempotent    
    if (m_pWriterInstance != NULL)  
        return S_OK;

    // try and create the writer
    m_pWriterInstance = new CFrsWriter();
    if (m_pWriterInstance == NULL)
        return E_OUTOFMEMORY;

    // try and initialize the writer
    HRESULT hr = S_OK;        
    hr = m_pWriterInstance->Initialize();
    if (FAILED(hr)) {
        delete m_pWriterInstance;
        m_pWriterInstance = NULL;
    }

    return hr;
}


void CFrsWriter::DestroyWriter()
/*++
Routine Description:
  This routine is called to destroy the FRS writer.
Arguments:

Return Value:
    HRESULT
--*/
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::DestroyWriter:"

    delete m_pWriterInstance;
    m_pWriterInstance = NULL;
}

HRESULT STDMETHODCALLTYPE CFrsWriter::Initialize()
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::Initialize:"

    HRESULT hr = S_OK;

    hr = CVssWriter::Initialize(WriterId,                                           // WriterID
                                           WriterName,                                     // wszWriterName
                                           VSS_UT_BOOTABLESYSTEMSTATE,    // usage type
                                           VSS_ST_OTHER,                              // source type
                                           VSS_APP_SYSTEM                           // nLevel
                                           );
    if (FAILED(hr)) {
        DPRINT1(1, "CVssWriter::Initialize failed with hresult 0x%08lx\n", hr);
        return hr;
    }
    
    hr = CVssWriter::Subscribe();
    if (FAILED(hr)) 
        DPRINT1(1, "CVssWriter::Subscribe failed with hresult 0x%08lx\n", hr);

    return hr;    
}

void CFrsWriter::Uninitialize()
{
    #undef DEBSUB
    #define DEBSUB  "CFrsWriter::Uninitialize:"

    HRESULT hr = CVssWriter::Unsubscribe();
    if (FAILED(hr)) 
        DPRINT1(1, "CVssWriter::Unsubscribe failed with hresult 0x%08lx\n", hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\util\waittime.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    waittime.c

Abstract:
    A timeout list is managed by a thread waiting on a
    waitable timer.

    The timer can be adjusted without context switching to the
    thread that is waiting on the timer.

    An entry can be pulled off the list. The timer is adjusted
    if the entry was at the head of the queue.

    The queue is sorted by timeout value. The timeout value is
    an absolute filetime.

    The list entry is a command packet. The generic command
    packet contains a field for the wait time in milliseconds.
    This code takes the wait time and converts it into an
    absolute filetime when the command packet is put on the
    queue. The timeout triggers when the time is equal to or
    greater than the command packet's filetime.

Author:
    Billy J. Fuller 21-Feb-1998

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>

//
// Struct for the Delayed Command Server
//      Contains info about the queues and the threads
//
//
// The wait thread exits if nothing shows up in 5 minutes.
//
#define WAIT_EXIT_TIMEOUT               (5 * 60 * 1000) // 5 minutes

//
// A command packet times out if the current time is within
// 1 second of the requested timeout value (avoids precision
// problems with the waitable timer).
//
#define WAIT_FUZZY_TIMEOUT              (1 * 1000 * 1000 * 10)

//
// When creating the wait thread, retry 10 times with a one
// second sleep in between retries
//
#define WAIT_RETRY_CREATE_THREAD_COUNT  (10)        // retry 10 times
#define WAIT_RETRY_TIMEOUT              (1 * 1000)  // 1 second

//
// The thread is running (or not). Exit after 5 minutes of idleness.
// Recreate on demand.
//
DWORD       WaitIsRunning;

//
// List of timeout commands
//
CRITICAL_SECTION    WaitLock;
CRITICAL_SECTION    WaitUnsubmitLock;
LIST_ENTRY          WaitList;

//
// Waitable timer. The thread waits on the timer and the queue's rundown event.
//
HANDLE      WaitableTimer;

//
// Current timeout trigger in WaitableTimer
//
LONGLONG    WaitFileTime;

//
// Set when the wait list is rundown
//
HANDLE      WaitRunDown;
BOOL        WaitIsRunDown;


VOID
WaitStartThread(
    VOID
    )
/*++
Routine Description:
    Start the wait thread if it isn't running. The timer has been
    set by the caller. The caller holds the WaitLock.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitStartThread:"
    DWORD       Retries;
    DWORD       MainWait(PVOID Arg);

    //
    // Caller holds WaitLock
    //

    //
    // Thread is running; done
    //
    if (WaitIsRunning) {
        return;
    }
    //
    // Queue is rundown; don't start
    //
    if (WaitIsRunDown) {
        DPRINT(4, "Don't start wait thread; queue is rundown.\n");
        return;
    }
    //
    // Queue is empty; don't start
    //
    if (IsListEmpty(&WaitList)) {
        DPRINT(4, "Don't start wait thread; queue is empty.\n");
        return;
    }

    //
    // Start the wait thread. Retry several times.
    //
    if (!WaitIsRunning) {
        Retries = WAIT_RETRY_CREATE_THREAD_COUNT;
        while (!WaitIsRunning && Retries--) {
            WaitIsRunning = ThSupCreateThread(L"Wait", &WaitList, MainWait, ThSupExitWithTombstone);
            if (!WaitIsRunning) {
                DPRINT(0, "WARN: Wait thread could not be started; retry later.\n");
                Sleep(1 * 1000);
            }
        }
    }
    //
    // Can't start the wait thread. Something is very wrong. Shutdown.
    //
    if (!WaitIsRunning) {
        FrsIsShuttingDown = TRUE;
        SetEvent(ShutDownEvent);
        return;
    }
}

VOID
WaitReset(
    IN BOOL ResetTimer
    )
/*++
Routine Description:
    Complete the command packets that have timed out. Reset the timer.

    Caller holds WaitLock.

Arguments:
    ResetTimer  - reset timer always

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitReset:"
    PCOMMAND_PACKET Cmd;
    PLIST_ENTRY     Entry;
    LONGLONG        Now;
    BOOL            StartThread = FALSE;

    //
    // Entries are sorted by absolute timeout
    //
    if (IsListEmpty(&WaitList)) {
        //
        // Allow the thread to exit in 5 minutes if no work shows up
        //
        if (WaitIsRunning) {
            FrsNowAsFileTime(&Now);
            WaitFileTime = Now + ((LONGLONG)WAIT_EXIT_TIMEOUT * 1000 * 10);
            ResetTimer = TRUE;
        }
    } else {
        StartThread = TRUE;
        Entry = GetListNext(&WaitList);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        //
        // Reset timeout
        //
        if ((Cmd->WaitFileTime != WaitFileTime) || ResetTimer) {
            WaitFileTime = Cmd->WaitFileTime;
            ResetTimer = TRUE;
        }
    }
    //
    // Reset the timer
    //
    if (ResetTimer) {
        DPRINT1(4, "Resetting timer to %08x %08x.\n", PRINTQUAD(WaitFileTime));

        if (!SetWaitableTimer(WaitableTimer, (LARGE_INTEGER *)&WaitFileTime, 0, NULL, NULL, TRUE)) {
            DPRINT_WS(0, "ERROR - Resetting timer;", GetLastError());
        }
    }
    //
    // Make sure the thread is running
    //
    if (StartThread && !WaitIsRunning) {
        WaitStartThread();
    }
}


VOID
WaitUnsubmit(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Pull the command packet off of the timeout queue and adjust
    the timer. NOP if the command packet is not on the command queue.

Arguments:
    Cmd - command packet to pull off the queue

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitUnsubmit:"
    BOOL    Reset = FALSE;

    //
    // Defensive
    //
    if (Cmd == NULL) {
        return;
    }

    DPRINT5(4, "UnSubmit cmd %08x (%08x) for timeout (%08x) in %d ms (%08x)\n",
            Cmd->Command, Cmd, Cmd->TimeoutCommand, Cmd->Timeout, Cmd->WaitFlags);

    EnterCriticalSection(&WaitLock);
    EnterCriticalSection(&WaitUnsubmitLock);

    //
    // Entries are sorted by absolute timeout
    //
    if (CmdWaitFlagIs(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST)) {
        RemoveEntryListB(&Cmd->ListEntry);
        ClearCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
        Reset = TRUE;
    }
    LeaveCriticalSection(&WaitUnsubmitLock);
    //
    // Reset the timer if the expiration time has changed
    //
    if (Reset) {
        WaitReset(FALSE);
    }
    LeaveCriticalSection(&WaitLock);
}


VOID
WaitProcessCommand(
    IN PCOMMAND_PACKET  Cmd,
    IN DWORD            ErrorStatus
    )
/*++
Routine Description:
    Process the timed out command packet. The timeout values are
    unaffected.

Arguments:
    Cmd         - command packet that timed out or errored out
    ErrorStatus - ERROR_SUCCESS if timed out

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitProcessCommand:"

    DPRINT5(4, "Process cmd %08x (%08x) for timeout (%08x) in %d ms (%08x)\n",
            Cmd->Command, Cmd, Cmd->TimeoutCommand, Cmd->Timeout, Cmd->WaitFlags);

    switch (Cmd->TimeoutCommand) {
        //
        // Submit a command
        //
        case CMD_DELAYED_SUBMIT:
            FrsSubmitCommand(Cmd, FALSE);
            break;

        //
        // Run the command packet's completion routine
        //
        case CMD_DELAYED_COMPLETE:
            FrsCompleteCommand(Cmd, ErrorStatus);
            break;

        //
        // Unknown command
        //
        default:
            DPRINT1(0, "ERROR - Wait: Unknown command 0x%x.\n", Cmd->TimeoutCommand);
            FRS_ASSERT(!"invalid comm timeout command stuck on list");
            FrsCompleteCommand(Cmd, ERROR_INVALID_FUNCTION);
            break;
    }
}


DWORD
WaitSubmit(
    IN PCOMMAND_PACKET  Cmd,
    IN DWORD            Timeout,
    IN USHORT           TimeoutCommand
    )
/*++
Routine Description:
    Insert the new command packet into the sorted, timeout list

    Restart the thread if needed.

    The Cmd may already be on the timeout list. If so, simply
    adjust its timeout.

Arguments:
    Cmd             - Command packet to timeout
    Timeout         - Timeout in milliseconds from now
    TimeoutCommand  - Disposition at timeout

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitSubmit:"
    PLIST_ENTRY     Entry;
    LONGLONG        Now;
    PCOMMAND_PACKET OldCmd;
    DWORD           WStatus = ERROR_SUCCESS;

    //
    // Defensive
    //
    if (Cmd == NULL) {
        return ERROR_SUCCESS;
    }

    //
    // Setup the command packet with timeout and wait specific info
    //      We acquire the lock now just in case the command
    //      is already on the list.
    //
    EnterCriticalSection(&WaitLock);

    Cmd->Timeout = Timeout;
    Cmd->TimeoutCommand = TimeoutCommand;
    FrsNowAsFileTime(&Now);
    Cmd->WaitFileTime = Now + ((LONGLONG)Cmd->Timeout * 1000 * 10);

    DPRINT5(4, "Submit cmd %08x (%08x) for timeout (%08x) in %d ms (%08x)\n",
            Cmd->Command, Cmd,  Cmd->TimeoutCommand, Cmd->Timeout, Cmd->WaitFlags);

    //
    // Remove from list
    //
    if (CmdWaitFlagIs(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST)) {
        RemoveEntryListB(&Cmd->ListEntry);
        ClearCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
    }

    //
    // Is the queue rundown?
    //
    if (WaitIsRunDown) {
        DPRINT2(4, "Can't insert cmd %08x (%08x); queue rundown\n",
                Cmd->Command, Cmd);
        WStatus = ERROR_ACCESS_DENIED;
        goto CLEANUP;
    }

    //
    // Insert into empty list
    //
    if (IsListEmpty(&WaitList)) {
        InsertHeadList(&WaitList, &Cmd->ListEntry);
        SetCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
        goto CLEANUP;
    }

    //
    // Insert at tail
    //
    Entry = GetListTail(&WaitList);
    OldCmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
    if (OldCmd->WaitFileTime <= Cmd->WaitFileTime) {
        InsertTailList(&WaitList, &Cmd->ListEntry);
        SetCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
        goto CLEANUP;
    }
    //
    // Insert into list
    //
    for (Entry = GetListHead(&WaitList);
         Entry != &WaitList;
         Entry = GetListNext(Entry)) {

        OldCmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        if (Cmd->WaitFileTime <= OldCmd->WaitFileTime) {
            InsertTailList(Entry, &Cmd->ListEntry);
            SetCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
            goto CLEANUP;
        }
    }

CLEANUP:
    //
    // Reset the timer if the expiration time has changed
    //
    if (WIN_SUCCESS(WStatus)) {
        WaitReset(FALSE);
    }
    LeaveCriticalSection(&WaitLock);

    return WStatus;
}


VOID
WaitTimeout(
    VOID
    )
/*++
Routine Description:
    Expel the commands whose timeouts have passed.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitTimeout:"
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;
    LONGLONG        Now;

    //
    // Expel expired commands
    //
    FrsNowAsFileTime(&Now);
    EnterCriticalSection(&WaitLock);
    while (!IsListEmpty(&WaitList)) {
        Entry = GetListHead(&WaitList);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        //
        // Hasn't timed out; stop
        //
        if ((Cmd->WaitFileTime - WAIT_FUZZY_TIMEOUT) > Now) {
            break;
        }

        //
        // Timed out; process it. Be careful to synchronize with
        // WaitUnsubmit.
        //
        RemoveEntryListB(Entry);
        ClearCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
        EnterCriticalSection(&WaitUnsubmitLock);
        LeaveCriticalSection(&WaitLock);
        WaitProcessCommand(Cmd, ERROR_SUCCESS);
        LeaveCriticalSection(&WaitUnsubmitLock);
        EnterCriticalSection(&WaitLock);
    }
    //
    // Reset the timer (always)
    //
    WaitReset(TRUE);
    LeaveCriticalSection(&WaitLock);
}


VOID
WaitRunDownList(
    VOID
    )
/*++
Routine Description:
    Error off the commands in the timeout list

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitRunDownList:"
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;

    //
    // Rundown commands
    //
    EnterCriticalSection(&WaitLock);
    while (!IsListEmpty(&WaitList)) {
        Entry = GetListHead(&WaitList);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);

        RemoveEntryListB(Entry);
        ClearCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);

        EnterCriticalSection(&WaitUnsubmitLock);
        LeaveCriticalSection(&WaitLock);

        WaitProcessCommand(Cmd, ERROR_ACCESS_DENIED);

        LeaveCriticalSection(&WaitUnsubmitLock);
        EnterCriticalSection(&WaitLock);
    }

    FrsNowAsFileTime(&WaitFileTime);
    DPRINT1(4, "Resetting rundown timer to %08x %08x.\n", PRINTQUAD(WaitFileTime));

    SetWaitableTimer(WaitableTimer, (LARGE_INTEGER *)&WaitFileTime, 0, NULL, NULL, TRUE);
    WaitIsRunDown = TRUE;
    LeaveCriticalSection(&WaitLock);
}


DWORD
MainWait(
    PFRS_THREAD FrsThread
    )
/*++
Routine Description:
    Entry point for a thread serving the wait queue.
    A timeout list is managed by a thread waiting on a
    waitable timer.

    The timer can be adjusted without context switching to the
    thread that is waiting on the timer.

    An entry can be pulled off the list. The timer is adjusted
    if the entry was at the head of the queue.

    The queue is sorted by timeout value. The timeout value is
    an absolute filetime.

    The list entry is a command packet. The generic command
    packet contains a field for the wait time in milliseconds.
    This code takes the wait time and converts it into an
    absolute filetime when the command packet is put on the
    queue. The timeout triggers when the time is equal to or
    greater than the command packet's filetime.

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "MainWait:"
    HANDLE      WaitArray[2];

    //
    // Thread is pointing at the correct queue
    //
    FRS_ASSERT(FrsThread->Data == &WaitList);

    DPRINT(0, "Wait thread has started.\n");

again:
    //
    // Wait for work, an exit timeout, or the queue to be rundown
    //
    DPRINT(4, "Wait thread is waiting.\n");
    WaitArray[0] = WaitRunDown;
    WaitArray[1] = WaitableTimer;

    WaitForMultipleObjectsEx(2, WaitArray, FALSE, INFINITE, TRUE);

    DPRINT(4, "Wait thread is running.\n");
    //
    // Nothing to do; exit
    //
    EnterCriticalSection(&WaitLock);
    if (IsListEmpty(&WaitList)) {
        WaitIsRunning = FALSE;
        LeaveCriticalSection(&WaitLock);

        DPRINT(0, "Wait thread is exiting.\n");
        ThSupSubmitThreadExitCleanup(FrsThread);
        ExitThread(ERROR_SUCCESS);
    }
    LeaveCriticalSection(&WaitLock);

    //
    // Check for timed out commands
    //
    WaitTimeout();

    //
    // Continue forever
    //
    goto again;
    return ERROR_SUCCESS;
}


VOID
WaitInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the wait subsystem. The thread is kicked off
    on demand.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitInitialize:"
    //
    // Timeout list
    //
    InitializeListHead(&WaitList);
    INITIALIZE_CRITICAL_SECTION(&WaitLock);
    INITIALIZE_CRITICAL_SECTION(&WaitUnsubmitLock);

    //
    // Rundown event for list
    //
    WaitRunDown = FrsCreateEvent(TRUE, FALSE);

    //
    // Timer
    //
    FrsNowAsFileTime(&WaitFileTime);
    WaitableTimer = FrsCreateWaitableTimer(TRUE);
    DPRINT1(4, "Setting initial timer to %08x %08x.\n", PRINTQUAD(WaitFileTime));

    if (!SetWaitableTimer(WaitableTimer, (LARGE_INTEGER *)&WaitFileTime, 0, NULL, NULL, TRUE)) {
        DPRINT_WS(0, "ERROR - Resetting timer;", GetLastError());
    }
}








VOID
ShutDownWait(
    VOID
    )
/*++
Routine Description:
    Shutdown the wait subsystem

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ShutDownWait:"
    WaitRunDownList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apiacct.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiAcct.c

Abstract:

    This module contains individual API handlers for the Account APIs.

    SUPPORTED - NetAccountDeltas, NetAccountSync.

    SEE ALSO - Other NetLogon service APIs - in ApiLogon.c.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991
    Jim Waters (t-jamesw) 09-August-1991

Revision History:

--*/


// Account APIs are UNICODE only. 

#ifndef UNICODE
#define UNICODE
#endif

#include "XactSrvP.h"

#include <netlibnt.h>
#include <crypt.h>     // must be included before <logonmsv.h>
#include <ntsam.h>     // must be included before <logonmsv.h>
#include <logonmsv.h>  // must be included before <ssi.h>
#include <ssi.h>       // I_NetAccountDeltas and I_NetAccountSync prototypes


NTSTATUS
XsNetAccountDeltas (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccountDeltas.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    NET_API_STATUS status;

    PXS_I_NET_ACCOUNT_DELTAS parameters = Parameters;
    LPTSTR nativeComputerName = NULL;       // Native parameters
    NETLOGON_AUTHENTICATOR authIn;
    NETLOGON_AUTHENTICATOR authOut;
    UAS_INFO_0 infoIn;
    DWORD entriesRead;
    DWORD totalEntries;
    UAS_INFO_0 infoOut;

    LPBYTE structure = NULL;                // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCOUNT) {
        NetpKdPrint(( "XsNetAccountDeltas: header at %lx, params at %lx, "
                      "buf size %ld\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->BufferLen )));
    }

    try {
        //
        // Convert parameters to Unicode, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeComputerName,
            (LPSTR)XsSmbGetPointer( &parameters->ComputerName )
            );

        //
        // Set up the input structures. This is to make sure that the
        // structures we pass to the API are naturally aligned, as well
        // as properly byte-aligned.
        //

        structure = (LPBYTE)XsSmbGetPointer( &parameters->RecordID );
        RtlCopyMemory( infoIn.ComputerName, structure, sizeof( infoIn.ComputerName ) );
        structure += sizeof( infoIn.ComputerName );
        infoIn.TimeCreated = SmbGetUlong( structure );
        structure += sizeof(DWORD);
        infoIn.SerialNumber = SmbGetUlong( structure );
        structure = (LPBYTE)XsSmbGetPointer( &parameters->Authenticator );
        RtlCopyMemory(
                &authIn.Credential,
                structure,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        authIn.timestamp = SmbGetUlong( structure );

        RtlZeroMemory( &authOut, sizeof(NETLOGON_AUTHENTICATOR) );

        //
        // Make the local I_NetAccountDeltas call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetAccountDeltas(
                         NULL,
                         nativeComputerName,
                         &authIn,
                         &authOut,
                         &infoIn,
                         (DWORD)SmbGetUshort( &parameters->Count ),
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         (DWORD)SmbGetUshort( &parameters->BufferLen ),
                         (LPDWORD)&entriesRead,
                         (LPDWORD)&totalEntries,
                         &infoOut
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetAccountDeltas: I_NetAccountDeltas failed: "
                              "%X\n", status ));
            }

            //
            // !!! When protocol level is available in the header information,
            //     we can check it. Right now, we ignore this code.
            //
            // For clients older than LanMan 2.1, return a different error code.
            // LANMAN 2.1 Protocol Level is 6.
            //

#if 0
            if ( status == NERR_TimeDiffAtDC && Header->ProtocolLevel < 6 ) {
                status = NERR_SyncRequired;
            }
#endif

            goto cleanup;
        }

        //
        // Fill in 16 bit return structures.
        //

        structure = parameters->NextRecordID;
        RtlCopyMemory( structure, infoOut.ComputerName, sizeof( infoOut.ComputerName ) );
        structure += sizeof( infoOut.ComputerName );
        SmbPutUlong( (LPDWORD)structure, infoOut.TimeCreated );
        structure += sizeof(DWORD);
        SmbPutUlong( (LPDWORD)structure, infoOut.SerialNumber );

        structure = parameters->RetAuth;
        RtlCopyMemory(
                structure,
                &authOut.Credential,
                sizeof(NETLOGON_CREDENTIAL)
                );

        structure += sizeof(NETLOGON_CREDENTIAL);
        SmbPutUlong( (LPDWORD)structure, authOut.timestamp );


        //
        // Fill in 16 bit return values.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesRead );
        SmbPutUshort( &parameters->TotalEntries, (WORD)totalEntries );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Free strings.
    //

    NetpMemoryFree( nativeComputerName );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetAccountDeltas


NTSTATUS
XsNetAccountSync (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccountSync.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    NET_API_STATUS status;

    PXS_I_NET_ACCOUNT_SYNC parameters = Parameters;
    LPTSTR nativeComputerName = NULL;       // Native parameters
    NETLOGON_AUTHENTICATOR authIn;
    NETLOGON_AUTHENTICATOR authOut;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD nextReference;
    UAS_INFO_0 infoOut;

    LPBYTE structure;                       // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCOUNT) {
        NetpKdPrint(( "XsNetAccountSync: header at %lx, params at %lx, "
                      "buf size %ld\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->BufferLen )));
    }
    // NetpBreakPoint();

    try {
        //
        // Convert parameters to Unicode, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeComputerName,
            (LPSTR)XsSmbGetPointer( &parameters->ComputerName )
            );

        //
        // Set up the input structure. This is to make sure that the
        // structure we pass to the API is naturally aligned, as well
        // as properly byte-aligned.
        //

        structure = (LPBYTE)XsSmbGetPointer( &parameters->Authenticator );
        RtlCopyMemory(
                &authIn.Credential,
                structure,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        authIn.timestamp = SmbGetUlong( structure );

        RtlZeroMemory( &authOut, sizeof(NETLOGON_AUTHENTICATOR) );


        //
        // Make the local I_NetAccountSync call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetAccountSync(
                         NULL,
                         nativeComputerName,
                         &authIn,
                         &authOut,
                         (DWORD)SmbGetUlong( &parameters->Reference ),
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         (DWORD)SmbGetUshort( &parameters->BufferLen ),
                         (LPDWORD)&entriesRead,
                         (LPDWORD)&totalEntries,
                         (LPDWORD)&nextReference,
                         &infoOut
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetAccountSync: I_NetAccountSync failed: "
                              "%X\n", status ));
            }

            //
            // !!! When protocol level is available in the header information,
            //     we can check it. Right now, we ignore this code.
            //
            // For clients older than LanMan 2.1, return a different error code.
            // LANMAN 2.1 Protocol Level is 6.
            //

#if 0
            if ( status == NERR_TimeDiffAtDC && Header->ProtocolLevel < 6 ) {
                status = NERR_SyncRequired;
            }
#endif

            goto cleanup;
        }

        //
        // Fill in 16 bit return structures.
        //

        structure = parameters->LastRecordID;
        RtlCopyMemory( structure, infoOut.ComputerName, sizeof( infoOut.ComputerName ) );
        structure += sizeof( infoOut.ComputerName );
        SmbPutUlong( (LPDWORD)structure, infoOut.TimeCreated );
        structure += sizeof(DWORD);
        SmbPutUlong( (LPDWORD)structure, infoOut.SerialNumber );

        structure = parameters->RetAuth;
        RtlCopyMemory(
                structure,
                &authOut.Credential,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        SmbPutUlong( (LPDWORD)structure, authOut.timestamp );

        //
        // Fill in 16 bit return values.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesRead );
        SmbPutUshort( &parameters->TotalEntries, (WORD)totalEntries );
        SmbPutUlong( &parameters->NextReference, nextReference );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Free strings.
    //

    NetpMemoryFree( nativeComputerName );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetAccountSync
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apiacces.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiAcces.c

Abstract:

    This module contains individual API handlers for the NetAccess APIs.

    SUPPORTED : NetAccessAdd, NetAccessDel, NetAccessEnum, NetAccessGetInfo,
                NetAccessGetUserPerms, NetAccessSetInfo.

Author:

    Shanku Niyogi (w-shanku)    13-Mar-1991

Revision History:

--*/

//
// Access APIs are UNICODE only.
//

#ifndef UNICODE
#define UNICODE
#endif

#include "xactsrvp.h"

//
// We do not support NetAccess apis from downlevel
//

#define RETURN_ACCESS_NOT_SUPPORTED    \
        API_HANDLER_PARAMETERS_REFERENCE;       \
        Header->Status = ERROR_NOT_SUPPORTED;


#ifdef NET_ACCESS_SUPPORTED

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_access_info_0 = REM16_access_info_0;
STATIC const LPDESC Desc32_access_info_0 = REM32_access_info_0;
STATIC const LPDESC Desc16_access_info_1 = REM16_access_info_1;
STATIC const LPDESC Desc32_access_info_1 = REM32_access_info_1;
STATIC const LPDESC Desc16_access_list = REM16_access_list;
STATIC const LPDESC Desc32_access_list = REM32_access_list;


STATIC NET_API_STATUS
XsNetAccessEnumVerify (
    IN NET_API_STATUS ConvertStatus,
    IN PBYTE ConvertedEntry,
    IN PBYTE BaseAddress
    )

/*++

Routine Description:


    This function is called by XsFillEnumBuffer after each entry is
    converted, in order to determine whether the entry should be retained
    in the enum buffer or discarded.


    The access_info_1 entries contain a number of auxiliary structures.
    The limit in LanMan 2.0 for these is 64. This function makes sure that
    entries with more than 64 structures are not returned. Note that the
    number of entries is not truncated to 64; if this data is received and
    used for a SetInfo, 32-bit data will be irretrievably lost.

Arguments:

    ConvertStatus - The return code from RapConvertSingleEntry.

    ConvertedEntry - The converted entry created by RapConvertSingleEntry.

    BaseAddress - A pointer to the base used to calculate offsets.

Return Value:

    NET_API_STATUS - NERR_Success if the entry should be retained, or
        an error code if the entry should be discarded.

--*/

{
    PACCESS_16_INFO_1 acc = (PACCESS_16_INFO_1)ConvertedEntry;

    UNREFERENCED_PARAMETER(BaseAddress);

    //
    // If RapConvertSingleEntry failed, discard the entry.
    //

    if ( ConvertStatus != NERR_Success ) {
        return ConvertStatus;
    }

    //
    // If there are more than 64 entries, discard the entry.
    //

    if ( SmbGetUshort( &acc->acc1_count ) > 64 ) {

        IF_DEBUG(CONVERT) {
            NetpKdPrint(( "XsNetAccessEnumVerify: too many aux. entries\n" ));
        }

        return ERROR_MORE_DATA;

    } else {

        return NERR_Success;
    }
}
#endif // NET_ACCESS_SUPPORTED


NTSTATUS
XsNetAccessAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#ifdef NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD auxDataCount;
    DWORD bufferSize;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessAdd: header at %lx, params at %lx, "
                      "level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_access_info_1;
        AuxStructureDesc = Desc16_access_list;

        //
        // Figure out if there is enough room in the buffer for the fixed
        // structure. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE    // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find the auxiliary data structure count, and form a long descriptor
        // string which can be used to do all the conversion in one pass.
        //

        auxDataCount = RapAuxDataCount(
                           (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                           StructureDesc,
                           Response,
                           FALSE     // not in native format
                           );

        if ( auxDataCount > 64 ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: too many access_lists.\n" ));
            }
            Header->Status = NERR_ACFTooManyLists;
            goto cleanup;
        }

        longDescriptor = NetpMemoryAllocate(
                             strlen( StructureDesc )
                             + strlen( AuxStructureDesc ) * auxDataCount + 1 );
        longNativeDescriptor = NetpMemoryAllocate(
                                   strlen( Desc32_access_info_1 )
                                   + strlen( Desc32_access_list ) * auxDataCount
                                   + 1 );

        if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: failed to allocate memory" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        strcpy( longDescriptor, StructureDesc );
        strcpy( longNativeDescriptor, Desc32_access_info_1 );
        for ( i = 0; i < auxDataCount; i++ ) {
            strcat( longDescriptor, AuxStructureDesc );
            strcat( longNativeDescriptor, Desc32_access_list );
        }

        //
        // Figure out if there is enough room in the buffer for all this
        // data. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 longDescriptor,
                 FALSE   // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                         longDescriptor,
                         longNativeDescriptor,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(ACCESS) {
            NetpKdPrint(( "XsNetAccessAdd: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                longDescriptor,
                TRUE,
                buffer,
                buffer,
                longNativeDescriptor,
                FALSE,
                &stringLocation,
                &bytesRequired,
                Response,
                RapToNative
                );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetAccessAdd(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: NetAccessAdd failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );

#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;

} // XsNetAccessAdd


NTSTATUS
XsNetAccessDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_DEL parameters = Parameters;
    LPTSTR nativeResource = NULL;           // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessDel: header at %lx, params at %lx, "
                      "resource %s\n",
                      Header, parameters, SmbGetUlong( &parameters->Resource )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeResource,
            (LPSTR)SmbGetUlong( &parameters->Resource )
            );

        //
        // Make the local call.
        //

        status = NetAccessDel(
                     NULL,
                     nativeResource
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessDel: NetAccessDel failed: "
                              "%X\n", status ));
            }
        }

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeResource );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessDel


NTSTATUS
XsNetAccessEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_ENUM parameters = Parameters;
    LPTSTR nativeBasePath = NULL;           // Native parameters
    LPVOID outBuffer = NULL;
    DWORD  entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD invalidEntries = 0;
    DWORD bytesRequired;
    LPDESC nativeStructureDesc;
    LPDESC nativeAuxStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, and check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeBasePath,
            (LPSTR)SmbGetUlong( &parameters->BasePath )
            );

        //
        // Make the local 32-bit call.
        //

        status = NetAccessEnum(
                     NULL,
                     nativeBasePath,
                     (DWORD)SmbGetUshort( &parameters->Recursive ),
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetAccessEnum: NetAccessEnum failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(ACCESS) {
            NetpKdPrint(( "XsNetAccessEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Determine descriptors based on level.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            StructureDesc = Desc16_access_info_0;
            nativeStructureDesc = Desc32_access_info_0;
            AuxStructureDesc = NULL;
            nativeAuxStructureDesc = NULL;

        case 1:

            StructureDesc = Desc16_access_info_1;
            nativeStructureDesc = Desc32_access_info_1;
            AuxStructureDesc = Desc16_access_list;
            nativeAuxStructureDesc = Desc32_access_list;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures. We call XsFillAuxEnumBuffer, because there may be
        // auxiliary structures. In level 0, auxiliary descriptors are NULL,
        // and XsFillAuxEnumBuffer will automatically call XsFillEnumBuffer.
        //

        XsFillAuxEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            nativeAuxStructureDesc,
            (LPVOID)SmbGetUlong( &parameters->Buffer ),
            (LPVOID)SmbGetUlong( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            AuxStructureDesc,
            &XsNetAccessEnumVerify,
            &bytesRequired,
            &entriesFilled,
            &invalidEntries
            );

        IF_DEBUG(ACCESS) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Because of the complexity of the
        // access structures, we'll send the data back unpacked.
        //

        if (( entriesFilled + invalidEntries ) < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail,
                          (WORD)( totalEntries - invalidEntries ));

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessEnum


NTSTATUS
XsNetAccessGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_GET_INFO parameters = Parameters;
    LPTSTR nativeResource = NULL;           // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD auxDataCount;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, and check for errors.
        //

        switch ( SmbGetUshort( &parameters->Level )) {

        case 0:

            StructureDesc = Desc16_access_info_0;
            break;

        case 1:

            StructureDesc = Desc16_access_info_1;
            break;

        default:

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeResource,
            (LPSTR)SmbGetUlong( &parameters->Resource )
            );

        //
        // Make the local call.
        //

        status = NetAccessGetInfo(
                     NULL,
                     nativeResource,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetAccessGetInfo: NetAccessGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the 32-bit
        // structure we got back from NetAccessGetInfo. For a level 0 call,
        // the structure is described by the native descriptor string.
        // If the level is 1, form a long descriptor string which contains
        // enough copies of the auxiliary data descriptor. The format of the
        // 16-bit structure is stored in the transaction block - it must
        // also be converted to a long descriptor for level 1 calls.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            longDescriptor = NetpMemoryAllocate(
                                 strlen( Desc16_access_info_1 ) + 1 );
            longNativeDescriptor = NetpMemoryAllocate(
                                       strlen( Desc32_access_info_0 ) + 1 );

            if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessGetInfo: failed to allocate memory" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }

            strcpy( longDescriptor, Desc16_access_info_0 );
            strcpy( longNativeDescriptor, Desc32_access_info_0 );

            break;

        case 1:

            //
            // Find the auxiliary data count.
            //

            auxDataCount = RapAuxDataCount(
                               (LPBYTE)outBuffer,
                               Desc32_access_info_1,
                               Response,
                               TRUE   // native format
                               );

            //
            // 16-bit clients can only get 64 access list structures.
            //

            auxDataCount = ( auxDataCount > 64 ) ? 64 : auxDataCount;

            longDescriptor = NetpMemoryAllocate(
                                 strlen( Desc16_access_info_1 )
                                 + strlen( Desc16_access_list ) *
                                     auxDataCount + 1 );
            longNativeDescriptor = NetpMemoryAllocate(
                                       strlen( Desc32_access_info_1 )
                                       + strlen( Desc32_access_list ) * auxDataCount
                                       + 1 );

            if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessGetInfo: failed to allocate memory" ));
                }
                Header->Status = (WORD)NERR_NoRoom;
                goto cleanup;
            }

            strcpy( longDescriptor, Desc16_access_info_1 );
            strcpy( longNativeDescriptor, Desc32_access_info_1 );
            for ( i = 0; i < auxDataCount; i++ ) {
                strcat( longDescriptor, Desc16_access_list );
                strcat( longNativeDescriptor, Desc32_access_list );
            }

            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( SmbGetUlong( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     longNativeDescriptor,
                     FALSE,
                     (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                     (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                     longDescriptor,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(ACCESS) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE     // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetAccessGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)SmbGetUlong( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    longDescriptor,
                                    1
                                    );
        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );
    NetpMemoryFree( nativeResource );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        longDescriptor,
        Header->Converter,
        1,
        Header->Status
        );


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessGetInfo


NTSTATUS
XsNetAccessGetUserPerms (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessGetUserPerms.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_GET_USER_PERMS parameters = Parameters;
    LPTSTR nativeUgName = NULL;             // Native parameters
    LPTSTR nativeResource = NULL;
    DWORD userPerms;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeUgName,
            (LPSTR)SmbGetUlong( &parameters->UgName )
            );

        XsConvertTextParameter(
            nativeResource,
            (LPSTR)SmbGetUlong( &parameters->Resource )
            );

        //
        // Make the local call.
        //

        status = NetAccessGetUserPerms(
                     NULL,
                     nativeUgName,
                     nativeResource,
                     &userPerms
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessGetUserPerms: "
                              "NetAccessGetUserPerms failed: %X\n",
                              status ));
            }
        }

        //
        // Put perms into return field.
        //

        SmbPutUshort( &parameters->Perms, (WORD)userPerms );

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeUgName );
    NetpMemoryFree( nativeResource );

    Header->Status = (WORD)status;


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessGetUserPerms


NTSTATUS
XsNetAccessSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_SET_INFO parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters
    LPTSTR nativeResource = NULL;
    DWORD accessAttr;

    DWORD bufferSize;                       // Conversion variables
    LPBYTE stringLocation = NULL;
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD auxDataCount;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessSetInfo: header at %lx, params at %lx,"
                      " level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, and check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeResource,
            (LPSTR)SmbGetUlong( &parameters->Resource )
            );

        StructureDesc = Desc16_access_info_1;
        AuxStructureDesc = Desc16_access_list;

        //
        // The ParmNum can either be to change the whole ACL or just the auditing
        // attribute. Since the latter is much simpler than the former, check
        // for that ParmNum and process it. If not, we go through the elaborate
        // process of converting the whole buffer as in NetAccessAdd.
        //

        switch ( SmbGetUshort( &parameters->ParmNum )) {

        case ACCESS_ATTR_PARMNUM:

            if ( SmbGetUshort( &parameters->BufLen ) < sizeof(WORD)) {

                Header->Status= NERR_BufTooSmall;
                goto cleanup;
            }

            accessAttr = (DWORD)SmbGetUshort(
                                   (LPWORD)SmbGetUlong( &parameters->Buffer )
                                   );

            buffer = &accessAttr;

            break;

        case PARMNUM_ALL:

            //
            // Figure out if there is enough room in the buffer for the fixed
            // structure. If not, return NERR_BufTooSmall.
            //

            if ( !XsCheckBufferSize(
                     SmbGetUshort( &parameters->BufLen ),
                     StructureDesc,
                     FALSE    // not in native format
                    )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: Buffer too small.\n" ));
                }
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            //
            // Find the auxiliary data structure count, and form a long descriptor
            // string which can be used to do all the conversion in one pass.
            //

            auxDataCount = RapAuxDataCount(
                               (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                               StructureDesc,
                               Response,
                               FALSE   // not in native format
                               );

            if ( auxDataCount > 64 ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: too many access_lists.\n" ));
                }
                Header->Status = NERR_ACFTooManyLists;
                goto cleanup;
            }

            longDescriptor = NetpMemoryAllocate(
                                 strlen( StructureDesc )
                                 + strlen( AuxStructureDesc ) * auxDataCount
                                 + 1 );
            longNativeDescriptor = NetpMemoryAllocate(
                                       strlen( Desc32_access_info_1 )
                                       + strlen( Desc32_access_list ) * auxDataCount
                                       + 1 );

            if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: failed to allocate memory" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }

            strcpy( longDescriptor, StructureDesc );
            strcpy( longNativeDescriptor, Desc32_access_info_1 );
            for ( i = 0; i < auxDataCount; i++ ) {
                strcat( longDescriptor, AuxStructureDesc );
                strcat( longNativeDescriptor, Desc32_access_list );
            }

            //
            // Figure out if there is enough room in the buffer for all this
            // data. If not, return NERR_BufTooSmall.
            //

            if ( !XsCheckBufferSize(
                     SmbGetUshort( &parameters->BufLen ),
                     longDescriptor,
                     FALSE   // not in native format
                    )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: Buffer too small.\n" ));
                }
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            //
            // Find out how big a buffer we need to allocate to hold the native
            // 32-bit version of the input data structure.
            //

            bufferSize = XsBytesForConvertedStructure(
                             (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                             longDescriptor,
                             longNativeDescriptor,
                             RapToNative,
                             TRUE
                             );

            //
            // Allocate enough memory to hold the converted native buffer.
            //

            buffer = NetpMemoryAllocate( bufferSize );

            if ( buffer == NULL ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: failed to create buffer" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;

            }

            IF_DEBUG(ACCESS) {
                NetpKdPrint(( "XsNetAccessSetInfo: buffer of %ld bytes at %lx\n",
                              bufferSize, buffer ));
            }

            //
            // Convert the buffer from 16-bit to 32-bit.
            //

            stringLocation = (LPBYTE)buffer + bufferSize;
            bytesRequired = 0;

            status = RapConvertSingleEntry(
                         (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                         longDescriptor,
                         TRUE,
                         buffer,
                         buffer,
                         longNativeDescriptor,
                         FALSE,
                         &stringLocation,
                         &bytesRequired,
                         Response,
                         RapToNative
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: "
                                  "RapConvertSingleEntry failed: %X\n",
                                  status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            break;

        }

        //
        // Make the local call.
        //

        status = NetAccessSetInfo(
                     NULL,
                     nativeResource,
                     PARMNUM_BASE_INFOLEVEL + SmbGetUshort( &parameters->ParmNum ),
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessSetInfo: NetAccessSetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeResource );

    //
    // If there is a 32-bit native buffer, free it.
    //

    if ( SmbGetUshort( &parameters->ParmNum ) == PARMNUM_ALL ) {

        NetpMemoryFree( buffer );
        NetpMemoryFree( longDescriptor );
        NetpMemoryFree( longNativeDescriptor );
    }


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apichdev.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiChDev.c

Abstract:

    This module contains individual API handlers for the NetCharDev
    and NetCharDevQ APIs. Supported APIs are NetCharDevControl,
    NetCharDevEnum, NetCharDevGetInfo, NetCharDevQEnum, NetCharDevQGetInfo,
    NetCharDevQPurge, NetCharDevQPurgeSelf, and NetCharDevQSetInfo.

    SUPPORTED: NetCharDevControl, NetCharDevEnum, NetCharDevGetInfo,
               NetCharDevQEnum, NetCharDevQGetInfo, NetCharDevQPurge,
               NetCharDevQPurgeSelf, NetCharDevQSetInfo.

    !!! Remove handlers for unsupported APIs when done.

Author:

    Shanku Niyogi (w-shanku)    06-Mar-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

#if 0
STATIC const LPDESC Desc16_chardev_info_0 = REM16_chardev_info_0;
STATIC const LPDESC Desc32_chardev_info_0 = REM32_chardev_info_0;
STATIC const LPDESC Desc16_chardev_info_1 = REM16_chardev_info_1;
STATIC const LPDESC Desc32_chardev_info_1 = REM32_chardev_info_1;
STATIC const LPDESC Desc16_chardevQ_info_0 = REM16_chardevQ_info_0;
STATIC const LPDESC Desc32_chardevQ_info_0 = REM32_chardevQ_info_0;
STATIC const LPDESC Desc16_chardevQ_info_1 = REM16_chardevQ_info_1;
STATIC const LPDESC Desc32_chardevQ_info_1 = REM32_chardevQ_info_1;
STATIC const LPDESC Desc16_chardevQ_info_1_setinfo
                                           = REM16_chardevQ_info_1_setinfo;
STATIC const LPDESC Desc32_chardevQ_info_1_setinfo
                                           = REM32_chardevQ_info_1_setinfo;
#endif

#define RETURN_CHARDEV_NOT_SUPPORTED    \
        API_HANDLER_PARAMETERS_REFERENCE;       \
        Header->Status = ERROR_NOT_SUPPORTED;


NTSTATUS
XsNetCharDevControl (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevControl.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if 0
    NET_API_STATUS status;

    PXS_NET_CHAR_DEV_CONTROL parameters = Parameters;
    LPTSTR nativeDevName = NULL;            // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeDevName,
        (LPSTR)SmbGetUlong( &parameters->DevName )
        );

    //
    // Make the local call.
    //

    status = NetCharDevControl(
                 NULL,
                 nativeDevName,
                 (DWORD)SmbGetUshort( &parameters->OpCode )
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevControl: "
                          "NetCharDevControl failed: %X\n", status ));
        }
    }

cleanup:

    NetpMemoryFree( nativeDevName );

    //
    // No return data.
    //

    Header->Status = (WORD)status;
#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    return STATUS_SUCCESS;

} // XsNetCharDevControl


NTSTATUS
XsNetCharDevEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    PXS_NET_CHAR_DEV_ENUM parameters = Parameters;
    DWORD entriesFilled = 0;
#if 0

    NET_API_STATUS status;

    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD bytesRequired = 0;                // Conversion variables
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    //
    // Check for errors.
    //

    if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    //
    // Make the local call.
    //

    status = NetCharDevEnum(
                 NULL,
                 (DWORD)SmbGetUshort( &parameters->Level ),
                 (LPBYTE *)&outBuffer,
                 XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                 &entriesRead,
                 &totalEntries,
                 NULL
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetCharDevEnum: NetCharDevEnum failed: %X\n",
                          status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;
    }

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevEnum: received %ld entries at %lx\n",
                      entriesRead, outBuffer ));
    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( SmbGetUshort( &parameters->Level ) ) {

    case 0:

        nativeStructureDesc = Desc32_chardev_info_0;
        StructureDesc = Desc16_chardev_info_0;
        break;

    case 1:

        nativeStructureDesc = Desc32_chardev_info_1;
        StructureDesc = Desc16_chardev_info_1;
        break;

    }

    //
    // Do the actual conversion from the 32-bit structures to 16-bit
    // structures.
    //

    XsFillEnumBuffer(
        outBuffer,
        entriesRead,
        nativeStructureDesc,
        (LPVOID)SmbGetUlong( &parameters->Buffer ),
        (LPVOID)SmbGetUlong( &parameters->Buffer ),
        SmbGetUshort( &parameters->BufLen ),
        StructureDesc,
        NULL,  // verify function
        &bytesRequired,
        &entriesFilled,
        NULL
        );

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                      " Entries %ld of %ld\n",
                      outBuffer, SmbGetUlong( &parameters->Buffer ),
                      bytesRequired, entriesFilled, totalEntries ));
    }

    //
    // The 16-bit chardev_info structures do not contain any variable
    // data. Therefore, there is no need to pack any data - the converter
    // is already set to 0.
    //

    if ( entriesFilled < totalEntries ) {

        Header->Status = ERROR_MORE_DATA;

    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
    SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:

    NetApiBufferFree( outBuffer );

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetCharDevEnum


NTSTATUS
XsNetCharDevGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    PXS_NET_CHAR_DEV_GET_INFO parameters = Parameters;
#if 0
    NET_API_STATUS status;

    LPTSTR nativeDevName = NULL;            // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    //
    // Translate parameters, check for errors.
    //

    if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    XsConvertTextParameter(
        nativeDevName,
        (LPSTR)SmbGetUlong( &parameters->DevName )
        );

    //
    //
    // Make the local call.
    //

    status = NetCharDevGetInfo(
                 NULL,
                 nativeDevName,
                 (DWORD)SmbGetUshort( &parameters->Level ),
                 (LPBYTE *)&outBuffer
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetCharDevGetInfo: NetCharDevGetInfo failed: "
                          "%X\n", status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;

    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( SmbGetUshort( &parameters->Level ) ) {

    case 0:

        nativeStructureDesc = Desc32_chardev_info_0;
        StructureDesc = Desc16_chardev_info_0;
        break;

    case 1:

        nativeStructureDesc = Desc32_chardev_info_1;
        StructureDesc = Desc16_chardev_info_1;
        break;

    }

    //
    // Convert the structure returned by the 32-bit call to a 16-bit
    // structure. The last possible location for variable data is
    // calculated from buffer location and length.
    //

    stringLocation = (LPBYTE)( SmbGetUlong( &parameters->Buffer )
                                  + SmbGetUshort( &parameters->BufLen ) );

    status = RapConvertSingleEntry(
                 outBuffer,
                 nativeStructureDesc,
                 FALSE,
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 StructureDesc,
                 TRUE,
                 &stringLocation,
                 &bytesRequired,
                 Response,
                 NativeToRap
                 );


    if ( status != NERR_Success ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevGetInfo: RapConvertSingleEntry failed: "
                      "%X\n", status ));
        }

        Header->Status = NERR_InternalError;
        goto cleanup;
    }

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                      outBuffer, SmbGetUlong( &parameters->Buffer ),
                      bytesRequired ));
    }

    //
    // Determine return code based on the size of the buffer. The 16-bit
    // chardev_info structures do not have any variable data to pack.
    //

    if ( !XsCheckBufferSize(
             SmbGetUshort( &parameters->BufLen ),
             StructureDesc,
             FALSE  // not in native format
             )) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevGetInfo: Buffer too small.\n" ));
        }
        Header->Status = NERR_BufTooSmall;

    } else if ( bytesRequired > SmbGetUshort( &parameters-> BufLen )) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "NetCharDevGetInfo: More data available.\n" ));
        }
        Header->Status = ERROR_MORE_DATA;

    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );
cleanup:

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeDevName );

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetCharDevGetInfo


NTSTATUS
XsNetCharDevQEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_CHAR_DEV_Q_ENUM parameters = Parameters;
    DWORD entriesFilled = 0;

#if 0
    NET_API_STATUS status;

    LPTSTR nativeUserName = NULL;           // Native parameters
    LPVOID outBuffer = NULL;
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevQEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    //
    // Translate parameters, check for errors.
    //

    if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    XsConvertTextParameter(
        nativeUserName,
        (LPSTR)SmbGetUlong( &parameters->UserName )
        );

    //
    // Make the local call.
    //

    status = NetCharDevQEnum(
                 NULL,
                 nativeUserName,
                 (DWORD)SmbGetUshort( &parameters->Level ),
                 (LPBYTE *)&outBuffer,
                 XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                 &entriesRead,
                 &totalEntries,
                 NULL
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetCharDevQEnum: NetCharDevQEnum failed: %X\n",
                          status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;
    }

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevQEnum: received %ld entries at %lx\n",
                      entriesRead, outBuffer ));
    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( SmbGetUshort( &parameters->Level ) ) {

    case 0:

        nativeStructureDesc = Desc32_chardevQ_info_0;
        StructureDesc = Desc16_chardevQ_info_0;
        break;

    case 1:

        nativeStructureDesc = Desc32_chardevQ_info_1;
        StructureDesc = Desc16_chardevQ_info_1;
        break;

    }

    //
    // Do the actual conversion from the 32-bit structures to 16-bit
    // structures.
    //

    XsFillEnumBuffer(
        outBuffer,
        entriesRead,
        nativeStructureDesc,
        (LPVOID)SmbGetUlong( &parameters->Buffer ),
        (LPVOID)SmbGetUlong( &parameters->Buffer ),
        SmbGetUshort( &parameters->BufLen ),
        StructureDesc,
        NULL,  // verify function
        &bytesRequired,
        &entriesFilled,
        NULL
        );

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                      " Entries %ld of %ld\n",
                      outBuffer, SmbGetUlong( &parameters->Buffer ),
                      bytesRequired, entriesFilled, totalEntries ));
    }

    //
    // If all the data was returned, try to pack the data so that we
    // don't send empty bytes back.
    //

    if ( entriesFilled < totalEntries ) {

        Header->Status = ERROR_MORE_DATA;

    } else {

        Header->Converter = XsPackReturnData(
                                (LPVOID)SmbGetUlong( &parameters->Buffer ),
                                SmbGetUshort( &parameters->BufLen ),
                                StructureDesc,
                                entriesFilled
                                );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
    SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeUserName );
#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetCharDevQEnum


NTSTATUS
XsNetCharDevQGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_CHAR_DEV_Q_GET_INFO parameters = Parameters;
#if 0
    NET_API_STATUS status;

    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPTSTR nativeUserName = NULL;
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    XsConvertTextParameter(
        nativeQueueName,
        (LPSTR)SmbGetUlong( &parameters->QueueName )
        );

    XsConvertTextParameter(
        nativeUserName,
        (LPSTR)SmbGetUlong( &parameters->UserName )
        );

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevQGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    //
    // Make the local call.
    //

    status = NetCharDevQGetInfo(
                 NULL,
                 nativeQueueName,
                 nativeUserName,
                 (DWORD)SmbGetUshort( &parameters->Level ),
                 (LPBYTE *)&outBuffer
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetCharDevQGetInfo: NetCharDevQGetInfo failed: "
                          "%X\n", status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;

    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( SmbGetUshort( &parameters->Level ) ) {

    case 0:

        nativeStructureDesc = Desc32_chardevQ_info_0;
        StructureDesc = Desc16_chardevQ_info_0;
        break;

    case 1:

        nativeStructureDesc = Desc32_chardevQ_info_1;
        StructureDesc = Desc16_chardevQ_info_1;
        break;

    }

    //
    // Convert the structure returned by the 32-bit call to a 16-bit
    // structure. The last possible location for variable data is
    // calculated from buffer location and length.
    //

    stringLocation = (LPBYTE)( SmbGetUlong( &parameters->Buffer )
                                  + SmbGetUshort( &parameters->BufLen ) );

    status = RapConvertSingleEntry(
                 outBuffer,
                 nativeStructureDesc,
                 FALSE,
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 StructureDesc,
                 TRUE,
                 &stringLocation,
                 &bytesRequired,
                 Response,
                 NativeToRap
                 );

    if ( status != NERR_Success ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsCharDevQGetInfo: RapConvertSingleEntry failed: "
                          "%X\n", status ));
        }

        Header->Status = NERR_InternalError;
        goto cleanup;
    }

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                      outBuffer, SmbGetUlong( &parameters->Buffer ),
                      bytesRequired ));
    }

    //
    // Determine return code based on the size of the buffer. If all data
    // has fit, try to pack it.
    //

    if ( !XsCheckBufferSize(
             SmbGetUshort( &parameters->BufLen ),
             StructureDesc,
             FALSE   // not in native format
             )) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQGetInfo: Buffer too small.\n" ));
        }
        Header->Status = NERR_BufTooSmall;

    } else if ( bytesRequired > SmbGetUshort( &parameters-> BufLen )) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "NetCharDevQGetInfo: More data available.\n" ));
        }
        Header->Status = ERROR_MORE_DATA;

    } else {

        Header->Converter = XsPackReturnData(
                                (LPVOID)SmbGetUlong( &parameters->Buffer ),
                                SmbGetUshort( &parameters->BufLen ),
                                StructureDesc,
                                1
                                );

    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeQueueName );
    NetpMemoryFree( nativeUserName );

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif
    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetCharDevQGetInfo


NTSTATUS
XsNetCharDevQPurge (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQPurge.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if 0
    NET_API_STATUS status;

    PXS_NET_CHAR_DEV_Q_PURGE parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeQueueName,
        (LPSTR)SmbGetUlong( &parameters->QueueName )
        );

    //
    // Make the local call.
    //

    status = NetCharDevQPurge(
                 NULL,
                 nativeQueueName
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQPurge: "
                          "NetCharDevQPurge failed: %X\n", status ));
        }
    }

cleanup:

    NetpMemoryFree( nativeQueueName );

    //
    // No return data.
    //

    Header->Status = (WORD)status;

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif
    return STATUS_SUCCESS;

} // XsNetCharDevQPurge


NTSTATUS
XsNetCharDevQPurgeSelf (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQPurgeSelf.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if 0
    NET_API_STATUS status;

    PXS_NET_CHAR_DEV_Q_PURGE_SELF parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPTSTR nativeComputerName = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeQueueName,
        (LPSTR)SmbGetUlong( &parameters->QueueName )
        );

    XsConvertTextParameter(
        nativeComputerName,
        (LPSTR)SmbGetUlong( &parameters->ComputerName )
        );

    //
    // Make the local call.
    //

    status = NetCharDevQPurgeSelf(
                 NULL,
                 nativeQueueName,
                 nativeComputerName
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQPurgeSelf: "
                          "NetCharDevQPurgeSelf failed: %X\n", status ));
        }
    }

cleanup:

    NetpMemoryFree( nativeQueueName );
    NetpMemoryFree( nativeComputerName );

    //
    // No return data.
    //

    Header->Status = (WORD)status;
#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    return STATUS_SUCCESS;

} // XsNetCharDevQPurgeSelf


NTSTATUS
XsNetCharDevQSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if 0
    NET_API_STATUS status;

    PXS_NET_CHAR_DEV_Q_SET_INFO parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPVOID buffer = NULL;
    DWORD level;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    if ( SmbGetUshort( &parameters->Level ) != 1 ) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    XsConvertTextParameter(
        nativeQueueName,
        (LPSTR)SmbGetUlong( &parameters->QueueName )
        );

    StructureDesc = Desc16_chardevQ_info_1;

    status = XsConvertSetInfoBuffer(
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 SmbGetUshort( &parameters->BufLen ),
                 SmbGetUshort( &parameters->ParmNum ),
                 FALSE,
                 TRUE,
                 StructureDesc,
                 Desc32_chardevQ_info_1,
                 Desc16_chardevQ_info_1_setinfo,
                 Desc32_chardevQ_info_1_setinfo,
                 (LPBYTE *)&buffer,
                 NULL
                 );

    if ( status != NERR_Success ) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQSetInfo: Problem with conversion: "
                          "%X\n", status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;

    }

    //
    // Make the local call.
    //

    level = SmbGetUshort( &parameters->ParmNum );
    if ( level != 0 ) {
        level = level + PARMNUM_BASE_INFOLEVEL;
    } else {
        level = SmbGetUshort( &parameters->Level );
    }

    status = NetCharDevQSetInfo(
                 NULL,
                 nativeQueueName,
                 level,
                 buffer,
                 NULL
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQSetInfo: NetCharDevQSetInfo failed: "
                          "%X\n", status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;
    }

    //
    // No return information for this API.
    //

cleanup:

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    NetpMemoryFree( nativeQueueName );

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif
    return STATUS_SUCCESS;

} // XsNetCharDevQSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apiconn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiConn.c

Abstract:

    This module contains individual API handlers for the NetConnection APIs.

    SUPPORTED : NetConnectionEnum.

Author:

    Shanku Niyogi (w-shanku) 26-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_connection_info_0 = REM16_connection_info_0;
STATIC const LPDESC Desc32_connection_info_0 = REM32_connection_info_0;
STATIC const LPDESC Desc16_connection_info_1 = REM16_connection_info_1;
STATIC const LPDESC Desc32_connection_info_1 = REM32_connection_info_1;


NTSTATUS
XsNetConnectionEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetConnectionEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_CONNECTION_ENUM parameters = Parameters;
    LPTSTR nativeQualifier = NULL;          // Native parameters
    LPVOID outBuffer = NULL;
    DWORD entriesRead;
    DWORD totalEntries;
    WORD bufferLength;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(CONNECTION) {
        NetpKdPrint(( "XsNetConnectionEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;

        }

        XsConvertTextParameter(
            nativeQualifier,
            (LPSTR)XsSmbGetPointer( &parameters->Qualifier )
            );

        bufferLength = SmbGetUshort( &parameters->BufLen );

        //
        // Make the local call.
        //

        status = NetConnectionEnum(
                     NULL,
                     nativeQualifier,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( bufferLength ),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetConnectionEnum: NetConnectionEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(CONNECTION) {
            NetpKdPrint(( "XsNetConnectionEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_connection_info_0;
            StructureDesc = Desc16_connection_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_connection_info_1;
            StructureDesc = Desc16_connection_info_1;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (DWORD)bufferLength,
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(CONNECTION) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( (entriesFilled < totalEntries) ||
             (bytesRequired > bufferLength) ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    bufferLength,
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeQualifier );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} //XsNetConnectionEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apigroup.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiGroup.c

Abstract:

    This module contains individual API handlers for the NetGroup APIs.

    SUPPORTED : NetGroupAdd, NetGroupAddUser, NetGroupDel, NetGroupDelUser,
                NetGroupEnum, NetGroupGetInfo, NetGroupGetUsers,
                NetGroupSetInfo, NetGroupSetUsers.

Author:

    Shanku Niyogi (w-shanku)    13-Mar-1991

Revision History:

--*/

//
// Group APIs are UNICODE only.
//

#ifndef UNICODE
#define UNICODE
#endif

#include "xactsrvp.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_group_info_0 = REM16_group_info_0;
STATIC const LPDESC Desc32_group_info_0 = REM32_group_info_0;
STATIC const LPDESC Desc16_group_info_1 = REM16_group_info_1;
STATIC const LPDESC Desc32_group_info_1 = REM32_group_info_1;
STATIC const LPDESC Desc16_group_info_1_setinfo = REM16_group_info_1_setinfo;
STATIC const LPDESC Desc32_group_info_1_setinfo = REM32_group_info_1_setinfo;
STATIC const LPDESC Desc16_group_users_info_0 = REM16_group_users_info_0;
STATIC const LPDESC Desc32_group_users_info_0 = REM32_group_users_info_0;
STATIC const LPDESC Desc16_group_users_info_0_set
                        = REM16_group_users_info_0_set;
STATIC const LPDESC Desc32_group_users_info_0_set
                        = REM32_group_users_info_0_set;


NTSTATUS
XsNetGroupAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupAdd: header at %lx, params at %lx, "
                      "level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Use the requested level to determine the format of the destination
        // 32-bit structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:
            StructureDesc = Desc16_group_info_0;
            nativeStructureDesc = Desc32_group_info_0;
            break;

        case 1:
            StructureDesc = Desc16_group_info_1;
            nativeStructureDesc = Desc32_group_info_1;
            break;

        default:
            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;

        }

        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         nativeStructureDesc,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "XsNetGroupAdd: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     nativeStructureDesc,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAdd: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetGroupAdd(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAdd: NetGroupAdd failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetGroupAdd


NTSTATUS
XsNetGroupAddUser (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupAddUser.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_ADD_USER parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPTSTR nativeUserName = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );
        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Make the local call.
        //

        status = NetGroupAddUser(
                     NULL,
                     nativeGroupName,
                     nativeUserName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAddUser: NetGroupAddUser failed: %X\n",
                              status ));
            }
        }

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeGroupName );
    NetpMemoryFree( nativeUserName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetGroupAddUser


NTSTATUS
XsNetGroupDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_DEL parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupDel: header at %lx, params at %lx, name %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->GroupName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Make the local call.
        //

        status = NetGroupDel(
                     NULL,
                     nativeGroupName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupDel: NetGroupDel failed: %X\n", status ));
            }
        }

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeGroupName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetGroupDel


NTSTATUS
XsNetGroupDelUser (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupDelUser.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_DEL_USER parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPTSTR nativeUserName = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );
        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Make the local call.
        //

        status = NetGroupDelUser(
                     NULL,
                     nativeGroupName,
                     nativeUserName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupDelUser: NetGroupDelUser failed: %X\n",
                              status ));
            }
        }

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeGroupName );
    NetpMemoryFree( nativeUserName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetGroupDelUser


NTSTATUS
XsNetGroupEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;                 // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetGroupEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetGroupEnum: NetGroupEnum failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "XsNetGroupEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_group_info_0;
            StructureDesc = Desc16_group_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_group_info_1;
            StructureDesc = Desc16_group_info_1;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetGroupEnum


NTSTATUS
XsNetGroupGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_GET_INFO parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Make the local call.
        //

        status = NetGroupGetInfo(
                     NULL,
                     nativeGroupName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetGroupGetInfo: NetGroupGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_group_info_0;
            StructureDesc = Desc16_group_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_group_info_1;
            StructureDesc = Desc16_group_info_1;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupGetInfo: Buffer too small %ld s.b. %ld.\n",
                    SmbGetUshort( &parameters->BufLen ),
                    RapStructureSize(
                        StructureDesc,
                        Response,
                        FALSE ) ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetGroupGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeGroupName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetGroupGetInfo


NTSTATUS
XsNetGroupGetUsers (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupGetUsers.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;
    PXS_NET_GROUP_GET_USERS parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPVOID outBuffer= NULL;
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupGetUsers: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Make the local call.
        //

        status = NetGroupGetUsers(
                     NULL,
                     nativeGroupName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetGroupGetUsers: NetGroupGetUsers failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "XsNetGroupGetUsers: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Do the conversion from 32- to 16-bit data.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            Desc32_group_users_info_0,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            Desc16_group_users_info_0,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If there is no room for one fixed structure, return NERR_BufTooSmall.
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. GROUP_USERS_INFO_0 structures don't
        // need to be packed, because they have no variable data.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 Desc16_group_users_info_0,
                 FALSE  // not in native format
                 )) {

            Header->Status = NERR_BufTooSmall;

        } else if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeGroupName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        Desc16_group_users_info_0,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetGroupGetUsers


NTSTATUS
XsNetGroupSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_SET_INFO parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPVOID buffer = NULL;

    WORD fieldIndex;                        // Conversion variables
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Translate parmnum to a field number.
        //

        fieldIndex = SmbGetUshort( &parameters->ParmNum );
        fieldIndex = ( fieldIndex == PARMNUM_ALL ) ?
                         PARMNUM_ALL : fieldIndex + 1;

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     fieldIndex,
                     TRUE,
                     TRUE,
                     Desc16_group_info_1,
                     Desc32_group_info_1,
                     Desc16_group_info_1_setinfo,
                     Desc32_group_info_1_setinfo,
                     (LPBYTE *)&buffer,
                     NULL
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetInfo: Problem with conversion: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Do the actual local call.
        //

        status = NetGroupSetInfo(
                     NULL,
                     nativeGroupName,
                     XsLevelFromParmNum( SmbGetUshort( &parameters->Level ),
                                             SmbGetUshort( &parameters->ParmNum )),
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetInfo: NetGroupSetInfo failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    NetpMemoryFree( nativeGroupName );

    return STATUS_SUCCESS;

} // XsNetGroupSetInfo


NTSTATUS
XsNetGroupSetUsers (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupSetUsers.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_SET_USERS parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPBYTE actualBuffer = NULL;
    DWORD userCount;

    LPBYTE stringLocation = NULL;           // Conversion variables
    LPVOID buffer = NULL;
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD bufferSize;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupSetUsers: header at %lx, params at %lx,"
                      "level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_group_users_info_0_set;
        AuxStructureDesc = Desc16_group_users_info_0;

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Use the count of group_users_info_0 structures to form a long
        // descriptor string which can be used to do all the conversion
        // in one pass.
        //

        userCount = (DWORD)SmbGetUshort( &parameters->Entries );

        longDescriptor = NetpMemoryAllocate(
                             strlen( StructureDesc )
                             + strlen( AuxStructureDesc ) * userCount
                             + 1 );
        longNativeDescriptor = NetpMemoryAllocate(
                                   strlen( Desc32_group_users_info_0_set )
                                   + strlen( Desc32_group_users_info_0 ) * userCount
                                   + 1 );

        if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: failed to allocate memory" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        strcpy( longDescriptor, StructureDesc );
        strcpy( longNativeDescriptor, Desc32_group_users_info_0_set );
        for ( i = 0; i < userCount; i++ ) {
            strcat( longDescriptor, AuxStructureDesc );
            strcat( longNativeDescriptor, Desc32_group_users_info_0 );
        }

        //
        // Figure out if there is enough room in the buffer for all this
        // data. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 longDescriptor,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         longDescriptor,
                         longNativeDescriptor,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "XsNetGroupSetUsers: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     longDescriptor,
                     TRUE,
                     buffer,
                     buffer,
                     longNativeDescriptor,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Check if we got all the entries. If not, we'll quit.
        //

        if ( RapAuxDataCount( buffer, Desc32_group_users_info_0_set, Both, TRUE )
                 != userCount ) {

             Header->Status = NERR_BufTooSmall;
             goto cleanup;
        }

        //
        // If there are no entries, there's no data. Otherwise, the data comes
        // after an initial header structure.
        //

        if ( userCount > 0 ) {

            actualBuffer = (LPBYTE)buffer + RapStructureSize(
                                                Desc32_group_users_info_0_set,
                                                Both,
                                                TRUE
                                                );

        } else {

            actualBuffer = NULL;
        }

        //
        // Make the local call.
        //

        status = NetGroupSetUsers(
                     NULL,
                     nativeGroupName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     actualBuffer,
                     userCount
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: NetGroupSetUsers failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeGroupName );
    NetpMemoryFree( buffer );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );

    return STATUS_SUCCESS;

} // XsNetGroupSetUsers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apimsg.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiMsg.c

Abstract:

    This module contains individual API handlers for the NetMessage APIs.

    SUPPORTED - NetMessageBufferSend, NetMessageNameAdd, NetMessageNameDel,
                NetMessageNameEnum, NetMessageNameGetInfo.

Author:

    Shanku Niyogi (w-shanku)    8-Mar-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_msg_info_0 = REM16_msg_info_0;
STATIC const LPDESC Desc32_msg_info_0 = REM32_msg_info_0;
STATIC const LPDESC Desc16_msg_info_1 = REM16_msg_info_1;
STATIC const LPDESC Desc32_msg_info_1 = REM32_msg_info_1;


NTSTATUS
XsNetMessageBufferSend (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageBufferSend.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_BUFFER_SEND parameters = Parameters;
    LPTSTR nativeRecipient = NULL;          // Native parameters
    LPBYTE nativeBuffer = NULL;
    DWORD nativeBufLen;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageBufferSend: header at %lx, params at %lx, "
                      "recipient %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->Recipient )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeRecipient,
            (LPSTR)XsSmbGetPointer( &parameters->Recipient )
            );

        //
        // NetMessageBufferSend has an ASCII data buffer. Convert this to
        // Unicode if necessary. 
        //

#ifdef UNICODE

        nativeBufLen = SmbGetUshort( &parameters->BufLen ) * sizeof(WCHAR);

        if (( nativeBuffer = NetpMemoryAllocate( nativeBufLen )) == NULL ) {

            status = NERR_NoRoom;
            goto cleanup;

        } else {

            XsCopyBufToTBuf(
                (LPBYTE)nativeBuffer,
                (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                (DWORD)SmbGetUshort( &parameters->BufLen )
                );

        }
#else

        nativeBuffer = (LPBYTE)SmbGetUlong( &parameters->Buffer );
        nativeBufLen = (DWORD)SmbGetUshort( &parameters->BufLen );

#endif // def UNICODE

        status = NetMessageBufferSend(
                     NULL,
                     nativeRecipient,
                     NULL,
                     nativeBuffer,
                     nativeBufLen
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetMessageBufferSend: NetMessageBufferSend "
                              "failed: %X\n", status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeRecipient );

#ifdef UNICODE
    NetpMemoryFree( nativeBuffer );
#endif // def UNICODE

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetMessageBufferSend


NTSTATUS
XsNetMessageNameAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageNameAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_NAME_ADD parameters = Parameters;
    LPTSTR nativeMessageName = NULL;        // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageNameDel: header at %lx, params at %lx, "
                      "name %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->MessageName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeMessageName,
            (LPSTR)XsSmbGetPointer( &parameters->MessageName )
            );

        //
        // NetMessageNameAdd has one useful parameter, MessageName, a string.
        // The other parameter, FwdAction, is ignored in NT, because forwarding
        // messages is not supported.
        //
        // Make the local call.
        //

        status = NetMessageNameAdd(
                     NULL,
                     nativeMessageName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetMessageNameAdd: NetMessageNameAdd "
                              "failed: %X\n", status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeMessageName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetMessageNameAdd


NTSTATUS
XsNetMessageNameDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageNameDel.

Arguments:

    Transaction - a pointer to a transaction block containing information
        about the API to process.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_NAME_DEL parameters = Parameters;
    LPTSTR nativeMessageName = NULL;        // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageNameDel: header at %lx, params at %lx, "
                      "name %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->MessageName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeMessageName,
            (LPSTR)XsSmbGetPointer( &parameters->MessageName )
            );

        //
        // NetMessageNameDel has only one useful parameter, MessageName, which is
        // a string. The other parameter, FwdAction, is ignored, because NT does
        // not support message forwarding.
        //
        // Make the local call.
        //

        status = NetMessageNameDel(
                     NULL,
                     nativeMessageName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetMessageNameDel: NetMessageNameDel failed: "
                              "%X\n", status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeMessageName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetMessageNameDel


NTSTATUS
XsNetMessageNameEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageNameEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_NAME_ENUM parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageNameEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Get the actual information from the local 32-bit call.
        //

        status = NetMessageNameEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetMessageNameEnum: NetMessageNameEnum failed:"
                              " %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(MESSAGE) {
            NetpKdPrint(( "XsNetMessageNameEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_msg_info_0;
            StructureDesc = Desc16_msg_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_msg_info_1;
            StructureDesc = Desc16_msg_info_1;
            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(MESSAGE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. MSG_INFO_x structures have no
        // data to pack.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetMessageNameEnum


NTSTATUS
XsNetMessageNameGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageNameGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_NAME_GET_INFO parameters = Parameters;
    LPTSTR nativeMessageName = NULL;        // Native parameters
    LPVOID outBuffer = NULL;

    DWORD bytesRequired = 0;                // Conversion variables
    LPBYTE stringLocation = NULL;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageNameGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeMessageName,
            (LPSTR)XsSmbGetPointer( &parameters->MessageName )
            );

        //
        // Do the actual local call.
        //

        status = NetMessageNameGetInfo(
                     NULL,
                     nativeMessageName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetMessageNameGetInfo: "
                              "NetMessageNameGetInfo failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_msg_info_0;
            StructureDesc = Desc16_msg_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_msg_info_1;
            StructureDesc = Desc16_msg_info_1;
            break;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetMessageNameGetInfo: "
                              "RapConvertSingleEntry failed: %X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(MESSAGE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer. msg_info_x
        // structures have no data to pack.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetMessageNameGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeMessageName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetMessageNameGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apipath.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiPath.c

Abstract:

    This module contains individual API handlers for the NetName and
    NetPath APIs.

    SUPPORTED : I_NetNameCanonicalize, I_NetNameCompare, I_NetNameValidate,
                I_NetPathCanonicalize, I_NetPathCompare, I_NetPathType.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991
    Jim Waters (t-jamesw) 6-Aug-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Needed for canonicalization routine prototypes.
//

#include <icanon.h>


NTSTATUS
XsI_NetNameCanonicalize (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetI_NetNameCanonicalize.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_NAME_CANONICALIZE parameters = Parameters;
    LPTSTR nativeName = NULL;               // Native parameters
    LPTSTR outBuffer = NULL;
    DWORD outBufLen;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetNameCanonicalize: header at %lx, params at %lx\n",
                      Header, parameters ));
    }


    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeName,
        (LPSTR)XsSmbGetPointer( &parameters->Name )
        );

    //
    // Allocate local buffer, accounting for possible differences in
    // character size.
    //

    outBufLen = (DWORD)STRING_SPACE_REQD(
                           SmbGetUshort( &parameters->OutbufLen ));

    if (( outBuffer = NetpMemoryAllocate( outBufLen )) == NULL ) {
        status = NERR_NoRoom;
        goto cleanup;
    }

    //
    // Make the local call.
    //

    status = I_NetNameCanonicalize(
        NULL,
        nativeName,
        outBuffer,
        outBufLen,
        (DWORD)SmbGetUshort( &parameters->NameType ),
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetNameCanonicalize: "
                          "NetNameCanonicalize failed: %X\n", status ));
        }
        goto cleanup;
    }

    //
    // Copy return buffer, possibly translating from Unicode.
    //

    NetpCopyTStrToStr( (LPSTR)XsSmbGetPointer( &parameters->Outbuf ), outBuffer );

cleanup:

    NetpMemoryFree( nativeName );
    NetpMemoryFree( outBuffer );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsI_NetNameCanonicalize


NTSTATUS
XsI_NetNameCompare (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetNameCompare.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_NAME_COMPARE parameters = Parameters;
    LPTSTR nativeName1 = NULL;              // Native parameters
    LPTSTR nativeName2 = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetNameCompare: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeName1,
        (LPSTR)XsSmbGetPointer( &parameters->Name1 )
        );

    XsConvertTextParameter(
        nativeName2,
        (LPSTR)XsSmbGetPointer( &parameters->Name2 )
        );

    //
    // Make the local call.
    //

    status = I_NetNameCompare(
        NULL,
        nativeName1,
        nativeName2,
        (DWORD)SmbGetUshort( &parameters->NameType ),
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetNameCompare: NetNameCompare failed: "
                          "%X\n", status));
        }
    }

cleanup:

    NetpMemoryFree( nativeName1 );
    NetpMemoryFree( nativeName2 );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsI_NetNameCompare


NTSTATUS
XsI_NetNameValidate (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetNameValidate.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_NAME_VALIDATE parameters = Parameters;
    LPTSTR nativeName = NULL;               // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetNameValidate: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    try {

        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeName,
            (LPSTR)XsSmbGetPointer( &parameters->Name )
            );

        //
        // Make the local call.
        //

        status = I_NetNameValidate(
            NULL,
            nativeName,
            (DWORD)SmbGetUshort( &parameters->NameType ),
            (DWORD)SmbGetUlong( &parameters->Flags )
            );

        if ( !XsApiSuccess(status) ) {

            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsI_NetPathType: NetPathType failed: %X\n", status));
            }
        }

    cleanup:
        Header->Status = (WORD)status;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if (nativeName != NULL) {
        NetpMemoryFree( nativeName );
    }

    return STATUS_SUCCESS;

} // XsI_NetNameValidate


NTSTATUS
XsI_NetPathCanonicalize (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetPathCanonicalize.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_PATH_CANONICALIZE parameters = Parameters;
    LPTSTR nativePathName = NULL;           // Native parameters
    LPTSTR outBuffer = NULL;
    DWORD outBufLen;
    LPTSTR nativePrefix = NULL;
    DWORD pathType = 0;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetPathCanonicalize: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativePathName,
        (LPSTR)XsSmbGetPointer( &parameters->PathName )
        );

    XsConvertTextParameter(
        nativePrefix,
        (LPSTR)XsSmbGetPointer( &parameters->Prefix )
        );

    //
    // Get a copy of the input path type.
    //

    pathType = SmbGetUlong( &parameters->PathType );

    //
    // Allocate local buffer, accounting for possible differences in
    // character size.
    //

    outBufLen = (DWORD)STRING_SPACE_REQD(
                           SmbGetUshort( &parameters->OutbufLen ));

    if (( outBuffer = (LPTSTR)NetpMemoryAllocate( outBufLen )) == NULL ) {
        status = NERR_NoRoom;
        goto cleanup;
    }

    //
    // Make the local call.
    //

    status = I_NetPathCanonicalize(
        NULL,
        nativePathName,
        outBuffer,
        outBufLen,
        nativePrefix,
        &pathType,
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetPathCanonicalize: "
                          "NetPathCanonicalize failed: %X\n", status));
        }
        goto cleanup;
    }

    //
    // Copy return buffer, possibly translating from Unicode.
    //

    NetpCopyTStrToStr( (LPSTR)XsSmbGetPointer( &parameters->Outbuf ), outBuffer );

cleanup:

    //
    // Fill return parameter.
    //

    SmbPutUlong( &parameters->PathTypeOut, pathType );

    Header->Status = (WORD)status;

    NetpMemoryFree( nativePathName );
    NetpMemoryFree( nativePrefix );
    NetpMemoryFree( outBuffer );

    return STATUS_SUCCESS;

} // XsI_NetPathCanonicalize


NTSTATUS
XsI_NetPathCompare (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetPathCompare.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_PATH_COMPARE parameters = Parameters;
    LPTSTR nativePathName1 = NULL;          // Native parameters
    LPTSTR nativePathName2 = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetPathCompare: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativePathName1,
        (LPSTR)XsSmbGetPointer( &parameters->PathName1 )
        );

    XsConvertTextParameter(
        nativePathName2,
        (LPSTR)XsSmbGetPointer( &parameters->PathName2 )
        );

    //
    // Make the local call.
    //

    status = I_NetPathCompare(
        NULL,
        nativePathName1,
        nativePathName2,
        (DWORD)SmbGetUlong( &parameters->PathType ),
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetPathCompare: NetPathCompare failed: "
                          "%X\n", status));
        }
    }

cleanup:

    NetpMemoryFree( nativePathName1 );
    NetpMemoryFree( nativePathName2 );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsI_NetPathCompare


NTSTATUS
XsI_NetPathType (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetPathType.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_PATH_TYPE parameters = Parameters;
    LPTSTR nativePathName = NULL;           // Native parameters
    DWORD pathType;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetPathType: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativePathName,
        (LPSTR)XsSmbGetPointer( &parameters->PathName )
        );

    //
    // Make the local call.
    //

    status = I_NetPathType(
        NULL,
        nativePathName,
        &pathType,
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetPathType: NetPathType failed: %X\n", status));
        }
    }

    //
    // Fill in return values.
    //

    SmbPutUlong( &parameters->PathType, pathType );
    Header->Status = (WORD)status;

cleanup:

    NetpMemoryFree( nativePathName );

    return STATUS_SUCCESS;

} // XsI_NetPathType


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apilogon.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiLogon.c

Abstract:

    This module contains individual API handlers for the NetLogon APIs.

    SUPPORTED : NetGetDCName, NetLogonEnum, NetServerAuthenticate,
                NetServerPasswordSet, NetServerReqChallenge,
                NetWkstaUserLogoff, NetWkstaUserLogon.

    SEE ALSO : NetAccountDeltas, NetAccountSync - in ApiAcct.c.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991

Revision History:

--*/

//
// Logon APIs are Unicode only.
//

#ifndef UNICODE
#define UNICODE
#endif

#include "xactsrvp.h"
#include <netlibnt.h>

#include <crypt.h>     // must be included before <logonmsv.h>
#include <ntsam.h>     // must be included before <logonmsv.h>
#include <logonmsv.h>  // must be included before <ssi.h>
#include <ssi.h>       // I_NetAccountDeltas and I_NetAccountSync prototypes

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_user_logon_info_0 = REM16_user_logon_info_0;
STATIC const LPDESC Desc32_user_logon_info_0 = REM32_user_logon_info_0;
STATIC const LPDESC Desc16_user_logon_info_1 = REM16_user_logon_info_1;
STATIC const LPDESC Desc32_user_logon_info_1 = REM32_user_logon_info_1;
STATIC const LPDESC Desc16_user_logon_info_2 = REM16_user_logon_info_2;
STATIC const LPDESC Desc32_user_logon_info_2 = REM32_user_logon_info_2;
STATIC const LPDESC Desc16_user_logoff_info_1 = REM16_user_logoff_info_1;
STATIC const LPDESC Desc32_user_logoff_info_1 = REM32_user_logoff_info_1;


NTSTATUS
XsNetGetDCName (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGetDCName.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GET_DC_NAME parameters = Parameters;
    LPTSTR nativeDomain = NULL;             // Native parameters
    LPTSTR dcName = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeDomain,
            (LPSTR)XsSmbGetPointer( &parameters->Domain )
            );

        //
        // Make the local call.
        //

        status = NetGetDCName(
                     NULL,
                     nativeDomain,
                     (LPBYTE *)&dcName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGetDCName: NetGetDCName failed: %X\n",
                              status ));
            }
            goto cleanup;
        }

        //
        // Put string into buffer. Convert from Unicode if necessary.
        //

        if ( (DWORD)SmbGetUshort( &parameters->BufLen ) <= NetpUnicodeToDBCSLen( dcName )) {

            status = NERR_BufTooSmall;

        } else {

            NetpCopyWStrToStrDBCS( (LPSTR)XsSmbGetPointer( &parameters->Buffer ), dcName );

        }


        IF_DEBUG(LOGON) {
            NetpKdPrint(( "Name is %ws\n", dcName ));
        }

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }


    //
    // Set return data count.
    //

    if ( status == NERR_Success ) {
        SmbPutUshort( &parameters->BufLen, (USHORT)( STRLEN( dcName ) + 1 ));
    } else {
        SmbPutUshort( &parameters->BufLen, 0 );
    }


    Header->Status = (WORD)status;
    NetpMemoryFree( nativeDomain );
    NetApiBufferFree( dcName );

    return STATUS_SUCCESS;

} // XsNetGetDCName


NTSTATUS
XsNetLogonEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetLogonEnum.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_LOGON_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;
    DWORD entriesRead = 0;
    DWORD totalEntries = 0;

    DWORD entriesFilled = 0;
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;

    IF_DEBUG(LOGON) {
        NetpKdPrint(( "XsNetLogonEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if (( SmbGetUshort( &parameters->Level ) != 0 )
            && ( SmbGetUshort( &parameters->Level ) != 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

#ifdef LOGON_ENUM_SUPPORTED
        status = NetLogonEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );
#else // LOGON_ENUM_SUPPORTED
    status = NERR_InvalidAPI;
#endif // LOGON_ENUM_SUPPORTED

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetLogonEnum: NetLogonEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(LOGON) {
            NetpKdPrint(( "XsNetLogonEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_user_logon_info_0;
            StructureDesc = Desc16_user_logon_info_0;
            break;

        case 2:

            nativeStructureDesc = Desc32_user_logon_info_2;
            StructureDesc = Desc16_user_logon_info_2;
            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(LOGON) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetLogonEnum


NTSTATUS
XsNetServerAuthenticate (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerAuthenticate.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_SERVER_AUTHENTICATE parameters = Parameters;
    NET_API_STATUS status;                  // Native parameters
    LPTSTR nativeRequestor = NULL;
    NETLOGON_CREDENTIAL inCredential = {0};
    NETLOGON_CREDENTIAL outCredential = {0};
    WCHAR AccountName[MAX_PATH+1];

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeRequestor,
            (LPSTR)XsSmbGetPointer( &parameters->Requestor )
            );

        //
        // Copy the source credential, and zero out the destination
        // credential.
        //

        RtlCopyMemory(
                &inCredential,
                (PVOID)XsSmbGetPointer( &parameters->Caller ),
                sizeof(NETLOGON_CREDENTIAL)
                );

        RtlZeroMemory(
                &outCredential,
                sizeof(NETLOGON_CREDENTIAL)
                );

        //
        // Build the account name.
        //

        NetpNCopyTStrToWStr( AccountName, nativeRequestor, MAX_PATH );

        //
        // Make the local call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetServerAuthenticate(
                         NULL,
                         AccountName,
                         UasServerSecureChannel,
                         nativeRequestor,
                         &inCredential,
                         &outCredential
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerAuthenticate: I_NetServerAuthenticate "
                              "failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

cleanup:

        //
        // Set the return credential.
        //

        RtlCopyMemory(
                parameters->Primary,
                &outCredential,
                sizeof(NETLOGON_CREDENTIAL)
                );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeRequestor );

    return STATUS_SUCCESS;

} // XsNetServerAuthenticate


NTSTATUS
XsNetServerPasswordSet (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGetDCName.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_SERVER_PASSWORD_SET parameters = Parameters;
    NET_API_STATUS status;                  // Native parameters
    LPTSTR nativeRequestor = NULL;
    NETLOGON_AUTHENTICATOR authIn = {0};
    NETLOGON_AUTHENTICATOR authOut = {0};
    ENCRYPTED_LM_OWF_PASSWORD password;
    WCHAR AccountName[MAX_PATH+1];

    LPBYTE structure = NULL;                // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeRequestor,
            (LPSTR)XsSmbGetPointer( &parameters->Requestor )
            );

        //
        // Copy the source authenticator and password, and zero out the
        // destination authenticator.
        //

        structure = (LPBYTE)XsSmbGetPointer( &parameters->Authenticator );
        RtlCopyMemory(
                &authIn.Credential,
                structure,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        authIn.timestamp = SmbGetUlong( structure );

        RtlCopyMemory(
                &password,
                parameters->Password,
                sizeof(ENCRYPTED_LM_OWF_PASSWORD)
                );

        RtlZeroMemory(
                &authOut,
                sizeof(NETLOGON_CREDENTIAL)
                );


        //
        // Build the account name.
        //
        if( STRLEN( nativeRequestor ) >= MAX_PATH )
        {
            Header->Status = NERR_PasswordTooShort;
            goto cleanup;
        }

        // Make sure its NULL terminated
        AccountName[MAX_PATH] = L'\0';
        NetpNCopyTStrToWStr( AccountName, nativeRequestor, MAX_PATH );

        //
        // Make the local call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetServerPasswordSet(
                         NULL,
                         AccountName,
                         UasServerSecureChannel,
                         nativeRequestor,
                         &authIn,
                         &authOut,
                         &password
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerPasswordSet: "
                              "I_NetServerPasswordSet failed: %X\n",
                              status ));
            }

            //
            // !!! When protocol level is available in the header information,
            //     we can check it. Right now, we ignore this code.
            //
            // For clients older than LanMan 2.1, return a different error code.
            // LANMAN 2.1 Protocol Level is 6.
            //

#if 0
            if ( status == NERR_TimeDiffAtDC && Header->ProtocolLevel < 6 ) {
                status = NERR_SyncRequired;
            }
#endif

            Header->Status = (WORD)status;
            goto cleanup;
        }

cleanup:

        //
        // Fill in 16 bit return structures.
        //

        structure = parameters->RetAuth;
        RtlCopyMemory(
                structure,
                &authOut.Credential,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        SmbPutUlong( (LPDWORD)structure, authOut.timestamp );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeRequestor );

    return STATUS_SUCCESS;

} // XsNetServerPasswordSet


NTSTATUS
XsNetServerReqChallenge (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGetDCName.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_SERVER_REQ_CHALLENGE parameters = Parameters;
    NET_API_STATUS status;                  // Native parameters
    LPTSTR nativeRequestor = NULL;
    NETLOGON_CREDENTIAL inChallenge = {0};
    NETLOGON_CREDENTIAL outChallenge = {0};

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeRequestor,
            (LPSTR)XsSmbGetPointer( &parameters->Requestor )
            );

        //
        // Copy the source challenge, and zero out the destination
        // challenge.
        //

        RtlCopyMemory(
                &inChallenge,
                (PVOID)XsSmbGetPointer( &parameters->Caller ),
                sizeof(NETLOGON_CREDENTIAL)
                );

        RtlZeroMemory(
                &outChallenge,
                sizeof(NETLOGON_CREDENTIAL)
                );


        //
        // Make the local call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetServerReqChallenge(
                         NULL,
                         nativeRequestor,
                         &inChallenge,
                         &outChallenge
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerReqChallenge: "
                              "I_NetServerReqChallenge failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

cleanup:

        //
        // Set the return credential.
        //

        RtlCopyMemory(
                parameters->Primary,
                &outChallenge,
                sizeof(NETLOGON_CREDENTIAL)
                );
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeRequestor );

    return STATUS_SUCCESS;

} // XsNetServerReqChallenge


NTSTATUS
XsNetWkstaUserLogoff (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This temporary routine just returns STATUS_NOT_IMPLEMENTED.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_WKSTA_USER_LOGOFF parameters = Parameters;
    LPWSTR machineName = NULL;              // Native parameters
    LPWSTR userName = NULL;
    NETLOGON_LOGOFF_UAS_INFORMATION buffer;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    PWKSTA_16_USER_LOGOFF_REQUEST_1 usrLogoffReq =
        (PWKSTA_16_USER_LOGOFF_REQUEST_1)parameters->InBuf;
    PUSER_16_LOGOFF_INFO_1 logoffInfo;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertUnicodeTextParameter(
            userName,
            (LPSTR)( usrLogoffReq->wlreq1_name )
            );

        XsConvertUnicodeTextParameter(
            machineName,
            (LPSTR)( usrLogoffReq->wlreq1_workstation )
            );

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make sure the workstation name in the logon request is the
        // name of the workstation from which the request came.
        //

        if ( wcscmp( machineName, Header->ClientMachineName ) ) {

            Header->Status = (WORD)ERROR_ACCESS_DENIED;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = I_NetLogonUasLogoff(
                     userName,
                     machineName,
                     &buffer
                     );

        if ( !XsApiSuccess(status)) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: I_NetLogonUasLogoff "
                              "failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->OutBuf )
                                    + SmbGetUshort( &parameters->OutBufLen ) );

        status = RapConvertSingleEntry(
                     (LPBYTE)&buffer,
                     Desc32_user_logoff_info_1,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->OutBuf ),
                     (LPBYTE)XsSmbGetPointer( &parameters->OutBuf ),
                     Desc16_user_logoff_info_1,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: RapConvertSingleEntry "
                              "failed: %X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(LOGON) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          &buffer, SmbGetUlong( &parameters->OutBuf ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        // The user_logoff_info_1 structure has no variable data to pack,
        // but we do need to fill in the code field of the return structure.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->OutBufLen ),
                 Desc16_user_logoff_info_1,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters->OutBufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;
        }

        if ( SmbGetUshort( &parameters->OutBufLen ) > sizeof(WORD)) {

            logoffInfo = (PUSER_16_LOGOFF_INFO_1)XsSmbGetPointer(
                                                     &parameters->OutBuf );
            SmbPutUshort( &logoffInfo->usrlogf1_code, VALID_LOGOFF );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }


    NetpMemoryFree( userName );
    NetpMemoryFree( machineName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->OutBufLen,
        Desc16_user_logoff_info_1,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetWkstaUserLogoff


NTSTATUS
XsNetWkstaUserLogon (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetWkstaUserLogon.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;
    PXS_NET_WKSTA_USER_LOGON parameters = Parameters;
    LPWSTR machineName = NULL;              // Native parameters
    LPWSTR userName = NULL;
    PNETLOGON_VALIDATION_UAS_INFO buffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    PWKSTA_16_USER_LOGON_REQUEST_1 usrLogonReq =
        (PWKSTA_16_USER_LOGON_REQUEST_1)parameters->InBuf;
    PUSER_16_LOGON_INFO_1 logonInfo;


    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertUnicodeTextParameter(
            userName,
            (LPSTR)( usrLogonReq->wlreq1_name )
            );

        XsConvertUnicodeTextParameter(
            machineName,
            (LPSTR)( usrLogonReq->wlreq1_workstation )
            );

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make sure the workstation name in the logon request is the
        // name of the workstation from which the request came.
        //

        if ( wcscmp( machineName, Header->ClientMachineName ) ) {

            Header->Status = (WORD)ERROR_ACCESS_DENIED;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = I_NetLogonUasLogon(
                     userName,
                     machineName,
                     &buffer
                     );

        if ( !XsApiSuccess ( status )) {

            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogon: I_NetLogonUasLogon failed: "
                              "%X\n", status));
            }
            Header->Status = (WORD) status;
            goto cleanup;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->OutBuf )
                                    + SmbGetUshort( &parameters->OutBufLen ) );

        status = RapConvertSingleEntry(
                     (LPBYTE)buffer,
                     Desc32_user_logon_info_1,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->OutBuf ),
                     (LPBYTE)XsSmbGetPointer( &parameters->OutBuf ),
                     Desc16_user_logon_info_1,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogon: RapConvertSingleEntry "
                              "failed: %X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(LOGON) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          buffer, SmbGetUlong( &parameters->OutBuf ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        // The user_logoff_info_1 structure has no variable data to pack,
        // but we do need to fill in the code field of the return structure.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->OutBufLen ),
                 Desc16_user_logon_info_1,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogon: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters->OutBufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->OutBuf ),
                                    SmbGetUshort( &parameters->OutBufLen ),
                                    Desc16_user_logon_info_1,
                                    1
                                    );
        }

        if ( SmbGetUshort( &parameters->OutBufLen ) > sizeof(WORD)) {

            logonInfo = (PUSER_16_LOGON_INFO_1)XsSmbGetPointer(
                                                     &parameters->OutBuf );
            SmbPutUshort( &logonInfo->usrlog1_code, VALIDATED_LOGON );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }


    NetpMemoryFree( userName );
    NetpMemoryFree( machineName );
    if ( buffer != NULL ) {
        NetApiBufferFree( buffer );
    }

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->OutBufLen,
        Desc16_user_logon_info_1,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetWkstaUserLogon
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apiprint.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ApiPrint.c

Abstract:

    This module contains individual API handlers for the DosPrint APIs.

    SUPPORTED : DosPrintDestAdd, DosPrintDestControl, DosPrintDestDel,
                DosPrintDestEnum, DosPrintDestGetInfo, DosPrintDestSetInfo,
                DosPrintJobContinue, DosPrintJobDel, DosPrintJobEnum,
                DosPrintJobGetId, DosPrintJobGetInfo, DosPrintJobPause,
                DosPrintJobSetInfo, DosPrintQAdd, DosPrintQContinue,
                DosPrintQDel, DosPrintQEnum, DosPrintQGetInfo,
                DosPrintQPause, DosPrintQPurge, DosPrintQSetInfo.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991

Revision History:

    18-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
        Use FORMAT_ equates.
    01-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo(from downlevel) level 3, rc=124.  (4&5 too.)

--*/

#include "XactSrvP.h"
#include <dosprint.h>

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_print_dest_0 = REM16_print_dest_0;
STATIC const LPDESC Desc32_print_dest_0 = REM32_print_dest_0;
STATIC const LPDESC Desc16_print_dest_1 = REM16_print_dest_1;
STATIC const LPDESC Desc32_print_dest_1 = REM32_print_dest_1;
STATIC const LPDESC Desc16_print_dest_2 = REM16_print_dest_2;
STATIC const LPDESC Desc32_print_dest_2 = REM32_print_dest_2;
STATIC const LPDESC Desc16_print_dest_3 = REM16_print_dest_3;
STATIC const LPDESC Desc32_print_dest_3 = REM32_print_dest_3;
STATIC const LPDESC Desc16_print_dest_3_setinfo = REM16_print_dest_3_setinfo;
STATIC const LPDESC Desc32_print_dest_3_setinfo = REM32_print_dest_3_setinfo;
STATIC const LPDESC Desc16_print_job_0 = REM16_print_job_0;
STATIC const LPDESC Desc32_print_job_0 = REM32_print_job_0;
STATIC const LPDESC Desc16_print_job_1 = REM16_print_job_1;
STATIC const LPDESC Desc32_print_job_1 = REM32_print_job_1;
STATIC const LPDESC Desc16_print_job_1_setinfo = REM16_print_job_1_setinfo;
STATIC const LPDESC Desc32_print_job_1_setinfo = REM32_print_job_1_setinfo;
STATIC const LPDESC Desc16_print_job_2 = REM16_print_job_2;
STATIC const LPDESC Desc32_print_job_2 = REM32_print_job_2;
STATIC const LPDESC Desc16_print_job_3 = REM16_print_job_3;
STATIC const LPDESC Desc32_print_job_3 = REM32_print_job_3;
STATIC const LPDESC Desc16_print_job_3_setinfo = REM16_print_job_3_setinfo;
STATIC const LPDESC Desc32_print_job_3_setinfo = REM32_print_job_3_setinfo;
STATIC const LPDESC Desc16_printQ_0 = REM16_printQ_0;
STATIC const LPDESC Desc32_printQ_0 = REM32_printQ_0;
STATIC const LPDESC Desc16_printQ_1 = REM16_printQ_1;
STATIC const LPDESC Desc32_printQ_1 = REM32_printQ_1;
STATIC const LPDESC Desc16_printQ_1_setinfo = REM16_printQ_1_setinfo;
STATIC const LPDESC Desc32_printQ_1_setinfo = REM32_printQ_1_setinfo;
STATIC const LPDESC Desc16_printQ_2 = REM16_printQ_2;
STATIC const LPDESC Desc32_printQ_2 = REM32_printQ_2;
STATIC const LPDESC Desc16_printQ_3 = REM16_printQ_3;
STATIC const LPDESC Desc32_printQ_3 = REM32_printQ_3;
STATIC const LPDESC Desc16_printQ_3_setinfo = REM16_printQ_3_setinfo;
STATIC const LPDESC Desc32_printQ_3_setinfo = REM32_printQ_3_setinfo;
STATIC const LPDESC Desc16_printQ_4 = REM16_printQ_4;
STATIC const LPDESC Desc32_printQ_4 = REM32_printQ_4;
STATIC const LPDESC Desc16_printQ_5 = REM16_printQ_5;
STATIC const LPDESC Desc32_printQ_5 = REM32_printQ_5;
STATIC const LPDESC Desc16_printQ_52 = REM16_printQ_52;
STATIC const LPDESC Desc32_printQ_52 = REM32_printQ_52;

//
// DosPrint calls behave differently from Net api calls.  On Net api calls,
// the called routine supplies the buffer to us.  DosPrint apis need a
// supplied buffer and thus can return NERR_BufferTooSmall which means
// it's an error but return the bytes needed if it's a XXGetInfo call.
//

#define XsPrintApiSuccess( Status ) \
    (( (Status) == NERR_Success ) || ( (Status) == ERROR_MORE_DATA ))

//
// Now that servers can have multiple names (See SrvNetTransportAdd, and clusters),
//  it is necessary to transmit the server name part of a queue name to the spooler.
//  The following three macros aid in the translation.
//
#define  PREPARE_CONVERT_QUEUE_NAME()                                           \
    WCHAR queueNameBuf[ MAX_PATH ];                                             \
    CHAR localComputerName[ NETBIOS_NAME_LEN ];                                 \
    DWORD localComputerNameLen = sizeof( localComputerName );                   \
    PUCHAR p = &Header->ServerName[ NETBIOS_NAME_LEN-2 ];                       \
    for( ; p > Header->ServerName && *p == ' '; p-- );                          \
    p++;                                                                        \
    GetComputerNameA( localComputerName, &localComputerNameLen );

#define CONVERT_QUEUE_NAME( queue )                                             \
    if( queue && ((DWORD)(p-Header->ServerName) != localComputerNameLen ||      \
        memcmp( localComputerName, Header->ServerName, localComputerNameLen )) &&\
        mbstowcs( NULL, Header->ServerName, (size_t)(p-Header->ServerName )) <= \
        sizeof( queueNameBuf ) - wcslen(queue)*sizeof(WCHAR) - 4*sizeof(WCHAR)){\
                                                                                \
        RtlZeroMemory( queueNameBuf, sizeof( queueNameBuf ) );                  \
        queueNameBuf[0] = queueNameBuf[1] = L'\\';                              \
        mbstowcs( queueNameBuf+2, Header->ServerName,                           \
                                  (size_t)(p-Header->ServerName) );             \
        wcscat( queueNameBuf, L"\\" );                                          \
        wcscat( queueNameBuf, queue );                                          \
        NetApiBufferFree( queue );                                              \
        queue = queueNameBuf;                                                   \
    }

#define FREE_QUEUE_NAME( queue ) if( queue != queueNameBuf ) NetApiBufferFree( queue )

#define GET_LOCAL_SERVER_NAME()                                                 \
    WCHAR LocalServerName[ MAX_PATH ];                                          \
    PUCHAR p = &Header->ServerName[ NETBIOS_NAME_LEN-2 ];                       \
    for( ; p > Header->ServerName && *p == ' '; p-- );                          \
    p++;                                                                        \
    LocalServerName[0] = LocalServerName[1] = L'\\';                            \
    mbstowcs( LocalServerName+2, Header->ServerName,                            \
                                 (size_t)(p-Header->ServerName) );              \
    LocalServerName[2+p-Header->ServerName] = L'\0';



NTSTATUS
XsNetPrintDestAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestAdd: header at " FORMAT_LPVOID
                      ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD "\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 3 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_print_dest_3;

        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         Desc32_print_dest_3,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintDestAdd: buffer of " FORMAT_DWORD " bytes at " FORMAT_LPVOID "\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     Desc32_print_dest_3,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestAdd: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintDestAdd(
                     NULL,
                     SmbGetUshort( &parameters->Level ),
                     buffer,
                     (WORD)bufferSize
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestAdd: DosPrintDestAdd failed: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetPrintDestAdd


NTSTATUS
XsNetPrintDestControl (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestControl.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_CONTROL parameters = Parameters;
    LPTSTR nativeDestName = NULL;           // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestControl: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->DestName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeDestName,
            (LPSTR)XsSmbGetPointer( &parameters->DestName )
            );

        CONVERT_QUEUE_NAME( nativeDestName );

        //
        // Make the local call.
        //
        status = DosPrintDestControl(
                     NULL,
                     nativeDestName,
                     SmbGetUshort( &parameters->Control )
                     );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintDestControl: DosPrintDestControl failed: "
                          FORMAT_API_STATUS "\n", status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativeDestName );

    return STATUS_SUCCESS;

} // XsNetPrintDestControl


NTSTATUS
XsNetPrintDestDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_DEL parameters = Parameters;
    LPTSTR nativePrinterName = NULL;        // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestDel: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->PrinterName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativePrinterName,
            (LPSTR)XsSmbGetPointer( &parameters->PrinterName )
            );

        CONVERT_QUEUE_NAME( nativePrinterName );

        //
        // Make the local call.
        //

        status = DosPrintDestDel(
                     NULL,
                     nativePrinterName
                     );
cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintDestDel: DosPrintDestDel failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativePrinterName );
    return STATUS_SUCCESS;

} // XsNetPrintDestDel


NTSTATUS
XsNetPrintDestEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;                 // Native parameters
    DWORD outBufferSize;
    DWORD entriesRead = 0;
    DWORD totalEntries = 0;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestEnum: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD ", buf size " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ));
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestEnum: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintDestEnum(
                     NULL,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     (LPWORD)&entriesRead,
                     (LPWORD)&totalEntries
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintDestEnum: DosPrintDestEnum failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintDestEnum: received " FORMAT_DWORD " entries at " FORMAT_LPVOID "\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_print_dest_0;
            StructureDesc = Desc16_print_dest_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_print_dest_1;
            StructureDesc = Desc16_print_dest_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_print_dest_2;
            StructureDesc = Desc16_print_dest_2;
            break;

        case 3:

            nativeStructureDesc = Desc32_print_dest_3;
            StructureDesc = Desc16_print_dest_3;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR,"
                          " Entries " FORMAT_DWORD " of " FORMAT_DWORD "\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->Returned, (WORD)entriesFilled );
        SmbPutUshort( &parameters->Total, (WORD)totalEntries );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintDestEnum


NTSTATUS
XsNetPrintDestGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_GET_INFO parameters = Parameters;
    LPTSTR nativeName = NULL;               // Native parameters
    LPVOID outBuffer = NULL;
    DWORD outBufferSize;
    WORD bytesNeeded = 0;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestGetInfo: header at " FORMAT_LPVOID ", "
                      "params at " FORMAT_LPVOID ", level " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeName,
            (LPSTR)XsSmbGetPointer( &parameters->Name )
            );

        CONVERT_QUEUE_NAME( nativeName );

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ));
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestGetInfo: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintDestGetInfo(
                     NULL,
                     nativeName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     &bytesNeeded
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintDestGetInfo: DosPrintDestGetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_print_dest_0;
            StructureDesc = Desc16_print_dest_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_print_dest_1;
            StructureDesc = Desc16_print_dest_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_print_dest_2;
            StructureDesc = Desc16_print_dest_2;
            break;

        case 3:

            nativeStructureDesc = Desc32_print_dest_3;
            StructureDesc = Desc16_print_dest_3;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsDosPrintDestGetInfo: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        bytesNeeded = (WORD)bytesRequired;

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->Needed, bytesNeeded );

    NetApiBufferFree( outBuffer );
    FREE_QUEUE_NAME( nativeName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintDestGetInfo


NTSTATUS
XsNetPrintDestSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_SET_INFO parameters = Parameters;
    LPTSTR nativeName = NULL;               // Native parameters
    LPVOID buffer = NULL;
    DWORD bytesRequired;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 3 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_print_dest_3;

        XsConvertTextParameter(
            nativeName,
            (LPSTR)XsSmbGetPointer( &parameters->Name )
            );

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     SmbGetUshort( &parameters->ParmNum ),
                     FALSE,
                     TRUE,
                     StructureDesc,
                     Desc32_print_dest_3,
                     Desc16_print_dest_3_setinfo,
                     Desc32_print_dest_3_setinfo,
                     (LPBYTE *)&buffer,
                     &bytesRequired
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestSetInfo: Problem with conversion: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        CONVERT_QUEUE_NAME( nativeName );

        //
        // Do the actual local call.
        //

        status = DosPrintDestSetInfo(
                     NULL,
                     nativeName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)buffer,
                     (WORD)bytesRequired,
                     SmbGetUshort( &parameters->ParmNum )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestSetInfo: DosPrintDestSetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    FREE_QUEUE_NAME( nativeName );

    return STATUS_SUCCESS;

} // XsNetPrintDestSetInfo


NTSTATUS
XsNetPrintJobContinue (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobContinue.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_CONTINUE parameters = Parameters;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobContinue: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "job " FORMAT_WORD_ONLY "\n",
                      Header, parameters, SmbGetUshort( &parameters->JobId )));
    }

    try {
        //
        // Make the local call.
        //

        status = DosPrintJobContinue(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobContinue: DosPrintJobContinue failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetPrintJobContinue


NTSTATUS
XsNetPrintJobDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_DEL parameters = Parameters;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobDel: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "job " FORMAT_WORD_ONLY "\n",
                      Header, parameters, SmbGetUshort( &parameters->JobId )));
    }

    try {
        //
        // Make the local call.
        //

        status = DosPrintJobDel(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobDel: DosPrintJobDel failed: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetPrintJobDel


NTSTATUS
XsNetPrintJobEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_ENUM parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPVOID outBuffer= NULL;
    DWORD outBufferSize;
    DWORD entriesRead = 0;
    DWORD totalEntries = 0;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    WORD bufferLength;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobEnum: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD ", buf size " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        bufferLength = SmbGetUshort( &parameters->BufLen );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( bufferLength );
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobEnum: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintJobEnum(
                     NULL,
                     nativeQueueName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     (LPWORD)&entriesRead,
                     (LPWORD)&totalEntries
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintJobEnum: DosPrintJobEnum failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintJobEnum: received " FORMAT_DWORD " entries at " FORMAT_LPVOID "\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_print_job_0;
            StructureDesc = Desc16_print_job_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_print_job_1;
            StructureDesc = Desc16_print_job_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_print_job_2;
            StructureDesc = Desc16_print_job_2;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (DWORD)bufferLength,
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR,"
                          " Entries " FORMAT_DWORD " of " FORMAT_DWORD "\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( (entriesFilled < totalEntries) ||
             (bytesRequired > bufferLength) ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    bufferLength,
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->Returned, (WORD)entriesFilled );
        SmbPutUshort( &parameters->Total, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    FREE_QUEUE_NAME( nativeQueueName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintJobEnum


NTSTATUS
XsNetPrintJobGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_GET_INFO parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD outBufferSize;
    WORD bytesNeeded = 0;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobGetInfo: header at " FORMAT_LPVOID ", "
                      "params at " FORMAT_LPVOID ", level " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ));
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobGetInfo: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //
        status = DosPrintJobGetInfo(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId ),
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     &bytesNeeded
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintJobGetInfo: DosPrintJobGetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_print_job_0;
            StructureDesc = Desc16_print_job_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_print_job_1;
            StructureDesc = Desc16_print_job_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_print_job_2;
            StructureDesc = Desc16_print_job_2;
            break;

        case 3:

            nativeStructureDesc = Desc32_print_job_3;
            StructureDesc = Desc16_print_job_3;
            break;
        }


        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsDosPrintJobGetInfo: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobGetInfo: Buffer too small.\n" ));
            }

            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        bytesNeeded = (WORD)bytesRequired;

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->Needed, bytesNeeded );

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintJobGetInfo


NTSTATUS
XsNetPrintJobPause (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobPause.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_PAUSE parameters = Parameters;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobPause: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "job " FORMAT_WORD_ONLY "\n",
                      Header, parameters, SmbGetUshort( &parameters->JobId )));
    }

    try {
        //
        // Make the local call.
        //

        status = DosPrintJobPause(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId )
                     );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintJobPause: DosPrintJobPause failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetPrintJobPause


NTSTATUS
XsNetPrintJobSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_SET_INFO parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters
    DWORD bytesRequired;
    WORD level;

    DWORD fieldIndex;
    LPDESC setInfoDesc;                     // Conversion variables
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors.
        //

        level = SmbGetUshort( &parameters->Level );

        if ( level != 1 && level != 3 ) {
            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Determine descriptor strings based on level. Also translate the
        // parmnum value to a field index.
        // !!! - Right now, we don't check for parameters settable in downlevel
        //       that are meaningless in the NT mapping layer. Fix this,
        //       if necessary, in the descriptor string file (with
        //       REM_IGNORE fields).
        //

        fieldIndex = (DWORD)SmbGetUshort( &parameters->ParmNum );

        switch ( level ) {

        case 1:

            StructureDesc = Desc16_print_job_1;
            nativeStructureDesc = Desc32_print_job_1;
            setInfoDesc = Desc16_print_job_1_setinfo;
            nativeSetInfoDesc = Desc32_print_job_1_setinfo;
            if ( fieldIndex > 2 ) {             // Account for pad field
                fieldIndex++;
            }

            break;

        case 3:

            StructureDesc = Desc16_print_job_3;
            nativeStructureDesc = Desc32_print_job_3;
            setInfoDesc = Desc16_print_job_3_setinfo;
            nativeSetInfoDesc = Desc32_print_job_3_setinfo;
            if ( fieldIndex != PARMNUM_ALL && fieldIndex < 15 ) {
                switch ( fieldIndex ) {
                case PRJ_NOTIFYNAME_PARMNUM:
                case PRJ_DATATYPE_PARMNUM:
                case PRJ_PARMS_PARMNUM:
                    fieldIndex += 7; break;
                case PRJ_POSITION_PARMNUM:
                    fieldIndex = 4; break;
                case PRJ_COMMENT_PARMNUM:
                case PRJ_DOCUMENT_PARMNUM:
                    fieldIndex -= 3; break;
                case PRJ_PRIORITY_PARMNUM:
                    fieldIndex = 2; break;
                default:
                    fieldIndex = 0xFFFFFFFF;    // Some invalid field
                }
            }

            break;

        }

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     (WORD)fieldIndex,
                     FALSE,
                     TRUE,
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     &bytesRequired
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobSetInfo: Problem with conversion: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Do the actual local call.
        //

        status = DosPrintJobSetInfo(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId ),
                     level,
                     (LPBYTE)buffer,
                     (WORD)bytesRequired,
                     SmbGetUshort( &parameters->ParmNum )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobSetInfo: DosPrintJobSetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetPrintJobSetInfo


NTSTATUS
XsNetPrintQAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPTSTR nativeStructureDesc;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQAdd: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD "\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->Level ) ));
    }

    try {

        //
        // Determine native structure descriptor based on level.
        //

        switch ( SmbGetUshort( &parameters->Level )) {

        case 1:
            StructureDesc = Desc16_printQ_1;
            nativeStructureDesc = (LPTSTR)Desc32_printQ_1;
            break;

        case 3:
            StructureDesc = Desc16_printQ_3;
            nativeStructureDesc = (LPTSTR)Desc32_printQ_3;
            break;

        default:
            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         (LPDESC)nativeStructureDesc,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintQAdd: buffer of " FORMAT_DWORD " bytes at " FORMAT_LPVOID "\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     (LPDESC)nativeStructureDesc,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQAdd: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintQAdd(
                     NULL,
                     SmbGetUshort( &parameters->Level ),
                     buffer,
                     (WORD)bufferSize
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQAdd: DosPrintQAdd failed: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetPrintQAdd


NTSTATUS
XsNetPrintQContinue (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQContinue.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_CONTINUE parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters

    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQContinue: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->QueueName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Make the local call.
        //

        status = DosPrintQContinue(
                     NULL,
                     nativeQueueName
                     );
cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintQContinue: DosPrintQContinue failed: "
                          FORMAT_API_STATUS "\n", status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativeQueueName );
    return STATUS_SUCCESS;

} // XsNetPrintQContinue


NTSTATUS
XsNetPrintQDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_DEL parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQDel: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->QueueName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Make the local call.
        //

        status = DosPrintQDel(
                     NULL,
                     nativeQueueName
                     );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintQDel: DosPrintQDel failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativeQueueName );
    return STATUS_SUCCESS;

} // XsNetPrintQDel


NTSTATUS
XsNetPrintQEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;                 // Native parameters
    DWORD outBufferSize;
    DWORD entriesRead = 0;
    DWORD totalEntries = 0;
    WORD bufferLength;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    LPDESC nativeAuxStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQEnum: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD ", buf size " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 5 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        bufferLength = SmbGetUshort( &parameters->BufLen );
        outBufferSize = XsNativeBufferSize( bufferLength );
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 ||  outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQEnum: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintQEnum(
                     NULL,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     (LPWORD)&entriesRead,
                     (LPWORD)&totalEntries
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintQEnum: DosPrintQEnum failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintQEnum: received " FORMAT_DWORD " entries at " FORMAT_LPVOID "\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        nativeAuxStructureDesc = NULL;
        AuxStructureDesc = NULL;

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_printQ_0;
            StructureDesc = Desc16_printQ_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_printQ_1;
            StructureDesc = Desc16_printQ_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_printQ_2;
            nativeAuxStructureDesc = Desc32_print_job_1;
            StructureDesc = Desc16_printQ_2;
            AuxStructureDesc = Desc16_print_job_1;
            break;

        case 3:

            nativeStructureDesc = Desc32_printQ_3;
            StructureDesc = Desc16_printQ_3;
            break;

        case 4:

            nativeStructureDesc = Desc32_printQ_4;
            nativeAuxStructureDesc = Desc32_print_job_2;
            StructureDesc = Desc16_printQ_4;
            AuxStructureDesc = Desc16_print_job_2;
            break;

        case 5:

            nativeStructureDesc = Desc32_printQ_5;
            StructureDesc = Desc16_printQ_5;
            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures. Levels 2 and 4 have auxiliary data, other levels call
        // with NULL auxiliary descriptors, so that the normal XsFillEnumBuffer
        // is called.
        //

        XsFillAuxEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            nativeAuxStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (DWORD)bufferLength,
            StructureDesc,
            AuxStructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR,"
                          " Entries " FORMAT_DWORD " of " FORMAT_DWORD "\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data. We won't
        // try to pack the ones with the auxiliary structures.
        //

        if ( (entriesFilled < totalEntries) ||
             (bytesRequired > bufferLength) ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            switch ( SmbGetUshort( &parameters->Level )) {

            case 2:
            case 4:

                break;

            default:

                Header->Converter = XsPackReturnData(
                                        (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                        bufferLength,
                                        StructureDesc,
                                        entriesFilled
                                        );
            }
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->Returned, (WORD)entriesFilled );
        SmbPutUshort( &parameters->Total, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintQEnum


NTSTATUS
XsNetPrintQGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_GET_INFO parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPVOID outBuffer = NULL;
    DWORD outBufferSize;
    WORD bytesNeeded = 0;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc = NULL;
    LPDESC nativeAuxStructureDesc = NULL;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD auxDataCount;
    DWORD i;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQGetInfo: header at " FORMAT_LPVOID ", "
                      "params at " FORMAT_LPVOID ", level " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        //
        // Level 52 supported for Win95 clients
        //
        if ( XsWordParamOutOfRange( parameters->Level, 0, 5 ) &&
             (DWORD) SmbGetUshort(&parameters->Level) != 52 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ));
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQGetInfo: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintQGetInfo(
                     NULL,
                     nativeQueueName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     SmbGetUshort( &parameters->BufLen ),
                     &bytesNeeded
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintQGetInfo: DosPrintQGetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_printQ_0;
            StructureDesc = Desc16_printQ_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_printQ_1;
            StructureDesc = Desc16_printQ_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_printQ_2;
            nativeAuxStructureDesc = Desc32_print_job_1;
            StructureDesc = Desc16_printQ_2;
            AuxStructureDesc = Desc16_print_job_1;
            break;

        case 3:

            nativeStructureDesc = Desc32_printQ_3;
            StructureDesc = Desc16_printQ_3;
            break;

        case 4:

            nativeStructureDesc = Desc32_printQ_4;
            nativeAuxStructureDesc = Desc32_print_job_2;
            StructureDesc = Desc16_printQ_4;
            AuxStructureDesc = Desc16_print_job_2;
            break;

        case 5:

            nativeStructureDesc = Desc32_printQ_5;
            StructureDesc = Desc16_printQ_5;
            break;

        case 52:

            nativeStructureDesc = Desc32_printQ_52;
            StructureDesc = Desc16_printQ_52;
            break;

        }

        //
        // Common code between cases 2 and 4 - form long descriptors.
        //

        switch ( SmbGetUshort( &parameters->Level )) {

        case 2:
        case 4:

            //
            // Find the auxiliary data count.
            //

            auxDataCount = RapAuxDataCount(
                               (LPBYTE)outBuffer,
                               nativeStructureDesc,
                               Response,
                               TRUE   // native format
                               );

            longDescriptor = NetpMemoryAllocate(
                                 strlen( StructureDesc )
                                 + strlen( AuxStructureDesc ) *
                                     auxDataCount + 1 );
            longNativeDescriptor = NetpMemoryAllocate(
                                       strlen( nativeStructureDesc )
                                       + strlen( nativeAuxStructureDesc )
                                             * auxDataCount
                                       + 1 );

            if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetPrintQGetInfo: failed to allocate memory" ));
                }
                Header->Status = (WORD)NERR_NoRoom;
                goto cleanup;
            }

            strcpy( longDescriptor, StructureDesc );
            strcpy( longNativeDescriptor, nativeStructureDesc );
            for ( i = 0; i < auxDataCount; i++ ) {
                strcat( longDescriptor, AuxStructureDesc );
                strcat( longNativeDescriptor, nativeAuxStructureDesc );
            }

            StructureDesc = longDescriptor;
            nativeStructureDesc = longNativeDescriptor;

            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsDosPrintQGetInfo: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        bytesNeeded = (WORD)bytesRequired;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->Needed, bytesNeeded );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,            // desc (may be one we created on heap)
        Header->Converter,
        1,
        Header->Status
        );

    (VOID) NetApiBufferFree( outBuffer );
    FREE_QUEUE_NAME( nativeQueueName );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );

    return STATUS_SUCCESS;

} // XsNetPrintQGetInfo


NTSTATUS
XsNetPrintQPause (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQPause.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_PAUSE parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQPause: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->QueueName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Make the local call.
        //

        status = DosPrintQPause(
                     NULL,
                     nativeQueueName
                     );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintQPause: DosPrintQPause failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativeQueueName );
    return STATUS_SUCCESS;

} // XsNetPrintQPause


NTSTATUS
XsNetPrintQPurge (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQPurge.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_PURGE parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQPurge: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->QueueName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Make the local call.
        //

        status = DosPrintQPurge(
                     NULL,
                     nativeQueueName
                     );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintQPurge: DosPrintQPurge failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;


    FREE_QUEUE_NAME( nativeQueueName );
    return STATUS_SUCCESS;

} // XsNetPrintQPurge


NTSTATUS
XsNetPrintQSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetPrintQSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_SET_INFO parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPVOID buffer = NULL;
    DWORD bytesRequired;

    DWORD fieldIndex;
    LPDESC setInfoDesc;                     // Conversion variables
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1
                 && SmbGetUshort( &parameters->Level ) != 3 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Determine descriptor strings based on level. Also translate the
        // parmnum value to a field index.
        // !!! - Right now, we don't check for parameters settable in downlevel
        //       that are meaningless in the NT mapping layer.
        //

        fieldIndex = (DWORD)SmbGetUshort( &parameters->ParmNum );

        switch ( SmbGetUshort( &parameters->Level )) {

        case 1:

            StructureDesc = Desc16_printQ_1;
            nativeStructureDesc = Desc32_printQ_1;
            setInfoDesc = Desc16_printQ_1_setinfo;
            nativeSetInfoDesc = Desc32_printQ_1_setinfo;

            if ( fieldIndex > 1 ) {             // Account for pad field
                fieldIndex++;
            }

            break;

        case 3:

            StructureDesc = Desc16_printQ_3;
            nativeStructureDesc = Desc32_printQ_3;
            setInfoDesc = Desc16_printQ_3_setinfo;
            nativeSetInfoDesc = Desc32_printQ_3_setinfo;
            if ( fieldIndex == PRQ_DESTINATIONS_PARMNUM ) {
                fieldIndex = (DWORD)-1;         // No corresponding field
            } else if ( fieldIndex == PRQ_SEPARATOR_PARMNUM
                        || fieldIndex == PRQ_PROCESSOR_PARMNUM ) {
                fieldIndex++;
            }
            break;

        }

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     (WORD)fieldIndex,
                     FALSE,
                     TRUE,
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     &bytesRequired
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQSetInfo: Problem with conversion: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Do the actual local call.
        //

        status = DosPrintQSetInfo(
                     NULL,
                     nativeQueueName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)buffer,
                     (WORD)bytesRequired,
                     SmbGetUshort( &parameters->ParmNum )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQSetInfo: DosPrintQSetInfo failed: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    FREE_QUEUE_NAME( nativeQueueName );

    return STATUS_SUCCESS;

} // XsNetPrintQSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apifile.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiFile.c

Abstract:

    This module contains individual API handlers for the NetFile APIs.

    SUPPORTED - NetFileClose2, NetFileEnum2, NetFileGetInfo2.

Author:

    Shanku Niyogi (w-shanku) 20-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_file_info_2 = REM16_file_info_2;
STATIC const LPDESC Desc32_file_info_2 = REM32_file_info_2;
STATIC const LPDESC Desc16_file_info_3 = REM16_file_info_3;
STATIC const LPDESC Desc32_file_info_3 = REM32_file_info_3;


NTSTATUS
XsNetFileClose2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetFileClose.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_FILE_CLOSE_2 parameters = Parameters;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Make the local call.
        //

        status = NetFileClose(
                     NULL,
                     SmbGetUlong( &parameters->FileId )
                     );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetFileClose2: NetFileClose failed: %X\n",
                          status ));
        }
    }

    //
    // No return data.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetFileClose2


NTSTATUS
XsNetFileEnum2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetFileEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_FILE_ENUM_2 parameters = Parameters;
    LPTSTR nativeBasePath = NULL;           // Native parameters
    LPTSTR nativeUserName = NULL;
    LPVOID outBuffer = NULL;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD_PTR resumeKey = 0;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD totalEntriesRead = 0;
    DWORD bytesRequired = 0;
    DWORD nativeBufferSize;
    LPDESC nativeStructureDesc;
    LPBYTE bufferBegin;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(FILE) {
        NetpKdPrint(( "XsNetFileEnum2: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeBasePath,
            (LPSTR)XsSmbGetPointer( &parameters->BasePath )
            );

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Copy input resume handle to output resume handle, and get a copy of it.
        //

        if ( SmbGetUlong( &parameters->ResumeKeyIn ) == 0 ) {

            Header->Status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        RtlCopyMemory( parameters->ResumeKeyOut,
            (LPBYTE)XsSmbGetPointer( &parameters->ResumeKeyIn ), 8 );
        resumeKey = (DWORD)SmbGetUlong( &parameters->ResumeKeyOut[2] );

        IF_DEBUG(FILE) {
            NetpKdPrint(( "XsNetFileEnum2: resume key is %ld\n", resumeKey ));
        }

        //
        // Use the level to determine the descriptor string.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 2:

            StructureDesc = Desc16_file_info_2;
            nativeStructureDesc = Desc32_file_info_2;
            break;

        case 3:

            StructureDesc = Desc16_file_info_3;
            nativeStructureDesc = Desc32_file_info_3;
            break;

        default:

            //
            // Unsupported levels, abort before any work.
            //

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // NetFileEnum2 is a resumable API, so we cannot get more information
        // from the native call than we can send back. The most efficient way
        // to do this is in a loop...we use the 16-bit buffer size to determine
        // a safe native buffer size, make the call, fill the entries, then
        // take the amount of space remaining and determine a safe size again,
        // and so on, until NetFileEnum returns either no entries or all entries
        // read.
        //

        //
        // Initialize important variables for loop.
        //

        bufferBegin = (LPBYTE)XsSmbGetPointer( &parameters->Buffer );
        bufferSize = (DWORD)SmbGetUshort( &parameters->BufLen );
        totalEntriesRead = 0;

        for ( ; ; ) {

            //
            //  Compute a safe size for the native buffer.
            //

            switch ( SmbGetUshort( &parameters->Level ) ) {

            case 2:

                nativeBufferSize = bufferSize;
                break;

            case 3:

                nativeBufferSize = bufferSize;
                break;

            }

            //
            // Make the local call.
            //

            status = NetFileEnum(
                         NULL,
                         nativeBasePath,
                         nativeUserName,
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         (LPBYTE *)&outBuffer,
                         nativeBufferSize,
                         &entriesRead,
                         &totalEntries,
                         &resumeKey
                         );

            if ( !XsApiSuccess( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetFileEnum2: NetFileEnum failed: %X\n",
                                  status ));
                }

                Header->Status = (WORD)status;
                goto cleanup;
            }

            IF_DEBUG(FILE) {
                NetpKdPrint(( "XsNetFileEnum2: received %ld entries at %lx\n",
                              entriesRead, outBuffer ));

                NetpKdPrint(( "XsNetFileEnum2: resume key is now %Id\n",
                              resumeKey ));
            }

            //
            // Was NetFileEnum able to read at least one complete entry?
            //

            if ( entriesRead == 0 ) {
                break;
            }

            //
            // Do the actual conversion from the 32-bit structures to 16-bit
            // structures.
            //

            XsFillEnumBuffer(
                outBuffer,
                entriesRead,
                nativeStructureDesc,
                bufferBegin,
                (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                bufferSize,
                StructureDesc,
                NULL,  // verify function
                &bytesRequired,
                &entriesFilled,
                NULL
                );

            IF_DEBUG(FILE) {
                NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                              " Entries %ld of %ld\n",
                              outBuffer, SmbGetUlong( &parameters->Buffer ),
                              bytesRequired, entriesFilled, totalEntries ));
            }

            //
            // Very key assertion!
            //

            NetpAssert( entriesRead == entriesFilled );

            //
            // Update count of entries read.
            //

            totalEntriesRead += entriesRead;

            //
            // Are there any more entries to read?
            //

            if ( entriesRead == totalEntries ) {
                break;
            }

            //
            // Calculate new buffer beginning and size.
            //

            bufferBegin += entriesRead *
                               RapStructureSize( StructureDesc, Response, FALSE );
            bufferSize -= bytesRequired;

            //
            // Free last native buffer.
            //

            NetApiBufferFree( outBuffer );
            outBuffer = NULL;

        }

        //
        // Upon exit from the loop, totalEntriesRead has the number of entries
        // read, entriesRead has the number read in the last call, totalEntries
        // has the number remaining plus entriesRead. Formulate return codes,
        // etc. from these values.
        //

        if ( totalEntries > entriesRead ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    totalEntriesRead
                                    );

        }

        IF_DEBUG(FILE) {
            NetpKdPrint(( "XsNetFileEnum2: resume key is now %ld\n", resumeKey ));
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)totalEntriesRead );
        SmbPutUshort( &parameters->EntriesRemaining,
            (WORD)( totalEntries - entriesRead ));

        //
        // Over the wire, resumeKey is a true 32-bit index, so this cast works.
        //

        SmbPutUlong( (LPDWORD)&parameters->ResumeKeyOut[2], (DWORD)resumeKey );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeBasePath );
    NetpMemoryFree( nativeUserName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        totalEntriesRead,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetFileEnum2


NTSTATUS
XsNetFileGetInfo2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetFileGetInfo2.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_FILE_GET_INFO_2 parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(FILE) {
        NetpKdPrint(( "XsNetFileGetInfo2: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 2, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetFileGetInfo(
                     NULL,
                     SmbGetUlong( &parameters->FileId ),
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetFileGetInfo2: NetFileGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 2:

            StructureDesc = Desc16_file_info_2;
            nativeStructureDesc = Desc32_file_info_2;
            break;

        case 3:

            StructureDesc = Desc16_file_info_3;
            nativeStructureDesc = Desc32_file_info_3;
            break;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsFileGetInfo2: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(FILE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetFileGetInfo2: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else {

            if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "NetFileGetInfo2: More data available.\n" ));
                }
                Header->Status = ERROR_MORE_DATA;

            } else {

                //
                // Pack the response data.
                //

                Header->Converter = XsPackReturnData(
                                        (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                        SmbGetUshort( &parameters->BufLen ),
                                        StructureDesc,
                                        1
                                        );
            }

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetFileGetInfo2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apisess.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiSess.c

Abstract:

    This module contains individual API handlers for the NetSession APIs.

    SUPPORTED : NetSessionDel, NetSessionEnum, NetSessionGetInfo.

Author:

    Shanku Niyogi (w-shanku) 5-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_session_info_0 = REM16_session_info_0;
STATIC const LPDESC Desc32_session_info_0 = REM32_session_info_0;
STATIC const LPDESC Desc16_session_info_1 = REM16_session_info_1;
STATIC const LPDESC Desc32_session_info_1 = REM32_session_info_1;
STATIC const LPDESC Desc16_session_info_2 = REM16_session_info_2;
STATIC const LPDESC Desc32_session_info_2 = REM32_session_info_2;
STATIC const LPDESC Desc16_session_info_10 = REM16_session_info_10;
STATIC const LPDESC Desc32_session_info_10 = REM32_session_info_10;


NTSTATUS
XsNetSessionDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetSessionDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SESSION_DEL parameters = Parameters;
    LPTSTR nativeClientName = NULL;          // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;        // Avoid warnings

    IF_DEBUG(SESSION) {
        NetpKdPrint(( "XsNetSessionDel: header at %lx, params at %lx, "
                      "device %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->ClientName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeClientName,
            (LPSTR)XsSmbGetPointer( &parameters->ClientName )
            );

        //
        // Make the local call.
        //

        status = NetSessionDel(
                     NULL,
                     nativeClientName,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetSessionDel: NetSessionDel failed: %X\n",
                              status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeClientName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;


} // NetSessionDel


NTSTATUS
XsNetSessionEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetSessionEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SESSION_ENUM parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    PSESSION_16_INFO_1 struct1;
    PSESSION_16_INFO_2 struct2;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SESSION) {
        NetpKdPrint(( "XsNetSessionEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 ) &&
             ( SmbGetUshort( &parameters->Level ) != 10 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetSessionEnum(
                     NULL,
                     NULL,
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetSessionEnum: NetSessionEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(SESSION) {
            NetpKdPrint(( "XsNetSessionEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_session_info_0;
            StructureDesc = Desc16_session_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_session_info_1;
            StructureDesc = Desc16_session_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_session_info_2;
            StructureDesc = Desc16_session_info_2;
            break;

        case 10:

            nativeStructureDesc = Desc32_session_info_10;
            StructureDesc = Desc16_session_info_10;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL, // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(SESSION) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // Go through all the structures, and fill in the default data.
        //

        struct1 = (PSESSION_16_INFO_1)XsSmbGetPointer( &parameters->Buffer );
        struct2 = (PSESSION_16_INFO_2)struct1;

        switch ( SmbGetUshort( &parameters->Level )) {

        case 1:

            for ( i = 0; i < entriesFilled; i++, struct1++ ) {

                SmbPutUshort( &struct1->sesi1_num_conns, DEF16_ses_num_conns );
                SmbPutUshort( &struct1->sesi1_num_users, DEF16_ses_num_users );
            }

            break;

        case 2:

            for ( i = 0; i < entriesFilled; i++, struct2++ ) {

                SmbPutUshort( &struct2->sesi2_num_conns, DEF16_ses_num_conns );
                SmbPutUshort( &struct2->sesi2_num_users, DEF16_ses_num_users );
            }

            break;

        default:

            break;

        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // NetSessionEnum


NTSTATUS
XsNetSessionGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetSessionGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SESSION_GET_INFO parameters = Parameters;
    LPTSTR nativeClientName = NULL;         // Native parameters
    LPVOID outBuffer = NULL;
    DWORD entriesRead;
    DWORD totalEntries;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    PSESSION_16_INFO_2 struct2;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SESSION) {
        NetpKdPrint(( "XsNetSessionGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 ) &&
             ( SmbGetUshort( &parameters->Level ) != 10 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeClientName,
            (LPSTR)XsSmbGetPointer( &parameters->ClientName )
            );

        //
        // If this is a null client name, send the appropriate response.
        //

        if ( ( nativeClientName == NULL ) ||
              STRLEN( nativeClientName ) == 0 ) {

            Header->Status = NERR_ClientNameNotFound;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetSessionEnum(
                     NULL,
                     nativeClientName,
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetSessionGetInfo: NetSessionEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        IF_DEBUG(SESSION) {
            NetpKdPrint(( "XsNetSessionGetInfo: Received %ld entries\n",
                          entriesRead ));
        }

        //
        // Use the requested level to determine the format of the 32-bit
        // structure we got back from NetSessionGetInfo.  The format of the
        // 16-bit structure is stored in the transaction block, and we
        // got a pointer to it as a parameter.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_session_info_0;
            StructureDesc = Desc16_session_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_session_info_1;
            StructureDesc = Desc16_session_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_session_info_2;
            StructureDesc = Desc16_session_info_2;
            break;

        case 10:

            nativeStructureDesc = Desc32_session_info_10;
            StructureDesc = Desc16_session_info_10;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetSessionGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(SESSION) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetSessionGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else {

            //
            // Fill in default data in the structure.
            //

            if (( SmbGetUshort( &parameters->Level ) == 1 ) ||
                    SmbGetUshort( &parameters->Level ) == 2 ) {

                struct2 = (PSESSION_16_INFO_2)XsSmbGetPointer( &parameters->Buffer );

                SmbPutUshort( &struct2->sesi2_num_conns, DEF16_ses_num_conns );
                SmbPutUshort( &struct2->sesi2_num_users, (WORD)entriesRead );

            }

            if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "NetSessionGetInfo: More data available.\n" ));
                }
                Header->Status = ERROR_MORE_DATA;

            } else {

                //
                // Pack the response data.
                //

                Header->Converter = XsPackReturnData(
                                        (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                        SmbGetUshort( &parameters->BufLen ),
                                        StructureDesc,
                                        1
                                        );
            }
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeClientName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // NetSessionGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apishare.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiShare.c

Abstract:

    This module contains individual API handlers for the NetShare APIs.

    SUPPORTED : NetShareAdd, NetShareCheck, NetShareDel, NetShareEnum,
                NetShareGetInfo, NetShareSetInfo.

Author:

    David Treadwell (davidtr)    07-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_share_info_0 = REM16_share_info_0;
STATIC const LPDESC Desc32_share_info_0 = REM32_share_info_0;
STATIC const LPDESC Desc16_share_info_1 = REM16_share_info_1;
STATIC const LPDESC Desc32_share_info_1 = REM32_share_info_1;
STATIC const LPDESC Desc16_share_info_1_setinfo = REM16_share_info_1_setinfo;
STATIC const LPDESC Desc32_share_info_1_setinfo = REM32_share_info_1_setinfo;
STATIC const LPDESC Desc16_share_info_2 = REM16_share_info_2;
STATIC const LPDESC Desc32_share_info_2 = REM32_share_info_2;
STATIC const LPDESC Desc16_share_info_2_setinfo = REM16_share_info_2_setinfo;
STATIC const LPDESC Desc32_share_info_2_setinfo = REM32_share_info_2_setinfo;


NTSTATUS
XsNetShareAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SHARE) {
        NetpKdPrint(( "XsNetShareAdd: header at %lx, params at %lx, "
                      "level %ld\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->Level ) ));
    }

    try {
            //
            // Check for errors.
            //

            if ( SmbGetUshort( &parameters->Level ) != 2 ) {

                Header->Status = ERROR_INVALID_LEVEL;
                goto cleanup;
            }

            StructureDesc = Desc16_share_info_2;

            //
            // Figure out if there is enough room in the buffer for all the
            // data required. If not, return NERR_BufTooSmall.
            //

            if ( !XsCheckBufferSize(
                     SmbGetUshort( &parameters->BufLen ),
                     StructureDesc,
                     FALSE  // not in native format
                     )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetShareAdd: Buffer too small.\n" ));
                }
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            //
            // Find out how big a buffer we need to allocate to hold the native
            // 32-bit version of the input data structure.
            //

            bufferSize = XsBytesForConvertedStructure(
                             (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                             StructureDesc,
                             Desc32_share_info_2,
                             RapToNative,
                             TRUE
                             );

            //
            // Allocate enough memory to hold the converted native buffer.
            //

            buffer = NetpMemoryAllocate( bufferSize );

            if ( buffer == NULL ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetShareAdd: failed to create buffer" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;

            }

            IF_DEBUG(SHARE) {
                NetpKdPrint(( "XsNetShareAdd: buffer of %ld bytes at %lx\n",
                              bufferSize, buffer ));
            }

            //
            // Convert the buffer from 16-bit to 32-bit.
            //

            stringLocation = (LPBYTE)buffer + bufferSize;
            bytesRequired = 0;

            status = RapConvertSingleEntry(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         TRUE,
                         buffer,
                         buffer,
                         Desc32_share_info_2,
                         FALSE,
                         &stringLocation,
                         &bytesRequired,
                         Response,
                         RapToNative
                         );


            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetShareAdd: RapConvertSingleEntry failed: "
                                  "%X\n", status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            //
            // Make the local call.
            //

            status = NetShareAdd(
                         NULL,
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         buffer,
                         NULL
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetShareAdd: NetShareAdd failed: %X\n", status ));
                }

                if ( status == ERROR_DIRECTORY ) {
                    Header->Status = NERR_UnknownDevDir;
                } else {
                    Header->Status = (WORD)status;
                }
                goto cleanup;
            }

            //
            // There is no real return information for this API.
            //

cleanup:
        ;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
        }

        NetpMemoryFree( buffer );

        return STATUS_SUCCESS;

} // XsNetShareAdd


NTSTATUS
XsNetShareCheck (
        API_HANDLER_PARAMETERS
        )

/*++

Routine Description:

        This routine handles a call to NetShareCheck.

Arguments:

        API_HANDLER_PARAMETERS - information about the API call. See
            XsTypes.h for details.

Return Value:

        NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
        NET_API_STATUS status;

        PXS_NET_SHARE_CHECK parameters = Parameters;
        LPTSTR nativeDeviceName = NULL;         // Native parameters
        DWORD shareType;

        API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

        try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeDeviceName,
            (LPSTR)XsSmbGetPointer( &parameters->DeviceName )
            );

        //
        // Do the local call.
        //

        status = NetShareCheck(
                     NULL,
                     nativeDeviceName,
                     &shareType
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareCheck: NetShareCheck failed: "
                              "%X\n", status ));
            }
        }

        //
        // Put type into return field.
        //

        SmbPutUshort( &parameters->Type, (WORD)shareType );

        Header->Status = (WORD)status;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeDeviceName );
    return STATUS_SUCCESS;

} // XsNetShareCheck


NTSTATUS
XsNetShareDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_DEL parameters = Parameters;
    LPTSTR nativeNetName = NULL;            // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SHARE) {
        NetpKdPrint(( "XsNetShareDel: header at %lx, params at %lx, name %s\n",
                      Header, parameters, SmbGetUlong( &parameters->NetName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeNetName,
            (LPSTR)XsSmbGetPointer( &parameters->NetName )
            );

        //
        // Make the local call.
        //

        status = NetShareDel(
                     NULL,
                     nativeNetName,
                     (DWORD)SmbGetUshort( &parameters->Reserved )
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareDel: NetShareDel failed: %X\n", status ));
            }
        }

        //
        // Nothing to return.
        //

        Header->Status = (WORD)status;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeNetName );
    return STATUS_SUCCESS;

} // XsNetShareDel


NTSTATUS
XsNetShareEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;                 // Native parameters
    DWORD entriesRead = 0;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    DWORD invalidEntries = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SHARE) {
        NetpKdPrint(( "XsNetShareEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetShareEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetShareEnum: NetShareEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(SHARE) {
            NetpKdPrint(( "XsNetShareEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_share_info_0;
            StructureDesc = Desc16_share_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_share_info_1;
            StructureDesc = Desc16_share_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_share_info_2;
            StructureDesc = Desc16_share_info_2;
            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            &invalidEntries
            );

        IF_DEBUG(SHARE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled + invalidEntries < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetShareEnum


NTSTATUS
XsNetShareGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_GET_INFO parameters = Parameters;
    LPTSTR nativeNetName = NULL;            // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SHARE) {
        NetpKdPrint(( "XsNetShareGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeNetName,
            (LPSTR)XsSmbGetPointer( &parameters->NetName )
            );

        //
        // Make the local call.
        //

        status = NetShareGetInfo(
                     NULL,
                     nativeNetName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetShareGetInfo: NetShareGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_share_info_0;
            StructureDesc = Desc16_share_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_share_info_1;
            StructureDesc = Desc16_share_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_share_info_2;
            StructureDesc = Desc16_share_info_2;
            break;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(SHARE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeNetName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetShareGetInfo


NTSTATUS
XsNetShareSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_SET_INFO parameters = Parameters;
    LPTSTR nativeNetName = NULL;            // Native parameters
    LPVOID buffer = NULL;
    DWORD level;

    LPDESC setInfoDesc;                     // Conversion variables
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeNetName,
            (LPSTR)XsSmbGetPointer( &parameters->NetName )
            );

        //
        // Determine descriptor strings based on level.
        //

        switch ( SmbGetUshort( &parameters->Level )) {

        case 1:

            StructureDesc = Desc16_share_info_1;
            nativeStructureDesc = Desc32_share_info_1;
            setInfoDesc = Desc16_share_info_1_setinfo;
            nativeSetInfoDesc = Desc32_share_info_1_setinfo;

            break;

        case 2:

            StructureDesc = Desc16_share_info_2;
            nativeStructureDesc = Desc32_share_info_2;
            setInfoDesc = Desc16_share_info_2_setinfo;
            nativeSetInfoDesc = Desc32_share_info_2_setinfo;

            break;

        default:

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     SmbGetUshort( &parameters->ParmNum ),
                     FALSE,
                     TRUE,
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     NULL
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareSetInfo: Problem with conversion: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Do the actual local call.
        //

        level = SmbGetUshort( &parameters->ParmNum );
        if ( level != 0 ) {
            level = level + PARMNUM_BASE_INFOLEVEL;
        } else {
            level = SmbGetUshort( &parameters->Level );
        }

        status = NetShareSetInfo(
                     NULL,
                     nativeNetName,
                     level,
                     (LPBYTE)buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareSetInfo: NetShareSetInfo failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    NetpMemoryFree( nativeNetName );

    return STATUS_SUCCESS;

} // XsNetShareSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apitime.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ApiTime.c

Abstract:

    This module contains individual API handler for the NetRemoteTOD API.

    SUPPORTED : NetRemoteTOD.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991

Revision History:

    10-Jun-1993 JohnRo
        RAID 13081: NetRemoteTOD should return timezone info.
--*/

#include "XactSrvP.h"
#include <timelib.h>    // NetpLocalTimeZoneOffset().

//
// Forward declarations
//

NET_API_STATUS
GetLocalTOD(
    OUT LPTIME_OF_DAY_INFO TimeOfDayInfo
    );

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_time_of_day_info = REM16_time_of_day_info;
STATIC const LPDESC Desc32_time_of_day_info = REM32_time_of_day_info;


NTSTATUS
XsNetRemoteTOD (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetRemoteTOD.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_REMOTE_TOD parameters = Parameters;
    TIME_OF_DAY_INFO timeOfDay;

    DWORD bytesRequired = 0;                // Conversion variables
    LPBYTE stringLocation = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(TIME) {
        NetpKdPrint(( "XsNetRemoteTOD: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Make the local call.
    //

    status = GetLocalTOD(
                 &timeOfDay
                 );
    try {

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetRemoteTOD: NetRemoteTOD failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     (LPBYTE)&timeOfDay,
                     Desc32_time_of_day_info,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     Desc16_time_of_day_info,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetRemoteTOD: RapConvertSingleEntry failed: "
                          "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(TIME) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          &timeOfDay, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer. There is
        // no variable data for a time_of_day_info structure, only fixed data.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 Desc16_time_of_day_info,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetRemoteTOD: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        }

        //
        // No return parameters.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        Desc16_time_of_day_info,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetRemoteTOD

NET_API_STATUS
GetLocalTOD(
    OUT LPTIME_OF_DAY_INFO TimeOfDayInfo
    )
/*++

Routine Description:

    This routine calls the Win32 and NT base timer APIs to get the
    relevant time/date information. It also calls the Rtl routine to
    convert the time elapsed since 1-1-1970.

    The routine allocates a buffer to contain the time of day information
    and returns a pointer to that buffer to the caller.

Arguments:

    bufptr - Location of where to place pointer to buffer.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/
{

    SYSTEMTIME    LocalTime;
    LONG          LocalTimeZoneOffsetSecs;  // offset (+ for West of GMT, etc).
    LARGE_INTEGER Time;

    //
    // Call the appropriate routines to collect the time information
    //

    // Number of seconds from UTC.  Positive values for west of Greenwich,
    // negative values for east of Greenwich.
    LocalTimeZoneOffsetSecs = NetpLocalTimeZoneOffset();

    GetLocalTime(&LocalTime);

    TimeOfDayInfo->tod_hours        = LocalTime.wHour;
    TimeOfDayInfo->tod_mins         = LocalTime.wMinute;
    TimeOfDayInfo->tod_secs         = LocalTime.wSecond;
    TimeOfDayInfo->tod_hunds        = LocalTime.wMilliseconds/10;

    // tod_timezone is + for west of GMT, - for east of it.
    // tod_timezone is in minutes.
    TimeOfDayInfo->tod_timezone     = LocalTimeZoneOffsetSecs / 60;

    TimeOfDayInfo->tod_tinterval    = 310;
    TimeOfDayInfo->tod_day          = LocalTime.wDay;
    TimeOfDayInfo->tod_month        = LocalTime.wMonth;
    TimeOfDayInfo->tod_year         = LocalTime.wYear;
    TimeOfDayInfo->tod_weekday      = LocalTime.wDayOfWeek;

    //
    // Get the 64-bit system time.  Convert the system time to the
    // number of seconds since 1-1-1970.  This is in GMT, Rap will
    // convert this to local time later.
    //

    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(
                &Time,
                &(TimeOfDayInfo->tod_elapsedt)
                );

    //
    // Get the free running counter value
    //

    TimeOfDayInfo->tod_msecs = GetTickCount();

    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apisvc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiSvc.c

Abstract:

    This module contains individual API handlers for the NetService APIs.

    SUPPORTED : NetServicControl, NetServiceEnum, NetServiceGetInfo,
                NetServiceInstall.

Author:

    Shanku Niyogi (w-shanku) 26-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"


#define XACTSRV_CONVERT_SVC_EXITCODE(ob)                                       \
    {                                                                          \
        PSERVICE_INFO_2 ss = (PSERVICE_INFO_2) ob;                             \
        if ((unsigned short) ss->svci2_code == ERROR_SERVICE_SPECIFIC_ERROR) { \
            ss->svci2_code = (ss->svci2_code & 0xffff0000) | (unsigned short) ss->svci2_specific_error;\
        }                                                                      \
    }


//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_service_info_0 = REM16_service_info_0;
STATIC const LPDESC Desc32_service_info_0 = REM32_service_info_0;
STATIC const LPDESC Desc16_service_info_1 = REM16_service_info_1;
STATIC const LPDESC Desc32_service_info_1 = REM32_service_info_1;
STATIC const LPDESC Desc16_service_info_2 = REM16_service_info_2;
STATIC const LPDESC Desc32_service_info_2 = REM32_service_info_2;


NTSTATUS
XsNetServiceControl (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServiceControl.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVICE_CONTROL parameters = Parameters;
    LPTSTR nativeService = NULL;            // Native parameters
    LPVOID outBuffer = NULL;
    LPVOID newOutBuffer = NULL;
    LPSERVICE_INFO_2 serviceInfo2;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD installState;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVICE) {
        NetpKdPrint(( "XsNetServiceControl: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    try {
            //
            // Translate parameters, check for errors.
            //

            XsConvertTextParameter(
                nativeService,
                (LPSTR)XsSmbGetPointer( &parameters->Service )
                );

            //
            // Make the local call.  We need to mask off the upper bytes of
            // both the opcode and the arg parameters since the client is
            // putting some garbage on the high byte.  The valid values for
            // both are 1-255.
            //

            status = NetServiceControl(
                         NULL,
                         XS_MAP_SERVICE_NAME( nativeService ),
                         (DWORD)( parameters->OpCode & 0x00FF ),
                         (DWORD)( parameters->Arg & 0x00FF ),
                         (LPBYTE *)&outBuffer
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServiceControl: NetServiceControl failed: "
                                  "%X\n", status ));
                }

                Header->Status = (WORD)status;

                goto cleanup;

            }

            //
            // Convert nt service name to os/2 name
            //

            status = NetpTranslateNamesInServiceArray(
                                        2,                      // level 2 by def
                                        outBuffer,
                                        1,                      // 1 entry
                                        FALSE,
                                        &newOutBuffer
                                        );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServiceControl: NetpTranslateNamesInServiceArray failed: "
                                  "%X\n", status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            //
            // If the status indicates INSTALL or UNINSTALL PENDING, and if the
            // wait hint is greater than 0xFF then the wait hint sent to downlevel
            // must be set the maximum SERVICE_MAXTIME (0xFF).
            //
            serviceInfo2 = (LPSERVICE_INFO_2)newOutBuffer;
            installState = serviceInfo2->svci2_status & SERVICE_INSTALL_STATE;

            if ((installState == SERVICE_INSTALL_PENDING) ||
                (installState == SERVICE_UNINSTALL_PENDING)) {

                if (SERVICE_NT_WAIT_GET(serviceInfo2->svci2_code) > SERVICE_MAXTIME) {
                    serviceInfo2->svci2_code |= UPPER_HINT_MASK;
                    serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
                }
            }
            else {
                //
                // NT version has code and specific_error while downlevel
                // version only has code.  Convert the info from the extra
                // NT specific_error field.
                //

                XACTSRV_CONVERT_SVC_EXITCODE(newOutBuffer);
            }
            //
            // Convert the structure returned by the 32-bit call to a 16-bit
            // structure. The last possible location for variable data is
            // calculated from buffer location and length.
            //

            stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                          + SmbGetUshort( &parameters->BufLen ) );

            status = RapConvertSingleEntry(
                         newOutBuffer,
                         Desc32_service_info_2,
                         FALSE,
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         Desc16_service_info_2,
                         TRUE,
                         &stringLocation,
                         &bytesRequired,
                         Response,
                         NativeToRap
                         );


            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServiceControl: RapConvertSingleEntry failed: "
                                  "%X\n", status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            IF_DEBUG(SERVICE ) {
                NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                              newOutBuffer, SmbGetUlong( &parameters->Buffer ),
                              bytesRequired ));
            }

            //
            // Determine return code based on the size of the buffer.
            // SERVICE_INFO_x structures have no variable data to pack.
            //

            if ( !XsCheckBufferSize(
                     SmbGetUshort( &parameters->BufLen ),
                     Desc16_service_info_2,
                     FALSE  // not in native format
                     )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServiceControl: Buffer too small.\n" ));
                }
                Header->Status = NERR_BufTooSmall;

            }

cleanup:
        ;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
        }

        NetpMemoryFree( nativeService );
        NetApiBufferFree( outBuffer );
        NetApiBufferFree( newOutBuffer );

        //
        // Determine return buffer size.
        //

        XsSetDataCount(
            &parameters->BufLen,
            Desc16_service_info_2,
            Header->Converter,
            1,
            Header->Status
            );

        return STATUS_SUCCESS;

} // XsNetServiceControl


NTSTATUS
XsNetServiceEnum (
        API_HANDLER_PARAMETERS
        )

/*++

Routine Description:

        This routine handles a call to NetServiceEnum.

Arguments:

        API_HANDLER_PARAMETERS - information about the API call. See
            XsTypes.h for details.

Return Value:

        NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
        NET_API_STATUS status;

        PXS_NET_SERVICE_ENUM parameters = Parameters;
        LPVOID outBuffer = NULL;                // Native parameters
        LPVOID newOutBuffer = NULL;
        DWORD entriesRead;
        DWORD totalEntries;

        DWORD entriesFilled = 0;                    // Conversion variables
        DWORD bytesRequired = 0;
        LPDESC nativeStructureDesc;
        DWORD level;

        API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

        IF_DEBUG(SERVICE) {
            NetpKdPrint(( "XsNetServiceEnum: header at %lx, params at %lx, "
                          "level %ld, buf size %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ),
                          SmbGetUshort( &parameters->BufLen )));
        }

        try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        level = (DWORD)SmbGetUshort( &parameters->Level );
        status = NetServiceEnum(
                     NULL,
                     level,
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceEnum: NetServiceEnum failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(SERVICE) {
            NetpKdPrint(( "XsNetServiceEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Convert nt service names to os/2 name
        //

        status = NetpTranslateNamesInServiceArray(
                                    level,
                                    outBuffer,
                                    entriesRead,
                                    FALSE,
                                    &newOutBuffer
                                    );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceEnum: NetpTranslateNamesInServiceArray failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( level ) {

        case 0:

            nativeStructureDesc = Desc32_service_info_0;
            StructureDesc = Desc16_service_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_service_info_1;
            StructureDesc = Desc16_service_info_1;
            {
                DWORD i;
                DWORD installState;
                PSERVICE_INFO_1 serviceInfo1 = (PSERVICE_INFO_1) newOutBuffer;

                for (i = 0; i < entriesRead; i++, serviceInfo1++) {

                    //
                    // If the status indicates INSTALL or UNINSTALL PENDING,
                    // and if the wait hint is greater than 0xFF then the
                    // wait hint sent to downlevel must be set the
                    // maximum SERVICE_MAXTIME (0xFF).
                    //
                    installState = (serviceInfo1[i]).svci1_status & SERVICE_INSTALL_STATE;
                    if ((installState == SERVICE_INSTALL_PENDING) ||
                        (installState == SERVICE_UNINSTALL_PENDING)) {

                        if (SERVICE_NT_WAIT_GET(serviceInfo1->svci1_code) > SERVICE_MAXTIME) {
                            serviceInfo1->svci1_code |= UPPER_HINT_MASK;
                            serviceInfo1->svci1_code &= SERVICE_RESRV_MASK;
                        }
                    }
                }
            }
            break;

        case 2:

            nativeStructureDesc = Desc32_service_info_2;
            StructureDesc = Desc16_service_info_2;

            {
                DWORD i;
                DWORD installState;
                PSERVICE_INFO_2 serviceInfo2 = (PSERVICE_INFO_2) newOutBuffer;

                for (i = 0; i < entriesRead; i++, serviceInfo2++) {

                    //
                    // If the status indicates INSTALL or UNINSTALL PENDING,
                    // and if the wait hint is greater than 0xFF then the
                    // wait hint sent to downlevel must be set the
                    // maximum SERVICE_MAXTIME (0xFF).
                    //
                    installState = (serviceInfo2[i]).svci2_status & SERVICE_INSTALL_STATE;
                    if ((installState == SERVICE_INSTALL_PENDING) ||
                        (installState == SERVICE_UNINSTALL_PENDING)) {

                        if (SERVICE_NT_WAIT_GET(serviceInfo2->svci2_code) > SERVICE_MAXTIME) {
                            serviceInfo2->svci2_code |= UPPER_HINT_MASK;
                            serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
                        }
                    }
                    else {
                        //
                        // NT version has code and specific_error while downlevel
                        // version only has code.  Convert the info from the extra
                        // NT specific_error field.
                        //
                        XACTSRV_CONVERT_SVC_EXITCODE(serviceInfo2);
                    }
                }
            }

            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            newOutBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(SERVICE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          newOutBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA.
        // SERVICE_INFO_x structures have no variable data to pack.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetApiBufferFree( newOutBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServiceEnum


NTSTATUS
XsNetServiceGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServiceGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVICE_GET_INFO parameters = Parameters;
    LPTSTR nativeService = NULL;            // Native parameters
    LPVOID outBuffer = NULL;
    LPVOID newOutBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    DWORD level;
    LPSERVICE_INFO_2 serviceInfo2;
    LPSERVICE_INFO_1 serviceInfo1;
    DWORD installState;


    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVICE) {
        NetpKdPrint(( "XsNetServiceGetInfo: header at %lx, "
                      "params at %lx, level %d\n",
                      Header, parameters, SmbGetUshort( &parameters->Level )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeService,
            (LPSTR)XsSmbGetPointer( &parameters->Service )
            );

        if (nativeService == NULL) {
            Header->Status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        level = (DWORD)SmbGetUshort( &parameters->Level );
        status = NetServiceGetInfo(
                     NULL,
                     XS_MAP_SERVICE_NAME( nativeService ),
                     level,
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceGetInfo: NetServiceGetInfo failed: "
                              "%X\n", status ));
            }

            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Convert nt service name to os/2 name
        //

        status = NetpTranslateNamesInServiceArray(
                                    level,
                                    outBuffer,
                                    1,
                                    FALSE,
                                    &newOutBuffer
                                    );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceGetInfo: NetpTranslateNamesInServiceArray failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( level ) {

        case 0:

            nativeStructureDesc = Desc32_service_info_0;
            StructureDesc = Desc16_service_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_service_info_1;
            StructureDesc = Desc16_service_info_1;
            //
            // If the status indicates INSTALL or UNINSTALL PENDING, and if the
            // wait hint is greater than 0xFF then the wait hint sent to downlevel
            // must be set the maximum SERVICE_MAXTIME (0xFF).
            //
            serviceInfo1 = (LPSERVICE_INFO_1)newOutBuffer;
            installState = serviceInfo1->svci1_status & SERVICE_INSTALL_STATE;

            if ((installState == SERVICE_INSTALL_PENDING) ||
                (installState == SERVICE_UNINSTALL_PENDING)) {

                if (SERVICE_NT_WAIT_GET(serviceInfo1->svci1_code) > SERVICE_MAXTIME) {
                    serviceInfo1->svci1_code |= UPPER_HINT_MASK;
                    serviceInfo1->svci1_code &= SERVICE_RESRV_MASK;
                }
            }
            break;

        case 2:

            nativeStructureDesc = Desc32_service_info_2;
            StructureDesc = Desc16_service_info_2;

            //
            // If the status indicates INSTALL or UNINSTALL PENDING, and if the
            // wait hint is greater than 0xFF then the wait hint sent to downlevel
            // must be set the maximum SERVICE_MAXTIME (0xFF).
            //
            serviceInfo2 = (LPSERVICE_INFO_2)newOutBuffer;
            installState = serviceInfo2->svci2_status & SERVICE_INSTALL_STATE;

            if ((installState == SERVICE_INSTALL_PENDING) ||
                (installState == SERVICE_UNINSTALL_PENDING)) {

                if (SERVICE_NT_WAIT_GET(serviceInfo2->svci2_code) > SERVICE_MAXTIME) {
                    serviceInfo2->svci2_code |= UPPER_HINT_MASK;
                    serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
                }
            }
            else {
                //
                // NT version has code and specific_error while downlevel
                // version only has code.  Convert the info from the extra
                // NT specific_error field.
                //
                XACTSRV_CONVERT_SVC_EXITCODE(newOutBuffer);
            }
            break;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     newOutBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServiceGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(SERVICE ) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          newOutBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        // SERVICE_INFO_x structures have no variable data to pack.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServiceGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( newOutBuffer );
    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeService );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServiceGetInfo

NTSTATUS
XsNetServiceInstall (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServiceInstall.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVICE_INSTALL parameters = Parameters;
    LPTSTR nativeService = NULL;            // Native parameters
    DWORD argc;
    LPTSTR * argv = NULL;
    LPVOID outBuffer = NULL;
    LPVOID newOutBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPTSTR nativeRcvBuffer = NULL;
    LPSTR srcBuffer = NULL;
    LPTSTR destBuffer = NULL;
    DWORD bufSize;
    DWORD i;
    DWORD installState;
    LPSERVICE_INFO_2 serviceInfo2;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVICE) {
        NetpKdPrint(( "XsNetServiceInstall: header at %lx, "
                      "params at %lx, service %s\n",
                      Header, parameters,
                      (LPSTR)XsSmbGetPointer( &parameters->Service ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeService,
            (LPSTR)XsSmbGetPointer( &parameters->Service )
            );

        //
        // Convert buffer. First, find number of arguments and buffer size.
        //

        srcBuffer = (LPSTR)XsSmbGetPointer( &parameters->RcvBuffer );
        if ( srcBuffer ) {
            bufSize = 0;
            for ( argc = 0; strlen( srcBuffer ) > 0; argc++ ) {
                bufSize += ( strlen( srcBuffer ) + 1 );
                srcBuffer += ( strlen( srcBuffer ) + 1 );
            }
        } else {
            bufSize = 0;
            argc = 0;
        }

        if ( argc ) {

            //
            // Allocate an argument vector.
            //

            argv = NetpMemoryAllocate( argc * sizeof(LPTSTR) );
            if ( argv == NULL ) {
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }

            //
            // If we are Unicode, allocate room for converted buffer.
            // Otherwise, use the receive buffer to fill argv.
            //

#ifdef UNICODE
            nativeRcvBuffer = NetpMemoryAllocate( STRING_SPACE_REQD( bufSize + 1 ));
            if ( nativeRcvBuffer == NULL ) {
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }
            srcBuffer = (LPSTR)XsSmbGetPointer( &parameters->RcvBuffer );
#else
            nativeRcvBuffer = (LPTSTR)XsSmbGetPointer( &parameters->RcvBuffer );
#endif

        }

        //
        // Go through buffer, filling in argv vector, and optionally converting
        // to Unicode.
        //

        destBuffer = nativeRcvBuffer;
        for ( i = 0; i < argc; i++ ) {

#ifdef UNICODE
            NetpCopyStrToTStr( destBuffer, srcBuffer );
            srcBuffer += ( strlen( srcBuffer ) + 1 );
#endif

            argv[i] = destBuffer;
            destBuffer += ( STRLEN( destBuffer ) + 1 );
        }

        //
        // Make the local call.
        //

        status = NetServiceInstall(
                     NULL,
                     XS_MAP_SERVICE_NAME( nativeService ),
                     argc,
                     argv,
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceInstall: NetServiceInstall failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Convert nt service name to os/2 name
        //

        status = NetpTranslateNamesInServiceArray(
                                    2,                  // level 2 by def
                                    outBuffer,
                                    1,                  // 1 entry
                                    FALSE,
                                    &newOutBuffer
                                    );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceInstall: NetpTranslateNamesInServiceArray failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // If the status indicates INSTALL or UNINSTALL PENDING, and if the
        // wait hint is greater than 0xFF then the wait hint sent to downlevel
        // must be set the maximum SERVICE_MAXTIME (0xFF).
        //
        serviceInfo2 = (LPSERVICE_INFO_2)newOutBuffer;
        installState = serviceInfo2->svci2_status & SERVICE_INSTALL_STATE;

        if ((installState == SERVICE_INSTALL_PENDING) ||
            (installState == SERVICE_UNINSTALL_PENDING)) {

            if (SERVICE_NT_WAIT_GET(serviceInfo2->svci2_code) > SERVICE_MAXTIME) {
                serviceInfo2->svci2_code |= UPPER_HINT_MASK;
                serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
            }
        }

        else {
            //
            // NT version has code and specific_error while downlevel
            // version only has code.  Convert the info from the extra
            // NT specific_error field.
            //

            XACTSRV_CONVERT_SVC_EXITCODE(newOutBuffer);
        }
        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The "return buffer" is actually a byte array in the
        // parameter area.
        //

        stringLocation = parameters->RetBuffer + sizeof( parameters->RetBuffer );

        status = RapConvertSingleEntry(
                     newOutBuffer,
                     Desc32_service_info_2,
                     FALSE,
                     parameters->RetBuffer,
                     parameters->RetBuffer,
                     Desc16_service_info_2,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServiceInstall: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(SERVICE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          newOutBuffer, &parameters->RetBuffer, bytesRequired ));
        }

        //
        // There should have been enough memory to make this call, because
        // buffer length is checked locally on the client, and an 88 byte
        // receive buffer is always provided.
        //

        NetpAssert( bytesRequired <= sizeof( parameters->RetBuffer ));

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetApiBufferFree( newOutBuffer );
    NetpMemoryFree( nativeService );
    NetpMemoryFree( argv );
#ifdef UNICODE
    NetpMemoryFree( nativeRcvBuffer );
#endif // def UNICODE

    return STATUS_SUCCESS;

} // XsNetServiceInstall
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apiuse.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiUse.c

Abstract:

    This module contains individual API handlers for the NetUse APIs.

    SUPPORTED : NetUseAdd, NetUseDel, NetUseEnum, NetUseGetInfo.

    NOTE : These handlers are only provided as exports by the XACTSRV
           DLL, for use by clients such as VDM. They are not supported
           for remote clients.

Author:

    Shanku Niyogi (w-shanku) 31-Jan-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_use_info_0 = REM16_use_info_0;
STATIC const LPDESC Desc32_use_info_0 = REM32_use_info_0;
STATIC const LPDESC Desc16_use_info_1 = REM16_use_info_1;
STATIC const LPDESC Desc32_use_info_1 = REM32_use_info_1;


STATIC NET_API_STATUS
XsNetUseEnumVerify (
    IN NET_API_STATUS ConvertStatus,
    IN PBYTE ConvertedEntry,
    IN PBYTE BaseAddress
    )

/*++

Routine Description:


    This function is called by XsFillEnumBuffer after each entry is
    converted, in order to determine whether the entry should be retained
    in the enum buffer or discarded.


    The use_info_x structures contain sharenames in a field with the format
    \\computername\sharename.  XACTSRV must not return information about
    shares or computers with names longer than are allowed under LanMan 2.0.
    RapConvertSingleEntry can only insure that the entire field does not
    exceed the specified length; it cannot verify the lengths of individual
    components of a sharename.  So this function is called by
    XsFillEnumBuffer after each call to RapConvertSingleEntry in order to
    check whether the converted entry satisfies this additional constraint.


Arguments:

    ConvertStatus - The return code from RapConvertSingleEntry.

    ConvertedEntry - The converted entry created by RapConvertSingleEntry.

    BaseAddress - A pointer to the base used to calculate offsets.

Return Value:

    NTSTATUS - STATUS_INVALID_PARAMETER if the entry should be retained, or
        an error code if the entry should be discarded.

--*/

{
    NTSTATUS status;
    DWORD remote;
    PUSE_16_INFO_0 use = (PUSE_16_INFO_0)ConvertedEntry;

    //
    // If RapConvertSingleEntry failed, discard the entry.
    //

    if ( ConvertStatus != NERR_Success ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If the sharename is too long, discard the entry.
    //

    remote = (DWORD)SmbGetUlong( &use->ui0_remote );

    status = ( remote == 0 ) ? NERR_Success
                             : XsValidateShareName( BaseAddress + remote );

    IF_DEBUG(CONVERT) {

        if ( !NT_SUCCESS(status) ) {
            NetpKdPrint(( "XsNetUseEnumVerify: sharename too long: "
                          "discarding entry\n" ));
        }
    }

    return status;
}


NTSTATUS
XsNetUseAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUseAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USE_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USE) {
        NetpKdPrint(( "XsNetUseAdd: header at %lx, params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_use_info_1;

        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format yet
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         Desc32_use_info_1,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        IF_DEBUG(USE) {
            NetpKdPrint(( "XsNetUseAdd: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     Desc32_use_info_1,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseAdd: RapConvertSingleEntry failed: "
                          "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // RLF
        //
        // if use_info_1.ui1_asg_type is 0xffff meaning wildcard, we have to
        // convert it to 0xffffffff since NetUseAdd is going to compare it
        // against (DWORD)(-1) and RapConvertSingleEntry has only converted it
        // to 0x0000ffff which results in an error
        //

        if (((LPUSE_INFO_1)buffer)->ui1_asg_type == 0xffff) {
            ((LPUSE_INFO_1)buffer)->ui1_asg_type = 0xffffffff;
        }

        //
        // Do the actual local call.
        //

        status = NetUseAdd(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE)buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseAdd: NetUseAdd failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetUseAdd


NTSTATUS
XsNetUseDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUseDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USE_DEL parameters = Parameters;
    LPTSTR nativeUseName = NULL;            // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USE) {
        NetpKdPrint(( "XsNetUseDel: header at %lx, params at %lx, device %s\n",
                      Header, parameters, SmbGetUlong( &parameters->UseName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeUseName,
            (LPSTR)XsSmbGetPointer( &parameters->UseName )
            );

        //
        // Do local call, with converted parameter values.
        //

        status = NetUseDel(
                     NULL,
                     nativeUseName,
                     (DWORD)SmbGetUshort( &parameters->Force )
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseDel: NetUseDel failed: %X\n", status ));
            }
        }

        //
        // Nothing to return.
        //

        Header->Status = (WORD)status;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeUseName );

    return STATUS_SUCCESS;

} // XsNetUseDel


NTSTATUS
XsNetUseEnum (
    API_HANDLER_PARAMETERS
    )

/*+

Routine Description:

    This routine handles a call to NetUseEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.
+
--*/

{
    NET_API_STATUS status;

    PXS_NET_USE_ENUM parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD invalidEntries = 0;
    DWORD bytesRequired;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USE) {
        NetpKdPrint(( "XsNetUseEnum: header at %lx, params at %lx, level %ld, "
                      "buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetUseEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUseEnum: NetUseEnum failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(USE) {
            NetpKdPrint(( "XsNetUseEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_use_info_0;
            StructureDesc = Desc16_use_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_use_info_1;
            StructureDesc = Desc16_use_info_1;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            &XsNetUseEnumVerify,
            &bytesRequired,
            &entriesFilled,
            &invalidEntries
            );

        IF_DEBUG(USE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if (( entriesFilled + invalidEntries ) < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail,
                          (WORD)( totalEntries - invalidEntries ));

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // NetUseEnum


NTSTATUS
XsNetUseGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUseGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USE_GET_INFO parameters = Parameters;
    LPTSTR nativeUseName = NULL;            // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USE) {
        NetpKdPrint(( "XsNetUseGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeUseName,
            (LPSTR)XsSmbGetPointer( &parameters->UseName )
            );

        //
        // Do the actual local call.
        //

        status = NetUseGetInfo(
                     NULL,
                     nativeUseName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUseGetInfo: NetUseGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the 32-bit
        // structure we got back from NetUseGetInfo.  The format of the
        // 16-bit structure is stored in the transaction block, and we
        // got a pointer to it as a parameter.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_use_info_0;
            StructureDesc = Desc16_use_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_use_info_1;
            StructureDesc = Desc16_use_info_1;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseGetInfo: RapConvertSingleEntry failed: "
                          "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(USE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE      // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetUseGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // NetUseGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apisrv.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ApiSrv.c

Abstract:

    This module contains individual API handlers for the NetServer APIs.

    SUPPORTED : NetServerDiskEnum, NetServerEnum2, NetServerGetInfo,
                NetServerSetInfo.

    SEE ALSO : NetServerAuthenticate, NetServerPasswordSet,
               NetServerReqChallenge - in ApiLogon.c.

Author:

    Shanku Niyogi (w-shanku) 25-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"
#include <lmbrowsr.h>       // Definition of I_BrowserServerEnum


//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_server_info_0 = REM16_server_info_0;
STATIC const LPDESC Desc32_server_info_0 = REM32_server_info_0;
STATIC const LPDESC Desc16_server_info_1 = REM16_server_info_1;
STATIC const LPDESC Desc32_server_info_1 = REM32_server_info_1;
STATIC const LPDESC Desc16_server_info_2 = REM16_server_info_2;
STATIC const LPDESC Desc32_server_info_2 = REM32_server_info_2;
STATIC const LPDESC Desc16_server_info_3 = REM16_server_info_3;
STATIC const LPDESC Desc32_server_info_3 = REM32_server_info_3;


NTSTATUS
XsNetServerDiskEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerDiskEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVER_DISK_ENUM parameters = Parameters;
    LPBYTE outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries = 0;
    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bufferLength;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;

        }

        //
        // Make the local call.
        //

        bufferLength = (DWORD)SmbGetUshort( &parameters->BufLen );

        status = NetServerDiskEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( bufferLength ),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServer: NetServerDiskEnum failed: "
                              "%X\n", status ));
            }

            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // Calculate how many entries will fit in 16-bit buffer;
        //

        if ( bufferLength > 0 ) {
            DWORD elementSize;

            elementSize = RapStructureSize( StructureDesc, Response, FALSE );

            if (elementSize != 0) {
                entriesFilled = ( bufferLength - 1 ) / elementSize;
            }
        }

        if ( entriesFilled < entriesRead ) {

            status = ERROR_MORE_DATA;
        } else {

            entriesFilled = entriesRead;
            status = NERR_Success;
        }

        //
        // Copy native buffer to 16-bit buffer, converting Unicode to Ansi
        // if necessary.
        //

        if ( bufferLength > 0 ) {

            DWORD i;
            LPTSTR entryIn = (LPTSTR)outBuffer;
            LPSTR entryOut = (LPSTR)XsSmbGetPointer( &parameters->Buffer );

            for ( i = 0; i < entriesFilled; i++ ) {

                NetpCopyWStrToStrDBCS( entryOut, entryIn );
                entryOut += ( strlen( entryOut ) + 1 );
                entryIn += ( STRLEN( entryIn ) + 1 );

            }
            strcpy( entryOut, "" );
        }

        Header->Status = (WORD)status;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Put return data into fields.
    //

    SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
    SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

    return STATUS_SUCCESS;

} // XsNetServerDiskEnum


NTSTATUS
XsNetServerEnum2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

    Transport - The name of the transport provided to the API.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status = NERR_Success;

    PXS_NET_SERVER_ENUM_2 parameters = Parameters;
    LPTSTR nativeDomain = NULL;             // Native parameters
    LPVOID outBuffer= NULL;
    DWORD entriesRead;
    DWORD totalEntries;
    LPTSTR clientTransportName = NULL;
    LPTSTR clientName = NULL;

    DWORD entriesFilled = 0;                    // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "XsNetServerEnum2: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeDomain,
            (LPSTR)XsSmbGetPointer( &parameters->Domain )
            );

        clientTransportName = Header->ClientTransportName;

        clientName = Header->ClientMachineName;

        //
        // Get the actual server information from the local 32-bit call. The
        // native level is 100 or 101.
        //

        if (clientTransportName == NULL) {
            status = NetServerEnum(
                            NULL,
                            100 + (DWORD)SmbGetUshort( &parameters->Level ),
                            (LPBYTE *)&outBuffer,
                            XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                            &entriesRead,
                            &totalEntries,
                            SmbGetUlong( &parameters->ServerType ),
                            nativeDomain,
                            NULL
                            );

            if ( !XsApiSuccess( status ) ) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerEnum2: NetServerEnum failed: %X\n",
                                  status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            Header->Status = XsConvertServerEnumBuffer(
                                  outBuffer,
                                  entriesRead,
                                  &totalEntries,
                                  SmbGetUshort( &parameters->Level ),
                                  (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                  SmbGetUshort( &parameters->BufLen ),
                                  &entriesFilled,
                                  &Header->Converter);

        } else {

            Header->Status = I_BrowserServerEnumForXactsrv(
                     clientTransportName,
                     clientName,

                     100 + SmbGetUshort( &parameters->Level ),
                     SmbGetUshort( &parameters->Level ),

                     (PVOID)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ) ),

                     &entriesFilled,
                     &totalEntries,

                     SmbGetUlong( &parameters->ServerType ),
                     nativeDomain,
                     NULL,

                     &Header->Converter

                     );


            if (!XsApiSuccess( Header->Status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerEnum2: I_BrowserServerEnum failed: %d\n", Header->Status));
                }
                goto cleanup;
            }
        }

        if ( entriesFilled == 0 ) {
            SmbPutUshort( &parameters->BufLen, 0 );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( outBuffer != NULL ) {
        NetApiBufferFree( outBuffer );
    }
    NetpMemoryFree( nativeDomain );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        SmbGetUshort( &parameters->Level ) == 0 ?
                    Desc16_server_info_0 :
                    Desc16_server_info_1,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServerEnum2


NTSTATUS
XsNetServerEnum3 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

    Transport - The name of the transport provided to the API.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status = NERR_Success;

    PXS_NET_SERVER_ENUM_3 parameters = Parameters;
    LPTSTR nativeDomain = NULL;             // Native parameters
    LPTSTR nativeFirstNameToReturn = NULL;  // Native parameters
    LPVOID outBuffer= NULL;
    DWORD entriesRead;
    DWORD totalEntries;
    LPTSTR clientTransportName = NULL;
    LPTSTR clientName = NULL;

    DWORD entriesFilled = 0;                    // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "XsNetServerEnum3: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeDomain,
            (LPSTR)XsSmbGetPointer( &parameters->Domain )
            );

        XsConvertTextParameter(
            nativeFirstNameToReturn,
            (LPSTR)XsSmbGetPointer( &parameters->FirstNameToReturn )
            );

        clientTransportName = Header->ClientTransportName;

        clientName = Header->ClientMachineName;

        //
        // Get the actual server information from the local 32-bit call. The
        // native level is 100 or 101.
        //

        if (clientTransportName == NULL) {
            status = NetServerEnumEx(
                            NULL,
                            100 + (DWORD)SmbGetUshort( &parameters->Level ),
                            (LPBYTE *)&outBuffer,
                            XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                            &entriesRead,
                            &totalEntries,
                            SmbGetUlong( &parameters->ServerType ),
                            nativeDomain,
                            nativeFirstNameToReturn
                            );

            if ( !XsApiSuccess( status ) ) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerEnum3: NetServerEnum failed: %X\n",
                                  status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            Header->Status = XsConvertServerEnumBuffer(
                                  outBuffer,
                                  entriesRead,
                                  &totalEntries,
                                  SmbGetUshort( &parameters->Level ),
                                  (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                  SmbGetUshort( &parameters->BufLen ),
                                  &entriesFilled,
                                  &Header->Converter);

        } else {

            Header->Status = I_BrowserServerEnumForXactsrv(
                     clientTransportName,
                     clientName,

                     100 + SmbGetUshort( &parameters->Level ),
                     SmbGetUshort( &parameters->Level ),

                     (PVOID)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ) ),

                     &entriesFilled,
                     &totalEntries,

                     SmbGetUlong( &parameters->ServerType ),
                     nativeDomain,
                     nativeFirstNameToReturn,

                     &Header->Converter

                     );


            if (!XsApiSuccess( Header->Status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerEnum3: I_BrowserServerEnum failed: %d\n", Header->Status));
                }
                goto cleanup;
            }
        }

        if ( entriesFilled == 0 ) {
            SmbPutUshort( &parameters->BufLen, 0 );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( outBuffer != NULL ) {
        NetApiBufferFree( outBuffer );
    }
    NetpMemoryFree( nativeDomain );
    NetpMemoryFree( nativeFirstNameToReturn );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        SmbGetUshort( &parameters->Level ) == 0 ?
                    Desc16_server_info_0 :
                    Desc16_server_info_1,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServerEnum3


USHORT
XsConvertServerEnumBuffer(
    IN LPVOID ServerEnumBuffer,
    IN DWORD EntriesRead,
    IN OUT PDWORD TotalEntries,
    IN USHORT Level,
    IN LPBYTE ClientBuffer,
    IN USHORT BufferLength,
    OUT PDWORD EntriesFilled,
    OUT PUSHORT Converter
    )
/*++

Routine Description:

    This routine converts an NT server info array into a down level RAP
    server info buffer.

Arguments:

    IN LPVOID ServerEnumBuffer - Buffer with NT server info.
    IN DWORD EntriesRead -       Number of entries in buffer.
    IN OUT PDWORD TotalEntries - Total Number of entries.
    IN USHORT Level - Downlevel information Level (0 or 1).
    IN LPBYTE ClientBuffer - Pointer to 16 bit client side buffer.
    IN USHORT BufferLength - Size of client buffer.
    OUT PDWORD EntriesFilled - Number of entries converted into client buffer.
    OUT PUSHORT Converter - Converter used by client side to convert back.

Return Value:

    USHORT - NERR_Success or reason for failure (16 bit DOS error).

--*/

{
    USHORT status = NERR_Success;
    DWORD invalidEntries;
    LPDESC nativeStructureDesc;
    DWORD bytesRequired = 0;
    PCHAR StructureDesc;

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "XsConvertServerEnumBuffer: received %ld entries at %lx\n",
                      EntriesRead, ServerEnumBuffer ));
    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( Level ) {

    case 0:

        StructureDesc = Desc16_server_info_0;
        nativeStructureDesc = Desc32_server_info_0;
        break;

    case 1:

        StructureDesc = Desc16_server_info_1;
        nativeStructureDesc = Desc32_server_info_1;
        break;

    }

    //
    // Do the actual conversion from the 32-bit structures to 16-bit
    // structures.
    //

    XsFillEnumBuffer(
        ServerEnumBuffer,
        EntriesRead,
        nativeStructureDesc,
        ClientBuffer,
        ClientBuffer,
        BufferLength,
        StructureDesc,
        NULL,  // verify function
        &bytesRequired,
        EntriesFilled,
        &invalidEntries
        );

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                      " Entries %ld of %ld\n",
                      ServerEnumBuffer, ClientBuffer ,
                      bytesRequired, *EntriesFilled, *TotalEntries ));
    }

    //
    // If there are any invalid entries, subtract this from the
    // number of total entries to avoid the case where the client
    // keeps bugging us for more data.
    //

    if ( invalidEntries > 0) {
        (*TotalEntries) -= invalidEntries;
#if DBG
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetServerEnum: %d invalid entries removed."
                          " Total entries now %d, entries filled %d.\n",
                          invalidEntries, *TotalEntries, *EntriesFilled ));
        }
#endif
    }

    //
    // If all the entries could not be filled, return ERROR_MORE_DATA,
    // The data needs to be packed so that we don't send too much
    // useless data.
    //

    if ( (*EntriesFilled < *TotalEntries) ||
         (bytesRequired > BufferLength) ) {

        status = ERROR_MORE_DATA;
    }

    *Converter = XsPackReturnData(
                            ClientBuffer,
                            BufferLength,
                            StructureDesc,
                            *EntriesFilled
                            );


    return status;
}   //  XsConvertServerEnumBuffer



NTSTATUS
XsNetServerGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerGetInfo. Since NT only provides
    levels 100-102, this routine manually fills in default values for other
    fields. Because of this, the handling in this procedure is different
    from other Xs...GetInfo handlers.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVER_GET_INFO parameters = Parameters;
    DWORD localLevel;                       // Native parameters
    PSERVER_INFO_102 nativeStruct = NULL;
    PSERVER_INFO_502 secondaryNativeStruct = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD sizeOfFixedStructure;
    LPDESC nativeStructureDesc;
    PSERVER_16_INFO_3 returnStruct;
    BOOLEAN bufferTooSmall = FALSE;
    LPWSTR ServerName = NULL;
    UCHAR serverNameBuf[ 2 + NETBIOS_NAME_LEN + 1 ];
    PUCHAR p;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "XsNetServerGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 3 ) ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Use the 16-bit level number to determine the NT level number and the
        // native descriptor string.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_server_info_0;
            StructureDesc = Desc16_server_info_0;
            localLevel = 100;
            break;

        case 1:

            nativeStructureDesc = Desc32_server_info_1;
            StructureDesc = Desc16_server_info_1;
            localLevel = 101;
            break;

        case 2:

            nativeStructureDesc = Desc32_server_info_2;
            StructureDesc = Desc16_server_info_2;
            localLevel = 102;
            break;

        case 3:

            nativeStructureDesc = Desc32_server_info_3;
            StructureDesc = Desc16_server_info_3;
            localLevel = 102;
            break;

        }

        //
        // If the buffer is not big enough, we have to continue doing the
        // Rap Conversion so that we can return the right buffer size to
        // the caller.
        //

        sizeOfFixedStructure = RapStructureSize( StructureDesc,
                                                  Response,
                                                  FALSE );

        if ( SmbGetUshort( &parameters->BufLen ) < sizeOfFixedStructure ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerGetInfo: Buffer too small.\n" ));
            }

            bufferTooSmall = TRUE;
        }

        serverNameBuf[0] = serverNameBuf[1] = '\\';
        memcpy( &serverNameBuf[2], Header->ServerName, NETBIOS_NAME_LEN );
        for( p = &serverNameBuf[ NETBIOS_NAME_LEN + 1 ]; p > serverNameBuf && *p == ' '; p-- )
            ;
        *(p+1) = '\0';

        ServerName = XsDupStrToWStr( serverNameBuf );

        if( ServerName == NULL ) {
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Do the actual local call.
        //
        status = NetServerGetInfo(
                     ServerName,
                     localLevel,
                     (LPBYTE *)&nativeStruct
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServerGetInfo: NetServerGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // For levels 2 and 3 (native level 102), additional data is
        // required from native level 502. Do this call.
        //

        if ( localLevel == 102 ) {

            status = NetServerGetInfo(
                         ServerName,
                         502,
                         (LPBYTE *)&secondaryNativeStruct
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerGetInfo: NetServerGetInfo failed: "
                                  "%X\n", status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;

            }
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. For levels 0 and 1, there is no additional work
        // involved after this step, so ConvertSingleEntry can store the
        // variable data in the structure. This is indicated by passing
        // the end of the entire buffer in stringLocation. For levels 2 and 3,
        // the manual filling scheme requires that variable data not be entered
        // at this stage, so stringLocation is set to the end of the fixed
        // structure.
        //

        stringLocation = (LPBYTE)XsSmbGetPointer( &parameters->Buffer );

        if ( !bufferTooSmall ) {
            stringLocation += ( localLevel == 102 ) ?
                                        sizeOfFixedStructure:
                                        SmbGetUshort( &parameters->BufLen );
        }

        status = RapConvertSingleEntry(
                     (LPBYTE)nativeStruct,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // For levels 2 and 3, the number of bytes required is, in fact, more than
        // that returned by ConvertSingleEntry. We also need space for the
        // string defaults.
        //

        if ( localLevel == 102 ) {

            //
            // The number we get from rap includes some string lengths.
            // We only need the fixed length since we are manually adding
            // those ourselves.
            //

            bytesRequired = sizeOfFixedStructure;
        }

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 3:

            bytesRequired += NetpUnicodeToDBCSLen( DEF16_sv_autopath ) + 1;

        case 2:

            bytesRequired += ( NetpUnicodeToDBCSLen( DEF16_sv_alerts )
                                   + NetpUnicodeToDBCSLen( DEF16_sv_srvheuristics )
                                   + NetpUnicodeToDBCSLen( nativeStruct->sv102_comment )
                                   + NetpUnicodeToDBCSLen( nativeStruct->sv102_userpath )
                                   + 4 );
        }

        //
        // We don't have room even for the fixed data, abort.
        //

        if ( bufferTooSmall ) {

            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // For levels 2 and 3, fill in the default values in the fixed structure
        // manually.
        //

        returnStruct = (PSERVER_16_INFO_3)XsSmbGetPointer( &parameters->Buffer );

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 3:

            SmbPutUlong( &returnStruct->sv3_auditedevents, DEF16_sv_auditedevents );
            SmbPutUshort( &returnStruct->sv3_autoprofile, DEF16_sv_autoprofile );

        case 2:

            SmbPutUlong( &returnStruct->sv3_ulist_mtime, DEF16_sv_ulist_mtime );
            SmbPutUlong( &returnStruct->sv3_alist_mtime, DEF16_sv_alist_mtime );
            SmbPutUlong( &returnStruct->sv3_glist_mtime, DEF16_sv_glist_mtime );
            SmbPutUshort( &returnStruct->sv3_security, DEF16_sv_security );
            SmbPutUshort( &returnStruct->sv3_auditing, DEF16_sv_auditing );
            SmbPutUshort( &returnStruct->sv3_numadmin, (USHORT)DEF16_sv_numadmin );
            SmbPutUshort( &returnStruct->sv3_lanmask, DEF16_sv_lanmask );
            NetpCopyTStrToStr( returnStruct->sv3_guestacct, DEF16_sv_guestacct );
            SmbPutUshort( &returnStruct->sv3_chdevs, DEF16_sv_chdevs );
            SmbPutUshort( &returnStruct->sv3_chdevq, DEF16_sv_chdevq );
            SmbPutUshort( &returnStruct->sv3_chdevjobs, DEF16_sv_chdevjobs );
            SmbPutUshort( &returnStruct->sv3_connections, DEF16_sv_connections );
            SmbPutUshort( &returnStruct->sv3_shares, DEF16_sv_shares );
            SmbPutUshort( &returnStruct->sv3_openfiles, DEF16_sv_openfiles );
            SmbPutUshort( &returnStruct->sv3_sessopens,
                (WORD)secondaryNativeStruct->sv502_sessopens );
            SmbPutUshort( &returnStruct->sv3_sessvcs,
                (WORD)secondaryNativeStruct->sv502_sessvcs );
            SmbPutUshort( &returnStruct->sv3_sessreqs, DEF16_sv_sessreqs );
            SmbPutUshort( &returnStruct->sv3_opensearch,
                (WORD)secondaryNativeStruct->sv502_opensearch );
            SmbPutUshort( &returnStruct->sv3_activelocks, DEF16_sv_activelocks );
            SmbPutUshort( &returnStruct->sv3_numreqbuf, DEF16_sv_numreqbuf );
            SmbPutUshort( &returnStruct->sv3_sizreqbuf,
                (WORD)secondaryNativeStruct->sv502_sizreqbuf );
            SmbPutUshort( &returnStruct->sv3_numbigbuf, DEF16_sv_numbigbuf );
            SmbPutUshort( &returnStruct->sv3_numfiletasks, DEF16_sv_numfiletasks );
            SmbPutUshort( &returnStruct->sv3_alertsched, DEF16_sv_alertsched );
            SmbPutUshort( &returnStruct->sv3_erroralert, DEF16_sv_erroralert );
            SmbPutUshort( &returnStruct->sv3_logonalert, DEF16_sv_logonalert );
            SmbPutUshort( &returnStruct->sv3_accessalert, DEF16_sv_accessalert );
            SmbPutUshort( &returnStruct->sv3_diskalert, DEF16_sv_diskalert );
            SmbPutUshort( &returnStruct->sv3_netioalert, DEF16_sv_netioalert );
            SmbPutUshort( &returnStruct->sv3_maxauditsz, DEF16_sv_maxauditsz );
        }

        //
        // Now check if there is room for the variable data. If there isn't,
        // set return status and quit. This is done here to prevent code
        // below from overwriting the buffer.
        //

        if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetServerGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;
            goto cleanup;
        }

        //
        // For levels 2 and 3, fill in the variable data manually. The variable
        // data is filled in immediately following the fixed structures. For
        // other levels, pack the response data as normal.

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                             + sizeOfFixedStructure );

        switch ( SmbGetUshort( &parameters->Level )) {

        case 3:

            XsAddVarString(
                stringLocation,
                DEF16_sv_autopath,
                &returnStruct->sv3_autopath,
                returnStruct
                );

        case 2:

            XsAddVarString(
                stringLocation,
                DEF16_sv_srvheuristics,
                &returnStruct->sv3_srvheuristics,
                returnStruct
                );

            XsAddVarString(
                stringLocation,
                nativeStruct->sv102_userpath,
                &returnStruct->sv3_userpath,
                returnStruct
                );

            XsAddVarString(
                stringLocation,
                DEF16_sv_alerts,
                &returnStruct->sv3_alerts,
                returnStruct
                );

            XsAddVarString(
                stringLocation,
                nativeStruct->sv102_comment,
                &returnStruct->sv3_comment,
                returnStruct
                );

            break;

        default:

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );

            break;

        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if( ServerName != NULL ) {
        NetpMemoryFree( ServerName );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

    NetApiBufferFree( nativeStruct );
    NetApiBufferFree( secondaryNativeStruct );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServerGetInfo


NTSTATUS
XsNetServerSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    NET_API_STATUS status;

    PXS_NET_SERVER_SET_INFO parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    DWORD data;
    DWORD bufferSize;
    DWORD level;
    LPTSTR comment = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 1, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Processing of this API depends on the value of the ParmNum
        // parameter.
        //

        switch ( SmbGetUshort( &parameters->ParmNum )) {

        case PARMNUM_ALL:

            //
            // PARMNUM_ALL.
            //
            // The structure descriptor given is OK; determine native descriptor
            // (and expected minimum buffer length) from level. The buffer then
            // needs to be converted into a native 32-bit buffer.
            //

            switch( SmbGetUshort( &parameters->Level )) {

            case 1:

                StructureDesc = Desc16_server_info_1;
                nativeStructureDesc = Desc32_server_info_1;
                break;

            case 2:

                StructureDesc = Desc16_server_info_2;
                nativeStructureDesc = Desc32_server_info_2;
                break;

            case 3:

                StructureDesc = Desc16_server_info_3;
                nativeStructureDesc = Desc32_server_info_3;
                break;

            }

            if ( !XsCheckBufferSize(
                      SmbGetUshort( &parameters->BufLen ),
                      StructureDesc,
                      FALSE // native format
                      )) {

                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            //
            // Find out how big a 32-bit data buffer we need.
            //

            bufferSize = XsBytesForConvertedStructure(
                             (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                             StructureDesc,
                             nativeStructureDesc,
                             RapToNative,
                             TRUE
                             );

            //
            // Allocate enough memory to hold the converted native buffer.
            //

            buffer = NetpMemoryAllocate( bufferSize );

            if ( buffer == NULL ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServerSetInfo: failed to create buffer" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;

            }

            IF_DEBUG(SERVER) {
                NetpKdPrint(( "XsNetServerSetInfo: buffer of %ld bytes at %lx\n",
                              bufferSize, buffer ));
            }

            //
            // Convert 16-bit data into 32-bit data and store it in the native
            // buffer.
            //

            stringLocation = (LPBYTE)buffer + bufferSize;
            bytesRequired = 0;

            status = RapConvertSingleEntry(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         TRUE,
                         buffer,
                         buffer,
                         nativeStructureDesc,
                         FALSE,
                         &stringLocation,
                         &bytesRequired,
                         Response,
                         RapToNative
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServerSetInfo: RapConvertSingleEntry "
                                  "failed: %X\n", status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            break;

        case SV_COMMENT_PARMNUM:

            //
            // SV_COMMENT_PARMNUM.
            //
            // The structure descriptor given is meaningless. The data is actually
            // a null terminated string, and can be passed to the native routine
            // immediately. Being a string, it must be at least one character long.
            //

            if ( !XsCheckBufferSize(
                      SmbGetUshort( &parameters->BufLen ),
                      "B",
                      FALSE  // not in native format
                      )) {

                Header->Status= NERR_BufTooSmall;
                goto cleanup;
            }

            XsConvertUnicodeTextParameter(
                                    comment,
                                    (LPSTR)XsSmbGetPointer( &parameters->Buffer )
                                    );

            if ( comment == NULL ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServerSetInfo: failed to create buffer" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }

            buffer = &comment;

            break;

        case SV_ALERTS_PARMNUM:
        case SV_ALERTSCHED_PARMNUM:
        case SV_ERRORALERT_PARMNUM:
        case SV_LOGONALERT_PARMNUM:

            goto cleanup;

        case SV_ACCESSALERT_PARMNUM:
        case SV_DISKALERT_PARMNUM:
        case SV_NETIOALERT_PARMNUM:
        case SV_MAXAUDITSZ_PARMNUM:

            //
            // SV_ALERTS_PARMNUM, SV_ALERTSCHED_PARMNUM, SV_ERRORALERT_PARMNUM,
            // SV_LOGONALERT_PARMNUM, SV_ACCESSALERT_PARMNUM, SV_DISKALERT_PARMNUM,
            // SV_NETIOALERT_PARMNUM, or SV_MAXAUDITSZ_PARMNUM.
            //
            // These parameters are not supported in NT, so just return an OK.
            //

            goto cleanup;

        case SV_DISC_PARMNUM:
        case SV_HIDDEN_PARMNUM:
        case SV_ANNOUNCE_PARMNUM:
        case SV_ANNDELTA_PARMNUM:

            //
            // SV_DISC_PARMNUM, SV_HIDDEN_PARMNUM, SV_ANNOUNCE_PARMNUM, or
            // SV_ANNDELTA_PARMNUM.
            //
            // The structure descriptor given is meaningless; the data is a word
            // to be converted into a 32-bit DWORD. The length of data must be 2.
            //

            if ( !XsCheckBufferSize(
                      SmbGetUshort( &parameters->BufLen ),
                      "W",
                      FALSE   // not in native format
                      )) {

                Header->Status= NERR_BufTooSmall;
                goto cleanup;
            }

            data = (DWORD)SmbGetUshort(
                                  (LPWORD)XsSmbGetPointer( &parameters->Buffer )
                                  );
            buffer = &data;

            break;

        default:

            Header->Status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        //
        // Do the actual local call.
        //

        level = SmbGetUshort( &parameters->ParmNum );
        if ( level != 0 ) {
            level = level + PARMNUM_BASE_INFOLEVEL;
        } else {
            level = 100 + SmbGetUshort( &parameters->Level );
            if ( level == 103 ) {
                level = 102;
            }
        }

        status = NetServerSetInfo(
                     NULL,
                     level,
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerSetInfo: NetServerSetInfo failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    if ( SmbGetUshort( &parameters->ParmNum ) == PARMNUM_ALL ) {
        NetpMemoryFree( buffer );
    } else if ( SmbGetUshort( &parameters->ParmNum ) == SV_COMMENT_PARMNUM ) {
        NetpMemoryFree( comment );
    }

    return STATUS_SUCCESS;

} // XsNetServerSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apiwksta.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiWksta.c

Abstract:

    This module contains individual API handlers for the NetWksta
    APIs.

    SUPPORTED : NetWkstaGetInfo, NetWkstaSetInfo.

    UNSUPPORTED : NetWkstaSetUid.

    SEE ALSO : NetWkstaUserLogon, NetWkstaUserLogoff - in ApiLogon.c.

Author:

    Shanku Niyogi (w-shanku) 25-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_wksta_info_0 = REM16_wksta_info_0;
STATIC const LPDESC Desc16_wksta_info_1 = REM16_wksta_info_1;
STATIC const LPDESC Desc16_wksta_info_10 = REM16_wksta_info_10;

//
// The size of the heuristics is actually 55 chars but we add one
// for padding.
//

#define  SIZE_HEURISTICS            56

NTSTATUS
XsNetWkstaGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine sets up a call to NetWkstaGetInfo. Because of the differences
    between 16- and 32-bit structures, this routine does not use the normal
    conversion process.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_WKSTA_GET_INFO parameters = Parameters;
    LPWKSTA_INFO_100 wksta_100 = NULL;      // Native parameters
    LPWKSTA_INFO_101 wksta_101 = NULL;
    LPWKSTA_INFO_502 wksta_502 = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    BOOL varWrite;
    LPWKSTA_16_INFO_1 entry1;
    LPWKSTA_16_INFO_10 entry10;
    TCHAR heuristics[SIZE_HEURISTICS];
    DWORD i;
    USHORT level;

    WCHAR lanroot[PATHLEN+1];

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(WKSTA) {
        NetpKdPrint(( "XsNetWkstaGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        level = SmbGetUshort( &parameters->Level );
        if ( (level != 0) && (level != 1) && (level != 10) ) {
            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // we return the system directory as the lanroot
        //

        *lanroot = 0;
        GetSystemDirectory(lanroot, sizeof(lanroot)/sizeof(*lanroot));

        //
        // Gather the requested data by making local GetInfo calls.
        //

        switch ( level ) {

        case 10:
            status = NetWkstaGetInfo(
                         NULL,
                         (DWORD)100,
                         (LPBYTE *)&wksta_100
                         );

            if ( !XsApiSuccess ( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsWkstaGetInfo: WkstaGetInfo (level 100) "
                                  "failed: %X\n", status));
                }

                Header->Status = (WORD) status;
                goto cleanup;
            }

            break;

        case 0:
        case 1:
            status = NetWkstaGetInfo(
                         NULL,
                         (DWORD)101,
                         (LPBYTE *)&wksta_101
                         );

            if ( !XsApiSuccess( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsWkstaGetInfo: WkstaGetInfo (level 101) "
                                  "failed: %X\n", status));
                }

                Header->Status = (WORD) status;
                goto cleanup;
            }

            status = NetWkstaGetInfo(
                         NULL,
                         (DWORD)502,
                         (LPBYTE *)&wksta_502
                         );

            if ( !XsApiSuccess( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsWkstaGetInfo: WkstaGetInfo (level 502) "
                                  "failed: %X\n", status));
                }

                Header->Status = (WORD) status;
                goto cleanup;
            }

            break;

        }

        //
        // Calculate the amount of space required to hold the fixed and
        // variable data. Since this is the only place where we get one
        // case for each valid level, we will also get the source structure
        // descriptor here.
        //

        switch ( level ) {

        case 0:

            StructureDesc = Desc16_wksta_info_0;
            bytesRequired = sizeof( WKSTA_16_INFO_0 )
                                + NetpUnicodeToDBCSLen( lanroot )
                                + NetpUnicodeToDBCSLen( wksta_101->wki101_computername )
                                + NetpUnicodeToDBCSLen( DEF16_wk_username )
                                + NetpUnicodeToDBCSLen( wksta_101->wki101_langroup )
                                + NetpUnicodeToDBCSLen( DEF16_wk_logon_server )
                                + SIZE_HEURISTICS
                                + 6;  // for terminating nulls
            break;

        case 1:

            StructureDesc = Desc16_wksta_info_1;
            bytesRequired = sizeof( WKSTA_16_INFO_1 )
                                + NetpUnicodeToDBCSLen( lanroot )
                                + NetpUnicodeToDBCSLen( wksta_101->wki101_computername )
                                + NetpUnicodeToDBCSLen( DEF16_wk_username )
                                + NetpUnicodeToDBCSLen( wksta_101->wki101_langroup )
                                + NetpUnicodeToDBCSLen( DEF16_wk_logon_server )
                                + SIZE_HEURISTICS
                                + NetpUnicodeToDBCSLen( DEF16_wk_logon_domain )
                                + NetpUnicodeToDBCSLen( DEF16_wk_oth_domains )
                                + 8;  // for terminating nulls

            break;

        case 10:

            StructureDesc = Desc16_wksta_info_10;
            bytesRequired = sizeof( WKSTA_16_INFO_10 )
                                + NetpUnicodeToDBCSLen( DEF16_wk_username )
                                + NetpUnicodeToDBCSLen( DEF16_wk_logon_domain )
                                + NetpUnicodeToDBCSLen( wksta_100->wki100_computername )
                                + NetpUnicodeToDBCSLen( wksta_100->wki100_langroup )
                                + NetpUnicodeToDBCSLen( DEF16_wk_oth_domains )
                                + 5;  // for terminating nulls
            break;
        }

        //
        // If there isn't enough room in the buffer for this, don't write any
        // variable data.
        //

        varWrite = ( (DWORD)SmbGetUshort( &parameters->BufLen )
                         >= bytesRequired ) ? TRUE : FALSE;

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                             + RapStructureSize( StructureDesc, Response, FALSE ));

        //
        // Return NERR_BufTooSmall if fixed structure will not fit.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );
            goto cleanup;

        }

        //
        // Based on the level, fill the appropriate information directly into
        // 16-bit buffer.
        //

        entry1 = (LPWKSTA_16_INFO_1) XsSmbGetPointer( &parameters->Buffer );
        entry10 = (LPWKSTA_16_INFO_10) entry1;

        switch ( level ) {

        case 1:

            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_logon_domain,
                    &entry1->wki1_logon_domain,
                    entry1
                    );
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_oth_domains,
                    &entry1->wki1_oth_domains,
                    entry1
                    );
            }
            SmbPutUshort( &entry1->wki1_numdgrambuf,
                          DEF16_wk_numdgrambuf );

            //
            // Fill the rest of the level 1 structure just like a
            // level 0 structure.
            //

        case 0:

            //
            // Zero the reserved words.
            //

            SmbPutUshort( &entry1->wki1_reserved_1, (WORD) 0 );
            SmbPutUlong( &entry1->wki1_reserved_2, (DWORD) 0 );
            SmbPutUlong( &entry1->wki1_reserved_3, (DWORD) 0 );
            SmbPutUshort( &entry1->wki1_reserved_4, (WORD) 0 );
            SmbPutUshort( &entry1->wki1_reserved_5, (WORD) 0 );
            SmbPutUshort( &entry1->wki1_reserved_6, (WORD) 0 );

            //
            // Fill in the fields which have analogues in NT.
            //

            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    lanroot,
                    &entry1->wki1_root,
                    entry1
                    );
                XsAddVarString(
                    stringLocation,
                    wksta_101->wki101_computername,
                    &entry1->wki1_computername,
                    entry1
                    );
                XsAddVarString(
                    stringLocation,
                    wksta_101->wki101_langroup,
                    &entry1->wki1_langroup,
                    entry1
                    );
            }

            entry1->wki1_ver_major = (BYTE) wksta_101->wki101_ver_major;
            entry1->wki1_ver_minor = (BYTE) wksta_101->wki101_ver_minor;

            SmbPutUshort( &entry1->wki1_charwait,
                          XsDwordToWord( wksta_502->wki502_char_wait ) );
            SmbPutUlong( &entry1->wki1_chartime,
                         (DWORD) wksta_502->wki502_collection_time );
            SmbPutUshort( &entry1->wki1_charcount,
                          XsDwordToWord( wksta_502->
                                             wki502_maximum_collection_count ) );
            SmbPutUshort( &entry1->wki1_keepconn,
                          XsDwordToWord( wksta_502->wki502_keep_conn ) );
            SmbPutUshort( &entry1->wki1_maxthreads,
                          XsDwordToWord( wksta_502->wki502_max_threads ) );
            SmbPutUshort( &entry1->wki1_maxcmds,
                          XsDwordToWord( wksta_502->wki502_max_cmds ) );
            SmbPutUshort( &entry1->wki1_sesstimeout,
                          XsDwordToWord( wksta_502->wki502_sess_timeout ) );

            //
            // Construct the heuristics string.
            //

            // Request opportunistic locking of files.
            heuristics[0] = MAKE_TCHAR(XsBoolToDigit(
                                wksta_502->wki502_use_opportunistic_locking ));
            // Optimize performance for command files.
            heuristics[1] = MAKE_TCHAR('1');
            // Unlock and WriteUnlock asynchronously.
            heuristics[2] = MAKE_TCHAR('1'); // default
            // Close and WriteClose asynchronously.
            heuristics[3] = MAKE_TCHAR('1'); // default
            // Buffer named pipes and communication devices.
            heuristics[4] = MAKE_TCHAR(XsBoolToDigit(
                                wksta_502->wki502_buf_named_pipes ));
            // LockRead and WriteUnlock.
            heuristics[5] = MAKE_TCHAR(XsBoolToDigit(
                                wksta_502->wki502_use_lock_read_unlock ));
            // Use Open and Read.
            heuristics[6] = MAKE_TCHAR('0');
            // Read-ahead to sector boundary.
            heuristics[7] = MAKE_TCHAR('1');
            // Use the "chain send" NetBIOS NCB.
            heuristics[8] = MAKE_TCHAR('2');
            // Buffer small read/write requests.
            heuristics[9] = MAKE_TCHAR('1');
            // Use buffer mode.
            heuristics[10] = MAKE_TCHAR('3');
            // Use raw data transfer read/write server message block protocols.
            heuristics[11] = MAKE_TCHAR('1');
            // Use large RAW read-ahead buffer.
            heuristics[12] = MAKE_TCHAR('1');
            // Use large RAW write-behind buffer.
            heuristics[13] = MAKE_TCHAR('1');
            // Use read multiplex SMB protocols.
            heuristics[14] = MAKE_TCHAR('0');
            // Use write multiplex SMB protocols.
            heuristics[15] = MAKE_TCHAR('0');
            // Use big buffer for large core reads.
            heuristics[16] = MAKE_TCHAR('1');
            // Set the read-ahead size.
            heuristics[17] = MAKE_TCHAR('0');
            // Set the write-behind size.
            heuristics[18] = MAKE_TCHAR('0');
            // Force 512-byte maximum transfers to and from core servers.
            heuristics[19] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_use_512_byte_max_transfer ));
            // Flush pipes and devices on DosBufReset or DosClose.
            heuristics[20] = MAKE_TCHAR('0');
            // Use encryption if the server supports it.
            heuristics[21] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_use_encryption ));
            // Control log entries for multiple occurences of an error.
            heuristics[22] = MAKE_TCHAR('1');
            // Buffer all files opened with "deny write" rights.
            heuristics[23] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_buf_files_deny_write ));
            // Buffer all files opened with R attribute.
            heuristics[24] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_buf_read_only_files ));
            // Read ahead when opening a file for execution.
            heuristics[25] = MAKE_TCHAR('0');
            // Handle Ctrl-C.
            heuristics[26] = MAKE_TCHAR('2');
            // Force correct open mode when creating files on a core server.
            heuristics[27] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_force_core_create_mode ));
            // Use NetBIOS NoAck mode.
            heuristics[28] = MAKE_TCHAR('0');
            // Send data along with SMB write-block-RAW requests.
            heuristics[29] = MAKE_TCHAR('1');
            // Send a popup when the workstation logs an error.
            heuristics[30] = MAKE_TCHAR('1');
            // Close the print job, causing the remote spooler to print if no
            // activity occurs on the printer for the time specified.
            heuristics[31] = MAKE_TCHAR('0');
            // Controls BufReset and SMBFlush behavior for the MS-DOS
            // compatibility box.
            heuristics[32] = MAKE_TCHAR('2');
            // Controls the time-out value for performing logon validation from a
            // domain controller.
            heuristics[33] = MAKE_TCHAR('0');

            for ( i = 34; i <= 54; i++ ) {
                heuristics[i] = MAKE_TCHAR('0');
            }

            heuristics[SIZE_HEURISTICS-1] = MAKE_TCHAR('\0');

            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    heuristics,
                    &entry1->wki1_wrkheuristics,
                    entry1
                    );
            }

            //
            // Put default values in the fields that are meaningless in NT.
            //

            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_logon_server,
                    &entry1->wki1_logon_server,
                    entry1
                    );
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_username,
                    &entry1->wki1_username,
                    entry1
                    );
            }

            SmbPutUshort( &entry1->wki1_keepsearch,
                          (WORD) DEF16_wk_keepsearch );
            SmbPutUshort( &entry1->wki1_numworkbuf,
                          (WORD) DEF16_wk_numworkbuf );
            SmbPutUshort( &entry1->wki1_sizworkbuf,
                          (WORD) DEF16_wk_sizeworkbuf );
            SmbPutUshort( &entry1->wki1_maxwrkcache,
                          (WORD) DEF16_wk_maxwrkcache );
            SmbPutUshort( &entry1->wki1_sizerror,
                          (WORD) DEF16_wk_sizerror );
            SmbPutUshort( &entry1->wki1_numalerts,
                          (WORD) DEF16_wk_numalerts );
            SmbPutUshort( &entry1->wki1_numservices,
                          (WORD) DEF16_wk_numservices );
            SmbPutUshort( &entry1->wki1_errlogsz,
                          (WORD) DEF16_wk_errlogsz );
            SmbPutUshort( &entry1->wki1_printbuftime,
                          (WORD) DEF16_wk_printbuftime );
            SmbPutUshort( &entry1->wki1_numcharbuf,
                          (WORD) DEF16_wk_numcharbuf );
            SmbPutUshort( &entry1->wki1_sizcharbuf,
                          (WORD) DEF16_wk_sizcharbuf );
            SmbPutUshort( &entry1->wki1_mailslots,
                          (WORD) DEF16_wk_mailslots );

            break;

        case 10:

            //
            // Fill in the fields which have analogues in NT.
            //


            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    wksta_100->wki100_computername,
                    &entry10->wki10_computername,
                    entry10
                    );
                XsAddVarString(
                    stringLocation,
                    wksta_100->wki100_langroup,
                    &entry10->wki10_langroup,
                    entry10
                    );
            }

            entry10->wki10_ver_major = XsDwordToByte( wksta_100->wki100_ver_major );
            entry10->wki10_ver_minor = XsDwordToByte( wksta_100->wki100_ver_minor );

            //
            // Put default values in the fields that are meaningless in NT.
            //


            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_username,
                    &entry10->wki10_username,
                    entry10
                    );
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_logon_domain,
                    &entry10->wki10_logon_domain,
                    entry10
                    );
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_oth_domains,
                    &entry10->wki10_oth_domains,
                    entry10
                    );
            }

            break;
        }

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

        if ( varWrite == 0 ) {
            Header->Status = ERROR_MORE_DATA;
        } else {
            Header->Status = NERR_Success;
            Header->Converter = 0;
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( wksta_100 != NULL ) {
        NetApiBufferFree( wksta_100 );
    }

    if ( wksta_101 != NULL ) {
        NetApiBufferFree( wksta_101 );
    }

    if ( wksta_502 != NULL ) {
        NetApiBufferFree( wksta_502 );
    }

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetWkstaGetInfo



NTSTATUS
XsNetWkstaSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetWkstaSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    NET_API_STATUS status;

    PXS_NET_WKSTA_SET_INFO parameters = Parameters;
    DWORD data;
    BOOL flag;
    DWORD nativeParmNum;

    LPVOID buffer = NULL;                   // Conversion variables
    DWORD bufferSize;
    LPWKSTA_16_INFO_1 entry1;
    LPWKSTA_16_INFO_10 entry10;
    BOOL error;
    DWORD parmNum;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors. We will filter out wrong levels now.
        //

        parmNum = SmbGetUshort( &parameters->ParmNum );

        switch ( SmbGetUshort( &parameters->Level )) {

        case 0:
            StructureDesc = Desc16_wksta_info_0;
            if ( parmNum == WKSTA_OTH_DOMAINS_PARMNUM ) {
                Header->Status = ERROR_INVALID_LEVEL;
                goto cleanup;
            }

            break;

        case 1:
            StructureDesc = Desc16_wksta_info_1;
            break;

        case 10:
            StructureDesc = Desc16_wksta_info_10;
            if ( parmNum == WKSTA_CHARWAIT_PARMNUM
                 || parmNum == WKSTA_CHARTIME_PARMNUM
                 || parmNum == WKSTA_CHARCOUNT_PARMNUM
                 || parmNum == WKSTA_ERRLOGSZ_PARMNUM
                 || parmNum == WKSTA_PRINTBUFTIME_PARMNUM
                 || parmNum == WKSTA_WRKHEURISTICS_PARMNUM ) {

                Header->Status = ERROR_INVALID_LEVEL;
                goto cleanup;
            }

            break;

        default:

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
            break;
        }

        //
        // Check input buffer size if parmnum is PARMNUM_ALL.
        //

        if ( parmNum == PARMNUM_ALL ) {

            if ( !XsCheckBufferSize(
                      SmbGetUshort( &parameters->BufLen ),
                      StructureDesc,
                      FALSE  // not in native format
                      )) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }
        }

        buffer = (LPVOID)XsSmbGetPointer( &parameters->Buffer );
        bufferSize = (DWORD)SmbGetUshort( &parameters->BufLen );
        entry1 = (LPWKSTA_16_INFO_1)buffer;
        entry10 = (LPWKSTA_16_INFO_10)buffer;

        //
        // Processing of this API depends on the value of the ParmNum
        // parameter. Because of all the discrepancies between NT and downlevel
        // info structures, we will handle each instance by hand.
        //

        error = TRUE;

        //
        // charwait - source data is in a WORD - convert to DWORD
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_CHARWAIT_PARMNUM ) {

            if ( bufferSize < sizeof(WORD) ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            data = ( parmNum == PARMNUM_ALL )
                       ? (DWORD)SmbGetUshort( &entry1->wki1_charwait )
                       : (DWORD)SmbGetUshort( (LPWORD)buffer );

            status = NetWkstaSetInfo(
                         NULL,
                         PARMNUM_BASE_INFOLEVEL + WKSTA_CHARWAIT_PARMNUM,
                         (LPBYTE)&data,
                         NULL
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetWkstaSetInfo : SetInfo of charwait failed"
                                  "%X\n", status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // chartime - source data is in a DWORD - convert to DWORD
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_CHARTIME_PARMNUM ) {

            if ( bufferSize < sizeof(DWORD) ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            data = ( parmNum == PARMNUM_ALL )
                       ? SmbGetUlong( &entry1->wki1_chartime )
                       : SmbGetUlong( (LPDWORD)buffer );

            status = NetWkstaSetInfo(
                         NULL,
                         PARMNUM_BASE_INFOLEVEL + WKSTA_CHARTIME_PARMNUM,
                         (LPBYTE)&data,
                         NULL
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetWkstaSetInfo : SetInfo of chartime failed"
                                  "%X\n", status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // charcount - source data is in a WORD - convert to DWORD
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_CHARCOUNT_PARMNUM ) {

            if ( bufferSize < sizeof(WORD) ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            data = ( parmNum == PARMNUM_ALL )
                       ? (DWORD)SmbGetUshort( &entry1->wki1_charcount )
                       : (DWORD)SmbGetUshort( (LPWORD)buffer );

            status = NetWkstaSetInfo(
                         NULL,
                         PARMNUM_BASE_INFOLEVEL + WKSTA_CHARCOUNT_PARMNUM,
                         (LPBYTE)&data,
                         NULL
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetWkstaSetInfo : SetInfo of charcount failed"
                                  "%X\n", status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // errlogsz, printbuftime - source data is in a WORD.
        //
        // We can't set this, but downlevel can, so indicate success,
        // as long as something was sent.
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_ERRLOGSZ_PARMNUM
                                    || parmNum == WKSTA_PRINTBUFTIME_PARMNUM ) {

            if ( bufferSize < sizeof(WORD) ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // othdomains - source data is a string.
        //
        // We can't set this, but downlevel can, so indicate success,
        // as long as something was sent.
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_OTH_DOMAINS_PARMNUM ) {

            if ( bufferSize == 0 ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // wrkheuristics - source data is in a string.
        //
        // There are some elements of this that we can set. We go through a loop,
        // setting these.
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_WRKHEURISTICS_PARMNUM ) {

            LPBYTE heuristics;
            DWORD i;

            if ( bufferSize < 54 ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            heuristics = ( parmNum == PARMNUM_ALL )
                             ? (LPBYTE)XsSmbGetPointer( &entry1->wki1_wrkheuristics )
                             : (LPBYTE)buffer;

            //
            // Nothing to be changed
            //

            if ( heuristics == NULL ) {
                goto cleanup;
            }

            //
            // Make sure we have the right size of string.
            //

            if ( strlen( heuristics ) != 54 ) {

                Header->Status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            for ( i = 0; i < 54; i++ ) {

                //
                // Make sure heuristics string is valid.
                //

                if ( !isdigit( heuristics[i] )) {

                    Header->Status = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                }

                //
                // Check if we can set this field.
                //

                switch ( i ) {

                case 0:
                    nativeParmNum = WKSTA_USEOPPORTUNISTICLOCKING_PARMNUM;
                    break;
                case 4:
                    nativeParmNum = WKSTA_BUFFERNAMEDPIPES_PARMNUM;
                    break;
                case 5:
                    nativeParmNum = WKSTA_USELOCKANDREADANDUNLOCK_PARMNUM;
                    break;
                case 19:
                    nativeParmNum = WKSTA_USE512BYTESMAXTRANSFER_PARMNUM;
                    break;
                case 21:
                    nativeParmNum = WKSTA_USEENCRYPTION_PARMNUM;
                    break;
                case 23:
                    nativeParmNum = WKSTA_BUFFILESWITHDENYWRITE_PARMNUM;
                    break;
                case 24:
                    nativeParmNum = WKSTA_BUFFERREADONLYFILES_PARMNUM;
                    break;
                case 27:
                    nativeParmNum = WKSTA_FORCECORECREATEMODE_PARMNUM;
                    break;
                default:
                    nativeParmNum = 0;
                    break;

                }

                //
                // If we can set the field, set it.
                //

                if ( nativeParmNum != 0 ) {

                    if ( heuristics[i] != '0' && heuristics[i] != '1' ) {

                        Header->Status = ERROR_INVALID_PARAMETER;
                        goto cleanup;
                    }

                    flag = XsDigitToBool( heuristics[i] );

                    status = NetWkstaSetInfo(
                                 NULL,
                                 PARMNUM_BASE_INFOLEVEL + nativeParmNum,
                                 (LPBYTE)&flag,
                                 NULL
                                 );

                    if ( status != NERR_Success ) {
                        IF_DEBUG(ERRORS) {
                            NetpKdPrint(( "XsNetWkstaSetInfo : SetInfo of a "
                                          "heuristic failed: %X\n", status ));
                        }
                        Header->Status = (WORD)status;
                        goto cleanup;
                    }
                }
            }

            error = FALSE;
        }

        //
        // Tried all possible parmnums. If error is still set, we have an
        // invalid parmnum on our hands.
        //

        if ( error ) {

            Header->Status = ERROR_INVALID_PARAMETER;

        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    return STATUS_SUCCESS;

} // XsNetWkstaSetInfo


NTSTATUS
XsNetWkstaSetUID (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This temporary routine just returns STATUS_NOT_IMPLEMENTED.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    Header->Status = (WORD)NERR_InvalidAPI;

    return STATUS_SUCCESS;

} // XsNetWkstaSetUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apiuser.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ApiUser.c

Abstract:

    This module contains individual API handlers for the NetUser APIs.

    SUPPORTED : NetUserAdd2, NetUserDel, NetUserEnum, NetUserEnum2,
                NetUserGetGroups, NetUserGetInfo, NetUserModalsGet,
                NetUserModalsSet, NetUserSetGroups, NetUserSetInfo2,
                NetUserSetInfo, NetUserPasswordSet2

    UNSUPPORTED :  NetUserValidate2.

Author:

    Shanku Niyogi (w-shanku) 11-Feb-1991

Revision History:

--*/

//
// NetUser APIs are UNICODE only.
//

#ifndef UNICODE
#define UNICODE
#endif

#include "xactsrvp.h"
#include <crypt.h>
#include "changepw.h"
#include <loghours.h>
#include <netlibnt.h>
#include <names.h>
#include <prefix.h>     // PREFIX_ equates.

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_user_info_0 = REM16_user_info_0;
STATIC const LPDESC Desc32_user_info_0 = REM32_user_info_0;

STATIC const LPDESC Desc16_user_info_1 = REM16_user_info_1;
STATIC const LPDESC Desc32_user_info_1 = REM32_user_info_1;
STATIC const LPDESC Desc32_user_info_1_NC = REM32_user_info_1_NOCRYPT;
STATIC const LPDESC Desc32_user_info_1_OWF = REM32_user_info_1_OWF;
STATIC const LPDESC Desc16_user_info_1_setinfo = REM16_user_info_1_setinfo;
STATIC const LPDESC Desc32_user_info_1_setinfo = REM32_user_info_1_setinfo;
STATIC const LPDESC Desc32_user_info_1_setinfo_NC = REM32_user_info_1_setinfo_NOCRYPT;

STATIC const LPDESC Desc16_user_info_2 = REM16_user_info_2;
STATIC const LPDESC Desc32_user_info_2 = REM32_user_info_2;
STATIC const LPDESC Desc32_user_info_2_NC = REM32_user_info_2_NOCRYPT;
STATIC const LPDESC Desc16_user_info_2_setinfo = REM16_user_info_2_setinfo;
STATIC const LPDESC Desc32_user_info_2_setinfo = REM32_user_info_2_setinfo;
STATIC const LPDESC Desc32_user_info_2_setinfo_NC = REM32_user_info_2_setinfo_NOCRYPT;

STATIC const LPDESC Desc16_user_info_10 = REM16_user_info_10;
STATIC const LPDESC Desc32_user_info_10 = REM32_user_info_10;
STATIC const LPDESC Desc16_user_info_11 = REM16_user_info_11;
STATIC const LPDESC Desc32_user_info_11 = REM32_user_info_11;
STATIC const LPDESC Desc32_user_info_22 = REM32_user_info_22;

STATIC const LPDESC Desc16_user_group_info_0 = REM16_group_info_0;
STATIC const LPDESC Desc32_user_group_info_0 = REM32_group_info_0;
STATIC const LPDESC Desc16_user_group_info_0_set
                        = REM16_group_users_info_0_set;
STATIC const LPDESC Desc32_user_group_info_0_set
                        = REM32_group_users_info_0_set;

STATIC const LPDESC Desc16_user_modals_info_0 = REM16_user_modals_info_0;
STATIC const LPDESC Desc32_user_modals_info_0 = REM32_user_modals_info_0;
STATIC const LPDESC Desc16_user_modals_info_0_setinfo
                        = REM16_user_modals_info_0_setinfo;
STATIC const LPDESC Desc32_user_modals_info_0_setinfo
                        = REM32_user_modals_info_0_setinfo;
STATIC const LPDESC Desc16_user_modals_info_1 = REM16_user_modals_info_1;
STATIC const LPDESC Desc32_user_modals_info_1 = REM32_user_modals_info_1;
STATIC const LPDESC Desc16_user_modals_info_1_setinfo
                        = REM16_user_modals_info_1_setinfo;
STATIC const LPDESC Desc32_user_modals_info_1_setinfo
                        = REM32_user_modals_info_1_setinfo;


STATIC NET_API_STATUS
XsGetMinPasswordLength(
    LPDWORD minPasswordLength
    )
{
    NET_API_STATUS apiStatus;
    LPUSER_MODALS_INFO_0 modals = NULL;
    HANDLE                      OpenedToken;

    NetpAssert( minPasswordLength != NULL );

    //
    // Revert to Local System
    //
    (VOID)NtOpenThreadToken(
                NtCurrentThread(),
                MAXIMUM_ALLOWED,
                TRUE,
                &OpenedToken
            );

    RevertToSelf();

    //
    // Find out how long the password has to be.
    //

    apiStatus = NetUserModalsGet(
            NULL,                       // local (no server name)
            0,                          // level
            (LPBYTE *)&modals );        // alloc and set ptr

    //
    // Re-impersonate the client
    //
    (VOID)NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        &OpenedToken,
                        sizeof( OpenedToken )
                        );

    if ( apiStatus != NO_ERROR ) {
        NetpKdPrint(( PREFIX_XACTSRV
                "XsGetMinPasswordLength: Problems getting modals: "
                FORMAT_API_STATUS ".\n", apiStatus ));
        return (apiStatus);
    }
    NetpAssert( modals != NULL );

    *minPasswordLength = modals->usrmod0_min_passwd_len;
    (VOID) NetApiBufferFree( (LPVOID)modals );
    return (NO_ERROR);

} // XsGetMinPasswordLength


STATIC NET_API_STATUS
XsCheckAndReplacePassword (
    IN DWORD Length
    )

/*++

Routine Description

    This routine checks the current password's real length to make sure
    it is valid, and then generates a reasonably random replacement password
    long enough to satisfy the system's modal for minimum password length.
    This routine is used by Add and SetInfo handlers below.

Arguments:

    Length - Real length of the current password.

    Seed - A seed number.

    TempPassword - Receives a pointer to a new temporary password. If
        this is not specified, the new password is not generated.

Return Value:

    NET_API_STATUS - NERR_Success on successful completion, or some other
        error status.

--*/

{
    NET_API_STATUS status;
    DWORD minPasswordLength;

    //
    // Find out how long the password has to be.
    //

    status = XsGetMinPasswordLength( &minPasswordLength );


    if ( status != NERR_Success ) {
        NetpKdPrint(( PREFIX_XACTSRV
                "XsCheckAndReplacePassword: Problems getting min PW len: "
                FORMAT_API_STATUS ".\n", status ));
        return status;
    }

    //
    // Check length of current password.
    //

    if ( Length < minPasswordLength ) {

        return NERR_PasswordTooShort;
    }


    return NERR_Success;

}


NET_API_STATUS
XsNameToRid(
    IN LPCTSTR Name,      // may be user or group name.
    IN SID_NAME_USE ExpectedType,
    OUT PULONG UserRid
    )
{
    NET_API_STATUS status;
    PSID_NAME_USE nameUse;
    NTSTATUS ntstatus;
    UNICODE_STRING unicodeName;
    PULONG tempRid;
    PSID accountsDomainId;
    SAM_HANDLE samConnectHandle;
    SAM_HANDLE samAccountsDomainHandle;

    if( ARGUMENT_PRESENT( UserRid ) ) {
        *UserRid = 0;
    }

    //
    // Get a connection to SAM.
    //

    ntstatus = SamConnect(
                    NULL,                       // no server name (local)
                    &samConnectHandle,          // resulting SAM handle
                    SAM_SERVER_LOOKUP_DOMAIN,   // desired access
                    NULL                        // no object attributes
                    );
    if ( !NT_SUCCESS( ntstatus ) ) {
        status = NetpNtStatusToApiStatus( ntstatus );
        return status;
    }

    //
    // To open the accounts domain, we'll need the domain ID.
    //

    status = NetpGetLocalDomainId (
                LOCAL_DOMAIN_TYPE_ACCOUNTS, // type we want.
                &accountsDomainId
                );
    if ( status != NO_ERROR ) {
        SamCloseHandle( samConnectHandle );
        return status;
    }

    //
    // Open the accounts domain.
    //

    ntstatus = SamOpenDomain(
                    samConnectHandle,
                    DOMAIN_LOOKUP,
                    accountsDomainId,
                    &samAccountsDomainHandle
                    );
    if ( !NT_SUCCESS( ntstatus ) ) {
        LocalFree( accountsDomainId );
        SamCloseHandle( samConnectHandle );
        status = NetpNtStatusToApiStatus( ntstatus );
        return status;
    }

    //
    // Get a RID for this user name.
    //

    RtlInitUnicodeString(
            &unicodeName,       // dest (NT struct)
            Name );             // src (null-terminated)

    ntstatus = SamLookupNamesInDomain(
                    samAccountsDomainHandle,    // users live in accounts domain
                    (ULONG)1,                   // only want one name.
                    &unicodeName,               // name (in NT struct)
                    &tempRid,                   // alloc and set RIDs.
                    &nameUse                    // alloc and set name types.
                    );

    if ( !NT_SUCCESS( ntstatus ) ) {
        status = NetpNtStatusToApiStatus( ntstatus );
        goto cleanup;
    }

    *UserRid = *tempRid;

    //
    // Did type user wanted match the actual one?
    //

    if ( ExpectedType != *nameUse ) {
        status = ERROR_INVALID_PARAMETER;   
    } else {
        status = NO_ERROR;
    }

    //
    // Free memory which SAM allocated for us.
    //

    ntstatus = SamFreeMemory( nameUse );
    if ( !NT_SUCCESS( ntstatus ) ) {
        status = NetpNtStatusToApiStatus( ntstatus );
    }

    ntstatus = SamFreeMemory( tempRid );
    if ( !NT_SUCCESS( ntstatus ) ) {
        status = NetpNtStatusToApiStatus( ntstatus );
    }

cleanup:

    LocalFree( accountsDomainId );
    SamCloseHandle( samAccountsDomainHandle );
    SamCloseHandle( samConnectHandle );

    return status;

} // XsNameToRid


NET_API_STATUS
XsSetMacPrimaryGroup(
    IN LPCTSTR UserName,
    IN LPCTSTR MacPrimaryField   // field in "mGroup:junk" format.
    )
{
    NET_API_STATUS status;
    LPTSTR groupName = NULL;
    ULONG groupRid;
    USER_INFO_1051 userInfo;

    //
    // Extract the primary group name from the Mac field.
    //

    status = NetpGetPrimaryGroupFromMacField(
                MacPrimaryField,              // name in "mGroup:" format.
                &groupName                    // alloc and set ptr.
                );
    if ( status != NO_ERROR ) {
        goto cleanup;
    }

    //
    // Make sure this user is a member of the group (add to group if needed).
    // This will also check if the group and user exist.
    //

    status = NetGroupAddUser(
                NULL,                       // local (no server name)
                groupName,                  // group to update
                (LPTSTR)UserName            // user name to add to group
                );
    if ( (status != NO_ERROR) && (status != NERR_UserInGroup) ) {
        goto cleanup;
    }

    //
    // Convert the group name to a RID.
    //

    status = XsNameToRid(
                (LPCWSTR)groupName,
                SidTypeGroup,       // expected type
                &groupRid
                );
    if ( status != NO_ERROR ) {
        goto cleanup;
    }

    //
    // Call NetUserSetInfo to set the primary group ID using the RID.
    //

    userInfo.usri1051_primary_group_id = (DWORD)groupRid;

    status = NetUserSetInfo (
                NULL,                       // local (no server name)
                (LPTSTR)UserName,
                PARMNUM_BASE_INFOLEVEL + USER_PRIMARY_GROUP_PARMNUM,
                (LPVOID)&userInfo,
                NULL                        // don't care about parmnum
                );

cleanup:

    if ( groupName != NULL ) {
        NetpMemoryFree( groupName );
    }

    return status;

} // XsSetMacPrimaryGroup


NTSTATUS
XsNetUserAdd2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserAdd. A remote NetUserAdd call
    from a 16-bit machine will translate to a NetUserAdd2 call, with
    a doubly encrypted password. We will call a special level of
    NetUserSetInfo to set this later, after the user has been added.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_ADD_2 parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters
    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;
    LPBYTE nativeStructureDesc;
    LPUSER_INFO_1 user = NULL;
    DWORD parmError;
    DWORD level;
    BOOLEAN encryptionSupported = TRUE;
    PUSER_INFO_22 usri22;
    BYTE tempPwdBuffer[ENCRYPTED_PWLEN];

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USER) {
        NetpKdPrint(( "XsNetUserAdd2: header at %lx, params at %lx, "
                      "level %ld\n",
                      Header, parameters,
                      SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check if password is encrypted.  We know for a fact that dos redirs
        // don't support encryption
        //

        encryptionSupported = (BOOLEAN)
                ( SmbGetUshort( &parameters->DataEncryption ) == TRUE );
        level = SmbGetUshort( &parameters->Level );

        //
        // Check for password length
        //

        status = XsCheckAndReplacePassword( (DWORD)( SmbGetUshort( &parameters->PasswordLength )) );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd2: XsCheckAndReplacePassword failed: "
                              "%X\n", status ));
            }
            goto cleanup;
        }

        //
        // Use the requested level to determine the format of the 32-bit
        // we need to pass to NetUserAdd. The format of the
        // 16-bit structure is stored in the transaction block, and we
        // got a pointer to it as a parameter.
        //

        switch ( level ) {

        case 1:
            StructureDesc = Desc16_user_info_1;
            nativeStructureDesc = Desc32_user_info_1_OWF;
            break;

        case 2:
            StructureDesc = Desc16_user_info_2;
            nativeStructureDesc = Desc32_user_info_22;
            break;

        default:
            status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }


        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd2: Buffer too small.\n" ));
            }
            status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.  Always allocate
        // a level 22 buffer since we will always be making a level 22
        // call to netuseradd.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         Desc32_user_info_22,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd2: failed to create buffer" ));
            }
            status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserAdd2: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     nativeStructureDesc,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            status = NERR_InternalError;
            goto cleanup;
        }

        usri22 = buffer;

        //
        // If this is a level 1 call, then we did not fill up all the
        // entries required for a level 22 call.  Put the default values
        // here.
        //

        if ( level == 1 ) {

            //
            // These are not used in a NetUserAdd.
            //
            // usri22->usri22_last_logon
            // usri22->usri22_last_logoff
            // usri22->usri22_units_per_week
            // usri22->usri22_bad_pw_count
            // usri22->usri22_num_logons
            //

            usri22->usri22_auth_flags = 0;
            usri22->usri22_full_name = NULL;
            usri22->usri22_usr_comment = NULL;
            usri22->usri22_parms = NULL;
            usri22->usri22_workstations = NULL;
            usri22->usri22_acct_expires = TIMEQ_FOREVER;
            usri22->usri22_max_storage = USER_MAXSTORAGE_UNLIMITED;
            usri22->usri22_logon_hours = NULL;
            usri22->usri22_logon_server = NULL;
            usri22->usri22_country_code = 0;
            usri22->usri22_code_page = 0;

        } else if ( usri22->usri22_logon_hours != NULL ) {

            //
            // Call NetpRotateLogonHours to make sure we behave properly
            // during DST.
            //

            if ( !NetpRotateLogonHours(
                        usri22->usri22_logon_hours,
                        usri22->usri22_units_per_week,
                        TRUE
                        ) ) {

                status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

        }

        //
        // If the password is clear text, we need to convert it to an OWF
        // password.  This is to fix a LMUNIX bug which forgets to upper
        // case the password it sends across.  Converting it to OWF
        // tells sam not to do upcasing.
        //
        // If the password is encrypted, then we get the owf by decrypting
        // it with the session key.
        //

        RtlCopyMemory(
                tempPwdBuffer,
                usri22->usri22_password,
                ENCRYPTED_PWLEN
                );

        if ( !encryptionSupported ) {

            (VOID) RtlCalculateLmOwfPassword(
                                (PLM_PASSWORD) tempPwdBuffer,
                                (PLM_OWF_PASSWORD) usri22->usri22_password
                                );


        } else {

            (VOID) RtlDecryptLmOwfPwdWithLmSesKey(
                                    (PENCRYPTED_LM_OWF_PASSWORD) tempPwdBuffer,
                                    (PLM_SESSION_KEY) Header->EncryptionKey,
                                    (PLM_OWF_PASSWORD) usri22->usri22_password
                                    );

        }

        //
        // Make the local call.
        //

        status = NetUserAdd(
                         NULL,
                         22,
                         (LPBYTE) usri22,
                         &parmError
                         );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd2: NetUserAdd failed: %X\n", status ));
                if ( status == ERROR_INVALID_PARAMETER ) {
                    NetpKdPrint(( "XsNetUserAdd2: ParmError: %ld\n",
                                  parmError ));

                }
            }
            goto cleanup;
        }

        //
        // If there was a Macintosh primary group field for this user, then
        // set the primary group.
        //

        if ( NetpIsMacPrimaryGroupFieldValid( (LPCTSTR)usri22->usri22_parms ) ) {
            NET_API_STATUS status1;
            status1 = XsSetMacPrimaryGroup(
                        (LPCTSTR)usri22->usri22_name,
                        (LPCTSTR)usri22->usri22_parms
                        );
            if ( !XsApiSuccess( status1 )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetUserAdd2: SetMacPrimaryGroup failed: %X\n",
                                    status1 ));
                }
            }
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    Header->Status = (WORD)status;

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetUserAdd2


NTSTATUS
XsNetUserDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_DEL parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USER) {
        NetpKdPrint(( "XsNetUserDel: header at %lx, params at %lx, name %s\n",
                      Header, parameters, SmbGetUlong( &parameters->UserName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Make the local call.
        //

        status = NetUserDel(
                     NULL,
                     nativeUserName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserDel: NetUserDel failed: %X\n", status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeUserName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;
}


NTSTATUS
XsNetUserEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description

    This routine handles a call to NetUserEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_ENUM parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD bytesRequired = 0;
    LPBYTE nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid parameters

    IF_DEBUG(USER) {
        NetpKdPrint(( "XsNetUserEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if (( XsWordParamOutOfRange( parameters->Level, 0, 2 ))
             && SmbGetUshort( &parameters->Level ) != 10 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetUserEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     FILTER_NORMAL_ACCOUNT,
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUserEnum: NetUserEnum failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_user_info_0;
            StructureDesc = Desc16_user_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_user_info_1;
            StructureDesc = Desc16_user_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_user_info_2;
            StructureDesc = Desc16_user_info_2;
            break;

        case 10:

            nativeStructureDesc = Desc32_user_info_10;
            StructureDesc = Desc16_user_info_10;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(USER) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserEnum


NTSTATUS
XsNetUserEnum2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserEnum. This version supports a
    resumable handle.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_ENUM_2 parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD TotalEntriesToReturn = 0;
    LPDESC nativeStructureDesc;
    DWORD nativeBufferSize = 0xFFFFFFFF;

    DWORD entriesRead = 0;
    DWORD PreviousEntriesRead;
    DWORD totalEntries;
    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD bytesRequired;

    LPBYTE bufferBegin;
    DWORD bufferSize;
    DWORD totalEntriesRead= 0;
    DWORD resumeKey;

    LPBYTE SavedBufferBegin;
    DWORD SavedBufferSize;
    DWORD SavedTotalEntriesRead;
    DWORD SavedResumeKey;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserEnum2: header at %lx, params at %lx, "
                          "level %ld, buf size %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ),
                          SmbGetUshort( &parameters->BufLen )));
        }

        //
        // Copy input resume handle to output resume handle, and get a copy of it.
        //

        resumeKey = SmbGetUlong( &parameters->ResumeIn );
        SmbPutUlong( &parameters->ResumeOut, resumeKey );

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserEnum2: resume key is %ld\n", resumeKey ));
        }

        //
        // Use the level to determine the descriptor string.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_user_info_0;
            StructureDesc = Desc16_user_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_user_info_1;
            StructureDesc = Desc16_user_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_user_info_2;
            StructureDesc = Desc16_user_info_2;
            break;

        case 10:

            nativeStructureDesc = Desc32_user_info_10;
            StructureDesc = Desc16_user_info_10;
            break;

        default:

            //
            // Unsupported levels, abort before any work.
            //

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // NetUserEnum2 is a resumable API, so we cannot get more information
        // from the native call than we can send back. The most efficient way
        // to do this is in a loop...we use the 16-bit buffer size to determine
        // a safe native buffer size, make the call, fill the entries, then
        // take the amount of space remaining and determine a safe size again,
        // and so on, until NetUserEnum returns either no entries or all entries
        // read.
        //

        //
        // Initialize important variables for loop.
        //

        bufferBegin = (LPBYTE)XsSmbGetPointer( &parameters->Buffer );
        bufferSize = (DWORD)SmbGetUshort( &parameters->BufLen );
        totalEntriesRead = 0;

        for ( ; ; ) {


            //
            // Compute a safe size for the native buffer.
            //
            // It is better to underguess than overguess.  NetUserEnum is relatively
            // efficient (especially in the local case) at resuming an enumeration.
            // It is relatively inefficient at returning detailed information about
            // the enumerated users.
            //
            // If nativeBufferSize reaches 1 (or 0),
            //  NetUserEnum will typically enumerate a single user.
            //

            if ( nativeBufferSize > bufferSize/2 ) {
                nativeBufferSize = bufferSize/2;
            }

            //
            // Remember how many we read last time to ensure we make progress.
            //

            PreviousEntriesRead = entriesRead;

            //
            // Save away a copy of all the important variables.
            //
            // The NetUserEnum API can actually overshoot its PrefMaxLen.  The
            // values being saved are values known to not already have been overshot.
            // We can restore these values later if needed.
            //

            SavedBufferBegin = bufferBegin;
            SavedBufferSize = bufferSize;
            SavedTotalEntriesRead = totalEntriesRead;
            SavedResumeKey = resumeKey;


            //
            // Make the local call.
            //

            status = NetUserEnum(
                         NULL,
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         FILTER_NORMAL_ACCOUNT,
                         (LPBYTE *)&outBuffer,
                         nativeBufferSize,
                         &entriesRead,
                         &totalEntries,
                         &resumeKey
                         );

            if ( !XsApiSuccess( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetUserEnum2: NetUserEnum failed: %X\n",
                                  status ));
                }

                Header->Status = (WORD)status;
                goto cleanup;
            }

            IF_DEBUG(USER) {
                NetpKdPrint(( "XsNetUserEnum2: received %ld entries out of %ld at %lx asking for %ld bytes.\n",
                              entriesRead, totalEntries, outBuffer, nativeBufferSize ));

                NetpKdPrint(( "XsNetUserEnum2: resume key is now %ld\n",
                              resumeKey ));
            }

            //
            // Keep track of the total entries available.
            //

            if ( totalEntries > TotalEntriesToReturn ) {
                TotalEntriesToReturn = totalEntries;
            }

            //
            // Was NetUserEnum able to read at least one complete entry?
            //

            if ( entriesRead == 0 ) {
                break;
            }

            //
            // Do the actual conversion from the 32-bit structures to 16-bit
            // structures.
            //

            XsFillEnumBuffer(
                outBuffer,
                entriesRead,
                nativeStructureDesc,
                bufferBegin,
                (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                bufferSize,
                StructureDesc,
                NULL,  // verify function
                &bytesRequired,
                &entriesFilled,
                NULL
                );

            IF_DEBUG(USER) {
                NetpKdPrint(( "XsNetUserEnum2: 32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                              " Entries %ld of %ld\n",
                              outBuffer, SmbGetUlong( &parameters->Buffer ),
                              bytesRequired, entriesFilled, entriesRead ));
            }

            //
            // If NetUserEnum overshot PrefMaxLen,
            //  we can't simply return the collected data since we wouldn't
            //  know what to use as a ResumeHandle.
            //

            if ( entriesRead != entriesFilled ) {

                //
                // Restore the saved values.
                //

                bufferBegin = SavedBufferBegin;
                bufferSize = SavedBufferSize;
                totalEntriesRead = SavedTotalEntriesRead;
                resumeKey = SavedResumeKey;

                //
                // If we have ANY data to return to the caller,
                //  return the short list now rather than trying to outguess NetUserEnum
                //

                if ( totalEntriesRead != 0 ) {
                    IF_DEBUG(USER) {
                        NetpKdPrint(( "XsNetUserEnum2: couldn't pack data: return previous data\n" ));
                    }
                    break;
                }

                //
                // If we've already asked NetUserEnum for the smallest amount,
                //  just give up.
                //

                if ( nativeBufferSize == 1 || entriesRead == 1 ) {

                    status = NERR_BufTooSmall;
                    IF_DEBUG(API_ERRORS) {
                        NetpKdPrint(( "XsNetUserEnum2: NetUserEnum buffer too small: %X\n",
                                      status ));
                    }

                    Header->Status = (WORD)status;
                    goto cleanup;
                }

                //
                // Otherwise, trim it down and try again.
                //  If we've tried twice and gotten the same result,
                //      be really agressive.
                //

                if ( entriesRead == PreviousEntriesRead || entriesRead < 10 ) {
                    nativeBufferSize = 1;
                } else {
                    nativeBufferSize /= 2;
                }

            //
            // If NetUserEnum returned useful data,
            //  account for it.
            //

            } else {
                //
                // Update count of entries read.
                //

                totalEntriesRead += entriesRead;

                //
                // Are there any more entries to read?
                //

                if ( entriesRead == totalEntries ) {
                    break;
                }

                //
                // If we've made the nativeBufferSize so small we're barely making
                //  progress,
                //  just return what we have to the caller.
                //

                if ( entriesRead == 1 ) {
                    break;
                }

                //
                // Calculate new buffer beginning and size.
                //

                bufferBegin += entriesRead *
                                   RapStructureSize( StructureDesc, Response, FALSE );
                bufferSize -= bytesRequired;

                //
                // Don't hassle the last few bytes,
                //  we'll just overshoot anyway.
                //

                if ( bufferSize < 50 ) {
                    break;
                }
            }


            //
            // Free last native buffer.
            //

            NetApiBufferFree( outBuffer );
            outBuffer = NULL;

        }

        //
        // Upon exit from the loop, totalEntriesRead has the number of entries
        // read, TotalEntriesToReturn has the number available from NetUserEnum.
        // Formulate return codes, etc. from these values.
        //

        if ( totalEntriesRead < TotalEntriesToReturn ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    totalEntriesRead
                                    );

        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserEnum2: returning %ld entries of %ld. Resume key is now %ld\n",
                          totalEntriesRead,
                          TotalEntriesToReturn,
                          resumeKey ));
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)totalEntriesRead );
        SmbPutUshort( &parameters->TotalAvail,
            (WORD)( TotalEntriesToReturn ));
        SmbPutUlong( &parameters->ResumeOut, resumeKey );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        totalEntriesRead,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserEnum2


NTSTATUS
XsNetUserGetGroups (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserGetGroups.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_GET_GROUPS parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    LPVOID outBuffer= NULL;
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD bytesRequired = 0;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserGetGroups: header at %lx, params at %lx, "
                          "level %ld, buf size %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ),
                          SmbGetUshort( &parameters->BufLen )));
        }

        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Get the actual information from the local 32-bit call.
        //

        status = NetUserGetGroups(
                     NULL,
                     nativeUserName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUserGetGroups: NetUserGetGroups failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserGetGroups: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Do the conversion from 32- to 16-bit data.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            Desc32_user_group_info_0,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            Desc16_user_group_info_0,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(USER) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If there is no room for one fixed structure, return NERR_BufTooSmall.
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. GROUP_INFO_0 structures don't
        // need to be packed, because they have no variable data.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 Desc16_user_group_info_0,
                 FALSE   // not in native format
                 )) {

            Header->Status = NERR_BufTooSmall;

        } else if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeUserName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        Desc16_user_group_info_0,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserGetGroups


NTSTATUS
XsNetUserGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_GET_INFO parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPBYTE nativeStructureDesc;
    DWORD level;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserGetInfo: header at %lx, "
                          "params at %lx, level %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ) ));
        }

        //
        // Translate parameters, check for errors.
        //

        level = SmbGetUshort( &parameters->Level );

        if ( XsWordParamOutOfRange( level, 0, 2 )
             && XsWordParamOutOfRange( level, 10, 11 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Make the local call.
        //

        status = NetUserGetInfo(
                     NULL,
                     nativeUserName,
                     level,
                     (LPBYTE *)&outBuffer
                     );


        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUserGetInfo: NetUserGetInfo failed: "
                            "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( level ) {

        case 0:

            nativeStructureDesc = Desc32_user_info_0;
            StructureDesc = Desc16_user_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_user_info_1;
            StructureDesc = Desc16_user_info_1;
            break;

        case 2:

            {
                PUSER_INFO_2 usri2 = outBuffer;

                //
                // Call NetpRotateLogonHours to make sure we behave properly
                // during DST.
                //

                if ( usri2->usri2_logon_hours != NULL ) {

                    if ( !NetpRotateLogonHours(
                                usri2->usri2_logon_hours,
                                usri2->usri2_units_per_week,
                                FALSE
                                ) ) {

                        Header->Status = NERR_InternalError;
                        goto cleanup;
                    }
                }

                //
                // Truncate UserParms to 48 bytes
                //

                if (( usri2->usri2_parms != NULL ) &&
                    (wcslen(usri2->usri2_parms) > LM20_MAXCOMMENTSZ))
                {
                    *(usri2->usri2_parms + LM20_MAXCOMMENTSZ) = UNICODE_NULL;
                }
                
                nativeStructureDesc = Desc32_user_info_2;
                StructureDesc = Desc16_user_info_2;
            }
            break;

        case 10:

            nativeStructureDesc = Desc32_user_info_10;
            StructureDesc = Desc16_user_info_10;
            break;

        case 11:

            {
                PUSER_INFO_11 usri11 = outBuffer;

                //
                // Call NetpRotateLogonHours to make sure we behave properly
                // during DST.
                //

                if ( usri11->usri11_logon_hours != NULL ) {
                    if ( !NetpRotateLogonHours(
                                usri11->usri11_logon_hours,
                                usri11->usri11_units_per_week,
                                FALSE
                                ) ) {

                        Header->Status = NERR_InternalError;
                        goto cleanup;
                    }
                }

                //
                // Truncate UserParms to 48 bytes
                //

                if (( usri11->usri11_parms != NULL ) &&
                    (wcslen(usri11->usri11_parms) > LM20_MAXCOMMENTSZ))
                {
                    *(usri11->usri11_parms + LM20_MAXCOMMENTSZ) = UNICODE_NULL;
                }
                
                nativeStructureDesc = Desc32_user_info_11;
                StructureDesc = Desc16_user_info_11;
            }
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserGetInfo: Buffer too small %ld s.b. %ld.\n",
                    SmbGetUshort( &parameters->BufLen ),
                    RapStructureSize(
                        StructureDesc,
                        Response,
                        FALSE ) ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetUserGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeUserName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserGetInfo


NTSTATUS
XsNetUserModalsGet (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserModalsGet.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_MODALS_GET parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPBYTE nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserModalsGet: header at %lx, "
                          "params at %lx, level %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ) ));
        }

        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetUserModalsGet(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUserModalsGet: NetUserModalsGet failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_user_modals_info_0;
            StructureDesc = Desc16_user_modals_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_user_modals_info_1;
            StructureDesc = Desc16_user_modals_info_1;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserModalsGet: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserModalsGet: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetUserModalsGet: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserModalsGet


NTSTATUS
XsNetUserModalsSet (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserModalsSet.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_MODALS_SET parameters = Parameters;
    DWORD nativeLevel;                      // Native parameters
    LPVOID buffer = NULL;

    LPDESC setInfoDesc;                     // Conversion variables
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // First of all, the 32-bit parmnum is a bit messed up. If the level
        // is 2, the new parmnum is 5 plus the old parmnum.
        //

        nativeLevel = XsLevelFromParmNum( SmbGetUshort( &parameters->Level ),
                          SmbGetUshort( &parameters->ParmNum ));

        switch ( SmbGetUshort( &parameters->Level )) {

        case 0:

            StructureDesc = Desc16_user_modals_info_0;
            nativeStructureDesc = Desc32_user_modals_info_0;
            setInfoDesc = Desc16_user_modals_info_0_setinfo;
            nativeSetInfoDesc = Desc32_user_modals_info_0_setinfo;

            break;

        case 1:

            StructureDesc = Desc16_user_modals_info_1;
            nativeStructureDesc = Desc32_user_modals_info_1;
            setInfoDesc = Desc16_user_modals_info_1_setinfo;
            nativeSetInfoDesc = Desc32_user_modals_info_1_setinfo;
            if ( nativeLevel != (DWORD)SmbGetUshort( &parameters->Level )) {
                nativeLevel += 5;
            }

            break;

        }

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     SmbGetUshort( &parameters->ParmNum ),
                     TRUE,
                     TRUE,
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     NULL
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserModalsSet: Problem with conversion: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Make the local call.
        //

        status = NetUserModalsSet(
                     NULL,
                     nativeLevel,
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserModalsSet: NetUserModalsSet failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetUserModalsSet


NTSTATUS
XsNetUserPasswordSet2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserPasswordSet. This call is
    translated to NetUserPasswordSet2 when remotely called from a
    16-bit machine.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_PASSWORD_SET_2 parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    UNICODE_STRING UserName;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Convert the username.
        //

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        RtlInitUnicodeString(
            &UserName,
            nativeUserName
            );

        //
        // Check the password length.
        //
        status = XsCheckAndReplacePassword( (DWORD)( SmbGetUshort( &parameters->PasswordLength )) );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserPasswordSet2: XsCheckAndReplacePassword "
                              "failed: %X\n", status ));
            }
            goto cleanup;
        }

        status = XsChangePasswordSam(
                     &UserName,
                     parameters->OldPassword,
                     parameters->NewPassword,
                     (BOOLEAN)SmbGetUshort( &parameters->DataEncryption )
                     );


        //
        // No return data.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeUserName );
    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetUserPasswordSet2


NTSTATUS
XsNetUserSetGroups (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserSetGroups.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_SET_GROUPS parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    LPBYTE actualBuffer = NULL;
    DWORD groupCount;

    LPBYTE stringLocation = NULL;           // Conversion variables
    LPVOID buffer = NULL;
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD bufferSize;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserSetGroups: header at %lx, params at %lx,"
                          "level %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ) ));
        }

        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_user_group_info_0_set;
        AuxStructureDesc = Desc16_user_group_info_0;

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Use the count of group_info_0 structures to form a long
        // descriptor string which can be used to do all the conversion
        // in one pass.
        //

        groupCount = (DWORD)SmbGetUshort( &parameters->Entries );

        longDescriptor = NetpMemoryAllocate(
                             strlen( StructureDesc )
                             + strlen( AuxStructureDesc ) * groupCount
                             + 1 );
        longNativeDescriptor = NetpMemoryAllocate(
                                   strlen( Desc32_user_group_info_0_set )
                                   + strlen( Desc32_user_group_info_0 )
                                         * groupCount
                                   + 1 );

        if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: failed to allocate memory" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        strcpy( longDescriptor, StructureDesc );
        strcpy( longNativeDescriptor, Desc32_user_group_info_0_set );
        for ( i = 0; i < groupCount; i++ ) {
            strcat( longDescriptor, AuxStructureDesc );
            strcat( longNativeDescriptor, Desc32_user_group_info_0 );
        }

        //
        // Figure out if there is enough room in the buffer for all this
        // data. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 longDescriptor,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         longDescriptor,
                         longNativeDescriptor,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserSetGroups: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     longDescriptor,
                     TRUE,
                     buffer,
                     buffer,
                     longNativeDescriptor,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Check if we got all the entries. If not, we'll quit.
        //

        if ( RapAuxDataCount( buffer, Desc32_user_group_info_0_set, Both, TRUE )
                 != groupCount ) {

             Header->Status = NERR_BufTooSmall;
             goto cleanup;
        }

        //
        // If there are no entries, there's no data. Otherwise, the data comes
        // after an initial header structure.
        //

        if ( groupCount > 0 ) {

            actualBuffer = (LPBYTE)buffer + RapStructureSize(
                                                Desc32_user_group_info_0_set,
                                                Both,
                                                TRUE
                                                );

        } else {

            actualBuffer = NULL;
        }

        //
        // Make the local call.
        //

        status = NetUserSetGroups(
                     NULL,
                     nativeUserName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     actualBuffer,
                     (DWORD)groupCount
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: NetUserSetGroups failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );
    NetpMemoryFree( nativeUserName );

    return STATUS_SUCCESS;

} // XsNetUserSetGroups


NTSTATUS
XsNetUserSetInfo2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserSetInfo2. A remote NetUserGetInfo2
    call from a 16-bit machine is translated to NetUserGetInfo2, with
    an encrypted password. This routine has to check for a password set
    and handle it properly, by using level 21 to set the password.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status = NO_ERROR;

    PXS_NET_USER_SET_INFO_2 parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    LPVOID buffer = NULL;
    WORD   bufLen;
    DWORD level;
    BYTE newPassword[ENCRYPTED_PWLEN];

    LPDESC setInfoDesc;                     // Conversion variables
    LPVOID nativePasswordArea = NULL;       // Points to Unicode or encrypted.
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;
    LPUSER_INFO_2 user = NULL;
    PUSER_16_INFO_1 user16 = NULL;
    USER_INFO_1020 usri1020;
    BOOLEAN changePassword = FALSE;
    BOOLEAN changeUserInfo = FALSE;
    BOOLEAN encryptionSupported = TRUE;
    WORD parmNum;
    PUSER_INFO_2 Susri2 = NULL;

    //
    // avoid warnings;
    //

    API_HANDLER_PARAMETERS_REFERENCE;

    try {
        bufLen  = SmbGetUshort( &parameters->BufLen );
        level   = SmbGetUshort( &parameters->Level );
        parmNum = SmbGetUshort( &parameters->ParmNum );

        IF_DEBUG(USER) {
            NetpKdPrint((
                    "XsNetUserSetInfo2: header at " FORMAT_LPVOID ", "
                    "params at " FORMAT_LPVOID ",\n  "
                    "level " FORMAT_DWORD ", parmnum " FORMAT_DWORD ", "
                    "buflen " FORMAT_WORD_ONLY "\n",
                    Header, parameters,
                    level, parmNum, bufLen ));
        }

        //
        // Translate parameters
        //

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Check if password is encrypted.  We know for a fact that dos redirs
        // don't support encryption
        //

        encryptionSupported = (BOOLEAN)
                ( SmbGetUshort( &parameters->DataEncryption ) == TRUE );

        //
        // Determine descriptor strings based on level.
        //

        switch ( level ) {

        case 1:

            StructureDesc = Desc16_user_info_1;
            setInfoDesc = Desc16_user_info_1_setinfo;

            if ( encryptionSupported ) {
                nativeStructureDesc = Desc32_user_info_1;
                nativeSetInfoDesc = Desc32_user_info_1_setinfo;
            } else {
                nativeStructureDesc = Desc32_user_info_1_NC;
                nativeSetInfoDesc = Desc32_user_info_1_setinfo_NC;
            }

            break;

        case 2:

            StructureDesc = Desc16_user_info_2;
            setInfoDesc = Desc16_user_info_2_setinfo;

            if ( encryptionSupported ) {
                nativeStructureDesc = Desc32_user_info_2;
                nativeSetInfoDesc = Desc32_user_info_2_setinfo;
            } else {
                nativeStructureDesc = Desc32_user_info_2_NC;
                nativeSetInfoDesc = Desc32_user_info_2_setinfo_NC;
            }
            break;

        default:
            status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        if (parmNum != USER_PASSWORD_PARMNUM) {
            status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     bufLen,
                     parmNum,
                     TRUE,                  // yes, convert strings
                     TRUE,                  // yes, meaningless input pointers
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     NULL                   // don't need output buffer size
                     );

            if ( status != NERR_Success ) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint((
                            "XsNetUserSetInfo2: Problem with conversion: "
                            FORMAT_API_STATUS "\n",
                            status ));
                }
                goto cleanup;

            }

        } else {
            XsConvertTextParameter(
                    buffer,
                    (LPSTR)XsSmbGetPointer( &parameters->Buffer ) );
        }
        NetpAssert( buffer != NULL );


        //
        // Check the password length.  A value of -1 means caller wants us
        // to compute the length; see XsNetUserSetInfo below.
        //

        if ( parmNum == PARMNUM_ALL || parmNum == USER_PASSWORD_PARMNUM) {
            WORD   passwordLength = SmbGetUshort( &parameters->PasswordLength );

            if (parmNum == PARMNUM_ALL) {
                LPUSER_INFO_2 userInfo = (LPVOID) buffer;  // Native structure.
                nativePasswordArea = userInfo->usri2_password;   // May be NULL.
            } else {
                nativePasswordArea = buffer;        // Entire native buffer.
                if (nativePasswordArea == NULL) {
                    status = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                }
            }

            if (passwordLength == (WORD)(-1)) {
                if (parameters->DataEncryption) {
                    parameters->PasswordLength = ENCRYPTED_PWLEN;
                } else if (nativePasswordArea != NULL) {
                    // Unencrypted, count is number of chars, w/o null char.
                    parameters->PasswordLength = (USHORT)wcslen( nativePasswordArea );
                } else {
                    parameters->PasswordLength = 0;
                }
            }

            status = XsCheckAndReplacePassword( (DWORD)( SmbGetUshort( &parameters->PasswordLength )) );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetUserSetInfo2: XsCheckAndReplacePassword "
                                  "failed: " FORMAT_API_STATUS "\n", status ));
                }
                goto cleanup;
            }

        }

        //
        // If necessary, do work with passwords. Also, translate the parmnum to
        // an info level.
        //

        switch( parmNum ) {

        case PARMNUM_ALL:

            //
            // Get the encrypted password.
            //

            user16 = (PUSER_16_INFO_1)XsSmbGetPointer( &parameters->Buffer );

            RtlCopyMemory(
                newPassword,
                user16->usri1_password,
                ENCRYPTED_PWLEN
                );

            user = (LPUSER_INFO_2)buffer;
            user->usri2_password = NULL;

            if ( level == 2 && user->usri2_logon_hours != NULL ) {

                //
                // Call NetpRotateLogonHours to make sure we behave properly
                // during DST.
                //

                if ( !NetpRotateLogonHours(
                            user->usri2_logon_hours,
                            user->usri2_units_per_week,
                            TRUE
                            ) ) {

                    status = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                }
            }

            changePassword = TRUE;
            changeUserInfo = TRUE;
            break;

        case USER_PASSWORD_PARMNUM:

            //
            // We will use level 21 for changing passwords.
            //

            //
            // Get the encrypted password.
            //

            RtlCopyMemory(
                    newPassword,
                    (PVOID)XsSmbGetPointer( &parameters->Buffer ),
                    ENCRYPTED_PWLEN
                    );

            changePassword = TRUE;
            break;

        case USER_LOGON_HOURS_PARMNUM:

            usri1020.usri1020_units_per_week = UNITS_PER_WEEK;
            usri1020.usri1020_logon_hours =
                                (LPBYTE)XsSmbGetPointer( &parameters->Buffer );

            //
            // Call NetpRotateLogonHours to make sure we behave properly
            // during DST.
            //

            if ( !NetpRotateLogonHours(
                        usri1020.usri1020_logon_hours,
                        usri1020.usri1020_units_per_week,
                        TRUE
                        ) ) {

                status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            //
            // Lack of break is intentional
            //

        default:

            changeUserInfo = TRUE;
            level = PARMNUM_BASE_INFOLEVEL + parmNum;

            break;
        }

        //
        // Bug 114883
        // Downlevel clients cannot set more than 48 wchars and if the server
        // did have more than 48 wchars, we were truncating it! We merge the
        // data that the client sent with what exists on the server
        //

        if ((buffer != NULL) &&
            (changeUserInfo) &&
            ((level == 2) || (parmNum == USER_PARMS_PARMNUM)))
        {
            PUSER_INFO_2 Cusri2 = NULL;
            PUSER_INFO_1013 Cusri1013 = NULL;
            LPWSTR UserParms = NULL;

            // Get the pointer to the client's userparms

            if (level == 2)
            {
                Cusri2 = buffer;
                UserParms = Cusri2->usri2_parms;
            }
            else
            {
                Cusri1013 = buffer;
                UserParms = Cusri1013->usri1013_parms;
            }
            
            //
            // Make the local call.
            //

            status = NetUserGetInfo(
                         NULL,
                         nativeUserName,
                         level,
                         (LPBYTE *)&Susri2
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetUserGetInfo: NetUserGetInfo failed: "
                            "%X\n", status ));
                }
                goto cleanup;
            }

            // If the server userparms field is > 48, we want to do something special

            if (( Susri2->usri2_parms != NULL )  &&
                (wcslen(Susri2->usri2_parms) > LM20_MAXCOMMENTSZ))
            {
                //
                // We need to merge the returned bytes with the local ones
                //

                UINT Length = 0;

                if ( UserParms != NULL )
                {
                    //
                    // Just to be safe, we never over-write more than 48 wchars.
                    //

                    Length = wcslen(UserParms);

                    if (Length > LM20_MAXCOMMENTSZ)
                    {
                        Length = LM20_MAXCOMMENTSZ;
                    }
                }

                // we copy the bytes that the client sent, but only upto
                // 48 wchars.

                RtlCopyMemory( Susri2->usri2_parms,
                               UserParms,
                               Length * sizeof(WCHAR));

                // From Length to LM20_MAXCOMMENTSZ, we pad with blanks

                while (Length < LM20_MAXCOMMENTSZ)
                {
                    Susri2->usri2_parms[Length++] = L' ';
                }

                // Save the merged user parms

                if (level == 2 )
                {
                    Cusri2->usri2_parms = Susri2->usri2_parms;
                }
                else
                {
                    Cusri1013->usri1013_parms = Susri2->usri2_parms;
                }
            }
        }

        //
        // Change user infos other than the password
        //

        if ( changeUserInfo ) {

            status = NetUserSetInfo(
                         NULL,
                         nativeUserName,
                         level,
                         buffer,
                         NULL
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetUserSetInfo2: NetUserSetInfo failed: %X\n",
                                  status ));
                }
                goto cleanup;
            }

            //
            // If there was a Macintosh primary group field for this user, then
            // set the primary group.
            //

            if ( (level == 2) &&
                 NetpIsMacPrimaryGroupFieldValid( (LPCTSTR)user->usri2_parms ) ) {
                NET_API_STATUS status1;
                status1 = XsSetMacPrimaryGroup(
                            (LPCTSTR)nativeUserName,
                            (LPCTSTR)user->usri2_parms
                            );
                if ( !XsApiSuccess( status1 )) {
                    IF_DEBUG(ERRORS) {
                        NetpKdPrint(( "XsNetUserSetInfo2: SetMacPrimaryGroup "
                                        "failed: %X\n", status1 ));
                    }
                }
            } else if ( (level == USER_PARMS_INFOLEVEL) &&
                        NetpIsMacPrimaryGroupFieldValid(
                          (LPCTSTR)((LPUSER_INFO_1013)buffer)->usri1013_parms ) ) {
                NET_API_STATUS status1;
                status1 = XsSetMacPrimaryGroup(
                            (LPCTSTR)nativeUserName,
                            (LPCTSTR)((LPUSER_INFO_1013)buffer)->usri1013_parms
                            );
                if ( !XsApiSuccess( status1 )) {
                    IF_DEBUG(ERRORS) {
                        NetpKdPrint(( "XsNetUserSetInfo2: SetMacPrimaryGroup "
                                        "failed: %X\n", status1 ));
                    }
                }
            }

        }

        //
        // If there is a pending password change, do it now.
        //

        if ( changePassword ) {

            USER_INFO_21 user21;

            if ( !encryptionSupported ) {

                //
                // Do not change password if user sent all blanks.  Clear text
                // passwords are only 14 bytes (LM20_PWLEN) long.
                //

                if ( RtlCompareMemory(
                            newPassword,
                            NULL_USERSETINFO_PASSWD,
                            LM20_PWLEN
                            ) == LM20_PWLEN ) {

                    status = NERR_Success;
                    goto cleanup;
                }

                //
                // Change clear text password to OWF
                //

                (VOID) RtlCalculateLmOwfPassword(
                                    (PLM_PASSWORD) newPassword,
                                    (PLM_OWF_PASSWORD) user21.usri21_password
                                    );


            } else {

                BYTE NullOwfPassword[ENCRYPTED_PWLEN];

                //
                // Decrypt doubly encrypted password with the encryption key
                // provided creating an OWF encrypted password.
                //

                (VOID) RtlDecryptLmOwfPwdWithLmSesKey(
                                    (PENCRYPTED_LM_OWF_PASSWORD) newPassword,
                                    (PLM_SESSION_KEY) Header->EncryptionKey,
                                    (PLM_OWF_PASSWORD) user21.usri21_password
                                    );

                //
                // Generate the NULL Owf Password.
                //

                (VOID) RtlCalculateLmOwfPassword(
                                    (PLM_PASSWORD) NULL_USERSETINFO_PASSWD,
                                    (PLM_OWF_PASSWORD) NullOwfPassword
                                    );

                //
                // Compare the Owf password the client sent and the Owf password
                // for the NULL password.  Do not change the password if this is
                // the case.
                //

                if ( RtlCompareMemory(
                            user21.usri21_password,
                            NullOwfPassword,
                            ENCRYPTED_PWLEN
                            ) == ENCRYPTED_PWLEN ) {

                    status = NERR_Success;
                    goto cleanup;

                }
            }

            status = NetUserSetInfo(
                         NULL,
                         nativeUserName,
                         21,
                         (LPBYTE)&user21,
                         NULL
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetUserSetInfo2: NetUserSetInfo failed: "
                                  "%X\n", status ));
                }
                goto cleanup;
            }

        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    if (Susri2)
        NetApiBufferFree( Susri2);
    Header->Status = (WORD)status;
    NetpMemoryFree( buffer );
    NetpMemoryFree( nativeUserName );

    return STATUS_SUCCESS;

} // XsNetUserSetInfo2


NTSTATUS
XsNetUserSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserSetInfo.  Since this is a subset
    of the newer NetUserSetInfo2, we just convert into a call to that.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    WORD                   dataEncryption;
    WORD                   bufLen;
    WORD                   level;
    NTSTATUS               ntStatus;
    WORD                   parmNum;
    PXS_NET_USER_SET_INFO  subsetParameters = Parameters;
    XS_NET_USER_SET_INFO_2 supersetParameters;

    bufLen         = SmbGetUshort( &subsetParameters->BufLen );
    dataEncryption = SmbGetUshort( &subsetParameters->DataEncryption );
    level          = SmbGetUshort( &subsetParameters->Level );
    parmNum        = SmbGetUshort( &subsetParameters->ParmNum );

    try {
        IF_DEBUG(USER) {
            NetpKdPrint((
                    "XsNetUserSetInfo: header at " FORMAT_LPVOID ", "
                    "params at " FORMAT_LPVOID ",\n  level " FORMAT_DWORD ", "
                    "parmnum " FORMAT_DWORD ", buflen " FORMAT_LONG "\n",
                    Header, subsetParameters,
                    (DWORD) level, (DWORD) parmNum, (LONG) bufLen ));
        }

        //
        // Create parms for XsNetUserSetInfo2()...
        //

        supersetParameters.Buffer   = subsetParameters->Buffer;
        supersetParameters.UserName = subsetParameters->UserName;

        SmbPutUshort( &supersetParameters.Level,          level );
        SmbPutUshort( &supersetParameters.BufLen,         bufLen );
        SmbPutUshort( &supersetParameters.ParmNum,        parmNum );
        SmbPutUshort( &supersetParameters.DataEncryption, dataEncryption );

        //
        // Set info 2 will calc password length for us if we give it -1.
        //
        SmbPutUshort( &supersetParameters.PasswordLength, (WORD)(-1) );


        //
        // Invoke new version of API.
        //

        ntStatus = XsNetUserSetInfo2(
                Header,
                &supersetParameters,
                StructureDesc,
                AuxStructureDesc );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        ntStatus = GetExceptionCode();
    }

    return (ntStatus);

} // XsNetUserSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apistubs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiStubs.c

Abstract:

    This module contains stubs for XACTSRV API handlers, including the
    default handler for unsupported APIs.

Author:

    David Treadwell (davidtr) 07-Jan-1991

Revision History:

--*/

#include "XactSrvP.h"


NTSTATUS
XsNetUnsupportedApi (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine is for APIs which are not supported in Xactsrv. They
    return a special error message.

Arguments:

    Transaction - a pointer to a transaction block containing information
        about the API to process.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    API_HANDLER_PARAMETERS_REFERENCE;

    Header->Status = (WORD)NERR_InvalidAPI;

    return STATUS_SUCCESS;

} // XsNetUnsupportedApi


NTSTATUS
XsNetBuildGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This temporary routine just returns STATUS_NOT_IMPLEMENTED.

Arguments:

    Transaction - a pointer to a transaction block containing information
        about the API to process.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    API_HANDLER_PARAMETERS_REFERENCE;

    Header->Status = (WORD)NERR_InvalidAPI;

    return STATUS_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\apistats.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiStats.c

Abstract:

    This module contains individual API handlers for the NetStatistics APIs.

    SUPPORTED : NetStatisticsGet2.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991

Revision History:

--*/

#define LM20_WORKSTATION_STATISTICS

#include "XactSrvP.h"
#include <ntddnfs.h>
#include <lmstats.h>

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_stat_server_0 = REM16_stat_server_0;
STATIC const LPDESC Desc32_stat_server_0 = REM32_stat_server_0;
STATIC const LPDESC Desc16_stat_workstation_0 = REM16_stat_workstation_0;
STATIC const LPDESC Desc32_stat_workstation_0 = REM32_stat_workstation_0;


NTSTATUS
XsNetStatisticsGet2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetStatisticsGet.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_STATISTICS_GET_2 parameters = Parameters;
    LPTSTR nativeService = NULL;            // Native parameters
    LPVOID outBuffer = NULL;
    LPVOID statBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD options;
    LPDESC actualStructureDesc;
    LPDESC nativeStructureDesc;
    STAT_WORKSTATION_0 wkstaStats;
    PREDIR_STATISTICS ntRedirStats;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(STATISTICS) {
        NetpKdPrint(( "XsNetStatisticsGet2: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0
             || SmbGetUlong( &parameters->Reserved ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // No options currently supported by both rdr and srv
        //

        if ( SmbGetUlong( &parameters->Options ) != 0 ) {
            Header->Status = ERROR_NOT_SUPPORTED;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeService,
            (LPSTR)XsSmbGetPointer( &parameters->Service )
            );

        //
        // Make the local call.
        //

        status = NetStatisticsGet(
                     NULL,
                     XS_MAP_SERVICE_NAME( nativeService ),
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     0,                 // Options MBZ
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetStatisticsGet2: NetStatisticsGet failed: "
                            "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the name of the service to determine the format of the 32-bit
        // structure we got back from NetStatisticsGet, and the format of what
        // the resulting 16-bit structure should be. If the service name is not
        // one supported in LM2.x, return ERROR_NOT_SUPPORTED now, as required.
        //

        if ( !_stricmp( (LPSTR)XsSmbGetPointer( &parameters->Service ), "SERVER" )) {

            statBuffer = outBuffer;
            nativeStructureDesc = Desc32_stat_server_0;
            actualStructureDesc = Desc16_stat_server_0;

        } else if ( !_stricmp( (LPSTR)XsSmbGetPointer( &parameters->Service ),
                        "WORKSTATION" )) {

            //
            // The structure we got back is an nt structure.  We need to convert
            // it by hand here.
            //

            statBuffer = &wkstaStats;
            ntRedirStats = (PREDIR_STATISTICS)outBuffer;
            RtlZeroMemory(
                    &wkstaStats,
                    sizeof(STAT_WORKSTATION_0)
                    );

            (VOID)RtlTimeToSecondsSince1970(
                            &ntRedirStats->StatisticsStartTime,
                            &wkstaStats.stw0_start
                            );

            wkstaStats.stw0_sesstart = ntRedirStats->Sessions;
            wkstaStats.stw0_sessfailcon = ntRedirStats->FailedSessions;
            wkstaStats.stw0_sessbroke = ntRedirStats->ServerDisconnects +
                                        ntRedirStats->HungSessions;
            wkstaStats.stw0_uses =
                        ntRedirStats->CoreConnects +
                        ntRedirStats->Lanman20Connects +
                        ntRedirStats->Lanman21Connects +
                        ntRedirStats->LanmanNtConnects;

            wkstaStats.stw0_usefail = ntRedirStats->FailedUseCount;
            wkstaStats.stw0_autorec = ntRedirStats->Reconnects;

            wkstaStats.stw0_bytessent_r_hi =
                                ntRedirStats->BytesTransmitted.HighPart;
            wkstaStats.stw0_bytessent_r_lo =
                                ntRedirStats->BytesTransmitted.LowPart;

            wkstaStats.stw0_bytesrcvd_r_hi =
                                ntRedirStats->BytesReceived.HighPart;
            wkstaStats.stw0_bytesrcvd_r_lo =
                                ntRedirStats->BytesReceived.LowPart;

            nativeStructureDesc = Desc32_stat_workstation_0;
            actualStructureDesc = Desc16_stat_workstation_0;

        } else {

            Header->Status = ERROR_NOT_SUPPORTED;
            goto cleanup;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     statBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     actualStructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetStatisticsGet2: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(STATISTICS) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer. Statistics
        // structures don't have any variable data to pack.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 actualStructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetStatisticsGet2: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeService );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        actualStructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetStatisticsGet2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xsdata.c ===
/*+

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsData.c

Abstract:

    Global data declarations for XACTSRV.

Author:

    David Treadwell (davidtr) 05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#include <XactSrvP.h>

//
// Conditional debug print variable.  See XsDebug.h.
// !!! If you change this, also change XsDebug in ..\SvcDlls\XsSvc\XsData.c
//

#if DBG
DWORD XsDebug = 0; // DEBUG_API_ERRORS | DEBUG_ERRORS;
#endif

//DWORD XsDebug = 0xFFFFFFFF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\changepw.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ChangePw.h

Abstract:

    This module implements password change from downlevel clients.
    XsChangePasswordSam is called by XsNetUserPasswordSet2 in
    apiuser.c.  I've put this in a seperate file because it #includes
    a private SAM header.

Author:

    Dave Hart (davehart) 31-Apr-1992

Revision History:

--*/

NET_API_STATUS
XsChangePasswordSam (
    IN PUNICODE_STRING UserName,
    IN PVOID OldPassword,
    IN PVOID NewPassword,
    IN BOOLEAN Encrypted
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xactsrvp.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    xactsrvp.h

Abstract:

    Private header file for XACTSRV.

Author:

    David Treadwell (davidtr) 05-Jan-1991

Revision History:

    02-Jun-1992 JohnRo
        RAID 9829: Avoid SERVICE_ equate conflicts.

--*/

#ifndef _XACTSRVP_
#define _XACTSRVP_

//
// To make netlib declare NetpDbgPrint.
//

#if DBG
#ifndef CDEBUG
#define CDEBUG
#endif
#endif

//
// "System" include files
//

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ctype.h>
#include <stdlib.h>
#include <windef.h>
#include <winbase.h>
#include <string.h>
//!!UNICODE!! - Include tstring.h TSTR type-independent functions
#include <tstring.h>

//
// Network include files.
//

#include <nettypes.h>

#include <smbtypes.h>
#include <smbmacro.h>
#include <smbgtpt.h>
#include <smb.h>
#include <smbtrans.h>

#include <status.h>
#include <srvfsctl.h>
#include <lm.h>         // LM20_SERVICE_ equates, etc.
#include <ntmsv1_0.h>

#include <winsvc.h>     // SERVICE_ equates, etc.

#include <apiparam.h>
#include <remdef.h>
#include <remtypes.h>
#include <netlib.h>
#include <netdebug.h>
#include <rap.h>

//
// Xactsrv's own include files
//

#include <XsDebug.h>
#include <XsTypes.h>
#include <XactSrv2.h>             // XsTypes.h must precede XactSrv.h
#include <XsConst.h>              // XactSrv.h must precede XsConst.h
#include <XsUnicod.h>
#include <XsProcs.h>              // XsTypes.h must precede XsProcs.h.
#include <XsProcsP.h>             // XsTypes.h, XsConst.h and XsUnicod.h
                                  // must precede XsProcsP.h.
#include <XsDef16.h>
#include <XsParm16.h>

//
// !!! Temporary definitions for stubs.
//

#include <WkstaDef.h>

#endif // ndef _XACTSRVP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\wkstadef.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    WkstaDef.h

Abstract:

    This is a temporary file of definitions for the local NT
    workstation/server. It contains information returned by the
    stubs for NetServer/NetWksta code. Change these values locally
    to adapt to your machine. All caps is probably wise, as this only
    deals with 2.0 servers

Author:

    Shanku Niyogi (w-shanku) 25-Feb-1991

Revision History:

--*/

//!!UNICODE!! - Added TEXT prefix for these strings.

//
// Server name. This should be the same name as entered in NET SERVE command.
//

#define XS_SERVER_NAME TEXT("SERVER")

//
// Workstation name. Same as in NET START REDIR command.
//

#define XS_WKSTA_NAME TEXT("WKSTA")

//
// Workstation user name.
//

#define XS_WKSTA_USERNAME TEXT("USER")

//
// List of drives on NT server. Each character should be a drive letter.
//

#define XS_ENUM_DRIVES TEXT("ABC")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xsdef16.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsDef16.h

Abstract:

    Type declarations and constants for default values returned to 16-bit
    clients. Data expected by downlevel clients but not available to NT
    is defined here.

Author:

    David Treadwell (davidtr) 09-Jan-1991

Revision History:

--*/

#ifndef _XSDEF16_

#define _XSDEF16_

//
// The string definitions in this file are put into 16-bit
// structures with a macro that converts Unicode->Ansi.
// Therefore, these definitions should be Unicode.
// All other definitions are Ascii, and should be left alone.
//
// 16-bit info structures for manual filling of defaults.
//

#include <packon.h>

// Pointers are actually Dword offsets (64-bit compat)
#define LPSTR_16_REMOTE DWORD

typedef struct _ACCESS_16_INFO_1 {
    LPSTR_16_REMOTE acc1_resource_name;
    WORD acc1_attr;
    WORD acc1_count;
} ACCESS_16_INFO_1, *PACCESS_16_INFO_1;

typedef struct _PRQINFO_16 {
    LPSTR_16_REMOTE pszName;
    WORD uPriority;
    WORD uStartTime;
    WORD uUntilTime;
    WORD pad1;
    LPSTR_16_REMOTE pszSepFile;
    LPSTR_16_REMOTE pszPrProc;
    LPSTR_16_REMOTE pszParms;
    LPSTR_16_REMOTE pszComment;
    WORD fsStatus;
    WORD cJobs;
    LPSTR_16_REMOTE pszPrinters;
    LPSTR_16_REMOTE pszDriverName;
    PBYTE pDriverData;
} PRQINFO3_16, *PPRQINFO3_16;

typedef struct _PRJINFO_16 {
    WORD uJobId;
    WORD uPriority;
    LPSTR_16_REMOTE pszUserName;
    WORD uPosition;
    WORD fsStatus;
    DWORD ulSubmitted;
    DWORD ulSize;
    LPSTR_16_REMOTE pszComment;
    LPSTR_16_REMOTE pszDocument;
} PRJINFO2_16, *PPRJINFO2_16;

typedef struct _PRINTQ_16_INFO_5 {
    LPSTR_16_REMOTE pszName;
} PRQ_16_INFO_5, *PPRQ_16_INFO_5;

typedef struct _SERVER_16_INFO_2 {
    BYTE sv2_name[LM20_CNLEN + 1];
    BYTE sv2_version_major;
    BYTE sv2_version_minor;
    DWORD sv2_type;
    LPSTR_16_REMOTE sv2_comment;
    DWORD sv2_ulist_mtime;
    DWORD sv2_glist_mtime;
    DWORD sv2_alist_mtime;
    WORD sv2_users;
    WORD sv2_disc;
    LPSTR_16_REMOTE sv2_alerts;
    WORD sv2_security;
    WORD sv2_auditing;
    WORD sv2_numadmin;
    WORD sv2_lanmask;
    WORD sv2_hidden;
    WORD sv2_announce;
    WORD sv2_anndelta;
    BYTE sv2_guestacct[LM20_UNLEN + 1];
    BYTE sv2_pad1;
    LPSTR_16_REMOTE sv2_userpath;
    WORD sv2_chdevs;
    WORD sv2_chdevq;
    WORD sv2_chdevjobs;
    WORD sv2_connections;
    WORD sv2_shares;
    WORD sv2_openfiles;
    WORD sv2_sessopens;
    WORD sv2_sessvcs;
    WORD sv2_sessreqs;
    WORD sv2_opensearch;
    WORD sv2_activelocks;
    WORD sv2_numreqbuf;
    WORD sv2_sizreqbuf;
    WORD sv2_numbigbuf;
    WORD sv2_numfiletasks;
    WORD sv2_alertsched;
    WORD sv2_erroralert;
    WORD sv2_logonalert;
    WORD sv2_accessalert;
    WORD sv2_diskalert;
    WORD sv2_netioalert;
    WORD sv2_maxauditsz;
    LPSTR_16_REMOTE sv2_srvheuristics;
} SERVER_16_INFO_2, *PSERVER_16_INFO_2;

typedef struct _SERVER_16_INFO_3 {
    BYTE sv3_name[LM20_CNLEN + 1];
    BYTE sv3_version_major;
    BYTE sv3_version_minor;
    DWORD sv3_type;
    LPSTR_16_REMOTE sv3_comment;
    DWORD sv3_ulist_mtime;
    DWORD sv3_glist_mtime;
    DWORD sv3_alist_mtime;
    WORD sv3_users;
    WORD sv3_disc;
    LPSTR_16_REMOTE sv3_alerts;
    WORD sv3_security;
    WORD sv3_auditing;
    WORD sv3_numadmin;
    WORD sv3_lanmask;
    WORD sv3_hidden;
    WORD sv3_announce;
    WORD sv3_anndelta;
    BYTE sv3_guestacct[LM20_UNLEN + 1];
    BYTE sv3_pad1;
    LPSTR_16_REMOTE sv3_userpath;
    WORD sv3_chdevs;
    WORD sv3_chdevq;
    WORD sv3_chdevjobs;
    WORD sv3_connections;
    WORD sv3_shares;
    WORD sv3_openfiles;
    WORD sv3_sessopens;
    WORD sv3_sessvcs;
    WORD sv3_sessreqs;
    WORD sv3_opensearch;
    WORD sv3_activelocks;
    WORD sv3_numreqbuf;
    WORD sv3_sizreqbuf;
    WORD sv3_numbigbuf;
    WORD sv3_numfiletasks;
    WORD sv3_alertsched;
    WORD sv3_erroralert;
    WORD sv3_logonalert;
    WORD sv3_accessalert;
    WORD sv3_diskalert;
    WORD sv3_netioalert;
    WORD sv3_maxauditsz;
    LPSTR_16_REMOTE sv3_srvheuristics;
    DWORD sv3_auditedevents;
    WORD sv3_autoprofile;
    LPSTR_16_REMOTE sv3_autopath;
} SERVER_16_INFO_3, *PSERVER_16_INFO_3;

#define DEF16_sv_ulist_mtime 0
#define DEF16_sv_glist_mtime 0
#define DEF16_sv_alist_mtime 0
#define DEF16_sv_alerts TEXT("")
#define DEF16_sv_security SV_USERSECURITY
#define DEF16_sv_auditing 0
#define DEF16_sv_numadmin -1
#define DEF16_sv_lanmask 0x0F
#define DEF16_sv_guestacct TEXT("")
#define DEF16_sv_chdevs 65535
#define DEF16_sv_chdevq 65535
#define DEF16_sv_chdevjobs 65535
#define DEF16_sv_connections 2000
#define DEF16_sv_shares 65535
#define DEF16_sv_openfiles 8000
#define DEF16_sv_sessreqs 65535
#define DEF16_sv_activelocks 64
#define DEF16_sv_numreqbuf 300
#define DEF16_sv_numbigbuf 80
#define DEF16_sv_numfiletasks 8
#define DEF16_sv_alertsched 5
#define DEF16_sv_erroralert 5
#define DEF16_sv_logonalert 5
#define DEF16_sv_accessalert 5
#define DEF16_sv_diskalert 300
#define DEF16_sv_netioalert 5
#define DEF16_sv_maxauditsz 100
#define DEF16_sv_srvheuristics TEXT("0110151110111001331")
#define DEF16_sv_auditedevents 0xFFFFFFFF
#define DEF16_sv_autoprofile 0
#define DEF16_sv_autopath TEXT("")

typedef struct _SESSION_16_INFO_1 {
    LPSTR_16_REMOTE sesi1_cname;
    LPSTR_16_REMOTE sesi1_username;
    WORD sesi1_num_conns;
    WORD sesi1_num_opens;
    WORD sesi1_num_users;
    DWORD sesi1_time;
    DWORD sesi1_idle_time;
    DWORD sesi1_user_flags;
} SESSION_16_INFO_1, *PSESSION_16_INFO_1;

typedef struct _SESSION_16_INFO_2 {
    LPSTR_16_REMOTE sesi2_cname;
    LPSTR_16_REMOTE sesi2_username;
    WORD sesi2_num_conns;
    WORD sesi2_num_opens;
    WORD sesi2_num_users;
    DWORD sesi2_time;
    DWORD sesi2_idle_time;
    DWORD sesi2_user_flags;
    LPSTR_16_REMOTE sesi2_cltype_name;
} SESSION_16_INFO_2, *PSESSION_16_INFO_2;

typedef struct _SESSION_16_INFO_10 {
    LPSTR_16_REMOTE sesi10_cname;
    LPSTR_16_REMOTE sesi10_username;
    DWORD sesi10_time;
    DWORD sesi10_idle_time;
} SESSION_16_INFO_10, *PSESSION_16_INFO_10;

#define DEF16_ses_num_conns 1
#define DEF16_ses_num_users 1

typedef struct _USE_16_INFO_0 {
    BYTE ui0_local[LM20_DEVLEN + 1];
    BYTE ui0_pad1;
    LPSTR_16_REMOTE ui0_remote;
} USE_16_INFO_0, *PUSE_16_INFO_0;

typedef struct _USER_16_INFO_1 {
    BYTE usri1_name[LM20_UNLEN+1];
    BYTE usri1_pad_1;
    BYTE usri1_password[ENCRYPTED_PWLEN];
    DWORD usri1_password_age;
    WORD usri1_priv;
    LPSTR_16_REMOTE usri1_home_dir;
    LPSTR_16_REMOTE usri1_comment;
    WORD usri1_flags;
    LPSTR_16_REMOTE usri1_script_path;
} USER_16_INFO_1, *PUSER_16_INFO_1;

typedef struct _USER_16_LOGOFF_INFO_1 {
    WORD usrlogf1_code;
    DWORD usrlogf1_duration;
    WORD usrlogf1_num_logons;
} USER_16_LOGOFF_INFO_1, *PUSER_16_LOGOFF_INFO_1;

typedef struct _USER_16_LOGON_INFO_1 {
    WORD usrlog1_code;
    BYTE usrlog1_eff_name[UNLEN+1];
    BYTE usrlog1_pad_1;
    WORD usrlog1_priv;
    DWORD usrlog1_auth_flags;
    WORD usrlog1_num_logons;
    WORD usrlog1_bad_pw_count;
    DWORD usrlog1_last_logon;
    DWORD usrlog1_last_logoff;
    DWORD usrlog1_logoff_time;
    DWORD usrlog1_kickoff_time;
    DWORD usrlog1_password_age;
    DWORD usrlog1_pw_can_change;
    DWORD usrlog1_pw_must_change;
    LPSTR_16_REMOTE usrlog1_computer;
    LPSTR_16_REMOTE usrlog1_domain;
    LPSTR_16_REMOTE usrlog1_script_path;
    DWORD usrlog1_reserved1;
} USER_16_LOGON_INFO_1, *PUSER_16_LOGON_INFO_1;

typedef struct _WKSTA_16_INFO_0 {
    WORD  wki0_reserved_1;
    DWORD wki0_reserved_2;
    LPSTR_16_REMOTE wki0_root;
    LPSTR_16_REMOTE wki0_computername;
    LPSTR_16_REMOTE wki0_username;
    LPSTR_16_REMOTE wki0_langroup;
    BYTE  wki0_ver_major;
    BYTE  wki0_ver_minor;
    DWORD wki0_reserved_3;
    WORD  wki0_charwait;
    DWORD wki0_chartime;
    WORD  wki0_charcount;
    WORD  wki0_reserved_4;
    WORD  wki0_reserved_5;
    WORD  wki0_keepconn;
    WORD  wki0_keepsearch;
    WORD  wki0_maxthreads;
    WORD  wki0_maxcmds;
    WORD  wki0_reserved_6;
    WORD  wki0_numworkbuf;
    WORD  wki0_sizworkbuf;
    WORD  wki0_maxwrkcache;
    WORD  wki0_sesstimeout;
    WORD  wki0_sizerror;
    WORD  wki0_numalerts;
    WORD  wki0_numservices;
    WORD  wki0_errlogsz;
    WORD  wki0_printbuftime;
    WORD  wki0_numcharbuf;
    WORD  wki0_sizcharbuf;
    LPSTR_16_REMOTE wki0_logon_server;
    LPSTR_16_REMOTE wki0_wrkheuristics;
    WORD  wki0_mailslots;
} WKSTA_16_INFO_0, *PWKSTA_16_INFO_0, *LPWKSTA_16_INFO_0;

typedef struct _WKSTA_16_INFO_1 {
    WORD  wki1_reserved_1;
    DWORD wki1_reserved_2;
    LPSTR_16_REMOTE wki1_root;
    LPSTR_16_REMOTE wki1_computername;
    LPSTR_16_REMOTE wki1_username;
    LPSTR_16_REMOTE wki1_langroup;
    BYTE  wki1_ver_major;
    BYTE  wki1_ver_minor;
    DWORD wki1_reserved_3;
    WORD  wki1_charwait;
    DWORD wki1_chartime;
    WORD  wki1_charcount;
    WORD  wki1_reserved_4;
    WORD  wki1_reserved_5;
    WORD  wki1_keepconn;
    WORD  wki1_keepsearch;
    WORD  wki1_maxthreads;
    WORD  wki1_maxcmds;
    WORD  wki1_reserved_6;
    WORD  wki1_numworkbuf;
    WORD  wki1_sizworkbuf;
    WORD  wki1_maxwrkcache;
    WORD  wki1_sesstimeout;
    WORD  wki1_sizerror;
    WORD  wki1_numalerts;
    WORD  wki1_numservices;
    WORD  wki1_errlogsz;
    WORD  wki1_printbuftime;
    WORD  wki1_numcharbuf;
    WORD  wki1_sizcharbuf;
    LPSTR_16_REMOTE wki1_logon_server;
    LPSTR_16_REMOTE wki1_wrkheuristics;
    WORD  wki1_mailslots;
    LPSTR_16_REMOTE wki1_logon_domain;
    LPSTR_16_REMOTE wki1_oth_domains;
    WORD  wki1_numdgrambuf;
} WKSTA_16_INFO_1, *PWKSTA_16_INFO_1, *LPWKSTA_16_INFO_1;

typedef struct _WKSTA_16_INFO_10 {
    LPSTR_16_REMOTE wki10_computername;
    LPSTR_16_REMOTE wki10_username;
    LPSTR_16_REMOTE wki10_langroup;
    BYTE  wki10_ver_major;
    BYTE  wki10_ver_minor;
    LPSTR_16_REMOTE wki10_logon_domain;
    LPSTR_16_REMOTE wki10_oth_domains;
} WKSTA_16_INFO_10, *PWKSTA_16_INFO_10, *LPWKSTA_16_INFO_10;

typedef struct _WKSTA_16_USER_LOGON_REQUEST_1 {
    BYTE wlreq1_name[LM20_UNLEN + 1];
    BYTE wlreq1_pad1;
    BYTE wlreq1_password[LM20_PWLEN + 1];
    BYTE wlreq1_pad2;
    BYTE wlreq1_workstation[LM20_CNLEN + 1];
} WKSTA_16_USER_LOGON_REQUEST_1, *PWKSTA_16_USER_LOGON_REQUEST_1,
      *LPWKSTA_16_USER_LOGON_REQUEST_1;

typedef struct _WKSTA_16_USER_LOGOFF_REQUEST_1 {
    BYTE wlreq1_name[LM20_UNLEN + 1];
    BYTE wlreq1_pad_1;
    BYTE wlreq1_workstation[LM20_CNLEN + 1];
} WKSTA_16_USER_LOGOFF_REQUEST_1, *PWKSTA_16_USER_LOGOFF_REQUEST_1,
      *LPWKSTA_16_USER_LOGOFF_REQUEST_1;

#define DEF16_ses_num_conns 1
#define DEF16_ses_num_users 1

#define DEF16_wk_username TEXT("")
#define DEF16_wk_keepsearch 600
#define DEF16_wk_numworkbuf 15
#define DEF16_wk_sizeworkbuf 4096
#define DEF16_wk_maxwrkcache 64
#define DEF16_wk_sizerror 512
#define DEF16_wk_numalerts 12
#define DEF16_wk_numservices 8
#define DEF16_wk_errlogsz 100
#define DEF16_wk_printbuftime 60
#define DEF16_wk_numcharbuf 5
#define DEF16_wk_sizcharbuf 512
#define DEF16_wk_logon_server TEXT("")
#define DEF16_wk_wrk_heuristics TEXT("")
#define DEF16_wk_mailslots 1
#define DEF16_wk_logon_domain TEXT("")
#define DEF16_wk_oth_domains TEXT("")
#define DEF16_wk_numdgrambuf 14

#include <packoff.h>

#endif // ndef _XSDEF16_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xsdebug.h ===
#ifndef _XSDEBUG_
#define _XSDEBUG_

//
// Debugging macros
//

#ifndef DBG
#define DBG 0
#endif

#if !DBG

#undef XSDBG
#define XSDBG 0

#else

#ifndef XSDBG
#define XSDBG 1
#endif

#endif

#undef IF_DEBUG

#if !XSDBG

#define STATIC static

#define DEBUG if (FALSE)
#define IF_DEBUG(flag) if (FALSE)

#else

extern DWORD XsDebug;

#define STATIC

#define DEBUG if (TRUE)
#define IF_DEBUG(flag) if (XsDebug & (DEBUG_ ## flag))

#define DEBUG_INIT                0x00000001
#define DEBUG_TRACE               0x00000002
#define DEBUG_LPC                 0x00000004
#define DEBUG_CONVERT             0x00000008

#define DEBUG_THREADS             0x00000010
#define DEBUG_SHARE               0x00000020
#define DEBUG_SESSION             0x00000040
#define DEBUG_USE                 0x00000080

#define DEBUG_USER                0x00000100
#define DEBUG_FILE                0x00000200
#define DEBUG_SERVER              0x00000400
#define DEBUG_WKSTA               0x00000800

#define DEBUG_SERVICE             0x00001000
#define DEBUG_CONNECTION          0x00002000
#define DEBUG_CHAR_DEV            0x00004000
#define DEBUG_MESSAGE             0x00008000

#define DEBUG_ACCESS              0x00010000
#define DEBUG_GROUP               0x00020000
#define DEBUG_AUDIT               0x00040000
#define DEBUG_ERROR               0x00080000

#define DEBUG_PRINT               0x00100000
#define DEBUG_STATISTICS          0x00200000
#define DEBUG_TIME                0x00400000
#define DEBUG_NETBIOS             0x00800000

#define DEBUG_CONFIG              0x01000000
#define DEBUG_LOGON               0x02000000
#define DEBUG_PATH                0x04000000
#define DEBUG_ACCOUNT             0x08000000

#define DEBUG_BOGUS_APIS          0x10000000
#define DEBUG_DESC_STRINGS        0x20000000
#define DEBUG_API_ERRORS          0x40000000
#define DEBUG_ERRORS              0x80000000

#endif // else !XSDBG

#endif // ndef _XSDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xsconst.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    XsConst.h

Abstract:

    Constant manifests for XACTSRV.

Author:

    David Treadwell (davidtr) 09-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#ifndef _XSCONST_
#define _XSCONST_

//
// The server device name.  XACTSRV will open this name to send the
// "connect to XACTSRV" FSCTL to the server.
//

#define XS_SERVER_DEVICE_NAME_W  L"\\Device\\LanmanServer"

//
// The name of the LPC port XACTSRV creates and uses for communication
// with the server.  This name is included in the connect FSCTL sent to
// the server so that the server knows what port to connect to.
//

#define XS_PORT_NAME_W  L"\\XactSrvLpcPort"
#define XS_PORT_NAME_A   "\\XactSrvLpcPort"

//
// The maximum size of a message that can be sent over the port.
//

#define XS_PORT_MAX_MESSAGE_LENGTH                                         \
    ( sizeof(XACTSRV_REQUEST_MESSAGE) > sizeof(XACTSRV_REPLY_MESSAGE) ?    \
         sizeof(XACTSRV_REQUEST_MESSAGE) : sizeof(XACTSRV_REPLY_MESSAGE) )

#define XS_PORT_TIMEOUT_MILLISECS 5000

//
// The minimum gap before variable-length data is moved up in a response
// data buffer.  If the variable-length data is moved, the converted word
// is set appropriately.
//

#define MAXIMUM_ALLOWABLE_DATA_GAP 100

//
// A scaling function for approximating the maximum required buffer size
// for native Enumeration calls. This value should preferably be 3, because
// at least a factor of 2 is required to convert all 16-bit client words to
// 32-bit native dwords, while character arrays require a factor of more
// than two, to account for Unicode conversion plus a four-byte pointer
// to the converted string.
//
// To specify a minimum value for the buffer size, specify the scaling
// function in form min + s, where min is the minimum and s is the scale.
// DO NOT USE PARENTHESES IN THIS EXPRESSION.
//

#define XS_BUFFER_SCALE 1024 + 3

//
// Parameter descriptor for unsupported APIs.
//

#define REMSmb_NetUnsupportedApi_P NULL

#endif // ndef _XSCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\changepw.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ChangePw.c

Abstract:

    This module implements password change from downlevel clients.
    XsChangePasswordSam is called by XsNetUserPasswordSet2 in
    apiuser.c.  I've put this in a seperate file because it #includes
    a private SAM header.

Author:

    Dave Hart (davehart) 31-Apr-1992

Revision History:

--*/

#include "xactsrvp.h"
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <crypt.h>
#include <lmcons.h>
#include "changepw.h"
#include <netlibnt.h>
#include <smbgtpt.h>


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  Internal function prototyptes.                                         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
RtlGetPrimaryDomain(
    IN  ULONG            SidLength,
    OUT PBOOLEAN         PrimaryDomainPresent,
    OUT PUNICODE_STRING  PrimaryDomainName,
    OUT PUSHORT          RequiredNameLength,
    OUT PSID             PrimaryDomainSid OPTIONAL,
    OUT PULONG           RequiredSidLength
    );


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  Exported functions.                                                    //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NET_API_STATUS
XsChangePasswordSam (
    IN PUNICODE_STRING UserName,
    IN PVOID OldPassword,
    IN PVOID NewPassword,
    IN BOOLEAN Encrypted
    )
/*++

Routine Description:

    This routine is called by XsNetUserPasswordSet2 to change the password
    on a Windows NT machine.  The code is based on
    lsa\msv1_0\nlmain.c MspChangePasswordSam.

Arguments:

    UserName     - Name of the user to change password for.

    OldPassword  - Old password encrypted using new password as key.

    NewPassword  - New password encrypted using old password as key.

Return Value:


--*/

{
    NTSTATUS                    Status;
    NT_PRODUCT_TYPE             NtProductType;
    UNICODE_STRING              DomainName;
    LPWSTR                      serverName = NULL;
    BOOLEAN                     DomainNameAllocated;
    BOOLEAN                     PrimaryDomainPresent;
    USHORT                      RequiredDomainNameLength;
    ULONG                       RequiredDomainSidLength;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PSID                        DomainSid = NULL;
    PULONG                      UserId = NULL;
    PSID_NAME_USE               NameUse = NULL;
    SAM_HANDLE                  SamHandle = NULL;
    SAM_HANDLE                  DomainHandle = NULL;
    SAM_HANDLE                  UserHandle = NULL;
    HANDLE                      OpenedToken;

    //
    // We're going to _open the local account domain.  The name of this
    // domain is "Account" on a WinNT machine, or the name of the
    // primary domain on a LanManNT machine.  Figure out the product
    // type, assuming WinNT if RtlGetNtProductType fails.
    //

    DomainName.MaximumLength = 0;
    DomainName.Buffer = NULL;
    DomainNameAllocated = FALSE;

    NtProductType = NtProductWinNt;

    RtlGetNtProductType(
        &NtProductType
    );

    if (NtProductLanManNt != NtProductType) {

        NET_API_STATUS error;

        //
        // The server name is the database name.
        //

        error = NetpGetComputerName( &serverName );

        if ( error != NO_ERROR ) {
            return(error);
        }

        RtlInitUnicodeString(
            &DomainName,
            serverName
            );

    } else {

        //
        // This is a LanManNT machine, so we need to find out the
        // name of the primary domain.  First get the length of the
        // domain name, then make room for it and retrieve it.
        //

        Status = RtlGetPrimaryDomain(
                     0,
                     &PrimaryDomainPresent,
                     &DomainName,
                     &RequiredDomainNameLength,
                     NULL,
                     &RequiredDomainSidLength
                     );

        if (STATUS_BUFFER_TOO_SMALL != Status && !NT_SUCCESS(Status)) {

            KdPrint(("XsChangePasswordSam: Unable to size primary "
                         " domain name buffer, %8.8x\n", Status));

            goto Cleanup;
        }

        DomainName.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                DomainName.MaximumLength = RequiredDomainNameLength
                                );
        DomainNameAllocated = TRUE;

        DomainSid = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                RequiredDomainSidLength
                                );

        if (!DomainName.Buffer || !DomainSid) {
            KdPrint(("XsChangePasswordSam: Out of memory allocating %d and %d bytes.",
                     RequiredDomainNameLength, RequiredDomainSidLength));
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        Status = RtlGetPrimaryDomain(
                     RequiredDomainSidLength,
                     &PrimaryDomainPresent,
                     &DomainName,
                     &RequiredDomainNameLength,
                     DomainSid,
                     &RequiredDomainSidLength
                     );

        RtlFreeHeap(RtlProcessHeap(), 0, DomainSid);
        DomainSid = NULL;

        if (!NT_SUCCESS(Status)) {
            KdPrint(("XsChangePasswordSam: Unable to retrieve domain "
                     "name, %8.8x\n", Status));
            goto Cleanup;
        }

        ASSERT(PrimaryDomainPresent);

    }


    //
    // Wrap an exception handler around this entire function,
    // since RPC raises exceptions to return errors.
    //

    try {

        //
        // Connect to local SAM.
        //

        InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
        ObjectAttributes.SecurityQualityOfService = &SecurityQos;

        SecurityQos.Length = sizeof(SecurityQos);
        SecurityQos.ImpersonationLevel = SecurityIdentification;
        SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
        SecurityQos.EffectiveOnly = FALSE;

        Status = SamConnect(
                     NULL,
                     &SamHandle,
                     GENERIC_EXECUTE,
                     &ObjectAttributes
                     );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: SamConnect failed, status %8.8x\n",
                      Status));
            goto Cleanup;
        }

        //
        // Lookup the Domain SID.
        //

        Status = SamLookupDomainInSamServer(
                     SamHandle,
                     &DomainName,
                     &DomainSid
                     );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: Cannot find domain %wZ, "
                    "status %8.8x\n", &DomainName, Status));

            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
            goto Cleanup;
        }


        //
        // Revert to Local System
        //
        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    MAXIMUM_ALLOWED,
                    TRUE,
                    &OpenedToken
                );

        if( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        RevertToSelf();

        //
        // Open the account domain.
        //

        Status = SamOpenDomain(
                     SamHandle,
                     GENERIC_EXECUTE,
                     DomainSid,
                     &DomainHandle
                     );

        if ( !NT_SUCCESS(Status) ) {
#if DBG
            UNICODE_STRING UnicodeSid;

            RtlConvertSidToUnicodeString(
                &UnicodeSid,
                DomainSid,
                TRUE
                );
            KdPrint(("XsChangePasswordSam: Cannot open domain %wZ, status %8.8x, SAM handle %8.8x, Domain SID %wZ\n",
                     &DomainName, Status, SamHandle, UnicodeSid));
            RtlFreeUnicodeString(&UnicodeSid);
#endif
            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
            goto Cleanup;
        }

        //
        // Find the ID for this username.
        //

        Status = SamLookupNamesInDomain(
                     DomainHandle,
                     1,
                     UserName,
                     &UserId,
                     &NameUse
                     );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: Cannot lookup user %wZ, "
                     "status %8.8x\n", UserName, Status));
            if (STATUS_NONE_MAPPED == Status) {
                Status = STATUS_NO_SUCH_USER;
            }

            goto Cleanup;
        }

        //
        // Re-impersonate the client
        //
        Status = NtSetInformationThread(
                            NtCurrentThread(),
                            ThreadImpersonationToken,
                            &OpenedToken,
                            sizeof( OpenedToken )
                            );

        if( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }


        //
        // Open the user object.
        //

        Status = SamOpenUser(
                     DomainHandle,
                     USER_CHANGE_PASSWORD,
                     *UserId,
                     &UserHandle
                     );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: Cannot open user %wZ, "
                     "status %8.8x\n", UserName, Status));
            goto Cleanup;
        }

        if (Encrypted) {

            //
            // The client is Windows for Workgroups, OS/2, or DOS running
            // the ENCRYPT service.  Pass the cross-encrypted passwords
            // to SamiLmChangePasswordUser.
            //

            Status = SamiLmChangePasswordUser(
                         UserHandle,
                         OldPassword,
                         NewPassword
                         );
        } else {

            //
            // The client is DOS not running the ENCRYPT service, and so
            // sent plaintext.  Calculate the one-way functions and call
            // SamiChangePasswordUser.
            //

            LM_OWF_PASSWORD OldLmOwfPassword, NewLmOwfPassword;

            Status = RtlCalculateLmOwfPassword(
                         OldPassword,
                         &OldLmOwfPassword
                         );

            if (NT_SUCCESS(Status)) {

                Status = RtlCalculateLmOwfPassword(
                             NewPassword,
                             &NewLmOwfPassword
                             );
            }

            if (!NT_SUCCESS(Status)) {
                KdPrint(("XsChangePasswordSam: Unable to generate OWF "
                         "passwords, %8.8x\n", Status));
                goto Cleanup;
            }


            //
            // Ask SAM to change the LM password and not store a new
            // NT password.
            //

            Status = SamiChangePasswordUser(
                         UserHandle,
                         TRUE,
                         &OldLmOwfPassword,
                         &NewLmOwfPassword,
                         FALSE,
                         NULL,
                         NULL
                         );

        }

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: Cannot change password "
                     "for %wZ, status %8.8x\n", UserName, Status));

            goto Cleanup;
        }

    } except (Status = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER) {

        KdPrint(("XsChangePasswordSam: caught exception 0x%8.8x\n", Status));

        if (RPC_S_SERVER_UNAVAILABLE == Status) {
            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        }

    }

Cleanup:

    NetApiBufferFree( serverName );

    if (DomainNameAllocated && DomainName.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, DomainName.Buffer);
    }

    if (DomainSid) {
        SamFreeMemory(DomainSid);
    }

    if (UserId) {
        SamFreeMemory(UserId);
    }

    if (NameUse) {
        SamFreeMemory(NameUse);
    }

    if (UserHandle) {
        SamCloseHandle(UserHandle);
    }

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

    return RtlNtStatusToDosError(Status);
}

NTSTATUS
XsSamOEMChangePasswordUser2_P (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to SamrOemChangePasswordUser2 coming in
        from Win 95 clients

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_SAMOEMCHGPASSWORDUSER2_P  parameters = Parameters;
    STRING                        UserName;
    SAMPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    ENCRYPTED_LM_OWF_PASSWORD     EncryptedOwfPassword;
    NTSTATUS                      ntstatus;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        if( SmbGetUshort( &parameters->BufLen ) !=
            sizeof( EncryptedUserPassword) + sizeof( EncryptedOwfPassword ) ) {

                Header->Status = ERROR_INVALID_PARAMETER;
                return STATUS_SUCCESS;
        }

        RtlCopyMemory( &EncryptedUserPassword,
                       parameters->Buffer,
                       sizeof( EncryptedUserPassword ) );

        RtlCopyMemory( &EncryptedOwfPassword,
                       parameters->Buffer + sizeof( EncryptedUserPassword ),
                       sizeof( EncryptedOwfPassword ) );

        UserName.Buffer = parameters->UserName;
        UserName.Length = (USHORT) strlen( UserName.Buffer );
        UserName.MaximumLength = UserName.Length;

        ntstatus = SamiOemChangePasswordUser2(
                NULL,
                &UserName,
                &EncryptedUserPassword,
                &EncryptedOwfPassword );


        if( ntstatus == STATUS_NOT_SUPPORTED ) {
            Header->Status = NERR_InvalidAPI;
        } else {
            Header->Status = (WORD)NetpNtStatusToApiStatus( ntstatus );
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    return STATUS_SUCCESS;

} // XsSamOEMChangePasswordUser2_P


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  Internal function implementation.                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

//
// Copied from ntos\dll\seurtl.c, where it is disabled.  Remove if
// it is enabled in ntdll.
//

NTSTATUS
RtlGetPrimaryDomain(
    IN  ULONG            SidLength,
    OUT PBOOLEAN         PrimaryDomainPresent,
    OUT PUNICODE_STRING  PrimaryDomainName,
    OUT PUSHORT          RequiredNameLength,
    OUT PSID             PrimaryDomainSid OPTIONAL,
    OUT PULONG           RequiredSidLength
    )

/*++

Routine Description:

    This procedure opens the LSA policy object and retrieves
    the primary domain information for this machine.

Arguments:

    SidLength - Specifies the length of the PrimaryDomainSid
        parameter.

    PrimaryDomainPresent - Receives a boolean value indicating
        whether this machine has a primary domain or not. TRUE
        indicates the machine does have a primary domain. FALSE
        indicates the machine does not.

    PrimaryDomainName - Points to the unicode string to receive
        the primary domain name.  This parameter will only be
        used if there is a primary domain.

    RequiredNameLength - Recevies the length of the primary
        domain name (in bytes).  This parameter will only be
        used if there is a primary domain.

    PrimaryDomainSid - This optional parameter, if present,
        points to a buffer to receive the primary domain's
        SID.  This parameter will only be used if there is a
        primary domain.

    RequiredSidLength - Recevies the length of the primary
        domain SID (in bytes).  This parameter will only be
        used if there is a primary domain.


Return Value:

    STATUS_SUCCESS - The requested information has been retrieved.

    STATUS_BUFFER_TOO_SMALL - One of the return buffers was not
        large enough to receive the corresponding information.
        The RequiredNameLength and RequiredSidLength parameter
        values have been set to indicate the needed length.

    Other status values as may be returned by:

        LsaOpenPolicy()
        LsaQueryInformationPolicy()
        RtlCopySid()


--*/
{
    NTSTATUS Status, IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;


    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );
    if (NT_SUCCESS(Status)) {

        //
        // Get the primary domain info
        //
        Status = LsaQueryInformationPolicy(LsaHandle,
                                           PolicyPrimaryDomainInformation,
                                           (PVOID *)&PrimaryDomainInfo);
        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (NT_SUCCESS(Status)) {

        //
        // Is there a primary domain?
        //

        if (PrimaryDomainInfo->Sid != NULL) {

            //
            // Yes
            //

            (*PrimaryDomainPresent) = TRUE;
            (*RequiredNameLength) = PrimaryDomainInfo->Name.Length;
            (*RequiredSidLength)  = RtlLengthSid(PrimaryDomainInfo->Sid);



            //
            // Copy the name
            //

            if (PrimaryDomainName->MaximumLength >=
                PrimaryDomainInfo->Name.Length) {
                RtlCopyUnicodeString(
                    PrimaryDomainName,
                    &PrimaryDomainInfo->Name
                    );
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }


            //
            // Copy the SID (if appropriate)
            //

            if (PrimaryDomainSid != NULL && NT_SUCCESS(Status)) {

                Status = RtlCopySid(SidLength,
                                    PrimaryDomainSid,
                                    PrimaryDomainInfo->Sid
                                    );
            }
        } else {

            (*PrimaryDomainPresent) = FALSE;
        }

        //
        // We're finished with the buffer returned by LSA
        //

        IgnoreStatus = LsaFreeMemory(PrimaryDomainInfo);
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }


    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xsunicod.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    XsUnicod.h

Abstract:

    This module contains declarations for Unicode work done by XACTSRV.

Author:

    Shanku Niyogi(w-shankn)      27-Sep-1991

Revision History:

--*/

#ifndef _XSUNICOD_
#define _XSUNICOD_

//
// Unicode macro/procedure definitions.
//
// !!UNICODE!! - Added these type-independent conversion routines.
// These will probably last only as long as NetpDup isn't written.

//
// XsDupStrToTstr, XsDupTstrToStr - allocate memory and do a
//                          NetpCopy. This memory is XACTSRV memory,
//                          and can be freed with NetpMemoryFree.
//

LPWSTR
XsDupStrToWStr(
    IN LPSTR Src
    );

LPSTR
XsDupWStrToStr(
    IN LPWSTR Src
    );

#ifdef UNICODE

#define XsDupStrToTStr( src ) ((LPTSTR)XsDupStrToWStr(( src )))
#define XsDupTStrToStr( src ) (XsDupWStrToStr((LPWSTR)( src )))

VOID
XsCopyTBufToBuf(
    OUT LPBYTE Dest,
    IN LPBYTE Src,
    IN DWORD DestSize
    );

VOID
XsCopyBufToTBuf(
    OUT LPBYTE Dest,
    IN LPBYTE Src,
    IN DWORD SrcSize
    );

#else

//
// XsDupStrToStr - used instead of strdup so that XsDupStrToTStr macros
//                 end up allocating memory from the same place, which
//                 can be freed with NetpMemoryFree.
//

LPSTR
XsDupStrToStr(
    IN LPSTR Src
    );

#define XsDupStrToTStr( src ) (LPTSTR)XsDupStrToStr( src )
#define XsDupTStrToStr( src ) XsDupStrToStr( (LPSTR)src )
#define XsCopyTBufToBuf( dest, src, size ) RtlCopyMemory( dest, src, size )
#define XsCopyBufToTBuf( dest, src, size ) RtlCopyMemory( dest, src, size )

#endif // def UNICODE

//
// VOID
// XsConvertTextParameter(
//     OUT LPTSTR OutParam,
//     IN LPSTR InParam
// )
//
// Convert InParam parameter to Unicode, allocating memory, and return the
// address in OutParam. Free with NetpMemoryFree.
//

#define XsConvertTextParameter( OutParam, InParam )     \
    if (( InParam ) == NULL ) {                         \
        OutParam = NULL;                                \
    } else {                                            \
        OutParam = XsDupStrToTStr( InParam );           \
        if (( OutParam ) == NULL ) {                    \
            Header->Status = (WORD)NERR_NoRoom;         \
            status = NERR_NoRoom;                       \
            goto cleanup;                               \
        }                                               \
    }

//
// VOID
// XsConvertUnicodeTextParameter(
//     OUT LPWSTR OutParam,
//     IN LPSTR InParam
// )
//
// Convert InParam parameter to Unicode, allocating memory, and return the
// address in OutParam. Free with NetpMemoryFree.
//

#define XsConvertUnicodeTextParameter( OutParam, InParam ) \
    if (( InParam ) == NULL ) {                            \
        OutParam = NULL;                                   \
    } else {                                               \
        OutParam = XsDupStrToWStr( InParam );              \
        if (( OutParam ) == NULL ) {                       \
            Header->Status = (WORD)NERR_NoRoom;            \
            status = NERR_NoRoom;                          \
            goto cleanup;                                  \
        }                                                  \
    }

#endif // ndef _XSUNICOD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xsparm16.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsParm16.h

Abstract:

    Constants for PARMNUM values for 16-bit info structures. 16-bit
    clients use these values for parmnum parameters, while NT uses
    its own values.

    ??UNICODE?? - Once the SetInfo calls are converted to the new
                  format (see NetShareSetInfo), this file is no longer
                  required.

Author:

    Shanku Niyogi (w-shanku) 03-Apr-1991

Revision History:

--*/

#ifndef _XSPARM16_

#define _XSPARM16_

//
// Standard PARMNUM_ALL value.
//

#define PARMNUM_16_ALL 0

//
// access_info_x parmnums.
//

#define PARMNUM_16_ACCESS_ATTR 2

//
// chardevQ_info_x parmnums.
//

#define PARMNUM_16_CHARDEVQ_PRIORITY 2
#define PARMNUM_16_CHARDEVQ_DEVS 3

//
// group_info_x parmnums.
//

#define PARMNUM_16_GRP1_COMMENT 2

//
// share_info_x parmnums.
//

#define PARMNUM_16_SHI_REMARK 4
#define PARMNUM_16_SHI_PERMISSIONS 5
#define PARMNUM_16_SHI_MAX_USES 6
#define PARMNUM_16_SHI_PASSWD 9

//
// server_info_x parmnums.
//

#define PARMNUM_16_SV_COMMENT 5
#define PARMNUM_16_SV_DISC 10
#define PARMNUM_16_SV_ALERTS 11
#define PARMNUM_16_SV_HIDDEN 16
#define PARMNUM_16_SV_ANNOUNCE 17
#define PARMNUM_16_SV_ANNDELTA 18
#define PARMNUM_16_SV_ALERTSCHED 37
#define PARMNUM_16_SV_ERRORALERT 38
#define PARMNUM_16_SV_LOGONALERT 39
#define PARMNUM_16_SV_ACCESSALERT 40
#define PARMNUM_16_SV_DISKALERT 41
#define PARMNUM_16_SV_NETIOALERT 42
#define PARMNUM_16_SV_MAXAUDITSZ 43

//
// user_info_x parmnums.
//

#define PARMNUM_16_USER_PASSWD 3
#define PARMNUM_16_USER_PRIV 5
#define PARMNUM_16_USER_DIR 6
#define PARMNUM_16_USER_COMMENT 7
#define PARMNUM_16_USER_USER_FLAGS 8
#define PARMNUM_16_USER_SCRIPT_PATH 9
#define PARMNUM_16_USER_AUTH_FLAGS 10
#define PARMNUM_16_USER_FULL_NAME 11
#define PARMNUM_16_USER_USR_COMMENT 12
#define PARMNUM_16_USER_PARMS 13
#define PARMNUM_16_USER_WORKSTATIONS 14
#define PARMNUM_16_USER_ACCT_EXPIRES 17
#define PARMNUM_16_USER_MAX_STORAGE 18
#define PARMNUM_16_USER_LOGON_HOURS 20
#define PARMNUM_16_USER_LOGON_SERVER 23
#define PARMNUM_16_USER_COUNTRY_CODE 24
#define PARMNUM_16_USER_CODE_PAGE 25

//
// user_modals_info_x parmnums
//

#define PARMNUM_16_MODAL0_MIN_LEN 1     // These two must be the same!
#define PARMNUM_16_MODAL1_ROLE 1
#define PARMNUM_16_MODAL0_MAX_AGE 2     // These two must be the same!
#define PARMNUM_16_MODAL1_PRIMARY 2
#define PARMNUM_16_MODAL0_MIN_AGE 3
#define PARMNUM_16_MODAL0_FORCEOFF 4
#define PARMNUM_16_MODAL0_HISTLEN 5

//
// wksta_info_x parmnums
//

#define PARMNUM_16_WKSTA_CHARWAIT 10
#define PARMNUM_16_WKSTA_CHARTIME 11
#define PARMNUM_16_WKSTA_CHARCOUNT 12
#define PARMNUM_16_WKSTA_ERRLOGSZ 27
#define PARMNUM_16_WKSTA_PRINTBUFTIME 28
#define PARMNUM_16_WKSTA_WRKHEURISTICS 32
#define PARMNUM_16_WKSTA_OTHDOMAINS 35

#endif // ndef _XSPARM16_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xsprocsp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsProcsP.h

Abstract:

    This header file contains private procedure prototypes for XACTSRV.

Author:

    David Treadwell (davidtr) 05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#ifndef _XSPROCSP_
#define _XSPROCSP_

//
// This header file is full of expressions that are always false. These
// expressions manifest themselves in macros that take unsigned values
// and make tests, for example, of greater than or equal to zero.
//
// Turn off these warnings until the authors fix this code.
//

#pragma warning(disable:4296)

//
// Helper subroutines.
//

//
// XsAddVarString(
//     IN OUT LPSTR StringLocation,
//     IN LPTSTR String,
//     IN OUT LPBYTE *Pointer,
//     IN LPBYTE OffsetBegin
// )
//
// Copy string to location, put the offset of location from OffsetBegin
// in Pointer, and update location to point past string.
//
// !!UNICODE!! - Changed strcpy to NetpCopyTStrToStr. Fix WKSTA.H to use this!

#define XsAddVarString( StringLocation, String, Pointer, OffsetBegin ) \
    NetpCopyWStrToStrDBCS((StringLocation), (String));                 \
    SmbPutUlong((LPDWORD)(Pointer),                                    \
        (ULONG)((LPBYTE)(StringLocation)-(LPBYTE)(OffsetBegin)));      \
    StringLocation += (strlen((LPSTR)StringLocation) + 1)

//
// XsAuxiliaryDescriptor - return second argument if 'N' character is present
//     in first argument (an LPDESC), or NULL otherwise.
//
// !!UNICODE!! - Descriptor strings are always Ascii. No conversion.

#define XsAuxiliaryDescriptor( DataDescriptor, EndOfParameters ) \
    (( strchr(( DataDescriptor ), REM_AUX_NUM ) != NULL ) \
        ? (EndOfParameters) : NULL )

//
// BOOL
// XsApiSuccess(
//     IN NET_API_STATUS Status
// )
//
// XsApiSuccess - check if status is one of three allowable ones.
//

#define XsApiSuccess( Status ) \
    (( (Status) == NERR_Success ) || ( (Status) == ERROR_MORE_DATA ) || \
        ( (Status) == NERR_BufTooSmall ))

//
// WORD
// XsDwordToWord(
//     IN DWORD d
// )
//
// Returns the WORD which is closest in value to the supplied DWORD.
//

#define XsDwordToWord(d) \
    ( (WORD) ( (DWORD) (d) > 0xffff ? 0xffff : (d) ) )

//
// BYTE
// XsDwordToByte(
//     IN DWORD d
// )
//
// Returns the BYTE which is closest in value to the supplied DWORD.
//

#define XsDwordToByte(d) \
    ( (BYTE) ( (DWORD) (d) > 0xff ? 0xff : (d) ) )

//
// BYTE
// XsBoolToDigit(
//     IN BOOL b
// )
//
// Returns '1' if the supplied boolean is true, or '0' if it is false.
//

#define XsBoolToDigit(b) \
    ( (BYTE) ( (BOOL)(b) ? '0' : '1' ) )

DWORD
XsBytesForConvertedStructure (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN RAP_CONVERSION_MODE Mode,
    IN BOOL MeaninglessInputPointers
    );

BOOL
XsCheckBufferSize (
    IN WORD BufferLength,
    IN LPDESC Descriptor,
    IN BOOL NativeFormat
    );

//
// XsDwordParamOutOfRange(
//     IN DWORD Field,
//     IN DWORD Min,
//     IN DWORD Max
//     )
//
// Check if parameter is out of range.
//


#define XsDwordParamOutOfRange( Field, Min, Max )   \
    (((DWORD)SmbGetUlong( &( Field )) < ( Min )) || \
     ((DWORD)SmbGetUlong( &( Field )) > ( Max )))

// !!UNICODE!! - Validation on ASCII string - leave as LPSTR
NET_API_STATUS
XsValidateShareName(
    IN LPSTR ShareName
);

NET_API_STATUS
XsConvertSetInfoBuffer(
    IN LPBYTE InBuffer,
    IN WORD BufferLength,
    IN WORD ParmNum,
    IN BOOL ConvertStrings,
    IN BOOL MeaninglessInputPointers,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN LPDESC InSetInfoDesc,
    IN LPDESC OutSetInfoDesc,
    OUT LPBYTE * OutBuffer,
    OUT LPDWORD OutBufferLength OPTIONAL
    );

//
// BOOL
// XsDigitToBool(
//     IN BYTE b
// )
//
// Returns false if the supplied digit is '0', true otherwise.
//

#define XsDigitToBool(b) \
    (BOOL)((( b ) == '0' ) ? FALSE : TRUE )

VOID
XsFillAuxEnumBuffer (
    IN LPBYTE InBuffer,
    IN DWORD NumberOfEntries,
    IN LPDESC InStructureDesc,
    IN LPDESC InAuxStructureDesc,
    IN OUT LPBYTE OutBuffer,
    IN LPBYTE OutBufferStart,
    IN DWORD OutBufferLength,
    IN LPDESC OutStructureDesc,
    IN LPDESC OutAuxStructureDesc,
    IN PXACTSRV_ENUM_VERIFY_FUNCTION VerifyFunction OPTIONAL,
    OUT LPDWORD BytesRequired,
    OUT LPDWORD EntriesFilled,
    OUT LPDWORD InvalidEntries OPTIONAL
    );

VOID
XsFillEnumBuffer (
    IN LPBYTE InBuffer,
    IN DWORD NumberOfEntries,
    IN LPDESC InStructureDesc,
    IN OUT LPBYTE OutBuffer,
    IN LPBYTE OutBufferStart,
    IN DWORD OutBufferLength,
    IN LPDESC OutStructureDesc,
    IN PXACTSRV_ENUM_VERIFY_FUNCTION VerifyFunction OPTIONAL,
    OUT LPDWORD BytesRequired,
    OUT LPDWORD EntriesFilled,
    OUT LPDWORD InvalidEntries OPTIONAL
    );

LPBYTE
XsFindParameters (
    IN LPTRANSACTION Transaction
    );

//
// DWORD
// XsLevelFromParmNum(
//     WORD Level,
//     WORD ParmNum
//     )
//
// Translate an old parmnum to an info level. If parmnum is PARMNUM_ALL,
// this is just the old level, otherwise it is the old parmnum plus
// PARMNUM_BASE_INFOLEVEL.
//

#define XsLevelFromParmNum( Level, ParmNum )                      \
    ((( ParmNum ) == PARMNUM_ALL ) ? (DWORD)( Level )             \
                                   : (DWORD)( ParmNum )           \
                                         + PARMNUM_BASE_INFOLEVEL )

//
// Maps downlevel service names to nt service names
//

#define XS_MAP_SERVICE_NAME( ServiceName ) \
        (!STRICMP( ServiceName, SERVICE_LM20_SERVER ) ? SERVICE_SERVER :    \
         !STRICMP( ServiceName, SERVICE_LM20_WORKSTATION ) ? SERVICE_WORKSTATION : \
         ServiceName )


//
// DWORD
// XsNativeBufferSize(
//     IN WORD Size
//     )
//
// Uses XS_BUFFER_SCALE constant to calculate a reasonable maximum for the host
// buffer, and rounds it to an even number for alignment.
//

#define XsNativeBufferSize( Size ) \
    ( (( XS_BUFFER_SCALE * (DWORD)( Size )) + 1) & (~1) )

WORD
XsPackReturnData (
    IN LPVOID Buffer,
    IN WORD BufferLength,
    IN LPDESC Descriptor,
    IN DWORD EntriesRead
    );

VOID
XsSetDataCount(
    IN OUT LPWORD DataCount,
    IN LPDESC Descriptor,
    IN WORD Converter,
    IN DWORD EntriesRead,
    IN WORD ReturnStatus
    );

//
// XsWordParamOutOfRange(
//     IN WORD Field,
//     IN WORD Min,
//     IN WORD Max
//     )
//
// Check if parameter is out of range.
//
// N.B. If Min is zero, then the first part of the following expression is
//      always FALSE.
//

#define XsWordParamOutOfRange( Field, Min, Max )            \
    (((DWORD)SmbGetUshort( &( Field )) < ( (DWORD)Min )) || \
     ((DWORD)SmbGetUshort( &( Field )) > ( (DWORD)Max )))

VOID
XsAnnounceServiceStatus( VOID );

//
// API bogus stub.
//

NTSTATUS
XsNetUnsupportedApi (
    API_HANDLER_PARAMETERS
    );

//
//  Convert an NT style server info array into a packed
//  RAP server info array
//

typedef
USHORT
(XS_CONVERT_SERVER_ENUM_BUFFER_FUNCTION)(
    IN LPVOID ServerEnumBuffer,
    IN DWORD EntriesRead,
    IN OUT PDWORD TotalEntries,
    IN USHORT Level,
    OUT LPBYTE ClientBuffer,
    IN USHORT BufferLength,
    OUT PDWORD EntriesFilled,
    OUT PUSHORT Converter
    );

extern XS_CONVERT_SERVER_ENUM_BUFFER_FUNCTION XsConvertServerEnumBuffer;


//++
//
// ULONG
// XsSmbGetPointer (
//     IN PSMB_ULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a ULONG value from the possibly misaligned
//     source address, avoiding alignment faults.
//     This also takes into account the fact that pointers are 8-bytes on 64-bit.
//
// Arguments:
//
//     SrcAddress - where to retrieve ULONG value from
//
// Return Value:
//
//     ULONG - the value retrieved.  The target must be aligned.
//
//--
#if defined (_WIN64)
#define XsSmbGetPointer(SrcAddress) ((LPBYTE)(  ((__int64)SmbGetUlong((LPVOID)SrcAddress)) + (((__int64)SmbGetUlong( ( ((LPBYTE)SrcAddress) + 4 ) ) ) << 32) ))
#else
#define XsSmbGetPointer SmbGetUlong
#endif


//++
//
// VOID
// XsSmbPutPointer (
//     OUT PSMB_ULONG DestAddress,
//     IN LPVOID Value
//     )
//
// Routine Description:
//
//     This macro stores a POINTER value at the possibly misaligned
//     destination address, avoiding alignment faults.
//     This also takes into account the fact that 64-bit pointers are 8-bytes
//
// Arguments:
//
//     DestAddress - where to store ULONG value
//
//     Value - ULONG to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--
#if defined (_WIN64)
#define XsSmbPutPointer(DestAddress64,Value)                 \
              {                                              \
                    LPDWORD Source = (LPDWORD)(&Value);      \
                    LPDWORD Dest = (LPDWORD)DestAddress64;   \
                    SmbPutUlong( Dest, SmbGetUlong(Source) );             \
                    SmbPutUlong( Dest+1, SmbGetUlong(Source+1) );         \
              }

#else
#define XsSmbPutPointer(DEST,VAL) SmbPutUlong(DEST, (ULONG)VAL)
#endif

#endif // ndef _XSPROCSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xssubs.c ===
/*++

Copyright (c) 1991-92 Microsoft Corporation

Module Name:

    XsSubs.c

Abstract:

    This module contains various subroutines for XACTSRV.

Author:

    David Treadwell (davidtr)    07-Jan-1991

Revision History:

    05-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo(from downlevel) level 3, rc=124.  (4&5 too.)
    (Fixed XsFillAuxEnumBuffer.)

--*/

#include "XactSrvP.h"
#include <WinBase.h>          // GetCurrentProcessId prototype
#include <align.h>

VOID
SmbCapturePtr(
    LPBYTE  PointerDestination,
    LPBYTE  PointerSource
    );


DWORD
XsBytesForConvertedStructure (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN RAP_CONVERSION_MODE Mode,
    IN BOOL MeaninglessInputPointers
    )

/*++

Routine Description:

    This routine determines the number of bytes that would be required
    to hold the input structure when converted to the structure
    described by OutStructureDesc.

Arguments:

    InStructure - a pointer to the actual input structure.

    InStructureDesc - a pointer to an ASCIIZ describing the format of the
        input structure.

    OutStructureDesc - a pointer to an ASCIIZ describing the format of the
        output structure.

    Mode - indicates mode of conversion (native to RAP or vice versa).

Return Value:

    DWORD - The number of bytes required to hold the converted structure.

--*/

{
    NET_API_STATUS status;
    DWORD bytesRequired = 0;

    //
    // Use RapConvertSingleEntry to get the size that the input structure
    // will take when converted to the format specified in the output
    // structure description.  That routine should not actually write
    // anything--it should simply appear that there is no room to
    // write more data into, just as if an Enum buffer is full.
    //

    //
    // Should handle errors from RapConvertSingleEntry.
    // But the way this is used, existing code probably
    // won't break if we just ignore them.
    //

    status = RapConvertSingleEntry(
                 InStructure,
                 InStructureDesc,
                 MeaninglessInputPointers,
                 NULL,
                 NULL,
                 OutStructureDesc,
                 FALSE,
                 NULL,
                 &bytesRequired,
                 Response,
                 Mode
                 );

    //
    // For native structures, we should make sure the buffer is an even amount,
    // to allow an even boundary for strings, as in Unicode.
    //

    if ( Mode == RapToNative ) {

        bytesRequired = ROUND_UP_COUNT( bytesRequired, ALIGN_DWORD );
    }

    return bytesRequired;

} // XsBytesForConvertedStructure


LPVOID
XsCaptureParameters (
    IN LPTRANSACTION Transaction,
    OUT LPDESC *AuxDescriptor
    )

/*++

Routine Description:

    This routine captures all input parameters from the transaction block
    and puts them into a consistent structure that API handlers can access.
    It allocates memory to hold this structure.  This memory should be
    freed by XsSetParameters after the API handler has done its work.

Arguments:

    Transaction - a pointer to the transaction block describing the
        request.

    AuxDescriptor - a pointer to a LPDESC which will hold a pointer to
        the auxiliary descriptor string if there is one, or NULL if there
        is not.

Return Value:

    LPVOID - a pointer to a buffer containing the captured parameters.

--*/

{
    LPDESC descriptorString;
    LPDESC descriptor;
    LPBYTE inParams;
    DWORD outParamsLength;
    LPBYTE outParams;
    LPBYTE outParamsPtr;
    WORD rcvBufferLength;

    //
    // The first two bytes of the parameter section are the API number,
    // then comes the descriptor string.
    //

    descriptorString = Transaction->InParameters + 2;

    //
    // Find the actual parameter data in the input.
    //

    inParams = XsFindParameters( Transaction );

    //
    // Find out how much space to allocate to hold the parameters.
    //

    outParamsLength = RapStructureSize( descriptorString, Response, FALSE );

    //
    // Allocate space to hold the output parameters.
    // In addition when the request fails the current APIs set the buflen field
    // In order to account for this additional buffer space is allocated. Since
    // this field is not located at the same offset we need to compute the
    // additional space reqd. to be the maximum of all the offsets. Currently
    // the 16 byte offset seems to suffice. When modifying apiparam.h ensure
    // that this is the case.
    //

    outParams = NetpMemoryAllocate( sizeof(XS_PARAMETER_HEADER)
                                        + outParamsLength +
                                        sizeof(DWORD) * 4);

    if ( outParams == NULL ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsCaptureParameters: unable to allocate %ld bytes\n",
                          outParamsLength ));
        }
        return NULL;
    }

    //
    // Zero out the parameters and set outParamsPtr to the start of the
    // actual parameters.
    //

    RtlZeroMemory( outParams, sizeof(XS_PARAMETER_HEADER) + outParamsLength );
    outParamsPtr = outParams + sizeof(XS_PARAMETER_HEADER);

    //
    // For each character in the descriptor string, fill in the output
    // parameters as appropriate.
    //

    for ( descriptor = descriptorString; *descriptor != '\0'; ) {

        switch ( *descriptor++ ) {

        case REM_ASCIZ:

            //
            // The parameter is a pointer to a string. The actual string
            // is in the parameter data, so put a pointer to it in the
            // output structure.
            //
            // String parameters just get passed as is. It
            // is up to the API handler to convert the actual data.
            //

            //
            // !!! Parameter string descriptors may not have maximum length
            //     counts.
            //

            if( isdigit( *descriptor ) ) {
                NetpMemoryFree( outParams );
                return NULL;
            }

            SmbCapturePtr( outParamsPtr, inParams );

            //
            // Update pointers -- move inParams past end of string.
            //

            inParams += ( strlen( inParams ) + 1 );
            outParamsPtr += sizeof(LPSTR);

            break;

        case REM_BYTE_PTR:
        case REM_FILL_BYTES:

            //
            // The parameter is a pointer to a byte or array of bytes.
            //

            SmbCapturePtr( outParamsPtr, inParams );

            inParams += sizeof(BYTE) * RapDescArrayLength( descriptor );
            outParamsPtr += sizeof(LPBYTE);

            break;

        case REM_DWORD:

            //
            // The parameter is a dword or array of dwords.
            //
            // !!! This assumes that an array of words will never be passed
            //     as a parameter.

            if( isdigit( *descriptor ) ) {
                NetpMemoryFree( outParams );
                return NULL;
            }

            //
            // Copy over the double word and update pointers.
            //

            SmbPutUlong(
                (LPDWORD)outParamsPtr,
                SmbGetUlong( (LPDWORD)inParams )
                );

            inParams += sizeof(DWORD);
            outParamsPtr += sizeof(DWORD);

            break;

        case REM_ENTRIES_READ:
        case REM_RCV_WORD_PTR:

            //
            // Count of entries read (e) or receive word pointer (h).
            // This is an output parameter, so just zero it and
            // increment the output parameter pointer.
            //

            SmbPutUshort( (LPWORD)outParamsPtr, 0 );

            outParamsPtr += sizeof(WORD);

            break;

        case REM_RCV_DWORD_PTR:

            //
            // Count of receive dword pointer (i).
            // This is an output parameter, so just zero it and
            // increment the output parameter pointer.
            //

            SmbPutUlong( (LPDWORD)outParamsPtr, 0 );

            outParamsPtr += sizeof(DWORD);

            break;

        case REM_NULL_PTR:

            //
            // Null pointer. Set output parameter to NULL, and increment
            // pointers.
            //

            SmbCapturePtr( outParamsPtr, NULL );
            outParamsPtr += sizeof(LPSTR);

            break;

        case REM_RCV_BUF_LEN:

            //
            // The length of the receive buffer (r).
            //

            rcvBufferLength = SmbGetUshort( (LPWORD)inParams );

            //
            // If the indicated buffer length is greater than the max
            // data count on the transaction, somebody messed up. Set
            // the length to MaxDataCount.
            //

            if ( rcvBufferLength > (WORD)Transaction->MaxDataCount ) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsCaptureParameters: OutBufLen %lx greater than MaxDataCount %lx.\n",
                    rcvBufferLength, Transaction->MaxDataCount ));
                }

                rcvBufferLength = (WORD)Transaction->MaxDataCount;
            }

            //
            // Put the max output data length in the output parameters.
            //

            SmbPutUshort( (LPWORD)outParamsPtr, rcvBufferLength );

            //
            // Fill in the receive buffer with zeroes for security.
            //

            RtlZeroMemory( Transaction->OutData, (DWORD)rcvBufferLength );

            inParams += sizeof(WORD);
            outParamsPtr += sizeof(WORD);

            break;

        case REM_RCV_BUF_PTR:

            //
            // A pointer to a receive data buffer.  There is nothing in
            // the transaction corresponding to this, but set a longword
            // in the output parameters to point to the data output
            // section of the transaction.
            //

            SmbCapturePtr(
                outParamsPtr,
                Transaction->OutData
                );

            outParamsPtr += sizeof(LPBYTE);

            break;

        case REM_RCV_BYTE_PTR:

            //
            // Return bytes, so just increment output parameter pointer.
            //

            outParamsPtr += sizeof(BYTE) * RapDescArrayLength( descriptor );

            break;

        case REM_SEND_BUF_LEN:

            //
            // The size of an input data buffer.  Put the size of the
            // received data in the output structure.
            //

            SmbPutUshort(
                (LPWORD)outParamsPtr,
                (WORD)Transaction->DataCount
                );

            outParamsPtr += sizeof(WORD);

            break;

        case REM_SEND_BUF_PTR:

            //
            // A pointer to a send data buffer.  There is nothing in the
            // transaction corresponding to this, but set a longword in
            // the output parameters to point to the data input section
            // of the transaction.
            //

            SmbCapturePtr( outParamsPtr, Transaction->InData );

            outParamsPtr += sizeof(LPBYTE);

            break;

        case REM_WORD:
        case REM_PARMNUM:

            //
            // The parameter is a word.
            //
            // !!! This assumes that an array of words will never be passed
            //     as a parameter.

            if( isdigit( *descriptor ) ) {
                NetpMemoryFree( outParams );
                return NULL;
            }

            //
            // Copy over the word and update pointers.
            //

            SmbPutUshort(
                (LPWORD)outParamsPtr,
                SmbGetUshort( (LPWORD)inParams )
                );

            inParams += sizeof(WORD);
            outParamsPtr += sizeof(WORD);

            break;

        default:

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsCaptureParameters: unsupported character at %lx: "
                                "%c\n", descriptor - 1, *( descriptor - 1 ) ));
                NetpBreakPoint( );
            }
        }
    }

    //
    // Examine the data descriptor string to see if an auxiliary descriptor
    // string exists. If it does, the string starts right after the end
    // of the parameters.
    //

    *AuxDescriptor = XsAuxiliaryDescriptor( ++descriptor, inParams );

    return outParams;

} // XsCaptureParameters


BOOL
XsCheckBufferSize (
    IN WORD BufferLength,
    IN LPDESC Descriptor,
    IN BOOL NativeFormat
    )

/*++

Routine Description:

    This routine determines if there is enough room in the buffer for the
    fixed component of at least one entry of the described structure.

Arguments:

    BufferLength - the length of the buffer to test.

    Descriptor - the format of the structure in the buffer.

    NativeFormat - TRUE iff the buffer is in native (as opposed to RAP) format.

Return Value:

    BOOL - True if there is enough room, false if there isn't.

--*/

{
    if ( (DWORD)BufferLength
            >= RapStructureSize( Descriptor, Response, NativeFormat )) {

        return TRUE;

    } else {

        return FALSE;

    }

} // XsCheckBufferSize


BOOL
XsCheckSmbDescriptor(
    IN LPDESC SmbDescriptor,
    IN LPDESC ActualDescriptor
)

/*++

Routine Description:

    This routine checks whether a descriptor passed in the SMB matches
    the actual descriptor expected, taking into account that the actual
    descriptor may have ignore fields which have no corresponding field in
    the SMB descriptor, and that the SMB descriptor may have null pointer
    fields instead of normal pointer fields. However, array-type fields
    have to be of the same length in both descriptors.

Arguments:

    SmbDescriptor - the descriptor to be validated.

    ActualDescriptor - the descriptor expected. Does not have to be an
        exact match - see the description above.

Return Value:

    BOOL - TRUE if the descriptor is valid,
           FALSE otherwise.

--*/

{
    DESC_CHAR smbField;
    DESC_CHAR expField;
    DWORD smbFieldSize;
    DWORD expFieldSize;
    CHAR nullParam = '\0';

    if( ActualDescriptor == NULL )
    {
        ActualDescriptor = &nullParam;
    }

    while (( smbField = *SmbDescriptor++ ) != '\0' ) {

        smbFieldSize = RapDescArrayLength( SmbDescriptor );

        //
        // Skip over ignore fields.
        //

        while ( *ActualDescriptor == REM_IGNORE ) {
            ActualDescriptor++;
        }

        //
        // There should be a corresponding field expected.
        //

        if (( expField = *ActualDescriptor++ ) == '\0' ) {
            return FALSE;
        }

        expFieldSize = RapDescArrayLength( ActualDescriptor );

        //
        // If both are actual data fields, they must be the same type and of
        // same length.
        //

        if (( !RapIsPointer( expField ) || smbField != REM_NULL_PTR ) &&
                 ( smbField != expField || smbFieldSize != expFieldSize )) {
            return FALSE;
        }

        //
        // SMB provides a null pointer field, we are expecting any pointer.
        // This is OK, as long as there is no input array length.
        //

        if ( smbField == REM_NULL_PTR &&
                 ( !RapIsPointer( expField ) || smbFieldSize != 1 )) {
            return FALSE;
        }
    }

    while ( *ActualDescriptor == REM_IGNORE ) {
        ActualDescriptor++;
    }

    //
    // Validate that the entire descriptor was present!
    //
    if( (*ActualDescriptor) != '\0' )
    {
        return FALSE;
    }

    return TRUE;

} // XsCheckSmbDescriptor


NET_API_STATUS
XsConvertSetInfoBuffer(
    IN LPBYTE InBuffer,
    IN WORD BufferLength,
    IN WORD ParmNum,
    IN BOOL ConvertStrings,
    IN BOOL MeaninglessInputPointers,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN LPDESC InSetInfoDesc,
    IN LPDESC OutSetInfoDesc,
    OUT LPBYTE * OutBuffer,
    OUT LPDWORD OutBufferLength OPTIONAL
    )

/*++

Routine Description:

    This routine converts data for a SetInfo call based on the parameter
    number (ParmNum) value. The ParmNum indicates the field in the whole
    structure which has to be changed, and may be 0.

Arguments:

    InBuffer - a pointer to the input buffer in 16-bit format.

    BufferLength - the length of the input buffer.

    ParmNum - the parameter number.

    ConvertStrings - a boolean indicating whether string parameter data
        should be converted to a pointer form. If TRUE, the return data
        buffer will have a pointer to another place in the buffer where
        the string will be. If FALSE, the data buffer will have only the
        physical string.

    InStructureDesc - the exact descriptor of the input buffer.

    OutStructureDesc - the descriptor of the 32-bit output data, as found
        in RemDef.h.

    InSetInfoDesc - the setinfo-specific descriptor of the input structure
        format, as found in RemDef.h.

    OutSetInfoDesc - the setinfo-specific descriptor of the output structure
        format, as found in RemDef.h.

    OutBuffer - a pointer to an LPBYTE which will get a pointer to the
        resulting output buffer.

    OutBufferLength - an optional pointer to a DWORD which will get the
        length of the resulting output buffer.

Return Value:

    NET_API_STATUS - NERR_Success if conversion was successful; otherwise
        the appropriate status to return to the user. The only exception is
        ERROR_NOT_SUPPORTED, which indicates that the particular parameter
        number is valid, but not on NT.

--*/

{

    LPDESC fieldDesc = NULL;
    DWORD stringLength;
    LPDESC subDesc = NULL;
    LPDESC subDesc2 = NULL;
    DWORD bufferSize;
    LPBYTE stringLocation;
    DWORD bytesRequired = 0;
    LPDESC OutDescCopy = OutStructureDesc;
    NET_API_STATUS status = NERR_Success;

    //
    // The buffer length should be greater than 0.
    //

    if ( BufferLength == 0 ) {

        return NERR_BufTooSmall;

    }

    if ( ParmNum != PARMNUM_ALL ) {

        //
        // Check 16-bit parameter to see if it could be changed in OS/2.
        //

        fieldDesc = RapParmNumDescriptor( InSetInfoDesc, (DWORD)ParmNum,
                        Both, FALSE );

        if ( fieldDesc == NULL ) {

            return NERR_NoRoom;
        }

        if ( fieldDesc[0] == REM_UNSUPPORTED_FIELD ) {

            status = ERROR_INVALID_PARAMETER;
            goto cleanup;

        } else {

            InStructureDesc = RapParmNumDescriptor( InStructureDesc,
                                  (DWORD)ParmNum, Both, FALSE );
        }

        NetpMemoryFree( fieldDesc );

        //
        // Check 32-bit parameter to see if it is valid in NT.
        //

        fieldDesc = RapParmNumDescriptor( OutSetInfoDesc, (DWORD)ParmNum,
                        Both, TRUE );

        if ( fieldDesc == NULL ) {

            return NERR_NoRoom;
        }

        if ( fieldDesc[0] == REM_IGNORE ) {

            status = ERROR_NOT_SUPPORTED;
            goto cleanup;

        } else {

            OutStructureDesc = RapParmNumDescriptor( OutStructureDesc,
                                   (DWORD)ParmNum, Both, TRUE );
        }

        //
        // Filter out strings that are too long for LM2.x.
        //

        if ( InStructureDesc[0] == REM_ASCIZ
             || InStructureDesc[0] == REM_ASCIZ_TRUNCATABLE ) {

            subDesc = InStructureDesc + 1;
            stringLength = RapDescStringLength( subDesc );
            subDesc = NULL;
            if ( stringLength && strlen( InBuffer ) >= stringLength ) {
                switch( InStructureDesc[0] ) {
                case REM_ASCIZ:
                    status = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                case REM_ASCIZ_TRUNCATABLE:
                    InBuffer[stringLength - 1] = '\0';
                }
            }
        }

        //
        // If a descriptor is a string pointer, the data is the actual
        // string, rather than a pointer. Find the length of the string,
        // and create a descriptor.
        //
        // Assuming all these arrays are string data, we
        // use available macros to generate an array big
        // enough to hold the converted string.

        if ( InStructureDesc[0] == REM_ASCIZ
             || InStructureDesc[0] == REM_ASCIZ_TRUNCATABLE ) {

            if (( subDesc = NetpMemoryAllocate( MAX_DESC_SUBSTRING + 1 ))
                      == NULL ) {
                status = NERR_NoRoom;
                goto cleanup;
            }
            stringLength = strlen( InBuffer ) + 1;
            subDesc[0] = REM_BYTE;
            _ltoa( stringLength, &subDesc[1], 10 );
            InStructureDesc = subDesc;

        }

        //
        // If output descriptor is a string pointer, and we are asked to keep
        // strings inline, make the target data an array of bytes. We find out
        // the length required by "walking" the input descriptor, and then
        // allocate memory to hold a similar descriptor.
        //
        // Assuming all these arrays are string data, we
        // use available macros to generate an array big
        // enough to hold the converted string. Because of the way
        // RAP works, if the destination string is Unicode, the destination
        // array will be exactly twice as long, and RAP will automatically
        // do the Unicode conversion.
        //

        if (( OutStructureDesc[0] == REM_ASCIZ
             || OutStructureDesc[0] == REM_ASCIZ_TRUNCATABLE )
             && !ConvertStrings ) {

            OutDescCopy = OutStructureDesc;
            subDesc2 = InStructureDesc + 1;
            stringLength = RapDescArrayLength( subDesc2 );
            if (( subDesc2 = NetpMemoryAllocate( MAX_DESC_SUBSTRING + 1 ))
                      == NULL ) {
                status = NERR_NoRoom;
                goto cleanup;
            }
            subDesc2[0] = REM_BYTE;
            _ltoa( STRING_SPACE_REQD( stringLength ), &subDesc2[1], 10 ) ;
            OutStructureDesc = subDesc2;
        }

    }

    if ( !XsCheckBufferSize( BufferLength, InStructureDesc, FALSE )) {

        status = NERR_BufTooSmall;
        goto cleanup;
    }

    //
    // Find out how big a 32-bit data buffer we need.
    //

    bufferSize = XsBytesForConvertedStructure(
                     InBuffer,
                     InStructureDesc,
                     OutStructureDesc,
                     RapToNative,
                     MeaninglessInputPointers
                     );

    //
    // Allocate enough memory to hold the converted native buffer.
    //

    *OutBuffer = NetpMemoryAllocate( bufferSize );

    if ( *OutBuffer == NULL ) {

        status = NERR_NoRoom;
        goto cleanup;
    }


    //
    // Convert 16-bit data into 32-bit data and store it in the native
    // buffer.
    //

    stringLocation = *OutBuffer + bufferSize;
    bytesRequired = 0;

    status = RapConvertSingleEntry(
                 InBuffer,
                 InStructureDesc,
                 MeaninglessInputPointers,
                 *OutBuffer,
                 *OutBuffer,
                 OutStructureDesc,
                 FALSE,
                 &stringLocation,
                 &bytesRequired,
                 Response,
                 RapToNative
                 );

    if ( status != NERR_Success ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsConvertSetInfoBuffer: RapConvertSingleEntry "
                          "failed %X\n", status ));
        }

        status = NERR_InternalError;
        goto cleanup;
    }

cleanup:

    //
    // Free buffers.
    //

    NetpMemoryFree( subDesc );
    NetpMemoryFree( subDesc2 );
    NetpMemoryFree( fieldDesc );

    if ( OutBufferLength != NULL ) {

        *OutBufferLength = bytesRequired;
    }

    return status;

} // XsConvertSetInfoBuffer


NET_API_STATUS
XsDefaultEnumVerifyFunction (
    NET_API_STATUS ConvertStatus,
    PBYTE ConvertedEntry,
    PBYTE BaseAddress
    )

/*++

Routine Description:

    This is the default routine called by XsFillEnumBuffer to determine
    whether each converted entry should be retained or discarded.  This
    routine directs XsFillEnumBuffer to discard any entry which
    RapConvertSingleEntry encountered an error trying to convert.

Parameters:

    ConvertStatus - the status which RapConvertSingleEntry encountered
        trying to convert this entry.

    ConvertedEntry - a pointer to the buffer containing the converted entry.

    BaseAddress - A pointer to the base used to calculate offsets.

Return Value:

    NET_API_STATUS - NERR_Success if the entry should be retained,
               or an error code if the entry should be discarded.

--*/

{
    UNREFERENCED_PARAMETER(ConvertedEntry);
    UNREFERENCED_PARAMETER(BaseAddress);

    return ConvertStatus;
}


VOID
XsFillAuxEnumBuffer (
    IN LPBYTE InBuffer,
    IN DWORD NumberOfEntries,
    IN LPDESC InStructureDesc,
    IN LPDESC InAuxStructureDesc,
    IN OUT LPBYTE OutBuffer,
    IN LPBYTE OutBufferStart,
    IN DWORD OutBufferLength,
    IN LPDESC OutStructureDesc,
    IN LPDESC OutAuxStructureDesc,
    IN PXACTSRV_ENUM_VERIFY_FUNCTION VerifyFunction OPTIONAL,
    OUT LPDWORD BytesRequired,
    OUT LPDWORD EntriesFilled,
    OUT LPDWORD InvalidEntries OPTIONAL
    )

/*++

Routine Description:

    This routine copies all Enum structures which have auxiliary data
    from 32-bit format to 16-bit format. As many complete entries as
    possible are copied, then possibly some incomplete entries.
    All pointer fields are converted to offsets so that this buffer
    may be returned directly to the requesting client.

    Enum buffers with auxiliary data have one or more auxiliary
    structures, with possible variable data, after each entry.

Arguments:

    InBuffer - a pointer to the input information in 32-bit format.

    NumberOfEntries - the count of fixed structures in the input buffer.

    InStructureDesc - description of the input fixed structure.

    InAuxStructureDesc - description of the input auxiliary structure.

    OutBuffer - a pointer to where to write the 16-bit buffer.

    OutBufferStart - a pointer to the actual start of the 16-bit buffer.
        Used to calculate offsets for all pointers in structures.

    OutBufferLength - length of the output buffer.

    OutStructureDesc - description of the output fixed structure.

    OutAuxStructureDesc - description of the output fixed structure.

    VerifyFunction - a pointer to a function which is be called after
        each enum record is converted in order to determine whether
        the record should be retained or discarded.  The function
        is passed the return code from RapConvertSingleEntry and
        a pointer to the converted entry.  It must return NERR_SUCCESS
        if the entry is to be retained, or any error code if the entry
        is to be discarded.  If no function is supplied, a default function
        is used, which discards an entry only if RapConvertSingleEntry
        returned an error trying to convert it.

    BytesRequired - a pointer to a DWORD to receive the total number of
        bytes that would be required to hold the entire output buffer.

    EntriesFilled - a pointer to a DWORD to receive the total number of
        entries that could be put in the buffer given.

    InvalidEntries - an optional pointer to a DWORD to receive the total
        number of entries discarded by the verify function. If NULL, this
        value will be not be available to the caller.

Return Value:

    None.

--*/

{

    NET_API_STATUS status;
    DWORD currentEntry;
    LPBYTE currentInEntryPtr;
    LPBYTE currentOutEntryPtr;
    LPBYTE outputStringLocation;
    LPBYTE oldStringLocation;
    DWORD inputStructureSize;
    DWORD inputAuxStructureSize;
    DWORD outputStructureSize;
    DWORD outputAuxStructureSize;
    DWORD inputAuxCount;
    DWORD currentAux;
    DWORD outputAuxOffset;
    DWORD newBytesRequired;
    DWORD auxBytesRequired;
    DWORD remainingSize;
    DWORD invalidEntries = 0;

    //
    // In degenerate case, just call FillEnumBuffer.
    //

    if ( InAuxStructureDesc == NULL || OutAuxStructureDesc == NULL ) {

        XsFillEnumBuffer (
            InBuffer,
            NumberOfEntries,
            InStructureDesc,
            OutBuffer,
            OutBufferStart,
            OutBufferLength,
            OutStructureDesc,
            VerifyFunction,
            BytesRequired,
            EntriesFilled,
            InvalidEntries
            );

        return;
    }

    if ( VerifyFunction == NULL ) {
        VerifyFunction = &XsDefaultEnumVerifyFunction;
    }

    //
    // Set up sizes of input and output structures.
    //

    inputStructureSize = RapStructureSize( InStructureDesc, Response, TRUE );
    inputAuxStructureSize
        = RapStructureSize( InAuxStructureDesc, Response, TRUE );
    outputStructureSize = RapStructureSize( OutStructureDesc, Response, FALSE );
    outputAuxStructureSize
        = RapStructureSize( OutAuxStructureDesc, Response, FALSE );
    outputAuxOffset = RapAuxDataCountOffset( InStructureDesc, Response, TRUE );

    outputStringLocation = (LPBYTE)OutBuffer + OutBufferLength;
    *BytesRequired = 0;

    //
    // Check if one fixed entry will fit.
    //

    if ( inputStructureSize > OutBufferLength ) {

        *EntriesFilled = 0;
        goto cleanup;
    }

    //
    // Loop through the entries, converting along the way.
    //

    currentInEntryPtr = InBuffer;
    currentOutEntryPtr = OutBuffer;
    *EntriesFilled = 0;

    for ( currentEntry = 0; currentEntry < NumberOfEntries; currentEntry++ ) {

        //
        // If there wasn't enough room for the conversion, we can quit now.
        //

        if ( currentOutEntryPtr + outputStructureSize > outputStringLocation ) {

            break;
        }

        newBytesRequired = *BytesRequired;
        oldStringLocation = outputStringLocation;

        //
        // Get the auxiliary number count.
        //

        inputAuxCount = RapAuxDataCount(
                            currentInEntryPtr,
                            InStructureDesc,
                            Response,
                            TRUE
                            );

        NetpAssert( inputAuxCount != NO_AUX_DATA );

        //
        // Convert the fixed entry.
        //

        status = RapConvertSingleEntry(
                     currentInEntryPtr,
                     InStructureDesc,
                     FALSE,
                     OutBufferStart,
                     currentOutEntryPtr,
                     OutStructureDesc,
                     TRUE,
                     &outputStringLocation,
                     &newBytesRequired,
                     Response,
                     NativeToRap
                     );

        //
        // Check if the entry is valid. If it is not, fix up pointers,
        // and start with the next entry in the list.
        // If there are more than 65536 auxiliary structures (which
        // probably never happens anyway), this entry is automatically
        // invalid.
        //


        status = (*VerifyFunction)(
                     status,
                     currentOutEntryPtr,
                     OutBufferStart
                     );

        if ( status != NERR_Success || inputAuxCount > 0xFFFF ) {

            invalidEntries++;
            currentInEntryPtr += inputStructureSize
                                     + inputAuxCount * inputAuxStructureSize;
            outputStringLocation = oldStringLocation;
            continue;

        }

        //
        // Prepare pointers for converting the auxiliary structures.
        //

        currentInEntryPtr += inputStructureSize;
        currentOutEntryPtr += outputStructureSize;

        //
        // Try to add the auxiliary structures.
        //

        for ( currentAux = 0; currentAux < inputAuxCount; currentAux++ ) {

            remainingSize = (DWORD)(outputStringLocation - currentOutEntryPtr);
            auxBytesRequired = 0;

            status = RapConvertSingleEntry(
                         currentInEntryPtr,
                         InAuxStructureDesc,
                         FALSE,
                         OutBufferStart,
                         currentOutEntryPtr,
                         OutAuxStructureDesc,
                         TRUE,
                         &outputStringLocation,
                         &auxBytesRequired,
                         Response,
                         NativeToRap
                         );

            //
            // Did this aux. entry fit? If all the aux. entries do not fit,
            // we are going to play it safe and say the main entry did not
            // fit.
            //

            if ( status != NERR_Success || auxBytesRequired > remainingSize ) {
                goto cleanup;
            }

            currentInEntryPtr += inputAuxStructureSize;
            currentOutEntryPtr += outputAuxStructureSize;
            newBytesRequired += auxBytesRequired;
        }

        *BytesRequired = newBytesRequired;
        *EntriesFilled += 1;
    }

cleanup:

    if ( InvalidEntries != NULL ) {

        *InvalidEntries = invalidEntries;

    }

    return;

} // XsFillAuxEnumBuffer


VOID
XsFillEnumBuffer (
    IN LPBYTE InBuffer,
    IN DWORD NumberOfEntries,
    IN LPDESC InStructureDesc,
    IN OUT LPBYTE OutBuffer,
    IN LPBYTE OutBufferStart,
    IN DWORD OutBufferLength,
    IN LPDESC OutStructureDesc,
    IN PXACTSRV_ENUM_VERIFY_FUNCTION VerifyFunction OPTIONAL,
    OUT LPDWORD BytesRequired,
    OUT LPDWORD EntriesFilled,
    OUT LPDWORD InvalidEntries OPTIONAL
    )

/*++

Routine Description:

    This routine copies all Enum structures from 32-bit format to
    16-bit format.  As many complete entries as possible are copied,
    then possibly some incomplete entries.  All pointer fields
    are converted to offsets so that this buffer may be returned
    directly to the requesting client.

Arguments:

    InBuffer - a pointer to the input information in 32-bit format.

    NumberOfEntries - the count of fixed structures in the input buffer.

    InStructureDesc - description of the input fixed structure.

    OutBuffer - a pointer to where to write the 16-bit buffer.

    OutBufferStart - a pointer to the actual start of the 16-bit buffer.
        Used to calculate offsets for all pointers in structures.

    OutBufferLength - length of the output buffer.

    OutStructureDesc - description of the output fixed structure.

    VerifyFunction - a pointer to a function which is be called after
        each enum record is converted in order to determine whether
        the record should be retained or discarded.  The function
        is passed the return code from RapConvertSingleEntry and
        a pointer to the converted entry.  It must return NERR_SUCCESS
        if the entry is to be retained, or any error code if the entry
        is to be discarded.  If no function is supplied, a default function
        is used, which discards an entry only if RapConvertSingleEntry
        returned an error trying to convert it.

    BytesRequired - a pointer to a DWORD to receive the total number of
        bytes that would be required to hold the entire output buffer.

    EntriesFilled - a pointer to a DWORD to receive the total number of
        entries that could be put in the buffer given.

    InvalidEntries - an optional pointer to a DWORD to receive the total
        number of entries discarded by the verify function. If NULL, this
        value will be not be available to the caller.

Return Value:

    None.

--*/

{
    NET_API_STATUS status;
    DWORD currentEntry;
    LPBYTE currentInEntryPtr;
    LPBYTE currentOutEntryPtr;
    LPBYTE outputStringLocation;
    LPBYTE oldStringLocation;
    DWORD inputStructureSize;
    DWORD outputStructureSize;
    DWORD newBytesRequired;
    DWORD invalidEntries = 0;

    if ( VerifyFunction == NULL ) {
        VerifyFunction = &XsDefaultEnumVerifyFunction;
    }

    //
    // Set up sizes of input and output structures.
    //

    inputStructureSize = RapStructureSize( InStructureDesc, Response, TRUE );
    outputStructureSize = RapStructureSize( OutStructureDesc, Response, FALSE );

    outputStringLocation = (LPBYTE)OutBuffer + OutBufferLength;
    *BytesRequired = 0;

    //
    // Check if one fixed entry will fit.
    //

    if ( inputStructureSize > OutBufferLength ) {

        *EntriesFilled = 0;
        goto cleanup;
    }

    //
    // Loop through the entries, converting along the way.
    //

    currentInEntryPtr = InBuffer;
    currentOutEntryPtr = OutBuffer;
    *EntriesFilled = 0;

    for ( currentEntry = 0; currentEntry < NumberOfEntries; currentEntry++ ) {

        //
        // If there wasn't enough room for the conversion, we can quit now.
        //

        if ( currentOutEntryPtr + outputStructureSize > outputStringLocation ) {

            break;
        }

        newBytesRequired = *BytesRequired;
        oldStringLocation = outputStringLocation;

        status = RapConvertSingleEntry(
                     currentInEntryPtr,
                     InStructureDesc,
                     FALSE,
                     OutBufferStart,
                     currentOutEntryPtr,
                     OutStructureDesc,
                     TRUE,
                     &outputStringLocation,
                     &newBytesRequired,
                     Response,
                     NativeToRap
                     );

        //
        // If the conversion was successful, increment the buffer pointers,
        // the count of bytes required, and the number of converted entries.
        //

        status = (*VerifyFunction)(
                     status,
                     currentOutEntryPtr,
                     OutBufferStart
                     );

        if ( status == NERR_Success ) {

            currentInEntryPtr += inputStructureSize;
            currentOutEntryPtr += outputStructureSize;
            *BytesRequired = newBytesRequired;
            *EntriesFilled += 1;

        } else {

            invalidEntries++;
            currentInEntryPtr += inputStructureSize;
            outputStringLocation = oldStringLocation;

        }

    }

cleanup:

    if ( InvalidEntries != NULL ) {

        *InvalidEntries = invalidEntries;

    }

    return;

} // XsFillEnumBuffer


LPBYTE
XsFindParameters (
    IN LPTRANSACTION Transaction
    )

/*++

Routine Description:

    This routine finds the start of the parameters section in the
    transaction block of a remote down-level API request.

Arguments:

    Transaction - a pointer to a transaction block containing information
        about the API to process.

Return Value:

    None.

--*/

{
    LPBYTE s;

    //
    // Skip over the API number and parameters description string.
    //

    for ( s = Transaction->InParameters + 2; *s != '\0'; s++ );

    //
    // Skip over the zero terminator and the data description string.
    //

    for ( s++; *s != '\0'; s++ );

    //
    // Return a pointer to the location after the zero terminator.
    //

    return s + 1;

} // XsFindParameters


WORD
XsPackReturnData (
    IN LPVOID Buffer,
    IN WORD BufferLength,
    IN LPDESC Descriptor,
    IN DWORD EntriesRead
    )

/*++

Routine Description:

    This routine, called by get info and enum API handlers, packs the
    output data so that no unused data is returned to the client.  This
    is necessary because buffers are filled with variable-length data
    starting at the end, thereby leaving potentially large gaps of
    unused space between the end of fixed structures and the beginning
    of variable-length data.

Arguments:

    Buffer - a pointer to the buffer to pack.

    BufferLength - the length of this buffer.

    Descriptor - a pointer to a string which describes the fixed structures
        in the buffer.

    EntriesRead - the count of fixed structures in the buffer.

Return Value:

    WORD - the "converter word" which informs the client how much
        to adjust pointers in the fixed structures so that they are
        meaningful.

--*/

{
    DWORD structureSize;
    LPBYTE lastFixedStructure;
    LPBYTE endOfFixedStructures;
    DWORD lastPointerOffset;
    DWORD beginningOfVariableData;

    //
    // If there is no data, return immediately.
    //

    if ( EntriesRead == 0 ) {

        return 0;
    }

    //
    // Find the size of a single fixed-length structure.
    //

    structureSize = RapStructureSize( Descriptor, Response, FALSE );

    //
    // Use this and the number of entries to find the location of the
    // last fixed structure and where the fixed structures end.
    //

    endOfFixedStructures = (LPBYTE)Buffer + EntriesRead * structureSize;
    lastFixedStructure = endOfFixedStructures - structureSize;

    //
    // Find the offset into the fixed structure of the last pointer
    // to variable data.  The value stored at this offset in the last
    // structure is the offset to the first variable data.
    //

    lastPointerOffset = RapLastPointerOffset( Descriptor, Response, FALSE );

    //
    // If there are no pointers, there is obviously no data to pack.
    //

    if ( lastPointerOffset == NO_POINTER_IN_STRUCTURE ) {

        return 0;
    }

    beginningOfVariableData =
        SmbGetUlong( (LPDWORD)(lastFixedStructure + lastPointerOffset) );

    //
    // If this offset is NULL, then the data overflowed, hence the buffer
    // is nearly full.  Don't do any packing.
    //
    // Also, if the gap is less than MAXIMUM_ALLOWABLE_DATA_GAP then it
    // isn't worth doing the packing because of the time involved in
    // the data copy.
    //

    if ( beginningOfVariableData == (DWORD)0 ||
         (DWORD_PTR)Buffer + beginningOfVariableData -
             (DWORD_PTR)endOfFixedStructures <= MAXIMUM_ALLOWABLE_DATA_GAP ) {

        return 0;
    }

    //
    // Move the variable data up to follow the fixed structures.
    //

    RtlMoveMemory(
        endOfFixedStructures,
        (LPBYTE)Buffer + beginningOfVariableData,
        BufferLength - beginningOfVariableData
        );

    //
    // Return the distance we moved the variable data.
    //

    return (WORD)( (DWORD_PTR)Buffer + beginningOfVariableData -
                         (DWORD_PTR)endOfFixedStructures );

} // XsPackReturnData


VOID
XsSetDataCount(
    IN OUT LPWORD DataCount,
    IN LPDESC Descriptor,
    IN WORD Converter,
    IN DWORD EntriesRead,
    IN WORD ReturnStatus
    )

/*++

Routine Description:

    This routine calculates the return data count based on a number
    of characteristics of the return data. This routine will examine
    the buffer size, the number of entries placed in the buffer,
    whether the data was packed, and what the return code was to
    determine the return data size. The following assumptions are made
    about the data: only calls with ReturnCode = NERR_Success or
    ERROR_MORE_DATA return any data to the client; and if there is
    no pointer in the fixed entries, then there is no variable data.
    Handlers which cannot assure these two assumptions must determine
    the data count manually.

Arguments:

    DataCount - a pointer to a short word indicating the maximum
        return data count (usually the BufLen parameter). On return,
        this word will hold the actual return data count.

    Descriptor - a string describing the structure of the fixed
        entries in the buffer.

    Converter - The adjustment value for pointers in data. A non-zero
        value indicates data in the buffer is packed.

    EntriesRead - Number of entries placed in the buffer. Used to
        determine data count for buffers with no variable data.

    ReturnStatus - Return status of the API call, as it will be returned
        to the client (in other words, converted to a WORD).

Return Value:

    None.

--*/

{

    if (( ReturnStatus != NERR_Success )
              && ( ReturnStatus != ERROR_MORE_DATA)) {

        //
        // If the return status is not NERR_Success or ERROR_MORE_DATA, then
        // the return data count is 0.

        SmbPutUshort( DataCount, 0 );
        return;

    }

    if ( RapLastPointerOffset( Descriptor, Response, FALSE )
             == NO_POINTER_IN_STRUCTURE ) {

        //
        // If there is no variable data, the return data count is the size
        // of the fixed structures.

        SmbPutUshort( DataCount,
                      (WORD)(RapStructureSize( Descriptor, Response, FALSE )
                                   * EntriesRead ));
        return;

    }

    SmbPutUshort( DataCount, SmbGetUshort( DataCount ) - Converter );

    return;

} // XsSetDataCount


VOID
XsSetParameters (
    IN LPTRANSACTION Transaction,
    IN LPXS_PARAMETER_HEADER Header,
    IN LPVOID Parameters
    )

/*++

Routine Description:

    This routine takes parameters from the structure allocated by
    XsCaptureParameters and uses the descriptor string to place them in
    the correct format in the transaction block.  It also frees the
    buffer holding the parameter structure.

Arguments:

    Transaction - a pointer to the transaction block describing the
        request.

    Header - a pointer to the parameter header, which contains information
        from the API handler such as the converter word and return status.

    Parameters - a pointer to the parameter structure.


Return Value:

    None.

--*/

{
    LPBYTE inParams = Parameters;
    LPBYTE outParams = Transaction->OutParameters;
    LPDESC descriptorString;
    LPDESC descriptor;
    LPBYTE outParamsMax = outParams + Transaction->MaxParameterCount;

    //
    // The first two bytes of the parameter section are the API number,
    // then comes the descriptor string.
    //

    descriptorString = Transaction->InParameters + 2;

    //
    // Set up the first part of the output parameters from the parameter
    // header.
    //

    if( outParams + sizeof(WORD) > outParamsMax ) goto insuff_buffer;
    SmbPutUshort( (LPWORD)outParams, Header->Status );
    outParams += sizeof(WORD);

    if( outParams + sizeof(WORD) > outParamsMax ) goto insuff_buffer;
    SmbPutUshort( (LPWORD)outParams, Header->Converter );
    outParams += sizeof(WORD);

    //
    // Initially set the size of the return data to 0. If there is a
    // receive buffer for this call, the API handler has changed the
    // buffer length parameter to the count of data returned, which
    // will be transferred to the DataCount variable later.
    //

    Transaction->DataCount = 0;

    //
    // Walk through the descriptor string, converting from the total
    // parameter set to the smaller set passed back to the client.  In
    // general, only information the client does not already know is
    // passed back as parameters.
    //

    for ( descriptor = descriptorString; *descriptor != '\0'; ) {

        switch ( *descriptor++ ) {

        case REM_ASCIZ:
        case REM_NULL_PTR:

            //
            // !!! Parameter string descriptors may not have maximum length
            //     counts.
            //

            NetpAssert( !isdigit( *descriptor ));

            //
            // The parameter is a pointer to a string, which is
            // not returned to the client.
            //

            inParams += sizeof(LPSTR);

            break;

        case REM_BYTE_PTR:
        case REM_FILL_BYTES:

            //
            // Array of bytes, doesn't get sent back.
            //

            //
            // Skip over any numeric characters in descriptor.
            //

            RapAsciiToDecimal( &descriptor );

            inParams += sizeof(LPBYTE);

            break;

        case REM_DWORD:

            //
            // The parameter is a input word not returned to the client.
            //
            // !!! This assumes that an array of dwords will never be passed
            //     as a parameter.

            NetpAssert( !isdigit( *descriptor ));

            inParams += sizeof(DWORD);

            break;

        case REM_ENTRIES_READ:
        case REM_RCV_WORD_PTR:

            //
            // Count of entries read (e) or receive word pointer (h).
            // This is an output parameter, so copy over the word.
            //

            if( outParams + sizeof(WORD) > outParamsMax ) goto insuff_buffer;

            SmbPutUshort(
                (LPWORD)outParams,
                SmbGetUshort( (LPWORD)inParams )
                );

            inParams += sizeof(WORD);
            outParams += sizeof(WORD);

            break;

        case REM_RCV_DWORD_PTR:

            //
            // Count of receive dword pointer (h).
            // This is an output parameter, so copy over the word.
            //

            if( outParams + sizeof(DWORD) > outParamsMax ) goto insuff_buffer;

            SmbPutUlong(
                (LPDWORD)outParams,
                SmbGetUlong( (LPDWORD)inParams )
                );

            inParams += sizeof(DWORD);
            outParams += sizeof(DWORD);

            break;

        case REM_RCV_BUF_LEN:

            //
            // The length of the receive buffer (r).  The parameter is not
            // returned to the client, but it is used to set the return
            // data count.
            //

            Transaction->DataCount = (DWORD)SmbGetUshort( (LPWORD)inParams );
            inParams += sizeof(WORD);

            break;

        case REM_RCV_BUF_PTR:
        case REM_SEND_BUF_PTR:

            //
            // A pointer to a data buffer.  This is not returned to the
            // client.
            //

            inParams += sizeof(LPBYTE);

            break;

        case REM_RCV_BYTE_PTR: {

            //
            // The parameter indicates return bytes.
            //

            DWORD arraySize;

            arraySize = sizeof(BYTE) * RapDescArrayLength( descriptor );

            if( outParams + arraySize > outParamsMax ) goto insuff_buffer;

            RtlCopyMemory( outParams, inParams, arraySize );

            outParams += arraySize;
            inParams += arraySize;

            break;

        }

        case REM_SEND_BUF_LEN:
        case REM_WORD:
        case REM_PARMNUM:

            //
            // The parameter is a input word not returned to the client.
            //
            // !!! This assumes that an array of words will never be passed
            //     as a parameter.

            NetpAssert( !isdigit( *descriptor ));

            inParams += sizeof(WORD);

            break;

        default:

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsSetParameters: unsupported character at %lx: %c\n",
                                descriptor - 1, *( descriptor - 1 )));
                NetpBreakPoint( );
            }
        }
    }

    //
    // Indicate the number of response parameter bytes.
    //

    Transaction->ParameterCount =
        (DWORD)((DWORD_PTR)outParams - (DWORD_PTR)(Transaction->OutParameters) );

    //
    // Free the parameter buffer allocated by XsCaptureParameters.
    //

    NetpMemoryFree( Header );

    return;

insuff_buffer:
    Header->Status = NERR_BufTooSmall;
    return;

} // XsSetParameters


NET_API_STATUS
XsValidateShareName(
    IN LPSTR ShareName
)

/*++

Routine Description:

    This routine determines whether the supplied string is a valid share
    name of the format \\computer\share, with both computer name and
    share name no longer than permitted by LanMan 2.0.  It does not
    attempt to determine whether the share actually exists.

Arguments:

    ShareName - The share name to be validated (an ASCII string)

Return Value:

    NET_API_STATUS - NERR_Success if the share name is valid,
                     ERROR_INVALID_PARAMETER otherwise.

--*/

{
    DWORD componentLength;
    NET_API_STATUS status = NERR_Success;

    if ( ShareName == NULL ) {           // NULL is OK
        return NERR_Success;
    }

    componentLength = 0;
    while ( *ShareName == '\\' ) {
        componentLength++;
        ShareName++;
    }

    if ( componentLength != 2 ) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    componentLength = 0;
    while (( *ShareName != '\\' ) && ( *ShareName != '\0' )) {
        componentLength++;
        ShareName++;
    }

    if (( *ShareName == '\0' ) ||
            ( componentLength < 1 ) || ( componentLength > MAX_PATH )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    componentLength = 0;
    while ( *ShareName == '\\' ) {
        componentLength++;
        ShareName++;
    }

    if ( componentLength != 1 ) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    componentLength = 0;
    while (( *ShareName != '\\' ) && ( *ShareName != '\0' )) {
        componentLength++;
        ShareName++;
    }

    if (( *ShareName == '\\' ) ||
            ( componentLength < 1 ) || ( componentLength > MAX_PATH )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

cleanup:

    return status;
}

VOID
SmbCapturePtr(
    LPBYTE  PointerDestination,
    LPBYTE  PointerValue
    )

/*++

Routine Description:

    This routine captures a pointer from the supplied buffer and places it
    into the destination buffer.

Arguments:

    PointerDestination - A pointer to the pointer value destination.

    PointerSource - A pointer to the pointer value source.

Return Value:

    None.

--*/

{
    XsSmbPutPointer( PointerDestination, PointerValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\event\dummy.c ===
void
DummyEntryPoint(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nlrepl\nlrepl.c ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    nlrepl.c

Abstract:

    The database replication functions called either from LSA OR SAM.
    The actual code resides in netlogon.dll.

Author:

    Madan Appiah (Madana)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-Apr-1992 (madana)
        Created.

--*/

#include <nt.h>         // needed for NTSTATUS
#include <ntrtl.h>      // needed for nturtl.h
#include <nturtl.h>     // needed for windows.h
#include <windows.h>    // win32 typedefs

#include <crypt.h>      // samsrv.h will need this
#include <ntlsa.h>      // needed for POLICY_LSA_SERVER_ROLE
#include <samrpc.h>
#include <samisrv.h>    // needed for SECURITY_DB_TYPE etc.
#include <winsock2.h>   // needed for SOCKET defn's
#include <nlrepl.h>     // proto types

typedef NTSTATUS
            (*PI_NetNotifyDelta) (
                IN SECURITY_DB_TYPE DbType,
                IN LARGE_INTEGER ModificationCount,
                IN SECURITY_DB_DELTA_TYPE DeltaType,
                IN SECURITY_DB_OBJECT_TYPE ObjectType,
                IN ULONG ObjectRid,
                IN PSID ObjectSid,
                IN PUNICODE_STRING ObjectName,
                IN DWORD ReplicationImmediately,
                IN PSAM_DELTA_DATA MemberId
            );


typedef NTSTATUS
            (*PI_NetNotifyRole) (
                IN POLICY_LSA_SERVER_ROLE Role
            );

typedef NTSTATUS
            (*PI_NetNotifyMachineAccount) (
                IN ULONG ObjectRid,
                IN PSID DomainSid,
                IN ULONG OldUserAccountControl,
                IN ULONG NewUserAccountControl,
                IN PUNICODE_STRING ObjectName
            );

typedef NTSTATUS
            (*PI_NetNotifyTrustedDomain) (
                IN PSID HostedDomainSid,
                IN PSID TrustedDomainSid,
                IN BOOLEAN IsDeletion
            );

typedef NTSTATUS
            (*PI_NetNotifyNetlogonDllHandle) (
                IN PHANDLE Role
            );

typedef NTSTATUS
    (*PI_NetLogonSetServiceBits)(
        IN DWORD ServiceBitsOfInterest,
        IN DWORD ServiceBits
    );

typedef NTSTATUS
    (*PI_NetLogonGetSerialNumber) (
    IN SECURITY_DB_TYPE DbType,
    IN PSID DomainSid,
    OUT PLARGE_INTEGER SerialNumber
    );

typedef NTSTATUS
    (*PI_NetLogonLdapLookupEx)(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    );

typedef VOID
    (*PI_NetLogonFree)(
    IN PVOID Buffer
    );

typedef NET_API_STATUS
    (*PI_DsGetDcCache)(
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    OUT PBOOLEAN InNt4Domain,
    OUT LPDWORD InNt4DomainTime
    );

typedef NET_API_STATUS
    (*PDsrGetDcNameEx2)(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPCWSTR AccountName OPTIONAL,
        IN ULONG AllowableAccountControlBits,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
        );

typedef NTSTATUS
(*PI_NetNotifyDsChange)(
    IN NL_DS_CHANGE_TYPE DsChangeType
    );

typedef NTSTATUS
(*PI_NetLogonReadChangeLog)(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    );

typedef NTSTATUS
(*PI_NetLogonNewChangeLog)(
    OUT HANDLE *ChangeLogHandle
    );

typedef NTSTATUS
(*PI_NetLogonAppendChangeLog)(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    );

typedef NTSTATUS
(*PI_NetLogonCloseChangeLog)(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    );

typedef NTSTATUS
(*PI_NetLogonSendToSamOnPdc)(
    IN LPWSTR DomainName,
    IN LPBYTE OpaqueBuffer,
    IN ULONG OpaqueBufferSize
    );

typedef NET_API_STATUS
(*PI_NetLogonGetIpAddresses)(
    OUT PULONG IpAddressCount,
    OUT LPBYTE *IpAddresses
    );

typedef NTSTATUS
(*PI_NetLogonGetAuthDataEx)(
    IN LPWSTR HostedDomainName OPTIONAL,
    IN LPWSTR TrustedDomainName,
    IN ULONG Flags,
    IN PLARGE_INTEGER FailedSessionSetupTime OPTIONAL,
    OUT LPWSTR *OurClientPrincipleName,
    OUT PVOID *ClientContext OPTIONAL,
    OUT LPWSTR *ServerName,
    OUT PNL_OS_VERSION ServerOsVersion,
    OUT PULONG AuthnLevel,
    OUT PLARGE_INTEGER SessionSetupTime
    );

typedef NTSTATUS
(*PI_NetNotifyNtdsDsaDeletion) (
    IN LPWSTR DnsDomainName,
    IN GUID *DomainGuid,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    );

typedef NET_API_STATUS
(*PI_NetLogonAddressToSiteName)(
    IN PSOCKET_ADDRESS SocketAddress,
    OUT LPWSTR *SiteName
    );

//
// Global status
//

HANDLE NetlogonDllHandle = NULL;
PI_NetNotifyDelta pI_NetNotifyDelta = NULL;
PI_NetNotifyRole pI_NetNotifyRole = NULL;
PI_NetNotifyMachineAccount pI_NetNotifyMachineAccount = NULL;
PI_NetNotifyTrustedDomain pI_NetNotifyTrustedDomain = NULL;
PI_NetLogonSetServiceBits pI_NetLogonSetServiceBits = NULL;
PI_NetLogonGetSerialNumber pI_NetLogonGetSerialNumber = NULL;
PI_NetLogonLdapLookupEx pI_NetLogonLdapLookupEx = NULL;
PI_NetLogonFree pI_NetLogonFree = NULL;
PI_DsGetDcCache pI_DsGetDcCache = NULL;
PDsrGetDcNameEx2 pDsrGetDcNameEx2 = NULL;
PI_NetNotifyDsChange pI_NetNotifyDsChange = NULL;
PI_NetLogonReadChangeLog pI_NetLogonReadChangeLog = NULL;
PI_NetLogonNewChangeLog pI_NetLogonNewChangeLog = NULL;
PI_NetLogonAppendChangeLog pI_NetLogonAppendChangeLog = NULL;
PI_NetLogonCloseChangeLog pI_NetLogonCloseChangeLog = NULL;
PI_NetLogonSendToSamOnPdc pI_NetLogonSendToSamOnPdc = NULL;
PI_NetLogonGetIpAddresses pI_NetLogonGetIpAddresses = NULL;
PI_NetLogonGetAuthDataEx pI_NetLogonGetAuthDataEx = NULL;
PI_NetNotifyNtdsDsaDeletion pI_NetNotifyNtdsDsaDeletion = NULL;
PI_NetLogonAddressToSiteName pI_NetLogonAddressToSiteName = NULL;


NTSTATUS
NlLoadNetlogonDll(
    VOID
    )
/*++

Routine Description:

    This function loads the netlogon.dll module if it is not loaded
    already. If the network is not installed then netlogon.dll will not
    present in the system and the LoadLibrary will fail.

Arguments:

    None

Return Value:

    NT Status code.

--*/
{
    static NTSTATUS DllLoadStatus = STATUS_SUCCESS;
    PI_NetNotifyNetlogonDllHandle pI_NetNotifyNetlogonDllHandle = NULL;
    HANDLE DllHandle = NULL;


    //
    // If we've tried to load the DLL before and it failed,
    //  return the same error code again.
    //

    if( DllLoadStatus != STATUS_SUCCESS ) {
        goto Cleanup;
    }


    //
    // Load netlogon.dll
    //

    DllHandle = LoadLibraryA( "Netlogon" );

    if ( DllHandle == NULL ) {

#if DBG
        DWORD DbgError;

        DbgError = GetLastError();

        DbgPrint("[Security Process] can't load netlogon.dll %d \n",
            DbgError);
#endif // DBG

        DllLoadStatus = STATUS_DLL_NOT_FOUND;

        goto Cleanup;
    }

//
// Macro to grab the address of the named procedure from netlogon.dll
//

#if DBG
#define GRAB_ADDRESS( _X ) \
    p##_X = (P##_X) GetProcAddress( DllHandle, #_X ); \
    \
    if ( p##_X == NULL ) { \
        DbgPrint("[security process] can't load " #_X " procedure. %ld\n", GetLastError()); \
        DllLoadStatus = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

#else // DBG
#define GRAB_ADDRESS( _X ) \
    p##_X = (P##_X) GetProcAddress( DllHandle, #_X ); \
    \
    if ( p##_X == NULL ) { \
        DllLoadStatus = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

#endif // DBG


    //
    // Get the addresses of the required procedures.
    //

    GRAB_ADDRESS( I_NetNotifyDelta );
    GRAB_ADDRESS( I_NetNotifyRole );
    GRAB_ADDRESS( I_NetNotifyMachineAccount );
    GRAB_ADDRESS( I_NetNotifyTrustedDomain );
    GRAB_ADDRESS( I_NetLogonSetServiceBits );
    GRAB_ADDRESS( I_NetLogonGetSerialNumber );
    GRAB_ADDRESS( I_NetLogonLdapLookupEx );
    GRAB_ADDRESS( I_NetLogonFree );
    GRAB_ADDRESS( I_DsGetDcCache );
    GRAB_ADDRESS( DsrGetDcNameEx2 );
    GRAB_ADDRESS( I_NetNotifyDsChange );
    GRAB_ADDRESS( I_NetLogonReadChangeLog );
    GRAB_ADDRESS( I_NetLogonNewChangeLog );
    GRAB_ADDRESS( I_NetLogonAppendChangeLog );
    GRAB_ADDRESS( I_NetLogonCloseChangeLog );
    GRAB_ADDRESS( I_NetLogonSendToSamOnPdc );
    GRAB_ADDRESS( I_NetLogonGetIpAddresses );
    GRAB_ADDRESS( I_NetLogonGetAuthDataEx );
    GRAB_ADDRESS( I_NetNotifyNtdsDsaDeletion );
    GRAB_ADDRESS( I_NetLogonAddressToSiteName );

    //
    // Find the address of the I_NetNotifyNetlogonDllHandle procedure.
    //  This is an optional procedure so don't complain if it isn't there.
    //

    pI_NetNotifyNetlogonDllHandle = (PI_NetNotifyNetlogonDllHandle)
        GetProcAddress( DllHandle, "I_NetNotifyNetlogonDllHandle" );



    DllLoadStatus = STATUS_SUCCESS;

Cleanup:
    if (DllLoadStatus == STATUS_SUCCESS) {
        NetlogonDllHandle = DllHandle;

        //
        // Notify Netlogon that we've loaded it.
        //

        if( pI_NetNotifyNetlogonDllHandle != NULL ) {
            (VOID) (*pI_NetNotifyNetlogonDllHandle)( &NetlogonDllHandle );
        }

    } else {
        if ( DllHandle != NULL ) {
            FreeLibrary( DllHandle );
        }
    }
    return( DllLoadStatus );
}


NTSTATUS
I_NetNotifyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN LARGE_INTEGER ModificationCount,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicationImmediately,
    IN PSAM_DELTA_DATA MemberId
    )
/*++

Routine Description:

    This function is called by the SAM and LSA services after each
    change is made to the SAM and LSA databases.  The services describe
    the type of object that is modified, the type of modification made
    on the object, the serial number of this modification etc.  This
    information is stored for later retrieval when a BDC or member
    server wants a copy of this change.  See the description of
    I_NetSamDeltas for a description of how the change log is used.

    Add a change log entry to circular change log maintained in cache as
    well as on the disk and update the head and tail pointers

    It is assumed that Tail points to a block where this new change log
    entry may be stored.

    NOTE: The actual code is in netlogon.dll. This wrapper function
    will determine whether the network is installed, if so, it calls the
    actual worker function after loading the netlogon.dll module. If the
    network is not installed then this will function will return with
    appropriate error code.

Arguments:

    DbType - Type of the database that has been modified.

    ModificationCount - The value of the DomainModifiedCount field for the
        domain following the modification.

    DeltaType - The type of modification that has been made on the object.

    ObjectType - The type of object that has been modified.

    ObjectRid - The relative ID of the object that has been modified.
        This parameter is valid only when the object type specified is
        either SecurityDbObjectSamUser, SecurityDbObjectSamGroup or
        SecurityDbObjectSamAlias otherwise this parameter is set to zero.

    ObjectSid - The SID of the object that has been modified.  If the object
        modified is in a SAM database, ObjectSid is the DomainId of the Domain
        containing the object.

    ObjectName - The name of the secret object when the object type
        specified is SecurityDbObjectLsaSecret or the old name of the object
        when the object type specified is either SecurityDbObjectSamUser,
        SecurityDbObjectSamGroup or SecurityDbObjectSamAlias and the delta
        type is SecurityDbRename otherwise this parameter is set to NULL.

    ReplicateImmediately - TRUE if the change should be immediately
        replicated to all BDCs.  A password change should set the flag
        TRUE.

    MemberId - This parameter is specified when group/alias membership
        is modified. This structure will then point to the member's ID that
        has been updated.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{

    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyDelta)(
                    DbType,
                    ModificationCount,
                    DeltaType,
                    ObjectType,
                    ObjectRid,
                    ObjectSid,
                    ObjectName,
                    ReplicationImmediately,
                    MemberId
                );

    return( STATUS_SUCCESS );

}


NTSTATUS
I_NetNotifyRole(
    IN POLICY_LSA_SERVER_ROLE Role
    )
/*++

Routine Description:

    This function is called by the LSA service upon LSA initialization
    and when LSA changes domain role.  This routine will initialize the
    change log cache if the role specified is PDC or delete the change
    log cache if the role specified is other than PDC.

    When this function initializing the change log if the change log
    currently exists on disk, the cache will be initialized from disk.
    LSA should treat errors from this routine as non-fatal.  LSA should
    log the errors so they may be corrected then continue
    initialization.  However, LSA should treat the system databases as
    read-only in this case.

    NOTE: The actual code is in netlogon.dll. This wrapper function
    will determine whether the network is installed, if so, it calls the
    actual worker function after loading the netlogon.dll module. If the
    network is not installed then this will function will return with
    appropriate error code.

Arguments:

    Role - Current role of the server.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{


    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyRole)(
                    Role
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyRole returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( STATUS_SUCCESS );

}


NTSTATUS
I_NetNotifyMachineAccount (
    IN ULONG ObjectRid,
    IN PSID DomainSid,
    IN ULONG OldUserAccountControl,
    IN ULONG NewUserAccountControl,
    IN PUNICODE_STRING ObjectName
    )
/*++

Routine Description:

    This function is called by the SAM to indicate that the account type
    of a machine account has changed.  Specifically, if
    USER_INTERDOMAIN_TRUST_ACCOUNT, USER_WORKSTATION_TRUST_ACCOUNT, or
    USER_SERVER_TRUST_ACCOUNT change for a particular account, this
    routine is called to let Netlogon know of the account change.

    NOTE: The actual code is in netlogon.dll. This wrapper function
    will determine whether the network is installed, if so, it calls the
    actual worker function after loading the netlogon.dll module. If the
    network is not installed then this will function will return with
    appropriate error code.

Arguments:

    ObjectRid - The relative ID of the object that has been modified.

    DomainSid - Specifies the SID of the Domain containing the object.

    OldUserAccountControl - Specifies the previous value of the
        UserAccountControl field of the user.

    NewUserAccountControl - Specifies the new (current) value of the
        UserAccountControl field of the user.

    ObjectName - The name of the account being changed.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyMachineAccount)(
                    ObjectRid,
                    DomainSid,
                    OldUserAccountControl,
                    NewUserAccountControl,
                    ObjectName );

#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyMachineAccount returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG

    return( NtStatus );
}


NTSTATUS
I_NetNotifyTrustedDomain (
    IN PSID HostedDomainSid,
    IN PSID TrustedDomainSid,
    IN BOOLEAN IsDeletion
    )
/*++

Routine Description:

    This function is called by the LSA to indicate that a trusted domain
    object has changed.

    This function is called for both PDC and BDC.

Arguments:

    HostedDomainSid - Domain SID of the domain the trust is from.

    TrustedDomainSid - Domain SID of the domain the trust is to.

    IsDeletion - TRUE if the trusted domain object was deleted.
        FALSE if the trusted domain object was created or modified.


Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyTrustedDomain)(
                    HostedDomainSid,
                    TrustedDomainSid,
                    IsDeletion );

#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyTrustedDomain returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG

    return( NtStatus );
}



NTSTATUS
I_NetLogonSetServiceBits(
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    )

/*++

Routine Description:

    Inidcates whether this DC is currently running the specified service.

    For instance,

        I_NetLogonSetServiceBits( DS_KDC_FLAG, DS_KDC_FLAG );

    tells Netlogon the KDC is running.  And

        I_NetLogonSetServiceBits( DS_KDC_FLAG, 0 );

    tells Netlogon the KDC is not running.

Arguments:

    ServiceBitsOfInterest - A mask of the service bits being changed, set,
        or reset by this call.  Only the following flags are valid:

            DS_KDC_FLAG
            DS_DS_FLAG
            DS_TIMESERV_FLAG

    ServiceBits - A mask indicating what the bits specified by ServiceBitsOfInterest
        should be set to.


Return Value:

    STATUS_SUCCESS - Success.

    STATUS_INVALID_PARAMETER - The parameters have extaneous bits set.

    STATUS_DLL_NOT_FOUND - Netlogon.dll could not be loaded.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonSetServiceBits)(
                    ServiceBitsOfInterest,
                    ServiceBits );

#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonSetServiceBits returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG

    return( NtStatus );
}


NTSTATUS
I_NetLogonGetSerialNumber (
    IN SECURITY_DB_TYPE DbType,
    IN PSID DomainSid,
    OUT PLARGE_INTEGER SerialNumber
    )
/*++

Routine Description:

    This function is called by the SAM and LSA services when they startup
    to get the current serial number written to the changelog.

Arguments:

    DbType - Type of the database that has been modified.

    DomainSid - For the SAM and builtin database, this specifies the DomainId of
        the domain whose serial number is to be returned.

    SerialNumber - Returns the latest set value of the DomainModifiedCount
        field for the domain.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_INVALID_DOMAIN_ROLE - This machine is not the PDC.

    STATUS_DLL_NOT_FOUND - Netlogon.dll could not be loaded.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonGetSerialNumber)(
                    DbType,
                    DomainSid,
                    SerialNumber );

#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonGetSerialNumber returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG

    return( NtStatus );
}

NTSTATUS
I_NetLogonLdapLookupEx(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    )

/*++

Routine Description:

    This routine builds a response to an LDAP ping of a DC.  DsGetDcName does
    such a ping to ensure the DC is functional and still meets the requirements
    of the DsGetDcName.  DsGetDcName does an LDAP lookup of the NULL DN asking
    for attribute "Netlogon".  The DS turns that into a call to this routine
    passing in the filter parameter.

Arguments:

    Filter - Filter describing the query.  The filter is built by the DsGetDcName
        client, so we can limit the flexibility significantly.  The filter is:

    SockAddr - Address of the client that sent the ping.

    Response - Returns a pointer to an allocated buffer containing
        the response to return to the caller.  This response is a binary blob
        which should be returned to the caller bit-for-bit intact.
        The buffer should be freed be calling I_NetLogonFree.

    ResponseSize - Size (in bytes) of the returned message.

Return Value:

    STATUS_SUCCESS -- The response was returned in the supplied buffer.

    STATUS_INVALID_PARAMETER -- The filter was invalid.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonLdapLookupEx)(
                    Filter,
                    SockAddr,
                    Response,
                    ResponseSize );

#ifdef notdef // Failures occur frequently in nature
#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonLdapLookupEx returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG
#endif // notdef

    return( NtStatus );

}

VOID
I_NetLogonFree(
    IN PVOID Buffer
    )

/*++

Routine Description:

    Free any buffer allocated by Netlogon and returned to an in-process caller.

Arguments:

    Buffer - Buffer to deallocate.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return;
        }
    }

    (*pI_NetLogonFree)( Buffer );
}


NET_API_STATUS
I_DsGetDcCache(
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    OUT PBOOLEAN InNt4Domain,
    OUT LPDWORD InNt4DomainTime
    )
/*++

Routine Description:

    This routine finds a domain entry that matches the caller's query.

Arguments:

    NetbiosDomainName - Specifies the Netbios name of the domain to find.

    DnsDomainName - Specifies the Dns name of the domain to find.

        At least one of the above parameters should be non-NULL.

    InNt4Domain - Returns true if the domain is an NT 4.0 domain.

    InNt4DomainTime - Returns the GetTickCount time of when the domain was
        detected to be an NT 4.0 domain.

Return Value:

    NO_ERROR: Information is returned about the domain.

    ERROR_NO_SUCH_DOMAIN: cached information is not available for this domain.

--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NetStatus = (*pI_DsGetDcCache)(
                    NetbiosDomainName,
                    DnsDomainName,
                    InNt4Domain,
                    InNt4DomainTime );

    return( NetStatus );
}

NET_API_STATUS
DsrGetDcNameEx2(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR AccountName OPTIONAL,
        IN ULONG AllowableAccountControlBits,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    Same as DsGetDcNameW except:

    AccountName - Account name to pass on the ping request.
        If NULL, no account name will be sent.

    AllowableAccountControlBits - Mask of allowable account types for AccountName.

    * This is the RPC server side implementation.

Arguments:

    Same as DsGetDcNameW except as above.

Return Value:

    Same as DsGetDcNameW except as above.


--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NetStatus = (*pDsrGetDcNameEx2)(
                    ComputerName,
                    AccountName,
                    AllowableAccountControlBits,
                    DomainName,
                    DomainGuid,
                    SiteName,
                    Flags,
                    DomainControllerInfo );

    return( NetStatus );
}


NTSTATUS
I_NetNotifyDsChange(
    IN NL_DS_CHANGE_TYPE DsChangeType
    )
/*++

Routine Description:

    This function is called by the LSA to indicate that configuration information
    in the DS has changed.

    This function is called for both PDC and BDC.

Arguments:

    DsChangeType - Indicates the type of information that has changed.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyDsChange)(
                    DsChangeType
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyDsChange &ld returns 0x%lx \n",
                    DsChangeType,
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );

}



NTSTATUS
I_NetLogonReadChangeLog(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    )
/*++

Routine Description:

    This function returns a portion of the change log to the caller.

    The caller asks for the first portion of the change log by passing zero as
    the InContext/InContextSize.  Each call passes out an OutContext that
    identifies the last change returned to the caller.  That context can
    be passed in on a subsequent call to I_NetlogonReadChangeLog.

Arguments:

    InContext - Opaque context describing the last entry to have been previously
        returned.  Specify NULL to request the first entry.

    InContextSize - Size (in bytes) of InContext.  Specify 0 to request the
        first entry.

    ChangeBufferSize - Specifies the size (in bytes) of the passed in ChangeBuffer.

    ChangeBuffer - Returns the next several entries from the change log.
        Buffer must be DWORD aligned.

    BytesRead - Returns the size (in bytes) of the entries returned in ChangeBuffer.

    OutContext - Returns an opaque context describing the last entry returned
        in ChangeBuffer.  NULL is returned if no entries were returned.
        The buffer must be freed using I_NetLogonFree

    OutContextSize - Returns the size (in bytes) of OutContext.


Return Value:

    STATUS_MORE_ENTRIES - More entries are available.  This function should
        be called again to retrieve the remaining entries.

    STATUS_SUCCESS - No more entries are currently available.  Some entries may
        have been returned on this call.  This function need not be called again.
        However, the caller can determine if new change log entries were
        added to the log, by calling this function again passing in the returned
        context.

    STATUS_INVALID_PARAMETER - InContext is invalid.
        Either it is too short or the change log entry described no longer
        exists in the change log.

    STATUS_INVALID_DOMAIN_ROLE - Change log not initialized

    STATUS_NO_MEMORY - There is not enough memory to allocate OutContext.


--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonReadChangeLog)(
                    InContext,
                    InContextSize,
                    ChangeBufferSize,
                    ChangeBuffer,
                    BytesRead,
                    OutContext,
                    OutContextSize
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonReadChangeLog returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}




NTSTATUS
I_NetLogonNewChangeLog(
    OUT HANDLE *ChangeLogHandle
    )
/*++

Routine Description:

    This function opens a new changelog file for writing.  The new changelog
    is a temporary file.  The real change log will not be modified until
    I_NetLogonCloseChangeLog is called asking to Commit the changes.

    The caller should follow this call by Zero more calls to
    I_NetLogonAppendChangeLog followed by a call to I_NetLogonCloseChangeLog.

    Only one temporary change log can be active at once.

Arguments:

    ChangeLogHandle - Returns a handle identifying the temporary change log.

Return Value:

    STATUS_SUCCESS - The temporary change log has been successfully opened.

    STATUS_INVALID_DOMAIN_ROLE - DC is neither PDC nor BDC.

    STATUS_NO_MEMORY - Not enough memory to create the change log buffer.

    Sundry file creation errors.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonNewChangeLog)(
                    ChangeLogHandle
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonNewChangeLog returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}




NTSTATUS
I_NetLogonAppendChangeLog(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    )
/*++

Routine Description:

    This function appends change log information to new changelog file.

    The ChangeBuffer must be a change buffer returned from I_NetLogonReadChangeLog.
    Care should be taken to ensure each call to I_NetLogonReadChangeLog is
    exactly matched by one call to I_NetLogonAppendChangeLog.

Arguments:

    ChangeLogHandle - A handle identifying the temporary change log.

    ChangeBuffer - A buffer describing a set of changes returned from
    I_NetLogonReadChangeLog.

    ChangeBufferSize - Size (in bytes) of ChangeBuffer.

Return Value:

    STATUS_SUCCESS - The temporary change log has been successfully opened.

    STATUS_INVALID_DOMAIN_ROLE - DC is neither PDC nor BDC.

    STATUS_INVALID_HANDLE - ChangeLogHandle is not valid.

    STATUS_INVALID_PARAMETER - ChangeBuffer contains invalid data.

    Sundry disk write errors.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonAppendChangeLog)(
                    ChangeLogHandle,
                    ChangeBuffer,
                    ChangeBufferSize
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonAppendChangeLog returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}


NTSTATUS
I_NetLogonCloseChangeLog(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    )
/*++

Routine Description:

    This function closes a new changelog file.

Arguments:

    ChangeLogHandle - A handle identifying the temporary change log.

    Commit - If true, the specified changes are written to the primary change log.
        If false, the specified change are deleted.

Return Value:

    STATUS_SUCCESS - The temporary change log has been successfully opened.

    STATUS_INVALID_DOMAIN_ROLE - DC is neither PDC nor BDC.

    STATUS_INVALID_HANDLE - ChangeLogHandle is not valid.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonCloseChangeLog)(
                    ChangeLogHandle,
                    Commit
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonCloseChangeLog returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}




NTSTATUS
I_NetLogonSendToSamOnPdc(
    IN LPWSTR DomainName,
    IN LPBYTE OpaqueBuffer,
    IN ULONG OpaqueBufferSize
    )
/*++

Routine Description:

    This function sends an opaque buffer from SAM on a BDC to SAM on the PDC of
    the specified domain.

    The original use of this routine will be to allow the BDC to forward user
    account password changes to the PDC.


Arguments:

    DomainName - Identifies the hosted domain that this request applies to.
        DomainName may be the Netbios domain name or the DNS domain name.
        NULL implies the primary domain hosted by this DC.

    OpaqueBuffer - Buffer to be passed to the SAM service on the PDC.
        The buffer will be encrypted on the wire.

    OpaqueBufferSize - Size (in bytes) of OpaqueBuffer.

Return Value:

    STATUS_SUCCESS: Message successfully sent to PDC

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NO_SUCH_DOMAIN: DomainName does not correspond to a hosted domain

    STATUS_NO_LOGON_SERVERS: PDC is not currently available

    STATUS_NOT_SUPPORTED: PDC does not support this operation

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonSendToSamOnPdc)(
                    DomainName,
                    OpaqueBuffer,
                    OpaqueBufferSize );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonSendToSamOnPdc returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}

NET_API_STATUS
I_NetLogonGetIpAddresses(
    OUT PULONG IpAddressCount,
    OUT LPBYTE *IpAddresses
    )
/*++

Routine Description:

    Returns all of the IP Addresses assigned to this machine.

Arguments:


    IpAddressCount - Returns the number of IP addresses assigned to this machine.

    IpAddresses - Returns a buffer containing an array of SOCKET_ADDRESS
        structures.
        This buffer should be freed using I_NetLogonFree().

Return Value:

    NO_ERROR - Success

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the operation.

    ERROR_NETLOGON_NOT_STARTED - Netlogon is not started.

--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NetStatus = (*pI_NetLogonGetIpAddresses)(
                    IpAddressCount,
                    IpAddresses );

    return( NetStatus );
}


NTSTATUS
I_NetLogonGetAuthDataEx(
    IN LPWSTR HostedDomainName OPTIONAL,
    IN LPWSTR TrustedDomainName,
    IN ULONG Flags,
    IN PLARGE_INTEGER FailedSessionSetupTime OPTIONAL,
    OUT LPWSTR *OurClientPrincipleName,
    OUT PVOID *ClientContext OPTIONAL,
    OUT LPWSTR *ServerName,
    OUT PNL_OS_VERSION ServerOsVersion,
    OUT PULONG AuthnLevel,
    OUT PLARGE_INTEGER SessionSetupTime
    )
/*++

Routine Description:

    This function returns the data that a caller could passed to
    RpcBindingSetAuthInfoW to do an RPC call using the Netlogon security package.

    The returned data is valid for the life of Netlogon's secure channel to
    the current DC.  There is no way for the caller to determine that lifetime.
    So, the caller should be prepared for access to be denied and respond to that
    by calling I_NetLogonGetAuthData again.  This condition is indicated by passing
    the previuosly used client context that resulted in denied access.

    Once the returned data is passed to RpcBindingSetAuthInfoW, the data should
    not be deallocated until after the binding handle is closed.

Arguments:

    HostedDomainName - Identifies the hosted domain that this request applies to.
        May be the Netbios domain name or the DNS domain name.
        NULL implies the primary domain hosted by this machine.

    TrustedDomainName - Identifies the domain the trust relationship is to.
        May be the Netbios domain name or the DNS domain name.

    Flags - Flags defining which ClientContext to return:

        NL_DIRECT_TRUST_REQUIRED: Indicates that STATUS_NO_SUCH_DOMAIN should be returned
            if TrustedDomainName is not directly trusted.

        NL_RETURN_CLOSEST_HOP: Indicates that for indirect trust, the "closest hop"
            session should be returned rather than the actual session

        NL_ROLE_PRIMARY_OK: Indicates that if this is a PDC, it's OK to return
            the client session to the primary domain.

        NL_REQUIRE_DOMAIN_IN_FOREST - Indicates that STATUS_NO_SUCH_DOMAIN should be
            returned if TrustedDomainName is not a domain in the forest.

    FailedSessionSetupTime - The time of the previous session setup to the server
        that the caller detected as no longer available. If this parameter is
        passed, the secure channel will be reset by this routine unless the timestamp
        on the current secure channel is different from the one passed by the caller
        (in which case the secure channel got already reset between the two calls to
        this routine).

    OurClientPrincipleName - The principle name of this machine (which is a client as far
        as authenication is concerned). This is the ServerPrincipleName parameter to pass
        to RpcBindingSetAuthInfo. Must be freed using NetApiBufferFree.

    ClientContext - Authentication data for ServerName to pass as AuthIdentity to
        RpcBindingSetAuthInfo. Must be freed using I_NetLogonFree.
        Note this OUT parameter is NULL if ServerName doesn't support this
        functionality.

    ServerName - UNC name of a DC in the trusted domain.
        The caller should RPC to the named DC.  This DC is the only DC that has the server
        side context associated with the returned ClientContext. The buffer must be freed
        using NetApiBufferFree.

    ServerOsVersion - Returns the operating system version of the DC named ServerName.

    AuthnLevel - Authentication level Netlogon will use for its secure channel. This value
        will be one of:

            RPC_C_AUTHN_LEVEL_PKT_PRIVACY: Sign and seal
            RPC_C_AUTHN_LEVEL_PKT_INTEGRITY: Sign only

        The caller can ignore this value and independently choose an authentication level.

    SessionSetupTime - The time of the secure channel session setup to the server.

Return Value:

    STATUS_SUCCESS: The auth data was successfully returned.

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NETLOGON_NOT_STARTED: Netlogon is not running

    STATUS_NO_SUCH_DOMAIN: HostedDomainName does not correspond to a hosted domain, OR
        TrustedDomainName is not a trusted domain corresponding to Flags.

    STATUS_NO_LOGON_SERVERS: No DCs are not currently available

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonGetAuthDataEx)(
                    HostedDomainName,
                    TrustedDomainName,
                    Flags,
                    FailedSessionSetupTime,
                    OurClientPrincipleName,
                    ClientContext,
                    ServerName,
                    ServerOsVersion,
                    AuthnLevel,
                    SessionSetupTime );

    return( NtStatus );
}

NTSTATUS
I_NetNotifyNtdsDsaDeletion (
    IN LPWSTR DnsDomainName,
    IN GUID *DomainGuid,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    )
/*++

Routine Description:

    This function is called by the DS to indicate that a NTDS-DSA object
    is being deleted.

    This function is called on the DC that the object is originally deleted on.
    It is not called when the deletion is replicated to other DCs.

Arguments:

    DnsDomainName - DNS domain name of the domain the DC was in.
        This need not be a domain hosted by this DC.

    DomainGuid - Domain Guid of the domain specified by DnsDomainName

    DsaGuid - GUID of the NtdsDsa object that is being deleted.

    DnsHostName - DNS host name of the DC whose NTDS-DSA object is being deleted.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyNtdsDsaDeletion)(
                                DnsDomainName,
                                DomainGuid,
                                DsaGuid,
                                DnsHostName );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyNtdsDsaDeletion returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}

NET_API_STATUS
I_NetLogonAddressToSiteName(
    IN PSOCKET_ADDRESS SocketAddress,
    OUT LPWSTR *SiteName
    )
/*++

Routine Description:

    This function translates a socket addresses to site name.

Arguments:

    SocketAddress -- the requested socket address

    SiteName -- the corresponding site name

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NetStatus = (*pI_NetLogonAddressToSiteName)(SocketAddress,
                                                SiteName );

    return( NetStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\xactsrv\xsunicod.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    XsUnicod.c

Abstract:

    This module contains Unicode routines for XACTSRV.

Author:

    Shanku Niyogi (w-shankn)   27-Sep-1990

Revision History:

--*/

#include "xactsrvp.h"
#include <prefix.h>     // PREFIX_ equates.



LPWSTR
XsDupStrToWStr(
    IN LPSTR Src
    )

/*++

Routine Description:

    This routine is an ANSI->Unicode equivalent of the run-time strdup
    function.

Arguments:

    Src - A pointer to the source string.

Return Value:

    LPWSTR - Pointer to the destination string if successful, NULL otherwise.
        Memory must be freed with NetpMemoryFree.

--*/

{

    LPWSTR dest = NULL;

    if (( dest = NetpMemoryAllocate(sizeof(WCHAR) * ( strlen( Src ) + 1 )))
           == NULL ) {

        return NULL;

    }

    NetpCopyStrToWStr( dest, Src );
    return dest;

} // XsDupStrToWStr


LPSTR
XsDupWStrToStr(
    IN LPWSTR Src
    )

/*++

Routine Description:

    This routine is a Unicode->ANSI equivalent of the run-time strdup
    function.

Arguments:

    Src - A pointer to the source string.

Return Value:

    LPSTR - Pointer to the destination string if successful, NULL otherwise.
        Memory must be freed with NetpMemoryFree.

--*/

{

    LPSTR dest = NULL;

    if (( dest = NetpMemoryAllocate( NetpUnicodeToDBCSLen( Src ) + 1 )) == NULL ) {
        return NULL;

    }

    NetpCopyWStrToStrDBCS( dest, Src );
    return dest;

} // XsDupWStrToStr


LPSTR
XsDupStrToStr(
    IN LPSTR Src
    )

/*++

Routine Description:

    This routine is equivalent to the run-time strdup function, but allocates
    memory using NetpMemory functions.

Arguments:

    Src - A pointer to the source string.

Return Value:

    LPSTR - Pointer to the destination string if successful, NULL otherwise.
        Memory must be freed with NetpMemoryFree.

--*/

{

    LPSTR dest = NULL;

    if (( dest = NetpMemoryAllocate( strlen( Src ) + 1 )) == NULL ) {

        return NULL;

    }

    strcpy( dest, Src );
    return dest;

} // XsDupStrToStr

#ifdef UNICODE


VOID
XsCopyTBufToBuf(
    OUT LPBYTE Dest,
    IN LPBYTE Src,
    IN DWORD DestSize
    )

/*++

Routine Description:

    This routine is a Unicode->ANSI equivalent of the run-time memcpy
    function.

Arguments:

    Dest - A pointer to the destination buffer.

    Src - A pointer to the source buffer.

    DestSize - The size, in bytes, of the destination buffer.

Return Value:

    none.

--*/

{
    DWORD finalDestSize;
    NTSTATUS ntStatus;
    DWORD srcSize;

    if ( (Dest == NULL) || (Src == NULL) || (DestSize == 0) ) {

        return;
    }

    srcSize = WCSSIZE( (LPWSTR) Src );
    NetpAssert( srcSize > 0 );

    ntStatus = RtlUnicodeToOemN(
            (PCHAR) Dest,               // OEM string
            (ULONG) DestSize,           // max bytes in OEM string
            (PULONG) & finalDestSize,   // bytes in OEM string
            (PWSTR) Src,                // UNICODE string
            (ULONG) srcSize             // bytes in UNICODE string
            );

    if ( !NT_SUCCESS( ntStatus ) ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( PREFIX_XACTSRV
                "XsCopyTBufToBuf: unexpected return code from "
                "RtlUnicodeToOemN: " FORMAT_NTSTATUS ".\n",
                ntStatus ));
        }
    }

    return;

} // XsCopyTBufToBuf




VOID
XsCopyBufToTBuf(
    OUT LPBYTE Dest,
    IN LPBYTE Src,
    IN DWORD SrcSize
    )

/*++

Routine Description:

    This routine is a ANSI->Unicode equivalent of the run-time memcpy
    function.

Arguments:

    Dest - A pointer to the destination buffer.

    Src - A pointer to the source buffer.

    SrcSize - The size, in bytes, of the source buffer.

Return Value:

    none.

--*/

{
    DWORD finalDestSize;
    DWORD destSize = SrcSize * sizeof(WCHAR);   // max byte count for dest.
    NTSTATUS ntStatus;

    if ( (Dest == NULL) || (Src == NULL) || (SrcSize == 0) ) {

        return;
    }
    NetpAssert( destSize > 0 );

    ntStatus = RtlOemToUnicodeN(
            (PWSTR) Dest,               // UNICODE string
            (ULONG) destSize,           // max bytes in UNICODE buffer
            (PULONG) & finalDestSize,   // final bytes in UNICODE buffer
            (PCHAR) Src,                // OEM string
            (ULONG) SrcSize             // bytes in OEM string
            );

    if ( !NT_SUCCESS( ntStatus ) ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( PREFIX_XACTSRV
                "XsCopyBufToTBuf: unexpected return code from "
                "RtlOemToUnicodeN: " FORMAT_NTSTATUS ".\n",
                ntStatus ));
        }
    }

} // XsCopyBufToTBuf

#endif // def UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\client\ncpsvc_c_stub.c ===
#include "ncpsvc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\client\ncpbind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ncpbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the NcpServer
    Service.

Author:

    Dan Lafferty (danl)     01-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    01-Mar-1991 danl
        created
    07-Jun-1991 JohnRo
        Allowed debug output of failures.
    15-Nov-1993 Yi-Hsin
        Modify for NcpServer.

--*/

//
// INCLUDES
//
#include <nt.h>          // DbgPrint prototype
#include <rpc.h>         // DataTypes and runtime APIs
#include <ncpsvc.h>      // generated by the MIDL complier
#include <ntrpcp.h>      // Rpc utils
#include <srvnames.h>    // SERVER_INTERFACE_NAME



handle_t
NCPSVC_HANDLE_bind (
    NCPSVC_HANDLE   ServerName
    )

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the ncpserver service client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle = NULL;
    RPC_STATUS  status;

    status = RpcpBindRpc( ServerName,
                          SERVER_INTERFACE_NAME,
    //                      TEXT("Security=Impersonation Static True"),
                          TEXT("Security=Impersonation Dynamic False"),
                          &bindingHandle );

#if DBG
    if ( status != RPC_S_OK )
        KdPrint(("NCPSVC_HANDLE_bind: RpcpBindRpc failed status=%lC\n",status));
#endif

    return( bindingHandle );
}



void
NCPSVC_HANDLE_unbind (
    NCPSVC_HANDLE   ServerName,
    handle_t        BindingHandle
    )
/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the ncpserver service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNREFERENCED_PARAMETER( ServerName );     // This parameter is not used

    RpcpUnbindRpc ( BindingHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\client\notify.c ===
/*++

Copyright (c) 1987-1994  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Sample SubAuthentication Package.

Author:

    Yi-Hsin Sung (yihsins) 27-Feb-1995

Revisions:


Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>

#include <windef.h>
#include <winbase.h>
#include <winuser.h>

#include <lmaccess.h>
#include <lmapibuf.h>

#include <nwsutil.h>
#include <fpnwcomm.h>
#include <usrprop.h>
#include <fpnwapi.h>
#include <nwsutil.h>

#define SW_DLL_NAME        L"swclnt.dll"
#define PASSWORD_PROC_NAME "SwPasswordChangeNotify"
#define NOTIFY_PROC_NAME   "SwDeltaChangeNotify"
#define NO_GRACE_LOGIN_LIMIT 0xFF

typedef DWORD (*PWPROC)( LPWSTR pUserName,
                         ULONG  RelativeId,
                         LPWSTR pPassword );

DWORD
GetNCPLSASecret(
    VOID
);

BOOL      fTriedToGetSW = FALSE;
BOOL      fTriedToGetNCP = FALSE;
HINSTANCE hinstSW = NULL;
PWPROC    ProcPasswordChange = NULL;
PSAM_DELTA_NOTIFICATION_ROUTINE ProcDeltaChange = NULL;
BOOL      fGotSecret = FALSE;
char      szNWSecretValue[NCP_LSA_SECRET_LENGTH] = "";



NTSTATUS
PasswordChangeNotify(
    PUNICODE_STRING UserName,
    ULONG RelativeId,
    PUNICODE_STRING Password
    )
{
    DWORD err = NO_ERROR;
    PUSER_INFO_2 pUserInfo2 = NULL;
    LPWSTR pszUser = NULL;
    LPWSTR pszPassword = NULL;

    //
    // If password is NULL, we can't get the cleartext password. Hence,
    // ignore this notification. Same for UserName.
    //
    if ( (Password == NULL) || (Password->Buffer == NULL) )
        return STATUS_SUCCESS;

    if ( (UserName == NULL) || (UserName->Buffer == NULL) )
        return STATUS_SUCCESS;

    //
    //  if neither DSMN nor FPNW are installed, blow out of here as there's
    //  nothing to do.
    //

    if ( ( fTriedToGetSW && hinstSW == NULL ) &&
         ( fTriedToGetNCP && fGotSecret == FALSE) )
    {
        return STATUS_SUCCESS;
    }

    //
    // Make sure user name and password are null terminated
    //
    pszUser = LocalAlloc( LMEM_ZEROINIT, UserName->Length + sizeof(WCHAR));

    if ( pszUser == NULL )
        return STATUS_NO_MEMORY;

    pszPassword = LocalAlloc( LMEM_ZEROINIT, Password->Length + sizeof(WCHAR));

    if ( pszPassword == NULL )
    {
        LocalFree( pszUser );
        return STATUS_NO_MEMORY;
    }

    memcpy( pszUser, UserName->Buffer, UserName->Length );
    memcpy( pszPassword, Password->Buffer, Password->Length );
    CharUpper( pszPassword );

    //
    // First, try to change the small world password if it is installed.
    //
    if ( !fTriedToGetSW )
    {
        hinstSW = LoadLibrary( SW_DLL_NAME );
        fTriedToGetSW = TRUE;
    }

    if (( hinstSW != NULL ) && ( ProcPasswordChange == NULL ))
    {
        ProcPasswordChange = (PWPROC) GetProcAddress( hinstSW,
                                                      PASSWORD_PROC_NAME );
    }

    if ( ProcPasswordChange != NULL )
    {
        err = (ProcPasswordChange)( pszUser, RelativeId, pszPassword );
    }

#if DBG
    if ( err )
    {
        KdPrint(("[FPNWCLNT] SwPasswordChangeNotify of user %ws changing returns %d.\n", pszUser, err ));
    }
#endif

    //
    //  we require that the PDC be rebooted after either DSMN or FPNW is
    //  installed anywhere in the domain for the first server... if we
    //  decide we shouldn't require a reboot, change the code such that
    //  it looks for the LSA secret everytime, not just first time through.
    //

    if ( !fTriedToGetNCP ) {

        fTriedToGetNCP = TRUE;

        //
        // Get the LSA secret used to encrypt the password
        //
        err = GetNCPLSASecret();
    }

    if ( !fGotSecret ) {

        goto CleanUp;
    }

    //
    // Next, change the netware password residue in the user parms field
    //
    err = NetUserGetInfo( NULL,
                          pszUser,
                          2,
                          (LPBYTE *) &pUserInfo2 );

    if ( !err )
    {
        WCHAR PropertyFlag;
        UNICODE_STRING PropertyValue;

        err = RtlNtStatusToDosError(
                  NetpParmsQueryUserProperty( pUserInfo2->usri2_parms,
                                     NWPASSWORD,
                                     &PropertyFlag,
                                     &PropertyValue ));


        if ( !err  && PropertyValue.Length != 0 )
        {
            //
            // This is a netware-enabled user, we need to store
            // the new password residue into the user parms
            //

            NT_PRODUCT_TYPE ProductType;
            WCHAR szEncryptedNWPassword[NWENCRYPTEDPASSWORDLENGTH];
            DWORD dwUserId;
            WORD wGraceLoginRemaining;
            WORD wGraceLoginAllowed;

            LocalFree( PropertyValue.Buffer );

            //
            // Get the grace login allowed and remaining value
            //
            err = RtlNtStatusToDosError(
                      NetpParmsQueryUserProperty( pUserInfo2->usri2_parms,
                                         GRACELOGINREMAINING,
                                         &PropertyFlag,
                                         &PropertyValue ));

            if ( !err && ( PropertyValue.Length != 0 ))
            {
                wGraceLoginRemaining = (WORD) *(PropertyValue.Buffer);
                LocalFree( PropertyValue.Buffer );

                if ( wGraceLoginRemaining != NO_GRACE_LOGIN_LIMIT )
                {
                    // If the grace login remaining is not unlimited,
                    // then we need to reset grace login remaining to
                    // the value in grace login allowed. Hence, read the
                    // grace login allowed value.

                    err = RtlNtStatusToDosError(
                              NetpParmsQueryUserProperty( pUserInfo2->usri2_parms,
                                                 GRACELOGINALLOWED,
                                                 &PropertyFlag,
                                                 &PropertyValue ));

                    if ( !err && ( PropertyValue.Length != 0 ))
                    {
                        wGraceLoginAllowed = (WORD) *(PropertyValue.Buffer);
                        LocalFree( PropertyValue.Buffer );
                    }

                }
            }


            if ( !err )
            {
                RtlGetNtProductType( &ProductType );


                dwUserId = MapRidToObjectId(
                               RelativeId,
                               pszUser,
                               ProductType == NtProductLanManNt,
                               FALSE );

                err = RtlNtStatusToDosError(
                          ReturnNetwareForm(
                              szNWSecretValue,
                              dwUserId,
                              pszPassword,
                              (UCHAR *) szEncryptedNWPassword ));
            }

            if ( !err )
            {
                LPWSTR pNewUserParms = NULL;
                BOOL fUpdate;
                UNICODE_STRING uPropertyValue;

                uPropertyValue.Buffer = szEncryptedNWPassword;
                uPropertyValue.Length = uPropertyValue.MaximumLength
                                      = sizeof( szEncryptedNWPassword );

                err = RtlNtStatusToDosError(
                          NetpParmsSetUserProperty(
                                  pUserInfo2->usri2_parms,
                                  NWPASSWORD,
                                  uPropertyValue,
                                  PropertyFlag,
                                  &pNewUserParms,
                                  &fUpdate ));

                if ( !err && fUpdate )
                {
                    USER_INFO_1013 userInfo1013;
                    LPWSTR pNewUserParms2 = NULL;
                    LPWSTR pNewUserParms3 = NULL;
                    LARGE_INTEGER currentTime;

                    //
                    //  Since we're resetting the user's password, let's
                    //  also clear the flag saying the password has
                    //  expired.  We do this by putting the current
                    //  time into the NWPasswordSet.
                    //

                    NtQuerySystemTime (&currentTime);

                    uPropertyValue.Buffer = (PWCHAR) &currentTime;
                    uPropertyValue.Length = sizeof (LARGE_INTEGER);
                    uPropertyValue.MaximumLength = sizeof (LARGE_INTEGER);

                    NetpParmsSetUserProperty( pNewUserParms,
                                     NWTIMEPASSWORDSET,
                                     uPropertyValue,
                                     (SHORT) 0,      // not a set
                                     &pNewUserParms2,
                                     &fUpdate );

                    if (pNewUserParms2 != NULL) {
                        userInfo1013.usri1013_parms = pNewUserParms2;
                    } else {
                        userInfo1013.usri1013_parms = pNewUserParms;
                    }

                    if ( wGraceLoginRemaining != NO_GRACE_LOGIN_LIMIT )
                    {
                        // If the grace login remaining is not unlimited,
                        // then we need to reset grace login remaining to
                        // the value in grace login allowed.

                        uPropertyValue.Buffer = (PWCHAR) &wGraceLoginAllowed;
                        uPropertyValue.Length = uPropertyValue.MaximumLength
                                              = sizeof(wGraceLoginAllowed);

                        NetpParmsSetUserProperty( userInfo1013.usri1013_parms,
                                         GRACELOGINREMAINING,
                                         uPropertyValue,
                                         (SHORT) 0,      // not a set
                                         &pNewUserParms3,
                                         &fUpdate );

                        if (pNewUserParms3 != NULL)
                            userInfo1013.usri1013_parms = pNewUserParms3;
                    }

                    err = NetUserSetInfo( NULL,
                                          pszUser,
                                          USER_PARMS_INFOLEVEL,
                                          (LPBYTE) &userInfo1013,
                                          NULL );

                    if (pNewUserParms2 != NULL)
                        NetpParmsUserPropertyFree( pNewUserParms2 );

                    if (pNewUserParms3 != NULL)
                        NetpParmsUserPropertyFree( pNewUserParms3 );
                }

                if ( pNewUserParms != NULL )
                    NetpParmsUserPropertyFree( pNewUserParms );
            }
        }

        NetApiBufferFree( pUserInfo2 );
    }

#if DBG
    if ( err )
    {
        KdPrint(("[FPNWCLNT] Password of user %ws changing returns %d.\n",
                pszUser, err ));
    }
#endif

CleanUp:

    LocalFree( pszUser );

    // Need to clear all memory that contains password
    memset( pszPassword, 0, Password->Length + sizeof( WCHAR ));
    LocalFree( pszPassword );

    return STATUS_SUCCESS;
}


BOOLEAN
InitializeChangeNotify (
    VOID
    )
{
    DWORD err = NO_ERROR;

    //
    // First, check to see if small world is installed.
    //
    if ( !fTriedToGetSW )
    {
        hinstSW = LoadLibrary( SW_DLL_NAME );
        fTriedToGetSW = TRUE;
    }

    if (( hinstSW != NULL )) {

        return TRUE;
    }

    if ( !fTriedToGetNCP ) {

        fTriedToGetNCP = TRUE;

        //
        // Get the LSA secret used to encrypt the password
        //
        err = GetNCPLSASecret();
    }

    return (fGotSecret != 0);
}



DWORD
GetNCPLSASecret(
    VOID
)
{
    DWORD err;
    LSA_HANDLE hlsaPolicy;
    OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    LSA_HANDLE hlsaSecret;
    UNICODE_STRING uSecretName;
    UNICODE_STRING *puSecretValue;
    LARGE_INTEGER lintCurrentSetTime, lintOldSetTime;

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( &oa, NULL, 0L, NULL, NULL );

    //
    // The InitializeObjectAttributes macro presently store NULL for
    // the psqos field, so we must manually copy that
    // structure for now.
    //

    oa.SecurityQualityOfService = &sqos;


    err = RtlNtStatusToDosError( LsaOpenPolicy( NULL,
                                                &oa,
                                                GENERIC_EXECUTE,
                                                &hlsaPolicy ));

    if ( !err )
    {
        RtlInitUnicodeString( &uSecretName, NCP_LSA_SECRET_KEY );
        err = RtlNtStatusToDosError( LsaOpenSecret( hlsaPolicy,
                                                    &uSecretName,
                                                    SECRET_QUERY_VALUE,
                                                    &hlsaSecret ));

        if ( !err )
        {
            err = RtlNtStatusToDosError(
                      LsaQuerySecret( hlsaSecret,
                                      &puSecretValue,
                                      &lintCurrentSetTime,
                                      NULL,
                                      &lintOldSetTime ));

            if ( !err )
            {
                memcpy( szNWSecretValue,
                        puSecretValue->Buffer,
                        NCP_LSA_SECRET_LENGTH );

                fGotSecret = TRUE;

                (VOID) LsaFreeMemory( puSecretValue );
            }

            (VOID) LsaClose( hlsaSecret );

        }

        (VOID) LsaClose( hlsaPolicy );
    }

    return err;

}



NTSTATUS
DeltaNotify(
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName OPTIONAL,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )
{
    NTSTATUS err = NO_ERROR;

    //
    // Try to notify small world of SAM changes if it is installed.
    //

    if ( !fTriedToGetSW )
    {
        hinstSW = LoadLibrary( SW_DLL_NAME );
        fTriedToGetSW = TRUE;
    }

    if ( ( hinstSW != NULL ) && ( ProcDeltaChange == NULL ))
    {
        ProcDeltaChange = (PSAM_DELTA_NOTIFICATION_ROUTINE)
                               GetProcAddress( hinstSW, NOTIFY_PROC_NAME );
    }

    if ( ProcDeltaChange != NULL )
    {
        err = (ProcDeltaChange)( DomainSid,
                                 DeltaType,
                                 ObjectType,
                                 ObjectRid,
                                 ObjectName,
                                 ModifiedCount,
                                 DeltaData );
    }

#if DBG
    if ( err )
    {
        KdPrint(("[FPNWCLNT] SwDeltaChangeNotify of type %d on rid 0x%x returns %d.\n", DeltaType, ObjectRid, err ));
    }
#endif

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\client\encrypt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    This module implements the routines for the NetWare
    redirector to mangle an objectid, challenge key and
    password such that a NetWare server will accept the
    password as valid.

    This program uses information published in Byte Magazine.

Author:

    Colin Watson    [ColinW]    15-Mar-1993
    Andy Herron     [AndyHe]

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <nwsutil.h>
#include <fpnwcomm.h>
#include <usrprop.h>
#include <crypt.h>

UCHAR Table[] =
{0x7,0x8,0x0,0x8,0x6,0x4,0xE,0x4,0x5,0xC,0x1,0x7,0xB,0xF,0xA,0x8,
 0xF,0x8,0xC,0xC,0x9,0x4,0x1,0xE,0x4,0x6,0x2,0x4,0x0,0xA,0xB,0x9,
 0x2,0xF,0xB,0x1,0xD,0x2,0x1,0x9,0x5,0xE,0x7,0x0,0x0,0x2,0x6,0x6,
 0x0,0x7,0x3,0x8,0x2,0x9,0x3,0xF,0x7,0xF,0xC,0xF,0x6,0x4,0xA,0x0,
 0x2,0x3,0xA,0xB,0xD,0x8,0x3,0xA,0x1,0x7,0xC,0xF,0x1,0x8,0x9,0xD,
 0x9,0x1,0x9,0x4,0xE,0x4,0xC,0x5,0x5,0xC,0x8,0xB,0x2,0x3,0x9,0xE,
 0x7,0x7,0x6,0x9,0xE,0xF,0xC,0x8,0xD,0x1,0xA,0x6,0xE,0xD,0x0,0x7,
 0x7,0xA,0x0,0x1,0xF,0x5,0x4,0xB,0x7,0xB,0xE,0xC,0x9,0x5,0xD,0x1,
 0xB,0xD,0x1,0x3,0x5,0xD,0xE,0x6,0x3,0x0,0xB,0xB,0xF,0x3,0x6,0x4,
 0x9,0xD,0xA,0x3,0x1,0x4,0x9,0x4,0x8,0x3,0xB,0xE,0x5,0x0,0x5,0x2,
 0xC,0xB,0xD,0x5,0xD,0x5,0xD,0x2,0xD,0x9,0xA,0xC,0xA,0x0,0xB,0x3,
 0x5,0x3,0x6,0x9,0x5,0x1,0xE,0xE,0x0,0xE,0x8,0x2,0xD,0x2,0x2,0x0,
 0x4,0xF,0x8,0x5,0x9,0x6,0x8,0x6,0xB,0xA,0xB,0xF,0x0,0x7,0x2,0x8,
 0xC,0x7,0x3,0xA,0x1,0x4,0x2,0x5,0xF,0x7,0xA,0xC,0xE,0x5,0x9,0x3,
 0xE,0x7,0x1,0x2,0xE,0x1,0xF,0x4,0xA,0x6,0xC,0x6,0xF,0x4,0x3,0x0,
 0xC,0x0,0x3,0x6,0xF,0x8,0x7,0xB,0x2,0xD,0xC,0x6,0xA,0xA,0x8,0xD};

UCHAR Keys[32] =
{0x48,0x93,0x46,0x67,0x98,0x3D,0xE6,0x8D,
 0xB7,0x10,0x7A,0x26,0x5A,0xB9,0xB1,0x35,
 0x6B,0x0F,0xD5,0x70,0xAE,0xFB,0xAD,0x11,
 0xF4,0x47,0xDC,0xA7,0xEC,0xCF,0x50,0xC0};

#define XorArray( DEST, SRC ) {                             \
    PULONG D = (PULONG)DEST;                                \
    PULONG S = (PULONG)SRC;                                 \
    int i;                                                  \
    for ( i = 0; i <= 7 ; i++ ) {                           \
        D[i] ^= S[i];                                       \
    }                                                       \
}

int
Scramble(
    int   iSeed,
    UCHAR achBuffer[32]
    );

VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
    )

/*++

Routine Description:

    This routine shuffles around the object ID with the password

Arguments:

    IN achObjectId - Supplies the 4 byte user's bindery object id

    IN szUpperPassword - Supplies the user's uppercased password on the
        first call to process the password. On the second and third calls
        this parameter contains the OutputBuffer from the first call

    IN iPasswordLen - length of uppercased password

    OUT achOutputBuffer - Returns the 8 byte sub-calculation

Return Value:

    none.

--*/

{
    int     iTempIndex;
    int     iOutputIndex;
    UCHAR   achTemp[32];

    //
    //  Truncate all trailing zeros from the password.
    //

    while (iPasswordLen > 0 && szUpperPassword[iPasswordLen-1] == 0 ) {
        iPasswordLen--;
    }

    //
    //  Initialize the achTemp buffer. Initialization consists of taking
    //  the password and dividing it up into chunks of 32. Any bytes left
    //  over are the remainder and do not go into the initialization.
    //
    //  achTemp[0] = szUpperPassword[0] ^ szUpperPassword[32] ^ szUpper...
    //  achTemp[1] = szUpperPassword[1] ^ szUpperPassword[33] ^ szUpper...
    //  etc.
    //

    if ( iPasswordLen > 32) {

        //  At least one chunk of 32. Set the buffer to the first chunk.

        RtlCopyMemory( achTemp, szUpperPassword, 32 );

        szUpperPassword +=32;   //  Remove the first chunk
        iPasswordLen -=32;

        while ( iPasswordLen >= 32 ) {
            //
            //  Xor this chunk with the characters already loaded into
            //  achTemp.
            //

            XorArray( achTemp, szUpperPassword);

            szUpperPassword +=32;   //  Remove this chunk
            iPasswordLen -=32;
        }

    } else {

        //  No chunks of 32 so set the buffer to zero's

        RtlZeroMemory( achTemp, sizeof(achTemp));

    }

    //
    //  achTemp is now initialized. Load the remainder into achTemp.
    //  The remainder is repeated to fill achTemp.
    //
    //  The corresponding character from Keys is taken to seperate
    //  each repitition.
    //
    //  As an example, take the remainder "ABCDEFG". The remainder is expanded
    //  to "ABCDEFGwABCDEFGxABCDEFGyABCDEFGz" where w is Keys[7],
    //  x is Keys[15], y is Keys[23] and z is Keys[31].
    //
    //

    if (iPasswordLen > 0) {
        int iPasswordOffset = 0;
        for (iTempIndex = 0; iTempIndex < 32; iTempIndex++) {

            if (iPasswordLen == iPasswordOffset) {
                iPasswordOffset = 0;
                achTemp[iTempIndex] ^= Keys[iTempIndex];
            } else {
                achTemp[iTempIndex] ^= szUpperPassword[iPasswordOffset++];
            }
        }
    }

    //
    //  achTemp has been loaded with the users password packed into 32
    //  bytes. Now take the objectid that came from the server and use
    //  that to munge every byte in achTemp.
    //

    for (iTempIndex = 0; iTempIndex < 32; iTempIndex++)
        achTemp[iTempIndex] ^= achObjectId[ iTempIndex & 3];

    Scramble( Scramble( 0, achTemp ), achTemp );

    //
    //  Finally take pairs of bytes in achTemp and return the two
    //  nibbles obtained from Table. The pairs of bytes used
    //  are achTemp[n] and achTemp[n+16].
    //

    for (iOutputIndex = 0; iOutputIndex < 16; iOutputIndex++) {

        achOutputBuffer[iOutputIndex] =
            Table[achTemp[iOutputIndex << 1]] |
            (Table[achTemp[(iOutputIndex << 1) + 1]] << 4);
    }

    return;
}

int
Scramble(
    int   iSeed,
    UCHAR   achBuffer[32]
    )

/*++

Routine Description:

    This routine scrambles around the contents of the buffer. Each buffer
    position is updated to include the contents of at least two character
    positions plus an EncryptKey value. The buffer is processed left to right
    and so if a character position chooses to merge with a buffer position
    to its left then this buffer position will include bits derived from at
    least 3 bytes of the original buffer contents.

Arguments:

    IN iSeed
    IN OUT achBuffer[32]

Return Value:

    none.

--*/

{
    int iBufferIndex;

    for (iBufferIndex = 0; iBufferIndex < 32; iBufferIndex++) {
        achBuffer[iBufferIndex] =
            (UCHAR)(
                ((UCHAR)(achBuffer[iBufferIndex] + iSeed)) ^
                ((UCHAR)(   achBuffer[(iBufferIndex+iSeed) & 31] -
                    Keys[iBufferIndex] )));

        iSeed += achBuffer[iBufferIndex];
    }
    return iSeed;
}

NTSTATUS
ReturnNetwareForm(
    const char * pszSecretValue,
    DWORD dwUserId,
    const WCHAR * pchNWPassword,
    UCHAR * pchEncryptedNWPassword
    )

/*++

Routine Description:

    This routine takes the ObjectId and encrypts it with the user
    supplied password to develop a credential for the intermediate form.

Arguments:
    DWORD dwUserId - Supplies the 4 byte user's object id
    const WCHAR * pchNWPassword - Supplies the user's password

    UCHAR * pchEncryptedNWPassword - 16 characters where the result goes.

Return Value:

    none.

--*/

{
    DWORD          dwStatus;
    DWORD          chObjectId = SWAP_OBJECT_ID (dwUserId);
    UNICODE_STRING uniNWPassword;
    OEM_STRING     oemNWPassword;

    //
    //  shuffle actually uses 32 bytes, not just 16.  It only returns 16 though.
    //

    UCHAR          pszShuffledNWPassword[NT_OWF_PASSWORD_LENGTH * 2];

    uniNWPassword.Buffer = (WCHAR *) pchNWPassword;
    uniNWPassword.Length = (USHORT)(lstrlenW (pchNWPassword)*sizeof(WCHAR));
    uniNWPassword.MaximumLength = uniNWPassword.Length;

    if ((dwStatus = RtlUpcaseUnicodeStringToOemString (&oemNWPassword,
                                           &uniNWPassword,
                                           TRUE)) == STATUS_SUCCESS)
    {
        Shuffle((UCHAR *) &chObjectId, oemNWPassword.Buffer, oemNWPassword.Length, pszShuffledNWPassword);

        // Encrypt with LSA secret.
        dwStatus = RtlEncryptNtOwfPwdWithUserKey(
                       (PNT_OWF_PASSWORD) pszShuffledNWPassword,
                       (PUSER_SESSION_KEY) pszSecretValue,
                       (PENCRYPTED_NT_OWF_PASSWORD) pchEncryptedNWPassword);
    }

    return (dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\client\nwsutil.c ===
/*++

Copyright (c) 1993-1993  Microsoft Corporation

Module Name:

    nwsutil.c

Abstract:

    This module implements IsNetWareInstalled()

Author:

    Congpa You  (CongpaY)   02-Dec-1993   Crested

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include "windef.h"
#include "winerror.h"
#include "winbase.h"

#include "ntlsa.h"
#include "nwsutil.h"
#include "crypt.h"

#include <fpnwcomm.h>
#include <usrprop.h>

NTSTATUS
GetRemoteNcpSecretKey (
    PUNICODE_STRING SystemName,
    CHAR *pchNWSecretKey
    )
{
    //
    //  this function returns the FPNW LSA Secret for the specified domain
    //

    NTSTATUS          ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;
    LSA_HANDLE        PolicyHandle = NULL;
    LSA_HANDLE        SecretHandle = NULL;
    UNICODE_STRING    SecretNameString;
    PUNICODE_STRING   punicodeCurrentValue;
    PUNICODE_STRING   punicodeOldValue;

    InitializeObjectAttributes( &ObjAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntstatus = LsaOpenPolicy( SystemName,
                              &ObjAttributes,
                              POLICY_CREATE_SECRET,
                              &PolicyHandle );

    if ( !NT_SUCCESS( ntstatus ))
    {
        return( ntstatus );
    }

    RtlInitUnicodeString( &SecretNameString, NCP_LSA_SECRET_KEY );

    ntstatus = LsaOpenSecret( PolicyHandle,
                              &SecretNameString,
                              SECRET_QUERY_VALUE,
                              &SecretHandle );

    if ( !NT_SUCCESS( ntstatus ))
    {
        LsaClose( PolicyHandle );
        return( ntstatus );
    }

    //
    // Do not need the policy handle anymore.
    //

    LsaClose( PolicyHandle );

    ntstatus = LsaQuerySecret( SecretHandle,
                               &punicodeCurrentValue,
                               NULL,
                               &punicodeOldValue,
                               NULL );

    //
    // Do not need the secret handle anymore.
    //

    LsaClose( SecretHandle );

    if ( NT_SUCCESS(ntstatus) && ( punicodeCurrentValue->Buffer != NULL))
    {
        memcpy( pchNWSecretKey,
                punicodeCurrentValue->Buffer,
                min(punicodeCurrentValue->Length, USER_SESSION_KEY_LENGTH));
    }

    LsaFreeMemory( punicodeCurrentValue );
    LsaFreeMemory( punicodeOldValue );

    return( ntstatus );
}

NTSTATUS
GetNcpSecretKey (
    CHAR *pchNWSecretKey
    )
{
    //
    //  simply return the LSA Secret for the local domain
    //

    return GetRemoteNcpSecretKey( NULL, pchNWSecretKey );
}

BOOL IsNetWareInstalled( VOID )
{
    CHAR pszNWSecretKey[USER_SESSION_KEY_LENGTH];

    return( !NT_SUCCESS( GetNcpSecretKey (pszNWSecretKey))
                       ? FALSE
                       : (pszNWSecretKey[0] != 0));
}

NTSTATUS InstallNetWare( LPWSTR lpNcpSecretKey )
{
    NTSTATUS          ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;
    LSA_HANDLE        PolicyHandle;
    LSA_HANDLE        SecretHandle;
    UNICODE_STRING    SecretNameString;
    UNICODE_STRING    unicodeCurrentValue;
    UNICODE_STRING    unicodeOldValue;

    InitializeObjectAttributes( &ObjAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL);

    ntstatus = LsaOpenPolicy( NULL,
                              &ObjAttributes,
                              POLICY_CREATE_SECRET,
                              &PolicyHandle );

    if ( !NT_SUCCESS( ntstatus ))
    {
        return( ntstatus );
    }

    RtlInitUnicodeString( &SecretNameString, NCP_LSA_SECRET_KEY );

    ntstatus = LsaCreateSecret( PolicyHandle,
                                &SecretNameString,
                                SECRET_SET_VALUE | DELETE,
                                &SecretHandle );

    if ( ntstatus == STATUS_OBJECT_NAME_COLLISION )
    {
        ntstatus = LsaOpenSecret( PolicyHandle,
                                  &SecretNameString,
                                  SECRET_SET_VALUE,
                                  &SecretHandle );
    }

    if ( NT_SUCCESS( ntstatus ))
    {
        RtlInitUnicodeString( &unicodeOldValue, NULL );
        RtlInitUnicodeString( &unicodeCurrentValue, lpNcpSecretKey );

        ntstatus = LsaSetSecret( SecretHandle,
                                 &unicodeCurrentValue,
                                 &unicodeOldValue );

        LsaClose( SecretHandle );
    }

    LsaClose( PolicyHandle );

    return( ntstatus );
}

ULONG
MapRidToObjectId(
    DWORD dwRid,
    LPWSTR pszUserName,
    BOOL fNTAS,
    BOOL fBuiltin )
{
    (void) fBuiltin ;   // unused for now.

    if (pszUserName && (lstrcmpi(pszUserName, SUPERVISOR_NAME_STRING)==0))
        return SUPERVISOR_USERID ;

    return ( fNTAS ? (dwRid | 0x10000000) : dwRid ) ;
}


ULONG SwapObjectId( ULONG ulObjectId )
{
    return (MAKELONG(HIWORD(ulObjectId),SWAPWORD(LOWORD(ulObjectId)))) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\client\logon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation


Module Name:

    logon.c

Abstract:

    This module contains the routines called by MSV1_0 authentication package.

Author:

    Yi-Hsin Sung (yihsins)
    Andy Herron (andyhe) 06-Jun-1994 Added support for MSV1_0 subauthority

Revision History:

    Andy Herron (andyhe) 15-Aug-1994 Pulled out (older) unused MSV1_0
                                     subauthority routines.
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <windows.h>
#include <ntmsv1_0.h>
#include <crypt.h>
#include <fpnwcomm.h>
#include <usrprop.h>
#include <samrpc.h>
#include <samisrv.h>
#include <ntlsa.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lmcons.h>
#include <logonmsv.h>

#define RESPONSE_SIZE       8
#define WKSTA_ADDRESS_SIZE  20
#define NET_ADDRESS_SIZE    8
#define NODE_ADDRESS_SIZE   12

#define MSV1_0_PASSTHRU     0x01
#define MSV1_0_GUEST_LOGON  0x02

#ifndef LOGON_SUBAUTH_SESSION_KEY
#define LOGON_SUBAUTH_SESSION_KEY 0x40
#endif

typedef NTSTATUS (*PF_SamIConnect)(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );
typedef NTSTATUS (*PF_SamrOpenUser)(
     SAMPR_HANDLE DomainHandle,
     ACCESS_MASK DesiredAccess,
     ULONG UserId,
     SAMPR_HANDLE __RPC_FAR *UserHandle);

typedef NTSTATUS (*PF_SamrCloseHandle)(
     SAMPR_HANDLE __RPC_FAR *SamHandle);

typedef NTSTATUS (*PF_SamrQueryInformationDomain)(
     SAMPR_HANDLE DomainHandle,
     DOMAIN_INFORMATION_CLASS DomainInformationClass,
     PSAMPR_DOMAIN_INFO_BUFFER __RPC_FAR *Buffer);

typedef NTSTATUS (*PF_SamrOpenDomain)(
     SAMPR_HANDLE ServerHandle,
     ACCESS_MASK DesiredAccess,
     PRPC_SID DomainId,
     SAMPR_HANDLE __RPC_FAR *DomainHandle);

typedef NTSTATUS (*PF_SamIAccountRestrictions)(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

typedef VOID (*PF_SamIFree_SAMPR_DOMAIN_INFO_BUFFER )(
    PSAMPR_DOMAIN_INFO_BUFFER Source,
    DOMAIN_INFORMATION_CLASS Branch
    );

typedef NTSTATUS (NTAPI *PF_LsaIQueryInformationPolicyTrusted)(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    );

typedef VOID (NTAPI *PF_LsaIFree_LSAPR_POLICY_INFORMATION )(
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    );

typedef NTSTATUS (NTAPI *PF_LsaIOpenPolicyTrusted)(
    OUT PLSAPR_HANDLE PolicyHandle
    );

typedef NTSTATUS (*PF_LsarQueryInformationPolicy)(
     LSAPR_HANDLE PolicyHandle,
     POLICY_INFORMATION_CLASS InformationClass,
     PLSAPR_POLICY_INFORMATION __RPC_FAR *PolicyInformation);

PF_SamIConnect pfSamIConnect = NULL;
PF_SamrOpenUser pfSamrOpenUser = NULL; 
PF_SamrCloseHandle pfSamrCloseHandle = NULL;
PF_SamrQueryInformationDomain pfSamrQueryInformationDomain = NULL;
PF_SamrOpenDomain pfSamrOpenDomain = NULL;
PF_SamIAccountRestrictions pfSamIAccountRestrictions = NULL;
PF_SamIFree_SAMPR_DOMAIN_INFO_BUFFER pfSamIFree_SAMPR_DOMAIN_INFO_BUFFER = NULL;
PF_LsaIQueryInformationPolicyTrusted pfLsaIQueryInformationPolicyTrusted = NULL;
PF_LsaIFree_LSAPR_POLICY_INFORMATION pfLsaIFree_LSAPR_POLICY_INFORMATION = NULL;
PF_LsaIOpenPolicyTrusted pfLsaIOpenPolicyTrusted = NULL;
PF_LsarQueryInformationPolicy pfLsarQueryInformationPolicy = NULL;

NTSTATUS LoadSamAndLsa(
    VOID
    ) ; 

NTSTATUS LoadSamAndLsa(
    VOID
    ) 
/*++

Routine Description:

    This routine loads the SAM/LSA dlls and resolves the entry points we
    need, to avoid staticly linking to those DLLs which do not expect to
    be loaded by proceses other than LSA. 


Arguments:

    None


Return Value:

    STATUS_SUCCESS: if there was no error.
    STATUS_DLL_NOT_FOUND: cannot load either DLL
    STATUS_ENTRYPOINT_NOT_FOUND: cannot get proc address for any of entry points

--*/
{
    static HMODULE hDllSam = NULL ;
    static HMODULE hDllLsa = NULL ;
    static NTSTATUS lastStatus = STATUS_SUCCESS ;

    if (hDllLsa && hDllSam) {

        return lastStatus ;
    }

    if (!(hDllSam = LoadLibrary(L"SAMSRV"))) {

        return  STATUS_DLL_NOT_FOUND ;
    }

    if (!(hDllLsa = LoadLibrary(L"LSASRV"))) {

        (void) FreeLibrary(hDllSam) ; 
        hDllSam = NULL ;

        return  STATUS_DLL_NOT_FOUND ;
    }

    pfSamIConnect = (PF_SamIConnect)
        GetProcAddress(hDllSam,"SamIConnect");
    pfSamrOpenUser = (PF_SamrOpenUser)
        GetProcAddress(hDllSam,"SamrOpenUser");
    pfSamrCloseHandle = (PF_SamrCloseHandle)
        GetProcAddress(hDllSam,"SamrCloseHandle");
    pfSamrQueryInformationDomain = (PF_SamrQueryInformationDomain)
        GetProcAddress(hDllSam,"SamrQueryInformationDomain") ;
    pfSamrOpenDomain = (PF_SamrOpenDomain)
        GetProcAddress(hDllSam,"SamrOpenDomain");
    pfSamIAccountRestrictions = (PF_SamIAccountRestrictions)
        GetProcAddress(hDllSam,"SamIAccountRestrictions");
    pfSamIFree_SAMPR_DOMAIN_INFO_BUFFER = (PF_SamIFree_SAMPR_DOMAIN_INFO_BUFFER)
        GetProcAddress(hDllSam,"SamIFree_SAMPR_DOMAIN_INFO_BUFFER");

    pfLsaIQueryInformationPolicyTrusted = (PF_LsaIQueryInformationPolicyTrusted)
        GetProcAddress(hDllLsa,"LsaIQueryInformationPolicyTrusted");
    pfLsaIFree_LSAPR_POLICY_INFORMATION = (PF_LsaIFree_LSAPR_POLICY_INFORMATION)
        GetProcAddress(hDllLsa,"LsaIFree_LSAPR_POLICY_INFORMATION");
    pfLsaIOpenPolicyTrusted = (PF_LsaIOpenPolicyTrusted)
        GetProcAddress(hDllLsa,"LsaIOpenPolicyTrusted");
    pfLsarQueryInformationPolicy = (PF_LsarQueryInformationPolicy)
        GetProcAddress(hDllLsa,"LsarQueryInformationPolicy");


    if (!( pfSamIConnect &&
           pfSamrOpenUser &&
           pfSamrCloseHandle &&
           pfSamrQueryInformationDomain &&
           pfSamrOpenDomain &&
           pfSamIAccountRestrictions &&
           pfSamIFree_SAMPR_DOMAIN_INFO_BUFFER &&
           pfLsaIQueryInformationPolicyTrusted &&
           pfLsaIFree_LSAPR_POLICY_INFORMATION &&
           pfLsaIOpenPolicyTrusted &&
           pfLsarQueryInformationPolicy) ) {
    
        //
        // cannot find at least one 
        //
        lastStatus = STATUS_ENTRYPOINT_NOT_FOUND ;

        (void) FreeLibrary(hDllSam) ; 
        hDllSam = NULL ;

        (void) FreeLibrary(hDllLsa) ; 
        hDllLsa = NULL ;
    }
    else {

        lastStatus = STATUS_SUCCESS ;
    }

    return lastStatus ;
}


///////////////////////////////////////////////////////////////////////////////

ULONG
MapRidToObjectId(
    DWORD dwRid,
    LPWSTR pszUserName,
    BOOL fNTAS,
    BOOL fBuiltin );

//
//  These are never closed once they're opened.  This is similar to how
//  msv1_0 does it.  Since there's no callback at shutdown time, we have no
//  way of knowing when to close them.
//

HANDLE SamDomainHandle = NULL;
SAMPR_HANDLE SamConnectHandle = NULL;
LSA_HANDLE LsaPolicyHandle = NULL;

//
//  This is where we store out LSA Secret
//

BOOLEAN GotSecret = FALSE;
UCHAR LsaSecretBuffer[USER_SESSION_KEY_LENGTH + 1];

//
// forward declare
//

BOOLEAN
MNSWorkstationValidate (
    IN PUNICODE_STRING Workstation,
    IN PUNICODE_STRING UserParameters
    );

BOOL
GetPasswordExpired(
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    );

NTSTATUS
QueryDomainPasswordInfo (
    PSAMPR_DOMAIN_INFO_BUFFER *DomainInfo
    );

VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
    );

NTSTATUS GetNcpSecretKey( CHAR *pchNWSecretKey );


NTSTATUS
Msv1_0SubAuthenticationRoutine2 (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime,
    OUT PUSER_SESSION_KEY UserSessionKey OPTIONAL
)
/*++

Routine Description:

    The subauthentication routine does cient/server specific authentication
    of a user.  The credentials of the user are passed in addition to all the
    information from SAM defining the user.  This routine decides whether to
    let the user logon.


Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials
            LOGON_GRACE_LOGON -- The caller's password has expired but logon
                was allowed during a grace period following the expiration.
            LOGON_SUBAUTH_SESSION_KEY - a session key was returned from this
                logon

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should logoff the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative NT system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

    UserSessionKey - If non-null, recives a session key for this logon
        session.


Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.

--*/
{
    NTSTATUS status;
    ULONG UserAccountControl;
    LARGE_INTEGER LogonTime;
    WCHAR    PropertyFlag;
    NT_OWF_PASSWORD DecryptedPassword;
    UCHAR    Response[RESPONSE_SIZE];
    UNICODE_STRING EncryptedPassword;
    UNICODE_STRING PasswordDateSet;
    UNICODE_STRING GraceLoginRemaining;
    SAMPR_HANDLE UserHandle;
    LARGE_INTEGER pwSetTime;
    PSAMPR_DOMAIN_INFO_BUFFER DomainInfo;
    PSAMPR_USER_INFO_BUFFER userControlInfo;
    LPWSTR pNewUserParams;
    int      index;
    UCHAR    achK[32];
    PNETLOGON_NETWORK_INFO LogonNetworkInfo;
    PCHAR challenge;
    BOOLEAN authoritative = TRUE;           // important default!
    ULONG   userFlags = 0;                  // important default!
    ULONG   whichFields = 0;                // important default!
    LARGE_INTEGER logoffTime;
    LARGE_INTEGER kickoffTime;

    pNewUserParams = NULL;
    DomainInfo = NULL;
    GraceLoginRemaining.Buffer = NULL;
    PasswordDateSet.Buffer = NULL;
    EncryptedPassword.Buffer = NULL;
    userControlInfo = NULL;

    logoffTime.HighPart  = 0x7FFFFFFF;      // default to no kickoff and
    logoffTime.LowPart   = 0xFFFFFFFF;      // no forced logoff
    kickoffTime.HighPart = 0x7FFFFFFF;
    kickoffTime.LowPart  = 0xFFFFFFFF;

    status = LoadSamAndLsa() ;
    if ( !NT_SUCCESS( status )) {
        
        return status ;
    }

    (VOID) NtQuerySystemTime( &LogonTime );

    //
    // Check whether the SubAuthentication package supports this type
    //  of logon.
    //

    if ( LogonLevel != NetlogonNetworkInformation ) {

        //
        // This SubAuthentication package only supports network logons.
        //

        status = STATUS_INVALID_INFO_CLASS;
        goto CleanUp;
    }

    //
    // This SubAuthentication package doesn't support access via machine
    // accounts.
    //

    UserAccountControl = USER_NORMAL_ACCOUNT;

    //
    // Local user (Temp Duplicate) accounts are only used on the machine
    // being directly logged onto.
    // (Nor are interactive or service logons allowed to them.)
    //

    if ( (Flags & MSV1_0_PASSTHRU) == 0 ) {
        UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT;
    }

    LogonNetworkInfo = (PNETLOGON_NETWORK_INFO) LogonInformation;

    //
    //  If the account type isn't allowed,
    //  Treat this as though the User Account doesn't exist.
    //
    // This SubAuthentication package doesn't allow guest logons.
    //

    if ( ( (UserAccountControl & UserAll->UserAccountControl) == 0 ) ||
         ( Flags & MSV1_0_GUEST_LOGON ) ) {

        authoritative = FALSE;
        status = STATUS_NO_SUCH_USER;
        goto CleanUp;
    }

    //
    // Ensure the account isn't locked out.
    //

    if ( UserAll->UserId != DOMAIN_USER_RID_ADMIN &&
         (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) ) {

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //
        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
            authoritative = FALSE;
        }
        status = STATUS_ACCOUNT_LOCKED_OUT;
        goto CleanUp;
    }

    //
    // Get the encrypted password from the user parms field
    //

    status = NetpParmsQueryUserPropertyWithLength(   &UserAll->Parameters,
                                            NWPASSWORD,
                                            &PropertyFlag,
                                            &EncryptedPassword );

    if ( !NT_SUCCESS( status )) {

        goto CleanUp;
    }

    //
    // If the user does not have a netware password, fail the login
    //

    if ( EncryptedPassword.Length == 0 ) {

        status = STATUS_NO_SUCH_USER;
        goto CleanUp;
    }

    //
    //  Read our LSA secret if we haven't already
    //

    if (! GotSecret) {

        status = GetNcpSecretKey( &LsaSecretBuffer[0] );

        if (! NT_SUCCESS(status)) {

            goto CleanUp;
        }

        GotSecret = TRUE;
    }

    //
    // Decrypt the password with NetwareLsaSecret to get the one way form
    //

    status = RtlDecryptNtOwfPwdWithUserKey(
                 (PENCRYPTED_NT_OWF_PASSWORD) EncryptedPassword.Buffer,
                 (PUSER_SESSION_KEY) &LsaSecretBuffer[0],
                 &DecryptedPassword );

    if ( !NT_SUCCESS( status )) {

        goto CleanUp;
    }

    //
    //  Get the response to challenge.  We do this by finishing off the
    //  password encryption algorithm here.
    //

    challenge = (PCHAR) &(LogonNetworkInfo->LmChallenge);

    Shuffle( challenge, (UCHAR *) &(DecryptedPassword.data), 16, &achK[0] );
    Shuffle( challenge+4, (UCHAR *) &(DecryptedPassword.data), 16, &achK[16] );

    for (index = 0; index < 16; index++) {
        achK[index] ^= achK[31-index];
    }

    for (index = 0; index < RESPONSE_SIZE; index++) {
        Response[index] = achK[index] ^ achK[15-index];
    }

    if ( memcmp(    Response,
                    (PCHAR) (LogonNetworkInfo->LmChallengeResponse.Buffer),
                    RESPONSE_SIZE ) != 0 ) {

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //

        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
            authoritative = FALSE;
        }

        //
        //  if the user tried to use a NULL password, don't note this as
        //  a bad password attempt since LOGON.EXE does this by default.
        //  Instead, map it to STATUS_LOGON_FAILURE.
        //

        {
            UCHAR  pszShuffledNWPassword[NT_OWF_PASSWORD_LENGTH * 2];
            DWORD  chObjectId;
            NT_PRODUCT_TYPE ProductType;
            DWORD dwUserId;

            //
            //  first we calculate what the user's Object ID is...
            //

            RtlGetNtProductType( &ProductType );
            dwUserId = MapRidToObjectId(
                           UserAll->UserId,
                           UserAll->UserName.Buffer,
                           ProductType == NtProductLanManNt,
                           FALSE );
            chObjectId = SWAP_OBJECT_ID (dwUserId);

            //
            //  then we calculate the user's password residue with a null
            //  password
            //

            RtlZeroMemory( &pszShuffledNWPassword, NT_OWF_PASSWORD_LENGTH * 2 );

            Shuffle( (UCHAR *) &chObjectId, NULL, 0, pszShuffledNWPassword );

            //
            //  we then finish off the encryption as we did above for the
            //  password in the user's record.
            //

            challenge = (PCHAR) &(LogonNetworkInfo->LmChallenge);

            Shuffle( challenge, pszShuffledNWPassword, 16, &achK[0] );
            Shuffle( challenge+4, pszShuffledNWPassword, 16, &achK[16] );

            for (index = 0; index < 16; index++) {
                achK[index] ^= achK[31-index];
            }

            for (index = 0; index < RESPONSE_SIZE; index++) {
                Response[index] = achK[index] ^ achK[15-index];
            }

            //
            //  now if the password that the user sent in matches the encrypted
            //  form of the null password, we exit with a generic return code
            //  that won't cause the user's record to be updated.  This will
            //  also cause LSA to not wait for 3 seconds to return the error
            //  (which is a good thing in this case).
            //

            if ( memcmp(    Response,
                            (PCHAR) (LogonNetworkInfo->LmChallengeResponse.Buffer),
                            RESPONSE_SIZE ) == 0 ) {

                status = STATUS_LOGON_FAILURE;

            } else {

                status = STATUS_WRONG_PASSWORD;
            }
        }
        goto CleanUp;
    }

    //
    // Prevent rest of things from effecting the Administrator user
    //

    if (UserAll->UserId == DOMAIN_USER_RID_ADMIN) {

        status = STATUS_SUCCESS;
        goto CleanUp;
    }

    //
    // Check if the account is disabled.
    //

    if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //

        authoritative = FALSE;
        status = STATUS_ACCOUNT_DISABLED;
        goto CleanUp;
    }

    //
    // Check if the account has expired.
    //

    if (UserAll->AccountExpires.QuadPart > 0 &&
        LogonTime.QuadPart >= UserAll->AccountExpires.QuadPart ) {

        status = STATUS_ACCOUNT_EXPIRED;
        goto CleanUp;
    }

    status = QueryDomainPasswordInfo( &DomainInfo );

    if ( !NT_SUCCESS( status )) {

        goto CleanUp;
    }

    //
    // Response is correct. So, check if the password has expired or not
    //

    if (! (UserAll->UserAccountControl & USER_DONT_EXPIRE_PASSWORD)) {

        status = NetpParmsQueryUserPropertyWithLength(   &UserAll->Parameters,
                                                NWTIMEPASSWORDSET,
                                                &PropertyFlag,
                                                &PasswordDateSet );
        if ( !NT_SUCCESS( status ) ||
                    PasswordDateSet.Length < sizeof(LARGE_INTEGER) ) {

            // date last password was set was not present.... hmmm.
            // we won't update anything here but let someone know all
            // is not kosher by making this a grace login.

            userFlags = LOGON_GRACE_LOGON;

        } else {

            pwSetTime = *((PLARGE_INTEGER)(PasswordDateSet.Buffer));

            if ( (pwSetTime.HighPart == 0xFFFF &&
                  pwSetTime.LowPart == 0xFFFF ) ||
                  GetPasswordExpired( pwSetTime,
                        DomainInfo->Password.MaxPasswordAge )) {

                //
                //  if we're on a bdc, just exit with invalid password, then
                //  we'll go try it on the PDC.
                //

                POLICY_LSA_SERVER_ROLE_INFO *LsaServerRole;
                PLSAPR_POLICY_INFORMATION LsaPolicyBuffer = NULL;

                status = (*pfLsaIQueryInformationPolicyTrusted)(
                                PolicyLsaServerRoleInformation,
                                &LsaPolicyBuffer );

                if ( NT_SUCCESS( status ) && (LsaPolicyBuffer != NULL)) {

                    LsaServerRole = (POLICY_LSA_SERVER_ROLE_INFO *) LsaPolicyBuffer;

                    if (LsaServerRole->LsaServerRole == PolicyServerRoleBackup) {

                        LsaFreeMemory( LsaServerRole );

                        status = STATUS_PASSWORD_EXPIRED;
                        goto CleanUp;
                    }

                    LsaFreeMemory( LsaServerRole );
                }

                //
                // Password has expired, so check if grace login is still allowed
                //

                userFlags = LOGON_GRACE_LOGON;

                //
                //  if this is a password validate rather than an
                //  actual login, don't update/check grace logins.
                //

                if ( LogonNetworkInfo->Identity.Workstation.Length > 0 ) {

                    status = NetpParmsQueryUserPropertyWithLength(   &UserAll->Parameters,
                                                            GRACELOGINREMAINING,
                                                            &PropertyFlag,
                                                            &GraceLoginRemaining );

                    if ( ! NT_SUCCESS( status ) ) {

                        //
                        //  The grace login value cannot be determined.
                        //

                        goto CleanUp;

                    } else if (  ( GraceLoginRemaining.Length != 0 ) &&
                              ( *(GraceLoginRemaining.Buffer) > 0 ) ) {

                        //
                        // Password has expired and grace login is available.
                        // So, return success and decrease the grace login remaining
                        // in the user parms field.
                        //

                        BOOL fUpdate;

                        (*(GraceLoginRemaining.Buffer))--;

                        status = NetpParmsSetUserProperty( UserAll->Parameters.Buffer,
                                                  GRACELOGINREMAINING,
                                                  GraceLoginRemaining,
                                                  USER_PROPERTY_TYPE_ITEM,
                                                  &pNewUserParams,
                                                  &fUpdate );

                        if ( NT_SUCCESS( status) &&
                             fUpdate ) {

                            //
                            //  if we actually updated the parms, mark as such.
                            //

                            whichFields = USER_ALL_PARAMETERS;

                            //
                            //  The length of the parameters didn't grow... we
                            //  know that because we started with a value and
                            //  ended with the same value - 1 ( same length )
                            //

                            memcpy( UserAll->Parameters.Buffer,
                                    pNewUserParams,
                                    UserAll->Parameters.Length );
                        }
                        status = STATUS_SUCCESS;

                    } else {

                        status = STATUS_PASSWORD_EXPIRED;
                        goto CleanUp;
                    }
                }
            }
        }
    }

    //
    //  To validate the user's logon hours, we must have a handle to the user.
    //  We'll open the user here.
    //

    UserHandle = NULL;

    status = (*pfSamrOpenUser)(  SamDomainHandle,
                            USER_READ_ACCOUNT,
                            UserAll->UserId,
                            &UserHandle );

    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "FPNWCLNT: Cannot SamrOpenUser %lX\n", status));
        goto CleanUp;
    }

    //
    // Validate the user's logon hours.
    //

    status = (*pfSamIAccountRestrictions)(   UserHandle,
                                        NULL,       // workstation id
                                        NULL,       // workstation list
                                        &UserAll->LogonHours,
                                        &logoffTime,
                                        &kickoffTime
                                        );
    (*pfSamrCloseHandle)( &UserHandle );

    if ( ! NT_SUCCESS( status )) {
        goto CleanUp;
    }

    //
    // Validate if the user can logon from this workstation.
    //  (Supply subauthentication package specific code here.)

    if ( ! MNSWorkstationValidate( &LogonNetworkInfo->Identity.Workstation,
                                   &UserAll->Parameters ) ) {

        status = STATUS_INVALID_WORKSTATION;
        goto CleanUp;
    }

    //
    //  The user is valid.  CleanUp up before returning.
    //

CleanUp:

    //
    // If we succeeded, create a session key.  The session key is created
    // by taking the decrypted password (a hash of the object id and
    // cleartext password) and adding the index of each byte to each byte
    // modulo 255, and using that to create a new challenge response from
    // the old challenge response.
    //

    if (NT_SUCCESS(status) && (UserSessionKey != NULL)) {
        UCHAR ChallengeResponse[NT_CHALLENGE_LENGTH];
        PUCHAR Password = (PUCHAR) &DecryptedPassword.data;
        PUCHAR SessionKey = (PUCHAR) UserSessionKey;

        ASSERT(RESPONSE_SIZE >= NT_CHALLENGE_LENGTH);

        RtlZeroMemory( UserSessionKey, sizeof(*UserSessionKey) );

        RtlCopyMemory(
            ChallengeResponse,
            Response,
            NT_CHALLENGE_LENGTH );

        //
        // Create the new password
        //

        for (index = 0; index < sizeof(DecryptedPassword) ; index++ ) {
            Password[index] = Password[index] + (UCHAR) index;
        }

        //
        // Use it to make a normal challenge response using the old challenge
        // response
        //

        Shuffle( ChallengeResponse, (UCHAR *) &(DecryptedPassword.data), 16, &achK[0] );
        Shuffle( ChallengeResponse+4, (UCHAR *) &(DecryptedPassword.data), 16, &achK[16] );

        for (index = 0; index < 16; index++) {
            achK[index] ^= achK[31-index];
        }

        for (index = 0; index < RESPONSE_SIZE; index++) {
            SessionKey[index] = achK[index] ^ achK[15-index];
        }
        userFlags |= LOGON_SUBAUTH_SESSION_KEY;

    }

    if (DomainInfo != NULL) {
        (*pfSamIFree_SAMPR_DOMAIN_INFO_BUFFER)( DomainInfo, DomainPasswordInformation );
    }
    if (EncryptedPassword.Buffer == NULL) {
        LocalFree( EncryptedPassword.Buffer );
    }
    if (PasswordDateSet.Buffer != NULL) {
        LocalFree( PasswordDateSet.Buffer );
    }
    if (GraceLoginRemaining.Buffer != NULL) {
        LocalFree( GraceLoginRemaining.Buffer );
    }
    if (pNewUserParams != NULL) {
        NetpParmsUserPropertyFree( pNewUserParams );
    }

    *Authoritative = authoritative;
    *UserFlags = userFlags;
    *WhichFields = whichFields;

    LogoffTime->HighPart  = logoffTime.HighPart;
    LogoffTime->LowPart   = logoffTime.LowPart;
    KickoffTime->HighPart = kickoffTime.HighPart;
    KickoffTime->LowPart  = kickoffTime.LowPart;

    return status;

} // Msv1_0SubAuthenticationRoutine



NTSTATUS
Msv1_0SubAuthenticationRoutine (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
/*++

Routine Description:

    Compatibility wrapper for Msv1_0SubAuthenticationRoutine2.


Arguments:

    Same as Msv1_0SubAuthenticationRoutine2

Return Value:

    Same as Msv1_0SubAuthenticationRoutine2

--*/
{
    return(Msv1_0SubAuthenticationRoutine2(
            LogonLevel,
            LogonInformation,
            Flags,
            UserAll,
            WhichFields,
            UserFlags,
            Authoritative,
            LogoffTime,
            KickoffTime,
            NULL            // session key
            ) );
}

BOOLEAN
MNSWorkstationValidate (
    IN PUNICODE_STRING Workstation,
    IN PUNICODE_STRING UserParameters
)
{
    NTSTATUS status;
    WCHAR    PropertyFlag;
    UNICODE_STRING LogonWorkstations;
    INT      cbRequired;
    INT      cb;
    LPWSTR   pszTmp;

    if ( Workstation->Length < (NET_ADDRESS_SIZE * sizeof(WCHAR)) ) {

        //
        //  Zero is used when simply verifying a password.
        //
        //  We also check that the length is enough so we dont
        //  blow up later. If for some reason a bad string is
        //  supplied, we pass it. This should never happen. Not a
        //  security hole as the user has no control over the string.
        //

        return(TRUE);
    }

    status = NetpParmsQueryUserPropertyWithLength(   UserParameters,
                                            NWLOGONFROM,
                                            &PropertyFlag,
                                            &LogonWorkstations );

    if ( !NT_SUCCESS( status) || LogonWorkstations.Length == 0 ) {
        return TRUE;
    }

    cbRequired = (LogonWorkstations.Length + 1) * sizeof(WCHAR);
    pszTmp = LocalAlloc( LMEM_ZEROINIT, cbRequired);

    if ( pszTmp == NULL ) {

        //
        // Not enough memory to allocate the buffer. Just
        // let the user logon.
        //

        LocalFree( LogonWorkstations.Buffer );
        return TRUE;
    }

    cb = MultiByteToWideChar( CP_ACP,
                              MB_PRECOMPOSED,
                              (const CHAR *) LogonWorkstations.Buffer,
                              LogonWorkstations.Length,
                              pszTmp,
                              cbRequired );

    LocalFree( LogonWorkstations.Buffer ); // Don't need it any more

    if ( cb > 1 )
    {
        USHORT  TotalEntries = LogonWorkstations.Length/WKSTA_ADDRESS_SIZE;
        WCHAR   *pszEntry    = pszTmp;
        WCHAR   *pszWksta    = Workstation->Buffer ;

        _wcsupr(pszEntry) ;
        _wcsupr(pszWksta) ;

        while ( TotalEntries > 0 )
        {

            //
            // if net # is not wildcard, check for match
            //
            if (wcsncmp(L"FFFFFFFF", pszEntry, NET_ADDRESS_SIZE)!=0)
            {
                if (wcsncmp(pszWksta, pszEntry, NET_ADDRESS_SIZE)!=0)
                {
                    //
                    // if no match, goto next entry
                    //
                    pszEntry += WKSTA_ADDRESS_SIZE;
                    TotalEntries--;
                    continue ;
                }
            }

            //
            // from above, net number passes. check node number.
            // again, look for wildcard first.
            //
            if (wcsncmp(L"FFFFFFFFFFFF", pszEntry+NET_ADDRESS_SIZE,
                        NODE_ADDRESS_SIZE)!=0)
            {
                if (wcsncmp(pszEntry+NET_ADDRESS_SIZE,
                            pszWksta+NET_ADDRESS_SIZE,
                            NODE_ADDRESS_SIZE)!=0)
                {
                    //
                    // if no match, goto next entry
                    //
                    pszEntry += WKSTA_ADDRESS_SIZE;
                    TotalEntries--;
                    continue ;
                }
            }

            //
            // found a match. return it.
            //
            LocalFree( pszTmp );
            return TRUE;
        }
    } else {

        //
        // MultiByteToWideChar failed or empty string (ie. 1 char).
        // Just let the user logon
        //
        LocalFree( pszTmp );
        return TRUE;
    }

    LocalFree( pszTmp );
    return FALSE;
}

BOOL
GetPasswordExpired(
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    )

/*++

Routine Description:

    This routine returns true if the password is expired, false otherwise.

Arguments:

    PasswordLastSet - Time when the password was last set for this user.

    MaxPasswordAge - Maximum password age for any password in the domain.

Return Value:

    Returns true if password is expired.  False if not expired.

--*/
{
    LARGE_INTEGER PasswordMustChange;
    NTSTATUS status;
    BOOLEAN rc;
    LARGE_INTEGER TimeNow;

    //
    // Compute the expiration time as the time the password was
    // last set plus the maximum age.
    //

    if (PasswordLastSet.QuadPart < 0 ||
        MaxPasswordAge.QuadPart > 0 ) {

        rc = TRUE;      // default for invalid times is that it is expired.

    } else {

        try {

            PasswordMustChange.QuadPart = PasswordLastSet.QuadPart -
                                          MaxPasswordAge.QuadPart;
            //
            // Limit the resultant time to the maximum valid absolute time
            //

            if ( PasswordMustChange.QuadPart < 0 ) {

                rc = FALSE;

            } else {

                status = NtQuerySystemTime( &TimeNow );
                if (NT_SUCCESS(status)) {

                    if ( TimeNow.QuadPart >= PasswordMustChange.QuadPart ) {
                        rc = TRUE;

                    } else {

                        rc = FALSE;
                    }
                } else {
                    rc = FALSE;     // won't fail if NtQuerySystemTime failed.
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            rc = TRUE;
        }
    }

    return rc;
}

NTSTATUS
QueryDomainPasswordInfo (
    PSAMPR_DOMAIN_INFO_BUFFER *DomainInfo
    )
/*++

  This routine opens a handle to sam so that we can get the max password
  age.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;
    PLSAPR_POLICY_INFORMATION PolicyAccountDomainInfo = NULL;

    //
    //  if we don't yet have a domain handle, open domain handle so that
    //  we can query the domain's password expiration time.
    //

    status = LoadSamAndLsa() ;
    if ( !NT_SUCCESS( status )) {
        
        return status ;
    }

    if (SamDomainHandle == NULL) {

        //
        // Determine the DomainName and DomainId of the Account Database
        //

        if (LsaPolicyHandle == NULL) {

            InitializeObjectAttributes( &PolicyObjectAttributes,
                                          NULL,             // Name
                                          0,                // Attributes
                                          NULL,             // Root
                                          NULL );           // Security Descriptor

            status = (*pfLsaIOpenPolicyTrusted)(&LsaPolicyHandle);

            if ( !NT_SUCCESS(status) ) {

                LsaPolicyHandle = NULL;
                KdPrint(( "FPNWCLNT: Cannot LsaIOpenPolicyTrusted 0x%x\n", status));
                goto CleanUp;
            }
        }

        status = (*pfLsarQueryInformationPolicy)( LsaPolicyHandle,
                                             PolicyAccountDomainInformation,
                                             &PolicyAccountDomainInfo );

        if ( !NT_SUCCESS(status) ) {

            KdPrint(( "FPNWCLNT: Cannot LsarQueryInformationPolicy 0x%x\n", status));
            goto CleanUp;
        }

        if ( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid == NULL ) {

            status = STATUS_NO_SUCH_DOMAIN;

            KdPrint(( "FPNWCLNT: Domain Sid is null 0x%x\n", status));
            goto CleanUp;
        }

        //
        // Open our connection with SAM
        //

        if (SamConnectHandle == NULL) {

            status = (*pfSamIConnect)( NULL,     // No server name
                                  &SamConnectHandle,
                                  SAM_SERVER_CONNECT,
                                  (BOOLEAN) TRUE );   // Indicate we are privileged

            if ( !NT_SUCCESS(status) ) {

                SamConnectHandle = NULL;

                KdPrint(( "FPNWCLNT: Cannot SamIConnect 0x%x\n", status));
                goto CleanUp;
            }
        }

        //
        // Open the domain.
        //

        status = (*pfSamrOpenDomain)( SamConnectHandle,
                                 DOMAIN_READ_OTHER_PARAMETERS,
                                 (RPC_SID *) PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid,
                                 &SamDomainHandle );

        if ( !NT_SUCCESS(status) ) {

            SamDomainHandle = NULL;
            KdPrint(( "FPNWCLNT: Cannot SamrOpenDomain 0x%x\n", status));
            goto CleanUp;
        }
    }

    status = (*pfSamrQueryInformationDomain)( SamDomainHandle,
                                         DomainPasswordInformation,
                                         DomainInfo );
    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "FPNWCLNT: Cannot SamrQueryInformationDomain %lX\n", status));
        goto CleanUp;
    }

CleanUp:

    if (PolicyAccountDomainInfo != NULL) {
        (*pfLsaIFree_LSAPR_POLICY_INFORMATION)( PolicyAccountDomainInformation,
                                           PolicyAccountDomainInfo );
    }
    return(status);

} // QueryDomainPasswordInfo


// logon.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\client\ncpstub.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ncpstub.c

Abstract:

    Contains NCP Server APIs.

Author:

    Yi-Hsin Sung (yihsins)  11-Sept-1993
    Andy Herron  (andyhe)

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <rpc.h>
#include <ncpsvc.h>
#include <nwstruct.h>

DWORD NwpMapRpcError(
    IN DWORD RpcError
);


DWORD
FpnwApiBufferFree(
    IN LPVOID pBuffer
)
/*++

Routine Description:

    This API frees the memory allocated by all enumeration and getinfo APIs.

Arguments:

    pBuffer - A pointer to an API information buffer previously returned
              on an API call.

Return Value:

    Error.

--*/
{
    if ( pBuffer == NULL )
        return NO_ERROR;

    MIDL_user_free( pBuffer );
    return NO_ERROR;
}

DWORD
NwApiBufferFree(
    IN LPVOID pBuffer
)
{   return(FpnwApiBufferFree( pBuffer ));
}



DWORD
FpnwServerGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppServerInfo
)
/*++

Routine Description:

    This API returns the information about the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the server structure requested, use
        1 for now.

    ppServerInfo - Place to store a pointer pointing to the returned
        NWSERVERINFO structure.

Return Value:

    Error.

--*/
{
    DWORD err;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if ( ppServerInfo == NULL )
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrServerGetInfo( pServerName,
                                dwLevel,
                                (PFPNWSERVERINFO *) ppServerInfo );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;

}
DWORD
NwServerGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWSERVERINFO *ppServerInfo
)
{   return(FpnwServerGetInfo(   pServerName,
                                dwLevel,
                                (LPBYTE *) ppServerInfo));
}



DWORD
FpnwServerSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  LPBYTE pServerInfo
)
/*++

Routine Description:

    This API sets the information about the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the server structure contained in
        pServerInfo, use 1 for now.

    pServerInfo - Points to a NWSERVERINFO structure which contains the server
        properties to set to.

Return Value:

    Error.

--*/
{
    DWORD err;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if ( pServerInfo == NULL )
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrServerSetInfo( pServerName,
                                dwLevel,
                                (PNWSERVERINFO) pServerInfo );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwServerSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWSERVERINFO pServerInfo
)
{   return( FpnwServerSetInfo( pServerName,
                               dwLevel,
                               (LPBYTE) pServerInfo ));
}



DWORD
FpnwVolumeAdd(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
)
/*++

Routine Description:

    This API adds a volume to the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        pVolumeInfo, use 1 & 2 for now.

    pVolumeInfo - Points to a NWVOLUMEINFO structure which contains the
        information about the volume to be added, i.e. the volume name, path,
        type, user limit and description. dwCurrentUses will be ignored.

Return Value:

    Error.

--*/
{
    DWORD err;
    ULONG                       SDLength = 0;
    ULONG                       oldSDLength;
    PSECURITY_DESCRIPTOR        fileSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR        oldFileSecurityDescriptor = NULL;
    PFPNWVOLUMEINFO_2 volInfo = (PFPNWVOLUMEINFO_2) pVolumeInfo;

    if ( dwLevel != 1 && dwLevel != 2 )
        return ERROR_INVALID_LEVEL;

    if ( pVolumeInfo == NULL )
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        if ( dwLevel == 2 ) {

            //
            // Save this. We need to restore this later.
            //

            oldFileSecurityDescriptor = volInfo->FileSecurityDescriptor;
            oldSDLength = volInfo->dwFileSecurityDescriptorLength;

            if ( oldFileSecurityDescriptor != NULL ) {

                if ( !RtlValidSecurityDescriptor( oldFileSecurityDescriptor ) ) {

                    return ERROR_INVALID_PARAMETER;
                }

                //
                // Make a self relative security descriptor for use in the
                // RPC call..
                //

                err = RtlMakeSelfRelativeSD(
                               oldFileSecurityDescriptor,
                               NULL,
                               &SDLength
                               );

                if (err != STATUS_BUFFER_TOO_SMALL) {

                    return(ERROR_INVALID_PARAMETER);

                } else {

                    fileSecurityDescriptor = MIDL_user_allocate( SDLength );

                    if ( fileSecurityDescriptor == NULL) {

                        return ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        //
                        // make an appropriate self-relative security descriptor
                        //

                        err = RtlMakeSelfRelativeSD(
                                       oldFileSecurityDescriptor,
                                       (PSECURITY_DESCRIPTOR) fileSecurityDescriptor,
                                       &SDLength
                                       );

                        if ( !NT_SUCCESS(err) ) {
                            MIDL_user_free( fileSecurityDescriptor );
                            return(ERROR_INVALID_PARAMETER);
                        }

                        volInfo->FileSecurityDescriptor = fileSecurityDescriptor;
                        volInfo->dwFileSecurityDescriptorLength = SDLength;
                    }
                }

            } else {

                volInfo->dwFileSecurityDescriptorLength = 0;
            }
        }

        err = NwrVolumeAdd( pServerName,
                            dwLevel,
                            (LPVOLUME_INFO) pVolumeInfo );

        if ( fileSecurityDescriptor != NULL ) {

            //
            // restore old values
            //

            volInfo->dwFileSecurityDescriptorLength = oldSDLength;
            volInfo->FileSecurityDescriptor = oldFileSecurityDescriptor;
            MIDL_user_free( fileSecurityDescriptor );
        }

    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeAdd(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
)
{   return( FpnwVolumeAdd( pServerName, dwLevel, (LPBYTE) pVolumeInfo ));
}



DWORD
FpnwVolumeDel(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
)
/*++

Routine Description:

    This API deletes a volume from the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pVolumeName - Specifies teh volume name that is to be deleted.

Return Value:

    Error.

--*/
{
    DWORD err;

    if ( (pVolumeName == NULL) || (pVolumeName[0] == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrVolumeDel( pServerName,
                            pVolumeName );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeDel(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
)
{   return( FpnwVolumeDel( pServerName, pVolumeName ));
}



DWORD
FpnwVolumeEnum(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
/*++

Routine Description:

    This enumerates all volumes on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppVolumeInfo, use 1 for now.

    ppVolumeInfo - On return, this will point to an array of NWVOLUMEINFO
        structures, one for each volume on the server.

    pEntriesRead - On return, this will specify the number of volumes returned

    resumeHandle - On return, a resume handle is stored in the DWORD pointed
        to by resumeHandle, and is used to continue an existing server search.
        The handle should be zero on the first call and left unchanged for
        subsequent calls. If the resumeHandle is NULL, then no resume
        handle is stored.

Return Value:

    Error.

--*/
{
    DWORD err;

    FPNWVOLUMEINFO_CONTAINER NwVolumeInfoContainer;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if ( ppVolumeInfo == NULL || pEntriesRead == NULL )
        return ERROR_INVALID_PARAMETER;

    NwVolumeInfoContainer.Buffer = NULL;

    RpcTryExcept
    {
        err = NwrVolumeEnum( pServerName,
                             dwLevel,
                             &NwVolumeInfoContainer,
                             resumeHandle );

        *ppVolumeInfo = (LPBYTE) NwVolumeInfoContainer.Buffer;

        if ( NwVolumeInfoContainer.Buffer != NULL ) {

            *pEntriesRead = NwVolumeInfoContainer.EntriesRead;

        } else {

            *pEntriesRead = 0;
        }
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeEnum(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{   return(FpnwVolumeEnum(  pServerName,
                            dwLevel,
                            (LPBYTE *)ppVolumeInfo,
                            pEntriesRead,
                            resumeHandle ));
}



DWORD
FpnwVolumeGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo
)
/*++

Routine Description:

    This querys the information about the given volume on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pVolumeName - A pointer to a UNICODE string containing the name of the
        volume we want to get information on.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppVolumeInfo, use 1 for now.

    ppVolumeInfo - On return, this will point to a NWVOLUMEINFO structure
        which contains information on the given volume on the given server.

Return Value:

    Error.

--*/
{
    DWORD err;

    if ( dwLevel != 1 && dwLevel != 2 ) {
        return ERROR_INVALID_LEVEL;
    }

    if ((pVolumeName == NULL) ||
        (pVolumeName[0] == 0 ) ||
        (ppVolumeInfo == NULL) ) {

        return ERROR_INVALID_PARAMETER;
    }

    *ppVolumeInfo = NULL ;

    RpcTryExcept
    {
        err = NwrVolumeGetInfo( pServerName,
                                pVolumeName,
                                dwLevel,
                                (LPVOLUME_INFO *) ppVolumeInfo );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo
)
{   return(FpnwVolumeGetInfo(   pServerName,
                                pVolumeName,
                                dwLevel,
                                (LPBYTE *)ppVolumeInfo ));
}



DWORD
FpnwVolumeSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
)
/*++

Routine Description:

    This sets the information about the given volume on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pVolumeName - A pointer to a UNICODE string containing the name of the
        volume we want to set information on.

    dwLevel - Reserved for the level of the volume structure contained in
        pVolumeInfo, use 1 for now.

    pVolumeInfo - Points to a NWVOLUMEINFO structure which contains
        information on the given volume to set to. Only dwMaxUses can be
        set. All the other fields in this structure will be ignored.

Return Value:

    Error.

--*/
{
    DWORD err;
    ULONG SDLength = 0;
    ULONG oldSDLength;
    PFPNWVOLUMEINFO_2 volInfo = (PFPNWVOLUMEINFO_2) pVolumeInfo;

    PSECURITY_DESCRIPTOR        fileSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR        oldFileSecurityDescriptor = NULL;

    if ( dwLevel != 1 && dwLevel != 2 )
        return ERROR_INVALID_LEVEL;

    if (  ((pVolumeName == NULL) ||
          ( pVolumeName[0] == 0 )) ||
          ( pVolumeInfo == NULL )
       ) {
        return ERROR_INVALID_PARAMETER;
    }

    RpcTryExcept
    {
        if ( dwLevel == 2 ) {

            //
            // Save this. We need to restore this later.
            //

            oldFileSecurityDescriptor = volInfo->FileSecurityDescriptor;
            oldSDLength = volInfo->dwFileSecurityDescriptorLength;

            if ( oldFileSecurityDescriptor != NULL ) {

                if ( !RtlValidSecurityDescriptor( oldFileSecurityDescriptor ) ) {

                    return ERROR_INVALID_PARAMETER;
                }

                //
                // Make a self relative security descriptor for use in the
                // RPC call..
                //

                err = RtlMakeSelfRelativeSD(
                               oldFileSecurityDescriptor,
                               NULL,
                               &SDLength
                               );

                if (err != STATUS_BUFFER_TOO_SMALL) {

                    return(ERROR_INVALID_PARAMETER);

                } else {

                    fileSecurityDescriptor = MIDL_user_allocate( SDLength );

                    if ( fileSecurityDescriptor == NULL) {

                        return ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        //
                        // make an appropriate self-relative security descriptor
                        //

                        err = RtlMakeSelfRelativeSD(
                                       oldFileSecurityDescriptor,
                                       (PSECURITY_DESCRIPTOR) fileSecurityDescriptor,
                                       &SDLength
                                       );

                        if ( !NT_SUCCESS(err) ) {
                            MIDL_user_free( fileSecurityDescriptor );
                            return(ERROR_INVALID_PARAMETER);
                        }

                        volInfo->FileSecurityDescriptor = fileSecurityDescriptor;
                        volInfo->dwFileSecurityDescriptorLength = SDLength;
                    }
                }

            } else {

                volInfo->dwFileSecurityDescriptorLength = 0;
            }
        }

        err = NwrVolumeSetInfo( pServerName,
                                pVolumeName,
                                dwLevel,
                                (LPVOLUME_INFO) pVolumeInfo );

        if ( fileSecurityDescriptor != NULL ) {

            //
            // restore old values
            //

            volInfo->dwFileSecurityDescriptorLength = oldSDLength;
            volInfo->FileSecurityDescriptor = oldFileSecurityDescriptor;
            MIDL_user_free( fileSecurityDescriptor );
        }

    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
)
{   return( FpnwVolumeSetInfo(  pServerName,
                                pVolumeName,
                                dwLevel,
                                (LPBYTE) pVolumeInfo ));
}



DWORD
FpnwConnectionEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT LPBYTE *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
/*++

Routine Description:

    This enumerates all connections on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppConnectionInfo, use 1 for now.

    ppConnectionInfo - On return, this will point to an array of
        NWCONNECTIONINFO structures, one for each volume on the server.

    pEntriesRead - On return, this will specify the number of current
        connecitons.

    resumeHandle - On return, a resume handle is stored in the DWORD pointed
        to by resumeHandle, and is used to continue an existing server search.
        The handle should be zero on the first call and left unchanged for
        subsequent calls. If the resumeHandle is NULL, then no resume
        handle is stored.

Return Value:

    Error.

--*/
{
    DWORD err;

    FPNWCONNECTIONINFO_CONTAINER NwConnectionInfoContainer;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if (( ppConnectionInfo == NULL ) || ( pEntriesRead == NULL ))
        return ERROR_INVALID_PARAMETER;

    NwConnectionInfoContainer.Buffer = NULL;

    RpcTryExcept
    {
        err = NwrConnectionEnum( pServerName,
                                 dwLevel,
                                 &NwConnectionInfoContainer,
                                 resumeHandle );

        *ppConnectionInfo = (LPBYTE) NwConnectionInfoContainer.Buffer;

        if ( NwConnectionInfoContainer.Buffer != NULL ) {

            *pEntriesRead = NwConnectionInfoContainer.EntriesRead;

        } else {

            *pEntriesRead = 0;
        }
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwConnectionEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT PNWCONNECTIONINFO *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{   return(FpnwConnectionEnum(  pServerName,
                                dwLevel,
                                (LPBYTE *) ppConnectionInfo,
                                pEntriesRead,
                                resumeHandle ));
}



DWORD
FpnwConnectionDel(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
)
/*++

Routine Description:

    This delete the connection with the given connection id on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwConnectionId - The identification number of the connection to tear down.

Return Value:

    Error.

--*/
{
    DWORD err;

    RpcTryExcept
    {
        err = NwrConnectionDel( pServerName,
                                dwConnectionId );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwConnectionDel(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
)
{   return( FpnwConnectionDel( pServerName, dwConnectionId ));
}



DWORD
FpnwVolumeConnEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD dwLevel,
    IN LPWSTR pVolumeName OPTIONAL,
    IN DWORD  dwConnectionId,
    OUT LPBYTE *ppVolumeConnInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
/*++

Routine Description:

    This enumerates all connections to a volume or list all volumes used by
    a particular connection on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppVolumeConnInfo, use 1 for now.

    pVolumeName - Specifies the volume name which we want to get all opened
        resources. This must be NULL if dwConnectionId is not 0.

    dwConnectionId - Specifies the connection id on which we want to get all
        opened resources. This must be 0 if pVolumeName is not NULL.

    ppVolumeConnInfo - On return, this will point to an array of
        NWVOLUMECONNINFO structures.

    pEntriesRead - On return, this will specify the number of NWVOLUMECONNINFO
        returned.

    resumeHandle - On return, a resume handle is stored in the DWORD pointed
        to by resumeHandle, and is used to continue an existing server search.
        The handle should be zero on the first call and left unchanged for
        subsequent calls. If the resumeHandle is NULL, then no resume
        handle is stored.

Return Value:

    Error.

--*/
{
    DWORD err;

    FPNWVOLUMECONNINFO_CONTAINER NwVolumeConnInfoContainer;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if (  ( dwConnectionId == 0 )
       && (( pVolumeName == NULL ) || ( *pVolumeName == 0 ))
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (  ( dwConnectionId != 0 )
       && (( pVolumeName != NULL) && ( *pVolumeName != 0 ))
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (( ppVolumeConnInfo == NULL ) || ( pEntriesRead == NULL ))
        return ERROR_INVALID_PARAMETER;

    NwVolumeConnInfoContainer.Buffer = NULL;

    RpcTryExcept
    {
        err = NwrVolumeConnEnum( pServerName,
                                 dwLevel,
                                 pVolumeName,
                                 dwConnectionId,
                                 &NwVolumeConnInfoContainer,
                                 resumeHandle );

        *ppVolumeConnInfo = (LPBYTE) NwVolumeConnInfoContainer.Buffer;

        if ( NwVolumeConnInfoContainer.Buffer != NULL ) {

            *pEntriesRead = NwVolumeConnInfoContainer.EntriesRead;

        } else {

            *pEntriesRead = 0;
        }
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeConnEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD dwLevel,
    IN LPWSTR pVolumeName OPTIONAL,
    IN DWORD  dwConnectionId,
    OUT PNWVOLUMECONNINFO *ppVolumeConnInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{   return( FpnwVolumeConnEnum( pServerName,
                                dwLevel,
                                pVolumeName,
                                dwConnectionId,
                                (LPBYTE *) ppVolumeConnInfo,
                                pEntriesRead,
                                resumeHandle ));
}



DWORD
FpnwFileEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT LPBYTE *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
/*++

Routine Description:

    This enumerates files opened on the server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppFileInfo, use 1 for now.

    pPathName - If this is not NULL, this means that we want to filter
        on the path. We only want entries with this path, i.e., all users that
        currently opened the file. If this is NULL, then all files that are
        opened are returned along with the user information.

    ppFileInfo - On return, this will point to an array of NWFILEINFO structures

    pEntriesRead - On return, this will specify the number of NWFILEINFO
        returned.

    resumeHandle - On return, a resume handle is stored in the DWORD pointed
        to by resumeHandle, and is used to continue an existing server search.
        The handle should be zero on the first call and left unchanged for
        subsequent calls. If the resumeHandle is NULL, then no resume
        handle is stored.

Return Value:

    Error.

--*/
{
    DWORD err;
    FPNWFILEINFO_CONTAINER NwFileInfoContainer;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if (( ppFileInfo == NULL ) || ( pEntriesRead == NULL ))
        return ERROR_INVALID_PARAMETER;

    NwFileInfoContainer.Buffer = NULL;

    RpcTryExcept
    {
        err = NwrFileEnum( pServerName,
                           dwLevel,
                           pPathName,
                           &NwFileInfoContainer,
                           resumeHandle );

        *ppFileInfo = (LPBYTE) NwFileInfoContainer.Buffer;

        if ( NwFileInfoContainer.Buffer != NULL ) {

            *pEntriesRead = NwFileInfoContainer.EntriesRead;

        } else {

            *pEntriesRead = 0;
        }
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwFileEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT PNWFILEINFO *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{   return(FpnwFileEnum( pServerName,
                         dwLevel,
                         pPathName,
                         (LPBYTE *) ppFileInfo,
                         pEntriesRead,
                         resumeHandle ));
}



DWORD
FpnwFileClose(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwFileId
)
/*++

Routine Description:

    This closes the file with the given identification number.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwFileId - The identification number of the file to close.

Return Value:

    Error.

--*/
{
    DWORD err;

    RpcTryExcept
    {
        err = NwrFileClose( pServerName,
                            dwFileId );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwFileClose(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwFileId
)
{   return(FpnwFileClose( pServerName, dwFileId ));
}



DWORD
FpnwMessageBufferSend(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId,
    IN DWORD  fConsoleBroadcast,
    IN LPBYTE pbBuffer,
    IN DWORD  cbBuffer
)
/*++

Routine Description:

    This sends the message to the given connection id.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwConnectionId - The id of the connection to send message to.

    fConsoleBroadcast - If this is TRUE, that means use console broadcast. If
        FALSE, use user broadcast.

    pbBuffer - Points to the message buffer to be sent.

    cbBuffer - The size of the pbBuffer in bytes.

Return Value:

    Error.

--*/
{
    DWORD err;

    if (( pbBuffer == NULL ) || ( cbBuffer == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrMessageBufferSend( pServerName,
                                    dwConnectionId,
                                    fConsoleBroadcast,
                                    pbBuffer,
                                    cbBuffer );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwMessageBufferSend(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId,
    IN DWORD  fConsoleBroadcast,
    IN LPBYTE pbBuffer,
    IN DWORD  cbBuffer
)
{   return( FpnwMessageBufferSend(  pServerName,
                                    dwConnectionId,
                                    fConsoleBroadcast,
                                    pbBuffer,
                                    cbBuffer ));
}



DWORD
FpnwSetDefaultQueue(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pQueueName
)
/*++

Routine Description:

    This sets the default queue on the server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pQueueName - The name of the queue that will become the default

Return Value:

    Error.

--*/
{
    DWORD err;

    if (( pQueueName == NULL ) || ( *pQueueName == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrSetDefaultQueue( pServerName,
                                  pQueueName );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwSetDefaultQueue(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pQueueName
)
{   return(FpnwSetDefaultQueue( pServerName, pQueueName ));
}



DWORD
FpnwAddPServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
)
/*++

Routine Description:

    This adds a pserver.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pPServerName - The name of the PServer.

Return Value:

    Error.

--*/
{
    DWORD err;

    if (( pPServerName == NULL ) || ( *pPServerName == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrAddPServer( pServerName,
                             pPServerName );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwAddPServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
)
{   return( FpnwAddPServer( pServerName, pPServerName ));
}



DWORD
FpnwRemovePServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
)
/*++

Routine Description:

    This removes a pserver.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pPServerName - The name of the PServer.

Return Value:

    Error.

--*/
{
    DWORD err;

    if (( pPServerName == NULL ) || ( *pPServerName == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrRemovePServer( pServerName,
                                pPServerName );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwRemovePServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
)
{   return( FpnwRemovePServer( pServerName, pPServerName ));
}


DWORD NwpMapRpcError(
    IN DWORD RpcError
)
/*++

Routine Description:

    This routine maps the RPC error into a more meaningful windows
    error for the caller.

Arguments:

    RpcError - Supplies the exception error raised by RPC

Return Value:

    Returns the mapped error.

--*/
{

    switch (RpcError)
    {
        case RPC_S_INVALID_BINDING:
        case RPC_X_SS_IN_NULL_CONTEXT:
        case RPC_X_SS_CONTEXT_DAMAGED:
        case RPC_X_SS_HANDLES_MISMATCH:
        case ERROR_INVALID_HANDLE:
            return ERROR_INVALID_HANDLE;

        case RPC_X_NULL_REF_POINTER:
            return ERROR_INVALID_PARAMETER;

        case STATUS_ACCESS_VIOLATION:
            return ERROR_INVALID_ADDRESS;

        default:
            return RpcError;
    }
}

// ncpstub.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\inc\imports.h ===
#include <windef.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t *
#define BOOL DWORD
#endif

#include "nwstruct.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\inc\nwsutil.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    nwsutil.h

Abstract:

    This is the public include file for some of the functions used by
    User Manager and Server Manager.

Author:

    Congpa You 02-Dec-1993  Created.

Revision History:

--*/

#ifndef _NWSUTIL_H_
#define _NWSUTIL_H_

#include <crypt.h>
#include <fpnwname.h>


/** Function Prototypes **/

NTSTATUS GetNcpSecretKey( CHAR *pchNWSecretKey );

NTSTATUS
GetRemoteNcpSecretKey (
    PUNICODE_STRING SystemName,
    CHAR *pchNWSecretKey
    );

BOOL IsNetWareInstalled( VOID );

ULONG
MapRidToObjectId(
    DWORD dwRid,
    LPWSTR pszUserName,
    BOOL fNTAS,
    BOOL fBuiltin
    );

ULONG
SwapObjectId(
    ULONG ulObjectId
    ) ;

NTSTATUS InstallNetWare( LPWSTR lpNcpSecretKey );

VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
    );

//Encryption function
NTSTATUS ReturnNetwareForm (const char * pszSecretValue,
                            DWORD dwUserId,
                            const WCHAR * pchNWPassword,
                            UCHAR * pchEncryptedNWPassword);

#endif // _NWSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\inc\nwprint.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    nw\svcdlls\ncpsvc\proc\nwprint.h

Abstract:

    Include file for the NCP print processor.

Author:

    Tommy Evans (vtommye) 02-16-1993

Revision History:

--*/

/** Data types we support **/

#define PRINTPROCESSOR_TYPE_RAW         0
#define PRINTPROCESSOR_TYPE_RAW_FF      1
#define PRINTPROCESSOR_TYPE_RAW_FF_AUTO 2
#define PRINTPROCESSOR_TYPE_JOURNAL     3
#define PRINTPROCESSOR_TYPE_TEXT        4
#define PRINTPROCESSOR_TYPE_NT_TEXT     5
#define PRINTPROCESSOR_TYPE_NUM         6   /* What is this? */

/** This is so we can compile JOURNAL.C **/

extern BOOL GdiPlayJournal(HDC, LPWSTR, DWORD, DWORD, INT);

extern HANDLE NCPXsPortHandle;

#define IDS_PSERVER_PORT 400

/** Structure used to track jobs **/

typedef struct _PRINTPROCESSORDATA {
    DWORD   signature;
    DWORD   cb;
    struct _PRINTPROCESSORDATA *pNext;
    DWORD   fsStatus;
    DWORD   uDatatype;
    DWORD   JobId;
    DWORD   Copies;                 /* Number of copies to print */
    DWORD   TabSize;                /* Tab expansion size */
    ULONG   QueueId;                /* Object id of the queue */
    HANDLE  semPaused;              /* Semaphore for job pausing */
    HANDLE  hPrinter;
    HANDLE  hLPCPort;
    HDC     hDC;
    LPWSTR  pPortName;              /* Text string for printer port */
    LPWSTR  pPrinterName;           /* Text string for printer name */
    LPWSTR  pDocument;
    LPWSTR  pOutputFile;
    LPWSTR  pDatatype;              /* Text string for datatype */
    LPWSTR  pParameters;            /* Parameters string for job */
    USHORT  NcpJobNumber;           /* NetWare job number for this job */
    BOOL    PServerPortFlag;        /* Flag if on a PServer port */
    BOOL    PServerAttachedFlag;    /* Flag if PServer attached to q */
} PRINTPROCESSORDATA, *PPRINTPROCESSORDATA;

#define PRINTPROCESSORDATA_SIGNATURE    0x5051  /* 'QP' is the signature value */

/* Define flags for fsStatus field */

#define PRINTPROCESSOR_ABORTED      0x0001
#define PRINTPROCESSOR_PAUSED       0x0002
#define PRINTPROCESSOR_CLOSED       0x0004

#define PRINTPROCESSOR_RESERVED     0xFFF8

/** Flags used for the GetKey routing **/

#define VALUE_STRING    0x01
#define VALUE_ULONG     0x02

/** Buffer sizes we'll use **/

#define READ_BUFFER_SIZE            4096
#define BASE_PRINTER_BUFFER_SIZE    2048

PPRINTPROCESSORDATA
ValidateHandle(
    HANDLE  hPrintProcessor
);

/**
    Debugging stuff.
**/

#define DBG_NONE    0x00000000
#define DBG_INFO    0x00000001
#define DBG_WARNING 0x00000002
#define DBG_ERROR   0x00000004
#define DBG_TRACE   0x00000008

#if DBG

/* Quick fix:
 *
 * Ensure DbgPrint and DbgBreakPoint are prototyped,
 * so that we're not affected by STDCALL.
 * This should be replaced by OutputDebugString
 */
ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS Debug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define DBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#else
#define DBGMSG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\fpnw\inc\srvnames.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    srvnames.h

Abstract:

    Private header file which defines the Server Service names.

Author:

    Dan Lafferty (danl) 07-Jan-1993

Revision History:

--*/

#define SERVER_INTERFACE_NAME    TEXT("FPNW")

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\nds.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nds.h

Abstract:

    This defines the necessary NDS data structures and
    symbolic constants for both kernel and user mode
    components.

Author:

    Cory West    [CoryWest]    08-Jan-1996

Revision History:

--*/

//
// NDS Actions.
//

#define NDS_REQUEST 104  // NCP Function Number.
#define NDS_PING    1    // Subfunction code for ping.
#define NDS_ACTION  2    // Subfunction code for action.

//
// NDS Verb Numbers.
//

#define NDSV_RESOLVE_NAME               1
#define NDSV_READ_ENTRY_INFO            2
#define NDSV_READ                       3
#define NDSV_LIST                       5
#define NDSV_OPEN_STREAM                27
#define NDSV_GET_SERVER_ADDRESS         53
#define NDSV_CHANGE_PASSWORD            55
#define NDSV_BEGIN_LOGIN                57
#define NDSV_FINISH_LOGIN               58
#define NDSV_BEGIN_AUTHENTICATE         59
#define NDSV_FINISH_AUTHENTICATE        60
#define NDSV_LOGOUT                     61

//
// Rounding Macros.
//

#define ROUNDUP4(x)                     ( ( (x) + 3 ) & ( ~3 ) )
#define ROUNDUP2(x)                     ( ( (x) + 1 ) & ( ~1 ) )

//
// Context Flags.
//

#define FLAGS_DEREF_ALIASES             0x1
#define FLAGS_XLATE_STRINGS             0x2
#define FLAGS_TYPELESS_NAMES            0x4
#define FLAGS_ASYNC_MODE                0x8     // Not supported.
#define FLAGS_CANONICALIZE_NAMES        0x10
#define FLAGS_ALL_PUBLIC                0x1f

//
// values for RESOLVE_NAME request flags
//

#define RSLV_DEREF_ALIASES  0x40
#define RSLV_READABLE       0x02
#define RSLV_WRITABLE       0x04
#define RSLV_WALK_TREE      0x20
#define RSLV_CREATE_ID      0x10
#define RSLV_ENTRY_ID       0x1

#define RESOLVE_NAME_ACCEPT_REMOTE      1
#define RESOLVE_NAME_REFER_REMOTE       2

//
// Confidence Levels.
//

#define LOW_CONF        0
#define MED_CONF        1
#define HIGH_CONF       2

//
// Referral Scopes.
//

#define ANY_SCOPE           0
#define COUNTRY_SCOPE       1
#define ORGANIZATION_SCOPE  2
#define LOCAL_SCOPE         3

//
// Max name sizes.
//

#define MAX_NDS_SCHEMA_NAME_CHARS 32

#define MAX_NDS_NAME_CHARS      256
#define MAX_NDS_NAME_SIZE       ( MAX_NDS_NAME_CHARS * 2 )
#define MAX_NDS_TREE_NAME_LEN   32

//
// For an NDS exchange, we use buffers of this size to hold the send
// and receive data.  These sizes come from the Win95 implementation.
//

#define NDS_BUFFER_SIZE         2048
#define DUMMY_ITER_HANDLE       ( ( unsigned long ) 0xffffffff )
#define INITIAL_ITERATION       ( ( unsigned long ) 0xffffffff )
#define ENTRY_INFO_NAME_VALUE   1

//
// Various server responses.
//

typedef struct {

    DWORD CompletionCode;
    DWORD RemoteEntry;
    DWORD EntryId;
    DWORD ServerNameLength;
    WCHAR ReferredServer[1];

    //
    // If RemoteEntry is set to RESOLVE_NAME_REFER_REMOTE,
    // Then the tree server doesn't know the information
    // about the object in question and has referred us to
    // the server named in ReferredServer.
    //

} NDS_RESPONSE_RESOLVE_NAME, *PNDS_RESPONSE_RESOLVE_NAME;

typedef struct {

    DWORD CompletionCode;
    DWORD EntryFlags;
    DWORD SubordinateCount;
    DWORD ModificationTime;

    //
    // Two UNICODE strings follow in standard NDS format:
    //
    //     DWORD BaseClassLen;
    //     WCHAR BaseClass[BaseClassLen];
    //     DWORD EntryNameLen;
    //     WCHAR EntryName[EntryNameLen];
    //

} NDS_RESPONSE_GET_OBJECT_INFO, *PNDS_RESPONSE_GET_OBJECT_INFO;

typedef struct {

    DWORD EntryId;
    DWORD Flags;
    DWORD SubordinateCount;
    DWORD ModificationTime;

    //
    // Two UNICODE strings follow in standard NDS format:
    //
    //     DWORD BaseClassLen;
    //     WCHAR BaseClass[BaseClassLen];
    //     DWORD EntryNameLen;
    //     WCHAR EntryName[EntryNameLen];
    //

} NDS_RESPONSE_SUBORDINATE_ENTRY, *PNDS_RESPONSE_SUBORDINATE_ENTRY;

typedef struct {

    DWORD  CompletionCode;
    DWORD  IterationHandle;
    DWORD  SubordinateEntries;

    //
    // Followed by an array of NDS_SUBORDINATE_ENTRY
    // structures that is SubordinateEntries long.
    //

} NDS_RESPONSE_SUBORDINATE_LIST, *PNDS_RESPONSE_SUBORDINATE_LIST;

typedef struct {

    DWORD SyntaxID;
    DWORD AttribNameLength;
    WCHAR AttribName[1];

    //
    // AttribName is of length
    // AttribNameLength, of course.
    //

    DWORD NumValues;

    //
    // Followed by an array of NumValues
    // Attrib structures.
    //

} NDS_ATTRIBUTE, *PNDS_ATTRIBUTE;

typedef struct {

    DWORD CompletionCode;
    DWORD IterationHandle;
    DWORD InfoType;
    DWORD NumAttributes;

    //
    // Followed by an array of
    // NDS_ATTRIBUTE structures.
    //

} NDS_RESPONSE_READ_ATTRIBUTE, *PNDS_RESPONSE_READ_ATTRIBUTE;

typedef struct {
    DWORD dwLength;
    WCHAR Buffer[1];
} NDS_STRING, *PNDS_STRING;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\nwcanon.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwcanon.h

Abstract:

    Header for NetWare names canonicalization library routines.

Author:

    Rita Wong      (ritaw)      19-Feb-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NW_CANON_INCLUDED_
#define _NW_CANON_INCLUDED_

DWORD
NwLibValidateLocalName(
    IN LPWSTR LocalName
    );

DWORD
NwLibCanonLocalName(
    IN LPWSTR LocalName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    );

DWORD
NwLibCanonRemoteName(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    );

DWORD
NwLibCanonUserName(
    IN LPWSTR UserName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    );

#endif // _NW_CANON_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\ncp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ncp.h

Abstract:

    This module defines NCP fields and constants.

Author:

    Manny Weiser (mannyw) 10-Aug-1993

Revision History:

--*/

#ifndef _NCP_
#define _NCP_

///////////////////////////////// IPX ///////////////////////////////////////

#define  RIP_SOCKET  0x5304
#define  SAP_SOCKET  0x5204
#define  NCP_SOCKET  0x5104

//
//  SAP request types
//

#define SAP_GENERAL_REQUEST      1
#define SAP_FIND_NEAREST         3

//
//  SAP services
//

#define SAP_SERVICE_TYPE_SERVER       4
#define SAP_SERVICE_TYPE_DIR_SERVER 278

///// IPX driver services:

#ifndef NWDOS_INCLUDED

typedef  UCHAR  byte;
typedef  USHORT word;

#endif

typedef  ULONG  NetAddress;
typedef  byte  NodeAddress [6];

typedef struct
{
    NetAddress   Net;
    NodeAddress  Node;
    word         Socket;
} IPXaddress;

NTSTATUS  IPX_Get_Local_Target          ( IPXaddress*, NodeAddress*, word* );
void  IPX_Get_Internetwork_Address  ( IPXaddress* );
word  IPX_Get_Interval_Marker       ( void );

struct _IRP_CONTEXT;
struct _NW_TDI_STRUCT;

NTSTATUS
IPX_Open_Socket(
    IN struct _IRP_CONTEXT* pIrpC,
    IN struct _NW_TDI_STRUCT* pTdiStruc
    );

VOID
IPX_Close_Socket(
    IN struct _NW_TDI_STRUCT* pTdiStruc
    );

///// IPX support routines to hide V86/VxD differences:

//byte*  IPX_Allocate_Low_Memory  ( word );
//ESR*   IPX_Wrap_Callback        ( ESR* );

///////////////////////////////// SAP ///////////////////////////////////////

typedef struct
{
    word        Command;
    word        ServerType;
    char        Name [48];
    IPXaddress  Address;
    word        Hops;
} SAPpacket;

///////////////////////////////// RIP ///////////////////////////////////////

typedef struct
{
    word        Command;
    NetAddress  Net;
    word        Hops;
    word        Ticks;
} RIPpacket;

///////////////////////////////// PEP ///////////////////////////////////////

#define  PEP_COMMAND_CONNECT        0x1111
#define  PEP_COMMAND_REQUEST        0x2222
#define  PEP_COMMAND_RESPONSE       0x3333
#define  PEP_COMMAND_DISCONNECT     0x5555
#define  PEP_COMMAND_BURST          0x7777
#define  PEP_COMMAND_ACKNOWLEDGE    0x9999

typedef struct
{
    word  command;
    byte  sequence;
    byte  connection;
    byte  x;
} PEPrequest;

typedef struct
{
    byte  error;
    byte  status;
} PEPresponse;

//
//  Bindery object types
//

#define OT_WILD         ~0
#define OT_USER         1
#define OT_GROUP        2
#define OT_PRINT_QUEUE  3
#define OT_FILESERVER   4
#define OT_DIRSERVER    0x278
#define OT_JOBQUEUE     0xA

#define ENCRYPTION_KEY_SIZE            8
#define OBJECT_ID_SIZE                 4

#define BROADCAST_MESSAGE_WAITING      0x21

//
//  NCP function codes
//

#define NCP_MESSAGE_FUNCTION            0x15
#define NCP_DIR_FUNCTION                0x16
#define NCP_ADMIN_FUNCTION              0x17
#define NCP_END_OF_JOB                  0x18
#define NCP_LOGOUT                      0x19
#define NCP_LOCK_RANGE                  0x1A
#define NCP_UNLOCK_RANGE                0x1E
#define NCP_NEGOTIATE_BUFFER_SIZE       0x21
#define NCP_GET_SHORT_NAME              0x30
#define NCP_FLUSH_FILE                  0x3D
#define NCP_SEARCH_INITIATE             0x3E
#define NCP_SEARCH_CONTINUE             0x3F
#define NCP_SEARCH_FILE                 0x40
#define NCP_CLOSE                       0x42
#define NCP_CREATE_FILE                 0x43
#define NCP_DELETE_FILE                 0x44
#define NCP_RENAME_FILE                 0x45
#define NCP_SET_FILE_ATTRIBUTES         0x46
#define NCP_GET_FILE_SIZE               0x47
#define NCP_READ_FILE                   0x48
#define NCP_WRITE_FILE                  0x49
#define NCP_SET_FILE_TIME               0x4B
#define NCP_OPEN_FILE                   0x4C
#define NCP_CREATE_NEW_FILE             0x4D
#define NCP_LFN_FUNCTION                0x57
#define NCP_NEGOTIATE_LIP_CONNECTION    0x61
#define NCP_NEGOTIATE_BURST_CONNECTION  0x65

//
//  Subfunctions of NCP_MESSAGE_FUNCTION
//

#define NCP_GET_MESSAGE                 0x01
#define NCP_GET_ENTIRE_MESSAGE          0x0B

//
//  Subfunctions of NCP_DIR_FUNCTION
//

#define NCP_GET_DIRECTORY_PATH          0x01
#define NCP_GET_VOLUME_NUMBER           0x05
#define NCP_CREATE_DIRECTORY            0x0A
#define NCP_DELETE_DIRECTORY            0x0B
#define NCP_RENAME_DIRECTORY            0x0F
#define NCP_ALLOCATE_DIR_HANDLE         0x12
#define NCP_ALLOCATE_TEMP_DIR_HANDLE    0x13
#define NCP_DEALLOCATE_DIR_HANDLE       0x14
#define NCP_GET_VOLUME_STATS            0x15
#define NCP_GET_VOLUME_INFO             0x2C
#define NCP_GET_NAME_SPACE_INFO         0x2F

//
//  Subfunctions of NCP_ADMIN_FUNCTION
//

#define NCP_GET_SERVER_INFO             0x11
#define NCP_PLAIN_TEXT_LOGIN            0x14
#define NCP_GET_LOGIN_KEY               0x17
#define NCP_ENCRYPTED_LOGIN             0x18
#define NCP_CHANGE_CONN_AUTH_STATUS     0x1D
#define NCP_QUERY_OBJECT_ID             0x35
#define NCP_SCAN_BINDERY_OBJECT         0x37
#define NCP_QUERY_PROPERTY_VALUE        0x3D
#define NCP_PLAIN_TEXT_VERIFY_PASSWORD  0x3F
#define NCP_IS_OBJECT_IN_SET            0x43
#define NCP_ENCRYPTED_VERIFY_PASSWORD   0x4A
#define NCP_CREATE_QUEUE_JOB            0x68
#define NCP_CLOSE_FILE_AND_START_JOB    0x69
#define NCP_CLOSE_FILE_AND_CANCEL_JOB   0x6A
#define NCP_SUBFUNC_79                  0x79
#define NCP_SUBFUNC_7F                  0x7F

//
// Values for NCP_CHANGE_CONN_AUTH_STATUS
//

#define NCP_CONN_NOT_LICENSED      0
#define NCP_CONN_LICENSED          1

//
//  Subfunctions of NCP_NAME_SPACE_FUNCTION
//

#define NCP_LFN_OPEN_CREATE             0x01
#define NCP_LFN_SEARCH_INITIATE         0x02
#define NCP_LFN_SEARCH_CONTINUE         0x03
#define NCP_LFN_RENAME_FILE             0x04
#define NCP_LFN_GET_INFO                0x06
#define NCP_LFN_SET_INFO                0x07
#define NCP_LFN_DELETE_FILE             0x08
#define NCP_LFN_ALLOCATE_DIR_HANDLE     0x0C

//
//  Packet types
//

#define PACKET_TYPE_SAP  0x00
#define PACKET_TYPE_NCP  0x11

//
//  Special character used to indicate that the next char in the
//  search mask is a wild card character.
//

#define LFN_META_CHARACTER              (UCHAR)0xFF

//
//  Properties we query and set
//

#define NET_ADDRESS_PROPERTY            "NET_ADDRESS"

//
//   Search attributes
//

#define SEARCH_ALL_DIRECTORIES          0x16
#define SEARCH_ALL_FILES                0x06
#define SEARCH_EXEC_ONLY_FILES          0x4E 

//  File Attributes

#define NW_ATTRIBUTE_SHARABLE       0x80
#define NW_ATTRIBUTE_ARCHIVE        0x20
#define NW_ATTRIBUTE_DIRECTORY      0x10
#define NW_ATTRIBUTE_EXECUTE_ONLY   0x08
#define NW_ATTRIBUTE_SYSTEM         0x04
#define NW_ATTRIBUTE_HIDDEN         0x02
#define NW_ATTRIBUTE_READ_ONLY      0x01
#define NW_ATTRIBUTE_EXEC_ONLY      0x4E

//  Open Flags

#define NW_OPEN_EXCLUSIVE           0x10
#define NW_DENY_WRITE               0x08
#define NW_DENY_READ                0x04
#define NW_OPEN_FOR_WRITE           0x02
#define NW_OPEN_FOR_READ            0x01

//
//  Connection status flags
//

#define NCP_STATUS_BAD_CONNECTION   0x01
#define NCP_STATUS_NO_CONNECTIONS   0x02
#define NCP_STATUS_SERVER_DOWN      0x04
#define NCP_STATUS_MSG_PENDING      0x08
#define NCP_STATUS_SHUTDOWN         0x10

//
//  Extended name space (long file name) query information flags
//

#define LFN_FLAG_INFO_NAME               0x0001
#define LFN_FLAG_INFO_BLOCK_SIZE         0x0002
#define LFN_FLAG_INFO_ATTRIBUTES         0x0004
#define LFN_FLAG_INFO_FILE_SIZE          0x0008
#define LFN_FLAG_INFO_STREAMS            0x0010
#define LFN_FLAG_INFO_EA_INFO            0x0020
#define LFN_FLAG_INFO_ARCHIVE_TIME       0x0040
#define LFN_FLAG_INFO_MODIFY_TIME        0x0080
#define LFN_FLAG_INFO_CREATION_TIME      0x0100
#define LFN_FLAG_INFO_CREATOR            0x0200
#define LFN_FLAG_INFO_DIR_INFO           0x0400
#define LFN_FLAG_INFO_RIGHTS             0x0800

//
//  Extended name space (long file name) set information flags
//

#define LFN_FLAG_SET_NAME                    0x0001  // Never used
#define LFN_FLAG_SET_INFO_ATTRIBUTES         0x0002
#define LFN_FLAG_SET_INFO_CREATE_DATE        0x0004
#define LFN_FLAG_SET_INFO_CREATE_TIME        0x0008
#define LFN_FLAG_SET_INFO_CREATOR_ID         0x0010
#define LFN_FLAG_SET_INFO_ARCHIVE_DATE       0x0020
#define LFN_FLAG_SET_INFO_ARCHIVE_TIME       0x0040
#define LFN_FLAG_SET_INFO_ARCHIVE_ID         0x0080
#define LFN_FLAG_SET_INFO_MODIFY_DATE        0x0100
#define LFN_FLAG_SET_INFO_MODIFY_TIME        0x0200
#define LFN_FLAG_SET_INFO_MODIFY_ID          0x0400
#define LFN_FLAG_SET_INFO_LASTACCESS_DATE    0x0800
#define LFN_FLAG_SET_INFO_INHERITANCE        0x1000
#define LFN_FLAG_SET_INFO_MAXIMUM_SPACE      0x2000

//
//  Extended name space (long file name) open mode flags
//

#define LFN_FLAG_OM_OPEN                 0x01
#define LFN_FLAG_OM_OVERWRITE            0x02
#define LFN_FLAG_OM_CREATE               0x08

//
//  Long name directory flags
//

#define LFN_FLAG_SHORT_DIRECTORY         0x00

//
//  Burst request
//

#define BURST_REQUEST_READ               0x01
#define BURST_REQUEST_WRITE              0x02

//
//  Burst flags
//

#define BURST_FLAG_END_OF_BURST          0x10
#define BURST_FLAG_SYSTEM_PACKET         0x80

/////////////////////////////////////////////////////////////////////////////

#define MAX_SERVER_NAME_LENGTH   48

#include <packon.h>

typedef struct _SAP_FIND_NEAREST_RESPONSE {
    USHORT SapType;         // == 4
    USHORT SapServiceType;
    UCHAR  ServerName[MAX_SERVER_NAME_LENGTH];
    ULONG  Network;
    UCHAR  NodeNumber[6];
    USHORT HopCount;       // Hi-lo order
} SAP_FIND_NEAREST_RESPONSE, *PSAP_FIND_NEAREST_RESPONSE;

typedef struct _NCP_HEADER {
    USHORT Command;
    UCHAR  SequenceNumber;
    UCHAR  ConnectionIdLow;
    UCHAR  TaskId;
    UCHAR  ConnectionIdHigh;
} NCP_HEADER, *PNCP_HEADER;

//
// Header format for NCP request with no subfunction.
//

typedef struct _NCP_REQUEST {
    NCP_HEADER NcpHeader;
    UCHAR FunctionCode;

    //
    //  Function specific stuff follows.
    //
} NCP_REQUEST, *PNCP_REQUEST;

//
// Header format for NCP request with a subfunction.
//

typedef struct _NCP_REQUEST_WITH_SUB {
    NCP_HEADER NcpHeader;
    UCHAR FunctionCode;
    USHORT SubfunctionLength;
    UCHAR SubfunctionCode;

    //
    //  Function specific stuff follows.
    //
} NCP_REQUEST_WITH_SUB, *PNCP_REQUEST_WITH_SUB;

typedef struct _NCP_RESPONSE {
    NCP_HEADER NcpHeader;

    UCHAR  Error;
    UCHAR  Status;

    //
    //  Function specific stuff follows.
    //

} NCP_RESPONSE, *PNCP_RESPONSE;

typedef struct _NCP_BURST_HEADER {
    USHORT Command;      // 0x7777
    UCHAR  Flags;
    UCHAR  StreamType;   // 0x02
    ULONG  SourceConnection;
    ULONG  DestinationConnection;
    ULONG  PacketSequenceNo;
    ULONG  SendDelayTime;
    USHORT BurstSequenceNo;
    USHORT AckSequenceNo;
    ULONG  DataSize;
    ULONG  BurstOffset;
    USHORT BurstLength;
    USHORT MissingFragmentCount;
} NCP_BURST_HEADER, *PNCP_BURST_HEADER;

typedef struct _NCP_BURST_WRITE_REQUEST {
    NCP_BURST_HEADER BurstHeader;
    ULONG Function;    //  0x02 = Write
    ULONG Handle;
    ULONG TotalWriteOffset;
    ULONG TotalWriteLength;
    ULONG Offset;
    ULONG Length;
    //UCHAR Data[x];
} NCP_BURST_WRITE_REQUEST, *PNCP_BURST_WRITE_REQUEST;

typedef struct _NCP_BURST_READ_RESPONSE {
    NCP_BURST_HEADER BurstHeader;
    ULONG Result;
    ULONG BytesRead;
    //UCHAR Data[x];
} NCP_BURST_READ_RESPONSE, *PNCP_BURST_READ_RESPONSE;

typedef struct _NCP_BURST_READ_REQUEST {
    NCP_BURST_HEADER BurstHeader;
    ULONG Function;    //  0x02 = Write
    ULONG Handle;
    ULONG TotalReadOffset;
    ULONG TotalReadLength;
    ULONG Offset;
    ULONG Length;
} NCP_BURST_READ_REQUEST, *PNCP_BURST_READ_REQUEST;

typedef struct _NCP_READ_REQUEST {
    NCP_REQUEST RequestHeader;
    UCHAR Unused;
    UCHAR Handle[6];
    ULONG FileOffset;
    USHORT Length;
} NCP_READ_REQUEST, *PNCP_READ_REQUEST;

typedef struct _NCP_READ_RESPONSE {
    NCP_RESPONSE ResponseHeader;
    USHORT Length;
    //UCHAR Data[x];
} NCP_READ_RESPONSE, *PNCP_READ_RESPONSE;

#include <packoff.h>

#endif // _NCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\ntddnwfs.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ntddnwfs.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the NetWare redirector file system device.

Author:

    Colin Watson   (ColinW)  23-Dec-1992

Revision History:


--*/

#ifndef _NTDDNWFS_
#define _NTDDNWFS_

#include <windef.h>
#include <winnetwk.h>      // NETRESOURCE structure

typedef CHAR SERVERNAME[48];
typedef SERVERNAME* PSERVERNAME;

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_NWFS_DEVICE_NAME    "\\Device\\NwRdr"
#define DD_NWFS_DEVICE_NAME_U L"\\Device\\NwRdr"

//
// The file system name as returned by
// NtQueryInformationVolume(FileFsAttributeInformation)
//
#define DD_NWFS_FILESYS_NAME "NWRDR"
#define DD_NWFS_FILESYS_NAME_U L"NWRDR"

//
// Connection type bit mask
//
#define CONNTYPE_DISK      0x00000001
#define CONNTYPE_PRINT     0x00000002
#define CONNTYPE_ANY       ( CONNTYPE_DISK | CONNTYPE_PRINT )
#define CONNTYPE_IMPLICIT  0x80000000
#define CONNTYPE_SYMBOLIC  0x40000000
#define CONNTYPE_UID       0x00010000

//
// EA Names for creating a connection
//
#define EA_NAME_USERNAME        "UserName"
#define EA_NAME_PASSWORD        "Password"
#define EA_NAME_TYPE            "Type"
#define EA_NAME_CREDENTIAL_EX   "ExCredentials"

#define TRANSACTION_REQUEST     0x00000003


//
// NtDeviceIoControlFile/NtFsControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_NWRDR_BASE                  FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _NWRDR_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_NWRDR_BASE, request, method, access)

#define FSCTL_NWR_START                 _NWRDR_CONTROL_CODE(200, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_NWR_STOP                  _NWRDR_CONTROL_CODE(201, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_LOGON                 _NWRDR_CONTROL_CODE(202, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_LOGOFF                _NWRDR_CONTROL_CODE(203, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONNECTION        _NWRDR_CONTROL_CODE(204, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_ENUMERATE_CONNECTIONS _NWRDR_CONTROL_CODE(205, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_DELETE_CONNECTION     _NWRDR_CONTROL_CODE(207, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_BIND_TO_TRANSPORT     _NWRDR_CONTROL_CODE(208, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_CHANGE_PASS           _NWRDR_CONTROL_CODE(209, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_SET_INFO              _NWRDR_CONTROL_CODE(211, METHOD_BUFFERED,  FILE_ANY_ACCESS)

#define FSCTL_NWR_GET_USERNAME          _NWRDR_CONTROL_CODE(215, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_CHALLENGE             _NWRDR_CONTROL_CODE(216, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_DETAILS      _NWRDR_CONTROL_CODE(217, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_MESSAGE           _NWRDR_CONTROL_CODE(218, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_STATISTICS        _NWRDR_CONTROL_CODE(219, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_STATUS       _NWRDR_CONTROL_CODE(220, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_INFO         _NWRDR_CONTROL_CODE(221, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_PREFERRED_SERVER  _NWRDR_CONTROL_CODE(222, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_PERFORMANCE  _NWRDR_CONTROL_CODE(223, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_SET_SHAREBIT          _NWRDR_CONTROL_CODE(224, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_DETAILS2     _NWRDR_CONTROL_CODE(225, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_CLOSEALL              _NWRDR_CONTROL_CODE(226, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_NWR_NDS_SETCONTEXT        NWR_ANY_NDS(1)
#define FSCTL_NWR_NDS_GETCONTEXT        NWR_ANY_NDS(2)
#define FSCTL_NWR_NDS_VERIFY_TREE       NWR_ANY_NDS(3)
#define FSCTL_NWR_NDS_RESOLVE_NAME      NWR_ANY_NDS(4)
#define FSCTL_NWR_NDS_LIST_SUBS         NWR_ANY_NDS(5)
#define FSCTL_NWR_NDS_READ_INFO         NWR_ANY_NDS(6)
#define FSCTL_NWR_NDS_READ_ATTR         NWR_ANY_NDS(7)
#define FSCTL_NWR_NDS_OPEN_STREAM       NWR_ANY_NDS(8)
#define FSCTL_NWR_NDS_GET_QUEUE_INFO    NWR_ANY_NDS(9)
#define FSCTL_NWR_NDS_GET_VOLUME_INFO   NWR_ANY_NDS(10)
#define FSCTL_NWR_NDS_RAW_FRAGEX        NWR_ANY_NDS(11)
#define FSCTL_NWR_NDS_CHANGE_PASS       NWR_ANY_NDS(12)
#define FSCTL_NWR_NDS_LIST_TREES        NWR_ANY_NDS(13)

#define IOCTL_NWR_RAW_HANDLE            _NWRDR_CONTROL_CODE(1002,METHOD_NEITHER,   FILE_ANY_ACCESS)

//
//  UserNcp control code definitions. The parameter (X) to NWR_ANY_NCP
//  is the function code to be placed in the NCP.
//

#define NWR_ANY_NCP(X)                  _NWRDR_CONTROL_CODE(0x400 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_F2_NCP(X)               _NWRDR_CONTROL_CODE(0x500 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_HANDLE_NCP(X)           _NWRDR_CONTROL_CODE(0x600 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_NDS(X)                  _NWRDR_CONTROL_CODE(0x700 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)

#define FSCTL_NWR_NCP_E3H               NWR_ANY_NCP(0x17)
#define FSCTL_NWR_NCP_E2H               NWR_ANY_NCP(0x16)
#define FSCTL_NWR_NCP_E1H               NWR_ANY_NCP(0x15)
#define FSCTL_NWR_NCP_E0H               NWR_ANY_NCP(0x14)

//
//  Macro for obtaining the parameter given to NWR_ANY_XXX when creating
//  a control code to send a UserNcp to the redirector.
//

#define ANY_NCP_OPCODE(X)      ((UCHAR)(((X) >> 2) & 0x00ff))

//
//  Macro to give the command type
//

#define IS_IT_NWR_ANY_NCP(X)            ((X & 0x1C00) == (0x400 << 2))
#define IS_IT_NWR_ANY_F2_NCP(X)         ((X & 0x1C00) == (0x500 << 2))
#define IS_IT_NWR_ANY_HANDLE_NCP(X)     ((X & 0x1C00) == (0x600 << 2))

//
// Redirector Request Packet used by the Workstation service
// to pass parameters to the Redirector through Buffer 1 of
// NtFsControlFile.
//
// Additional output of each FSCtl is found in Buffer 2.
//

#define REQUEST_PACKET_VERSION  0x00000001L // Structure version.

typedef struct _NWR_REQUEST_PACKET {

    ULONG Version;                      // Version of structure in Buffer 2

    union {


        //
        // For FSCTL_NWR_BIND_TO_TRANSPORT
        //
        struct {
            ULONG QualityOfService;     // Quality of service indicator   IN
            ULONG TransportNameLength;  // Not including terminator       IN
            WCHAR TransportName[1];     // Name of transport provider     IN
        } Bind;


        //
        // For FSCTL_NWR_LOGON
        //
        struct {
            LUID LogonId;               // User logon session identifier  IN
            ULONG UserNameLength;       // Byte count not including NULL  IN
            ULONG PasswordLength;       // Byte count not including NULL  IN
            ULONG ServerNameLength;     // Byte count not including NULL  IN
            ULONG ReplicaAddrLength;    // IPX address of the nearest dir server
                                        // replica (for NDS login only).
                                        // It's either sizeof(TDI_ADDRESS_IPX)
                                        // or 0.                          IN
            ULONG PrintOption;          // Print options for user         IN
            WCHAR UserName[1];          // User name not NULL terminated. IN

            // Password string          // Default password for connection,
                                        //    not NULL terminated, packed
                                        //    in buffer immediately after
                                        //    UserName.                   IN

            // ServerName               // Preferred server name packed in
                                        //    buffer immediately after
                                        //    Password.                   IN

            // IpxAddress               // Address copied from the SAP response
                                        // packet, packed immediately after
                                        // the servername.                IN
        } Logon;

        //
        // For FSCTL_NWR_CHANGE_PASS
        //
        struct {

            ULONG UserNameLength;
            ULONG PasswordLength;
            ULONG ServerNameLength;
            WCHAR UserName[1];

            // Password string          // New password.                  IN

            // ServerName               // Server with the new password   IN

        } ChangePass;

        //
        // For FSCTL_NWR_LOGOFF
        //
        struct {
            LUID LogonId;               // User logon session identifier  IN
        } Logoff;

        //
        // For FSCTL_NWR_DELETE_CONNECTION
        //
        struct {
            BOOLEAN UseForce;           // Force flag                     IN
        } DeleteConn;

        //
        // For FSCTL_NWR_GET_CONNECTION
        //
        struct {
            ULONG BytesNeeded;          // Size (byte count) required of
                                        //    output buffer including
                                        //    terminator                  OUT
            ULONG DeviceNameLength;     // Not including terminator       IN
            WCHAR DeviceName[4];        // Name of DOS device             IN
        } GetConn;

        //
        // FSCTL_NWR_ENUMERATE_CONNECTIONS
        //
        struct {
            ULONG EntriesRequested;    // Number of entries to get        IN
            ULONG EntriesReturned;     // Entries returned in respose buf OUT
            ULONG_PTR ResumeKey;       // Handle to next entry to get     IN OUT
            ULONG BytesNeeded;         // Size (byte count) of next entry OUT
            ULONG ConnectionType;      // Resource type requested         IN
            LUID  Uid;                 // Uid to search for               IN
        } EnumConn;

        //
        // FSCTL_NWR_SET_INFO
        //
        struct {
            ULONG PrintOption;
            ULONG MaximumBurstSize;

            ULONG PreferredServerLength; // Byte count not including NULL  IN
            ULONG ProviderNameLength;    // Byte count not including NULL  IN
            WCHAR PreferredServer[1];    // Preferred server name not NULL
                                         // terminated.
            // ProviderName string       // Provider name not NULL terminated.
                                         // Packed in buffer immediately
                                         // after PreferredServer

        } SetInfo;

        //
        // FSCTL_NWR_GET_CONN_STATUS
        //
        struct {
            ULONG ConnectionNameLength; // IN: Length of the connection name we want.
            ULONG_PTR ResumeKey;        // IN: Resume key for a continued request.
            ULONG EntriesReturned;      // OUT: Entries returned in respose buffer.
            ULONG BytesNeeded;          // OUT: Size (byte count) of next entry.
            WCHAR ConnectionName[1];    // IN: Connection name described above.
        } GetConnStatus;

        //
        // FSCTL_NWR_GET_CONN_INFO
        //
        struct {
            ULONG ConnectionNameLength; // IN: Length of the connection name we want.
            WCHAR ConnectionName[1];    // IN: Connection name described above.
        } GetConnInfo;

        //
        // FSCTL_NWR_GET_CONN_PERFORMANCE
        //
        struct {

            //
            // These are the fields for the NETCONNECTINFOSTRUCT.
            //

            DWORD dwFlags;
            DWORD dwSpeed;
            DWORD dwDelay;
            DWORD dwOptDataSize;

            //
            // This is the remote name in question.
            //

            ULONG RemoteNameLength;
            WCHAR RemoteName[1];
        } GetConnPerformance;

        struct {
            ULONG DebugFlags;           // Value for NwDebug
        } DebugValue;

    } Parameters;

} NWR_REQUEST_PACKET, *PNWR_REQUEST_PACKET;

typedef struct _NWR_NDS_REQUEST_PACKET {

    //
    // Version of structure in Buffer 2.
    //

    ULONG Version;

    union {

        //
        //  For FSCTL_NWR_NDS_RESOLVE_NAME
        //

        struct {
            ULONG ObjectNameLength;         // IN
            DWORD ResolverFlags;            // IN
            DWORD BytesWritten;             // OUT
            WCHAR ObjectName[1];            // IN
        } ResolveName;

        //
        //  For FSCTL_NWR_NDS_READ_INFO
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD BytesWritten;             // OUT
        } GetObjectInfo;

        //
        //  For FSCTL_NWR_NDS_LIST_SUBS
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD_PTR IterHandle;           // IN
            DWORD BytesWritten;             // OUT
        } ListSubordinates;

        //
        // For FSCTL_NWR_NDS_READ_ATTR
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD_PTR IterHandle;           // IN
            DWORD BytesWritten;             // OUT
            DWORD AttributeNameLength;      // IN
            WCHAR AttributeName[1];         // IN
        } ReadAttribute;

        //
        // For FSCTL_NWR_NDS_OPEN_STREAM
        //

        struct {
            DWORD FileLength;                 // OUT
            DWORD StreamAccess;               // IN
            DWORD ObjectOid;                  // IN
            UNICODE_STRING StreamName;        // IN
            WCHAR StreamNameString[1];        // IN
        } OpenStream;

        //
        // For FSCTL_NWR_NDS_SET_CONTEXT
        //

        struct {
            DWORD TreeNameLen ;               // IN
            DWORD ContextLen;                 // IN
            WCHAR TreeAndContextString[1];    // IN
        } SetContext;

        //
        // For FSCTL_NWR_NDS_GET_CONTEXT
        //

        struct {
            UNICODE_STRING Context;           // OUT
            DWORD TreeNameLen ;               // IN
            WCHAR TreeNameString[1];          // IN
        } GetContext;

        //
        // For FSCTL_NWR_NDS_VERIFY_TREE
        //

        struct {
            UNICODE_STRING TreeName;          // IN
            WCHAR NameString[1];              // IN
        } VerifyTree;

        //
        // For FSCTL_NWR_NDS_GET_QUEUE_INFO
        //

        struct {
            UNICODE_STRING QueueName;          // IN
            UNICODE_STRING HostServer;         // OUT
            DWORD QueueId;                     // OUT
        } GetQueueInfo;

        //
        // For FSCTL_NWR_NDS_GET_VOLUME_INFO
        //

        struct {
            DWORD ServerNameLen;    // OUT
            DWORD TargetVolNameLen; // OUT
            DWORD VolumeNameLen;    // IN
            WCHAR VolumeName[1];    // IN
        } GetVolumeInfo;

        //
        // For FSCTL_NWR_NDS_RAW_FRAGEX
        //

        struct {
            DWORD NdsVerb;          // IN
            DWORD RequestLength;    // IN
            DWORD ReplyLength;      // OUT
            BYTE  Request[1];       // IN
        } RawRequest;

        //
        // For FSCTL_NWR_NDS_CHANGE_PASS
        //

        struct {

            DWORD NdsTreeNameLength;
            DWORD UserNameLength;
            DWORD CurrentPasswordLength;
            DWORD NewPasswordLength;

            //
            // The above strings should be end to
            // end starting at StringBuffer.
            //

            WCHAR StringBuffer[1];
        } ChangePass;

        //
        // For FSCTL_NWR_NDS_LIST_TREES
        //

        struct {

            DWORD NtUserNameLength;   // IN
            LARGE_INTEGER UserLuid;   // OUT
            DWORD TreesReturned;      // OUT
            WCHAR NtUserName[1];      // IN
        } ListTrees;

    } Parameters;

} NWR_NDS_REQUEST_PACKET, *PNWR_NDS_REQUEST_PACKET;

//
// Structure of buffer 2 for FSCTL_NWR_GET_CONNECTION
//
typedef struct _NWR_SERVER_RESOURCE {
    WCHAR UncName[1];                   // Server resource name DOS device
                                        // is connected to; NULL terminated
} NWR_SERVER_RESOURCE, *PNWR_SERVER_RESOURCE;

//
// Structure of buffer for FSCTL_NWR_GET_MESSAGE
//

typedef struct _NWR_SERVER_MESSAGE {
    ULONG MessageOffset;   //  Offset from start of buffer to message
    LUID LogonId;          //  Logon ID
    WCHAR Server[1];       //  Source of message, NUL terminated         OUT
    //WCHAR Message[];     //  The message text, NUL terminated          OUT
} NWR_SERVER_MESSAGE, *PNWR_SERVER_MESSAGE;

#define TRANSACTION_VERSION     0x00000001L     // Structure version.
typedef struct _NWR_TRANSACTION {
    ULONG       Type;                   // Type of structure
    ULONG       Size;                   // Size of fixed portion of structure
    ULONG       Version;                // Structure version.
    ULONG       NameLength;             // Number of bytes in name (in path
                                        // format, e.g., \server\pipe\netapi\4)
    ULONG       NameOffset;             // Offset of name in buffer.
    BOOLEAN     ResponseExpected;       // Should remote system respond?
    ULONG       Timeout;                // Timeout time in milliseconds.
    ULONG       SetupWords;             // Number of trans setup words (may be
                                        // 0).  (setup words are input/output.)
    ULONG       SetupOffset;            // Offset of setup (may be 0 for none).
    ULONG       MaxSetup;               // Size of setup word array (may be 0).
    ULONG       ParmLength;             // Input param area length (may be 0).
    PVOID       ParmPtr;                // Input parameter area (may be NULL).
    ULONG       MaxRetParmLength;       // Output param. area length (may be 0).
    ULONG       DataLength;             // Input data area length (may be 0).
    PVOID       DataPtr;                // Input data area (may be NULL).
    ULONG       MaxRetDataLength;       // Output data area length (may be 0).
    PVOID       RetDataPtr;             // Output data area (may be NULL).
} NWR_TRANSACTION, *PNWR_TRANSACTION;

typedef struct _NWR_GET_CONNECTION_DETAILS {
    SERVERNAME ServerName;
    UCHAR OrderNumber;          //  Position in the Scb chain starting at 1
    UCHAR ServerAddress[12];
    UCHAR ConnectionNumberLo;
    UCHAR ConnectionNumberHi;
    UCHAR MajorVersion;
    UCHAR MinorVersion;
    BOOLEAN Preferred;
} NWR_GET_CONNECTION_DETAILS, *PNWR_GET_CONNECTION_DETAILS;

typedef struct _CONN_DETAILS2 {
   BOOL   fNds;             // TRUE if NDS, false for Bindery servers
   WCHAR  NdsTreeName[48];  // The tree name or '\0' for a 2.x or 3.x server
} CONN_DETAILS2, *PCONN_DETAILS2;


typedef struct _NWR_GET_USERNAME {
    WCHAR UserName[1];
} NWR_GET_USERNAME, *PNWR_GET_USERNAME;

typedef struct _NWR_GET_CHALLENGE_REQUEST {
    ULONG Flags;
    ULONG ObjectId;
    UCHAR Challenge[8];
    ULONG ServerNameorPasswordLength;
    WCHAR ServerNameorPassword[1];    // No NULL
} NWR_GET_CHALLENGE_REQUEST, *PNWR_GET_CHALLENGE_REQUEST;

#define CHALLENGE_FLAGS_SERVERNAME    0
#define CHALLENGE_FLAGS_PASSWORD      1

typedef struct _NWR_GET_CHALLENGE_REPLY {
    UCHAR Challenge[8];
} NWR_GET_CHALLENGE_REPLY, *PNWR_GET_CHALLENGE_REPLY;

typedef struct _NW_REDIR_STATISTICS {
    LARGE_INTEGER   StatisticsStartTime;

    LARGE_INTEGER   BytesReceived;
    LARGE_INTEGER   NcpsReceived;

    LARGE_INTEGER   BytesTransmitted;
    LARGE_INTEGER   NcpsTransmitted;

    ULONG           ReadOperations;
    ULONG           RandomReadOperations;
    ULONG           ReadNcps;
    ULONG           PacketBurstReadNcps;
    ULONG           PacketBurstReadTimeouts;

    ULONG           WriteOperations;
    ULONG           RandomWriteOperations;
    ULONG           WriteNcps;
    ULONG           PacketBurstWriteNcps;
    ULONG           PacketBurstWriteTimeouts;

    //  Connection/Session counts
    ULONG           Sessions;
    ULONG           FailedSessions;
    ULONG           Reconnects;
    ULONG           NW2xConnects;
    ULONG           NW3xConnects;
    ULONG           NW4xConnects;
    ULONG           ServerDisconnects;

    ULONG           CurrentCommands;
} NW_REDIR_STATISTICS, *PNW_REDIR_STATISTICS;

//
// CONN_STATUS structures for the new shell.
//

typedef struct _CONN_STATUS {
    DWORD   dwTotalLength;     // The total length including packed strings.
    LPWSTR  pszServerName;     // The server name.
    LPWSTR  pszUserName;       // The user name.
    LPWSTR  pszTreeName;       // The tree name or NULL for a 2.x or 3.x server.
    DWORD   nConnNum;          // The connection number used on nw srv.
    BOOL    fNds;              // TRUE if NDS, False for Bindery servers
    BOOL    fPreferred;        // TRUE if the connection is a preferred server with no explicit uses.
    DWORD   dwConnType;        // Authentication status of the connection.
} CONN_STATUS, *PCONN_STATUS;

#define NW_CONN_NOT_AUTHENTICATED            0x00000000
#define NW_CONN_BINDERY_LOGIN                0x00000001
#define NW_CONN_NDS_AUTHENTICATED_NO_LICENSE 0x00000002
#define NW_CONN_NDS_AUTHENTICATED_LICENSED   0x00000003
#define NW_CONN_DISCONNECTED                 0x00000004

typedef struct _CONN_INFORMATION {
    DWORD HostServerLength;
    LPWSTR HostServer;
    DWORD UserNameLength;
    LPWSTR UserName;
} CONN_INFORMATION, *PCONN_INFORMATION;

#endif  // ifndef _NTDDNWFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\br\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Versao incorreta do DOS"
NLS_MSG_002     equ     "Suporte a VDM IPX/SPX j carregado"
NLS_MSG_003     equ     "Nao  possvel carregar o suporte a VDM IPX/SPX"
NLS_MSG_004     equ     "Redirecionador Vdm NetWare j carregado"
NLS_MSG_005     equ     "Nao  possvel carregar o redirecionador Vdm NetWare"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\nwxchg.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwxchg.h

Abstract:

    Header for generic NCP calling routine.

Author:

    Rita Wong      (ritaw)      11-Mar-1993

Environment:


Revision History:

--*/

#ifndef _NW_XCHG_INCLUDED_
#define _NW_XCHG_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

NTSTATUS
NwlibMakeNcp(
    IN HANDLE DeviceHandle,
    IN ULONG FsControlCode,
    IN ULONG RequestBufferSize,
    IN ULONG ResponseBufferSize,
    IN PCHAR FormatString,
    ...                           // Arguments to FormatString
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _NW_XCHG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\ndsapi32.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsLib32.h

Abstract:

    This module exposes the minimal win32 API to Netware directory
    services support in the Netware redirector.

Author:

    Cory West    [CoryWest]    23-Feb-1995

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdef.h>

#include <stdio.h>
#include <ntddnwfs.h>

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
NwNdsOpenTreeHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT PHANDLE  phNwRdrHandle
);

// NwNdsOpenTreeHandle( PUNICODE_STRING, PHANDLE )
//
// Given an NDS tree name, this opens a handle the the redirector
// for accessing that tree.  The handle should closed using the
// standard NT CloseHandle() call. This function is only a
// simple wrapper around NT OpenFile().

//
// Administrativa.
//

#define HANDLE_TYPE_NCP_SERVER  1
#define HANDLE_TYPE_NDS_TREE    2

NTSTATUS
NwNdsOpenGenericHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwRdrHandle
);

// NwNdsOpenGenericHandle( PUNICODE_STRING, LPDWORD, PHANDLE )
//
// Given a name, this opens a handle the the redirector for accessing that
// named tree or server. lpdwHandleType is set to either HANDLE_TYPE_NCP_SERVER
// or HANDLE_TYPE_NDS_TREE accordingly. The handle should be closed using
// the standard NT CloseHandle() call. This function is only a simple
// wrapper around NT OpenFile().

NTSTATUS
NwOpenHandleWithSupplementalCredentials(
    IN PUNICODE_STRING puResourceName,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwHandle
);

// NwOpenHandleWithSupplementalCredentials
//
// Given a resource name (either a server name or a tree name),
// open a handle to that resource with the provided username and
// password.  As with the open generic handle routine, lpdsHandleType
// will be set to either HANDLE_TYPE_NCP_SERVER or
// HANDLE_TYPE_NDS_TREE based on the result of the open.

//
// Administrativa.
//

NTSTATUS
NwNdsSetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    IN PUNICODE_STRING puContext
);

// NwNdsSetTreeContext(HANDLE, PUNICODE_STRING, PUNICODE_STRING)
//
// Set the current context for the specified tree.
//
// Arguments:
//
//     HANDLE hNdsRdr - A handle to the redirector.
//     PUNICODE_STRING puTree - The tree name.
//     PUNICODE_STRING puContext - The context in that tree.

NTSTATUS
NwNdsGetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    OUT PUNICODE_STRING puContext
);

// NwNdsGetTreeContext(HANDLE, PUNICODE_STRING, PUNICODE_STRING)
//
// Get the current context for the specified tree.
//
// Arguments:
//
//     HANDLE hNdsRdr - A handle to the redirector.
//     PUNICODE_STRING puTree - The tree name.
//     PUNICODE_STRING puContext - The context in that tree.

NTSTATUS
NwNdsIsNdsConnection (
    IN     HANDLE hNdsRdr,
    OUT    BOOL * pfIsNds,
    IN OUT PUNICODE_STRING puTree
);

// NwNdsIsNdsConnection(HANDLE, PUNICODE_STRING)
//
// Get the current context for the specified tree.
//
// Arguments:
//
//     HANDLE hNdsRdr - A handle to the redirector.
//     BOOL *         - Get the boolean value of connection test
//     PUNICODE_STRING puTree - The tree name that handle to server
//                              represents. Caller allocates puTree
//                              with a buffer big enough to hold
//                              48 WCHARs.
//
// Returns: TRUE if hNdsRdr is a handle connected to a server that
//          is part of a NDS directory tree. puTree will contain
//          the tree name.
//          FALSE: if hNdsRdr is not a NDS tree handle.

//
// Browsing and Navigating support.
//

NTSTATUS
NwNdsResolveName (
    IN HANDLE           hNdsTree,
    IN PUNICODE_STRING  puObjectName,
    OUT DWORD           *dwObjectId,
    OUT PUNICODE_STRING puReferredServer,
    OUT PBYTE           pbRawResponse,
    IN DWORD            dwResponseBufferLen
);

// NwNdsResolveName(HANDLE, PUNICODE_STRING, PDWORD)
//
// Resolve the given name to an NDS object id.  This utilizes
// NDS verb 1.
//
// There is currently no interface for canonicalizing names.
// This call will use the default context if one has been set
// for this NDS tree.
//
// puReferredServer must point to a UNICODE_STRING with enough
// space to hold a server name (MAX_SERVER_NAME_LENGTH) *
// sizeof( WCHAR ).
//
// If dwResponseBufferLen is not 0, and pbRawResponse points
// to a writable buffer of length dwResponseBufferLen, then
// this routine will also return the entire NDS response in
// the raw response buffer.  The NDS response is described
// by NDS_RESPONSE_RESOLVE_NAME.
//
// Arguments:
//
//     HANDLE hNdsTree - The name of the NDS tree that we are interested in looking into.
//     PUNICODE_STRING puObjectName - The name that we want resolved into an object id.
//     DWORD *dwObjectId - The place where we will place the object id.
//     BYTE *pbRawResponse - The raw response buffer, if desired.
//     DWORD dwResponseBufferLen - The length of the raw response buffer.

NTSTATUS
NwNdsList (
   IN HANDLE   hNdsTree,
   IN DWORD    dwObjectId,
   OUT DWORD   *dwIterHandle,
   OUT BYTE    *pbReplyBuf,
   IN DWORD    dwReplyBufLen
);

// NwNdsList(HANDLE, DWORD, PDWORD, PBYTE, DWORD, PDWORD)
//
// List the immediate subordinates of an object.  This utilizes
// NDS verb 5.
//
// Arguments:
//
//     HANDLE hNdsTree - The handle to the tree that we are interested in.
//     DWORD dwObjectId - The object that we want to list.
//     DWORD *dwIterHandle - The iteration handle to be used in continuing
//         the request if the buffer is not large enough for the entire
//         list of subordinates.
//     BYTE *pbReplyBuf - The buffer where the raw reply will be placed.
//     DWORD dwReplyBufLen - The length of the raw reply buffer.

NTSTATUS
NwNdsReadObjectInfo(
    IN HANDLE    hNdsTree,
    IN DWORD     dwObjectId,
    OUT PBYTE    pbReplyBuf,
    IN DWORD     dwReplyBufLen
);

// NwNdsReadObjectInfo(PUNICODE_STRING, DWORD, PBYTE, DWORD)
//
// Given an object id, this gets the basic info for the object.  This
// utilizes NDS verb 2.  The reply buffer should be large enough to
// hold a DS_OBJ_INFO struct and the text of the two unicode strings.
//
// Arguments:
//
//     HANDLE hNdsTree - The tree that we want to look in.
//     DWORD dwObjectId - The object id that we want to learn about.
//     BYTE *pbReplyBuf - The space for the reply.
//     DWORD dwReplyBufLen - The length of the reply buffer.

NTSTATUS
NwNdsReadAttribute (
   IN HANDLE          hNdsTree,
   IN DWORD           dwObjectId,
   IN DWORD           *dwIterHandle,
   IN PUNICODE_STRING puAttrName,
   OUT BYTE           *pbReplyBuf,
   IN DWORD           dwReplyBufLen
);

// NwNdsReadAttribute(HANDLE, DWORD, PDWORD, PUNICODE_STRING, PBYTE, DWORD)
//
// Read the requested attribute from the listed object.
// This utilizes NDS verb 3.
//
// Arguments:
//
//     HANDLE hNdsTree - The tree that we want to read from.
//     DWORD dwObjectId - The object that we want to read from.
//     DWORD *dwIterHandle - The iteration handle.
//     PUNICODE_STRING puAttrName - The name of the attribute.
//     BYTE *pbReplyBuf - The buffer to hold the response.
//     DWORD deReplyBufLen - The length of the reply buffer.

NTSTATUS
NwNdsOpenStream (
    IN HANDLE          hNdsTree,
    IN DWORD           dwObjectId,
    IN PUNICODE_STRING puStreamName,
    IN DWORD           dwOpenFlags,
    OUT DWORD          *pdwFileLength
);

// NwNdsOpenStream(HANDLE, DWORD, PBYTE, DWORD)
//
// Open a file handle to the stream listed.
// This utilizes NDS verb 27.
//
// Arguments:
//
//     HANDLE hNdsTree - The handle to the NDS tree that we are interested in.
//     DWORD dwObjectId - The object id that we want to query.
//     PUNICODE_STRING puStreamName - The name of the stream that we want to open.
//     DWORD dwOpenFlags - 1 for read, 2 for write, 3 for read/write.
//     DWORD *pdwFileLength - The length of the file stream.

NTSTATUS
NwNdsGetQueueInformation(
    IN HANDLE            hNdsTree,
    IN PUNICODE_STRING   puQueueName,
    OUT PUNICODE_STRING  puHostServer,
    OUT PDWORD           pdwQueueId
);

// NwNdsGetQueueInformation(HANDLE, PUNICODE_STRING, PUNICODE_STRING, PDWORD)
//
// Arguments:
//
//     HANDLE hNdsTree - The handle to the NDS tree that knows about the queue.
//     PUNICODE_STRING puQueueName - The ds path to the queue that we want.
//     PUNICODE_STRING puHostServer - The host server for this queue.
//     PDWORD pdwQueueId - The queue id for this queue on this server.

NTSTATUS
NwNdsGetVolumeInformation(
    IN HANDLE            hNdsTree,
    IN PUNICODE_STRING   puVolumeName,
    OUT PUNICODE_STRING  puHostServer,
    OUT PUNICODE_STRING  puHostVolume
);

// NwNdsGetVoluemInformation(HANDLE, PUNICODE_STRING, PUNICODE_STRING, PUNICODE_STRING)
//
// Arguments:
//
//     HANDLE hNdsTree - The handle to the NDS tree that knows about the volume.
//     PUNICODE_STRING puVolumeName - The ds path to the volume that we want.
//     PUNICODE_STRING puHostServer - The host server for this nds volume.
//     PUNICODE_STRING puHostVolume - The host volume for this nds volume.

//
// User mode fragment exchange.
//

NTSTATUS
_cdecl
FragExWithWait(
    IN HANDLE  hNdsServer,
    IN DWORD   NdsVerb,
    IN BYTE    *pReplyBuffer,
    IN DWORD   pReplyBufferLen,
    IN OUT DWORD *pdwReplyLen,
    IN BYTE    *NdsRequestStr,
    ...
);

NTSTATUS
_cdecl
ParseResponse(
    PUCHAR  Response,
    ULONG ResponseLength,
    char*  FormatString,
    ...
);

int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
);

//
// Change password support.
//

NTSTATUS
NwNdsChangePassword(
    IN HANDLE          hNwRdr,
    IN PUNICODE_STRING puTreeName,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puCurrentPassword,
    IN PUNICODE_STRING puNewPassword
);

#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\validc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    validc.h

Abstract:

    Strings of valid/invalid characters for canonicalization

Author:

    Richard Firth (rfirth) 15-May-1991

Revision History:

    03-Jan-1992 rfirth
        Added ILLEGAL_FAT_CHARS and ILLEGAL_HPFS_CHARS (from fsrtl\name.c)

    27-Sep-1991 JohnRo
        Changed TEXT macro usage to allow UNICODE.

    19-Feb-1993 RitaW
        Ported for NetWare use.

--*/

//
// Disallowed control characters (not including \0)
//

#define CTRL_CHARS_0   L"\001\002\003\004\005\006\007"
#define CTRL_CHARS_1   L"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2   L"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3   L"\030\031\032\033\034\035\036\037"

#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

//
// Character subsets
//

#define NON_COMPONENT_CHARS L"\\/:"
#define ILLEGAL_CHARS_STR   L"\"<>|"
#define SPACE_STR           L" "
#define PATH_SEPARATORS     L"\\/"

//
// Combinations of the above
//

#define ILLEGAL_CHARS       CTRL_CHARS_STR ILLEGAL_CHARS_STR
#define ILLEGAL_NAME_CHARS_STR  L"\"/\\[]:|<>+;,?" CTRL_CHARS_STR  // "=" removed for NDS

#define STANDARD_ILLEGAL_CHARS  ILLEGAL_NAME_CHARS_STR L"*"
#define SERVER_ILLEGAL_CHARS    STANDARD_ILLEGAL_CHARS SPACE_STR

//
// Characters which may not appear in a canonicalized FAT filename are:
//
//  0x00 - 0x1f " * + , / : ; < = > ? [ \ ] |      
//

#define ILLEGAL_FAT_CHARS   CTRL_CHARS_STR L"\"*+,/:;<=>?[\\]|"

//
// Characters which may not appear in a canonicalized HPFS filename are:
//
//  0x00 - 0x1f " * / : < > ? \ |
//

#define ILLEGAL_HPFS_CHARS  CTRL_CHARS_STR L"\"*/:<>?\\|"


//
// Checks if the token contains all valid characters
//
#define IS_VALID_TOKEN(_Str, _StrLen) \
    ((BOOL) (wcscspn((_Str), STANDARD_ILLEGAL_CHARS) == (_StrLen)))

//
// Checks if the server name contains all valid characters for the server name
//
#define IS_VALID_SERVER_TOKEN(_Str, _StrLen) \
    ((BOOL) (wcscspn((_Str), SERVER_ILLEGAL_CHARS) == (_StrLen)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\chs\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "ȷ DOS 汾"
NLS_MSG_002     equ     "VDM IPX/SPX ֧Ѿ"
NLS_MSG_003     equ     "ܼ VDM IPX/SPX ֧"
NLS_MSG_004	equ	"Vdm NetWare ضѾ"
NLS_MSG_005	equ	"Vdm NetWare ضܼ"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\nwpkstr.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwpkstr.h

Abstract:

    Header for NetWare string packing library routines.

Author:

    Rita Wong      (ritaw)      2-Mar-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NW_PKSTR_INCLUDED_
#define _NW_PKSTR_INCLUDED_

BOOL
NwlibCopyStringToBuffer(
    IN LPCWSTR SourceString OPTIONAL,
    IN DWORD   CharacterCount,
    IN LPCWSTR FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

#endif // _NW_PKSTR_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\cht\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Incorrect DOS Version"
NLS_MSG_002     equ     "VDM IPX/SPX support is already loaded"
NLS_MSG_003     equ     "Cannot load VDM IPX/SPX support"
NLS_MSG_004	equ	"The Vdm NetWare Redirector is already loaded"
NLS_MSG_005	equ	"The Vdm NetWare Redirector cannot be loaded"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\es\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
	Created

--*/

endif

NLS_MSG_001     equ     "Versin incorrecta de DOS"
NLS_MSG_002     equ     "Ya se ha cargado la compatibilidad con VDM IPX/SPX"
NLS_MSG_003     equ     "No se puede cargar la compatibilidad con VDM IPX/SPX"
NLS_MSG_004     equ     "Ya se ha cargado el redirector de Vdm NetWare"
NLS_MSG_005     equ     "No se puede cargar el redirector Vdm NetWare"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\fr\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Version de DOS incorrecte"
NLS_MSG_002     equ     "Le support IPX/SPX VDM est dj charg"
NLS_MSG_003     equ     "Impossible de charger le support IPX/SPX VDM"
NLS_MSG_004	equ	"Le redirecteur NetWare Vdm est dj charg"
NLS_MSG_005	equ	"Impossible de charger le redirecteur NetWare Vdm"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\cs\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Nesprvn verze systmu DOS"
NLS_MSG_002     equ     "Podpora VDM IPX/SPX je ji natena"
NLS_MSG_003     equ     "Nelze nast podporu VDM IPX/SPX"
NLS_MSG_004     equ     "Pesmrova NetWare VDM je ji naten"
NLS_MSG_005     equ     "Pesmrova NetWare VDM nelze nast"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\ger\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Falsche DOS-Version"
NLS_MSG_002     equ     "VDM-IPX/SPX-Untersttzung ist bereits geladen."
NLS_MSG_003     equ     "VDM-IPX/SPX-Untersttzung kann nicht geladen werden."
NLS_MSG_004	equ	"Der VDM-NetWare-Redirector ist bereits geladen."
NLS_MSG_005	equ	"Der VDM-NetWare-Redirector kann nicht geladen werden."
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\hu\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Nem megfelel DOS verzi."
NLS_MSG_002     equ     "A VDM IPX/SPX tmogats mr be van tltve."
NLS_MSG_003     equ     "A VDM IPX/SPX tmogatst nem lehet betlteni."
NLS_MSG_004     equ     "A Vdm NetWare tirnyt mr be van tltve."
NLS_MSG_005     equ     "A Vdm NetWare tirnytt nem lehet betlteni."
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\it\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
	Created

--*/

endif

NLS_MSG_001     equ     "Versione DOS non valida"
NLS_MSG_002     equ     "Supporto VDM IPX/SPX gi caricato"
NLS_MSG_003     equ     "Impossibile caricare il supporto VDM IPX/SPX"
NLS_MSG_004     equ     "Il redirector Vdm NetWare  gi caricato"
NLS_MSG_005     equ     "Impossibile caricare il redirector Vdm NetWare"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\jpn\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "DOS ̃o[WԈĂ܂"
NLS_MSG_002     equ     "VDM IPX/SPX T|[g͊ɓǂݍ܂Ă܂"
NLS_MSG_003     equ     "VDM IPX/SPX T|[gǂݍ߂܂"
NLS_MSG_004	equ	"Vdm NetWare Redirector ͊ɓǂݍ܂Ă܂"
NLS_MSG_005	equ	"Vdm NetWare Redirector ǂݍ߂܂"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\usa\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Incorrect DOS Version"
NLS_MSG_002     equ     "VDM IPX/SPX support is already loaded"
NLS_MSG_003     equ     "Cannot load VDM IPX/SPX support"
NLS_MSG_004	equ	"The Vdm NetWare Redirector is already loaded"
NLS_MSG_005	equ	"The Vdm NetWare Redirector cannot be loaded"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\kor\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Incorrect DOS  Ʋϴ."
NLS_MSG_002     equ     "VDM IPX/SPX  ̹ εǾϴ."
NLS_MSG_003     equ     "VDM IPX/SPX  ε  ϴ."
NLS_MSG_004	equ	"VDM NetWare Ͱ ̹ εǾϴ."
NLS_MSG_005	equ	"VDM NetWare ͸ ε  ϴ."
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\sv\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
	Created

--*/

endif

NLS_MSG_001     equ     "Felaktig DOS-version"
NLS_MSG_002     equ     "VDM IPX/SPX-std r redan inlst"
NLS_MSG_003     equ     "Det gick inte att lsa in VDM IPX/SPX-std"
NLS_MSG_004     equ     "VDM NetWare-omdirigeraren r redan inlst"
NLS_MSG_005     equ     "Det gick inte att lsa in VDM NetWare-omdirigeraren"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\ru\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "ࠢ쭠  DOS"
NLS_MSG_002     equ     "প VDM IPX/SPX 㦥 㦥"
NLS_MSG_003     equ     " 㧨 প VDM IPX/SPX"
NLS_MSG_004     equ     "Vdm NetWare Redirector 㦥 㦥"
NLS_MSG_005     equ     " 㧨 Vdm NetWare Redirector"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\pl\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif


NLS_MSG_001     equ     "Niepoprawna wersja systemu DOS"
NLS_MSG_002     equ     "Obsuga VDM IPX/SPX jest ju zaadowana"
NLS_MSG_003     equ     "Nie mona zaadowa obsugi VDM IPX/SPX"
NLS_MSG_004     equ     "Readresator Vdm NetWare jest ju zaadowany"
NLS_MSG_005     equ     "Nie mona zaadowa readresatora Vdm NetWare"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\pt\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif


NLS_MSG_001     equ     "Versao incorrecta de DOS"
NLS_MSG_002     equ     "J est carregado o suporte VDM IPX/SPX"
NLS_MSG_003     equ     "Impossvel carregar o suporte VDM IPX/SPX"
NLS_MSG_004	equ	"J est carregado o Vdm NetWare Redirector"
NLS_MSG_005	equ	"Impossvel carregar o Vdm NetWare Redirector"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\nl\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Onjuiste DOS-versie"
NLS_MSG_002     equ     "Ondersteuning voor VDM IPX/SPX is al geladen"
NLS_MSG_003     equ     "Kan geen ondersteuning voor VDM IPX/SPX laden"
NLS_MSG_004	equ	"De VDM NetWare-redirector is al geladen"
NLS_MSG_005	equ	"Kan de VDM NetWare-redirector niet laden"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\inc\tr\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Yanl DOS Srm"
NLS_MSG_002     equ     "VDM IPX/SPX destei zaten ykl"
NLS_MSG_003     equ     "VDM IPX/SPX destei yklenemiyor"
NLS_MSG_004	equ	"Vdm NetWare Ynlendiricisi zaten ykl"
NLS_MSG_005	equ	"Vdm NetWare Ynlendiricisi yklenemiyor"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\setupdll\dllinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contians the DLL attach/detach event entry point for
    a Setup support DLL.

Author:

    Ted Miller (tedm) July-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <overflow.h>

HINSTANCE ThisDLLHandle;

BOOL
DLLInit(
    IN HINSTANCE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
        break;

    case DLL_PROCESS_DETACH:

        //  Delete all automatically established connections
        //  See UNC handling in netcon.c.
        //
        //  This doesn't work, because the unload sequence
        //  is different for "lazy" load DLLs than for load-time DLLs.
        //  INFs must be responsible for calling DeleteAllConnections().
        //
        //  DeleteAllConnectionsWorker() ;
        //
        break ;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\setupdll\nwcfg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

        nwcfg.h

        history:
                thomaspa  1/24/94        Created
*/


#ifndef _NWCFG_H_
#define _NWCFG_H_

#define PROVIDER_NAME 101

#endif // _NWCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\setupdll\common.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

common.h

    constants and globals that are common to LODCTR and UNLODCTR

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

--*/
#ifndef _LODCTR_COMMON_H_
#define _LODCTR_COMMON_H_
//
//  Local constants
//
#define RESERVED                0L
#define LARGE_BUFFER_SIZE       0x10000         // 64K
#define MEDIUM_BUFFER_SIZE      0x8000          // 32K
#define SMALL_BUFFER_SIZE       0x1000          //  4K
#define FILE_NAME_BUFFER_SIZE   MAX_PATH
#define DISP_BUFF_SIZE          256L
#define SIZE_OF_OFFSET_STRING   15
//
//  Data structure and type definitions
//
typedef struct _NAME_ENTRY {
    struct _NAME_ENTRY  *pNext;
    DWORD               dwOffset;
    DWORD               dwType;
    LPTSTR              lpText;
} NAME_ENTRY, *PNAME_ENTRY;

typedef struct _LANGUAGE_LIST_ELEMENT {
    struct _LANGUAGE_LIST_ELEMENT   *pNextLang;     // next lang. list
    LPTSTR  LangId;                                 // lang ID string for this elem
    PNAME_ENTRY pFirstName;                         // head of name list
    PNAME_ENTRY pThisName;                          // pointer to current entry
    DWORD   dwNumElements;                          // number of elements in array
    DWORD   dwNameBuffSize;
    DWORD   dwHelpBuffSize;
    PBYTE   NameBuffer;                             // buffer to store strings
    PBYTE   HelpBuffer;                             // buffer to store help strings
} LANGUAGE_LIST_ELEMENT, *PLANGUAGE_LIST_ELEMENT;

typedef struct _SYMBOL_TABLE_ENTRY {
    struct _SYMBOL_TABLE_ENTRY    *pNext;
    LPTSTR  SymbolName;
    DWORD   Value;
} SYMBOL_TABLE_ENTRY, *PSYMBOL_TABLE_ENTRY;
//
//  Utility Routine prototypes for routines in common.c
//
#define StringToInt(in,out) \
    (((_stscanf ((in), TEXT(" %d"), (out))) == 1) ? TRUE : FALSE)


#if _INITIALIZE_GLOBALS_
//
//
//  Text string Constant definitions
//
const LPTSTR NamesKey = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
const LPTSTR DefaultLangId = TEXT("009");
const LPTSTR Counters = TEXT("Counters");
const LPTSTR Help = TEXT("Help");
const LPTSTR VersionStr = TEXT("Version");
const LPTSTR LastHelp = TEXT("Last Help");
const LPTSTR LastCounter = TEXT("Last Counter");
const LPTSTR FirstHelp = TEXT("First Help");
const LPTSTR FirstCounter = TEXT("First Counter");
const LPTSTR Busy = TEXT("Updating");
const LPTSTR Slash = TEXT("\\");
const LPTSTR BlankString = TEXT(" ");
const LPSTR  BlankAnsiString = " ";
const LPTSTR DriverPathRoot = TEXT("SYSTEM\\CurrentControlSet\\Services");
const LPTSTR Performance = TEXT("Performance");
const LPTSTR CounterNameStr = TEXT("Counter ");
const LPTSTR HelpNameStr = TEXT("Explain ");
const LPTSTR AddCounterNameStr = TEXT("Addcounter ");
const LPTSTR AddHelpNameStr = TEXT("Addexplain ");

//
//  Global Buffers
//
TCHAR   DisplayStringBuffer[DISP_BUFF_SIZE];
CHAR    TextFormat[DISP_BUFF_SIZE];
HANDLE  hMod = NULL;    // process handle
DWORD   dwLastError = ERROR_SUCCESS;

#else   // just declare the globals

extern const LPTSTR NamesKey;
extern const LPTSTR VersionStr;
extern const LPTSTR DefaultLangId;
extern const LPTSTR Counters;
extern const LPTSTR Help;
extern const LPTSTR LastHelp;
extern const LPTSTR LastCounter;
extern const LPTSTR FirstHelp;
extern const LPTSTR FirstCounter;
extern const LPTSTR Busy;
extern const LPTSTR Slash;
extern const LPTSTR BlankString;
extern const LPSTR  BlankAnsiString;
extern const LPTSTR DriverPathRoot;
extern const LPTSTR Performance;
//
//  Global Buffers
//
extern TCHAR   DisplayStringBuffer[DISP_BUFF_SIZE];
extern CHAR    TextFormat[DISP_BUFF_SIZE];
extern HANDLE  hMod;
extern DWORD   dwLastError;

#endif // _INITIALIZE_GLOBALS_

#endif  // _LODCTR_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\setupdll\removesz.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

RemoveSzFromFile() - remove a specified string from the file

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <nwcfg.hxx>


BOOL
RemoveSzFromFile( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    FILE * hsrcfile;
    FILE * hdesfile;
    char * pszTempname;
    char szInput[1000];

    pszTempname = tmpnam(NULL);
    wsprintf(achBuff,"{1}");
    *ppszResult = achBuff;
    if ( nArgs != 2 )
    {
        return(FALSE);
    }
    hsrcfile = fopen(apszArgs[0],"r");
    hdesfile = fopen(pszTempname,"w");
    if (( hsrcfile != NULL ) && ( hdesfile != NULL ))
    {
        while (fgets(szInput,1000,hsrcfile))
        {
            if (_stricmp(szInput,apszArgs[1])!=0)
            {
                fputs(szInput,hdesfile);
            }
        }
    }
    if ( hsrcfile != NULL )
        fclose(hsrcfile);
    if ( hdesfile != NULL )
        fclose(hdesfile);
    if (( hsrcfile != NULL ) && ( hdesfile != NULL ))
    {
        CopyFileA(pszTempname,apszArgs[0], FALSE);
        DeleteFileA(pszTempname);
    }

    wsprintf(achBuff,"{0}");
    *ppszResult = achBuff;
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\setupdll\lodctr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lodctr.c

Abstract:

    Program to read the contents of the file specified in the command line
        and update the registry accordingly

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

    a-robw  25-Feb-93   revised calls to make it compile as a UNICODE or
                        an ANSI app.

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
//
//  Windows Include files
//
#include <windows.h>
#include <winperf.h>
#include <tchar.h>
//
#define _INITIALIZE_GLOBALS_ 1
#include "common.h"
#undef _INITIALIZE_GLOBALS_

#define TYPE_HELP   1
#define TYPE_NAME   2

#include "nwcfg.hxx"

#define  OLD_VERSION 0x010000
DWORD    dwSystemVersion;


BOOL
GetDriverName (
    IN  LPTSTR  lpIniFile,
    OUT LPTSTR  *lpDevName
)
/*++
GetDriverName

    looks up driver name in the .ini file and returns it in lpDevName

Arguments

    lpIniFile

        Filename of ini file

    lpDevName

        pointer to pointer to reciev buffer w/dev name in it

Return Value

    TRUE if found
    FALSE if not found in .ini file

--*/
{
    DWORD   dwRetSize;

    if (lpDevName) {
        dwRetSize = GetPrivateProfileString (
            TEXT("info"),       // info section
            TEXT("drivername"), // driver name value
            TEXT("drivernameNotFound"),   // default value
            *lpDevName,
            DISP_BUFF_SIZE,
            lpIniFile);
        
        if ((lstrcmpi(*lpDevName, TEXT("drivernameNotFound"))) != 0) {
            // name found
            return TRUE;
        } else {
            // name not found, default returned so return NULL string
            lstrcpy(*lpDevName,TEXT("\0"));
            return FALSE;
        }
    } else {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
}

BOOL
BuildLanguageTables (
    IN  LPTSTR  lpIniFile,
    IN OUT PLANGUAGE_LIST_ELEMENT   pFirstElem
)
/*++

BuildLanguageTables
    
    Creates a list of structures that will hold the text for
    each supported language

Arguments
    
    lpIniFile

        Filename with data

    pFirstElem

        pointer to first list entry

ReturnValue

    TRUE if all OK
    FALSE if not

--*/
{

    LPTSTR  lpEnumeratedLangs;
    LPTSTR  lpThisLang;
    
    PLANGUAGE_LIST_ELEMENT   pThisElem;

    DWORD   dwSize;

    lpEnumeratedLangs = malloc(SMALL_BUFFER_SIZE * sizeof(TCHAR));

    if (!lpEnumeratedLangs) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    dwSize = GetPrivateProfileString (
        TEXT("languages"),
        NULL,                   // return all values in multi-sz string
        TEXT("009"),            // english as the default
        lpEnumeratedLangs,
        SMALL_BUFFER_SIZE,
        lpIniFile);

    // do first language

    lpThisLang = lpEnumeratedLangs;
    pThisElem = pFirstElem;

    while (*lpThisLang) {
        pThisElem->pNextLang = NULL;

        pThisElem->LangId = (LPTSTR) malloc ((lstrlen(lpThisLang) + 1) * sizeof(TCHAR));
        if (pThisElem->LangId == NULL) {
            free(lpEnumeratedLangs);
            SetLastError (ERROR_OUTOFMEMORY);
            return FALSE;
        }

        lstrcpy (pThisElem->LangId, lpThisLang);
        pThisElem->pFirstName = NULL;
        pThisElem->pThisName = NULL;
        pThisElem->dwNumElements=0;
        pThisElem->NameBuffer = NULL;
        pThisElem->HelpBuffer = NULL;

        // go to next string

        lpThisLang += lstrlen(lpThisLang) + 1;

        if (*lpThisLang) {  // there's another so allocate a new element
            pThisElem->pNextLang = malloc (sizeof(LANGUAGE_LIST_ELEMENT));
            if (!pThisElem) {
                free(pThisElem->LangId);
                free(lpEnumeratedLangs);
                SetLastError (ERROR_OUTOFMEMORY);
                return FALSE;   
            }
            pThisElem = pThisElem->pNextLang;   // point to new one
        }
    }

    free(lpEnumeratedLangs);
    return TRUE;
}

BOOL
LoadIncludeFile (
    IN LPTSTR lpIniFile,
    OUT PSYMBOL_TABLE_ENTRY   *pTable
)
/*++

LoadIncludeFile

    Reads the include file that contains symbolic name definitions and
    loads a table with the values defined

Arguments

    lpIniFile

        Ini file with include file name

    pTable

        address of pointer to table structure created
Return Value

    TRUE if table read or if no table defined
    FALSE if error encountere reading table

--*/
{
    INT         iNumArgs;

    DWORD       dwSize;

    BOOL        bReUse;
    BOOL        bReturn = TRUE;

    PSYMBOL_TABLE_ENTRY   pThisSymbol;

    LPTSTR      lpIncludeFileName = NULL;
    LPSTR       lpIncludeFile = NULL;
    LPSTR       lpLineBuffer  = NULL;
    LPSTR       lpAnsiSymbol  = NULL;

    FILE        *fIncludeFile;
    HFILE       hIncludeFile;
    OFSTRUCT    ofIncludeFile;

    lpIncludeFileName = malloc (MAX_PATH * sizeof (TCHAR));
    lpIncludeFile = malloc (MAX_PATH);
    lpLineBuffer = malloc (DISP_BUFF_SIZE);
    lpAnsiSymbol = malloc (DISP_BUFF_SIZE);

    if (!lpIncludeFileName || !lpIncludeFile || !lpLineBuffer || !lpAnsiSymbol) {
        if (lpIncludeFileName) {
            free(lpIncludeFileName);
        }
        if (lpIncludeFile) {
            free(lpIncludeFile);
        }
        if (lpLineBuffer) {
            free(lpLineBuffer);
        }
        if (lpAnsiSymbol) {
            free(lpAnsiSymbol);
        }

        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;    
    }

    // get name of include file (if present)

    dwSize = GetPrivateProfileString (
            TEXT("info"),
            TEXT("symbolfile"),
            TEXT("SymbolFileNotFound"),
            lpIncludeFileName,
            _msize(lpIncludeFileName),
            lpIniFile);

    if ((lstrcmpi(lpIncludeFileName, TEXT("SymbolFileNotFound"))) == 0) {
        // no symbol file defined
        *pTable = NULL;
        goto CleanUp2;
    }

    // if here, then a symbol file was defined and is now stored in 
    // lpIncludeFileName
            
    CharToOem (lpIncludeFileName, lpIncludeFile);

    hIncludeFile = OpenFile (
        lpIncludeFile,
        &ofIncludeFile,
        OF_PARSE);

    if (hIncludeFile == HFILE_ERROR) { // unable to read include filename
        // error is already in GetLastError
        *pTable = NULL;
        bReturn = FALSE;
        goto CleanUp2;
    } else {
        // open a stream 
        fIncludeFile = fopen (ofIncludeFile.szPathName, "rt");

        if (!fIncludeFile) {
            *pTable = NULL;
            bReturn = FALSE;
            goto CleanUp2;
        }
    }
        
    //
    //  read ANSI Characters from include file
    //

    bReUse = FALSE;

    while (fgets(lpLineBuffer, DISP_BUFF_SIZE, fIncludeFile) != NULL) {
        if (strlen(lpLineBuffer) > 8) {
            if (!bReUse) {
                if (*pTable) {
                    // then add to list
                    pThisSymbol->pNext = malloc (sizeof (SYMBOL_TABLE_ENTRY));
                    pThisSymbol = pThisSymbol->pNext;
                } else { // allocate first element
                    *pTable = malloc (sizeof (SYMBOL_TABLE_ENTRY));
                    pThisSymbol = *pTable;
                }

                if (!pThisSymbol) {
                    SetLastError (ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                    goto CleanUp;
                }

                // allocate room for the symbol name by using the line length
                // - the size of "#define "

//                pThisSymbol->SymbolName = malloc ((strlen(lpLineBuffer) - 8) * sizeof (TCHAR));
                pThisSymbol->SymbolName = malloc (DISP_BUFF_SIZE * sizeof (TCHAR));

                if (!pThisSymbol->SymbolName) {
                    SetLastError (ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                    goto CleanUp;
                }

            }

            // all the memory is allocated so load the fields

            pThisSymbol->pNext = NULL;

            iNumArgs = sscanf (lpLineBuffer, "#define %s %d",
                lpAnsiSymbol, &pThisSymbol->Value);

            if (iNumArgs != 2) {
                *(pThisSymbol->SymbolName) = TEXT('\0');
                pThisSymbol->Value = (DWORD)-1L;
                bReUse = TRUE;
            }  else {
                OemToCharBuff (lpAnsiSymbol, pThisSymbol->SymbolName, DISP_BUFF_SIZE);
                pThisSymbol->SymbolName[DISP_BUFF_SIZE -1] = '\0'; // make sure string is terminated
                bReUse = FALSE;
            }
        }
    }
CleanUp:
    fclose (fIncludeFile);
CleanUp2:
    if (lpIncludeFileName) free (lpIncludeFileName);
    if (lpIncludeFile) free (lpIncludeFile);
    if (lpLineBuffer) free (lpLineBuffer);
    if (lpAnsiSymbol) free (lpAnsiSymbol);

    return bReturn;
}

BOOL
ParseTextId (
    IN LPTSTR  lpTextId,
    IN PSYMBOL_TABLE_ENTRY pFirstSymbol,
    OUT PDWORD  pdwOffset,
    OUT LPTSTR  *lpLangId,
    OUT PDWORD  pdwType
)
/*++

ParseTextId

    decodes Text Id key from .INI file

    syntax for this process is:

        {<DecimalNumber>}                {"NAME"}
        {<SymbolInTable>}_<LangIdString>_{"HELP"}

         e.g. 0_009_NAME
              OBJECT_1_009_HELP

Arguments

    lpTextId

        string to decode

    pFirstSymbol

        pointer to first entry in symbol table (NULL if no table)

    pdwOffset

        address of DWORD to recive offest value

    lpLangId

        address of pointer to Language Id string
        (NOTE: this will point into the string lpTextID which will be
        modified by this routine)

    pdwType

        pointer to dword that will recieve the type of string i.e.
        HELP or NAME

Return Value

    TRUE    text Id decoded successfully
    FALSE   unable to decode string

    NOTE: the string in lpTextID will be modified by this procedure

--*/
{
    LPTSTR  lpThisChar;
    PSYMBOL_TABLE_ENTRY pThisSymbol;
    
    // check for valid return arguments

    if (!(pdwOffset) ||
        !(lpLangId) ||
        !(pdwType)) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // search string from right to left in order to identify the
    // components of the string.

    lpThisChar = lpTextId + lstrlen(lpTextId); // point to end of string

    while (*lpThisChar != TEXT('_')) {
        lpThisChar--;
        if (lpThisChar <= lpTextId) {
            // underscore not found in string
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }
    }

    // first underscore found

    if ((lstrcmpi(lpThisChar, TEXT("_NAME"))) == 0) {
        // name found, so set type
        *pdwType = TYPE_NAME;
    } else if ((lstrcmpi(lpThisChar, TEXT("_HELP"))) == 0) {
        // help text found, so set type
        *pdwType = TYPE_HELP;
    } else {
        // bad format
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // set the current underscore to \0 and look for language ID

    *lpThisChar-- = TEXT('\0');

    while (*lpThisChar != TEXT('_')) {
        lpThisChar--;
        if (lpThisChar <= lpTextId) {
            // underscore not found in string
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }
    }
    
    // set lang ID string pointer to current char ('_') + 1

    *lpLangId = lpThisChar + 1;

    // set this underscore to a NULL and try to decode the remaining text

    *lpThisChar = TEXT('\0');

    // see if the first part of the string is a decimal digit

    if ((_stscanf (lpTextId, TEXT(" %d"), pdwOffset)) != 1) {
        // it's not a digit, so try to decode it as a symbol in the 
        // loaded symbol table

        for (pThisSymbol=pFirstSymbol;
             pThisSymbol && *(pThisSymbol->SymbolName);
             pThisSymbol = pThisSymbol->pNext) {

            if ((lstrcmpi(lpTextId, pThisSymbol->SymbolName)) == 0) {
                // a matching symbol was found, so insert it's value 
                // and return (that's all that needs to be done
                *pdwOffset = pThisSymbol->Value;
                return TRUE;
            }
        }
        // if here, then no matching symbol was found, and it's not
        // a number, so return an error

        SetLastError (ERROR_BAD_TOKEN_TYPE);
        return FALSE;
    } else {
        // symbol was prefixed with a decimal number
        return TRUE;
    }
}

PLANGUAGE_LIST_ELEMENT
FindLanguage (
    IN PLANGUAGE_LIST_ELEMENT   pFirstLang,
    IN LPTSTR   pLangId
)
/*++

FindLanguage

    searchs the list of languages and returns a pointer to the language
    list entry that matches the pLangId string argument

Arguments

    pFirstLang

        pointer to first language list element

    pLangId

        pointer to text string with language ID to look up

Return Value

    Pointer to matching language list entry
    or NULL if no match

--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    for (pThisLang = pFirstLang;
         pThisLang;
         pThisLang = pThisLang->pNextLang) {
        if ((lstrcmpi(pLangId, pThisLang->LangId)) == 0) {
            // match found so return pointer
            return pThisLang;
        }
    }
    return NULL;    // no match found
}

BOOL
AddEntryToLanguage (
    PLANGUAGE_LIST_ELEMENT  pLang,
    LPTSTR                  lpValueKey,
    DWORD                   dwType,
    DWORD                   dwOffset,
    LPTSTR                  lpIniFile
)
/*++

AddEntryToLanguage

    Add a text entry to the list of text entries for the specified language

Arguments

    pLang

        pointer to language structure to update

    lpValueKey

        value key to look up in .ini file

    dwOffset

        numeric offset of name in registry

    lpIniFile

        ini file

Return Value

    TRUE if added successfully
    FALSE if error
        (see GetLastError for status)

--*/
{
    LPTSTR  lpLocalStringBuff;
    DWORD   dwSize;

    lpLocalStringBuff = malloc (SMALL_BUFFER_SIZE * sizeof(TCHAR));

    if (!lpLocalStringBuff) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    dwSize = GetPrivateProfileString (
        TEXT("text"),       // section
        lpValueKey,      // key
        TEXT("DefaultValue"), // default value
        lpLocalStringBuff,
        SMALL_BUFFER_SIZE,
        lpIniFile);

    if ((lstrcmpi(lpLocalStringBuff, TEXT("DefaultValue")))== 0) {
        SetLastError (ERROR_BADKEY);
        if (lpLocalStringBuff) free (lpLocalStringBuff);
        return FALSE;
    }

    // key found, so load structure

    if (!pLang->pThisName) {
        // this is the first
        pLang->pThisName =
            malloc (sizeof (NAME_ENTRY) +
                    (lstrlen(lpLocalStringBuff) + 1) * sizeof (TCHAR));
        if (!pLang->pThisName) {
            SetLastError (ERROR_OUTOFMEMORY);
            if (lpLocalStringBuff) free (lpLocalStringBuff);
            return FALSE;
        } else {
            pLang->pFirstName = pLang->pThisName;
        }
    } else {
        pLang->pThisName->pNext =
            malloc (sizeof (NAME_ENTRY) +
                    (lstrlen(lpLocalStringBuff) + 1) * sizeof (TCHAR));
        if (!pLang->pThisName->pNext) {
            SetLastError (ERROR_OUTOFMEMORY);
            if (lpLocalStringBuff) free (lpLocalStringBuff);
            return FALSE;
        } else {
            pLang->pThisName = pLang->pThisName->pNext;
        }
    }

    // pLang->pThisName now points to an uninitialized structre

    pLang->pThisName->pNext = NULL;
    pLang->pThisName->dwOffset = dwOffset;
    pLang->pThisName->dwType = dwType;
    pLang->pThisName->lpText = (LPTSTR)&(pLang->pThisName[1]); // string follows

    lstrcpy (pLang->pThisName->lpText, lpLocalStringBuff);

    if (lpLocalStringBuff) free (lpLocalStringBuff);

    SetLastError (ERROR_SUCCESS);

    return (TRUE);
}

BOOL
LoadLanguageLists (
    IN LPTSTR  lpIniFile,
    IN DWORD   dwFirstCounter,
    IN DWORD   dwFirstHelp,
    IN PSYMBOL_TABLE_ENTRY   pFirstSymbol,
    IN PLANGUAGE_LIST_ELEMENT  pFirstLang
)
/*++

LoadLanguageLists

    Reads in the name and explain text definitions from the ini file and
    builds a list of these items for each of the supported languages and
    then combines all the entries into a sorted MULTI_SZ string buffer.

Arguments

    lpIniFile

        file containing the definitions to add to the registry
    
    dwFirstCounter

        starting counter name index number

    dwFirstHelp

        starting help text index number

    pFirstLang

        pointer to first element in list of language elements

Return Value

    TRUE if all is well
    FALSE if not
        error is returned in GetLastError

--*/
{
    LPTSTR  lpTextIdArray;
    LPTSTR  lpLocalKey;
    LPTSTR  lpThisKey;
    DWORD   dwSize;
    LPTSTR  lpLang;
    DWORD   dwOffset;
    DWORD   dwType;
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    if (!(lpTextIdArray = malloc (SMALL_BUFFER_SIZE * sizeof(TCHAR)))) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    if (!(lpLocalKey = malloc (MAX_PATH))) {
        SetLastError (ERROR_OUTOFMEMORY);
        if (lpTextIdArray) free (lpTextIdArray);
        return FALSE;
    }

    // get list of text keys to look up

    dwSize = GetPrivateProfileString (
        TEXT("text"),   // [text] section of .INI file
        NULL,           // return all keys
        TEXT("DefaultKeyValue"),    // default
        lpTextIdArray,  // return buffer
        SMALL_BUFFER_SIZE, // buffer size
        lpIniFile);     // .INI file name

    if ((lstrcmpi(lpTextIdArray, TEXT("DefaultKeyValue"))) == 0) {
        // key not found, default returned
        SetLastError (ERROR_NO_SUCH_GROUP);
        if (lpTextIdArray) free (lpTextIdArray);
        if (lpLocalKey) free (lpLocalKey);
        return FALSE;
    }

    // do each key returned

    for (lpThisKey=lpTextIdArray;
         *lpThisKey;
         lpThisKey += (lstrlen(lpThisKey) + 1)) {

        lstrcpy (lpLocalKey, lpThisKey);    // make a copy of the key
        
        // parse key to see if it's in the correct format

        if (ParseTextId(lpLocalKey, pFirstSymbol, &dwOffset, &lpLang, &dwType)) {
            // so get pointer to language entry structure
            pThisLang = FindLanguage (pFirstLang, lpLang);
            if (pThisLang) {
                if (!AddEntryToLanguage(pThisLang,
                    lpThisKey, dwType,
                    (dwOffset + ((dwType == TYPE_NAME) ? dwFirstCounter : dwFirstHelp)),
                    lpIniFile)) {
                }
            } else { // language not in list
            }
        } else { // unable to parse ID string
        }
    }

    if (lpTextIdArray) free (lpTextIdArray);
    if (lpLocalKey) free (lpLocalKey);
    return TRUE;

}

BOOL
SortLanguageTables (
    PLANGUAGE_LIST_ELEMENT pFirstLang,
    PDWORD                 pdwLastName,
    PDWORD                 pdwLastHelp
)
/*++

SortLangageTables

    walks list of languages loaded, allocates and loads a sorted multi_SZ
    buffer containing new entries to be added to current names/help text

Arguments

    pFirstLang

        pointer to first element in list of languages

ReturnValue

    TRUE    everything done as expected
    FALSE   error occurred, status in GetLastError

--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    BOOL            bSorted;

    LPTSTR          pNameBufPos, pHelpBufPos;

    PNAME_ENTRY     pThisName, pPrevName;

    DWORD           dwHelpSize, dwNameSize, dwSize;

    if (!pdwLastName || !pdwLastHelp) {
        SetLastError (ERROR_BAD_ARGUMENTS);
        return FALSE;
    }

    for (pThisLang = pFirstLang;
        pThisLang;
        pThisLang = pThisLang->pNextLang) {
        // do each language in list

        // sort elements in list by value (offset) so that lowest is first
        
        bSorted = FALSE;
        while (!bSorted ) {
            // point to start of list

            pPrevName = pThisLang->pFirstName;
            if (pPrevName) {
                pThisName = pPrevName->pNext;
            } else {
                break;  // no elements in this list
            }

            if (!pThisName) {
                break;      // only one element in the list
            }
            bSorted = TRUE; // assume that it's sorted

            // go until end of list
                    
            while (pThisName->pNext) {
                if (pThisName->dwOffset > pThisName->pNext->dwOffset) {
                    // switch 'em
                    pPrevName->pNext = pThisName->pNext;
                    pThisName->pNext = pThisName->pNext->pNext;
                    pThisName->pNext->pNext = pThisName;
                    bSorted = FALSE;
                }
                //move to next entry
                pPrevName = pThisName;
                pThisName = pThisName->pNext;
            }
            // if bSorted = TRUE , then we walked all the way down 
            // the list without changing anything so that's the end.
        }

        // with the list sorted, build the MULTI_SZ strings for the
        // help and name text strings

        // compute buffer size

        dwNameSize = dwHelpSize = 0;
        *pdwLastName = *pdwLastHelp = 0;
        
        for (pThisName = pThisLang->pFirstName;
            pThisName;
            pThisName = pThisName->pNext) {
                // compute buffer requirements for this entry
            dwSize = SIZE_OF_OFFSET_STRING;
            dwSize += lstrlen (pThisName->lpText);
            dwSize += 1;   // null
            dwSize *= sizeof (TCHAR);   // adjust for character size
                // add to appropriate size register
            if (pThisName->dwType == TYPE_NAME) {
                dwNameSize += dwSize;
                if (pThisName->dwOffset > *pdwLastName) {
                    *pdwLastName = pThisName->dwOffset;
                }
            } else if (pThisName->dwType == TYPE_HELP) {
                dwHelpSize += dwSize;
                if (pThisName->dwOffset > *pdwLastHelp) {
                    *pdwLastHelp = pThisName->dwOffset;
                }
            }
        }

        // allocate buffers for the Multi_SZ strings

        pThisLang->NameBuffer = malloc (dwNameSize);
        pThisLang->HelpBuffer = malloc (dwHelpSize);

        if (!pThisLang->NameBuffer || !pThisLang->HelpBuffer) {
            SetLastError (ERROR_OUTOFMEMORY);
            return FALSE;
        }

        // fill in buffers with sorted strings

        pNameBufPos = (LPTSTR)pThisLang->NameBuffer;
        pHelpBufPos = (LPTSTR)pThisLang->HelpBuffer;

        for (pThisName = pThisLang->pFirstName;
            pThisName;
            pThisName = pThisName->pNext) {
            if (pThisName->dwType == TYPE_NAME) {
                // load number as first 0-term. string
                dwSize = _stprintf (pNameBufPos, TEXT("%d"), pThisName->dwOffset);
                pNameBufPos += dwSize + 1;  // save NULL term.
                // load the text to match
                lstrcpy (pNameBufPos, pThisName->lpText);
                pNameBufPos += lstrlen(pNameBufPos) + 1;
            } else if (pThisName->dwType == TYPE_HELP) {
                // load number as first 0-term. string
                dwSize = _stprintf (pHelpBufPos, TEXT("%d"), pThisName->dwOffset);
                pHelpBufPos += dwSize + 1;  // save NULL term.
                // load the text to match
                lstrcpy (pHelpBufPos, pThisName->lpText);
                pHelpBufPos += lstrlen(pHelpBufPos) + 1;
            }
        }

        // add additional NULL at end of string to terminate MULTI_SZ

        *pHelpBufPos = TEXT('\0');
        *pNameBufPos = TEXT('\0');

        // compute size of MULTI_SZ strings

        pThisLang->dwNameBuffSize = (DWORD)((PBYTE)pNameBufPos -
                                            (PBYTE)pThisLang->NameBuffer) +
                                            sizeof(TCHAR);
        pThisLang->dwHelpBuffSize = (DWORD)((PBYTE)pHelpBufPos -
                                            (PBYTE)pThisLang->HelpBuffer) +
                                            sizeof(TCHAR);
    }
    return TRUE;
}

BOOL
UpdateEachLanguage (
    HKEY    hPerflibRoot,
    PLANGUAGE_LIST_ELEMENT    pFirstLang
)
/*++

UpdateEachLanguage

    Goes through list of languages and adds the sorted MULTI_SZ strings
    to the existing counter and explain text in the registry.
    Also updates the "Last Counter and Last Help" values

Arguments

    hPerflibRoot

        handle to Perflib key in the registry

    pFirstLanguage

        pointer to first language entry

Return Value

    TRUE    all went as planned
    FALSE   an error occured, use GetLastError to find out what it was.

--*/
{

    PLANGUAGE_LIST_ELEMENT  pThisLang;

    LPTSTR      pHelpBuffer = NULL;
    LPTSTR      pNameBuffer = NULL;
    LPTSTR      pNewName;
    LPTSTR      pNewHelp;

    DWORD       dwBufferSize;
    DWORD       dwValueType;
    DWORD       dwCounterSize;
    DWORD       dwHelpSize;

    HKEY        hKeyThisLang;

    LONG        lStatus;

    for (pThisLang = pFirstLang;
        pThisLang;
        pThisLang = pThisLang->pNextLang) {

        lStatus = RegOpenKeyEx(
            hPerflibRoot,
            pThisLang->LangId,
            RESERVED,
            KEY_READ | KEY_WRITE,
            &hKeyThisLang);

        if (lStatus == ERROR_SUCCESS) {
            
            // get size of counter names

            dwBufferSize = 0;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                Counters,
                RESERVED,
                &dwValueType,
                NULL,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                return FALSE;
            }

            dwCounterSize = dwBufferSize;

            // get size of help text

            dwBufferSize = 0;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                Help,
                RESERVED,
                &dwValueType,
                NULL,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                return FALSE;
            }

            dwHelpSize = dwBufferSize;

            // allocate new buffers
            
            dwCounterSize += pThisLang->dwNameBuffSize;
            pNameBuffer = malloc (dwCounterSize);

            dwHelpSize += pThisLang->dwHelpBuffSize;
            pHelpBuffer = malloc (dwHelpSize);

            if (!pNameBuffer || !pHelpBuffer) {
                if (pNameBuffer) {
                    free(pNameBuffer);
                }
                if (pHelpBuffer) {
                    free(pHelpBuffer);
                }
                SetLastError (ERROR_OUTOFMEMORY);
                return (FALSE);
            }

            // load current buffers into memory

            // read counter names into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Name"

            dwBufferSize = dwCounterSize;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                Counters,
                RESERVED,
                &dwValueType,
                (LPVOID)pNameBuffer,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                goto ErrorExit;
            }

            // set pointer to location in buffer where new string should be
            //  appended: end of buffer - 1 (second null at end of MULTI_SZ

            pNewName = (LPTSTR)((PBYTE)pNameBuffer + dwBufferSize - sizeof(TCHAR));

            // adjust buffer length to take into account 2nd null from 1st 
            // buffer that has been overwritten

            dwCounterSize -= sizeof(TCHAR);

            // read explain text into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Text..."

            dwBufferSize = dwHelpSize;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                Help,
                RESERVED,
                &dwValueType,
                (LPVOID)pHelpBuffer,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                goto ErrorExit;
            }

            // set pointer to location in buffer where new string should be
            //  appended: end of buffer - 1 (second null at end of MULTI_SZ

            pNewHelp = (LPTSTR)((PBYTE)pHelpBuffer + dwBufferSize - sizeof(TCHAR));

            // adjust buffer length to take into account 2nd null from 1st 
            // buffer that has been overwritten

            dwHelpSize -= sizeof(TCHAR);

            // append new strings to end of current strings

            memcpy (pNewHelp, pThisLang->HelpBuffer, pThisLang->dwHelpBuffSize);
            memcpy (pNewName, pThisLang->NameBuffer, pThisLang->dwNameBuffSize);

                lStatus = RegSetValueEx (
                    hKeyThisLang,
                    Counters,
                    RESERVED,
                    REG_MULTI_SZ,
                    (LPBYTE)pNameBuffer,
                    dwCounterSize);
            
                if (lStatus != ERROR_SUCCESS) {
                    SetLastError (lStatus);
                    goto ErrorExit;
                }

                lStatus = RegSetValueEx (
                    hKeyThisLang,
                    Help,
                    RESERVED,
                    REG_MULTI_SZ,
                    (LPBYTE)pHelpBuffer,
                    dwHelpSize);

                if (lStatus != ERROR_SUCCESS) {
                    SetLastError (lStatus);
                    goto ErrorExit;
                }
ErrorExit:
            free (pNameBuffer);
            free (pHelpBuffer);
            CloseHandle (hKeyThisLang);
            if (lStatus != ERROR_SUCCESS)
                return FALSE;
        } else {
        }
    }

    return TRUE;
}

BOOL
UpdateRegistry (
    LPTSTR  lpIniFile,
    HKEY    hKeyMachine,
    LPTSTR  lpDriverName,
    PLANGUAGE_LIST_ELEMENT  pFirstLang,
    PSYMBOL_TABLE_ENTRY   pFirstSymbol
)
/*++

UpdateRegistry
    
    - checks, and if not busy, sets the "busy" key in the registry
    - Reads in the text and help definitions from the .ini file
    - Reads in the current contents of the HELP and COUNTER names
    - Builds a sorted MULTI_SZ struct containing the new definitions 
    - Appends the new MULTI_SZ to the current as read from the registry
    - loads the new MULTI_SZ string into the registry
    - updates the keys in the driver's entry and Perflib's entry in the
        registry (e.g. first, last, etc)
    - clears the "busy" key

Arguments

    lpIniFile
        pathname to .ini file conatining definitions

    hKeyMachine
        handle to HKEY_LOCAL_MACHINE in registry on system to
        update counters for.

    lpDriverName
        Name of device driver to load counters for

    pFirstLang
        pointer to first element in language structure list

    pFirstSymbol
        pointer to first element in symbol definition list


Return Value

    TRUE if registry updated successfully
    FALSE if registry not updated
        (This routine will print an error message to stdout if an error
        is encountered).

--*/
{

    HKEY    hDriverPerf = NULL;
    HKEY    hPerflib = NULL;

    LPTSTR  lpDriverKeyPath;

    DWORD   dwType;
    DWORD   dwSize;

    DWORD   dwFirstDriverCounter;
    DWORD   dwFirstDriverHelp;
    DWORD   dwLastDriverCounter;
    DWORD   dwLastPerflibCounter;
    DWORD   dwLastPerflibHelp;

    BOOL    bStatus;
    LONG    lStatus;

    bStatus = FALSE;

    // allocate temporary buffers
    lpDriverKeyPath = malloc (MAX_PATH * sizeof(TCHAR));

    if (!lpDriverKeyPath) {
        SetLastError (ERROR_OUTOFMEMORY);
        goto UpdateRegExit;
    }

    // build driver key path string

    lstrcpy (lpDriverKeyPath, DriverPathRoot);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, lpDriverName);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, Performance);

    // open keys to registry
    // open key to driver's performance key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        lpDriverKeyPath,
        RESERVED,
        KEY_WRITE | KEY_READ,
        &hDriverPerf);

    if (lStatus != ERROR_SUCCESS) {
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // open key to perflib's "root" key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        NamesKey,
        RESERVED,
        KEY_WRITE | KEY_READ,
        &hPerflib);

    if (lStatus != ERROR_SUCCESS) {
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // get "last" values from PERFLIB

    dwType = 0;
    dwLastPerflibCounter = 0;
    dwSize = sizeof (dwLastPerflibCounter);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwLastPerflibCounter,
        &dwSize);
    
    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // get last help value now

    dwType = 0;
    dwLastPerflibHelp = 0;
    dwSize = sizeof (dwLastPerflibHelp);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwLastPerflibHelp,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // get last help value now

    dwType = 0;
    dwSize = sizeof (dwSystemVersion);
    lStatus = RegQueryValueEx (
        hPerflib,
        VersionStr,
        RESERVED,
        &dwType,
        (LPBYTE)&dwSystemVersion,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        dwSystemVersion = OLD_VERSION;
    }

    if ( dwSystemVersion != OLD_VERSION )
    {
        // ERROR. The caller does not check the version. It is the caller
        // fault
        goto UpdateRegExit;
    }

    // see if this driver's counter names have already been installed
    // by checking to see if LastCounter's value is less than Perflib's
    // Last Counter

    dwType = 0;
    dwLastDriverCounter = 0;
    dwSize = sizeof (dwLastDriverCounter);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwLastDriverCounter,
        &dwSize);

    if (lStatus == ERROR_SUCCESS) {
        // if key found, then compare with perflib value and exit this
        // procedure if the driver's last counter is <= to perflib's last
        //
        // if key not found, then continue with installation
        // on the assumption that the counters have not been installed

        if (dwLastDriverCounter <= dwLastPerflibCounter) {
            SetLastError (ERROR_SUCCESS);
            goto UpdateRegExit;
        }
    }

    // everything looks like it's ready to go so first check the 
    // busy indicator

    lStatus = RegQueryValueEx (
        hPerflib,
        Busy,
        RESERVED,
        &dwType,
        NULL,
        &dwSize);

    if (lStatus == ERROR_SUCCESS) { // perflib is in use at the moment
        return ERROR_BUSY;
    }

    // set the "busy" indicator under the PERFLIB key     

    dwSize = lstrlen(lpDriverName) * sizeof (TCHAR);
    lStatus = RegSetValueEx (
        hPerflib,
        Busy,
        RESERVED,
        REG_SZ,
        (LPBYTE)lpDriverName,
        dwSize);

    if (lStatus != ERROR_SUCCESS) {
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // increment (by 2) the last counters so they point to the first
    // unused index after the existing names and then 
    // set the first driver counters

    dwFirstDriverCounter = dwLastPerflibCounter += 2;
    dwFirstDriverHelp = dwLastPerflibHelp += 2;

    // load .INI file definitions into language tables

    if (!LoadLanguageLists (lpIniFile, dwLastPerflibCounter, dwLastPerflibHelp,
        pFirstSymbol, pFirstLang)) {
        // error message is displayed by LoadLanguageLists so just abort
        // error is in GetLastError already
        goto UpdateRegExit;
    }

    // all the symbols and definitions have been loaded into internal
    // tables. so now they need to be sorted and merged into a multiSZ string
    // this routine also updates the "last" counters

    if (!SortLanguageTables (pFirstLang, &dwLastPerflibCounter, &dwLastPerflibHelp)) {
        goto UpdateRegExit;
    }

    if (!UpdateEachLanguage (hPerflib, pFirstLang)) {
        goto UpdateRegExit;
    }

    // update last counters for driver and perflib

    // perflib...

    lStatus = RegSetValueEx(
        hPerflib,
        LastCounter,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibCounter,
        sizeof(DWORD));

    lStatus = RegSetValueEx(
        hPerflib,
        LastHelp,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibHelp,
        sizeof(DWORD));

    // and the driver

    lStatus = RegSetValueEx(
        hDriverPerf,
        LastCounter,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibCounter,
        sizeof(DWORD));

    lStatus = RegSetValueEx(
        hDriverPerf,
        LastHelp,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibHelp,
        sizeof(DWORD));

    lStatus = RegSetValueEx(
        hDriverPerf,
        FirstCounter,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwFirstDriverCounter,
        sizeof(DWORD));

    lStatus = RegSetValueEx(
        hDriverPerf,
        FirstHelp,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwFirstDriverHelp,
        sizeof(DWORD));

    bStatus = TRUE;

    // free temporary buffers
UpdateRegExit:
    // clear busy flag

    if (hPerflib) {
        lStatus = RegDeleteValue (
            hPerflib,
            Busy);
    }
     
    // free temporary buffers

    if (lpDriverKeyPath) free (lpDriverKeyPath);
    if (hDriverPerf) CloseHandle (hDriverPerf);
    if (hPerflib) CloseHandle (hPerflib);

    return bStatus;
}

BOOL FAR PASCAL lodctr(DWORD argc,LPSTR argv[], LPSTR *ppszResult )
/*++

main



Arguments


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpIniFile;
    LPTSTR  lpDriverName;

    LANGUAGE_LIST_ELEMENT   LangList;
    PSYMBOL_TABLE_ENTRY           SymbolTable = NULL;
    PSYMBOL_TABLE_ENTRY           pThisSymbol = NULL;

    BOOL fReturn = TRUE;

    lpIniFile    = malloc(MAX_PATH * sizeof(TCHAR));
    lpDriverName = malloc(MAX_PATH * sizeof(TCHAR));

    if ((lpIniFile == NULL) || (lpDriverName == NULL)) {
        if (lpIniFile) {
            free(lpIniFile);
        }
        if (lpDriverName) {
            free(lpDriverName);
        }
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    wsprintfA( achBuff, "{\"NO_ERROR\"}");

    if ( argc == 1) {
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, argv[0], -1, lpIniFile, MAX_PATH);

        if (!GetDriverName (lpIniFile, &lpDriverName)) {
            wsprintfA(achBuff,"{\"ERROR\"}");
            fReturn = FALSE;
            goto EndOfMain;
        }

        if (!BuildLanguageTables(lpIniFile, &LangList)) {
            wsprintfA (achBuff, "{\"ERROR\"}");
            fReturn = FALSE;
            goto EndOfMain;
        }

        if (!LoadIncludeFile(lpIniFile, &SymbolTable)) {
            // open errors displayed in routine
            fReturn = FALSE;
            goto EndOfMain;
        }

        if (!UpdateRegistry(lpIniFile,
            HKEY_LOCAL_MACHINE,
            lpDriverName,
            &LangList,
            SymbolTable)) {
            wsprintfA (achBuff, "{\"ERROR\"}");
            fReturn = FALSE;
        }

    } 

EndOfMain:
    if (lpIniFile) free (lpIniFile);    
    if (lpDriverName) free (lpDriverName);

    *ppszResult = achBuff;
    
    return (fReturn); // success
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\setupdll\nwcfg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

        nwcfg.cxx
                netware configuration source code.

        history:
                terryk  05/07/93        Created
*/


#if defined(DEBUG)
static const char szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define APIERR LONG

extern "C"
{

#include <windows.h>
#include <port1632.h>


#include <winspool.h>

// exported functions

BOOL FAR PASCAL AddNetwarePrinterProvidor( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL DeleteNetwarePrinterProvidor( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL AppendSzToFile( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL GetKernelVersion( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );

extern HINSTANCE ThisDLLHandle;
}

#define UNREFERENCED(x) ((void)(x))
#include <nwcfg.hxx>
#include <nwcfg.h>


/*******************************************************************

    NAME:       AddNetwarePrinterProvidor

    SYNOPSIS:   This is a wrapper routine for called AddPrintProvidor. It
                should be called from inf file if the user installs netware.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.

    HISTORY:
                terryk  07-May-1993     Created

********************************************************************/

#define PROVIDER_DLL_NAME   "nwprovau.dll"
#define MAX_PROVIDER_NAME_LEN 512
typedef BOOL (WINAPI *T_AddPrintProvidor)(LPSTR pName,DWORD Level,LPBYTE pMonitors);
typedef BOOL (WINAPI *T_DeletePrintProvidor)(LPSTR pName,LPSTR pEnv, LPSTR pMon);


BOOL FAR PASCAL AddNetwarePrinterProvidor( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    UNREFERENCED( nArgs );

    PROVIDOR_INFO_1 ProvidorInfo1;

    ProvidorInfo1.pEnvironment = (LPSTR) NULL;
    ProvidorInfo1.pDLLName = PROVIDER_DLL_NAME;

    APIERR err = 0;
    do {
        CHAR buf[MAX_PROVIDER_NAME_LEN];
        LPSTR lpProviderName = (LPSTR)buf;
        if ( lpProviderName == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        if ( !LoadString( ThisDLLHandle,
                          PROVIDER_NAME,
                          lpProviderName,
                          MAX_PROVIDER_NAME_LEN ) )
        {
            err = ::GetLastError();
            break;
        }

        ProvidorInfo1.pName = lpProviderName;



        HINSTANCE hDll = ::LoadLibraryA( "winspool.drv" );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pAddPrintProvidor = ::GetProcAddress( hDll, "AddPrintProvidorA" );

        if ( pAddPrintProvidor == NULL )
        {
            err = ::GetLastError();
        } else if ( !(*(T_AddPrintProvidor)pAddPrintProvidor)((LPSTR) NULL,1,(LPBYTE)&ProvidorInfo1))
        {
            err = ::GetLastError();
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);
    wsprintfA( achBuff, "{\"%d\"}", err );
    *ppszResult = achBuff;

    return TRUE;
}

BOOL FAR PASCAL DeleteNetwarePrinterProvidor( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    UNREFERENCED( nArgs );
    UNREFERENCED( apszArgs );

    APIERR err = 0;

    do {
        HINSTANCE hDll = ::LoadLibraryA( "winspool.drv" );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pDeletePrintProvidor = ::GetProcAddress( hDll, "DeletePrintProvidorA" );

        if ( pDeletePrintProvidor == NULL )
        {
            err = ::GetLastError();
        }
        else
        {
            CHAR buf[MAX_PROVIDER_NAME_LEN];
            LPSTR lpProviderName = (LPSTR)buf;
            if ( lpProviderName == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            if ( nArgs == 1 )
            {
                 lpProviderName = apszArgs[0];
            } else
            {
                if ( !LoadString( ThisDLLHandle,
                                  PROVIDER_NAME,
                                  lpProviderName,
                                  MAX_PROVIDER_NAME_LEN ) )
                {
                    err = ::GetLastError();
                }
            }
            if ( !(*(T_DeletePrintProvidor)pDeletePrintProvidor)( (LPSTR) NULL,
                                                                  (LPSTR) NULL,
                                                                  lpProviderName))
            {
                err = ::GetLastError();
            }
        }

        if ( hDll )
            ::FreeLibrary ( hDll );

    } while (FALSE);
    wsprintfA( achBuff, "{\"%d\"}", err );
    *ppszResult = achBuff;

    return TRUE;
}

/*******************************************************************

    NAME:       AppendSzToFile

    SYNOPSIS:   Append a string to a file.

    ENTRY:      Args[0] - FileName string
                Args[1] - String to be added to the file

    RETURN:     BOOL - TRUE for success.

    HISTORY:
                terryk  07-May-1993     Created

********************************************************************/

BOOL FAR PASCAL
AppendSzToFile( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    UNREFERENCED( nArgs );

    DWORD  BytesWritten;
    HANDLE hfile;
    LPSTR szFileName = apszArgs[0];
    LPSTR szAddOnSz = apszArgs[1];

    //
    // Open the file
    //

    hfile = CreateFile(
                szFileName,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ,
                (struct _SECURITY_ATTRIBUTES *) NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (hfile == INVALID_HANDLE_VALUE) {
        wsprintfA( achBuff, "{ Cannot Open File: \"%s\"}", szFileName );
        *ppszResult = achBuff;
        return FALSE;
    }

    //
    // Go to end of file
    //

    SetFilePointer (
        hfile,
        0,
        (PLONG) NULL,
        FILE_END
        );

    //
    // Append string passed in at the end of the file
    //

    WriteFile (
        hfile,
        szAddOnSz,
        lstrlen( szAddOnSz ),
        &BytesWritten,
        (struct _OVERLAPPED *) NULL
        );

    CloseHandle (hfile);
    wsprintfA( achBuff, "{\"%d\"}", 0 );
    *ppszResult = achBuff;
    return TRUE;
}

/*******************************************************************

    NAME:       GetKernelVersion

    SYNOPSIS:   Get the current kernel version number

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                The return number is the kernel build number.
                {"MajorVerion","MinorVersion","BuildNumber","PatchNumber"}

    HISTORY:
                terryk  24-Sept-1993     Created

********************************************************************/

BOOL FAR PASCAL
GetKernelVersion( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    UNREFERENCED( nArgs );

    DWORD wVer;
    LONG nSubVersion;
    LONG nVersion;

    LPCSTR  lpszRegName = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
    HKEY    hsubkey ;
    DWORD   dwZero = 0;
    DWORD   dwRegValueType;
    DWORD   dwRegValue;
    DWORD   cbRegValue;

    wVer = GetVersion();
    nSubVersion = GETMINORVERSION(wVer);
    nVersion = GETMAJORVERSION(wVer);

    cbRegValue = sizeof(dwRegValue);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            lpszRegName, dwZero, KEY_QUERY_VALUE, &hsubkey) ||
        RegQueryValueEx(hsubkey, "CSDVersion", (LPDWORD)NULL,
            &dwRegValueType, (LPBYTE)&dwRegValue, &cbRegValue) ||
        dwRegValueType != REG_DWORD
    ) {
        wsprintf(achBuff,"{\"%d\",\"%d\",\"%d\",\"%d\"}", nVersion, nSubVersion, wVer >> 16, 0);
    } else {
        wsprintf(achBuff,"{\"%d\",\"%d\",\"%d\",\"%d\"}", nVersion, nSubVersion, wVer >> 16, dwRegValue);
    }
    if (hsubkey != NULL) {
        RegCloseKey (hsubkey);
    }
    *ppszResult = achBuff;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\setupdll\setvalue.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

        setvalue.c
                Code to enable SetValue for everyone.

        history:
                terryk  09/30/93        Created
*/


#if defined(DEBUG)
static const char szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <string.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <nwapi.h>
#include <nwcfg.h>
#include <nwcfg.hxx>

extern char achBuff[];

// exported functions

BOOL FAR PASCAL SetFileSysChangeValue( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL SetEverybodyPermission( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL SetupRegistryForNWCS( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL SetupRegistryWorker( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL CleanupRegistryForNWCS( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );

//
// structure for registry munging
//

typedef struct REG_ENTRY_ {
    DWORD         Operation ;
    LONG          Level ;
    LPWSTR        s1 ;
    LPWSTR        s2 ;
} REG_ENTRY ;

//
// local routines
//
    
DWORD SetupShellExtensions(REG_ENTRY RegEntries[], DWORD dwNumEntries) ;

// Values & Tables that define registry data

#define MAX_REG_LEVEL       10

#define CREATE_ABS          1         // create/open a key with absolute path
#define CREATE_REL          2         // create/open a key with relative path
#define VALUE_STR           3         // write a string value
#define DELETE_ABS          4         // delete key with absolute path
#define DELETE_REL          5         // delete key with relative path
#define DELETE_VAL          6         // delete a value
#define DROP_STACK          7         // drop stack by one 

REG_ENTRY RegCreateEntries[] =
{
    {CREATE_ABS,0,L"SOFTWARE\\Classes\\NetWare_or_Compatible_Network", NULL},
    {DELETE_REL,0,L"shellex\\ContextMenuHandlers\\NetWareMenus", NULL},
    {DELETE_REL,0,L"shellex\\ContextMenuHandlers", NULL},
    {DELETE_REL,0,L"shellex\\PropertySheetHandlers\\NetWarePage", NULL},
    {DELETE_REL,0,L"shellex\\PropertySheetHandlers", NULL},
    {DELETE_REL,0,L"shellex", NULL},
    {DROP_STACK,0,NULL,NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\NetWare_or_Compatible_Network", NULL},

    {CREATE_ABS, 0,L"SOFTWARE\\Classes\\Network\\Type", NULL},
    {CREATE_REL,+1,    L"3", NULL},
    {CREATE_REL,+1,        L"shellex", NULL},
    {CREATE_REL,+1,            L"ContextMenuHandlers", NULL},
    {CREATE_REL,+1,                L"NetWareMenus", NULL},
    {VALUE_STR,0,                      L"", L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}"},
    {CREATE_REL,-1,            L"PropertySheetHandlers", NULL},
    {CREATE_REL,+1,                L"NetWarePage", NULL},
    {VALUE_STR,0,                      L"", L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}"},
    {CREATE_ABS, 0,L"SOFTWARE\\Classes\\CLSID", NULL},
    {CREATE_REL,+1,        L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}", NULL},
    {VALUE_STR,0,              L"", L"NetWare Objects"},
    {CREATE_REL,+1,            L"InProcServer32", NULL},
    {VALUE_STR,0,                  L"", L"nwprovau.dll"},
    {VALUE_STR,0,                  L"ThreadingModel", L"Apartment"},
    {CREATE_REL,-1,        L"{e3f2bac0-099f-11cf-8daa-00aa004a5691}", NULL},
    {VALUE_STR,0,              L"", L"NetWare UNC Folder Menu"},
    {CREATE_REL,+1,            L"InProcServer32", NULL},
    {VALUE_STR,0,                  L"", L"nwprovau.dll"},
    {VALUE_STR,0,                  L"ThreadingModel", L"Apartment"},
    {CREATE_REL,-1,        L"{52c68510-09a0-11cf-8daa-00aa004a5691}", NULL},
    {VALUE_STR,0,              L"", L"NetWare Hood Verbs"},
    {CREATE_REL,+1,            L"InProcServer32", NULL},
    {VALUE_STR,0,                  L"", L"nwprovau.dll"},
    {VALUE_STR,0,                  L"ThreadingModel", L"Apartment"},
    {CREATE_REL,-1,        L"{208D2C60-3AEA-1069-A2D7-08002B30309D}", NULL},
    {CREATE_REL,+1,            L"shellex", NULL},
    {CREATE_REL,+1,                L"ContextMenuHandlers", NULL},
    {CREATE_REL,+1,                    L"NetWareMenus", NULL},
    {VALUE_STR,0,                      L"", L"{52c68510-09a0-11cf-8daa-00aa004a5691}"},
    {CREATE_ABS, 0,L"SOFTWARE\\Classes\\Folder", NULL},
    {CREATE_REL,+1,        L"shellex", NULL},
    {CREATE_REL,+1,            L"ContextMenuHandlers", NULL},
    {CREATE_REL,+1,            L"NetWareUNCMenu", NULL},
    {VALUE_STR,0,                  L"", L"{e3f2bac0-099f-11cf-8daa-00aa004a5691}"},
    {CREATE_ABS, 0,L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion", NULL},
    {CREATE_REL,+1,    L"Shell Extensions", NULL},
    {CREATE_REL,+1,        L"Approved", NULL},
    {VALUE_STR,0,              L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}", L"Shell extensions for NetWare"},
    {VALUE_STR,0,              L"{e3f2bac0-099f-11cf-8daa-00aa004a5691}", L"Shell extensions for NetWare"},
    {VALUE_STR,0,              L"{52c68510-09a0-11cf-8daa-00aa004a5691}", L"Shell extensions for NetWare"}
} ;

REG_ENTRY RegDeleteEntries[] =
{
    {CREATE_ABS,0,L"SOFTWARE\\Classes\\Network\\Type\\3", NULL},
    {DELETE_REL,0,L"shellex\\ContextMenuHandlers\\NetWareMenus", NULL},
    {DELETE_REL,0,L"shellex\\ContextMenuHandlers", NULL},
    {DELETE_REL,0,L"shellex\\PropertySheetHandlers\\NetWarePage", NULL},
    {DELETE_REL,0,L"shellex\\PropertySheetHandlers", NULL},
    {DELETE_REL,0,L"shellex", NULL},
    {DROP_STACK,0,NULL,NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\Network\\Type\\3", NULL},

    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{8e9d6600-f84a-11ce-8daa-00aa004a5691}\\InProcServer32", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{8e9d6600-f84a-11ce-8daa-00aa004a5691}", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{e3f2bac0-099f-11cf-8daa-00aa004a5691}\\InProcServer32", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{e3f2bac0-099f-11cf-8daa-00aa004a5691}", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{52c68510-09a0-11cf-8daa-00aa004a5691}\\InProcServer32", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{52c68510-09a0-11cf-8daa-00aa004a5691}", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\shellex\\ContextMenuHandlers\\NetWareMenus", NULL},

    {DELETE_ABS,0,L"SOFTWARE\\Classes\\Folder\\shellex\\ContextMenuHandlers\\NetWareUNCMenu", NULL},
    {CREATE_ABS,0,L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", NULL},
    {DELETE_VAL,0,L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}", NULL},
    {DELETE_VAL,0,L"{e3f2bac0-099f-11cf-8daa-00aa004a5691}", NULL},
    {DELETE_VAL,0,L"{52c68510-09a0-11cf-8daa-00aa004a5691}", NULL}
} ;


/*******************************************************************

    NAME:       SetEverybodyPermission

    SYNOPSIS:   Set the registry key to everybody "Set Value" (or whatever
                the caller want.) This is called from the inf file

    ENTRY:      Registry key as the first parameter
                Permisstion type as the second parameter

    RETURN:     BOOL - TRUE for success.

    HISTORY:
                terryk  07-May-1993     Created

********************************************************************/

typedef DWORD (*T_SetPermission)(HKEY hKey, DWORD dwPermission);

BOOL FAR PASCAL SetEverybodyPermission( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    HKEY hKey = (HKEY)atol( &(apszArgs[0][1]) );    // registry key
    DWORD dwPermission = atol( apszArgs[1] );       // permission value
    DWORD err = ERROR_SUCCESS;

    do  {
        HINSTANCE hDll = LoadLibraryA( "nwapi32.dll" );
        FARPROC pSetPermission = NULL;

        if ( hDll == NULL )
        {
            err = GetLastError();
            break;
        }

        pSetPermission = GetProcAddress( hDll, "NwLibSetEverybodyPermission" );

        if ( pSetPermission == NULL )
        {
            err = GetLastError();
            break;
        }
        err = (*(T_SetPermission)pSetPermission)( hKey, dwPermission );
    } while ( FALSE );

    wsprintfA( achBuff, "{\"%d\"}", err );
    *ppszResult = achBuff;

    return( err == ERROR_SUCCESS );
}

/*******************************************************************

    NAME:       SetFileSysChangeValue

    SYNOPSIS:   calls common setup routine. this old entry point is
                is left here to handle any DLL/INF mismatch.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/

BOOL FAR PASCAL SetFileSysChangeValue( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    return SetupRegistryWorker( nArgs, apszArgs, ppszResult );
}

/*******************************************************************

    NAME:       SetupRegistryForNWCS

    SYNOPSIS:   calls common worker routine to setup registry.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/

BOOL FAR PASCAL SetupRegistryForNWCS( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    return SetupRegistryWorker( nArgs, apszArgs, ppszResult );
}

/*******************************************************************

    NAME:       SetupRegistryWorker

    SYNOPSIS:   set the FileSysChangeValue to please NETWARE.DRV.
                also set win.ini parameter so wfwnet.drv knows we are there.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/

BOOL FAR PASCAL SetupRegistryWorker( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    DWORD err = 0, err1 = 0 ;

    (void) nArgs ;         // quiet the compiler
    (void) apszArgs ;      // quiet the compiler

    if (!WriteProfileStringA("NWCS",
                             "NwcsInstalled",
                             "1"))
    {
        err = GetLastError() ;
    }

    if (!WritePrivateProfileStringA("386Enh",
                                    "FileSysChange",
                                    "off",
                                    "system.ini"))
    {
        err1 = GetLastError() ;
    }

    if (err1 == NO_ERROR)
    {
        err1 = SetupShellExtensions(
                   RegCreateEntries, 
                   sizeof(RegCreateEntries)/sizeof(RegCreateEntries[0])) ;
    }

    wsprintfA( achBuff, "{\"%d\"}", err ? err : err1 );
    *ppszResult = achBuff;

    return TRUE;
}

/*******************************************************************

    NAME:       DeleteGatewayPassword

    SYNOPSIS:   delete the LSA secret used for gateway password.
                also clears the NWCS installed bit. INF will be
                changed to call CleanupRegistryForNWCS, but this entry
                point is left here to handle DLL/INF mismatch.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/
BOOL FAR PASCAL 
DeleteGatewayPassword( 
    DWORD nArgs, 
    LPSTR apszArgs[], 
    LPSTR * ppszResult 
    )
{
    return TRUE ;    // work is done in cleanup below which does everything.
}

/*******************************************************************

    NAME:       CleanupRegistryForNWCS

    SYNOPSIS:   Set the flag that NWCS has been removed.
                This flag is used by wfwnet.drv.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/

BOOL FAR PASCAL 
CleanupRegistryForNWCS( 
    DWORD nArgs, 
    LPSTR apszArgs[], 
    LPSTR * ppszResult 
    )
{
    HANDLE hDll ;
    DWORD err = 0, err1 = 0 ;

    (void) nArgs ;         // quiet the compiler
    (void) apszArgs ;      // quiet the compiler

    if (!WriteProfileStringA("NWCS",
                             "NwcsInstalled",
                             "0"))
    {
        err = GetLastError() ;
    }

    //
    // ignore errors for this. 
    //
    (void) SetupShellExtensions(
                   RegDeleteEntries, 
                   sizeof(RegDeleteEntries)/sizeof(RegDeleteEntries[0])) ;

    if (!err)
        err = err1 ;

    wsprintfA( achBuff, "{\"%d\"}", err );
    *ppszResult = achBuff;

    return TRUE;
}

/*******************************************************************

    NAME:       SetupShellExtensions

    SYNOPSIS:   setup the registry for shell extensions. function is driven 
                by a table of entries (RegEntries). for each entry there is a
                Operation code that tells us what we are doing. key entries can
                be created absolute or relative to previous positions, so we 
                maintain a stack of registry handles for the latter case. every
                key that is created is initially put on the stack. values
                are always written based on the 'current stack' position.

    ENTRY:      NONE 

    RETURN:     Win32 error code 

    HISTORY:
                chuckc  29-Nov-1995     Created

********************************************************************/
DWORD SetupShellExtensions(REG_ENTRY RegEntries[], DWORD dwNumEntries) 
{
    DWORD  err, errClose, dwDisposition, i ; 
    HKEY   hKey, RegHandleStack[MAX_REG_LEVEL] ; 
    LONG   StackIndex = -1 ;
    
    //
    // Loop thru and for each entry. Then switch & do the appropriate 
    // operation in the registry.
    //

    for (i = 0; i < dwNumEntries; i++)
    {
        err = NO_ERROR ;

        switch (RegEntries[i].Operation)
        {
            case CREATE_ABS:       

                //
                // create/open a reg key with an absolute path. since this
                // is absolute, we drop everything on the stack, and start
                // all over again.
                //
                 
                while (StackIndex >= 0)
                {
                    errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;
                    ASSERT(errClose == NO_ERROR) ;
                }
 
                err = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                                      RegEntries[i].s1,      // subkey
                                      0,                     // reserved
                                      NULL,                  // class 
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_ALL_ACCESS,
                                      NULL,                  // default security
                                      &hKey,               
                                      &dwDisposition) ;      // not used
                if (err != NO_ERROR)
                {
                    break ;
                }

                //
                // by default we advance the stack. no need check for overflow
                // as the stack is empty.
                //

                RegHandleStack[++StackIndex] = hKey ;
                break ;

            case CREATE_REL:
 
                //
                // create/open a reg key relative to current stack. make sure 
                // there is something on the stack (check StackIndex >= 0). 
                // then see if we are advancing (+1), staying the same (0) or
                // dropping back (-ve).
                //
                 
                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;  
                    break ;
                }
 
                if (RegEntries[i].Level == +1)
                {
                    //
                    // opening next level down. continue as is and use
                    // most recently opened key as the starting point.
                    //
                }
                else if (RegEntries[i].Level == 0)
                {
                    //
                    // opening at same level as last time. so we are done
                    // with the last key. what we want to do is close it
                    // and use the parent.
                    //
                    errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;

                    ASSERT(errClose == NO_ERROR) ;

                    if (StackIndex < 0)
                    {
                        err = ERROR_INVALID_FUNCTION ;
                        break ;
                    }
                }
                else if (RegEntries[i].Level < 0) 
                {
                    //
                    // dropping back & opening at a higher level. cleanup 
                    // handle for each level we pop.
                    //

                    LONG Count =  RegEntries[i].Level ;
                    
                    while (Count++ < 1)
                    {
                        errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;

                        ASSERT(errClose == NO_ERROR) ;

                        if (StackIndex < -1)
                        {
                            err = ERROR_INVALID_FUNCTION ;
                            break ;
                        }
                    }
                }
                else 
                {
                    //
                    // only -ve numbers, 0 and 1 are valid
                    //

                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }

                //
                // create key relative to current point
                //
                err = RegCreateKeyExW(RegHandleStack[StackIndex], // current key
                                      RegEntries[i].s1,      // subkey
                                      0,                     // reserved
                                      NULL,                  // class 
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_ALL_ACCESS,
                                      NULL,                  // default security
                                      &hKey,               
                                      &dwDisposition) ;      // not used
                if (err != NO_ERROR)
                {
                    break ;
                }

                //
                // by default we advance the stack
                //

                RegHandleStack[++StackIndex] = hKey ;   
                
                if (StackIndex >= MAX_REG_LEVEL)
                {
                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }
                
                break ;

            case VALUE_STR:
 
                //
                // create a REG_SZ value at current point. check we have 
                // handle on stack.
                //

                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }

                err = RegSetValueExW(
                           RegHandleStack[StackIndex],       // current key
                           RegEntries[i].s1,                 // value name
                           0,                                // reserved
                           REG_SZ,
                           (BYTE *)RegEntries[i].s2,         // value data
                           (wcslen(RegEntries[i].s2)+1)*sizeof(WCHAR)) ;
                break ;

            case DELETE_ABS:       

                //
                // delete a key (absolute). no change to stack.
                //

                err = RegDeleteKeyW(HKEY_LOCAL_MACHINE,
                                    RegEntries[i].s1) ;        // subkey

                if ( err == ERROR_FILE_NOT_FOUND )
                    err = NO_ERROR;

                break ;

            case DELETE_REL:       

                //
                // delete a key (relative). no change to stack.
                //

                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }

                err = RegDeleteKeyW(RegHandleStack[StackIndex],   // current key
                                    RegEntries[i].s1) ;           // subkey

                if ( err == ERROR_FILE_NOT_FOUND )
                    err = NO_ERROR;

                break ;

            case DELETE_VAL:
 
                //
                // delete value at current point. check we have handle on stack.
                //

                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }

                err = RegDeleteValueW(RegHandleStack[StackIndex], // current key
                                      RegEntries[i].s1) ;         // value name
                break ;

            case DROP_STACK:
 
                //
                // drop current stack by one (closing the handle).
                //
                 
                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;  
                    break ;
                }

                errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;

                ASSERT(errClose == NO_ERROR) ;
              
                break ;
 
            default:

                //
                // error out if unknown operation
                //

                err = ERROR_INVALID_FUNCTION ;
                break ;
        }

        if (err != NO_ERROR)
        {
            break ;
        }
    }

    //
    // cleanup open handles on the stack
    //

    while (StackIndex >= 0)
    {
        errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;
        ASSERT(errClose == NO_ERROR) ;
    }
 
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\setupdll\unlodctr.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    unlodctr.c

Abstract:

    Program to remove the counter names belonging to the driver specified
        in the command line and update the registry accordingly

Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
//
//  Windows Include files
//
#include <windows.h>
#include <winperf.h>
#include <tchar.h>
//
//  local include files
//
//#define  _INITIALIZE_GLOBALS_   1   // to define & init global buffers
#include "common.h"
//#undef   _INITIALIZE_GLOBALS_
#include "nwcfg.hxx"

// version number for NT 1.0
#define OLD_VERSION  0x010000
DWORD   dwSystemVersion;    // PerfLib version number
DWORD   dwHelpItems;        // number of explain text items
DWORD   dwCounterItems;     // number of counter text items
DWORD   dwLastCounter;
DWORD   dwLastHelp;


LPTSTR
*BuildNameTable(
    IN HKEY    hKeyPerflib,     // handle to perflib key with counter names
    IN LPTSTR  lpszLangId,      // unicode value of Language subkey
    OUT PDWORD  pdwLastItem,     // size of array in elements
    OUT HKEY    *hKeyNames,
    OUT LPTSTR  CounterNameBuffer,  // New version counter name key   
    OUT LPTSTR  HelpNameBuffer     // New version help name key   
)
/*++

BuildNameTable

    Caches the counter names and explain text to accelerate name lookups
    for display.

Arguments:

    hKeyPerflib
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 009)

    pdwLastItem
            The last array element

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated TEXT strings.

    A NULL pointer is returned if an error occured. (error value is
    available using the GetLastError function).

    The structure of the buffer returned is:

        Array of pointers to zero terminated strings consisting of
            pdwLastItem elements

        MULTI_SZ string containing counter id's and names returned from
            registry for the specified language

        MULTI_SZ string containing explain text id's and explain text strings
            as returned by the registry for the specified language

    The structures listed above are contiguous so that they may be freed
    by a single "free" call when finished with them, however only the
    array elements are intended to be used.

--*/
{

    LPTSTR  *lpReturnValue;     // returned pointer to buffer

    LPTSTR  *lpCounterId;       //
    LPTSTR  lpCounterNames;     // pointer to Names buffer returned by reg.
    LPTSTR  lpHelpText ;        // pointet to exlpain buffer returned by reg.

    LPTSTR  lpThisName;         // working pointer


    BOOL    bStatus;            // return status from TRUE/FALSE fn. calls
    LONG    lWin32Status;       // return status from fn. calls

    DWORD   dwValueType;        // value type of buffer returned by reg.
    DWORD   dwArraySize;        // size of pointer array in bytes
    DWORD   dwBufferSize;       // size of total buffer in bytes
    DWORD   dwCounterSize;      // size of counter text buffer in bytes
    DWORD   dwHelpSize;         // size of help text buffer in bytes
    DWORD   dwThisCounter;      // working counter

    DWORD   dwLastId;           // largest ID value used by explain/counter text

    LPTSTR  lpValueNameString;  // pointer to buffer conatining subkey name

    //initialize pointers to NULL

    lpValueNameString = NULL;
    lpReturnValue = NULL;

    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = DefaultLangId;
    }

    if (hKeyNames) {
        *hKeyNames = NULL;
    } else {
        SetLastError (ERROR_BAD_ARGUMENTS);
        return NULL;
    }

    // use the greater of Help items or Counter Items to size array

    if (dwHelpItems >= dwCounterItems) {
        dwLastId = dwHelpItems;
    } else {
        dwLastId = dwCounterItems;
    }

    // array size is # of elements (+ 1, since names are "1" based)
    // times the size of a pointer

    dwArraySize = (dwLastId + 1) * sizeof(LPTSTR);

    // allocate string buffer for language ID key string

    lpValueNameString = malloc (
        lstrlen(NamesKey) * sizeof (TCHAR) +
        lstrlen(Slash) * sizeof (TCHAR) +
        lstrlen(lpszLangId) * sizeof (TCHAR) +
        sizeof (TCHAR));

    if (!lpValueNameString) {
        lWin32Status = ERROR_OUTOFMEMORY;
        goto BNT_BAILOUT;
    }

    lWin32Status = RegOpenKeyEx (   // get handle to this key in the
        hKeyPerflib,               // registry
        lpszLangId,
        RESERVED,
        KEY_READ | KEY_WRITE,
        hKeyNames);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // get size of counter names

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        Counters,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwCounterSize = dwBufferSize;

    // get size of help text

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        Help,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwHelpSize = dwBufferSize;

    // allocate buffer with room for pointer array, counter name
    // strings and help name strings

    lpReturnValue = malloc (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        lWin32Status = ERROR_OUTOFMEMORY;
        goto BNT_BAILOUT;
    }

    // initialize buffer

    memset (lpReturnValue, 0, _msize(lpReturnValue));

    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPTSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPTSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counter names into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Name"

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        Counters,
        RESERVED,
        &dwValueType,
        (LPVOID)lpCounterNames,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // read explain text into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Text..."

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        Help,
        RESERVED,
        &dwValueType,
        (LPVOID)lpHelpText,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // load counter array items, by locating each text string
    // in the returned buffer and loading the
    // address of it in the corresponding pointer array element.

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal digit characters)
        // so translate to an integer for use in array element identification

        bStatus = StringToInt (lpThisName, &dwThisCounter);

        if (!bStatus) {
            // error is in GetLastError
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name which follows the id number
        // string.

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element with pointer to string

        lpCounterId[dwThisCounter] = lpThisName;

    }

    // repeat the above for the explain text strings

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        bStatus = StringToInt (lpThisName, &dwThisCounter);

        if (!bStatus) {
            // error is in GetLastError
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }

    // if the last item arugment was used, then load the last ID value in it

    if (pdwLastItem) *pdwLastItem = dwLastId;

    // free the temporary buffer used

    if (lpValueNameString) {
        free ((LPVOID)lpValueNameString);
    }

    // exit returning the pointer to the buffer

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        // if lWin32Status has error, then set last error value to it,
        // otherwise assume that last error already has value in it
        SetLastError (lWin32Status);
    }

    // free buffers used by this routine

    if (lpValueNameString) {
        free ((LPVOID)lpValueNameString);
    }

    if (lpReturnValue) {
        free ((LPVOID)lpReturnValue);
    }

    return NULL;
} // BuildNameTable


BOOL
GetDriverFromCommandLine (
    HKEY    hKeyMachine,
    LPTSTR  *lpDriverName,
    HKEY    *hDriverPerf,
    LPSTR argv[]
)
/*++

GetDriverFromCommandLine

    locates the first argument in the command line string (after the
    image name) and checks to see if

        a) it's there

        b) it's the name of a device driver listed in the
            Registry\Machine\System\CurrentControlSet\Services key
            in the registry and it has a "Performance" subkey

        c) that the "First Counter" value under the Performance subkey
            is defined.

    if all these criteria are true, then the routine returns TRUE and
    passes the pointer to the driver name back in the argument. If any
    one of them fail, then NULL is returned in the DriverName arg and
    the routine returns FALSE

Arguments

    lpDriverName

        the address of a LPTSTR to recive the pointer to the driver name

    hDriverPerf

        the key to the driver's performance subkey

Return Value

    TRUE if a valid driver was found in the command line

    FALSE if not (see above)

--*/
{
    LPTSTR  lpDriverKey;    // buffer to build driver key name in
    LPTSTR  lpThisChar;

    LONG    lStatus;
    DWORD   dwFirstCounter;
    DWORD   dwSize;
    DWORD   dwType;

    if (!lpDriverName || !hDriverPerf) {
        SetLastError (ERROR_BAD_ARGUMENTS);
        return FALSE;
    }

    *lpDriverName = NULL;   // initialize to NULL
    *hDriverPerf = NULL;

    lpThisChar = malloc( MAX_PATH * sizeof(TCHAR));
    if (lpThisChar == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
    *lpThisChar = 0;

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, argv[0], -1, lpThisChar, MAX_PATH);

    if (*lpThisChar) {
        // an argument was found so see if it's a driver
        lpDriverKey = malloc (MAX_PATH * sizeof (TCHAR));
        if (!lpDriverKey) {
            SetLastError (ERROR_OUTOFMEMORY);
            if ( lpThisChar ) free (lpThisChar);
            return FALSE;
        }

        lstrcpy (lpDriverKey, DriverPathRoot);
        lstrcat (lpDriverKey, Slash);
        lstrcat (lpDriverKey, lpThisChar);
        lstrcat (lpDriverKey, Slash);
        lstrcat (lpDriverKey, Performance);

        lStatus = RegOpenKeyEx (
            hKeyMachine,
            lpDriverKey,
            RESERVED,
            KEY_READ | KEY_WRITE,
            hDriverPerf);

        if (lStatus == ERROR_SUCCESS) {
            //
            //  this driver has a performance section so see if its
            //  counters are installed by checking the First Counter
            //  value key for a valid return. If it returns a value
            //  then chances are, it has some counters installed, if
            //  not, then display a message and quit.
            //
            free (lpDriverKey); // don't need this any more

            dwType = 0;
            dwSize = sizeof (dwFirstCounter);

            lStatus = RegQueryValueEx (
                *hDriverPerf,
                FirstCounter,
                RESERVED,
                &dwType,
                (LPBYTE)&dwFirstCounter,
                &dwSize);

            if (lStatus == ERROR_SUCCESS) {
                // counter names are installed so return success
                *lpDriverName = lpThisChar;
                SetLastError (ERROR_SUCCESS);
                if ( lpThisChar ) free (lpThisChar);
                return TRUE;
            } else {
                SetLastError (ERROR_BADKEY);
                if ( lpThisChar ) free (lpThisChar);
                return FALSE;
            }
        } else { // key not found
            SetLastError (lStatus);
            free (lpDriverKey);
            if ( lpThisChar ) free (lpThisChar);
            return FALSE;
        }
    } else {
        SetLastError (ERROR_INVALID_PARAMETER);
        if ( lpThisChar ) free (lpThisChar);
        return FALSE;
    }
}


LONG
FixNames (
    HANDLE  hKeyLang,
    LPTSTR  *lpOldNameTable,
    IN LPTSTR  lpszLangId,      // unicode value of Language subkey
    DWORD   dwLastItem,
    DWORD   dwFirstNameToRemove,
    DWORD   dwLastNameToRemove
   )
{
    LONG    lStatus;
    LPTSTR  lpNameBuffer = NULL;
    LPTSTR  lpHelpBuffer = NULL;
    DWORD   dwTextIndex, dwSize;
    LPTSTR  lpNextHelpText;
    LPTSTR  lpNextNameText;

    // allocate space for the array of new text it will point
    // into the text buffer returned in the lpOldNameTable buffer)

    lpNameBuffer = malloc (_msize(lpOldNameTable));
    lpHelpBuffer = malloc (_msize(lpOldNameTable));

    if (!lpNameBuffer || !lpHelpBuffer) {
        if (lpNameBuffer) {
            free(lpNameBuffer);
        }
        if (lpHelpBuffer) {
            free(lpHelpBuffer);
        }
        lStatus = ERROR_OUTOFMEMORY;
        return lStatus;
    }

    // remove this driver's counters from array

    for (dwTextIndex = dwFirstNameToRemove;
         dwTextIndex <= dwLastNameToRemove;
         dwTextIndex++) {

        if (dwTextIndex > dwLastItem)
           break;

        lpOldNameTable[dwTextIndex] = NULL;
    }

    lpNextHelpText = lpHelpBuffer;
    lpNextNameText = lpNameBuffer;

    // build new Multi_SZ strings from New Table

    for (dwTextIndex = 0; dwTextIndex <= dwLastItem; dwTextIndex++){
        if (lpOldNameTable[dwTextIndex]) {
            // if there's a text string at that index, then ...
            if (dwTextIndex & 0x1) {    // ODD number == Help Text
                lpNextHelpText +=
                    _stprintf (lpNextHelpText, TEXT("%d"), dwTextIndex) + 1;
                lpNextHelpText +=
                    _stprintf (lpNextHelpText, TEXT("%s"),
                    lpOldNameTable[dwTextIndex]) + 1;
                if (dwTextIndex > dwLastHelp){
                    dwLastHelp = dwTextIndex;
                }
            } else { // EVEN number == counter name text
                lpNextNameText +=
                    _stprintf (lpNextNameText, TEXT("%d"), dwTextIndex) + 1;
                lpNextNameText +=
                    _stprintf (lpNextNameText, TEXT("%s"),
                lpOldNameTable[dwTextIndex]) + 1;
                if (dwTextIndex > dwLastCounter){
                    dwLastCounter = dwTextIndex;
                }
            }
        }
    } // for dwTextIndex

    // add MULTI_SZ terminating NULL
    *lpNextNameText++ = TEXT ('\0');
    *lpNextHelpText++ = TEXT ('\0');

    // update counter name text buffer

    dwSize = (DWORD)((LPBYTE)lpNextNameText - (LPBYTE)lpNameBuffer);
        lStatus = RegSetValueEx (
            hKeyLang,
            Counters,
            RESERVED,
            REG_MULTI_SZ,
            (LPBYTE)lpNameBuffer,
            dwSize);

    if (lStatus != ERROR_SUCCESS) {
//        printf (GetFormatResource(UC_UNABLELOADLANG),
//                Counters, lpLangName, lStatus);
        goto UCN_FinishLang;
    }

    dwSize = (DWORD)((LPBYTE)lpNextHelpText - (LPBYTE)lpHelpBuffer);
    lStatus = RegSetValueEx (
        hKeyLang,
        Help,
        RESERVED,
        REG_MULTI_SZ,
        (LPBYTE)lpHelpBuffer,
        dwSize);

    if (lStatus != ERROR_SUCCESS) {
//        printf (GetFormatResource(UC_UNABLELOADLANG),
//                Help, lpLangName, lStatus);
        goto UCN_FinishLang;
    }


UCN_FinishLang:

    free (lpNameBuffer);
    free (lpHelpBuffer);
    free (lpOldNameTable);

    RegCloseKey (hKeyLang);

    return lStatus;
}

LONG
UnloadCounterNames (
    HKEY    hKeyMachine,
    HKEY    hDriverPerf,
    LPTSTR  lpDriverName
)
/*++

UnloadCounterNames

    removes the names and explain text for the driver referenced by
    hDriverPerf and updates the first and last counter values accordingly

    update process:

        - set "updating" flag under Perflib to name of driver being modified
        - FOR each language under perflib key
            -- load current counter names and explain text into array of
                pointers
            -- look at all drivers and copy their names and text into a new
                buffer adjusting for the removed counter's entries keeping
                track of the lowest entry copied.  (the names for the driver
                to be removed will not be copied, of course)
            -- update each driver's "first" and "last" index values
            -- copy all other entries from 0 to the lowest copied (i.e. the
                system counters)
            -- build a new MULIT_SZ string of help text and counter names
            -- load new strings into registry
        - update perflibl "last" counters
        - delete updating flag

     ******************************************************
     *                                                    *
     *  NOTE: FUNDAMENTAL ASSUMPTION.....                 *
     *                                                    *
     *  this routine assumes that:                        *
     *                                                    *
     *      ALL COUNTER NAMES are even numbered and       *
     *      ALL HELP TEXT STRINGS are odd numbered        *
     *                                                    *
     ******************************************************

Arguments

    hKeyMachine

        handle to HKEY_LOCAL_MACHINE node of registry on system to
        remove counters from

    hDrivefPerf
        handle to registry key of driver to be de-installed

    lpDriverName
        name of driver being de-installed

Return Value

    DOS Error code.

        ERROR_SUCCESS if all went OK
        error value if not.

--*/
{

    HKEY    hPerflib;
    HKEY    hServices;
    HKEY    hKeyLang;

    LONG    lStatus;

    DWORD   dwLangIndex;
    //
    //  dfergus 19 Apr 2001 - 295153
    //  Init dwSize
    //
    DWORD   dwSize = 0;
    DWORD   dwType;
    DWORD   dwLastItem;


    DWORD   dwRemLastDriverCounter;
    DWORD   dwRemFirstDriverCounter;
    DWORD   dwRemLastDriverHelp;
    DWORD   dwRemFirstDriverHelp;

    DWORD   dwFirstNameToRemove;
    DWORD   dwLastNameToRemove;

    LPTSTR  *lpOldNameTable;

    LPTSTR  lpLangName = NULL;
    LPTSTR  lpThisDriver = NULL;

    BOOL    bPerflibUpdated = FALSE;
    BOOL    bDriversShuffled = FALSE;

    DWORD   dwBufferSize;       // size of total buffer in bytes

    TCHAR   CounterNameBuffer [40];
    TCHAR   HelpNameBuffer [40];

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        DriverPathRoot,
        RESERVED,
        KEY_READ | KEY_WRITE,
        &hServices);

    if (lStatus != ERROR_SUCCESS) {
        return lStatus;
    }

    // open registry handle to perflib key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        NamesKey,
        RESERVED,
        KEY_READ | KEY_WRITE,
        &hPerflib);

    if (lStatus != ERROR_SUCCESS) {
        return lStatus;
    }

    // check & set Busy flag...

    lStatus = RegQueryValueEx (
        hPerflib,
        Busy,
        RESERVED,
        &dwType,
        NULL,
        &dwSize);

    if (lStatus == ERROR_SUCCESS) { // perflib is in use at the moment
        return ERROR_BUSY;
    }


    lStatus = RegSetValueEx (
        hPerflib,
        Busy,
        RESERVED,
        REG_SZ,
        (LPBYTE)lpDriverName,
        lstrlen(lpDriverName) * sizeof(TCHAR));

    if (lStatus != ERROR_SUCCESS) {
        RegCloseKey (hPerflib);
        return lStatus;
    }

    // query registry to get number of Explain text items

    dwBufferSize = sizeof (dwHelpItems);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwHelpItems,
        &dwBufferSize);

    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        RegCloseKey (hPerflib);
        return lStatus;
    }

    // query registry to get number of counter and object name items

    dwBufferSize = sizeof (dwCounterItems);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwCounterItems,
        &dwBufferSize);

    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        RegCloseKey (hPerflib);
        return lStatus;
    }

    // query registry to get PerfLib system version

    dwBufferSize = sizeof (dwSystemVersion);
    lStatus = RegQueryValueEx (
        hPerflib,
        VersionStr,
        RESERVED,
        &dwType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        // Key not there, must be NT 1.0 version
        dwSystemVersion = OLD_VERSION;
    }

    if ( dwSystemVersion != OLD_VERSION )
    {
        // ERROR. The caller should check the version before calling me.
        // let return busy for now... 
        return(ERROR_BUSY);
    }


    // allocate temporary String buffer

    lpLangName = malloc (MAX_PATH * sizeof(TCHAR));
    lpThisDriver = malloc (MAX_PATH * sizeof(TCHAR));

    if (!lpLangName || !lpThisDriver) {
        lStatus = ERROR_OUTOFMEMORY;
        goto UCN_ExitPoint;
    }

    // Get the values that are in use by the driver to be removed

    dwSize = sizeof (dwRemLastDriverCounter);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemLastDriverCounter,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemFirstDriverCounter);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        FirstCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemFirstDriverCounter,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemLastDriverHelp);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        LastHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemLastDriverHelp,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemFirstDriverHelp);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        FirstHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemFirstDriverHelp,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        goto UCN_ExitPoint;
    }

    //  get the first and last counters to define block of names used
    //  by this device

    dwFirstNameToRemove = (dwRemFirstDriverCounter <= dwRemFirstDriverHelp ?
        dwRemFirstDriverCounter : dwRemFirstDriverHelp);

    dwLastNameToRemove = (dwRemLastDriverCounter >= dwRemLastDriverHelp ?
        dwRemLastDriverCounter : dwRemLastDriverHelp);

    dwLastCounter = dwLastHelp = 0;

    // do each language under perflib
    for (dwLangIndex = 0, dwSize = _msize(lpLangName);
         (RegEnumKey(hPerflib, dwLangIndex, lpLangName, dwSize)) == ERROR_SUCCESS;
        dwLangIndex++, dwSize = _msize(lpLangName)) {

        lpOldNameTable = BuildNameTable (hPerflib, lpLangName,
            &dwLastItem, &hKeyLang, CounterNameBuffer, HelpNameBuffer);

        if (lpOldNameTable) {
            if (!FixNames (
                hKeyLang,
                lpOldNameTable,
                lpLangName,
                dwLastItem,
                dwFirstNameToRemove,
                dwLastNameToRemove)) {
                bPerflibUpdated = TRUE;
            }
        } else { // unable to unload names for this language
            // display error message
        }
    } // end for (more languages)

    if (bPerflibUpdated) {
        // update perflib's "last" values

        dwSize = sizeof (dwLastCounter);
        lStatus = RegSetValueEx (
            hPerflib,
            LastCounter,
            RESERVED,
            REG_DWORD,
            (LPBYTE)&dwLastCounter,
            dwSize);

        dwSize = sizeof (dwLastHelp);
        lStatus = RegSetValueEx (
            hPerflib,
            LastHelp,
            RESERVED,
            REG_DWORD,
            (LPBYTE)&dwLastHelp,
            dwSize);

        // update "driver"s values (i.e. remove them)

        RegDeleteValue (hDriverPerf, FirstCounter);
        RegDeleteValue (hDriverPerf, LastCounter);
        RegDeleteValue (hDriverPerf, FirstHelp);
        RegDeleteValue (hDriverPerf, LastHelp);

    }

UCN_ExitPoint:
    RegDeleteValue (hPerflib, Busy);
    RegCloseKey (hPerflib);
    RegCloseKey (hServices);
    if (lpLangName) free (lpLangName);
    if (lpThisDriver) free (lpThisDriver);

    return lStatus;


}

BOOL FAR PASCAL unlodctr(DWORD argc,LPSTR argv[], LPSTR *ppszResult )
/*++

main

    entry point to Counter Name Unloader



Arguments

    argc
        # of command line arguments present

    argv
        array of pointers to command line strings

    (note that these are obtained from the GetCommandLine function in
    order to work with both UNICODE and ANSI strings.)

ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpDriverName;   // name of driver to delete from perflib
    HKEY    hDriverPerf;    // handle to performance sub-key of driver


    DWORD   dwStatus;       // return status of fn. calls

    *ppszResult = achBuff;

    wsprintfA( achBuff, "{\"NO_ERROR\"}");

    if (!GetDriverFromCommandLine (
        HKEY_LOCAL_MACHINE, &lpDriverName, &hDriverPerf, argv)) {
        // error message was printed in routine if there was an error
        wsprintfA( achBuff,"{\"ERROR\"}");
        return (FALSE);
    }

    // removes names and explain text for driver in lpDriverName
    // displays error messages for errors encountered

    dwStatus = (DWORD)UnloadCounterNames (HKEY_LOCAL_MACHINE,
        hDriverPerf, lpDriverName);

    RegCloseKey (hDriverPerf);

    if ( dwStatus != ERROR_SUCCESS )
    {
        wsprintfA( achBuff,"{\"ERROR\"}");
    }

    return (dwStatus==ERROR_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\wksta\makefile.inc ===
INFHEADER=$(TARGET_DIRECTORY).txt

!IFNDEF INFLANGUAGE
INFLANGUAGE=ENG
!ENDIF

all: oemnsvnw.inf

make_inf: oemnsvnw.inf

clean:  cleansrc oemnsvnw.inf

cleansrc:
        del oemnsvnw.inf


!IF "$(QFE_BUILD)" != "1"

oemnsvnw.inf: $(INFHEADER) nw.inf $(INFLANGUAGE).txt files10a.txt
        copy $(INFHEADER)+$(INFLANGUAGE).txt+nw.inf+files10a.txt oemnsvnw.inf
        binplace oemnsvnw.inf

!ELSE

oemnsvnw.inf: $(INFHEADER) nw.inf $(INFLANGUAGE).txt files10.txt
        copy $(INFHEADER)+$(INFLANGUAGE).txt+nw.inf+files10.txt oemnsvnw.inf
        binplace oemnsvnw.inf

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\install\wksta\nwperfm.h ===
//
//  NWPerfM.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values of the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define NWOBJ                       0
#define PACKET_BURST_READ_ID        2
#define PACKET_BURST_READ_TO_ID     4
#define PACKET_BURST_WRITE_ID       6
#define PACKET_BURST_WRITE_TO_ID    8
#define PACKET_BURST_IO_ID         10
#define CONNECT_2X_ID              12
#define CONNECT_3X_ID              14
#define CONNECT_4X_ID              16

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\dll\debug.c ===
/*++

Copyright (c) 1991-3  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This component of netbios runs in the user process and can ( when
    built in a debug kernel) will log to either the console or through the
    kernel debugger.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/

#include "procs.h"

#if NWDBG

//
//  Set DebugControl to 1 to open the logfile on the first NW call and close it
//  on process exit.
//

int  DebugCtrl = 0;

BOOL UseConsole = FALSE;
BOOL UseLogFile = FALSE;
BOOL Verbose    = FALSE;

HANDLE LogFile = INVALID_HANDLE_VALUE;
#define LOGNAME                 (LPTSTR) TEXT("c:\\nwapi16.log")

LONG NwMaxDump = SERVERNAME_LENGTH * MC; //128;

#define ERR_BUF_SIZE    260
#define NAME_BUF_SIZE   260

extern UCHAR CpuInProtectMode;

LPSTR
ConvertFlagsToString(
    IN  WORD    FlagsRegister,
    OUT LPSTR   Buffer
    );

WORD
GetFlags(
    VOID
    );

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    );

VOID
DebugControl(
    int Command
    )
/*++

Routine Description:

    This routine controls what we output as debug information and where.

Arguments:

    IN  int Command

Return Value:

    none.

--*/
{

    switch (Command) {
    case 0:
        UseLogFile = TRUE;
        break;

    case 1:
        UseConsole = TRUE;
        break;

    case 2:
        if (LogFile != INVALID_HANDLE_VALUE) {
            CloseHandle(LogFile);
            LogFile = INVALID_HANDLE_VALUE;
        }
        UseLogFile = FALSE;
        UseConsole = FALSE;
        break;

    case 8:
        Verbose = TRUE; //  Same as 4 only chatty
        DebugCtrl = 4;

    case 4:
        UseLogFile = TRUE;
        break;

    }
    NwPrint(("DebugControl %x\n", Command ));
}

VOID
NwPrintf(
    char *Format,
    ...
    )
/*++

Routine Description:

    This routine is equivalent to printf with the output being directed to
    stdout.

Arguments:

    IN  char *Format - Supplies string to be output and describes following
        (optional) parameters.

Return Value:

    none.

--*/
{
    va_list arglist;
    char OutputBuffer[200];
    int length;

    if (( UseConsole == FALSE ) &&
        ( UseLogFile == FALSE )) {
        return;
    }


    va_start( arglist, Format );

    length = _vsnprintf( OutputBuffer, sizeof(OutputBuffer)-1, Format, arglist );
    if (length < 0) {
        return;
    }

    OutputBuffer[sizeof(OutputBuffer)-1] = '\0';  // in-case length= 199;

    va_end( arglist );

    if ( UseConsole ) {
        DbgPrint( "%s", OutputBuffer );
    } else {

        if ( LogFile == INVALID_HANDLE_VALUE ) {
            if ( UseLogFile ) {
                LogFile = CreateFile( LOGNAME,
                            GENERIC_WRITE,
                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                            NULL,
                            TRUNCATE_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

                if (LogFile == INVALID_HANDLE_VALUE) {
                    LogFile = CreateFile( LOGNAME,
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
                }

                if ( LogFile == INVALID_HANDLE_VALUE ) {
                    UseLogFile = FALSE;
                    return;
                }
            }
        }

        WriteFile( LogFile , (LPVOID )OutputBuffer, length, &length, NULL );
    }

} // NwPrintf

void
FormattedDump(
    PCHAR far_p,
    LONG  len
    )
/*++

Routine Description:

    This routine outputs a buffer in lines of text containing hex and
    printable characters.

Arguments:

    IN  far_p - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.

Return Value:

    none.

--*/
{
    ULONG     l;
    char    s[80], t[80];

    if (( UseConsole == FALSE ) &&
        ( UseLogFile == FALSE )) {
        return;
    }

    if (( len > NwMaxDump ) ||
        ( len < 0 )) {
        len = NwMaxDump;
    }

    while (len) {
        l = len < 16 ? len : 16;

        NwPrint(("%lx ", far_p));
        HexDumpLine (far_p, l, s, t);
        NwPrint(("%s%.*s%s\n", s, 1 + ((16 - l) * 3), "", t));

        len    -= l;
        far_p  += l;
    }
}

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    )
/*++

Routine Description:

    This routine builds a line of text containing hex and printable characters.

Arguments:

    IN pch  - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.
    IN s - Supplies the start of the buffer to be loaded with the string
            of hex characters.
    IN t - Supplies the start of the buffer to be loaded with the string
            of printable ascii characters.


Return Value:

    none.

--*/
{
    static UCHAR rghex[] = "0123456789ABCDEF";

    UCHAR    c;
    UCHAR    *hex, *asc;


    hex = s;
    asc = t;

    *(asc++) = '*';
    while (len--) {
        c = *(pch++);
        *(hex++) = rghex [c >> 4] ;
        *(hex++) = rghex [c & 0x0F];
        *(hex++) = ' ';
        *(asc++) = (c < ' '  ||  c > '~') ? (CHAR )'.' : c;
    }
    *(asc++) = '*';
    *asc = 0;
    *hex = 0;

}


VOID
DisplayExtendedError(VOID)
{
    TCHAR            errorBuf[ERR_BUF_SIZE];
    TCHAR            nameBuf[NAME_BUF_SIZE];
    DWORD           errorCode;
    DWORD           status;

    status = WNetGetLastError(
                &errorCode,
                errorBuf,
                ERR_BUF_SIZE,
                nameBuf,
                NAME_BUF_SIZE);

    if(status != WN_SUCCESS) {
        NwPrint(("nwapi32: WNetGetLastError failed %d\n",status));
        return;
    }
    NwPrint(("nwapi32: EXTENDED ERROR INFORMATION:  (from GetLastError)\n"));
    NwPrint(("nwapi32:    Code:        %d\n",errorCode));
    NwPrint(("nwapi32:    Description: "FORMAT_LPSTR"\n",errorBuf));
    NwPrint(("nwapi32:    Provider:    "FORMAT_LPSTR"\n\n",nameBuf));
    return;
}

VOID
VrDumpRealMode16BitRegisters(
    IN  BOOL    DebugStyle
    )

/*++

Routine Description:

    Displays dump of 16-bit
    real-mode 80286 registers - gp registers (8), segment registers (4), flags
    register (1) instruction pointer register (1)

Arguments:

    DebugStyle  - determines look of output:

DebugStyle == TRUE:

ax=1111  bx=2222  cx=3333  dx=4444  sp=5555  bp=6666  si=7777  di=8888
ds=aaaa  es=bbbb  ss=cccc  cs=dddd  ip=iiii   fl fl fl fl fl fl fl fl

DebugStyle == FALSE:

cs:ip=cccc:iiii  ss:sp=ssss:pppp  bp=bbbb  ax=1111  bx=2222  cx=3333  dx=4444
ds:si=dddd:ssss  es:di=eeee:dddd  flags[ODIxSZxAxPxC]=fl fl fl fl fl fl fl fl

Return Value:

    None.

--*/

{
    char    flags_string[25];

    if (( UseConsole == FALSE ) &&
        ( UseLogFile == FALSE )) {
        return;
    }

    if (CpuInProtectMode) {
        NwPrint(( "Protect Mode:\n"));
    }

    if (DebugStyle) {
        NwPrint((
            "ax=%04x  bx=%04x  cx=%04x  dx=%04x  sp=%04x  bp=%04x  si=%04x  di=%04x\n"
            "ds=%04x  es=%04x  ss=%04x  cs=%04x  ip=%04x   %s\n\n",

            pNwDosTable->SavedAx, //getAX(),
            getBX(),
            getCX(),
            getDX(),
            getSP(),
            getBP(),
            getSI(),
            getDI(),
            getDS(),
            getES(),
            getSS(),
            getCS(),
            getIP(),
            ConvertFlagsToString(GetFlags(), flags_string)
            ));
    } else {
        NwPrint((
            "cs:ip=%04x:%04x  ss:sp=%04x:%04x  bp=%04x  ax=%04x  bx=%04x  cx=%04x  dx=%04x\n"
            "ds:si=%04x:%04x  es:di=%04x:%04x  flags[ODITSZxAxPxC]=%s\n\n",
            getCS(),
            getIP(),
            getSS(),
            getSP(),
            getBP(),
            pNwDosTable->SavedAx, //getAX(),
            getBX(),
            getCX(),
            getDX(),
            getDS(),
            getSI(),
            getES(),
            getDI(),
            ConvertFlagsToString(GetFlags(), flags_string)
            ));
    }
}

LPSTR
ConvertFlagsToString(
    IN  WORD    FlagsRegister,
    OUT LPSTR   Buffer
    )

/*++

Routine Description:

    Given a 16-bit word, interpret bit positions as for x86 Flags register
    and produce descriptive string of flags state (as per debug) eg:

        NV UP DI PL NZ NA PO NC     ODItSZxAxPxC = 000000000000b
        OV DN EI NG ZR AC PE CY     ODItSZxAxPxC = 111111111111b

    Trap Flag (t) is not dumped since this has no interest for programs which
    are not debuggers or don't examine program execution (ie virtually none)

Arguments:

    FlagsRegister   - 16-bit flags
    Buffer          - place to store string. Requires 25 bytes inc \0

Return Value:

    Address of <Buffer>

--*/

{
    static char* flags_states[16][2] = {
        //0     1
        "NC", "CY", // CF (0x0001) - Carry
        "",   "",   // x  (0x0002)
        "PO", "PE", // PF (0x0004) - Parity
        "",   "",   // x  (0x0008)
        "NA", "AC", // AF (0x0010) - Aux (half) carry
        "",   "",   // x  (0x0020)
        "NZ", "ZR", // ZF (0x0040) - Zero
        "PL", "NG", // SF (0x0080) - Sign
        "",   "",   // TF (0x0100) - Trap (not dumped)
        "DI", "EI", // IF (0x0200) - Interrupt
        "UP", "DN", // DF (0x0400) - Direction
        "NV", "OV", // OF (0x0800) - Overflow
        "",   "",   // x  (0x1000) - (I/O Privilege Level) (not dumped)
        "",   "",   // x  (0x2000) - (I/O Privilege Level) (not dumped)
        "",   "",   // x  (0x4000) - (Nested Task) (not dumped)
        "",   ""    // x  (0x8000)
    };
    int i;
    WORD bit;
    BOOL on;

    *Buffer = 0;
    for (bit=0x0800, i=11; bit; bit >>= 1, --i) {
        on = (BOOL)((FlagsRegister & bit) == bit);
        if (flags_states[i][on][0]) {
            strcat(Buffer, flags_states[i][on]);
            strcat(Buffer, " ");
        }
    }
    return Buffer;
}

WORD
GetFlags(
    VOID
    )

/*++

Routine Description:

    Supplies the missing softpc function

Arguments:

    None.

Return Value:

    Conglomerates softpc flags into x86 flags word

--*/

{
    WORD    flags;

    flags = (WORD)getCF();
    flags |= (WORD)getPF() << 2;
    flags |= (WORD)getAF() << 4;
    flags |= (WORD)getZF() << 6;
    flags |= (WORD)getSF() << 7;
    flags |= (WORD)getIF() << 9;
    flags |= (WORD)getDF() << 10;
    flags |= (WORD)getOF() << 11;

    return flags;
}

VOID
VrDumpNwData(
    VOID
    )

/*++

Routine Description:

    Dumps out the state of the 16 bit datastructures.

Arguments:

    none.

Return Value:

    None.

--*/

{
    int index;
    int Drive;

    if (Verbose == FALSE) {
        return;
    }

    NwPrint(( "Preferred = %x, Primary = %x\n",
        pNwDosTable->PreferredServer,
        pNwDosTable->PrimaryServer));

    for (index = 0; index < MC; index++) {


        if ((PUCHAR)pNwDosTable->ServerNameTable[index][0] != 0 ) {

            if (pNwDosTable->ConnectionIdTable[index].ci_InUse != IN_USE) {
                NwPrint(("Warning Connection not in use %x: %x\n",
                    index,
                    pNwDosTable->ConnectionIdTable[index].ci_InUse));
            }

            NwPrint((" Server %d = %s, Connection = %d\n",
                index,
                (PUCHAR)pNwDosTable-> ServerNameTable[index],
                (((pNwDosTable->ConnectionIdTable[index]).ci_ConnectionHi * 256) +
                 ( pNwDosTable-> ConnectionIdTable[index]).ci_ConnectionLo )));
        } else {
            if (pNwDosTable->ConnectionIdTable[index].ci_InUse != FREE) {
                NwPrint(("Warning Connection in use but name is null %x: %x\n",
                            index,
                            pNwDosTable->ConnectionIdTable[index]));
            }
        }
    }

    for (Drive = 0; Drive < MD; Drive++ ) {


        if (pNwDosTable->DriveFlagTable[Drive] & 3) {
            NwPrint(("%c=%x on server %d,",'A' + Drive,
                pNwDosTable->DriveFlagTable[Drive],
                pNwDosTable->DriveIdTable[ Drive ] ));
        }

    }
    NwPrint(("\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\dll\locks.c ===
/*++

Copyright (c) 1993/4  Microsoft Corporation

Module Name:

    Locks.c

Abstract:

    This module implements the routines for the NetWare
    16 bit support to perform the synchonization api's

Author:

    Colin Watson    [ColinW]    07-Dec-1993

Revision History:

--*/

#include "Procs.h"
UCHAR LockMode = 0;

BOOLEAN Tickle[MC];

NTSTATUS
Sem(
    UCHAR Function,
    UCHAR Connection
    );

VOID
Locks(
    USHORT Command
    )
/*++

Routine Description:

    Implements all the locking operations

Arguments:

    Command - supplies Applications AX.

Return Value:

    Return status.

--*/
{
    UCHAR Function = Command & 0x00ff;
    USHORT Operation = Command & 0xff00;
    CONN_INDEX Connection;
    NTSTATUS status = STATUS_SUCCESS;
    PUCHAR Request;
    ULONG RequestLength;
    WORD Timeout;

    if ( Operation != 0xCF00) {

        //
        //  Connection does not need to be initialised for CF00 because
        //  we have to loop through all connections. Its harmful because
        //  a CF00 is created during ProcessExit(). If we call selectconnection
        //  and there is no server available this will make process exit
        //  really slow.
        //

        Connection = SelectConnectionInCWD();
        if (Connection == 0xff) {
            setAL(0xff);
            return;
        }

        if ( ServerHandles[Connection] == NULL ) {

            status = OpenConnection( Connection );

            if (!NT_SUCCESS(status)) {
                setAL((UCHAR)RtlNtStatusToDosError(status));
                return;
            }
        }
    }

    switch ( Operation ) {

    case 0xBC00:        //  Log physical record

        status = NwlibMakeNcp(
                    GET_NT_HANDLE(),
                    NWR_ANY_HANDLE_NCP(0x1A),
                    17, //  RequestSize
                    0,  //  ResponseSize
                    "b_wwwww",
                    Function,
                    6,              //  Leave space for NetWare handle
                    getCX(),getDX(),
                    getSI(),getDI(),
                    getBP());
        break;

    case 0xBD00:        //  Physical Unlock
        status = NwlibMakeNcp(
                    GET_NT_HANDLE(),
                    NWR_ANY_HANDLE_NCP(0x1C),
                    15, //  RequestSize
                    0,  //  ResponseSize
                    "b_wwww",
                    Function,
                    6,              //  Leave space for NetWare handle
                    getCX(),getDX(),
                    getSI(),getDI());

        break;

    case 0xBE00:        //  Clear physical record

        status = NwlibMakeNcp(
                    GET_NT_HANDLE(),
                    NWR_ANY_HANDLE_NCP(0x1E),
                    15, //  RequestSize
                    0,  //  ResponseSize
                    "b_wwww",
                    Function,
                    6,              //  Leave space for NetWare handle
                    getCX(),getDX(),
                    getSI(),getDI());

        break;

    case 0xC200:        //  Physical Lock set
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x1B),
                    3,  //  RequestSize
                    0,  //  ResponseSize
                    "bw",
                    Function,
                    getBP());
        break;

    case 0xC300:        //  Release Physical Record Set
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x1D),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
        break;

    case 0xC400:        //  Clear Physical Record Set
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x1F),   //  Clear Physical Record Set
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
        break;

    case 0xC500:    //  All Semaphore operations
        status = Sem(Function, Connection);
        break;

    case 0xC600:    //  Set/Get Lock mode

        if (Function != 2) {
            LockMode = Function;
        }

        setAL(LockMode);
        return; // avoid setting AL to status at the end of this routine
        break;

    case 0xCB00:        //  Lock File Set

        if (LockMode == 0) {
            if (getDL()) {
                Timeout = 0xffff;
            } else {
                Timeout = 0;
            }
        } else {
            Timeout = getBP();
        }

        for (Connection = 0; Connection < MC; Connection++) {
            if (Tickle[Connection]) {
                status = NwlibMakeNcp(
                            ServerHandles[Connection],
                            NWR_ANY_F2_NCP(0x04),
                            2,  //  RequestSize
                            0,  //  ResponseSize
                            "w",
                            Timeout);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            }
        }
        break;

    case 0xCD00:        //  Release File Set
    case 0xCF00:        //  Clear File Set
        for (Connection = 0; Connection < MC; Connection++) {
            if (Tickle[Connection]) {
                status = NwlibMakeNcp(
                            ServerHandles[Connection],
                            (Operation == 0xCD00) ? NWR_ANY_F2_NCP(0x06): NWR_ANY_F2_NCP(0x08),
                            0,  //  RequestSize
                            0,  //  ResponseSize
                            "");
                if (!NT_SUCCESS(status)) {
                    break;
                }

                if (Operation == 0xCF00) {
                    Tickle[Connection] = FALSE;
                }
            }
        }

        break;

    case 0xD000:        //  Log Logical Record

        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                sizeof(UCHAR),
                                IS_PROTECT_MODE());

        RequestLength = Request[0] + 1;

        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                RequestLength,
                                IS_PROTECT_MODE());

        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x09),
                    RequestLength + 5,  //  RequestSize
                    0,  //  ResponseSize
                    "bwbr",
                    (LockMode) ? Function : 0,
                    (LockMode) ? getBP() : 0,
                    RequestLength,
                    Request, RequestLength );
        break;

    case 0xD100:        //  Lock Logical Record Set

        if (LockMode == 0) {
            if (getDL()) {
                Timeout = 0xffff;
            } else {
                Timeout = 0;
            }
        } else {
            Timeout = getBP();
        }

        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x0A),
                    3,  //  RequestSize
                    0,  //  ResponseSize
                    "bw",
                    (LockMode) ? Function : 0,
                    Timeout);
        break;

    case 0xD200:        //  Release File
    case 0xD400:        //  Clear Logical Record
        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                sizeof(UCHAR),
                                IS_PROTECT_MODE());

        RequestLength = Request[0]+1;

        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                RequestLength,
                                IS_PROTECT_MODE());

        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    (Operation == 0xD200) ? NWR_ANY_F2_NCP(0x0C) :
                        NWR_ANY_F2_NCP(0x0B),
                    RequestLength+1,
                    0,  //  ResponseSize
                    "br",
                    RequestLength,
                    Request, RequestLength );
        break;

    case 0xD300:
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x13),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
        break;


    case 0xD500:    //  Clear Logical Record Set
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x0E),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
        break;

    case 0xEB00:    //  Log File
    case 0xEC00:    //  Release File
    case 0xED00:    //  Clear File
        {
            UCHAR DirHandle;
            HANDLE Win32DirectoryHandle = 0;
            PUCHAR ptr;

            Request = GetVDMPointer (
                                    (ULONG)((getDS() << 16)|getDX()),
                                    256 * sizeof(UCHAR),
                                    IS_PROTECT_MODE());

            RequestLength = strlen(Request);

            //  Find DirHandle
            ptr = Request;
            while ( (*ptr != 0) &&
                    (!IS_ASCII_PATH_SEPARATOR(*ptr)) &&
                    (*ptr != ':' )) {
                ptr++;
            }

            if (IS_ASCII_PATH_SEPARATOR(*ptr)) {
                int ServerNameLength = (int) (ptr - Request);
                PUCHAR scanptr = ptr;

                //
                //  Make sure there is a ":" further up the name otherwise
                //  we could confuse foo\bar.txt with a server called foo
                //

                while ( (*scanptr != 0) &&
                        (*scanptr != ':' )) {
                    scanptr++;
                }

                if (*scanptr) {
                    //
                    //  Name is of the form server\sys:foo\bar.txt
                    //  set connection appropriately.
                    //

                    for (Connection = 0; Connection < MC ; Connection++ ) {

                        //
                        //  Look for server foo avoiding foobar.
                        //

                        if ((pNwDosTable->ConnectionIdTable[Connection].ci_InUse ==
                                    IN_USE) &&
                            (!memcmp( pNwDosTable->ServerNameTable[Connection],
                                      Request,
                                      ServerNameLength)) &&
                            (pNwDosTable->ServerNameTable[Connection][ServerNameLength] ==
                                '\0')) {
                            break;  // Connection is the correct server
                        }
                    }

                    //
                    // Move Request to after the seperator and ptr to the ":"
                    //

                    RequestLength -= (ULONG) (ptr + sizeof(UCHAR) - Request);
                    Request = ptr + sizeof(UCHAR);
                    ptr = scanptr;
                }
            }

            if (*ptr) {

                //
                //  Name of form "sys:foo\bar.txt" this gives the server
                //  all the information required.
                //

                DirHandle = 0;

                if (Request[1] == ':') {

                    UCHAR Drive = tolower(Request[0])-'a';

                    //
                    //  Its a normal (redirected) drive k:foo\bar.txt.
                    //  Use the drive tables to give the connection and handle.
                    //

                    Connection = pNwDosTable->DriveIdTable[ Drive ] - 1;
                    DirHandle = pNwDosTable->DriveHandleTable[Drive];

                    if (DirHandle == 0) {
                        DirHandle = (UCHAR)GetDirectoryHandle2(Drive);
                    }
                    Request += 2;           // skip "k:"
                    RequestLength -= 2;
                }

            } else {

                WCHAR Curdir[256];

                //
                //  Name of form "foo\bar.txt"
                //

                GetCurrentDirectory(sizeof(Curdir) / sizeof(WCHAR), Curdir);

                Win32DirectoryHandle =
                    CreateFileW( Curdir,
                                0,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_BACKUP_SEMANTICS,
                                0);

                if (Win32DirectoryHandle != INVALID_HANDLE_VALUE) {
                    DWORD BytesReturned;

                    if ( DeviceIoControl(
                            Win32DirectoryHandle,
                            IOCTL_NWR_RAW_HANDLE,
                            NULL,
                            0,
                            (PUCHAR)&DirHandle,
                            sizeof(DirHandle),
                            &BytesReturned,
                            NULL ) == FALSE ) {

                        CloseHandle( Win32DirectoryHandle );
                        setAL(0xff);
                        return;

                    }

                } else {

                    setAL(0xff);
                    return;
                }
            }

            if (Operation == 0xEB00) {
                status = NwlibMakeNcp(
                            ServerHandles[Connection],
                            NWR_ANY_F2_NCP(0x03),
                            RequestLength + 5,
                            0,  //  ResponseSize
                            "bbwbr",
                            DirHandle,
                            (LockMode) ? Function : 0,
                            (LockMode) ? getBP() : 0,
                            RequestLength,
                            Request, RequestLength );

                Tickle[Connection] = TRUE;

            } else {
                status = NwlibMakeNcp(
                            ServerHandles[Connection],
                            (Operation == 0xEC00 ) ?
                                NWR_ANY_F2_NCP(0x07) :
                                NWR_ANY_F2_NCP(0x05),
                            RequestLength + 2,
                            0,  //  ResponseSize
                            "bbr",
                            DirHandle,
                            RequestLength,
                            Request, RequestLength );
            }

            if (Win32DirectoryHandle) {
                CloseHandle( Win32DirectoryHandle );
            }
        }
        break;

    }

    if (!NT_SUCCESS(status)) {
        setAL((UCHAR)RtlNtStatusToDosError(status));
        return;
    } else {
        setAL(0);
    }
}

VOID
InitLocks(
    VOID
    )
/*++

Routine Description:

    Reset the Tickle internal variables

Arguments:

    None.

Return Value:

    None.

--*/
{

    ZeroMemory( Tickle, sizeof(Tickle));
}

VOID
ResetLocks(
    VOID
    )
/*++

Routine Description:

    Reset the Locks for the current VDM. Called during process exit.

Arguments:

    None.

Return Value:

    None.

--*/
{

    Locks(0xCF00);  //  Clear all File sets.

}

NTSTATUS
Sem(
    UCHAR Function,
    UCHAR Connection
    )
/*++

Routine Description:

    Build all NCPs for Semaphore support

Arguments:

    Function - Supplies the subfunction from AL

    Connection - Supplies the server for the request

Return Value:

    None.

--*/
{
    PUCHAR Request;
    NTSTATUS status;

    switch (Function) {

        UCHAR Value;
        UCHAR OpenCount;
        WORD  HandleHigh, HandleLow;

    case 0: //OpenSemaphore

        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                256 * sizeof(UCHAR),
                                IS_PROTECT_MODE());

        NwPrint(("Nw16: OpenSemaphore\n"));

        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x20),
                    Request[0] + 3,  //  RequestSize
                    5,  //  ResponseSize
                    "bbr|wwb",
                    0,
                    getCL(),    // Semaphore Value
                    Request, Request[0] + 1,

                    &HandleHigh, &HandleLow,
                    &OpenCount);


        if (NT_SUCCESS(status)) {
            setBL(OpenCount);
            setCX(HandleHigh);
            setDX(HandleLow);
        }

        break;

    case 1: // ExamineSemaphore

        NwPrint(("Nw16: ExamineSemaphore\n"));
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x20),
                    5,  //  RequestSize
                    2,  //  ResponseSize
                    "bww|bb",
                    1,
                    getCX(),getDX(),

                    &Value,
                    &OpenCount);

        if (NT_SUCCESS(status)) {
            setCX(Value);
            setDL(OpenCount);
        }
        break;

    case 2: // WaitOnSemaphore
        NwPrint(("Nw16: WaitOnSemaphore\n"));
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x20),
                    7,  //  RequestSize
                    0,  //  ResponseSize
                    "bwww",
                    2,
                    getCX(),getDX(),
                    getBP());
        break;

    case 3: // SignalSemaphore
        NwPrint(("Nw16: SignalSemaphore\n"));
    case 4: // CloseSemaphore

        if (Function == 4) {
            NwPrint(("Nw16: CloseSemaphore\n"));
        }

        status = NwlibMakeNcp(      //  Close and Signal
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x20),
                    5,  //  RequestSize
                    0,  //  ResponseSize
                    "bww",
                    Function,
                    getCX(),getDX());
        break;

    default:
        NwPrint(("Nw16: Unknown Semaphore operation %d\n", Function));
        status = STATUS_INVALID_PARAMETER;
        break;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\nw\nw16\dll\ncp.c ===
/*++

Copyright (c) 1993/4  Microsoft Corporation

Module Name:

    ncp.c

Abstract:

    Contains routine which accepts the bop from a 16 bit
    application and processes the request appropriately.
    Normally it performes an NCP exchange on behalf of the
    application.

Author:

    Colin Watson    (colinw)    07-Jul-1993

Environment:


Revision History:


--*/

#include "procs.h"

#define BASE_DOS_ERROR  ((NTSTATUS )0xC0010000L)

#include <packon.h>
typedef struct _TTSOUTPACKET {
    UCHAR SubFunction;
    USHORT cx;
    USHORT dx;
} TTSOUTPACKET, *PTTSOUTPACKET ;

typedef struct _TTSINPACKET{
    USHORT cx;
    USHORT dx;
} TTSINPACKET, *PTTSINPACKET;

#include <packoff.h>

VOID
InitDosTable(
    PNWDOSTABLE pdt
    );

VOID
LoadPreferredServerName(
    VOID
    );

VOID
ProcessResourceArray(
    LPNETRESOURCE   NetResource,
    DWORD           NumElements
    );

VOID
ProcessResource(
    LPNETRESOURCE   NetResource
    );

VOID
SendNCP(
    ULONG Command
    );

VOID
SendF2NCP(
    ULONG Command
    );

UCHAR
AttachmentControl(
    ULONG Command
    );

VOID
SendNCP2(
    ULONG Command,
    PUCHAR Request,
    ULONG RequestLength,
    PUCHAR Reply,
    ULONG ReplyLength
    );

VOID
CloseConnection(
    CONN_INDEX Connection
    );

NTSTATUS
InitConnection(
    CONN_INDEX Connection
    );

VOID
GetDirectoryHandle(
    VOID
    );

VOID
LoadDriveHandleTable(
    VOID
    );

VOID
AllocateDirectoryHandle(
    VOID
    );

VOID
ResetDrive(
    UCHAR Drive
    );

VOID
AllocateDirectoryHandle2(
    VOID
    );

PWCHAR
BuildUNC(
    IN PUCHAR aName,
    IN ULONG aLength
    );

VOID
GetServerDateAndTime(
    VOID
    );

VOID
GetShellVersion(
    IN USHORT Command
    );

VOID
TTS(
    VOID
    );

VOID
OpenCreateFile(
    VOID
    );

BOOL
IsItNetWare(
    PUCHAR Name
    );

VOID
SetCompatibility(
    VOID
    );

VOID
OpenQueueFile(
    VOID
    );

VOID
AttachHandle(
    VOID
    );

VOID
ProcessExit(
    VOID
    );

VOID
SystemLogout(
    VOID
    );

VOID
ServerFileCopy(
    VOID
    );

VOID
SetStatus(
    NTSTATUS Status
    );

//
//  The following pointer contains the 32 bit virtual address of where
//  the nw16.exe tsr holds the workstation structures.
//

PNWDOSTABLE pNwDosTable;

//
//  Global variables used to hold the state for this process
//

UCHAR OriginalPrimary = 0;
HANDLE ServerHandles[MC];

HANDLE Win32DirectoryHandleTable[MD];
PWCHAR Drives[MD]; // Strings such as R: or a unc name

UCHAR  SearchDriveTable[16];


BOOLEAN Initialized = FALSE;
BOOLEAN TablesValid = FALSE;                // Reload each time a process starts
BOOLEAN DriveHandleTableValid = FALSE;      // Reload first time process does NW API

WORD DosTableSegment;
WORD DosTableOffset;

extern UCHAR LockMode;

#if NWDBG
BOOL GotDebugState = FALSE;
extern int DebugCtrl;
#endif


VOID
Nw16Register(
    VOID
    )
/*++

Routine Description:

    This function is called by wow when nw16.sys is loaded.

Arguments:


Return Value:

    None.

--*/
{
    DWORD           status;
    HANDLE          enumHandle;
    LPNETRESOURCE   netResource;
    DWORD           numElements;
    DWORD           bufferSize;
    DWORD           dwScope = RESOURCE_CONNECTED;

    NwPrint(("Nw16Register\n"));

    if ( !Initialized) {
        UCHAR CurDir[256];
        DosTableSegment = getAX();
        DosTableOffset = getDX();

        //
        // this call always made from Real Mode (hence FALSE for last param)
        //

        pNwDosTable = (PNWDOSTABLE) GetVDMPointer (
                                        (ULONG)((DosTableSegment << 16)|DosTableOffset),
                                        sizeof(NWDOSTABLE),
                                        FALSE
                                        );

        InitDosTable( pNwDosTable );

        if ((GetCurrentDirectoryA(sizeof(CurDir)-1, CurDir) >= 2) &&
            (CurDir[1] == ':')) {
            pNwDosTable->CurrentDrive = tolower(CurDir[0]) - 'a';
        }

        InitLocks();
    }


#if NWDBG
    {
        WCHAR Value[80];

        if (GetEnvironmentVariableW(L"NWDEBUG",
                                     Value,
                                     sizeof(Value)/sizeof(Value[0]) - 1)) {

            DebugCtrl = Value[0] - '0';

            //  0 Use logfile
            //  1 Use debugger
            //  2/undefined No debug output
            //  4 Use logfile, close on process exit
            //  8 Use logfile, verbose, close on process exit

            DebugControl( DebugCtrl );

            GotDebugState = TRUE;  // Don't look again until process exits vdm
        }
    }
#endif

    LoadPreferredServerName();

    //
    // Attempt to allow for MD drives
    //

    bufferSize = (MD*sizeof(NETRESOURCE))+1024;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, bufferSize);

    if (netResource == NULL) {

        NwPrint(("Nw16Register: LocalAlloc Failed %d\n",GetLastError));
        setCF(1);
        return;
    }

    //-----------------------------------//
    // Get a handle for a top level enum //
    //-----------------------------------//
    status = NPOpenEnum(
                dwScope,
                RESOURCETYPE_DISK,
                0,
                NULL,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        NwPrint(("Nw16Register:WNetOpenEnum failed %d\n",status));

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto LoadLocal;
    }

    // ---- Multi-user code change : Add "while" ----
    while ( status == WN_SUCCESS ) {

        //-----------------------------//
        // Enumerate the disk devices. //
        //-----------------------------//

        numElements = 0xffffffff;

        status = NwEnumConnections(
                                  enumHandle,
                                  &numElements,
                                  netResource,
                                  &bufferSize,
                                  TRUE);  // Include implicit connections


        if ( status == WN_SUCCESS) {
            //----------------------------------------//
            // Insert the results in the Nw Dos Table //
            //----------------------------------------//
            ProcessResourceArray( netResource, numElements);

        }
    } // end while

    if ( status == WN_NO_MORE_ENTRIES ) {
        status = WN_SUCCESS;
    } else

        if ( status != WN_SUCCESS) {
        NwPrint(("Nw16Register:NwEnumResource failed %d\n",status));

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        WNetCloseEnum(enumHandle);
        goto LoadLocal;
    }

    //------------------------------------------//
    // Close the EnumHandle & print the results //
    //------------------------------------------//

    status = NPCloseEnum(enumHandle);
    if (status != WN_SUCCESS) {
        NwPrint(("Nw16Register:WNetCloseEnum failed %d\n",status));
        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto LoadLocal;

    }

LoadLocal:

    //
    //  Add the local devices so that NetWare apps don't try to map them
    //  to remote servers.
    //

    {
        USHORT Drive;
        WCHAR DriveString[4];
        UINT Type;

        DriveString[1] = L':';
        DriveString[2] = L'\\';
        DriveString[3] = L'\0';

        //
        // Hardwire A: and B: because hitting the floppy drive with
        // GetDriveType takes too long.
        //

        pNwDosTable->DriveFlagTable[0] = LOCAL_DRIVE;
        pNwDosTable->DriveFlagTable[1] = LOCAL_DRIVE;


        for (Drive = 2; Drive <= 'Z' - 'A'; Drive++ ) {

            if (pNwDosTable->DriveFlagTable[Drive] == 0) {
                DriveString[0] = L'A' + Drive;
                Type = GetDriveTypeW( DriveString );

                //
                //  0 means drive type cannot be determined, all others are
                //  provided by other filesystems.
                //

                if (Type != 1) {
                    pNwDosTable->DriveFlagTable[Drive] = LOCAL_DRIVE;
                }
            }
        }

#ifdef NWDBG
        for (Drive = 0; Drive < MD; Drive++ ) {

            DriveString[0] = L'A' + Drive;

            NwPrint(("%c(%d)=%x,",'A' + Drive,
                GetDriveTypeW( DriveString ),
                pNwDosTable->DriveFlagTable[Drive] ));

            if (!((Drive + 1) % 8)) {
                NwPrint(("\n",0));
            }
        }

        NwPrint(("\n"));
#endif

    }

    if ( !Initialized ) {
        Initialized = TRUE;
        pNwDosTable->PrimaryServer = OriginalPrimary;
    }

    TablesValid = TRUE;

    LocalFree(netResource);
    setCF(0);

    NwPrint(("Nw16Register: End\n"));
}

VOID
LoadPreferredServerName(
    VOID
    )
{

    //
    //  If we already have a connection to somewhere then we already have a
    //  preferred servername of some sort.
    //

    if (pNwDosTable->ConnectionIdTable[0].ci_InUse == IN_USE) {
        return;
    }

    //
    //  Load the server name table with the preferred/nearest server.
    //

    CopyMemory( pNwDosTable->ServerNameTable[0], "*", sizeof("*"));

    if (NT_SUCCESS(OpenConnection( 0 ))) {

        if( NT_SUCCESS(InitConnection(0)) ) {

            //
            //  Close the handle so that the rdr can be stopped if
            //  user is not running a netware aware application.
            //

            CloseConnection(0);

            pNwDosTable->PrimaryServer = 1;

            return;

        }

    }

    pNwDosTable->PrimaryServer = 0;

}

VOID
ProcessResourceArray(
    LPNETRESOURCE  NetResource,
    DWORD           NumElements
    )
{
    DWORD   i;
    for (i=0; i<NumElements ;i++ ) {
        ProcessResource(&(NetResource[i]));
    }
    return;
}

VOID
ProcessResource(
    LPNETRESOURCE   NetResource
    )
{
    SERVERNAME ServerName;
    int ServerNameLength;
    int i;
    int Connection;
    BOOLEAN Found = FALSE;

    //
    // Extract Server Name from RemoteName, skipping first 2 chars that
    // contain backslashes and taking care to handle entries that only
    // contain a servername.
    //


    ServerNameLength = wcslen( NetResource->lpRemoteName );

    ASSERT(NetResource->lpRemoteName[0] == '\\');
    ASSERT(NetResource->lpRemoteName[1] == '\\');

    for (i = 2; i <= ServerNameLength; i++) {

        if ((NetResource->lpRemoteName[i] == '\\') ||
            (i == ServerNameLength )){

            ServerNameLength = i - 2;

            WideCharToMultiByte(
                CP_OEMCP,
                0,
                &NetResource->lpRemoteName[2],
                ServerNameLength,
                ServerName,
                sizeof( ServerName ),
                NULL,
                NULL );

            CharUpperBuffA( ServerName, ServerNameLength );

            ZeroMemory( &ServerName[ServerNameLength],
                        SERVERNAME_LENGTH - ServerNameLength );

            break;
        }

    }

    //
    //  Now try to find ServerName in the connection table. If there are
    //  more than MC servers in the table already then skip this one.
    //

    for (Connection = 0; Connection < MC ; Connection++ ) {
        if ((pNwDosTable->ConnectionIdTable[Connection].ci_InUse == IN_USE) &&
            (!memcmp( pNwDosTable->ServerNameTable[Connection], ServerName, SERVERNAME_LENGTH))) {
            Found = TRUE;
            break;
        }
    }


    NwPrint(("Nw16ProcessResource Server: %s\n",ServerName));

    if ( Found == FALSE ) {
        for (Connection = 0; Connection < MC ; Connection++ ) {
            if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse == FREE) {

                CopyMemory( pNwDosTable->ServerNameTable[Connection],
                    ServerName,
                    SERVERNAME_LENGTH);

                if ((NT_SUCCESS(OpenConnection( (CONN_INDEX)Connection ))) &&
                    ( NT_SUCCESS(InitConnection( (CONN_INDEX)Connection ) ))) {

                        Found = TRUE;

                } else {
                    //  Couldn't talk to the server so ignore it.
                    ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );

                }

                break;  // Escape from for (Connection =...
            }
        }
    }

    //
    //  Build the drive id and drive flag tables.   Entries 0 - 25
    //  are reserved for drives redirected to letters.  We use drives
    //  26 - 31 for UNC drives.
    //

    if ( Found == TRUE ) {
        DRIVE Drive;
        DRIVE NextUncDrive = 26;

        if ( NetResource->dwType != RESOURCETYPE_DISK ) {
            return;
        }

        if ( NetResource->lpLocalName != NULL) {
            Drive = NetResource->lpLocalName[0] - L'A';
        } else {
            if ( NextUncDrive < MD ) {
                Drive = NextUncDrive++;
            } else {

                //
                //  No room in the table for this UNC drive.
                //

                return;
            }
        }

        //
        //  We have a drive and a connection. Complete the table
        //  mappings.
        //

        pNwDosTable->DriveIdTable[ Drive ] = Connection + 1;
        pNwDosTable->DriveFlagTable[ Drive ] = PERMANENT_NETWORK_DRIVE;

    }

}


VOID
InitDosTable(
    PNWDOSTABLE pdt
    )

/*++

Routine Description:

    This routine Initializes the NetWare Dos Table to its empty values.

Arguments:

    pdt - Supplies the table to be initialized.

Return Value:

    None

--*/
{
    ZeroMemory( ServerHandles, sizeof(ServerHandles) );
    ZeroMemory( Drives, sizeof(Drives) );
    ZeroMemory( (PVOID) pdt, sizeof(NWDOSTABLE) );
    ZeroMemory( Win32DirectoryHandleTable, sizeof(Win32DirectoryHandleTable) );
    FillMemory( SearchDriveTable, sizeof(SearchDriveTable), 0xff );
}

UCHAR CpuInProtectMode;


VOID
Nw16Handler(
    VOID
    )
/*++

Routine Description:

    This function is called by wow when nw16.sys traps an Int and
    bop's into 32 bit mode.

Arguments:


Return Value:

    None,

--*/
{
    USHORT Command;
    WORD offset;

    //
    // get the CPU mode once: the memory references it's required for won't
    // change during this call. Cuts down number of calls to getMSW()
    //

    CpuInProtectMode = IS_PROTECT_MODE();

    setCF(0);
    if ( TablesValid == FALSE ) {

        //
        //  Load the tables unless the process is exiting.
        //

        if ((pNwDosTable->SavedAx & 0xff00) != 0x4c00) {
            Nw16Register();
        }

#if NWDBG
        if (GotDebugState == FALSE) {

            WCHAR Value[80];

            if (GetEnvironmentVariableW(L"NWDEBUG",
                                         Value,
                                         sizeof(Value)/sizeof(Value[0]) - 1)) {

                DebugCtrl = Value[0] - '0';

                //  0 Use logfile
                //  1 Use debugger
                //  2/undefined No debug output
                //  4 Use logfile, close on process exit
                //  8 Use logfile, verbose, close on process exit

                DebugControl( DebugCtrl );

            }

            GotDebugState = TRUE;  // Don't look again until process exits vdm
        }
#endif
    }

    //
    //  Normal AX register is used to get into 32 bit code so get applications
    //  AX from the shared datastructure.
    //

    Command = pNwDosTable->SavedAx;

    //
    //  set AX register so that AH gets preserved
    //

    setAX( Command );

    NwPrint(("Nw16Handler process command %x\n", Command ));
    VrDumpRealMode16BitRegisters( FALSE );
    VrDumpNwData();

    switch (Command & 0xff00) {

    case 0x3C00:
    case 0x3D00:
            OpenCreateFile();
            break;

    case 0x4C00:
            ProcessExit();              //  Close all handles
            goto default_dos_handler;   //  Let Dos handle rest of processing
            break;

    case 0x9f00:
            OpenQueueFile();
            break;

    case 0xB300:                        //  Packet Signing
            setAL(0);                   //  not supported
            break;

    case 0xB400:
            AttachHandle();
            break;

    case 0xB500:
        switch (Command & 0x00ff) {
        case 03:
            setAX((WORD)pNwDosTable->TaskModeByte);
            break;

        case 04:
            setES((WORD)(CpuInProtectMode ? pNwDosTable->PmSelector : DosTableSegment));
            setBX((WORD)(DosTableOffset + &((PNWDOSTABLE)0)->TaskModeByte));
            break;

        case 06:
            setAX(2);
            break;

        default:
            goto default_dos_handler;
        }
        break;

    case 0xB800:    // Capture - Not supported
        setAL(0xff);
        setCF(1);
        break;

    case 0xBB00:    // Set EOJ status
        {
            static UCHAR EOJstatus = 1;
            setAL(EOJstatus);
            EOJstatus = pNwDosTable->SavedAx & 0x00ff;
        }
        break;

    case 0xBC00:
    case 0xBD00:
    case 0xBE00:

    case 0xC200:
    case 0xC300:
    case 0xC400:
    case 0xC500:
    case 0xC600:
        Locks(Command);
        break;

    case 0xC700:
        TTS();
        break;

    case 0xCB00:
    case 0xCD00:
    case 0xCF00:

    case 0xD000:
    case 0xD100:
    case 0xD200:
    case 0xD300:
    case 0xD400:
    case 0xD500:
        Locks(Command);
        break;

    case 0xD700:
        SystemLogout();
        break;

    case 0xDB00:
        {
            UCHAR Drive;
            UCHAR Count = 0;
            for (Drive = 0; Drive < MD; Drive++) {
                if (pNwDosTable->DriveFlagTable[Drive] == LOCAL_DRIVE ) {
                    Count++;
                }
            }
            setAL(Count);
        }
        break;

    case 0xDC00:    //  Get station number
        {
            CONN_INDEX Connection = SelectConnection();
            if (Connection == 0xff) {
                setAL(0xff);
                setCF(1);
            } else {

                PCONNECTIONID pConnection =
                    &pNwDosTable->ConnectionIdTable[Connection];

                setAL(pConnection->ci_ConnectionLo);
                setAH(pConnection->ci_ConnectionHi);
                setCH( (UCHAR)((pConnection->ci_ConnectionHi == 0) ?
                                pConnection->ci_ConnectionLo / 10 + '0':
                                'X'));
                setCL((UCHAR)(pConnection->ci_ConnectionLo % 10 + '0'));
            }
        }
        break;

    case 0xDD00:    //  Set NetWare Error mode
        {
            static UCHAR ErrorMode = 0;
            setAL( ErrorMode );
            ErrorMode = getDL();
        }
        break;

    case 0xDE00:
        {
            static UCHAR BroadCastMode = 0;
            UCHAR OpCode = getDL();
            if ( OpCode < 4) {
                BroadCastMode = OpCode;
            }
            setAL(BroadCastMode);
        }
        break;

    case 0xDF00:    // Capture - Not supported
        setAL(0xff);
        setCF(1);
        break;

    case 0xE000:
    case 0xE100:
    case 0xE300:
        SendNCP(Command);
        break;

    case 0xE200:

        AllocateDirectoryHandle();
        break;

    case 0xE700:
        GetServerDateAndTime();
        break;

    case 0xE900:

        switch (Command & 0x00ff) {
        PUCHAR ptr;
        case 0:
            GetDirectoryHandle();
            break;

        case 1:
            ptr = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                sizeof(SearchDriveTable),
                                CpuInProtectMode
                                );

            RtlMoveMemory( ptr, SearchDriveTable, sizeof(SearchDriveTable) );
            break;

        case 2:
            ptr = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                sizeof(SearchDriveTable),
                                CpuInProtectMode
                                );

            RtlMoveMemory( SearchDriveTable, ptr, sizeof(SearchDriveTable) );
            break;

        case 5:
            AllocateDirectoryHandle2();
            break;

        case 7:
            setAL(0xff);    // Drive depth not yet implemented
            break;

#ifdef NWDBG
        //  Debug control
        case 0xf0:  //  Use logfile
        case 0xf1:  //  Use debugger
        case 0xf2:  //  No debug output
            DebugControl(Command & 0x000f);
            break;
#endif
        default:
            NwPrint(("Nw16Handler unprocessed interrupt %x\n", pNwDosTable->SavedAx ));
        }
        break;

    case 0xEA00:
        GetShellVersion(Command);
        break;

    case 0xEB00:
    case 0xEC00:
    case 0xED00:
        Locks(Command);
        break;


    case 0xEF00:
        NwPrint(("Nw32: %x\n", pNwDosTable->SavedAx ));

        switch (Command & 0xff) {
        case 00:
            if (DriveHandleTableValid == FALSE) {
                LoadDriveHandleTable();
            }

            offset = (WORD)&((PNWDOSTABLE)0)->DriveHandleTable;
            break;

        case 01:
            offset = (WORD)&((PNWDOSTABLE)0)->DriveFlagTable;
            break;

        case 02:
            offset = (WORD)&((PNWDOSTABLE)0)->DriveIdTable;
            break;

        case 03:
            offset = (WORD)&((PNWDOSTABLE)0)->ConnectionIdTable;
            break;

        case 04:
            offset = (WORD)&((PNWDOSTABLE)0)->ServerNameTable;
            break;

        default:
            goto default_dos_handler;
        }
        setSI((WORD)(DosTableOffset + offset));
        setES((WORD)(CpuInProtectMode ? pNwDosTable->PmSelector : DosTableSegment));
        setAL(0);
        break;

    case 0xF100:
        setAL(AttachmentControl(Command));
        break;

    case 0xF200:
        SendF2NCP(Command);
        break;

    case 0xF300:
        ServerFileCopy();
        break;

    default:

default_dos_handler:

        NwPrint(("Nw16Handler unprocessed interrupt %x\n", pNwDosTable->SavedAx ));

        //
        // if we don't handle this call, we modify the return ip to point to
        // code that will restore the stack and jump far into dos
        //

        setIP((WORD)(getIP() + 3));

    }

#if NWDBG
    pNwDosTable->SavedAx = getAX();
#endif
    VrDumpRealMode16BitRegisters( FALSE );
}


CONN_INDEX
SelectConnection(
    VOID
    )
/*++

Routine Description:

    Pick target connection for current transaction

Arguments:

    None

Return Value:

    Index into ConnectionIdTable or 0xff,

--*/
{

    UCHAR IndexConnection;

    if ( pNwDosTable->PreferredServer != 0 ) {
        return(pNwDosTable->PreferredServer - 1);
    }

    // select default server if current drive is mapped by us?

    if ( pNwDosTable->PrimaryServer != 0 ) {
        return(pNwDosTable->PrimaryServer - 1);
    }


    // Need to pick another


    for (IndexConnection = 0; IndexConnection < MC ; IndexConnection++ ) {

        if (pNwDosTable->ConnectionIdTable[IndexConnection].ci_InUse == IN_USE) {

            pNwDosTable->PrimaryServer = IndexConnection + 1;

            return(pNwDosTable->PrimaryServer - 1);

        }
    }

    // No servers in the table so find the nearest/preferred.

    LoadPreferredServerName();

    return(pNwDosTable->PrimaryServer - 1);

}


CONN_INDEX
SelectConnectionInCWD(
    VOID
    )
/*++

Routine Description:

    Pick target connection for current transaction. Give preference to 
    the current working directory.

Arguments:

    None

Return Value:

    Index into ConnectionIdTable or 0xff,

--*/
{

    UCHAR IndexConnection;
    CHAR CurDir[256];
    USHORT Drive; 

    // Try to return the connection  for CWD first.
    if ((GetCurrentDirectoryA(sizeof(CurDir)-1, CurDir) >= 2) &&
         (CurDir[1] == ':')) {

        Drive = tolower(CurDir[0]) - 'a';

        IndexConnection = pNwDosTable->DriveIdTable[ Drive ] - 1 ; 

        if (pNwDosTable->ConnectionIdTable[IndexConnection].ci_InUse == IN_USE) {
            return IndexConnection ; 
        }
    }

    if ( pNwDosTable->PreferredServer != 0 ) {
        return(pNwDosTable->PreferredServer - 1);
    }


    if ( pNwDosTable->PrimaryServer != 0 ) {
        return(pNwDosTable->PrimaryServer - 1);
    }


    // Need to pick another


    for (IndexConnection = 0; IndexConnection < MC ; IndexConnection++ ) {

        if (pNwDosTable->ConnectionIdTable[IndexConnection].ci_InUse == IN_USE) {

            pNwDosTable->PrimaryServer = IndexConnection + 1;

            return(pNwDosTable->PrimaryServer - 1);

        }
    }

    // No servers in the table so find the nearest/preferred.

    LoadPreferredServerName();

    return(pNwDosTable->PrimaryServer - 1);

}


VOID
SendNCP(
    ULONG Command
    )
/*++

Routine Description:

    Implement generic Send NCP function.

    ASSUMES called from Nw16Handler

Arguments:

    Command  - Supply the opcode 0xexxx
    DS:SI    - Supply Request buffer & length
    ES:DI    - Supply Reply buffer & length

    On return AL = Status of operation.

Return Value:

    None.

--*/
{
    PUCHAR Request, Reply;
    ULONG RequestLength, ReplyLength;
    UCHAR OpCode;

    OpCode = (UCHAR)((Command >> 8) - 0xcc);

    Request = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            sizeof(WORD),
                            CpuInProtectMode
                            );

    Reply = GetVDMPointer (
                            (ULONG)((getES() << 16)|getDI()),
                            sizeof(WORD),
                            CpuInProtectMode
                            );

    RequestLength = *(WORD UNALIGNED*)Request;
    ReplyLength = *(WORD UNALIGNED*)Reply;

    Request = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI() + sizeof(WORD)),
                            (USHORT)RequestLength,
                            CpuInProtectMode
                            );
    Reply = GetVDMPointer (
                            (ULONG)((getES() << 16)|getDI()) + sizeof(WORD),
                            (USHORT)ReplyLength,
                            CpuInProtectMode
                            );

    NwPrint(("SubRequest     %x, RequestLength  %x\n", Request[0], RequestLength ));

    SendNCP2( NWR_ANY_NCP(OpCode ),
        Request,
        RequestLength,
        Reply,
        ReplyLength);
}


VOID
SendF2NCP(
    ULONG Command
    )
/*++

Routine Description:

    Implement generic Send NCP function. No length to be inseted by
    the redirector in the request buffer.

    ASSUMES called from Nw16Handler

Arguments:

    Command  - Supply the opcode 0xf2xx
    DS:SI CX - Supply Request buffer & length
    ES:DI DX - Supply Reply buffer & length

    On return AL = Status of operation.

Return Value:

    None.

--*/
{
    PUCHAR Request, Reply;
    ULONG RequestLength, ReplyLength;
    UCHAR OpCode;


    OpCode = (UCHAR)(Command & 0x00ff);

    RequestLength = getCX();
    ReplyLength = getDX();

    Request = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            (USHORT)RequestLength,
                            CpuInProtectMode
                            );
    Reply = GetVDMPointer (
                            (ULONG)((getES() << 16)|getDI()),
                            (USHORT)ReplyLength,
                            CpuInProtectMode
                            );

    NwPrint(("F2SubRequest   %x, RequestLength  %x\n", Request[2], RequestLength ));

#if 0
    if ((RequestLength != 0) &&
        (OpCode == 0x17)) {

        if ((Request[2] == 0x17) ||
            (Request[2] == 0x18)) {
            //
            //  The request was for an encryption key. Tell the
            //  application that encryption is not supported.
            //

            setAL(0xfb);
            return;

        } else if ((Request[2] == 0x14 ) ||
                   (Request[2] == 0x3f )) {

            //
            //  Plaintext login or Verify Bindery Object Password.
            //  Convert to its WNET equivalent version.
            //

            UCHAR Name[256];
            UCHAR Password[256];
            UCHAR ServerName[sizeof(SERVERNAME)+3];
            PUCHAR tmp;
            CONN_INDEX Connection;
            NETRESOURCEA Nr;

            Connection = SelectConnection();
            if ( Connection == 0xff ) {
                setAL(0xff);
                setCF(1);
                return;
            }

            ZeroMemory( &Nr, sizeof(NETRESOURCE));
            ServerName[0] = '\\';
            ServerName[1] = '\\';
            RtlCopyMemory( ServerName+2, pNwDosTable->ServerNameTable[Connection], sizeof(SERVERNAME) );
            ServerName[sizeof(ServerName)-1] = '\0';
            Nr.lpRemoteName = ServerName;
            Nr.dwType = RESOURCETYPE_DISK;

            //  point to password length.
            tmp = &Request[6] + Request[5];

            Name[Request[5]] = '\0';
            RtlMoveMemory( Name, &Request[6], Request[5]);

            Password[tmp[0]] = '\0';
            RtlMoveMemory( Password, tmp+1, tmp[0]);

            NwPrint(("Connect to %s as %s password %s\n", ServerName, Name, Password ));

            if (NO_ERROR == WNetAddConnection2A( &Nr, Password, Name, 0)) {
                setAL(0);
            } else {
                setAL(255);
            }
            return;
        }
    }

#endif

    SendNCP2( NWR_ANY_F2_NCP(OpCode ),
        Request,
        RequestLength,
        Reply,
        ReplyLength);
}


VOID
SendNCP2(
    ULONG Command,
    PUCHAR Request,
    ULONG RequestLength,
    PUCHAR Reply,
    ULONG ReplyLength
    )
/*++

Routine Description:

    Pick target connection for current transaction

    This routine effectively opens a handle for each NCP sent. This means that
    we don't keep handles open to servers unnecessarily which would cause
    problems if a user tries to delete the connection or stop the workstation.

    If this causes to much of a load then the fallback is to spin off a thread
    that waits on an event with a timeout and periodically sweeps the
    server handle table removing stale handles. Setting the event would cause
    the thread to exit. Critical sections would need to be added to protect
    handles. Dll Init/exit routine to kill the thread and close the handles
    would also be needed.

Arguments:

    Command  - Supply the opcode
    Request, RequestLength - Supply Request buffer & length
    Reply, ReplyLength - Supply Reply buffer & length

    On return AL = Status of operation.

Return Value:

    None.

--*/
{
    CONN_INDEX Connection = SelectConnection();
    NTSTATUS status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;

    NwPrint(("Send NCP %x to %d:%s\n", Command, Connection, pNwDosTable->ServerNameTable[Connection] ));
    NwPrint(("RequestLength  %x\n", RequestLength ));
    NwPrint(("Reply          %x, ReplyLength  %x\n", Reply, ReplyLength ));

    if (Connection == 0xff) {
        setAL(0xff);
        setCF(1);
        return;
    };

    if ( ServerHandles[Connection] == NULL ) {

        status = OpenConnection( Connection );

        if (!NT_SUCCESS(status)) {
            SetStatus(status);
            return;
        } else {
            InitConnection( Connection );
        }
    }

    Handle = ServerHandles[Connection];

    //
    //  If its a CreateJobandFile NCP then we need to use the handle
    //  created through Dos so that the writes go into the spoolfile created
    //  by this NCP.
    //

    if (Command == NWR_ANY_F2_NCP(0x17)) {

        if ((Request[2] == 0x68) ||
            (Request[2] == 0x79)) {

            Handle = GET_NT_HANDLE();
        }
    } else if (Command == NWR_ANY_NCP(0x17)) {
        if ((Request[0] == 0x68) ||
            (Request[0] == 0x79)) {

            Handle = GET_NT_HANDLE();
        }
    }

    FormattedDump( Request, RequestLength );

    //
    // Make the NCP request on the appropriate handle
    //

    status = NtFsControlFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 Command,
                 (PVOID) (Request),
                 RequestLength,
                 (PVOID) Reply,
                 ReplyLength);

    if (NT_SUCCESS(status)) {
        status = IoStatusBlock.Status;
        FormattedDump( Reply, ReplyLength );
    }

    if (!NT_SUCCESS(status)) {
        SetStatus(status);
        setCF(1);
        NwPrint(("NtStatus          %x, DosError     %x\n", status, getAL() ));
    } else {
        setAL(0);
    }
}


NTSTATUS
OpenConnection(
    CONN_INDEX Connection
    )
/*++

Routine Description:

    Open the handle to the redirector to access the specified server.

Arguments:

    Connection - Supplies the index to use for the handle

Return Value:

    Status of the operation

--*/
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    LPWSTR FullName;

    UCHAR AnsiName[SERVERNAME_LENGTH+sizeof(UCHAR)];

    UNICODE_STRING UServerName;
    OEM_STRING AServerName;

    if ( Connection >= MC) {
        return( BASE_DOS_ERROR + 249 ); // No free connection slots
    }

    if (ServerHandles[Connection] != NULL ) {

        CloseConnection(Connection);

    }

    FullName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                            sizeof( DD_NWFS_DEVICE_NAME_U ) +
                            (SERVERNAME_LENGTH + 1) * sizeof(WCHAR)
                            );

    if ( FullName == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(AnsiName,
                pNwDosTable->ServerNameTable[Connection],
                SERVERNAME_LENGTH);
    AnsiName[SERVERNAME_LENGTH] = '\0';

    RtlInitAnsiString( &AServerName, AnsiName );
    Status = RtlOemStringToUnicodeString( &UServerName,
                &AServerName,
                TRUE);

    if (!NT_SUCCESS(Status)) {
        LocalFree( FullName );
        return(Status);
    }

    wcscpy( FullName, DD_NWFS_DEVICE_NAME_U );
    wcscat( FullName, L"\\");
    wcscat( FullName, UServerName.Buffer );

    RtlFreeUnicodeString(&UServerName);

    RtlInitUnicodeString( &UServerName, FullName );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open a handle to the server.
    //

    //
    //  Try to login to the nearest server. This is necessary for
    //  the real preferred server if there are no redirections to
    //  it. The rdr can logout and disconnect. SYSCON doesn't like
    //  running from such a server.
    //
    Status = NtOpenFile(
                   &ServerHandles[Connection],
                   SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS(Status)) {
        //
        //  Failed to login. Use the non-login method. This allows the
        //  app to do a bindery login or query the bindery.
        //

        Status = NtOpenFile(
                       &ServerHandles[Connection],
                       SYNCHRONIZE,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       FILE_SHARE_VALID_FLAGS,
                       FILE_SYNCHRONOUS_IO_NONALERT
                       );

        if ( NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
        }
    }

    NwPrint(("Nw16:OpenConnection %d: %wZ status = %08lx\n", Connection, &UServerName, Status));

    LocalFree( FullName );

    if (!NT_SUCCESS(Status)) {
        SetStatus(Status);
        return Status;
    }

    return Status;
}


VOID
CloseConnection(
    CONN_INDEX Connection
    )
/*++

Routine Description:

    Close the connection handle

Arguments:

    Connection - Supplies the index to use for the handle

Return Value:

    None.

--*/
{
    if (ServerHandles[Connection]) {

        NwPrint(("CloseConnection: %d\n",Connection));

        NtClose(ServerHandles[Connection]);

        ServerHandles[Connection] = NULL;
    }
}


NTSTATUS
InitConnection(
    CONN_INDEX Connection
    )
/*++

Routine Description:

    Get the connection status from the redirector.

Arguments:

    Connection - Supplies the index to use for the handle

Return Value:

    Status of the operation

--*/
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    NWR_GET_CONNECTION_DETAILS Details;

    Status = NtFsControlFile(
                 ServerHandles[Connection],
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_NWR_GET_CONN_DETAILS,
                 NULL,
                 0,
                 (PVOID) &Details,
                 sizeof(Details));

    if (Status == STATUS_SUCCESS) {
        Status = IoStatusBlock.Status;
    }

    NwPrint(("Nw16:InitConnection: %d status = %08lx\n",Connection, Status));

    if (!NT_SUCCESS(Status)) {

        SetStatus(Status);

        CloseConnection(Connection);

    } else {
        PCONNECTIONID pConnection =
            &pNwDosTable->ConnectionIdTable[Connection];

        pConnection->ci_OrderNo= Details.OrderNumber;

        CopyMemory(pNwDosTable->ServerNameTable[Connection],
                    Details.ServerName,
                    sizeof(SERVERNAME));

        CopyMemory(pConnection->ci_ServerAddress,
                    Details.ServerAddress,
                    sizeof(pConnection->ci_ServerAddress));

        pConnection->ci_ConnectionNo= Details.ConnectionNumberLo;
        pConnection->ci_ConnectionLo= Details.ConnectionNumberLo;
        pConnection->ci_ConnectionHi= Details.ConnectionNumberHi;
        pConnection->ci_MajorVersion= Details.MajorVersion;
        pConnection->ci_MinorVersion= Details.MinorVersion;
        pConnection->ci_InUse = IN_USE;
        pConnection->ci_1 = 0;
        pConnection->ci_ConnectionStatus = 2;

        //
        //  If this is the preferred conection then record it as special.
        //  If this is the first drive then also record it. Usually it gets
        //  overwritten by the preferred.
        //

        if (( Details.Preferred ) ||
            ( OriginalPrimary == 0 )) {

            NwPrint(("Nw16InitConnection: Primary Connection is %d\n", Connection+1));

            pNwDosTable->PrimaryServer = OriginalPrimary = (UCHAR)Connection + 1;
        }

        setAL(0);
    }

    return Status;
}

VOID
GetDirectoryHandle(
    VOID
    )
/*++

Routine Description:

    Obtain a NetWare handle for the current directory.

    If a NetWare handle is assigned then the Win32 handle created for
    the directory handle is kept open. When the process exits, the Win32
    handle will close. When all the Win32 handles from this process are
    closed an endjob NCP will be sent freeing the directory handle on the
    server.

Arguments:

    DX supplies the drive.

    AL returns the handle.
    AH returns the status flags.


Return Value:

    None.

--*/
{
    USHORT Drive = getDX();

    NwPrint(("Nw32:GetDirectoryHandle %c: ", 'A' + Drive));

    GetDirectoryHandle2( Drive );

    setAL(pNwDosTable->DriveHandleTable[Drive]);
    setAH(pNwDosTable->DriveFlagTable[Drive]);

    NwPrint(("Handle = %x, Flags =%x\n", pNwDosTable->DriveHandleTable[Drive],
                                        pNwDosTable->DriveFlagTable[Drive] ));
}

ULONG
GetDirectoryHandle2(
    DWORD Drive
    )
/*++

Routine Description:

    Obtain a NetWare handle for the current directory.

    If a NetWare handle is assigned then the Win32 handle created for
    the directory handle is kept open. When the process exits, the Win32
    handle will close. When all the Win32 handles from this process are
    closed an endjob NCP will be sent freeing the directory handle on the
    server.

    Note: Updates DriveHandleTable.

Arguments:

    Drive supplies the drive index (0 = a:).

Return Value:

    returns the handle.

--*/
{
    DWORD BytesReturned;

    if (Drive >= MD) {
        setAL( 0x98 );  // Volume does not exist
        return 0xffffffff;
    }

    NwPrint(("Nw32:GetDirectoryHandle2 %c:\n", 'A' + Drive));

    //
    //  If we don't have a handle and its either a temporary or
    //  permanent drive then create it.
    //

    if (( Win32DirectoryHandleTable[Drive] == 0 ) &&
        ( (pNwDosTable->DriveFlagTable[Drive] & 3) != 0 )){
        WCHAR DriveString[4];
        PWCHAR Name;

        //
        //  We don't have a handle for this drive.
        //  Open an NT handle to the current directory and
        //  ask the redirector for a NetWare directory handle.
        //

        if (Drive <= ('Z' - 'A')) {

            DriveString[0] = L'A' + (WCHAR)Drive;
            DriveString[1] = L':';
            DriveString[2] = L'.';
            DriveString[3] = L'\0';

            Name = DriveString;

        } else {

            Name = Drives[Drive];

            if( Name == NULL ) {
                NwPrint(("\nNw32:GetDirectoryHandle2 Drive not mapped\n",0));
                return 0xffffffff;
            }
        }

        Win32DirectoryHandleTable[Drive] =
            CreateFileW( Name,
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS,
                        0);

        if (Win32DirectoryHandleTable[Drive] != INVALID_HANDLE_VALUE) {

            if ( DeviceIoControl(
                    Win32DirectoryHandleTable[Drive],
                    IOCTL_NWR_RAW_HANDLE,
                    NULL,
                    0,
                    (PUCHAR)&pNwDosTable->DriveHandleTable[Drive],
                    sizeof(pNwDosTable->DriveHandleTable[Drive]),
                    &BytesReturned,
                    NULL ) == FALSE ) {

                NwPrint(("\nNw32:GetDirectoryHandle2 DeviceIoControl %x\n", GetLastError()));
                CloseHandle( Win32DirectoryHandleTable[Drive] );
                Win32DirectoryHandleTable[Drive] = 0;
                return 0xffffffff;

            } else {
                ASSERT( BytesReturned == sizeof(pNwDosTable->DriveHandleTable[Drive]));

                NwPrint(("\nNw32:GetDirectoryHandle2 Success %x\n", pNwDosTable->DriveHandleTable[Drive]));
            }

        } else {
            NwPrint(("\nNw32:GetDirectoryHandle2 CreateFile %x\n", GetLastError()));

            Win32DirectoryHandleTable[Drive] = 0;

            return 0xffffffff;
        }

    }

    return (ULONG)pNwDosTable->DriveHandleTable[Drive];
}

VOID
LoadDriveHandleTable(
    VOID
    )
/*++

Routine Description:

    Open handles to all the NetWare drives

Arguments:

    none.

Return Value:

    none.

--*/
{

    USHORT Drive;
    for (Drive = 0; Drive < MD; Drive++ ) {
        GetDirectoryHandle2(Drive);
    }

    DriveHandleTableValid = TRUE;

}

VOID
AllocateDirectoryHandle(
    VOID
    )
/*++

Routine Description:

    Allocate permanent or temporary handle for drive.

    For a permanent handle, we map this to a "net use".

    ASSUMES called from Nw16Handler


Arguments:

    DS:SI supplies the request.
    ES:DI supplies the response.

    AL returns the completion code.


Return Value:

    None.

--*/
{

    PUCHAR Request=GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            2,
                            CpuInProtectMode
                            );

    PUCHAR Reply = GetVDMPointer (
                            (ULONG)((getES() << 16)|getDI()),
                            4,
                            CpuInProtectMode
                            );

    USHORT RequestLength = *(USHORT UNALIGNED *)( Request );

    Request=GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            RequestLength+2,
                            CpuInProtectMode
                            );

    FormattedDump( Request, RequestLength+2 );


    if (( Request[2] == 0x12) ||
        ( Request[2] == 0x13