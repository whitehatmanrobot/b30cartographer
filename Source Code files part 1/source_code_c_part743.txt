  m_SessionId = 0;
    m_NextTransactionId = PTP_TRANSACTIONID_MIN;

    //
    // Indicate that camera was reset, so that CWiaMiniDriver can notify caller
    // 
    m_bCameraWasReset = TRUE;

Cleanup:
    return hr;
}


//
// This function sends the class CancelRequest command to the device
// and wait for the device to complete the request.
// Input:
//      dwTransactionId -- transaction being canceled
//
HRESULT
CUsbCamera::SendCancelRequest(DWORD dwTransactionId)
{
    DBG_FN("CUsbCamera::CancelRequest");
    
    HRESULT hr = S_OK;
    IO_BLOCK_EX IoBlock;
    USB_PTPCANCELIOREQUEST CancelRequest;
    DWORD BytesReturned;

    IoBlock.bRequest = USB_PTPREQUEST_CANCELIO;
    IoBlock.bmRequestType = USB_PTPREQUEST_TYPE_OUT;
    IoBlock.fTransferDirectionIn = FALSE;             // Host to device
    IoBlock.uOffset = 0;                              // 0 for this request
    IoBlock.uLength = sizeof(USB_PTPCANCELIOREQUEST); // Data output length
    IoBlock.pbyData = (BYTE *)&CancelRequest;         // output data
    IoBlock.uIndex = 0;                               // 0 for this request

    CancelRequest.Id = USB_PTPCANCELIO_ID;
    CancelRequest.TransactionId = dwTransactionId;

    if (DeviceIoControl(m_hUSB,
                        IOCTL_SEND_USB_REQUEST_PTP,
                        &IoBlock,
                        sizeof(IoBlock),
                        NULL,
                        0,
                        &BytesReturned,
                        NULL
                       ))
    {
        //
        // Poll device until it returns to idle state
        //
        USB_PTPDEVICESTATUS DeviceStatus;
        const UINT MAX_CANCEL_RECOVERY_MILLISECONDS = 3000;
        const UINT SLEEP_BETWEEN_RETRIES            = 100;
        DWORD RetryCounts = MAX_CANCEL_RECOVERY_MILLISECONDS / SLEEP_BETWEEN_RETRIES;

        while (RetryCounts--)
        {
            hr = GetDeviceStatus(&DeviceStatus);
            if (SUCCEEDED(hr))
            {
                if (PTP_RESPONSECODE_OK == DeviceStatus.Header.Code)
                {
                    //
                    // CancelRequest completed and device is back idle
                    //
                    hr = S_OK;
                    break;
                }
                else if (PTP_RESPONSECODE_DEVICEBUSY != DeviceStatus.Header.Code)
                {
                    //
                    // This is wrong. Device must be either busy or idle
                    //
                    wiauDbgError("SendCancelRequest", 
                        "Device is in invalid state, DeviceStatus=0x%X", DeviceStatus.Header.Code);
                    hr = E_FAIL;
                    break;
                }
            }
            else
            {
                if (RetryCounts)
                {
                    hr = S_OK;
                    wiauDbgWarning("CancelRequest", "GetDeviceStatus failed, retrying...");
                }
                else
                {
                    wiauDbgError("CancelRequest", "GetDeviceStatus failed");
                }
            }

            Sleep(SLEEP_BETWEEN_RETRIES);
        }

        //
        // Flush system buffers - otherwise we'll get old data on next read
        //
        FlushFileBuffers(m_hUSB);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "CancelRequest", "send USB request failed");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\iso15740.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    iso15740.cpp

Abstract:

    This module implements methods used for manipulating PTP structures

Author:

    Dave Parsons

Revision History:


--*/

#include "ptppch.h"
#include <platform.h> // for MAKELONGLONG

//
// This function returns a 2 byte integer from raw data and advances the pointer
//
// Input:
//   ppRaw -- pointer to a pointer to the raw data
//
WORD
ParseWord(BYTE **ppRaw)
{
    WORD w;

    // we know that **ppRaw points to a little-endian word
    w = MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
    
    *ppRaw += sizeof(WORD);
    
    return w;
}

//
// This function returns a 4 byte integer from raw data and advances the pointer
//
// Input:
//   ppRaw -- pointer to a pointer to the raw data
//
DWORD
ParseDword(BYTE **ppRaw)
{
    DWORD dw;

    // we know that **ppRaw points to a little-endian dword
    dw = MAKELONG(MAKEWORD((*ppRaw)[0],(*ppRaw)[1]),
                  MAKEWORD((*ppRaw)[2],(*ppRaw)[3]));

    *ppRaw += sizeof(DWORD);

    return dw;
}

//
// This function returns an 8 byte integer from raw data and advances the pointer
//
// Input:
//   ppRaw -- pointer to a pointer to the raw data
//
QWORD
ParseQword(BYTE **ppRaw)
{
    QWORD qw;
    
    // we know that **ppRaw points to a little-endian qword
    qw = MAKELONGLONG(MAKELONG(MAKEWORD((*ppRaw)[0],(*ppRaw)[1]),
                               MAKEWORD((*ppRaw)[2],(*ppRaw)[3])),
                      MAKELONG(MAKEWORD((*ppRaw)[4],(*ppRaw)[5]),
                               MAKEWORD((*ppRaw)[6],(*ppRaw)[7])));

    *ppRaw += sizeof(QWORD);

    return qw;
}

//
// This function writes a 2 byte integer to a raw data buffer and advances the pointer
//
// Input:
//   ppRaw -- pointer to pointer to the raw data
//   value -- value to write
//
VOID
WriteWord(BYTE **ppRaw, WORD value)
{
    (*ppRaw)[0] = LOBYTE(LOWORD(value));
    (*ppRaw)[1] = HIBYTE(LOWORD(value));
    
    *ppRaw += sizeof(WORD);
    
    return;
}

//
// This function writes a 4 byte integer to a raw data buffer and advances the pointer
//
// Input:
//   ppRaw -- pointer to pointer to the raw data
//   value -- value to write
//
VOID
WriteDword(BYTE **ppRaw, DWORD value)
{
    (*ppRaw)[0] = LOBYTE(LOWORD(value));
    (*ppRaw)[1] = HIBYTE(LOWORD(value));
    (*ppRaw)[2] = LOBYTE(HIWORD(value));
    (*ppRaw)[3] = HIBYTE(HIWORD(value));
    
    *ppRaw += sizeof(DWORD);
    
    return;
}

//
// CBstr constructor
//
CBstr::CBstr() :
    m_bstrString(NULL)
{
}

//
// CBstr copy constructor
//
CBstr::CBstr(const CBstr &src)
{
    m_bstrString = SysAllocString(src.m_bstrString);
}

//
// CBstr destructor
//
CBstr::~CBstr()
{
    if (m_bstrString)
        SysFreeString(m_bstrString);
}

//
// Make a copy of a string
//
HRESULT
CBstr::Copy(WCHAR *wcsString)
{
    HRESULT hr = S_OK;

    if (m_bstrString)
    {
        if (!SysReAllocString(&m_bstrString, wcsString))
        {
            wiauDbgError("Copy", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
    }

    else
    {
        m_bstrString = SysAllocString(wcsString);
        if (!m_bstrString)
        {
            wiauDbgError("Copy", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
    }

    return hr;
}

//
// This function initializes a BSTR from a raw PTP string, clearing
// the BSTR first, if needed
//
// Input:
//   ppRaw -- pointer to pointer to raw data to initialize the string from
//   bParse -- indicates whether to advance the raw pointer or not
//
HRESULT
CBstr::Init(
    BYTE **ppRaw,
    BOOL bParse
    )
{
    HRESULT hr = S_OK;

    //
    // Check arguments
    //
    if (!ppRaw || !*ppRaw)
    {
        wiauDbgError("Init", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Extract the length from the raw data, and set up a more convenient pointer
    // to the string data (skipping over the length byte)
    //
    int length = (UCHAR) **ppRaw;
    OLECHAR *pRaw = (OLECHAR *) (*ppRaw + sizeof(UCHAR));

    if (m_bstrString)
    {
        if (!SysReAllocStringLen(&m_bstrString, pRaw, length))
        {
            wiauDbgError("Init", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
    }

    else
    {
        m_bstrString = SysAllocStringLen(pRaw, length);
        if (!m_bstrString)
        {
            wiauDbgError("Init", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
    }

    //
    // If requested, advance the raw pointer past the string. One byte for the length and
    // 2 times the number of chars in the wide string.
    //
    if (bParse)
    {
        *ppRaw += sizeof(UCHAR) + length * sizeof(USHORT);
    }

    return hr;
}

//
// This function writes the string to a buffer in PTP format
//
// Input:
//   ppRaw -- pointer to pointer to buffer
//   Length -- amount of space left in the buffer in bytes
//
VOID
CBstr::WriteToBuffer(
    BYTE **ppRaw
    )
{
    UCHAR NumChars = (UCHAR) Length();

    //
    // Add one for null terminating char, but only if string is non-empty
    //
    if (NumChars > 0)
        NumChars++;

    int NumBytes = NumChars * sizeof(WCHAR);

    **ppRaw = NumChars;
    (*ppRaw)++;

    if (NumChars > 0)
    {
        memcpy(*ppRaw, String(), NumBytes);
        *ppRaw += NumBytes;
    }

    return;
}

//
// This function dumps a PTP string to the log
// 
// Input:
//  szDesc -- Description for the string
//
VOID
CBstr::Dump(char *szDesc)
{
    if (m_bstrString && SysStringLen(m_bstrString) > 0)
    {
        wiauDbgDump("", "%s %S", szDesc, m_bstrString);
    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

    return;
}

//
// Dumps the contents of a CArray8 to the log
//
// Input:
//   szDesc -- description for the string
//   szFiller -- filler to use for subsequent lines
//
VOID
CArray8::Dump(
    char *szDesc,
    char *szFiller
    )
{
    HRESULT hr = S_OK;
    char szPart[MAX_PATH] = "\0";
    char szMsg[MAX_PATH] = "\0";

    //
    // Make sure array is not empty
    //
    if (GetSize() > 0)
    {
        //
        // Prime output string
        //
        hr = StringCchCopyA(szMsg, ARRAYSIZE(szMsg), szDesc);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        //
        // Loop through the elements
        //
        for (int count = 0; count < GetSize(); count++)
        {
            //
            // Start a new line every 8 values
            //
            if ((count != 0) && (count % 8 == 0))
            {
                wiauDbgDump("", "%s", szMsg);

                hr = StringCchCopyA(szMsg, ARRAYSIZE(szMsg), szFiller);
                if (FAILED(hr))
                {
                    goto Cleanup;
                }
            }

            hr = StringCchPrintfA(szPart, ARRAYSIZE(szPart), " 0x%02x", m_aT[count]);
            if (FAILED(hr))
            {
                goto Cleanup;
            }

            hr = StringCchCatA(szMsg, ARRAYSIZE(szMsg), szPart);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        wiauDbgDump("", "%s", szMsg);
    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

Cleanup:
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "CArray8::Dump", "Failed to dump array");
    }
    return;
}

//
// Dumps the contents of a CArray16 to the log
//
// Input:
//   szDesc -- description for the string
//   szFiller -- filler to use for subsequent lines
//
VOID
CArray16::Dump(
    char *szDesc,
    char *szFiller
    )
{
    HRESULT hr = S_OK;
    char szMsg[MAX_PATH] = "\0";
    char szPart[MAX_PATH] = "\0";
        
    //
    // Make sure it's not empty
    //
    if (GetSize() > 0)
    {
        //
        // Prime output string
        //
        hr = StringCchCopyA(szMsg, ARRAYSIZE(szMsg), szDesc);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        //
        // Loop through the elements
        //
        for (int count = 0; count < GetSize(); count++)
        {
            //
            // Start a new line every 4 values
            //
            if ((count != 0) && (count % 4 == 0))
            {
                wiauDbgDump("", "%s", szMsg);

                hr = StringCchCopyA(szMsg, ARRAYSIZE(szMsg), szFiller);
                if (FAILED(hr))
                {
                    goto Cleanup;
                }
            }

            hr = StringCchPrintfA(szPart, ARRAYSIZE(szPart), " 0x%04x", m_aT[count]);
            if (FAILED(hr))
            {
                goto Cleanup;
            }

            hr = StringCchCatA(szMsg, ARRAYSIZE(szMsg), szPart);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        wiauDbgDump("", "%s", szMsg);

    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

Cleanup:
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "CArray16::Dump", "Failed to dump array");
    }
    return;
}

//
// This function parses a CArray32 from an array of UCHARs
//
BOOL
CArray32::ParseFrom8(
    BYTE **ppRaw,
    int NumSize
    )
{
    if (!ppRaw || !*ppRaw)
        return FALSE;

    RemoveAll();

    // Get the number of elements from the raw data
    ULONG NumElems;
    switch (NumSize)
    {
    case 4:
        NumElems = MAKELONG(MAKEWORD((*ppRaw)[0], (*ppRaw)[1]), MAKEWORD((*ppRaw)[2], (*ppRaw)[3]));
        break;
    case 2:
        NumElems = MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
        break;
    case 1:
        NumElems = **ppRaw;
        break;
    default:
        return FALSE;
    }

    *ppRaw += NumSize;

    // Allocate space for the array
    if (!GrowTo(NumElems))
        return FALSE;

    // Copy in the elements, one at a time
    BYTE *pValues = *ppRaw;
    ULONG value = 0;
    for (ULONG count = 0; count < NumElems; count++)
    {
        value = (ULONG) pValues[count];
        if (!Add(value))
            return FALSE;
    }

    // Advance the raw pointer past the array and number of elements field
    *ppRaw += NumElems * sizeof(BYTE);

    return TRUE;
}

//
// This function parses a CArray32 from an array of WORDs
//
BOOL
CArray32::ParseFrom16(
    BYTE **ppRaw,
    int NumSize
    )
{
    if (!ppRaw || !*ppRaw)
        return FALSE;

    RemoveAll();

    // Get the number of elements from the raw data
    ULONG NumElems;
    
    switch (NumSize)
    {
    case 4:
        NumElems = MAKELONG(MAKEWORD((*ppRaw)[0], (*ppRaw)[1]), MAKEWORD((*ppRaw)[2], (*ppRaw)[3]));
        break;
    case 2:
        NumElems = MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
        break;
    case 1:
        NumElems = **ppRaw;
        break;
    default:
        return FALSE;
    }

    *ppRaw += NumSize;

    // Allocate space for the array
    if (!GrowTo(NumElems))
        return FALSE;

    // Copy in the elements, one at a time
    ULONG value = 0;
    for (ULONG count = 0; count < NumElems; count++)
    {
        value = (ULONG) MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
        *ppRaw += sizeof(WORD);
        if (!Add(value))
            return FALSE;
    }

    return TRUE;
}

//
// Copies values from an array of bytes
//
BOOL
CArray32::Copy(CArray8 values8)
{
    RemoveAll();

    GrowTo(values8.GetSize());

    for (int count = 0; count < values8.GetSize(); count++)
    {
        ULONG value = values8[count];
        if (!Add(value))
            return FALSE;
    }

    return TRUE;
}

//
// Copies values from an array of bytes
//
BOOL
CArray32::Copy(CArray16 values16)
{
    RemoveAll();

    GrowTo(values16.GetSize());

    for (int count = 0; count < values16.GetSize(); count++)
    {
        ULONG value = values16[count];
        if (!Add(value))
            return FALSE;
    }

    return TRUE;
}

//
// Dumps the contents of a CArray32 to the log
//
// Input:
//  szDesc -- description for the string
//  szFiller -- filler to use for subsequent lines
//
VOID
CArray32::Dump(
    char *szDesc,
    char *szFiller
    )
{
    HRESULT hr = S_OK;
    char szMsg[MAX_PATH] = "\0";
    char szPart[MAX_PATH] = "\0";
        
    //
    // Make sure it's not empty
    //
    if (GetSize() > 0)
    {
        //
        // Prime output string
        //
        hr = StringCchCopyA(szMsg, ARRAYSIZE(szMsg), szDesc);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        //
        // Loop through the elements
        //
        for (int count = 0; count < GetSize(); count++)
        {
            //
            // Start a new line every 4 values
            //
            if ((count != 0) && (count % 4 == 0))
            {
                wiauDbgDump("", "%s", szMsg);

                hr = StringCchCopyA(szMsg, ARRAYSIZE(szMsg), szFiller);
                if (FAILED(hr))
                {
                    goto Cleanup;
                }
            }
            hr = StringCchPrintfA(szPart, ARRAYSIZE(szPart), " 0x%08x", m_aT[count]);
            if (FAILED(hr))
            {
                goto Cleanup;
            }

            hr = StringCchCatA(szMsg, ARRAYSIZE(szMsg), szPart);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        wiauDbgDump("", "%s", szMsg);

    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

Cleanup:
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "CArray32::Dump", "Failed to dump array");
    }
    return;
}

//
// This function initializes a string array from raw data, clearing
// the array first, if needed
//
// Input:
//   ppRaw -- pointer to pointer to raw data to initialize the string from
//   bParse -- indicates whether to advance the raw pointer or not
//
HRESULT
CArrayString::Init(
    BYTE **ppRaw,
    int NumSize
    )
{
    HRESULT hr = S_OK;

    if (!ppRaw || !*ppRaw)
        return E_INVALIDARG;

    RemoveAll();

    // Get the number of elements from the raw data
    int NumElems;
    switch (NumSize)
    {
    case 4:
        NumElems = MAKELONG(MAKEWORD((*ppRaw)[0],(*ppRaw)[1]),
                            MAKEWORD((*ppRaw)[2],(*ppRaw)[3]));
        break;
    case 2:
        NumElems = MAKEWORD((*ppRaw)[0],(*ppRaw)[1]);
        break;
    case 1:
        NumElems = (BYTE) **ppRaw;
        break;
    default:
        return E_FAIL;
    }

    // Allocate space for the array
    if (!GrowTo(NumElems))
        return E_OUTOFMEMORY;

    // Advance past the number of elements field
    *ppRaw += NumSize;

    // Read in each string
    CBstr tempStr;
    for (int count = 0; count < NumElems; count++)
    {
        tempStr.Init(ppRaw, TRUE);
        if (!Add(tempStr))
            return E_FAIL;
    }

    return hr;
}

//
// Dumps the contents of a CArrayString to the log
//
// Input:
//  szDesc -- description for the string
//  szFiller -- filler to use for subsequent lines
//
VOID
CArrayString::Dump(
    char *szDesc,
    char *szFiller
    )
{
    int count;
        
    //
    // Make sure it's not empty
    //
    if (GetSize() > 0)
    {
        //
        // Dump first string with description
        //
        m_aT[0].Dump(szDesc);

        //
        // Loop through the elements, dumping with the filler
        //
        for (count = 1; count < GetSize(); count++)
            m_aT[count].Dump(szFiller);
    }
    else
    {
        wiauDbgDump("", "%s <blank>", szDesc);
    }

    return;
}

//
// CPtpDeviceInfo constructor
//
CPtpDeviceInfo::CPtpDeviceInfo() :
    m_Version(0),
    m_VendorExtId(0),
    m_VendorExtVersion(0),
    m_FuncMode(0)
{
}

//
// CPtpDeviceInfo copying constructor
//
CPtpDeviceInfo::CPtpDeviceInfo(const CPtpDeviceInfo &src) :
    m_Version(src.m_Version),
    m_VendorExtId(src.m_VendorExtId),
    m_VendorExtVersion(src.m_VendorExtVersion),
    m_cbstrVendorExtDesc(src.m_cbstrVendorExtDesc),
    m_FuncMode(src.m_FuncMode),
    m_cbstrManufacturer(src.m_cbstrManufacturer),
    m_cbstrModel(src.m_cbstrModel),
    m_cbstrDeviceVersion(src.m_cbstrDeviceVersion),
    m_cbstrSerialNumber(src.m_cbstrSerialNumber)
{
    for (INT i = 0; i < src.m_SupportedOps.GetSize(); i++)
    {
        m_SupportedOps.Add(src.m_SupportedOps[i]);
    }

    for (i = 0; i < src.m_SupportedEvents.GetSize(); i++)
    {
        m_SupportedEvents.Add(src.m_SupportedEvents[i]);
    }

    for (i = 0; i < src.m_SupportedProps.GetSize(); i++)
    {
        m_SupportedProps.Add(src.m_SupportedProps[i]);
    }

    for (i = 0; i < src.m_SupportedCaptureFmts.GetSize(); i++)
    {
        m_SupportedCaptureFmts.Add(src.m_SupportedCaptureFmts[i]);
    }

    for (i = 0; i < src.m_SupportedImageFmts.GetSize(); i++)
    {
        m_SupportedImageFmts.Add(src.m_SupportedImageFmts[i]);
    }
}

//
// CPtpDeviceInfo destructor
//
CPtpDeviceInfo::~CPtpDeviceInfo()
{
}

//
// This function initializes the device info from raw data
//
// Input:
//   pRawData -- the raw data
//
HRESULT
CPtpDeviceInfo::Init(BYTE *pRawData)
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRawData;

    m_Version = ParseWord(&pCurrent);
    m_VendorExtId = ParseDword(&pCurrent);
    m_VendorExtVersion = ParseWord(&pCurrent);

    hr = m_cbstrVendorExtDesc.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    m_FuncMode = ParseWord(&pCurrent);

    if (!m_SupportedOps.Parse(&pCurrent))
        return E_FAIL;

    if (!m_SupportedEvents.Parse(&pCurrent))
        return E_FAIL;

    if (!m_SupportedProps.Parse(&pCurrent))
        return E_FAIL;

    if (!m_SupportedCaptureFmts.Parse(&pCurrent))
        return E_FAIL;

    if (!m_SupportedImageFmts.Parse(&pCurrent))
        return E_FAIL;

    hr = m_cbstrManufacturer.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrModel.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrDeviceVersion.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrSerialNumber.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    return hr;
}

//
// This function dumps the device information to the log
//
VOID
CPtpDeviceInfo::Dump()
{
    wiauDbgDump("", "DumpDeviceInfo, dumping DeviceInfo:");
    wiauDbgDump("", "  Standard version  = 0x%04x", m_Version);
    wiauDbgDump("", "  Vendor ext id     = 0x%08x", m_VendorExtId);
    wiauDbgDump("", "  Vendor ext ver    = 0x%04x", m_VendorExtVersion);

    m_cbstrVendorExtDesc.Dump(   "  Vendor ext desc   =");
    
    m_SupportedOps.Dump(         "  Ops supported     =", "                     ");
    m_SupportedEvents.Dump(      "  Events supported  =", "                     ");
    m_SupportedProps.Dump(       "  Props supported   =", "                     ");
    m_SupportedCaptureFmts.Dump( "  Capture fmts supp =", "                     ");
    m_SupportedImageFmts.Dump(   "  Img formats supp  =", "                     ");

    m_cbstrManufacturer.Dump(    "  Manufacturer      =");
    m_cbstrModel.Dump(           "  Model             =");
    m_cbstrDeviceVersion.Dump(   "  Device Version    =");
    m_cbstrSerialNumber.Dump(    "  Serial Number     =");

    return;
}

//
// CPtpStorageInfo constructor
//
CPtpStorageInfo::CPtpStorageInfo() :
    m_StorageId(0),
    m_StorageType(0),           
    m_FileSystemType(0),    
    m_AccessCapability(0),  
    m_MaxCapacity(0),       
    m_FreeSpaceInBytes(0),  
    m_FreeSpaceInImages(0)
{
}

//
// CPtpStorageInfo destructor
//
CPtpStorageInfo::~CPtpStorageInfo()
{
}

//
// This function initializes the device info from raw data
//
// Input:
//   pRawData -- the raw data
//
HRESULT
CPtpStorageInfo::Init(
    BYTE *pRawData,
    DWORD StorageId
    )
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRawData;

    m_StorageId = StorageId;

    m_StorageType = ParseWord(&pCurrent);
    m_FileSystemType = ParseWord(&pCurrent);
    m_AccessCapability = ParseWord(&pCurrent);
    m_MaxCapacity = ParseQword(&pCurrent);
    m_FreeSpaceInBytes = ParseQword(&pCurrent);
    m_FreeSpaceInImages = ParseDword(&pCurrent);

    hr = m_cbstrStorageDesc.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrStorageLabel.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    return hr;
}

//
// This function dumps the storage information to the log
//
VOID
CPtpStorageInfo::Dump()
{
    wiauDbgDump("", "DumpStorageInfo, dumping StorageInfo for store 0x%08x:", m_StorageId);
    
    
    wiauDbgDump("", "  Storage type      = 0x%04x", m_StorageType);
    wiauDbgDump("", "  File system type  = 0x%04x", m_FileSystemType);
    wiauDbgDump("", "  Access capability = 0x%04x", m_AccessCapability);
    wiauDbgDump("", "  Max capacity      = %I64u", m_MaxCapacity);
    wiauDbgDump("", "  Free space (byte) = %I64u", m_FreeSpaceInBytes);
    wiauDbgDump("", "  Free space (imgs) = %u", m_FreeSpaceInImages);

    m_cbstrStorageDesc.Dump(  "  Storage desc      =");
    m_cbstrStorageLabel.Dump( "  Storage label     =");

    return;
}

//
// CPtpObjectInfo constructor
//
CPtpObjectInfo::CPtpObjectInfo() :
    m_ObjectHandle(0),
    m_StorageId(0),           
    m_FormatCode(0),          
    m_ProtectionStatus(0),    
    m_CompressedSize(0),      
    m_ThumbFormat(0),         
    m_ThumbCompressedSize(0), 
    m_ThumbPixWidth(0),       
    m_ThumbPixHeight(0),      
    m_ImagePixWidth(0),       
    m_ImagePixHeight(0),      
    m_ImageBitDepth(0),       
    m_ParentHandle(0),        
    m_AssociationType(0),     
    m_AssociationDesc(0),     
    m_SequenceNumber(0)      
{
}

//
// CPtpObjectInfo destructor
//
CPtpObjectInfo::~CPtpObjectInfo()
{
}

//
// This function initializes the object info from raw data
//
// Input:
//   pRawData -- the raw data
//   ObjectHandle -- the object's handle
//
HRESULT
CPtpObjectInfo::Init(
    BYTE *pRawData,
    DWORD ObjectHandle
    )
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRawData;

    m_ObjectHandle = ObjectHandle;

    m_StorageId = ParseDword(&pCurrent);
    m_FormatCode = ParseWord(&pCurrent);
    m_ProtectionStatus = ParseWord(&pCurrent);
    m_CompressedSize = ParseDword(&pCurrent);
    m_ThumbFormat = ParseWord(&pCurrent);
    m_ThumbCompressedSize = ParseDword(&pCurrent);
    m_ThumbPixWidth = ParseDword(&pCurrent);
    m_ThumbPixHeight = ParseDword(&pCurrent);
    m_ImagePixWidth = ParseDword(&pCurrent);
    m_ImagePixHeight = ParseDword(&pCurrent);
    m_ImageBitDepth = ParseDword(&pCurrent);
    m_ParentHandle = ParseDword(&pCurrent);
    m_AssociationType = ParseWord(&pCurrent);
    m_AssociationDesc = ParseDword(&pCurrent);
    m_SequenceNumber = ParseDword(&pCurrent);

    hr = m_cbstrFileName.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrCaptureDate.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrModificationDate.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    hr = m_cbstrKeywords.Init(&pCurrent, TRUE);
    if (FAILED(hr))
        return hr;

    return hr;
}

//
// This function writes the ObjectInfo structure to a buffer in PTP format
//
// Input:
//   ppRaw -- pointer to pointer to buffer
//   Length -- amount of space left in the buffer in bytes
//
VOID
CPtpObjectInfo::WriteToBuffer(
    BYTE **ppRaw
    )
{
    WriteDword(ppRaw, m_StorageId);
    WriteWord(ppRaw, m_FormatCode);
    WriteWord(ppRaw, m_ProtectionStatus);
    WriteDword(ppRaw, m_CompressedSize);
    WriteWord(ppRaw, m_ThumbFormat);
    WriteDword(ppRaw, m_ThumbCompressedSize);
    WriteDword(ppRaw, m_ThumbPixWidth);
    WriteDword(ppRaw, m_ThumbPixHeight);
    WriteDword(ppRaw, m_ImagePixWidth);
    WriteDword(ppRaw, m_ImagePixHeight);
    WriteDword(ppRaw, m_ImageBitDepth);
    WriteDword(ppRaw, m_ParentHandle);
    WriteWord(ppRaw, m_AssociationType);
    WriteDword(ppRaw, m_AssociationDesc);
    WriteDword(ppRaw, m_SequenceNumber);
    m_cbstrFileName.WriteToBuffer(ppRaw);
    m_cbstrCaptureDate.WriteToBuffer(ppRaw);
    m_cbstrModificationDate.WriteToBuffer(ppRaw);
    m_cbstrKeywords.WriteToBuffer(ppRaw);

    return;
}


//
// This function dumps the object information to the log
//
VOID
CPtpObjectInfo::Dump()
{
    wiauDbgDump("", "DumpObjectInfo, dumping ObjectInfo for object 0x%08x:", m_ObjectHandle);
    wiauDbgDump("", "  Storage id        = 0x%08x", m_StorageId);
    wiauDbgDump("", "  Format code       = 0x%04x", m_FormatCode);
    wiauDbgDump("", "  Protection status = 0x%04x", m_ProtectionStatus);
    wiauDbgDump("", "  Compressed size   = %u", m_CompressedSize);
    wiauDbgDump("", "  Thumbnail format  = 0x%04x", m_ThumbFormat);
    wiauDbgDump("", "  Thumbnail size    = %u", m_ThumbCompressedSize);
    wiauDbgDump("", "  Thumbnail width   = %u", m_ThumbPixWidth);
    wiauDbgDump("", "  Thumbnail height  = %u", m_ThumbPixHeight);
    wiauDbgDump("", "  Image width       = %u", m_ImagePixWidth);
    wiauDbgDump("", "  Image height      = %u", m_ImagePixHeight);
    wiauDbgDump("", "  Image bit depth   = %u", m_ImageBitDepth);
    wiauDbgDump("", "  Parent obj handle = 0x%08x", m_ParentHandle);
    wiauDbgDump("", "  Association type  = 0x%04x", m_AssociationType);
    wiauDbgDump("", "  Association desc  = 0x%08x", m_AssociationDesc);
    wiauDbgDump("", "  Sequence number   = %u", m_SequenceNumber);

    m_cbstrFileName.Dump(         "  File name         =");
    m_cbstrCaptureDate.Dump(      "  Capture date      =");
    m_cbstrModificationDate.Dump( "  Modification date =");
    m_cbstrKeywords.Dump(         "  Keywords          =");

    return;
}

//
// CPtpPropDesc constructor
//
CPtpPropDesc::CPtpPropDesc() :
    m_PropCode(0),
    m_DataType(0),
    m_GetSet(0),
    m_FormFlag(0),
    m_NumValues(0),
    m_lDefault(0),
    m_lCurrent(0),
    m_lRangeMin(0),
    m_lRangeMax(0),
    m_lRangeStep(0)
{
}

//
// CPtpPropDesc destructor
//
CPtpPropDesc::~CPtpPropDesc()
{
}

//
// This function initializes a CPtpPropDesc from raw data
//
// Input:
//   pRawData -- pointer to the raw data
//
HRESULT
CPtpPropDesc::Init(BYTE *pRawData)
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRawData;

    m_PropCode = ParseWord(&pCurrent);
    m_DataType = ParseWord(&pCurrent);
    m_GetSet = *pCurrent++;

    switch (m_DataType)
    {
    case PTP_DATATYPE_INT8:
    case PTP_DATATYPE_UINT8:
        m_lDefault = *pCurrent++;
        m_lCurrent = *pCurrent++;
        break;
    case PTP_DATATYPE_INT16:
    case PTP_DATATYPE_UINT16:
        m_lDefault = ParseWord(&pCurrent);
        m_lCurrent = ParseWord(&pCurrent);
        break;
    case PTP_DATATYPE_INT32:
    case PTP_DATATYPE_UINT32:
        m_lDefault = ParseDword(&pCurrent);
        m_lCurrent = ParseDword(&pCurrent);
        break;
    case PTP_DATATYPE_STRING:
        hr = m_cbstrDefault.Init(&pCurrent, TRUE);
        if (FAILED(hr)) return hr;
        hr = m_cbstrCurrent.Init(&pCurrent, TRUE);
        if (FAILED(hr)) return hr;
        break;
    default:
        return E_FAIL;
    }

    m_FormFlag = *pCurrent++;

    if (m_FormFlag == PTP_FORMFLAGS_RANGE)
    {
        switch (m_DataType)
        {
        case PTP_DATATYPE_INT8:
        case PTP_DATATYPE_UINT8:
            m_lRangeMin = *pCurrent++;
            m_lRangeMax = *pCurrent++;
            m_lRangeStep = *pCurrent++;
            m_lRangeStep = max(1, m_lRangeStep);
            break;
        case PTP_DATATYPE_INT16:
        case PTP_DATATYPE_UINT16:
            m_lRangeMin = ParseWord(&pCurrent);
            m_lRangeMax = ParseWord(&pCurrent);
            m_lRangeStep = ParseWord(&pCurrent);
            m_lRangeStep = max(1, m_lRangeStep);
            break;
        case PTP_DATATYPE_INT32:
        case PTP_DATATYPE_UINT32:
            m_lRangeMin = ParseDword(&pCurrent);
            m_lRangeMax = ParseDword(&pCurrent);
            m_lRangeStep = ParseDword(&pCurrent);
            m_lRangeStep = max(1, m_lRangeStep);
            break;
        case PTP_DATATYPE_STRING:
            hr = m_cbstrRangeMin.Init(&pCurrent, TRUE);
            if (FAILED(hr)) return hr;
            hr = m_cbstrRangeMax.Init(&pCurrent, TRUE);
            if (FAILED(hr)) return hr;
            hr = m_cbstrRangeStep.Init(&pCurrent, TRUE);
            if (FAILED(hr)) return hr;
            break;
        default:
            return E_FAIL;
        }
    }

    else if (m_FormFlag == PTP_FORMFLAGS_ENUM)
    {
        switch (m_DataType)
        {
        case PTP_DATATYPE_INT8:
        case PTP_DATATYPE_UINT8:
            if (!m_lValues.ParseFrom8(&pCurrent, 2))
                return E_FAIL;
            break;
        case PTP_DATATYPE_INT16:
        case PTP_DATATYPE_UINT16:
            if (!m_lValues.ParseFrom16(&pCurrent, 2))
                return E_FAIL;
            break;
        case PTP_DATATYPE_INT32:
        case PTP_DATATYPE_UINT32:
            if (!m_lValues.Parse(&pCurrent, 2))
                return E_FAIL;
            break;
        case PTP_DATATYPE_STRING:
            hr = m_cbstrValues.Init(&pCurrent, 2);
            if (FAILED(hr)) return hr;
            break;
        default:
            return E_FAIL;
        }

        m_NumValues = max(m_lValues.GetSize(), m_cbstrValues.GetSize());

    }

    return hr;
}

//
// This function sets the current value of a CPtpPropDesc from raw data
//
// Input:
//   pRaw -- pointer to the raw data
//
HRESULT
CPtpPropDesc::ParseValue(BYTE *pRaw)
{
    HRESULT hr = S_OK;

    BYTE *pCurrent = pRaw;

    switch (m_DataType)
    {
    case PTP_DATATYPE_INT8:
    case PTP_DATATYPE_UINT8:
        m_lCurrent = *pCurrent++;
        break;
    case PTP_DATATYPE_INT16:
    case PTP_DATATYPE_UINT16:
        m_lCurrent = ParseWord(&pCurrent);
        break;
    case PTP_DATATYPE_INT32:
    case PTP_DATATYPE_UINT32:
        m_lCurrent = ParseDword(&pCurrent);
        break;
    case PTP_DATATYPE_STRING:
        hr = m_cbstrCurrent.Init(&pCurrent, TRUE);
        break;
    default:
        return E_FAIL;
    }

    return hr;
}

//
// This function writes the current value of a CPtpPropDesc to a raw buffer
//
// Input:
//   ppRaw -- pointer to pointer to a raw buffer
//
VOID
CPtpPropDesc::WriteValue(BYTE **ppRaw)
{
    switch (m_DataType)
    {
    case PTP_DATATYPE_INT8:
    case PTP_DATATYPE_UINT8:
        **ppRaw = (BYTE) m_lCurrent;
        (*ppRaw)++;
        break;
    case PTP_DATATYPE_INT16:
    case PTP_DATATYPE_UINT16:
        WriteWord(ppRaw, (WORD) m_lCurrent);
        break;
    case PTP_DATATYPE_INT32:
    case PTP_DATATYPE_UINT32:
        WriteDword(ppRaw, m_lCurrent);
        break;
    case PTP_DATATYPE_STRING:
        m_cbstrCurrent.WriteToBuffer(ppRaw);
        break;
    }

    return;
}

//
// This function dumps the property description information to the log
//
VOID
CPtpPropDesc::Dump()
{
    wiauDbgDump("", "CPtpPropDesc::Dump, dumping PropDesc for property 0x%04x:", m_PropCode);
    wiauDbgDump("", "  Data type         = 0x%04x", m_DataType);
    wiauDbgDump("", "  GetSet            = 0x%02x", m_GetSet);

    if (m_DataType == PTP_DATATYPE_STRING)
    {
        m_cbstrDefault.Dump("  Default           =");
        m_cbstrCurrent.Dump("  Current           =");
        wiauDbgDump("", "  Form flag         = 0x%02x", m_FormFlag);

        switch (m_FormFlag)
        {
        case PTP_FORMFLAGS_RANGE:
            m_cbstrRangeMin.Dump("  Range min         =");
            m_cbstrRangeMax.Dump("  Range max         =");
            m_cbstrRangeStep.Dump("  Range step        =");
            break;
        case PTP_FORMFLAGS_ENUM:
            m_cbstrValues.Dump("  Valid values      =", "                     ");
            break;
        default:
            wiauDbgDump("", "  <unknown valid value type>");
        }
    }

    else
    {
        wiauDbgDump("", "  Default           = 0x%08x", m_lDefault);
        wiauDbgDump("", "  Current           = 0x%08x", m_lCurrent);
        wiauDbgDump("", "  Form flag         = 0x%02x", m_FormFlag);

        switch (m_FormFlag)
        {
        case PTP_FORMFLAGS_RANGE:
            wiauDbgDump("", "  Range min         = 0x%08x", m_lRangeMin);
            wiauDbgDump("", "  Range max         = 0x%08x", m_lRangeMax);
            wiauDbgDump("", "  Range step        = 0x%08x", m_lRangeStep);
            break;
        case PTP_FORMFLAGS_ENUM:
            m_lValues.Dump("  Valid values      =", "                     ");
            break;
        default:
            wiauDbgDump("", "  <unknown valid value type>");
        }
    }

    return;
}

//
// This function dumps the property value to the log
//
VOID
CPtpPropDesc::DumpValue()
{
    wiauDbgDump("", "CPtpPropDescDumpValue, current value for property 0x%04x:", m_PropCode);

    if (m_DataType == PTP_DATATYPE_STRING)
        m_cbstrCurrent.Dump("  Current           =");

    else
        wiauDbgDump("", "  Current           = 0x%08x", m_lCurrent);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\ptppch.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ptppch.h

Abstract:

    Precompiled header

Author:

    DavePar

Revision History:


--*/


#ifndef _PTPPCH_H
#define _PTPPCH_H

#include <windows.h>
#include <stddef.h>
#include <tchar.h>
#include <objbase.h>
#include <assert.h>
#include <stdio.h>

#include <usbscan.h>

#include <wiamindr.h>
#include <wiautil.h>

#include "wiatempl.h"
#include "iso15740.h"
#include "camera.h"
#include "camusb.h"
#include "ptputil.h"

#define STRSAFE_NO_DEPRECATE // don't deprecate old string functions
#define STRSAFE_NO_CB_FUNCTIONS // don't define byte count based functions, use character count only
#include "strsafe.h"

#endif // _PTPPCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\ptputil.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    ptputil.h

Abstract:

    This module declares PTP data manipulating utility functions

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef PTPUTIL__H_
#define PTPUTIL__H_

//
// Time conversion functions
//
HRESULT PtpTime2SystemTime(CBstr *pptpTime, SYSTEMTIME *pSystemTime);
HRESULT SystemTime2PtpTime(SYSTEMTIME *pSystemTime, CBstr *pptpTime, BOOL bTwoDigitsForMilliseconds);

//
// Functions that dump a PTP structure to the log file
//
VOID    DumpCommand(PTP_COMMAND *pCommand, DWORD NumParams);
VOID    DumpResponse(PTP_RESPONSE *pResponse);
VOID    DumpEvent(PTP_EVENT *pEvent);
VOID    DumpGuid(GUID *pGuid);

//
// Macro for getting size of array
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))
#endif

//
// Class for reading registry entries
//
class CPTPRegistry
{
public:
    CPTPRegistry() :
        m_hKey(NULL)
    {
    }

    ~CPTPRegistry()
    {
        if (m_hKey)
            RegCloseKey(m_hKey);
    }

    HRESULT Open(HKEY hkAncestor, LPCTSTR KeyName, REGSAM Access = KEY_READ);
    HRESULT GetValueStr(LPCTSTR ValueName, TCHAR *string, DWORD *pcbStringBytes);
    HRESULT GetValueDword(LPCTSTR ValueName, DWORD *pValue);
    HRESULT GetValueCodes(LPCTSTR ValueName, CArray16 *pCodeArray);

private:
    HKEY    m_hKey;
};

#endif // PTPUTIL__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\iso15740.h ===
/*++
Copyright (c) 1999- Microsoft Corporation

Module Name:

    ISO15740.h

Abstract:
    This module contains PIMA15740 defined data types and their predefined
    values(if there are any).

Revision History:

--*/

#ifndef ISO15740__H_
#define ISO15740__H_

//
// This is PTP_STRING maximum string length in characters.
//
const UINT32 PTP_MAXSTRINGSIZE = 255;

//
// Define QWORD type
//
typedef unsigned __int64 QWORD;

//
// Every structure must be packed on byte boundary
//
#pragma pack(push,Old,1)
//
// Define 128 bits integer and unsigned integer
// This will be the base type of INT128 and UINT128
//
typedef struct tagInt128
{
    unsigned __int64 LowPart;
         __int64 HighPart;
}INT128, *PINT128;

typedef struct tagUInt128
{
    unsigned __int64 LowPart;
    unsigned __int64 HighPart;
}UINT128, *PUINT128;

//
// Data code ranges and masks. Each data code has 16 bits:
//
// Bit 15(std/vendor)
//    0 -- the code is defined by PTP standard
//    1 -- the code is vendor specific
//
// Bit 14 - 12(data type)
//   14 13 12
//   0  0  0    -- undefined data type
//   0  0  1    -- op code
//   0  1  0    -- response code
//   0  1  1    -- format code
//   1  0  0    -- event code
//   1  0  1    -- property code
//   1  1  0    -- reserved
//   1  1  1    -- reserved
//
// Bit 11 - bit 0 (data value)
//
const WORD  PTP_DATACODE_VENDORMASK         = 0x8000;
const WORD  PTP_DATACODE_TYPEMASK           = 0x7000;
const WORD  PTP_DATACODE_VALUEMASK          = 0x0FFF;
const WORD  PTP_DATACODE_TYPE_UNKNOWN       = 0x0000;
const WORD  PTP_DATACODE_TYPE_OPERATION     = 0x1000;
const WORD  PTP_DATACODE_TYPE_RESPONSE      = 0x2000;
const WORD  PTP_DATACODE_TYPE_FORMAT        = 0x3000;
const WORD  PTP_DATACODE_TYPE_EVENT         = 0x4000;
const WORD  PTP_DATACODE_TYPE_PROPERTY      = 0x5000;
const WORD  PTP_DATACODE_TYPE_RESERVED_1    = 0x6000;
const WORD  PTP_DATACODE_TYPE_RESERVED_2    = 0x7000;
//
// To verify an op code
//  (Code & PTP_DATACODE_TYPEMASK) == PTP_DATACODE_TYPE_OPERATION
// To verify a response code
//  (Code & PTP_DATACODE_TYPEMASK) == PTP_DATACODE_TYPE_RESPONSE)

//
// Image format codes receive special treatment.
//
const WORD  PTP_DATACODE_TYPEIMAGEMASK      = 0x7800;
const WORD  PTP_DATACODE_TYPE_IMAGEFORMAT   = 0x3800;
const WORD  PTP_DATACODE_VALUE_IMAGEVMASK   = 0x07FF;
// To verify an image code
// (Code & PTP_DATACODE_TYPEIMAGEMASK) == PTP_DATACODE_TYPE_IMAGEFORMAT
//

//
// PTP specially defined constants
//
const DWORD PTP_OBJECTHANDLE_ALL        = 0x0;
const DWORD PTP_OBJECTHANDLE_UNDEFINED  = 0x0;
const DWORD PTP_OBJECTHANDLE_ROOT       = 0xFFFFFFFF;
const DWORD PTP_STORAGEID_ALL           = 0xFFFFFFFF;
const DWORD PTP_STORAGEID_DEFAULT       = 0;
const DWORD PTP_STORAGEID_UNDEFINED     = 0;
const DWORD PTP_STORAGEID_PHYSICAL      = 0xFFFF0000;
const DWORD PTP_STORAGEID_LOGICAL       = 0x0000FFFF;
const DWORD PTP_SESSIONID_ALL           = 0;
const DWORD PTP_SESSIONID_NOSESSION     = 0;
const WORD  PTP_FORMATCODE_IMAGE        = 0xFFFF;
const WORD  PTP_FORMATCODE_ALL          = 0x0000;
const WORD  PTP_FORMATCODE_DEFAULT      = 0x0000;
const DWORD PTP_TRANSACTIONID_ALL       = 0xFFFFFFFF;
const DWORD PTP_TRANSACTIONID_NOSESSION = 0;
const DWORD PTP_TRANSACTIONID_MIN       = 1;
const DWORD PTP_TRANSACTIONID_MAX       = 0xFFFFFFFE;

//
// Data type codes.
//
const WORD PTP_DATATYPE_UNDEFINED   = 0x0000;
const WORD PTP_DATATYPE_INT8        = 0x0001;
const WORD PTP_DATATYPE_UINT8       = 0x0002;
const WORD PTP_DATATYPE_INT16       = 0x0003;
const WORD PTP_DATATYPE_UINT16      = 0x0004;
const WORD PTP_DATATYPE_INT32       = 0x0005;
const WORD PTP_DATATYPE_UINT32      = 0x0006;
const WORD PTP_DATATYPE_INT64       = 0x0007;
const WORD PTP_DATATYPE_UINT64      = 0x0008;
const WORD PTP_DATATYPE_INT128      = 0x0009;
const WORD PTP_DATATYPE_UINT128     = 0x000A;
const WORD PTP_DATATYPE_STRING      = 0xFFFF;


//
// standard operation codes
//
const WORD PTP_OPCODE_UNDEFINED             = 0x1000;
const WORD PTP_OPCODE_GETDEVICEINFO         = 0x1001;
const WORD PTP_OPCODE_OPENSESSION           = 0x1002;
const WORD PTP_OPCODE_CLOSESESSION          = 0x1003;
const WORD PTP_OPCODE_GETSTORAGEIDS         = 0x1004;
const WORD PTP_OPCODE_GETSTORAGEINFO        = 0x1005;
const WORD PTP_OPCODE_GETNUMOBJECTS         = 0x1006;
const WORD PTP_OPCODE_GETOBJECTHANDLES      = 0x1007;
const WORD PTP_OPCODE_GETOBJECTINFO         = 0x1008;
const WORD PTP_OPCODE_GETOBJECT             = 0x1009;
const WORD PTP_OPCODE_GETTHUMB              = 0x100A;
const WORD PTP_OPCODE_DELETEOBJECT          = 0x100B;
const WORD PTP_OPCODE_SENDOBJECTINFO        = 0x100C;
const WORD PTP_OPCODE_SENDOBJECT            = 0x100D;
const WORD PTP_OPCODE_INITIATECAPTURE       = 0x100E;
const WORD PTP_OPCODE_FORMATSTORE           = 0x100F;
const WORD PTP_OPCODE_RESETDEVICE           = 0x1010;
const WORD PTP_OPCODE_SELFTEST              = 0x1011;
const WORD PTP_OPCODE_SETOBJECTPROTECTION   = 0x1012;
const WORD PTP_OPCODE_POWERDOWN             = 0x1013;
const WORD PTP_OPCODE_GETDEVICEPROPDESC     = 0x1014;
const WORD PTP_OPCODE_GETDEVICEPROPVALUE    = 0x1015;
const WORD PTP_OPCODE_SETDEVICEPROPVALUE    = 0x1016;
const WORD PTP_OPCODE_RESETDEVICEPROPVALUE  = 0x1017;
const WORD PTP_OPCODE_TERMINATECAPTURE      = 0x1018;
const WORD PTP_OPCODE_MOVEOBJECT            = 0x1019;
const WORD PTP_OPCODE_COPYOBJECT            = 0x101A;
const WORD PTP_OPCODE_GETPARTIALOBJECT      = 0x101B;
const WORD PTP_OPCODE_INITIATEOPENCAPTURE   = 0x101C;

//
// standard event codes
//
const WORD PTP_EVENTCODE_UNDEFINED              = 0x4000;
const WORD PTP_EVENTCODE_CANCELTRANSACTION      = 0x4001;
const WORD PTP_EVENTCODE_OBJECTADDED            = 0x4002;
const WORD PTP_EVENTCODE_OBJECTREMOVED          = 0x4003;
const WORD PTP_EVENTCODE_STOREADDED             = 0x4004;
const WORD PTP_EVENTCODE_STOREREMOVED           = 0x4005;
const WORD PTP_EVENTCODE_DEVICEPROPCHANGED      = 0x4006;
const WORD PTP_EVENTCODE_OBJECTINFOCHANGED      = 0x4007;
const WORD PTP_EVENTCODE_DEVICEINFOCHANGED      = 0x4008;
const WORD PTP_EVENTCODE_REQUESTOBJECTTRANSFER  = 0x4009;
const WORD PTP_EVENTCODE_STOREFULL              = 0x400A;
const WORD PTP_EVENTCODE_DEVICERESET            = 0x400B;
const WORD PTP_EVENTCODE_STORAGEINFOCHANGED     = 0x400C;
const WORD PTP_EVENTCODE_CAPTURECOMPLETE        = 0x400D;
const WORD PTP_EVENTCODE_UNREPORTEDSTATUS       = 0x400E;
const WORD PTP_EVENTCODE_VENDOREXTENTION        = 0xC000;

//
// standard response codes
//
const WORD PTP_RESPONSECODE_UNDEFINED                   = 0x2000;
const WORD PTP_RESPONSECODE_OK                          = 0x2001;
const WORD PTP_RESPONSECODE_GENERALERROR                = 0x2002;
const WORD PTP_RESPONSECODE_SESSIONNOTOPEN              = 0x2003;
const WORD PTP_RESPONSECODE_INVALIDTRANSACTIONID        = 0x2004;
const WORD PTP_RESPONSECODE_OPERATIONNOTSUPPORTED       = 0x2005;
const WORD PTP_RESPONSECODE_PARAMETERNOTSUPPORTED       = 0x2006;
const WORD PTP_RESPONSECODE_INCOMPLETETRANSFER          = 0x2007;
const WORD PTP_RESPONSECODE_INVALIDSTORAGEID            = 0x2008;
const WORD PTP_RESPONSECODE_INVALIDOBJECTHANDLE         = 0x2009;
const WORD PTP_RESPONSECODE_INVALIDPROPERTYCODE         = 0x200A;
const WORD PTP_RESPONSECODE_INVALIDOBJECTFORMATCODE     = 0x200B;
const WORD PTP_RESPONSECODE_STOREFULL                   = 0x200C;
const WORD PTP_RESPONSECODE_OBJECTWRITEPROTECTED        = 0x200D;
const WORD PTP_RESPONSECODE_STOREWRITEPROTECTED         = 0x200E;
const WORD PTP_RESPONSECODE_ACCESSDENIED                = 0x200F;
const WORD PTP_RESPONSECODE_NOTHUMBNAILPRESENT          = 0x2010;
const WORD PTP_RESPONSECODE_SELFTESTFAILED              = 0x2011;
const WORD PTP_RESPONSECODE_PARTIALDELETION             = 0x2012;
const WORD PTP_RESPONSECODE_STORENOTAVAILABLE           = 0x2013;
const WORD PTP_RESPONSECODE_NOSPECIFICATIONBYFORMAT     = 0x2014;
const WORD PTP_RESPONSECODE_NOVALIDOBJECTINFO           = 0x2015;
const WORD PTP_RESPONSECODE_INVALIDCODEFORMAT           = 0x2016;
const WORD PTP_RESPONSECODE_UNKNOWNVENDORCODE           = 0x2017;
const WORD PTP_RESPONSECODE_CAPTUREALREADYTERMINATED    = 0x2018;
const WORD PTP_RESPONSECODE_DEVICEBUSY                  = 0x2019;
const WORD PTP_RESPONSECODE_INVALIDPARENT               = 0x201A;
const WORD PTP_RESPONSECODE_INVALIDPROPFORMAT           = 0x201B;
const WORD PTP_RESPONSECODE_INVALIDPROPVALUE            = 0x201C;
const WORD PTP_RESPONSECODE_INVALIDPARAMETER            = 0x201D;
const WORD PTP_RESPONSECODE_SESSIONALREADYOPENED        = 0x201E;
const WORD PTP_RESPONSECODE_TRANSACTIONCANCELLED        = 0x201F;

//
// offset for returning PTP response codes in an HRESULT
//
const HRESULT PTP_E_BASEERROR = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0);
#define HRESULT_FROM_PTP(x) (PTP_E_BASEERROR | (HRESULT) (x))


//
// standard property codes
//
const WORD PTP_PROPERTYCODE_UNDEFINED               = 0x5000;
const WORD PTP_PROPERTYCODE_BATTERYLEVEL            = 0x5001;
const WORD PTP_PROPERTYCODE_FUNCTIONMODE            = 0x5002;
const WORD PTP_PROPERTYCODE_IMAGESIZE               = 0x5003;
const WORD PTP_PROPERTYCODE_COMPRESSIONSETTING      = 0x5004;
const WORD PTP_PROPERTYCODE_WHITEBALANCE            = 0x5005;
const WORD PTP_PROPERTYCODE_RGBGAIN                 = 0x5006;
const WORD PTP_PROPERTYCODE_FNUMBER                 = 0x5007;
const WORD PTP_PROPERTYCODE_FOCALLENGTH             = 0x5008;
const WORD PTP_PROPERTYCODE_FOCUSDISTANCE           = 0x5009;
const WORD PTP_PROPERTYCODE_FOCUSMODE               = 0x500A;
const WORD PTP_PROPERTYCODE_EXPOSUREMETERINGMODE    = 0x500B;
const WORD PTP_PROPERTYCODE_FLASHMODE               = 0x500C;
const WORD PTP_PROPERTYCODE_EXPOSURETIME            = 0x500D;
const WORD PTP_PROPERTYCODE_EXPOSUREPROGRAMMODE     = 0x500E;
const WORD PTP_PROPERTYCODE_EXPOSUREINDEX           = 0x500F;
const WORD PTP_PROPERTYCODE_EXPOSURECOMPENSATION    = 0x5010;
const WORD PTP_PROPERTYCODE_DATETIME                = 0x5011;
const WORD PTP_PROPERTYCODE_CAPTUREDELAY            = 0x5012;
const WORD PTP_PROPERTYCODE_STILLCAPTUREMODE        = 0x5013;
const WORD PTP_PROPERTYCODE_CONTRAST                = 0x5014;
const WORD PTP_PROPERTYCODE_SHARPNESS               = 0x5015;
const WORD PTP_PROPERTYCODE_DIGITALZOOM             = 0x5016;
const WORD PTP_PROPERTYCODE_EFFECTMODE              = 0x5017;
const WORD PTP_PROPERTYCODE_BURSTNUMBER             = 0x5018;
const WORD PTP_PROPERTYCODE_BURSTINTERVAL           = 0x5019;
const WORD PTP_PROPERTYCODE_TIMELAPSENUMBER         = 0x501A;
const WORD PTP_PROPERTYCODE_TIMELAPSEINTERVAL       = 0x501B;
const WORD PTP_PROPERTYCODE_FOCUSMETERINGMODE       = 0x501C;


//
// standard format codes
//
const WORD  PTP_FORMATMASK_IMAGE        = 0x0800;

const WORD  PTP_FORMATCODE_NOTUSED      = 0x0000;
const WORD  PTP_FORMATCODE_ALLIMAGES    = 0xFFFF;
const WORD  PTP_FORMATCODE_UNDEFINED    = 0x3000;
const WORD  PTP_FORMATCODE_ASSOCIATION  = 0x3001;
const WORD  PTP_FORMATCODE_SCRIPT       = 0x3002;
const WORD  PTP_FORMATCODE_EXECUTABLE   = 0x3003;
const WORD  PTP_FORMATCODE_TEXT         = 0x3004;
const WORD  PTP_FORMATCODE_HTML         = 0x3005;
const WORD  PTP_FORMATCODE_DPOF         = 0x3006;
const WORD  PTP_FORMATCODE_AIFF         = 0x3007;
const WORD  PTP_FORMATCODE_WAVE         = 0x3008;
const WORD  PTP_FORMATCODE_MP3          = 0x3009;
const WORD  PTP_FORMATCODE_AVI          = 0x300A;
const WORD  PTP_FORMATCODE_MPEG         = 0x300B;

const WORD  PTP_FORMATCODE_IMAGE_UNDEFINED  = 0x3800;
const WORD  PTP_FORMATCODE_IMAGE_EXIF       = 0x3801;
const WORD  PTP_FORMATCODE_IMAGE_TIFFEP     = 0x3802;
const WORD  PTP_FORMATCODE_IMAGE_FLASHPIX   = 0x3803;
const WORD  PTP_FORMATCODE_IMAGE_BMP        = 0x3804;
const WORD  PTP_FORMATCODE_IMAGE_CIFF       = 0x3805;
const WORD  PTP_FORMATCODE_IMAGE_GIF        = 0x3807;
const WORD  PTP_FORMATCODE_IMAGE_JFIF       = 0x3808;
const WORD  PTP_FORMATCODE_IMAGE_PCD        = 0x3809;
const WORD  PTP_FORMATCODE_IMAGE_PICT       = 0x380A;
const WORD  PTP_FORMATCODE_IMAGE_PNG        = 0x380B;
const WORD  PTP_FORMATCODE_IMAGE_TIFF       = 0x380D;
const WORD  PTP_FORMATCODE_IMAGE_TIFFIT     = 0x380E;
const WORD  PTP_FORMATCODE_IMAGE_JP2        = 0x380F;
const WORD  PTP_FORMATCODE_IMAGE_JPX        = 0x3810;

//
// Property values definitions
//

//
// Property description data set form flags definitions
//
const BYTE PTP_FORMFLAGS_NONE      = 0;
const BYTE PTP_FORMFLAGS_RANGE     = 1;
const BYTE PTP_FORMFLAGS_ENUM      = 2;

//
// power states
//
const WORD PTP_POWERSTATE_DEVICEOFF   = 0x0000;
const WORD PTP_POWERSTATE_SLEEP       = 0x0001;
const WORD PTP_POWERSTATE_FULL        = 0x0002;


//
// white balances
//
const WORD PTP_WHITEBALANCE_UNDEFINED   = 0x0000;
const WORD PTP_WHILEBALANCE_MANUAL      = 0x0001;
const WORD PTP_WHITEBALANCE_AUTOMATIC   = 0x0002;
const WORD PTP_WHITEBALANCE_ONEPUSHAUTO = 0x0003;
const WORD PTP_WHITEBALANCE_DAYLIGHT    = 0x0004;
const WORD PTP_WHITEBALANCE_FLORESCENT  = 0x0005;
const WORD PTP_WHITEBALANCE_TUNGSTEN    = 0x0006;
const WORD PTP_WHITEBALANCE_FLASH       = 0x0007;


//
// focus modes
//
const WORD PTP_FOCUSMODE_UNDEFINED = 0x0000;
const WORD PTP_FOCUSMODE_MANUAL    = 0x0001;
const WORD PTP_FOCUSMODE_AUTO      = 0x0002;
const WORD PTP_FOCUSMODE_MACRO     = 0x0003;

//
// focus metering
//
const WORD  PTP_FOCUSMETERING_UNDEFINED    = 0x0000;
const WORD  PTP_FOCUSMETERING_CENTERSPOT   = 0x0001;
const WORD  PTP_FOCUSMETERING_MULTISPOT    = 0x0002;

//
// flash modes
//
const WORD PTP_FLASHMODE_UNDEFINED     = 0x0000;
const WORD PTP_FLASHMODE_AUTO          = 0x0001;
const WORD PTP_FLASHMODE_OFF           = 0x0002;
const WORD PTP_FLASHMODE_FILL          = 0x0003;
const WORD PTP_FLASHMODE_REDEYEAUTO    = 0x0004;
const WORD PTP_FLASHMODE_REDEYEFILL    = 0x0005;
const WORD PTP_FLASHMODE_EXTERNALSYNC  = 0x0006;

//
// exposure modes
//
const WORD PTP_EXPOSUREMODE_UNDEFINED           = 0x0000;
const WORD PTP_EXPOSUREMODE_MANUALSETTING       = 0x0001;
const WORD PTP_EXPOSUREMODE_AUTOPROGRAM         = 0x0002;
const WORD PTP_EXPOSUREMODE_APERTUREPRIORITY    = 0x0003;
const WORD PTP_EXPOSUREMODE_SHUTTERPRIORITY     = 0x0004;
const WORD PTP_EXPOSUREMODE_PROGRAMCREATIVE     = 0x0005;
const WORD PTP_EXPOSUREMODE_PROGRAMACTION       = 0x0006;
const WORD PTP_EXPOSUREMODE_PORTRAIT            = 0x0007;

//
// capturing modes
//
const WORD  PTP_CAPTUREMODE_UNDEFINED    = 0x0000;
const WORD  PTP_CAPTUREMODE_NORMAL       = 0x0001;
const WORD  PTP_CAPTUREMODE_BURST        = 0x0002;
const WORD  PTP_CAPTUREMODE_TIMELAPSE    = 0x0003;

//
// focus metering modes
//
const WORD   PTP_FOCUSMETERMODE_UNDEFINED   = 0x0000;
const WORD   PTP_FOCUSMETERMODE_CENTERSPOT  = 0x0001;
const WORD   PTP_FOCUSMETERMODE_MULTISPOT   = 0x0002;


//
// effect modes
//
const WORD PTP_EFFECTMODE_UNDEFINED = 0x0000;
const WORD PTP_EFFECTMODE_COLOR     = 0x0001;
const WORD PTP_EFFECTMODE_BW        = 0x0002;
const WORD PTP_EFFECTMODE_SEPIA     = 0x0003;


//
// storage types
//
const WORD PTP_STORAGETYPE_UNDEFINED     = 0x0000;
const WORD PTP_STORAGETYPE_FIXEDROM      = 0x0001;
const WORD PTP_STORAGETYPE_REMOVABLEROM  = 0x0002;
const WORD PTP_STORAGETYPE_FIXEDRAM      = 0x0003;
const WORD PTP_STORAGETYPE_REMOVABLERAM  = 0x0004;

//
// storage access capabilities
//
const WORD PTP_STORAGEACCESS_RWD = 0x0000;
const WORD PTP_STORAGEACCESS_R   = 0x0001;
const WORD PTP_STORAGEACCESS_RD  = 0x0002;

//
// association types
//
const WORD PTP_ASSOCIATIONTYPE_UNDEFINED        = 0x0000;
const WORD PTP_ASSOCIATIONTYPE_FOLDER           = 0x0001;
const WORD PTP_ASSOCIATIONTYPE_ALBUM            = 0x0002;
const WORD PTP_ASSOCIATIONTYPE_BURST            = 0x0003;
const WORD PTP_ASSOCIATIONTYPE_HPANORAMA        = 0x0004;
const WORD PTP_ASSOCIATIONTYPE_VPANORAMA        = 0x0005;
const WORD PTP_ASSOCIATIONTYPE_2DPANORAMA       = 0x0006;
const WORD PTP_ASSOCIATIONTYPE_ANCILLARYDATA    = 0x0007;

//
// protection status
//
const WORD PTP_PROTECTIONSTATUS_NONE        = 0x0000;
const WORD PTP_PROTECTIONSTATUS_READONLY    = 0x0001;

//
// file system types
//
const WORD PTP_FILESYSTEMTYPE_UNDEFINED     = 0x0000;
const WORD PTP_FILESYSTEMTYPE_FLAT          = 0x0001;
const WORD PTP_FILESYSTEMTYPE_HIERARCHICAL  = 0x0002;
const WORD PTP_FILESYSTEMTYPE_DCF           = 0x0003;

//
// functional modes
//
const WORD  PTP_FUNCTIONMODE_STDANDARD  = 0x0000;
const WORD  PTP_FUNCTIONMODE_SLEEP      = 0x0001;

//
// Get/Set
//
const BYTE    PTP_PROPGETSET_GETONLY  = 0x00;
const BYTE    PTP_PROPGETSET_GETSET   = 0x01;

//
// PTP command request
//
const DWORD COMMAND_NUMPARAMS_MAX = 5;
typedef struct tagPTPCommand
{
    WORD    OpCode;         // the opcode
    DWORD   SessionId;      // the session id
    DWORD   TransactionId;  // the transaction id
    DWORD   Params[COMMAND_NUMPARAMS_MAX];  // parameters
}PTP_COMMAND, *PPTP_COMMAND;

//
// PTP response block
//
const DWORD RESPONSE_NUMPARAMS_MAX = 5;
typedef struct tagPTPResponse
{
    WORD    ResponseCode;       // response code
    DWORD   SessionId;          // the session id
    DWORD   TransactionId;      // the transaction id
    DWORD   Params[RESPONSE_NUMPARAMS_MAX];  // parameters
}PTP_RESPONSE, *PPTP_RESPONSE;

//
// PTP event data
//
const DWORD EVENT_NUMPARAMS_MAX = 3;
typedef struct tagPTPEvent
{
    WORD    EventCode;      // the event code
    DWORD   SessionId;      // the session id
    DWORD   TransactionId;  // the transaction id
    DWORD   Params[EVENT_NUMPARAMS_MAX];  // parameters
}PTP_EVENT, *PPTP_EVENT;


#pragma pack(pop, Old)

//
// Raw data parsing utility functions
//
WORD  ParseWord(BYTE **ppRaw);
DWORD ParseDword(BYTE **ppRaw);
QWORD ParseQword(BYTE **ppRaw);

//
// Raw data writing utility functions
//
VOID  WriteWord(BYTE **ppRaw, WORD value);
VOID  WriteDword(BYTE **ppRaw, DWORD value);

//
// Class that holds a BSTR
//
class CBstr
{
public:
    CBstr();
    CBstr(const CBstr& src);
    ~CBstr();

    HRESULT Copy(WCHAR *wcsString);
    HRESULT Init(BYTE **ppRaw, BOOL bParse = FALSE);
    VOID    WriteToBuffer(BYTE **ppRaw);
    VOID    Dump(char *szDesc);

    UINT    Length() { return (m_bstrString == NULL ? 0 : SysStringLen(m_bstrString)); }
    BSTR    String() { return m_bstrString; }

    BSTR    m_bstrString;
};

//
// Array definitions for 8, 16, and 32 bit integers
//
class CArray8 : public CWiaArray<BYTE>
{
public:
    VOID    Dump(char *szDesc, char *szFiller);
};

class CArray16 : public CWiaArray<USHORT>
{
public:
    VOID    Dump(char *szDesc, char *szFiller);
};

class CArray32 : public CWiaArray<ULONG>
{
public:
    BOOL    ParseFrom8(BYTE **ppRaw, int NumSize = 4);
    BOOL    ParseFrom16(BYTE **ppRaw, int NumSize = 4);
    BOOL    Copy(CArray8 values8);
    BOOL    Copy(CArray16 values16);

    VOID    Dump(char *szDesc, char *szFiller);
};

//
// Array of CBstr
//
class CArrayString : public CWiaArray<CBstr>
{
public:
    HRESULT Init(BYTE **ppRaw, int NumSize = 4);
    VOID    Dump(char *szDesc, char *szFiller);
};

//
// Class that holds a PTP DeviceInfo structure
//
class CPtpDeviceInfo
{
public:
    CPtpDeviceInfo();
    CPtpDeviceInfo(const CPtpDeviceInfo &src);
    ~CPtpDeviceInfo();

    HRESULT Init(BYTE *pRawData);
    VOID    Dump();

    BOOL    IsValid() { return m_SupportedOps.GetSize() > 0; }
                                        
    WORD        m_Version;               // version in hundredths
    DWORD       m_VendorExtId;           // PIMA assigned vendor id
    WORD        m_VendorExtVersion;      // vender extention version
    CBstr       m_cbstrVendorExtDesc;    // Optional vender description
    WORD        m_FuncMode;              // current functional mode
    CArray16    m_SupportedOps;          // supported operations
    CArray16    m_SupportedEvents;       // supported events
    CArray16    m_SupportedProps;        // supported properties
    CArray16    m_SupportedCaptureFmts;  // supported capture formats
    CArray16    m_SupportedImageFmts;    // supported image formats
    CBstr       m_cbstrManufacturer;     // optional manufacturer description
    CBstr       m_cbstrModel;            // optional model description
    CBstr       m_cbstrDeviceVersion;    // optional firmware description
    CBstr       m_cbstrSerialNumber;     // optional serial number description
};

//
// Class that holds a PTP StorageInfo structure
//
class CPtpStorageInfo
{
public:
    CPtpStorageInfo();
    ~CPtpStorageInfo();

    HRESULT Init(BYTE *pRawData, DWORD StorageId);
    VOID    Dump();

    DWORD       m_StorageId;             // the "id" for this store
    WORD        m_StorageType;           // storage type
    WORD        m_FileSystemType;        // file system type
    WORD        m_AccessCapability;      // access capability (e.g. read/write)
    QWORD       m_MaxCapacity;           // maximum capacity in bytes
    QWORD       m_FreeSpaceInBytes;      // free space in bytes
    DWORD       m_FreeSpaceInImages;     // free space in images
    CBstr       m_cbstrStorageDesc;      // description
    CBstr       m_cbstrStorageLabel;     // volume label
};

//
// Class that holds a PTP ObjectInfo structure
//
class CPtpObjectInfo
{
public:
    CPtpObjectInfo();
    ~CPtpObjectInfo();

    HRESULT Init(BYTE *pRawData, DWORD ObjectHandle);
    VOID    WriteToBuffer(BYTE **ppRaw);
    VOID    Dump();

    DWORD       m_ObjectHandle;          // the "handle" for this object
    DWORD       m_StorageId;             // The storage the object resides
    WORD        m_FormatCode;            // object format code
    WORD        m_ProtectionStatus;      // object protection status
    DWORD       m_CompressedSize;        // object compressed size
    WORD        m_ThumbFormat;           // thumbnail format(image object only)
    DWORD       m_ThumbCompressedSize;   // thumbnail compressedsize
    DWORD       m_ThumbPixWidth;         // thumbnail width in pixels
    DWORD       m_ThumbPixHeight;        // thumbmail height in pixels
    DWORD       m_ImagePixWidth;         // image width in pixels
    DWORD       m_ImagePixHeight;        // image height in pixels
    DWORD       m_ImageBitDepth;         // image color depth
    DWORD       m_ParentHandle;          // parent objec handle
    WORD        m_AssociationType;       // association type
    DWORD       m_AssociationDesc;       // association description
    DWORD       m_SequenceNumber;        // sequence number
    CBstr       m_cbstrFileName;         // optional file name
    CBstr       m_cbstrExtension;        // file name extension
    CBstr       m_cbstrCaptureDate;      // Captured date
    CBstr       m_cbstrModificationDate; // when it was last modified.
    CBstr       m_cbstrKeywords;         // optional keywords
};

//
// Generic class for holding property information
//
class CPtpPropDesc
{
public:
    CPtpPropDesc();
    ~CPtpPropDesc();

    HRESULT Init(BYTE *pRawData);
    HRESULT ParseValue(BYTE *pRaw);
    VOID    WriteValue(BYTE **ppRaw);
    VOID    Dump();
    VOID    DumpValue();

    WORD    m_PropCode;   // Property code for this property
    WORD    m_DataType;   // Contains the type of the data (2=BYTE, 4=WORD, 6=DWORD, 0xFFFF=String)
    BYTE    m_GetSet;     // Indicates whether the property can be set or not (0=get-only, 1=get-set)
    BYTE    m_FormFlag;   // Indicates the form of the valid values (0=none, 1=range, 2=enum)

    int     m_NumValues;  // Number of values in the enumeration

    //
    // Integer values
    //
    DWORD       m_lDefault;    // Default value
    DWORD       m_lCurrent;    // Current value
    DWORD       m_lRangeMin;   // Minimum value
    DWORD       m_lRangeMax;   // Maximum value
    DWORD       m_lRangeStep;  // Step value
    CArray32    m_lValues;     // Array of values

    //
    // String values
    //
    CBstr           m_cbstrDefault;    // Default value
    CBstr           m_cbstrCurrent;    // Current value
    CBstr           m_cbstrRangeMin;   // Minimum value
    CBstr           m_cbstrRangeMax;   // Maximum value
    CBstr           m_cbstrRangeStep;  // Step value
    CArrayString    m_cbstrValues;     // Array of values
};

#endif      // #ifndef ISO15740__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\camusb.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    camusb.h

Abstract:

    Header file that declares CUsbCamera object

Author:

    William Hsieh (williamh) created

Revision History:

--*/

#ifndef CAMUSB__H_
#define CAMUSB__H_

//
// These are the USB timeout values in seconds
//
const PTP_READ_TIMEOUT = 5;
const PTP_WRITE_TIMEOUT = 5;
const PTP_EVENT_TIMEOUT = 0;
//
// USB Still image device container types
//
const WORD PTPCONTAINER_TYPE_UNDEFINED = 0;
const WORD PTPCONTAINER_TYPE_COMMAND   = 1;
const WORD PTPCONTAINER_TYPE_DATA      = 2;
const WORD PTPCONTAINER_TYPE_RESPONSE  = 3;
const WORD PTPCONTAINER_TYPE_EVENT     = 4;

//
// Used to store info about the endpoints
//
typedef struct _USB_PTP_ENDPOINT_INFO
{
    USHORT BulkInMaxSize;
    UCHAR  BulkInAddress;
    USHORT BulkOutMaxSize;
    UCHAR  BulkOutAddress;
    USHORT InterruptMaxSize;
    UCHAR  InterruptAddress;
} USB_PTP_ENDPOINT_INFO, *PUSB_PTP_ENDPOINT_INFO;


#pragma pack(push, Old, 1)


//
// When a USB device stalls, the usb kernel mode stack driver returns
// a NTSTATUS code, STATUS_DEVICE_DATA_ERROR. Translates this NT status
// code to WIN32 error code, we get ERROR_CRC.
//
const DWORD WIN32ERROR_USBSTALL = ERROR_CRC;

//
// Container header
//
typedef struct _USB_PTP_HEADER
{
    DWORD   Len;            // total length of container in bytes including header
    WORD    Type;           // container type, one of CONTAINER_TYPE_COMMAND/RESPONSE/DATA/EVENT
    WORD    Code;           // opcode, response code, or event code
    DWORD   TransactionId;  // transaction id

}USB_PTP_HEADER, *PUSB_PTP_HEADER;

//
// USB PTP command structure
//
typedef struct _USB_PTP_COMMAND
{
    USB_PTP_HEADER  Header;
    DWORD           Params[COMMAND_NUMPARAMS_MAX];

}USB_PTP_COMMAND, *PUSB_PTP_COMMAND;

//
// USB PTP response structure
//
typedef struct _USB_PTP_RESPONSE
{
    USB_PTP_HEADER  Header;
    DWORD           Params[RESPONSE_NUMPARAMS_MAX];
}USB_PTP_RESPONSE, *PUSB_PTP_RESPONSE;

//
// USB PTP event structure
//
typedef struct _USB_PTP_EVENT
{
    USB_PTP_HEADER  Header;
    DWORD           Params[EVENT_NUMPARAMS_MAX];

}USB_PTP_EVENT, *PUSB_PTP_EVENT;

//
// USB PTP data structure
//
typedef struct _USB_PTP_DATA
{
    USB_PTP_HEADER  Header;
    BYTE            Data[1];

}USB_PTP_DATA, *PUSB_PTP_DATA;

//
// GetDeviceStatus header
//
typedef struct tagUSBPTPDeviceStatusHeader
{
    WORD  Len;                        // status
    WORD  Code;                       // ptp response code

}USB_PTPDEVICESTATUS_HEADER, *PUSB_PTPDEVICESTATUS_HEADER;

//
// GetDeviceStatus data
//
typedef struct  tagUSBPTPDeviceStatus
{
    USB_PTPDEVICESTATUS_HEADER  Header;      // the header
    DWORD                       Params[MAX_NUM_PIPES];
}USB_PTPDEVICESTATUS, *PUSB_PTPDEVICESTATUS;

const BYTE USB_PTPREQUEST_TYPE_OUT  = 0x21;
const BYTE USB_PTPREQUEST_TYPE_IN   = 0xA1;
const BYTE USB_PTPREQUEST_CANCELIO  = 0x64;
const BYTE USB_PTPREQUEST_GETEVENT  = 0x65;
const BYTE USB_PTPREQUEST_RESET     = 0x66;
const BYTE USB_PTPREQUEST_GETSTATUS = 0x67;

const WORD USB_PTPCANCELIO_ID = 0x4001;

//
// Other USB Imaging Class-specific commands
//
typedef struct tagUSBPTPCancelIoRequest
{
    WORD    Id;
    DWORD   TransactionId;

}USB_PTPCANCELIOREQUEST, *PUSB_PTPCANCELIOREQUEST;

typedef struct tagUSBPTPResetRequest
{
    DWORD   TransactionId;

}USB_PTPRESETREQUEST, *PUSB_PTPRESETREQUEST;

typedef struct tagUSBPTPGetEventRequest
{
    WORD    EventCode;
    DWORD   TransactionId;
    DWORD   Params;

}USB_PTPGETEVENTREQUEST, *PUSB_PTPGETEVENTREQUEST;


#pragma pack(pop, Old)


//
// A CPTPCamera derived class to support PTP USB devices
//
class CUsbCamera : public CPTPCamera
{
public:
    CUsbCamera();
    ~CUsbCamera();

private:
    HRESULT Open(LPWSTR DevicePortName, PTPEventCallback pPTPEventCB,
                 PTPDataCallback pPTPDataCB, LPVOID pEventParam, BOOL bEnableEvents = TRUE);
    HRESULT Close();

    //
    // Functions called by the base class
    //
    HRESULT SendCommand(PTP_COMMAND *pCommand, UINT NumParams);
    HRESULT ReadData(BYTE *pData, UINT *pBufferSize);
    HRESULT SendData(BYTE *pData, UINT BufferSize);
    HRESULT ReadResponse(PTP_RESPONSE *pResponse);
    HRESULT ReadEvent(PTP_EVENT *pEvent);
    HRESULT AbortTransfer();
    HRESULT RecoverFromError();

private:
    //
    // Private utility functions
    //
    HRESULT GetDeviceStatus(USB_PTPDEVICESTATUS *pDeviceStatus);
    HRESULT ClearStalls(USB_PTPDEVICESTATUS *pDeviceStatus);
    HRESULT SendResetDevice();
    HRESULT SendCancelRequest(DWORD dwTransactionId);    
    
    //
    // Member variables
    //
    HANDLE                  m_hUSB;             // File handle used to communicate with USB device
    HANDLE                  m_hEventUSB;        // File handle used to read events
    OVERLAPPED              m_Overlapped;       // Overlapped structure for event reads
    HANDLE                  m_hEventRead;       // Event handle used by event read
    HANDLE                  m_hEventCancel;     // Event handle used to cancel interrupt read
    HANDLE                  m_EventHandles[2];  // Array used by WaitForMultipleObjects

    USB_PTP_ENDPOINT_INFO   m_EndpointInfo;     // Info about the endpoints

    USB_PTP_COMMAND         m_UsbCommand;       // Re-usable buffer for commands
    USB_PTP_RESPONSE        m_UsbResponse;      // Re-usable buffer for responses
    USB_PTP_DATA           *m_pUsbData;         // Pointer to re-usable buffer for short data transfers
    UINT                    m_UsbDataSize;      // Size allocated for the data transfer buffer

    WORD                    m_prevOpCode;       // Used to store opcode between command and data phases
    DWORD                   m_prevTranId;       // Used to store transaction id between command and data phases
};

#endif  // #ifndef CAMUSB__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\sources.inc ===
#############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   DavePar
#
#Date:
#   20-Jul-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     ISO/PIMA 15740 Picture Transfer Protocol driver
#
#############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=ptpusb
TARGETTYPE=LIBRARY
TARGETPATH=$(OBJ_DIR)

#DLLDEF=..\ptpusb.def
#DLLENTRY=_DllMainCRTStartup

USE_MSVCRT = 1

INCLUDES= \
        $(DDK_INC_PATH);        \
        ..\..\..\..\inc;        \
        $(SDK_INC_PATH)\atl30;  \
        $(INCLUDES);

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\ptppch.h
PRECOMPILED_OBJ = ptppch.obj

SOURCES=                \
        ..\iso15740.cpp \
        ..\camera.cpp   \
        ..\camusb.cpp   \
        ..\ptputil.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\devitem.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    devitem.cpp

Abstract:

    This module implements device related function of CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

#include <atlbase.h>
#include <atlconv.h>

//
// Locations for holding resource strings
//
extern WCHAR UnknownString[];
extern WCHAR FolderString[];
extern WCHAR ScriptString[];
extern WCHAR ExecString[];
extern WCHAR TextString[];
extern WCHAR HtmlString[];
extern WCHAR DpofString[];
extern WCHAR AudioString[];
extern WCHAR VideoString[];
extern WCHAR UnknownImgString[];
extern WCHAR ImageString[];
extern WCHAR AlbumString[];
extern WCHAR BurstString[];
extern WCHAR PanoramaString[];


//
// Mapping of non-image PTP formats to format info structures. Index is the
// lower 16 bits of the format code. The fields going across are WIA format GUID,
// string, and item type.
// Note: For associations, these fields depend on the type (e.g. burst, panorama)
//

FORMAT_INFO g_NonImageFormatInfo[] =
{
    { (GUID *)&WiaImgFmt_UNDEFINED, UnknownString,   ITEMTYPE_FILE,   L""    },  // Undefined                
    { NULL,                         FolderString,    ITEMTYPE_FOLDER, L""    },  // Association
    { (GUID *)&WiaImgFmt_SCRIPT,    ScriptString,    ITEMTYPE_FILE,   L""    },  // Script                   
    { (GUID *)&WiaImgFmt_EXEC,      ExecString,      ITEMTYPE_FILE,   L"EXE" },  // Executable               
    { (GUID *)&WiaImgFmt_UNICODE16, TextString,      ITEMTYPE_FILE,   L"TXT" },  // Text                     
    { (GUID *)&WiaImgFmt_HTML,      HtmlString,      ITEMTYPE_FILE,   L"HTM" },  // HTML                     
    { (GUID *)&WiaImgFmt_DPOF,      DpofString,      ITEMTYPE_FILE,   L""    },  // DPOF                     
    { (GUID *)&WiaAudFmt_AIFF,      AudioString,     ITEMTYPE_AUDIO,  L"AIF" },  // AIFF                     
    { (GUID *)&WiaAudFmt_WAV,       AudioString,     ITEMTYPE_AUDIO,  L"WAV" },  // WAV                      
    { (GUID *)&WiaAudFmt_MP3,       AudioString,     ITEMTYPE_AUDIO,  L"MP3" },  // MP3                      
    { (GUID *)&WiaImgFmt_AVI,       VideoString,     ITEMTYPE_VIDEO,  L"AVI" },  // AVI                      
    { (GUID *)&WiaImgFmt_MPG,       VideoString,     ITEMTYPE_VIDEO,  L"MPG" },  // MPEG                     
    { (GUID *)&WiaImgFmt_ASF,       VideoString,     ITEMTYPE_VIDEO,  L"ASF" }   // ASF
};
const UINT g_NumNonImageFormatInfo = sizeof(g_NonImageFormatInfo) / sizeof(g_NonImageFormatInfo[0]);

//
// Mapping of image PTP formats to format info structures.  Index is the
// lower 16 bits of the format code.
//
FORMAT_INFO g_ImageFormatInfo[] =
{
    { NULL,                        UnknownImgString, ITEMTYPE_IMAGE,  L""    },  // Undefined image
    { (GUID *)&WiaImgFmt_JPEG,     ImageString,      ITEMTYPE_IMAGE,  L"JPG" },  // EXIF/JPEG
    { (GUID *)&WiaImgFmt_TIFF,     ImageString,      ITEMTYPE_IMAGE,  L"TIF" },  // TIFF/EP
    { (GUID *)&WiaImgFmt_FLASHPIX, ImageString,      ITEMTYPE_IMAGE,  L"FPX" },  // FlashPix
    { (GUID *)&WiaImgFmt_BMP,      ImageString,      ITEMTYPE_IMAGE,  L"BMP" },  // BMP
    { (GUID *)&WiaImgFmt_CIFF,     ImageString,      ITEMTYPE_IMAGE,  L"TIF" },  // CIFF
    { NULL,                        UnknownString,    ITEMTYPE_IMAGE,  L""    },  // Undefined (Reserved)
    { (GUID *)&WiaImgFmt_GIF,      ImageString,      ITEMTYPE_IMAGE,  L"GIF" },  // GIF
    { (GUID *)&WiaImgFmt_JPEG,     ImageString,      ITEMTYPE_IMAGE,  L"JPG" },  // JFIF
    { (GUID *)&WiaImgFmt_PHOTOCD,  ImageString,      ITEMTYPE_IMAGE,  L"PCD" },  // PCD (PhotoCD Image Pac)
    { (GUID *)&WiaImgFmt_PICT,     ImageString,      ITEMTYPE_IMAGE,  L""    },  // PICT
    { (GUID *)&WiaImgFmt_PNG,      ImageString,      ITEMTYPE_IMAGE,  L"PNG" },  // PNG
    { NULL,                        UnknownString,    ITEMTYPE_IMAGE,  L""    },  // Undefined (Reserved)
    { (GUID *)&WiaImgFmt_TIFF,     ImageString,      ITEMTYPE_IMAGE,  L"TIF" },  // TIFF
    { (GUID *)&WiaImgFmt_TIFF,     ImageString,      ITEMTYPE_IMAGE,  L"TIF" },  // TIFF/IT
    { (GUID *)&WiaImgFmt_JPEG2K,   ImageString,      ITEMTYPE_IMAGE,  L""    },  // JPEG2000 Baseline
    { (GUID *)&WiaImgFmt_JPEG2KX,  ImageString,      ITEMTYPE_IMAGE,  L""    }   // JPEG2000 Extended
};
const UINT g_NumImageFormatInfo = sizeof(g_ImageFormatInfo) / sizeof(g_ImageFormatInfo[0]);

//
// Mapping of association types to format info structures.
//
FORMAT_INFO g_AssocFormatInfo[] =
{
    { NULL,                         UnknownString,   ITEMTYPE_FOLDER },  // Undefined
    { NULL,                         FolderString,    ITEMTYPE_FOLDER },  // Generic folder
    { NULL,                         AlbumString,     ITEMTYPE_FOLDER },  // Album
    { NULL,                         BurstString,     ITEMTYPE_BURST  },  // Time burst
    { NULL,                         PanoramaString,  ITEMTYPE_HPAN   },  // Horizontal panorama
    { NULL,                         PanoramaString,  ITEMTYPE_VPAN   },  // Vertical panorama
    { NULL,                         PanoramaString,  ITEMTYPE_FOLDER },  // 2D panorama
    { NULL,                         FolderString,    ITEMTYPE_FOLDER }   // Ancillary data
};
const UINT g_NumAssocFormatInfo = sizeof(g_AssocFormatInfo) / sizeof(g_AssocFormatInfo[0]);

//
// Mapping of property codes to property info structures. Index is the lower 12 bites of the
// prop code. The fields going across are WIA property ID, and WIA property string.
//
PROP_INFO g_PropInfo[] =
{
    { 0,                                NULL                                },  // Undefined property code
    { WIA_DPC_BATTERY_STATUS,           WIA_DPC_BATTERY_STATUS_STR          },
    { 0,                                NULL                                },  // Functional mode, not used
    { 0,                                NULL                                },  // Image capture dimensions (needs special processing)
    { WIA_DPC_COMPRESSION_SETTING,      WIA_DPC_COMPRESSION_SETTING_STR     },
    { WIA_DPC_WHITE_BALANCE,            WIA_DPC_WHITE_BALANCE_STR           },
    { WIA_DPC_RGB_GAIN,                 WIA_DPC_RGB_GAIN_STR                },
    { WIA_DPC_FNUMBER,                  WIA_DPC_FNUMBER_STR                 },
    { WIA_DPC_FOCAL_LENGTH,             WIA_DPC_FOCAL_LENGTH_STR            },
    { WIA_DPC_FOCUS_DISTANCE,           WIA_DPC_FOCUS_DISTANCE_STR          },
    { WIA_DPC_FOCUS_MODE,               WIA_DPC_FOCUS_MODE_STR              },
    { WIA_DPC_EXPOSURE_METERING_MODE,   WIA_DPC_EXPOSURE_METERING_MODE_STR  },
    { WIA_DPC_FLASH_MODE,               WIA_DPC_FLASH_MODE_STR              },
    { WIA_DPC_EXPOSURE_TIME,            WIA_DPC_EXPOSURE_TIME_STR           },
    { WIA_DPC_EXPOSURE_MODE,            WIA_DPC_EXPOSURE_MODE_STR           },
    { WIA_DPC_EXPOSURE_INDEX,           WIA_DPC_EXPOSURE_INDEX_STR          },
    { WIA_DPC_EXPOSURE_COMP,            WIA_DPC_EXPOSURE_COMP_STR           },
    { WIA_DPA_DEVICE_TIME,              WIA_DPA_DEVICE_TIME_STR             },
    { WIA_DPC_CAPTURE_DELAY,            WIA_DPC_CAPTURE_DELAY_STR           },
    { WIA_DPC_CAPTURE_MODE,             WIA_DPC_CAPTURE_MODE_STR            },
    { WIA_DPC_CONTRAST,                 WIA_DPC_CONTRAST_STR                },
    { WIA_DPC_SHARPNESS,                WIA_DPC_SHARPNESS_STR               },
    { WIA_DPC_DIGITAL_ZOOM,             WIA_DPC_DIGITAL_ZOOM_STR            },
    { WIA_DPC_EFFECT_MODE,              WIA_DPC_EFFECT_MODE_STR             },
    { WIA_DPC_BURST_NUMBER,             WIA_DPC_BURST_NUMBER_STR            },
    { WIA_DPC_BURST_INTERVAL,           WIA_DPC_BURST_INTERVAL_STR          },
    { WIA_DPC_TIMELAPSE_NUMBER,         WIA_DPC_TIMELAPSE_NUMBER_STR        },
    { WIA_DPC_TIMELAPSE_INTERVAL,       WIA_DPC_TIMELAPSE_INTERVAL_STR      },
    { WIA_DPC_FOCUS_METERING_MODE,      WIA_DPC_FOCUS_METERING_MODE_STR     },
    { WIA_DPC_UPLOAD_URL,               WIA_DPC_UPLOAD_URL_STR              },
    { WIA_DPC_ARTIST,                   WIA_DPC_ARTIST_STR                  },
    { WIA_DPC_COPYRIGHT_INFO,           WIA_DPC_COPYRIGHT_INFO_STR          }
};
    
const UINT g_NumPropInfo = sizeof(g_PropInfo) / sizeof(g_PropInfo[0]);

//
// Helper function - returns number of logical storages (those which have 
// StorageId & PTP_STORAGEID_LOGICAL > 0)
//
int CWiaMiniDriver::NumLogicalStorages()
{
    DBG_FN("CWiaMiniDriver::NumLogicalStorages");

    int nResult = 0;
    for (int i = 0; i < m_StorageIds.GetSize(); i++)
    {
        if (m_StorageIds[i] & PTP_STORAGEID_LOGICAL)
        {
            nResult++;
        }
    }
    return nResult;
}

//
// This function creates the driver item tree
//
// Input:
//   RootItemFullName -- the root item full name
//   ppRoot -- to receive the root driver item
//
HRESULT
CWiaMiniDriver::CreateDrvItemTree(IWiaDrvItem **ppRoot)
{
    DBG_FN("CWiaMiniDriver::CreateDrvItemTree");
    
    HRESULT hr = S_OK;

    DRVITEM_CONTEXT *pDrvItemContext;

    if (!ppRoot)
    {
        wiauDbgError("CreateDrvItemTree", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Create the root item name
    //
    BSTR bstrRoot = SysAllocString(L"Root");
    if (!bstrRoot)
    {
        wiauDbgError("CreateDrvItemTree", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Create the root item.
    //
    *ppRoot = NULL;
    pDrvItemContext = NULL;
    hr = wiasCreateDrvItem(WiaItemTypeDevice | WiaItemTypeRoot | WiaItemTypeFolder,
                           bstrRoot,
                           m_bstrRootItemFullName,
                           (IWiaMiniDrv *)this,
                           sizeof(DRVITEM_CONTEXT),
                           (BYTE **) &pDrvItemContext,
                           ppRoot
                          );

    SysFreeString(bstrRoot);

    if (FAILED(hr) || !*ppRoot || !pDrvItemContext)
    {
        wiauDbgError("CreateDrvItemTree", "wiasCreateDrvItem failed");
        return hr;
    }
    
    pDrvItemContext->pObjectInfo = NULL;
    pDrvItemContext->NumFormatInfos = 0;
    pDrvItemContext->pFormatInfos = NULL;

    pDrvItemContext->ThumbSize = 0;
    pDrvItemContext->pThumb = NULL;
    
    //
    // Clear the handle/driver item mapping (it might be non-empty if camera was reset, see bug #685926)
    //
    m_HandleItem.RemoveAll();

    //
    // Add an entry in the object handle/driver item association mapping for the root
    //
    if (!m_HandleItem.Add(0, *ppRoot))
    {
        wiauDbgError("CreateDrvItemTree", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Now create all the other items by looping through the list of all of the object
    // handles on the device
    //
    CArray32 ObjectHandleList;

    if (NumLogicalStorages() > 0)
    {
        hr = m_pPTPCamera->GetObjectHandles(PTP_STORAGEID_ALL, PTP_FORMATCODE_ALL, PTP_OBJECTHANDLE_ALL,
                                            &ObjectHandleList);
        if (FAILED(hr))
        {
            wiauDbgError("CreateDrvItemTree", "GetObjectHandles failed");
            return hr;
        }
    }

    //
    // In order to fill drv items tree correctly, get information for all objects, and add them
    // in order of depth (closest to the root first)
    //
    CWiaMap<DWORD, CPtpObjectInfo*> HandleToInfoMap;
    UINT nItems = ObjectHandleList.GetSize();
    
    CPtpObjectInfo *ObjectInfoList = new CPtpObjectInfo[nItems];
    BYTE *DepthList = new BYTE[nItems];
    if (ObjectInfoList == NULL || DepthList == NULL)
    {
        wiauDbgError("CreateDrvItemTree", "memory allocation failed");
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    //
    // Get the ObjectInfo for all objects
    //
    for (UINT i = 0; i < nItems; i++)
    {
        hr = m_pPTPCamera->GetObjectInfo(ObjectHandleList[i], &ObjectInfoList[i]);
        if (FAILED(hr))
        {
            wiauDbgError("CreateDrvItemTree", "GetObjectInfo failed");
            goto cleanup;
        }

        if (!HandleToInfoMap.Add(ObjectHandleList[i], &ObjectInfoList[i]))
        {
            wiauDbgError("CreateDrvItemTree", "failed to item to Handle-ObjectInfo map");
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    //
    // Find depth of every object
    //
    for (i = 0; i < nItems; i++)
    {
        DepthList[i] = 0;
        DWORD CurHandle = ObjectHandleList[i];
        while (CurHandle = HandleToInfoMap.Lookup(CurHandle)->m_ParentHandle)
        {
            DepthList[i]++;
        }
    }

    //
    // Add objects in order of depth (closest to the root first)
    //
    UINT nItemsAdded = 0;
    UINT CurDepth = 0;
    while (nItemsAdded < nItems)
    {
        for (i = 0; i < nItems; i++)
        {
            if (DepthList[i] == CurDepth)
            {
                hr = AddObject(ObjectHandleList[i], FALSE, &ObjectInfoList[i]); 
                if (FAILED(hr))
                {
                    wiauDbgError("CreateDrvItemTree", "AddObject failed");
                    goto cleanup;
                }
                nItemsAdded++;
            }
        }
        CurDepth++;
    }

cleanup:
    if (ObjectInfoList)
    {
        delete[] ObjectInfoList;
    }

    if (DepthList)
    {
        delete[] DepthList;
    }

    return hr;
}

//
// This function adds an object to the driver item tree
//
// Input:
//   ObjectHandle -- PTP handle for the object
//   bQueueEvent -- TRUE if WIA event should be queued
//   pObjectInfo -- optional ObjectInfo for this object. If NULL, info will be queried from camera
//
HRESULT
CWiaMiniDriver::AddObject(
    DWORD ObjectHandle,
    BOOL bQueueEvent,
    CPtpObjectInfo *pProvidedObjectInfo
    )
{
    USES_CONVERSION;
    
    DBG_FN("CWiaMiniDriver::AddObject");

    HRESULT hr = S_OK;
    CPtpObjectInfo *pObjectInfo = NULL;
    BSTR bstrItemFullName = NULL;
    BSTR bstrParentName = NULL;
    IWiaDrvItem *pItem = NULL;
    
    //
    // flag to indicate if pObjecInfo pointer has been copied to WiaDrvItem
    // if TRUE, it should not be deleted in Cleanup
    //
    BOOL fObjectInfoUsed = FALSE; 

    //
    // Get the ObjectInfo from camera or use provided info if it's given
    //
    if (pProvidedObjectInfo == NULL)
    {
        pObjectInfo = new CPtpObjectInfo;
        if (!pObjectInfo)
        {
            wiauDbgError("AddObject", "memory allocation failed");
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = m_pPTPCamera->GetObjectInfo(ObjectHandle, pObjectInfo);
        if (FAILED(hr))
        {
            wiauDbgError("AddObject", "GetObjectInfo failed");
            goto Cleanup;
        }
    }
    else
    {
        pObjectInfo = new CPtpObjectInfo(*pProvidedObjectInfo); // default copying constructor
        if (!pObjectInfo)
        {
            wiauDbgError("AddObject", "memory allocation failed");
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }        
    }

    int storeIdx = m_StorageIds.Find(pObjectInfo->m_StorageId);

    //
    // Look for objects to hide if this is a DCF store
    //
    if (m_StorageInfos[storeIdx].m_FileSystemType == PTP_FILESYSTEMTYPE_DCF)
    {
        BOOL bHideObject = FALSE;
        
        //
        // If the DCIM folder has been identified and this is a folder under DCIM, hide it
        //
        if (m_DcimHandle[storeIdx])
        {
            if (pObjectInfo->m_ParentHandle == m_DcimHandle[storeIdx])
                bHideObject = TRUE;
        }

        //
        // Otherwise see if this is the DCIM folder
        //
        else if (wcscmp(pObjectInfo->m_cbstrFileName.String(), L"DCIM") == 0)
        {
            bHideObject = TRUE;
            m_DcimHandle[storeIdx] = ObjectHandle;
        }

        if (bHideObject)
        {
            //
            // Create a dummy entry in the handle/item map so that objects under this
            // folder will be put under the root
            //
            if (!m_HandleItem.Add(ObjectHandle, m_pDrvItemRoot))
            {
                wiauDbgError("AddObject", "add handle item failed");
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            wiauDbgTrace("AddObject", "hiding DCIM folder 0x%08x", ObjectHandle);
            hr = S_OK;
            goto Cleanup;
        }
    }

    //
    // If this is an "ancillary data" association, don't create an item but put the handle
    // in the ancillary association array
    //
    if (pObjectInfo->m_AssociationType == PTP_ASSOCIATIONTYPE_ANCILLARYDATA)
    {
        if (!m_AncAssocParent.Add(ObjectHandle, m_HandleItem.Lookup(pObjectInfo->m_ParentHandle)))
        {
            wiauDbgError("AddObject", "add ancillary assoc handle failed");
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = S_OK;
        goto Cleanup;        
    }

    //
    // Keep count of the number of images
    //
    UINT16 FormatCode = pObjectInfo->m_FormatCode;
    if (FormatCode & PTP_FORMATMASK_IMAGE)
    {
        m_NumImages++;

        //
        // Also make sure that the bit depth is non-zero.
        //
        if (pObjectInfo->m_ImageBitDepth == 0) {
            switch(pObjectInfo->m_FormatCode) {
                case PTP_FORMATCODE_IMAGE_GIF:
                    pObjectInfo->m_ImageBitDepth = 8;
                    break;
                default:
                    pObjectInfo->m_ImageBitDepth = 24;
            }
        }
    }

    //
    // Update Storage Info (we are especially interested in Free Space info)
    //
    hr  = UpdateStorageInfo(pObjectInfo->m_StorageId);
    if (FAILED(hr))
    {
        wiauDbgError("AddObject", "UpdateStorageInfo failed");
        // we can proceed, even if storage info can't be updated
        hr = S_OK;
    }

    //
    // For images, check to see if the parent is an ancillary association
    //
    IWiaDrvItem *pParent = NULL;
    LONG ExtraItemFlags = 0;
    int ancIdx = m_AncAssocParent.FindKey(pObjectInfo->m_ParentHandle);
    if ((FormatCode & PTP_FORMATMASK_IMAGE) &&
        (ancIdx >= 0))
    {
        ExtraItemFlags |= WiaItemTypeHasAttachments;
        pParent = m_AncAssocParent.GetValueAt(ancIdx);
    }

    //
    // For normal images, just look up the parent item in the map
    //
    else
    {
        pParent = m_HandleItem.Lookup(pObjectInfo->m_ParentHandle);
    }

    //
    // If a parent wasn't found, just use the root as the parent
    //
    if (!pParent)
    {
        pParent = m_pDrvItemRoot;
    }

    //
    // Look up info about the object's format
    //
    FORMAT_INFO *pFormatInfo = FormatCodeToFormatInfo(FormatCode, pObjectInfo->m_AssociationType);
    
    //
    // Get the item's name, generating it if necessary
    //
    CBstr *pFileName = &(pObjectInfo->m_cbstrFileName);
    TCHAR tcsName[MAX_PATH];
    TCHAR *ptcsDot;

    if (pFileName->Length() == 0)
    {
        hr = StringCchPrintf(tcsName, ARRAYSIZE(tcsName), W2T(pFormatInfo->FormatString), ObjectHandle);
        if (FAILED(hr))
        {
            wiauDbgErrorHr(hr, "AddObject", "StringCchPrintf failed");
            goto Cleanup;
        }

        hr = pFileName->Copy(T2W(tcsName));
        if (FAILED(hr))
        {
            wiauDbgError("AddObject", "CBstr::Copy failed");
            goto Cleanup;
        }
    }

    //
    // For images Chop off the filename extension, if it exists 
    //
    WCHAR *pDot = wcsrchr(pFileName->String(), L'.');
    if (pDot)
    {
        // Copy extension first
        hr = pObjectInfo->m_cbstrExtension.Copy(pDot + 1);
        if (FAILED(hr))
        {
            wiauDbgError("AddObject", "copy string failed");
            goto Cleanup;
        }

        // then remove the extension from the item name 
        hr = StringCchCopy(tcsName, ARRAYSIZE(tcsName), W2T(pFileName->String()));
        if (FAILED(hr))
        {
            wiauDbgErrorHr(hr, "AddObject", "StringCchCopy failed");
            goto Cleanup;
        }

        ptcsDot = _tcsrchr(tcsName, TEXT('.'));
        *ptcsDot = TEXT('\0');
        
        hr = pFileName->Copy(T2W(tcsName));
        if (FAILED(hr))
        {
            wiauDbgError("AddObject", "copy string failed");
            goto Cleanup;
        }

    }

    if(pObjectInfo->m_cbstrExtension.Length()) {
        // this is special-case handling of .MOV files for which we
        // don't have GUID, but which need to be treated as video
        // elsewhere
        if(_wcsicmp(pObjectInfo->m_cbstrExtension.String(), L"MOV") == 0) {
            pFormatInfo->ItemType = ITEMTYPE_VIDEO;
        }
    }

    //
    // Create the item's full name
    //
    hr = pParent->GetFullItemName(&bstrParentName);
    if (FAILED(hr))
    {
        wiauDbgError("AddObject", "GetFullItemName failed");
        goto Cleanup;
    }

    hr = StringCchPrintf(tcsName, ARRAYSIZE(tcsName), TEXT("%s\\%s"), W2T(bstrParentName), W2T(pFileName->String()));
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "AddObject", "StringCchPrintf failed");
        goto Cleanup;
    }

    bstrItemFullName = SysAllocString(T2W(tcsName));
    if (!bstrItemFullName)
    {
        wiauDbgError("AddObject", "memory allocation failed");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Create the driver item
    //
    DRVITEM_CONTEXT *pDrvItemContext = NULL;
    hr = wiasCreateDrvItem(pFormatInfo->ItemType | ExtraItemFlags,
                           pFileName->String(),
                           bstrItemFullName,
                           (IWiaMiniDrv *)this,
                           sizeof(DRVITEM_CONTEXT),
                           (BYTE **) &pDrvItemContext,
                           &pItem);

    if (FAILED(hr) || !pItem || !pDrvItemContext)
    {
        wiauDbgError("AddObject", "wiasCreateDriverItem failed");
        goto Cleanup;
    }

    //
    // Fill in the driver item context. Wait until the thumbnail is requested before
    // reading it in.
    //
    pDrvItemContext->pObjectInfo = pObjectInfo;
    fObjectInfoUsed = TRUE; // indicate that pObjectInfo pointer has been copied and should not be freed
    pDrvItemContext->NumFormatInfos = 0;
    pDrvItemContext->pFormatInfos = NULL;

    pDrvItemContext->ThumbSize = 0;
    pDrvItemContext->pThumb = NULL;

    //
    // Place the new item under it's parent
    //
    hr = pItem->AddItemToFolder(pParent);
    if (FAILED(hr))
    {
        wiauDbgError("AddObject", "AddItemToFolder failed");
        pItem->Release();
        pItem = NULL;
        fObjectInfoUsed = FALSE;
        goto Cleanup;
    }

    //
    // Add the object handle/driver item association to the list
    //
    if (!m_HandleItem.Add(ObjectHandle, pItem))
    {
        wiauDbgError("AddObject", "memory allocation failed");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // If this image is replacing an ancillary association folder, put another entry
    // in the object handle/item map for that folder
    //
    if (ancIdx >= 0)
    {
        if (!m_HandleItem.Add(pObjectInfo->m_ParentHandle, pItem))
        {
            wiauDbgError("AddObject", "memory allocation failed");
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    //
    // Post an item added event, if requested
    //
    if (bQueueEvent)
    {
        hr = wiasQueueEvent(m_bstrDeviceId, &WIA_EVENT_ITEM_CREATED, bstrItemFullName);
        if (FAILED(hr))
        {
            wiauDbgError("AddObject", "wiasQueueEvent failed");
            goto Cleanup;
        }
    }

Cleanup:
    //
    // Delete pObjectInfo only if the pointer was not copied to WiaDrvItem
    //
    if (pObjectInfo && !fObjectInfoUsed)
    {
        delete pObjectInfo;
        pObjectInfo = NULL;
    }
        
    if (bstrParentName)
    {
        SysFreeString(bstrParentName);
        bstrParentName = NULL;
    }

    if (bstrItemFullName)
    {
        SysFreeString(bstrItemFullName);
        bstrItemFullName = NULL;
    }
    return hr;
}

//
// This function initializes device properties
//
// Input:
//   pWiasContext    -- wias context
//
HRESULT
CWiaMiniDriver::InitDeviceProperties(BYTE *pWiasContext)
{
    DBG_FN("CWiaMiniDriver::InitDeviceProperties");
    
    HRESULT hr = S_OK;

    const INT NUM_ROOT_PROPS = 12;

    //
    // Define things here that need to live until SendToWia() is called
    //
    CArray32 widthList, heightList;     // Used by code that split image width and height
    SYSTEMTIME SystemTime;              // Used for device time
    int NumFormats = 0;                 // Used by format setting code
    LPGUID *pFormatGuids = NULL;        // Used by format setting code
    FORMAT_INFO *pFormatInfo = NULL;    // Used by format setting code
    int FormatCount = 0;                // Used by format setting code

    //
    // Create the property list for the device
    //
    CWiauPropertyList RootProps;
    CArray16 *pSupportedProps = &m_DeviceInfo.m_SupportedProps;

    hr = RootProps.Init(pSupportedProps->GetSize() + NUM_ROOT_PROPS);
    if (FAILED(hr))
    {
        wiauDbgError("InitDeviceProperties", "Init failed");
        return hr;
    }

    INT index;
    int count;

    //
    // WIA_IPA_ACCESS_RIGHTS
    //
    hr = RootProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                             WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, (LONG) WIA_ITEM_READ|WIA_ITEM_WRITE);

    //
    // WIA_DPA_FIRMWARE_VERSION
    //
    hr = RootProps.DefineProperty(&index, WIA_DPA_FIRMWARE_VERSION, WIA_DPA_FIRMWARE_VERSION_STR,
                             WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_DeviceInfo.m_cbstrDeviceVersion.String());

    //
    // WIA_DPC_PICTURES_TAKEN
    //
    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_TAKEN, WIA_DPC_PICTURES_TAKEN_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, m_NumImages);

    //
    // WIA_DPC_PICTURES_REMAINING
    //
    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_REMAINING, WIA_DPC_PICTURES_REMAINING_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    RootProps.SetCurrentValue(index, GetTotalFreeImageSpace());

    //
    // WIA_IPA_FORMAT -- Translate from the CaptureFormats field of DeviceInfo
    //
    hr = RootProps.DefineProperty(&index, WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;

    NumFormats = m_DeviceInfo.m_SupportedCaptureFmts.GetSize();
    pFormatGuids = new LPGUID[NumFormats];
    FormatCount = 0;

    if (!pFormatGuids)
    {
        wiauDbgError("InitDeviceProperties", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    for (count = 0; count < NumFormats; count++)
    {
        pFormatInfo = FormatCodeToFormatInfo(m_DeviceInfo.m_SupportedCaptureFmts[count]);
        if (pFormatInfo->FormatGuid != NULL)
            pFormatGuids[FormatCount++] = pFormatInfo->FormatGuid;
    }

    //
    // Kodak DC4800 needs to have WIA_IPA_FORMAT set to JPEG. This hack can be removed
    // only if support of DC4800 is removed
    //
    if (m_pPTPCamera && m_pPTPCamera->GetHackModel() == HACK_MODEL_DC4800)
    {
        RootProps.SetCurrentValue(index, (CLSID *) &WiaImgFmt_JPEG);
    }

    else if (FormatCount == 1)
    {
        RootProps.SetCurrentValue(index, pFormatGuids[0]);
    }

    else if (FormatCount > 1)
    {
        RootProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_NONE);
        RootProps.SetValidValues(index, pFormatGuids[0], pFormatGuids[0], FormatCount, pFormatGuids);
    }

    else
        wiauDbgWarning("InitDeviceProperties", "Device has no valid formats");

    delete []pFormatGuids;

    //
    // Loop through PTP property description structures, translating them to WIA properties
    //
    PPROP_INFO pPropInfo;
    ULONG Access;
    ULONG SubType;

    for (count = 0; count < m_PropDescs.GetSize(); count++)
    {
        CPtpPropDesc *pCurrentPD = &m_PropDescs[count];
        WORD PropCode = pCurrentPD->m_PropCode;

        //
        // Set the property access and subtype
        //
        if (pCurrentPD->m_GetSet == PTP_PROPGETSET_GETSET)
        {
            Access = WIA_PROP_RW;

            if (pCurrentPD->m_FormFlag == PTP_FORMFLAGS_NONE)
            {
                //
                // If property is writeable and valid values are not a list or a range, set subtype to 
                // WIA_PROP_NONE now
                //
                SubType = WIA_PROP_NONE;
            }
            else
            {
                //
                // If property is writable and valid values are a list or a range, valid subtype will 
                // be set during a call to overloaded SetCurrentValue.
                //
                SubType = 0;
            }
        }
        else
        {
            //
            // If property is read-only, it's subtype is always WIA_PROP_NONE
            //
            Access = WIA_PROP_READ;
            SubType = WIA_PROP_NONE;
        }
        
        //
        // Process image capture dimensions separately, since they are in a string
        //
        if (PropCode == PTP_PROPERTYCODE_IMAGESIZE)
        {
            //
            // Define separate properties for image width and height
            //
            hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_WIDTH, WIA_DPC_PICT_WIDTH_STR, Access, SubType);
            if (FAILED(hr)) goto failure;

            hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_HEIGHT, WIA_DPC_PICT_HEIGHT_STR, Access, SubType);
            if (FAILED(hr)) goto failure;

            LONG curWidth, curHeight;
            SplitImageSize(pCurrentPD->m_cbstrCurrent, &curWidth, &curHeight);

            //
            // If the image capture size property is read-only, just set the current values
            //
            if (Access == WIA_PROP_READ)
            {
                RootProps.SetCurrentValue(index-1, curWidth);
                RootProps.SetCurrentValue(index, curHeight);
            }

            //
            // Otherwise, set the valid values too
            //
            else
            {
                //
                // Convert default values
                //
                LONG defWidth, defHeight;
                SplitImageSize(pCurrentPD->m_cbstrDefault, &defWidth, &defHeight);

                if (pCurrentPD->m_FormFlag == PTP_FORMFLAGS_RANGE)
                {
                    //
                    // Convert max, min, and step
                    //
                    LONG minWidth, minHeight, maxWidth, maxHeight, stepWidth, stepHeight;
                    SplitImageSize(pCurrentPD->m_cbstrRangeMin, &minWidth, &minHeight);
                    SplitImageSize(pCurrentPD->m_cbstrRangeMax, &maxWidth, &maxHeight);
                    SplitImageSize(pCurrentPD->m_cbstrRangeStep, &stepWidth, &stepHeight);

                    RootProps.SetValidValues(index-1, defWidth, curWidth, minWidth, maxWidth, stepWidth);
                    RootProps.SetValidValues(index, defHeight, curHeight, minHeight, maxHeight, stepHeight);
                }
                else if (pCurrentPD->m_FormFlag == PTP_FORMFLAGS_ENUM)
                {
                    //
                    // Convert list of strings
                    //
                    ULONG width, height;
                    
                    int numElem = pCurrentPD->m_NumValues;

                    if (!widthList.GrowTo(numElem) ||
                        !heightList.GrowTo(numElem))
                    {
                        wiauDbgError("InitDeviceProperties", "memory allocation failed");
                        return E_OUTOFMEMORY;
                    }

                    for (int countVals = 0; countVals < numElem; countVals++)
                    {
                        SplitImageSize(pCurrentPD->m_cbstrValues[countVals], (LONG*) &width, (LONG*) &height);

                        if (!widthList.Add(width) ||
                            !heightList.Add(height))
                        {
                            wiauDbgError("InitDeviceProperties", "error adding width or height");
                            return E_FAIL;
                        }
                    }

                    RootProps.SetValidValues(index-1, defWidth, curWidth, numElem, (LONG *) widthList.GetData());
                    RootProps.SetValidValues(index, defHeight, curHeight, numElem, (LONG *) heightList.GetData());
                }
            }

            continue;

        } // if (PropCode == PTP_PROPERTYCODE_IMAGESIZE)

        //
        // Look up the property info structure, which contains the WIA prop id and string
        //
        pPropInfo = PropCodeToPropInfo(PropCode);
        if (!pPropInfo->PropId)
        {
            wiauDbgError("InitDeviceProperties", "property code not found in array, 0x%04x", PropCode);
            return E_FAIL;
        }
        
        //
        // Define the property based on the fields in the property info structure
        //
        hr = RootProps.DefineProperty(&index, pPropInfo->PropId, pPropInfo->PropName, Access, SubType);
        if (FAILED(hr)) goto failure;

        //
        // Handle the device date/time. Convert it to SYSTEMTIME and create the property, skipping the rest.
        //
        if (PropCode == PTP_PROPERTYCODE_DATETIME)
        {
            hr = PtpTime2SystemTime(&(pCurrentPD->m_cbstrCurrent), &SystemTime);
            if (FAILED(hr))
            {
                wiauDbgError("InitDeviceProperties", "invalid date/time string");
                continue;
            }

            RootProps.SetCurrentValue(index, &SystemTime);

            continue;
        }

        //
        // Handle all other properties
        //
        if (Access == WIA_PROP_RW)
        {
            //
            // Set the valid values for ranges
            //
            if (pCurrentPD->m_FormFlag == PTP_FORMFLAGS_RANGE)
            {
                //
                // WIA can't handle string ranges, so handle just integers
                //
                if (pCurrentPD->m_DataType != PTP_DATATYPE_STRING)
                    RootProps.SetValidValues(index, (LONG) pCurrentPD->m_lDefault,
                                             (LONG) pCurrentPD->m_lCurrent,
                                             (LONG) pCurrentPD->m_lRangeMin,
                                             (LONG) pCurrentPD->m_lRangeMax,
                                             (LONG) pCurrentPD->m_lRangeStep);
            }

            //
            // Set the valid values for lists
            //
            else if (pCurrentPD->m_FormFlag == PTP_FORMFLAGS_ENUM)
            {
                if (pCurrentPD->m_DataType == PTP_DATATYPE_STRING)
                    RootProps.SetValidValues(index, pCurrentPD->m_cbstrDefault.String(),
                                             pCurrentPD->m_cbstrCurrent.String(),
                                             pCurrentPD->m_NumValues,
                                             (BSTR *) (pCurrentPD->m_cbstrValues.GetData()));
                else
                    RootProps.SetValidValues(index, (LONG) pCurrentPD->m_lDefault,
                                             (LONG) pCurrentPD->m_lCurrent,
                                             pCurrentPD->m_NumValues,
                                             (LONG *) (pCurrentPD->m_lValues.GetData()));
            }

            //
            // Unrecognized form. Just set the current values
            //
            if (pCurrentPD->m_DataType == PTP_DATATYPE_STRING)
                RootProps.SetCurrentValue(index, pCurrentPD->m_cbstrCurrent.String());
            else
                RootProps.SetCurrentValue(index, (LONG) pCurrentPD->m_lCurrent);
        }
        else
        {
            //
            // For read-only properties, just set the current value
            //
            if (pCurrentPD->m_DataType == PTP_DATATYPE_STRING)
                RootProps.SetCurrentValue(index, pCurrentPD->m_cbstrCurrent.String());
            else
                RootProps.SetCurrentValue(index, (LONG) pCurrentPD->m_lCurrent);
        }

    }

    // Last step: send all the properties to WIA

    hr = RootProps.SendToWia(pWiasContext);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "InitDeviceProperties", "SendToWia failed");
        return hr;
    }

    return hr;

    //
    // Any failures from DefineProperty will end up here
    //

    failure:
        wiauDbgErrorHr(hr, "InitDeviceProperties", "DefineProperty failed");
        return hr;
}

// This function reads the device properties
//
// Input:
//  pWiasContext  -- wias context
//  NumPropSpecs  -- number of properties to be read
//  pPropSpecs    -- list of PROPSPEC that designates what properties to read
//
HRESULT
CWiaMiniDriver::ReadDeviceProperties(
    BYTE *pWiasContext,
    LONG NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    DBG_FN("CWiaMiniDriver::ReadDeviceProperties");
    
    HRESULT hr = S_OK;
    
    if (!NumPropSpecs || !pPropSpecs)
    {
        wiauDbgError("ReadDeviceProperties", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Update the device properties
    //
    if (m_PropDescs.GetSize() > 0)
    {
        //
        // Loop through all of the PropSpecs
        //
        for (int count = 0; count < NumPropSpecs; count++)
        {
            PROPID propId = pPropSpecs[count].propid;
            
            //
            // Update free image space, if requested
            //
            if (propId == WIA_DPC_PICTURES_REMAINING)
            {
                hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_REMAINING, GetTotalFreeImageSpace());
                if (FAILED(hr))
                {
                    wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                    return hr;
                }
            }

            //
            // Update pictures taken, if requested
            //
            else if (propId == WIA_DPC_PICTURES_TAKEN)
            {
                hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_TAKEN, m_NumImages);
                if (FAILED(hr))
                {
                    wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                    return hr;
                }
            }
            
            //
            // Image size is a special case property, which we handle here
            //
            else if (propId == WIA_DPC_PICT_WIDTH ||
                     propId == WIA_DPC_PICT_HEIGHT)
            {
                int propDescIdx = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_IMAGESIZE);
                if (propDescIdx < 0)
                    continue;

                LONG width, height;
                SplitImageSize(m_PropDescs[propDescIdx].m_cbstrCurrent, &width, &height);

                if (propId == WIA_DPC_PICT_WIDTH)
                    hr = wiasWritePropLong(pWiasContext, propId, width);
                else
                    hr = wiasWritePropLong(pWiasContext, propId, height);

                if (FAILED(hr))
                {
                    wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                    return hr;
                }
            }
            
            //
            // See if the property is one that is contained in the PropSpec array
            //
            else
            {
                //
                // Try to convert the WIA prop id to a PTP prop code
                //
                WORD propCode = PropIdToPropCode(propId);
                if (propCode == 0)
                    continue;

                //
                // Try to find the prop code (and thus the prop desc structure) in the member array
                //
                int propDescIdx = m_DeviceInfo.m_SupportedProps.Find(propCode);
                if (propDescIdx < 0)
                    continue;

                //
                // If it's the device time property, convert to SYSTEMTIME and write to WIA
                //
                if (propId == WIA_DPA_DEVICE_TIME)
                {
                    hr = m_pPTPCamera->GetDevicePropValue(propCode, &m_PropDescs[propDescIdx]);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "GetDevicePropValue failed");
                        return hr;
                    }
                    
                    SYSTEMTIME st;
                    hr = PtpTime2SystemTime(&m_PropDescs[propDescIdx].m_cbstrCurrent, &st);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "PtpTime2SystemTime failed");
                        return hr;
                    }

                    PROPVARIANT pv;
                    pv.vt = VT_UI2 | VT_VECTOR;
                    pv.caui.cElems = sizeof(SYSTEMTIME)/sizeof(WORD);
                    pv.caui.pElems = (USHORT *) &st;

                    PROPSPEC ps;
                    ps.ulKind = PRSPEC_PROPID;
                    ps.propid = propId;

                    hr = wiasWriteMultiple(pWiasContext, 1, &ps, &pv);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "wiasWriteMultiple failed");
                        return hr;
                    }
                }

                //
                // If it's a string property, write the updated value to WIA
                //
                else if (m_PropDescs[propDescIdx].m_DataType == PTP_DATATYPE_STRING)
                {
                    hr = wiasWritePropStr(pWiasContext, propId,
                                          m_PropDescs[propDescIdx].m_cbstrCurrent.String());
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                        return hr;
                    }
                }

                //
                // If it's an integer property, write the updated value to WIA
                //
                else
                {
                    hr = wiasWritePropLong(pWiasContext, propId,
                                           m_PropDescs[propDescIdx].m_lCurrent);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ReadDeviceProperties", "wiasWritePropLong failed");
                        return hr;
                    }
                }
            }
        }
    }

    return hr;
}

//
// This function does nothing, since the values were already sent to the device in ValidateDeviceProp
//
// Input:
//   pWiasContext -- the WIA item context
//   pmdtc        -- the transfer context
//
HRESULT
CWiaMiniDriver::WriteDeviceProperties(
    BYTE *pWiasContext
    )
{
    DBG_FN("CWiaMiniDriver::WriteDeviceProperties");

    HRESULT hr = S_OK;

    return hr;
}

//
// This function validates device property current settings and writes them to the device. The
// settings need to be written here vs. WriteDeviceProperties in case the user unplugs the camera.
//
// Input:
//   pWiasContext    -- the item's context
//   NumPropSpecs    -- number of properties to be validated
//   pPropSpecs  -- properties to be validated
//
HRESULT
CWiaMiniDriver::ValidateDeviceProperties(
    BYTE    *pWiasContext,
    LONG    NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    USES_CONVERSION;
    
    DBG_FN("CWiaMiniDriver::ValidateDeviceProperties");
    
    HRESULT hr = S_OK;

    //
    // Call WIA service helper to check against valid values
    //
    hr = wiasValidateItemProperties(pWiasContext, NumPropSpecs, pPropSpecs);
    if (FAILED(hr))
    {
        wiauDbgWarning("ValidateDeviceProperties", "wiasValidateItemProperties failed");
        return hr;
    }

    {
        //
        // Ensure exclusive access
        //
        CPtpMutex cpm(m_hPtpMutex);

        PROPVARIANT *pPropVar = new PROPVARIANT[NumPropSpecs];
        if (pPropVar == NULL)
        {
            wiauDbgError("ValidateDeviceProperties", "memory allocation failed");
            return E_OUTOFMEMORY;
        }

        //
        // Read all of the new property values
        //
        hr = wiasReadMultiple(pWiasContext, NumPropSpecs, pPropSpecs, pPropVar, NULL);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateDeviceProperties", "wiasReadMultiple failed");
            delete []pPropVar;
            return hr;
        }
    
        //
        // First do validation
        //
        LONG width = 0;
        LONG height = 0;
        
        for (int count = 0; count < NumPropSpecs; count++)
        {
            //
            // Handle changes to the picture width
            //
            if (pPropSpecs[count].propid == WIA_DPC_PICT_WIDTH)
            {
                width = pPropVar[count].lVal;
                height = 0;
    
                //
                // Look through the valid values and find the corresponding height
                //
                hr = FindCorrDimension(pWiasContext, &width, &height);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "FindCorrDimension failed");
                    delete []pPropVar;
                    return hr;
                }
                
                //
                // If the app is trying to set height, make sure it's correct
                //
                int idx;
                if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_DPC_PICT_HEIGHT, &idx))
                {
                    if (height != pPropVar[idx].lVal)
                    {
                        wiauDbgError("ValidateDeviceProperties", "app attempting to set incorrect height");
                        delete []pPropVar;
                        return E_INVALIDARG;
                    }
                }
    
                else
                {
                    hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICT_HEIGHT, height);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ValidateDeviceProperties", "wiasWritePropLong failed");
                        delete []pPropVar;
                        return hr;
                    }
                }
    
            } // if (pPropSpecs[count].propid == WIA_DPC_PICT_WIDTH)
    
            
            //
            // Handle changes to the picture height
            //
            else if (pPropSpecs[count].propid == WIA_DPC_PICT_HEIGHT)
            {
                //
                // See if the app is trying to set width also. If so, the height has
                // already been set, so don't set it again.
                //
                if (!wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_DPC_PICT_WIDTH))
                {
                    width = 0;
                    height = pPropVar[count].lVal;
    
                    //
                    // Look through the valid values and find the corresponding width
                    //
                    hr = FindCorrDimension(pWiasContext, &width, &height);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ValidateDeviceProperties", "FindCorrDimension failed");
                        delete []pPropVar;
                        return hr;
                    }
    
                    //
                    // Set the width
                    //
                    hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICT_WIDTH, width);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ValidateDeviceProperties", "wiasWritePropLong failed");
                        delete []pPropVar;
                        return hr;
                    }
                }
            
            } // else if (pPropSpecs[count].propid == WIA_DPC_PICT_HEIGHT)
    
            //
            // Handle device time
            //
            else if (pPropSpecs[count].propid == WIA_DPA_DEVICE_TIME)
            {
                int propIndex = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_DATETIME);
                CPtpPropDesc *pCurrentPD = &m_PropDescs[propIndex];
    
                //
                // Convert the date/time to a string
                //
                SYSTEMTIME *pSystemTime = (SYSTEMTIME *) pPropVar[count].caui.pElems;
                hr = SystemTime2PtpTime(pSystemTime, &pCurrentPD->m_cbstrCurrent, m_bTwoDigitsMillisecondsOutput);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "invalid date/time string");
                    delete []pPropVar;
                    return E_FAIL;
                }
    
                //
                // Write the new date/time to the device
                //
                hr = m_pPTPCamera->SetDevicePropValue(PTP_PROPERTYCODE_DATETIME, pCurrentPD);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "SetDevicePropValue failed");
                    delete []pPropVar;
                    return hr;
                }
            } // else if (pPropSpecs[count].propid == WIA_DPA_DEVICE_TIME)
        } // for (count...
    
        //
        // Now write the new values to the camera
        //
        PROPSPEC propSpec;
        BOOL bWroteWidthHeight = FALSE;
        WORD propCode = 0;
        int pdIdx = 0;
        CPtpPropDesc *pCurrentPD = NULL;
        
        for (int count = 0; count < NumPropSpecs; count++)
        {
            //
            // Skip date/time since it was already written above
            //
            if (pPropSpecs[count].propid == WIA_DPA_DEVICE_TIME)
                continue;
            
            //
            // Handle changes to the picture width or height
            //
            if ((pPropSpecs[count].propid == WIA_DPC_PICT_WIDTH) ||
                (pPropSpecs[count].propid == WIA_DPC_PICT_HEIGHT))
            {
                //
                // If width and height were already written, don't do it again
                //
                if (bWroteWidthHeight)
                    continue;
    
                TCHAR ptcsImageSize[MAX_PATH];
                hr = StringCchPrintfW(ptcsImageSize, ARRAYSIZE(ptcsImageSize), TEXT("%dx%d"), width, height);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "StringCchPrintfW failed");
                    delete []pPropVar;
                    return E_FAIL;
                }
    
                propCode = PTP_PROPERTYCODE_IMAGESIZE;
                pdIdx = m_DeviceInfo.m_SupportedProps.Find(propCode);
                if (pdIdx < 0)
                {
                    wiauDbgWarning("ValidateDeviceProperties", "Width/height not supported by camera");
                    continue;
                }
                pCurrentPD = &m_PropDescs[pdIdx];
                
                hr = pCurrentPD->m_cbstrCurrent.Copy(T2W(ptcsImageSize));
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "Copy bstr failed");
                    delete []pPropVar;
                    return hr;
                }
    
                //
                // Write the new value to the device
                //
                hr = m_pPTPCamera->SetDevicePropValue(propCode, pCurrentPD);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "SetDevicePropValue failed");
                    delete []pPropVar;
                    return hr;
                }
                
                bWroteWidthHeight = TRUE;
            }
    
            else
            {
                //
                // Find the prop code and prop desc structure
                //
                propCode = PropIdToPropCode(pPropSpecs[count].propid);
                pdIdx = m_DeviceInfo.m_SupportedProps.Find(propCode);
                if (pdIdx < 0)
                {
                    wiauDbgWarning("ValidateDeviceProperties", "Property not supported by camera");
                    continue;
                }
                pCurrentPD = &m_PropDescs[pdIdx];
    
                //
                // Put the new value into the PropSpec structure
                //
                if (pPropVar[count].vt == VT_BSTR)
                {
                    hr = pCurrentPD->m_cbstrCurrent.Copy(pPropVar[count].bstrVal);
                    if (FAILED(hr))
                    {
                        wiauDbgError("ValidateDeviceProperties", "Copy bstr failed");
                        delete []pPropVar;
                        return hr;
                    }
                }
                else if (pPropVar[count].vt == VT_I4)
                {
                    pCurrentPD->m_lCurrent = pPropVar[count].lVal;
                }
                else
                {
                    wiauDbgError("ValidateDeviceProperties", "unsupported variant type");
                    delete []pPropVar;
                    return E_FAIL;
                }
    
                //
                // Write the new value to the device
                //
                hr = m_pPTPCamera->SetDevicePropValue(propCode, pCurrentPD);
                if (FAILED(hr))
                {
                    wiauDbgError("ValidateDeviceProperties", "SetDevicePropValue failed");
                    delete []pPropVar;
                    return hr;
                }
            }
        }
        delete []pPropVar;
    }

    return hr;
}

//
// This function finds the corresponding height for a width value, or vice versa. Set the
// value to find to zero.
//
// Input:
//   pWidth -- pointer to the width value
//   pHeight -- pointer to the height value
//
HRESULT
CWiaMiniDriver::FindCorrDimension(BYTE *pWiasContext, LONG *pWidth, LONG *pHeight)
{
    DBG_FN("CWiaMiniDriver::FindCorrDimensions");
    
    HRESULT hr = S_OK;

    if (!pWiasContext ||
        (*pWidth == 0 && *pHeight == 0))
    {
        wiauDbgError("FindCorrDimension", "invalid args");
        return E_INVALIDARG;
    }
    
    PROPSPEC ps[2];
    ULONG af[2];
    PROPVARIANT pv[2];

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_DPC_PICT_WIDTH;
    ps[1].ulKind = PRSPEC_PROPID;
    ps[1].propid = WIA_DPC_PICT_HEIGHT;

    hr = wiasGetPropertyAttributes(pWiasContext, 2, ps, af, pv);
    if (FAILED(hr))
    {
        wiauDbgError("FindCorrDimension", "wiasGetPropertyAttributes failed");
        return E_FAIL;
    }

    int count = 0 ;

    if (af[0] & WIA_PROP_LIST)
    {
        LONG numValues = pv[0].cal.pElems[WIA_LIST_COUNT];
        LONG *pValidWidths = &pv[0].cal.pElems[WIA_LIST_VALUES];
        LONG *pValidHeights = &pv[1].cal.pElems[WIA_LIST_VALUES];

        if (*pWidth == 0)
        {
            //
            // Find the height in the valid values array
            //
            for (count = 0; count < numValues; count++)
            {
                if (pValidHeights[count] == *pHeight)
                {
                    //
                    // Set the width and exit
                    //
                    *pWidth = pValidWidths[count];
                    break;
                }
            }
        }

        else
        {
            //
            // Find the width in the valid values array
            //
            for (count = 0; count < numValues; count++)
            {
                if (pValidWidths[count] == *pWidth)
                {
                    //
                    // Set the height and exit
                    //
                    *pHeight = pValidHeights[count];
                    break;
                }
            }
        }
    }

    else if (af[0] & WIA_PROP_RANGE)
    {
        LONG minWidth   = pv[0].cal.pElems[WIA_RANGE_MIN];
        LONG maxWidth   = pv[0].cal.pElems[WIA_RANGE_MAX];
        LONG stepWidth  = pv[0].cal.pElems[WIA_RANGE_STEP];
        LONG minHeight  = pv[1].cal.pElems[WIA_RANGE_MIN];
        LONG maxHeight  = pv[1].cal.pElems[WIA_RANGE_MAX];
        LONG stepHeight = pv[1].cal.pElems[WIA_RANGE_STEP];

        if (*pWidth == 0)
        {
            //
            // Set the width to the proportionally correct value, clipping to the step value
            //
            *pWidth = FindProportionalValue(*pHeight, minHeight, maxHeight, minWidth, maxWidth, stepWidth);
        }
        else
        {
            //
            // Set the height to the proportionally correct value, clipping to the step value
            //
            *pHeight = FindProportionalValue(*pWidth, minWidth, maxWidth, minHeight, maxHeight, stepHeight);
        }
    }

    return hr;
}

//
// This function takes the proportion of valueX between minX and maxX and uses that to
// find a value of the same proportion between minY and maxY. It then clips that value
// to the step value
//
int CWiaMiniDriver::FindProportionalValue(int valueX, int minX, int maxX, int minY, int maxY, int stepY)
{
    int valueY;

    //
    // Find proportional value
    //
    valueY = (valueX - minX) * (maxY - minY) / (maxX - minX)  + minY;

    //
    // Clip the value to the step
    //
    valueY = ((valueY + ((stepY - 1) / 2)) - minY) / stepY * stepY + minY;

    return valueY;
}


//
// This helper function returns a pointer to the property info structure
// based on the property code
//
// Input:
//   PropCode -- the format code
//
// Output:
//   Returns pointer to the property info structure
//
PPROP_INFO
CWiaMiniDriver::PropCodeToPropInfo(WORD PropCode)
{
    DBG_FN("CWiaMiniDriver::PropCodeToPropInfo");

    PPROP_INFO pPropInfo = NULL;
    UINT index = 0;
    const WORD PROPCODE_MASK = 0x0fff;
    
    if (PropCode & PTP_DATACODE_VENDORMASK)
    {
        //
        // Look up vendor extended PropCode
        //
        pPropInfo = m_VendorPropMap.Lookup(PropCode);
        if (!pPropInfo)
        {
            pPropInfo = &g_PropInfo[0];
        }
    }

    else
    {
        //
        // Look up the prop code in the prop info array
        //
        index = PropCode & PROPCODE_MASK;

        if (index >= g_NumPropInfo)
        {
            index = 0;
        }

        pPropInfo = &g_PropInfo[index];
    }

    return pPropInfo;
}

//
// This helper function returns a pointer to the format info structure
// based on the format code
//
// Input:
//   FormatCode -- the format code
//   AssocType -- association type (for associations)
//
// Output:
//   Returns pointer to the format info structure
//
PFORMAT_INFO
FormatCodeToFormatInfo(WORD FormatCode, WORD AssocType)
{
    DBG_FN("FormatCodeToFormatString");

    PFORMAT_INFO pFormatInfo = NULL;
    UINT index = 0;
    const WORD FORMATCODE_MASK = 0x07ff;
    
    if (FormatCode & PTP_DATACODE_VENDORMASK)
    {
        //
        // WIAFIX-9/6/2000-davepar This should ideally query GDI+ somehow for a filter
        // which the vendor could register
        //
        pFormatInfo = &g_NonImageFormatInfo[0];
    }

    else if (FormatCode == PTP_FORMATCODE_ASSOCIATION)
    {
        //
        // Look up the association type
        //
        index = AssocType;
        
        if (index > g_NumAssocFormatInfo)
        {
            index = 0;
        }
        pFormatInfo = &g_AssocFormatInfo[index];
    }

    else
    {
        //
        // Look up the format code in either the image or non-image format info array
        //
        index = FormatCode & FORMATCODE_MASK;

        if (FormatCode & PTP_FORMATMASK_IMAGE)
        {
            if (index > g_NumImageFormatInfo)
            {
                index = 0;
            }
            pFormatInfo = &g_ImageFormatInfo[index];
        }
        else
        {
            if (index >= g_NumNonImageFormatInfo)
            {
                index = 0;
            }
            pFormatInfo = &g_NonImageFormatInfo[index];
        }
    }

    return pFormatInfo;
}

//
// This function converts a WIA format GUID into a PTP format code
//
WORD
FormatGuidToFormatCode(GUID *pFormatGuid)
{
    WORD count = 0;

    //
    // Look through the image formats first
    //
    for (count = 0; count < g_NumImageFormatInfo; count++)
    {
        if (g_ImageFormatInfo[count].FormatGuid &&
            IsEqualGUID(*pFormatGuid, *(g_ImageFormatInfo[count].FormatGuid)))
        {
            return count | PTP_FORMATCODE_IMAGE_UNDEFINED;
        }
    }

    //
    // Then look through the non image formats
    //
    for (count = 0; count < g_NumNonImageFormatInfo; count++)
    {
        if (g_NonImageFormatInfo[count].FormatGuid &&
            IsEqualGUID(*pFormatGuid, *(g_NonImageFormatInfo[count].FormatGuid)))
        {
            return count | PTP_FORMATCODE_UNDEFINED;
        }
    }

    //
    // The GUID wasn't found in either array
    //
    return PTP_FORMATCODE_UNDEFINED;
}

//
// This function looks up a prop id in the property info array and returns a
// property code for it.
//
WORD
PropIdToPropCode(PROPID PropId)
{
    WORD PropCode;
    for (PropCode = 0; PropCode < g_NumPropInfo; PropCode++)
    {
        if (g_PropInfo[PropCode].PropId == PropId)
        {
            return PropCode | PTP_PROPERTYCODE_UNDEFINED;
        }
    }

    //
    // Not found
    //
    return 0;
}

//
// This function splits a PTP image size string (WXH) into two separate longs
//
VOID
SplitImageSize(
    CBstr cbstr,
    LONG *pWidth,
    LONG *pHeight
    )
{
    USES_CONVERSION;
    
    int num = _stscanf(W2T(cbstr.String()), TEXT("%dx%d"), pWidth, pHeight);

    //
    // The spec mentions "x" as divider, but let's be paranoid and check "X" as well
    //
    if (num != 2)
    {
        num = _stscanf(W2T(cbstr.String()), TEXT("%dX%d"), pWidth, pHeight);
    }

    if (num != 2)
    {
        wiauDbgError("SplitImageSize", "invalid current image dimensions");
        *pWidth = 0;
        *pHeight = 0;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\dllmain.h ===
#ifndef DLLMAIN__H_
#define DLLMAIN__H_

extern "C"
{
    BOOL
    APIENTRY
    DllMain(
           HINSTANCE hInstance,
           DWORD dwReason,
           LPVOID lpReserved
           );
}

STDAPI
DllCanUnloadNow(void);

STDAPI
DllGetClassObject(
                 REFCLSID    rclsid,
                 REFIID      riid,
                 LPVOID      *ppv
                 );


extern HINSTANCE g_hInst;

#endif // #ifndef DLLMAIN__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\common\ptputil.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    ptputil.cpp

Abstract:

    This module implements PTP data structure manipulating functions

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "ptppch.h"

//
// This function converts a PTP datetime string to Windows FILETIME.
//
// Input:
//  pptpTime    -- the PTP datetime string
//  SystemTime  -- SYSTEMTIME structure to receive the converted time
//
// Notes:
//   PTP timestamp is a string with the format "YYYYMMDDThhmmss.s", where
//     YYYY is the year
//     MM   is the month(1 - 12)
//     DD   is the day(1 - 31)
//     T    is the constant used to separate date and time
//     hh   is the hour(0 - 23)
//     mm   is the minute(0 - 59)
//     ss   is the second(0 - 59)
//     .s   is the optional 10th of second
//
//   Append it with 'Z' means it is a UTC time.
//   Append it with "+/-hhmm" means it is relative to a time zone.
//   Append neither means the time zone is unknown, assume time zone of the host.
//
HRESULT
PtpTime2SystemTime(
    CBstr *pptpTime,
    SYSTEMTIME *pSystemTime
    )
{
    DBG_FN("PTPTime2FileTime");

    HRESULT hr = S_OK;
    
    if (!pSystemTime || !pptpTime || !pptpTime->String() ||
        pptpTime->Length() < 4 + 2 + 2 + 1 + 2 + 2 + 2 ||
        L'T' != pptpTime->String()[4 + 2 + 2])
    {
        wiauDbgTrace("PtpTime2SystemTime", "Invalid arg");
        return E_INVALIDARG;
    }

    WCHAR TimeString[MAX_PATH];
    ZeroMemory(TimeString, sizeof(TimeString));
    
    hr = StringCchCopyW(TimeString, ARRAYSIZE(TimeString), pptpTime->String());
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "PtpTime2SystemTime", "StringCchCopyW failed");
        goto Cleanup;
    }
    

    WCHAR wch;
    LPWSTR pwcsEnd;

    wch = TimeString[4];
    TimeString[4] = UNICODE_NULL;
    pSystemTime->wYear = (WORD)wcstol(TimeString, &pwcsEnd, 10);
    TimeString[4] = wch;
    wch = TimeString[6];
    TimeString[6] = UNICODE_NULL;
    pSystemTime->wMonth = (WORD)wcstol(TimeString + 4, &pwcsEnd, 10);
    TimeString[6] = wch;
    wch = TimeString[8];
    TimeString[8] = UNICODE_NULL;
    pSystemTime->wDay =   (WORD)wcstol(TimeString + 6 , &pwcsEnd, 10);
    TimeString[8] = wch;
    wch = TimeString[11];
    TimeString[11] = UNICODE_NULL;
    pSystemTime->wHour = (WORD)wcstol(TimeString + 9, &pwcsEnd, 10);
    TimeString[11] = wch;
    wch = TimeString[13];
    TimeString[13] = UNICODE_NULL;
    pSystemTime->wMinute = (WORD)wcstol(TimeString + 11, &pwcsEnd, 10);
    TimeString[13] = wch;
    wch = TimeString[15];
    TimeString[15] = UNICODE_NULL;
    pSystemTime->wSecond = (WORD)wcstol(TimeString + 13, &pwcsEnd, 10);
    TimeString[15] = wch;
    if (L'.' == wch)
    {
        wch = TimeString[17];
        TimeString[17] = UNICODE_NULL;
        pSystemTime->wMilliseconds = 100 * (WORD)wcstol(TimeString + 16, &pwcsEnd, 10);
        TimeString[17] = wch;
    }
    else
    {
        pSystemTime->wMilliseconds = 0;
    }

    pSystemTime->wDayOfWeek = 0;

    //
    // WIAFIX-8/17/2000-davepar Time zone information is being ignored
    //

Cleanup:
    return hr;
}

//
// This function converts a SYSTEMTIME to PTP datetime string.
//
// Input:
//   pSystemTime -- the SYSTEMTIME
//   pptpTime    -- target PTP datatime string
//
HRESULT
SystemTime2PtpTime(
    SYSTEMTIME  *pSystemTime,
    CBstr *pptpTime,
    BOOL bTwoDigitsForMilliseconds
    )
{
    DBG_FN("SystemTime2PTPTime");

    HRESULT hr = S_OK;
    
    if (!pptpTime || !pSystemTime)
    {
        wiauDbgError("SystemTime2PtpTime", "Invalid arg");
        return E_INVALIDARG;
    }

    WCHAR ptpTimeStr[MAX_PATH];
    WCHAR *pwstr;
    pwstr = ptpTimeStr;

    //
    // Four digits for year, two for month, and two for day
    //
    swprintf(pwstr, L"%04d%02d%02d", pSystemTime->wYear, pSystemTime->wMonth, pSystemTime->wDay);

    //
    // Separator
    //
    pwstr[8] = L'T';
    pwstr += 9;

    //
    // Two digits for hour, two for minute, and two for second
    //
    swprintf(pwstr, L"%02d%02d%02d", pSystemTime->wHour, pSystemTime->wMinute, pSystemTime->wSecond);
    pwstr += 6;

    //
    // Optional tenth second
    //
    if (pSystemTime->wMilliseconds)
    {
        *pwstr++ = L'.';

        //
        // In XP, PTP driver was sending DATETIME string to camera with two digits for milliseconds (bug 699699) 
        // Some cameras may still expect this format. In this case, vendor should provide custom INF file for 
        // the camera and include the following string entry under DeviceData key:
        //
        // [ModelName.DeviceData]
        // ...
        // TwoDigitsMillisecondsOutput=1
        // ...
        //
        if (bTwoDigitsForMilliseconds)
        {
            swprintf(pwstr, L"%02d", pSystemTime->wMilliseconds / 10);
            pwstr += 2;
        }
        else
        {
            swprintf(pwstr, L"%01d", pSystemTime->wMilliseconds / 100);
            pwstr += 1;
        }
    }

    //
    // NULL terminates the string
    //
    *pwstr = UNICODE_NULL;

    hr = pptpTime->Copy(ptpTimeStr);
    if (FAILED(hr))
    {
        wiauDbgError("SystemTime2PtpTime", "Copy failed");
        return hr;
    }

    return hr;
}

//
// This function dumps a PTP command block to the log
//
// Input:
//   pCommand -- pointer to a PTP command
//   NumParams -- number of parameters in the command
//
VOID
DumpCommand(
    PTP_COMMAND *pCommand,
    DWORD NumParams
    )
{
    if (!pCommand)
    {
        wiauDbgError("DumpCommand", "Invalid arg");
        return;
    }

    if (NumParams > COMMAND_NUMPARAMS_MAX)
    {
        NumParams = COMMAND_NUMPARAMS_MAX;
    }

    wiauDbgDump("DumpCommand", "Dumping command:");
    wiauDbgDump("DumpCommand", "  Opcode            = 0x%04x", pCommand->OpCode);
    wiauDbgDump("DumpCommand", "  Session id        = 0x%08x", pCommand->SessionId);
    wiauDbgDump("DumpCommand", "  Transaction id    = 0x%08x", pCommand->TransactionId);
    if (NumParams)
    {
        for (DWORD count = 0; count < NumParams; count++)
        {
            wiauDbgDump("DumpCommand", "  Parameter %d       = 0x%08x = %d",
                           count, pCommand->Params[count], pCommand->Params[count]);
        }
    }
}

//
// This function dumps a PTP response block to the log
//
// Input:
//   pResponse -- pointer to a PTP response
//
VOID
DumpResponse(
    PTP_RESPONSE *pResponse
    )
{
    if (!pResponse)
    {
        wiauDbgError("DumpResponse", "Invalid arg");
        return;
    }
    wiauDbgDump("DumpResponse", "Dumping response:");
    wiauDbgDump("DumpResponse", "  Response code     = 0x%04x", pResponse->ResponseCode);
    wiauDbgDump("DumpResponse", "  Session id        = 0x%08x", pResponse->SessionId);
    wiauDbgDump("DumpResponse", "  Transaction id    = 0x%08x", pResponse->TransactionId);
    for (DWORD count = 0; count < RESPONSE_NUMPARAMS_MAX; count++)
    {
        wiauDbgDump("DumpResponse", "  Parameter %d       = 0x%08x = %d",
                       count, pResponse->Params[count], pResponse->Params[count]);
    }
}

//
// This function dumps a PTP event block to the log
//
// Input:
//   pEvent -- pointer to a PTP event
//
VOID
DumpEvent(
    PTP_EVENT *pEvent
    )
{
    if (!pEvent)
    {
        wiauDbgError("DumpEvent", "Invalid arg");
        return;
    }
    wiauDbgDump("DumpEvent", "Dumping event:");
    wiauDbgDump("DumpEvent", "  Event code        = 0x%04x", pEvent->EventCode);
    wiauDbgDump("DumpEvent", "  Session id        = 0x%08x", pEvent->SessionId);
    wiauDbgDump("DumpEvent", "  Transaction id    = 0x%08x", pEvent->TransactionId);
    for (DWORD count = 0; count < EVENT_NUMPARAMS_MAX; count++)
    {
        wiauDbgDump("DumpEvent", "  Parameter %d       = 0x%08x = %d",
                       count, pEvent->Params[count], pEvent->Params[count]);
    }
}

//
// This function dumps a GUID to the log
//
// Input:
//  pGuid  -- GUID to dump
//
VOID
DumpGuid(
        GUID *pGuid
        )
{
    HRESULT hr = S_OK;
    
    if (!pGuid)
    {
        wiauDbgError("DumpGuid", "Invalid arg");
        return;
    }

    WCHAR GuidStringW[128];
    hr = StringFromGUID2(*pGuid, GuidStringW, sizeof(GuidStringW) / sizeof(WCHAR));
    if (FAILED(hr))
    {
        wiauDbgError("DumpGuid", "StringFromGUID2 failed");
        return;
    }

    wiauDbgDump("DumpGuid", "Guid = %S", GuidStringW);
    
    return;
}

//
// This function opens a registry key
//
HRESULT
CPTPRegistry::Open(
                  HKEY hkAncestor,
                  LPCTSTR KeyName,
                  REGSAM Access
                  )
{
    DBG_FN("CPTPRegistry::Open");

    HRESULT hr = S_OK;
    
    if (m_hKey)
    {
        wiauDbgError("Open", "Registry is already open");
        return E_ACCESSDENIED;
    }

    DWORD Win32Err;
    Win32Err = ::RegOpenKeyEx(hkAncestor, KeyName, 0, Access, &m_hKey);
    if (Win32Err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(Win32Err);
        wiauDbgErrorHr(hr, "Open", "RegOpenKeyEx failed");
        return hr;
    }

    return hr;
}

//
// This function gets a string type registry value
//
// Input:
//   ValueName -- the value's name
//   pptpStr   -- the receive the value
//
HRESULT
CPTPRegistry::GetValueStr(
    LPCTSTR ValueName,
    TCHAR *string,
    DWORD *pcbStringBytes
    )
{
    DBG_FN("CPTPRegistry::GetValueStr");

    HRESULT hr = S_OK;
    
    if (!ValueName || !string)
    {
        wiauDbgError("GetValueStr", "Invalid arg");
        return E_INVALIDARG;
    }

    //
    // Need to handle non-Unicode
    //
    DWORD Win32Err;
    Win32Err = ::RegQueryValueEx(m_hKey, ValueName, NULL, NULL, (BYTE *) string, pcbStringBytes);
    if (Win32Err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(Win32Err);
        wiauDbgErrorHr(hr, "GetValueStr", "RegQueryValueEx failed");
        return hr;
    }

    return hr;
}

//
// This function gets a string type registry value and converts it to a DWORD
//
// Input:
//   ValueName -- the value's name
//   pptpStr   -- the receive the value
//
HRESULT
CPTPRegistry::GetValueDword(
    LPCTSTR ValueName,
    DWORD *pValue
    )
{
    DBG_FN("CPTPRegistry::GetValueDword");

    HRESULT hr = S_OK;
    
    if (!ValueName || !pValue)
    {
        wiauDbgError("GetValueDword", "Invalid arg");
        return E_INVALIDARG;
    }

    //
    // Get the string from the registry
    //
    TCHAR string[MAX_PATH];
    DWORD stringLen = sizeof(string);
    hr = GetValueStr(ValueName, string, &stringLen);
    if (FAILED(hr))
    {
        wiauDbgError("GetValueDword", "GetValueStr failed");
        return hr;
    }

    *pValue = _tcstol(string, NULL, 0);

    return hr;
}

//
// This function gets a list of codes registry value
//
// Input:
//   ValueName -- the value's name
//
//   pptpStr   -- the receive the value
//
HRESULT
CPTPRegistry::GetValueCodes(
    LPCTSTR ValueName,
    CArray16 *pCodeArray
    )
{
    DBG_FN("CPTPRegistry::GetValueCodes");

    HRESULT hr = S_OK;
    
    if (!ValueName || !pCodeArray)
    {
        wiauDbgError("GetValueCodes", "Invalid arg");
        return E_INVALIDARG;
    }

    //
    // Get the string from the registry
    //
    TCHAR valueString[MAX_PATH];
    DWORD stringLen = sizeof(valueString);
    hr = GetValueStr(ValueName, valueString, &stringLen); 
    if (FAILED(hr))
    {
        wiauDbgError("GetValueCodes", "GetValueStr failed");
        return hr;
    }

    //
    // Parse the string for codes
    //
    TCHAR *pCurrent = _tcstok(valueString, TEXT(","));
    WORD code;
    while (pCurrent)
    {
        code = (WORD) _tcstol(pCurrent, NULL, 0);
        pCodeArray->Add(code);
        pCurrent = _tcstok(NULL, TEXT(","));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\dllmain.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    dllmain.cpp

Abstract:

    This module implements the dll exported APIs

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

#include <locale.h>

HINSTANCE g_hInst;

//
// Entry point of this transport DLL
// Input:
//  hInstance   -- Instance handle of this dll
//  dwReason    -- reason why this entry was called.
//  lpReserved  -- reserved!
//
// Output:
//  TRUE        if our initialization went well
//  FALSE       if for GetLastError() reason, we failed.
//
BOOL
APIENTRY
DllMain(
        HINSTANCE hInstance,
        DWORD dwReason,
        LPVOID lpReserved
        )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        
        g_hInst = hInstance;
        
        //
        // Set the locale to system default so that wcscmp and similary functions
        // would work on non-unicode platforms(Millenium, for example).
        //
        setlocale(LC_ALL, "");

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }
    return TRUE;
}

STDAPI
DllCanUnloadNow(void)
{
    return CClassFactory::CanUnloadNow();
}


//
// This api returns an inteface on the given class object
// Input:
//  rclsid  -- the class object.
//
STDAPI
DllGetClassObject(
                 REFCLSID    rclsid,
                 REFIID      riid,
                 LPVOID      *ppv
                 )
{
    return CClassFactory::GetClassObject(rclsid, riid, ppv);
}


//
// GetDeviceName
//
// This function is called by Co-Installer (not by WIA!), and is used to obtain 
// actual device name. This is necessary because all PTP cameras are installed with
// single generic INF file, and this INF file does not provide information about
// device name and manufacturer. 
//
// Parameters:
//      pwszPortName     - this name will be used in CreateFile to open device
//      pwszManufacturer - pointer to buffer provided by caller for Manufacturer name, may be NULL
//      cchManufacturer  - size of buffer, in characters
//      pwszModelName    - pointer to buffer provided by caller for Model name, may be NULL
//      cchModelName     - size of buffer, in characters
//

extern "C"
HRESULT 
APIENTRY
GetDeviceName(
    LPCWSTR     pwszPortName,
    WCHAR       *pwszManufacturer,
    DWORD       cchManufacturer,
    WCHAR       *pwszModelName,
    DWORD       cchModelName
    )
{
    if (pwszPortName == NULL || pwszPortName[0] == 0)
    {
       return E_INVALIDARG;
    }

    HRESULT          hr = S_OK;
    CPTPCamera      *pPTPCamera = NULL;
    CPtpDeviceInfo   DeviceInfo;

    //
    // Create a new camera object.
    //
    pPTPCamera = new CUsbCamera;
    if (pPTPCamera == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Open a connection to the camera
    //
    hr = pPTPCamera->Open((LPWSTR)pwszPortName, NULL, NULL, NULL, FALSE);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Query the camera for its DeviceInfo 
    //
    hr = pPTPCamera->GetDeviceInfo(&DeviceInfo);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Copy the returned Manufacturer and/or ModelName into the OUT params.
    //
    if ((pwszManufacturer != NULL) && 
        (cchManufacturer > 0)      && 
        (DeviceInfo.m_cbstrManufacturer.String() != NULL))
    {
        hr = StringCchCopy(pwszManufacturer, cchManufacturer, DeviceInfo.m_cbstrManufacturer.String());
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if ((pwszModelName != NULL) && 
        (cchModelName  > 0)      && 
        (DeviceInfo.m_cbstrModel.String() != NULL))
    {
        hr = StringCchCopy(pwszModelName, cchModelName, DeviceInfo.m_cbstrModel.String());
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

Cleanup:
    //
    // Close the connection to the camera and delete the camera object.
    //
    if (pPTPCamera) 
    {
        pPTPCamera->Close();
        delete pPTPCamera;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\eventcb.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    eventcb.cpp

Abstract:

    This module implements CWiaPTPEventCallback class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

//
// This method is the callback function for every PTP event
//
// Input:
//   pEvent -- PTP event block
//
HRESULT
CWiaMiniDriver::EventCallbackDispatch(
    PPTP_EVENT pEvent
    )
{
    DBG_FN("CWiaMiniDriver::EventCallback");
    
    HRESULT hr = S_OK;

    CPtpMutex cpm(m_hPtpMutex);

    if (!pEvent)
    {
        wiauDbgError("EventCallback", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Events are not expected when there is no open session. Just ignore the event
    //
    if (!m_pPTPCamera || !m_pPTPCamera->IsCameraSessionOpen())
    {
        wiauDbgError("EventCallback", "events not expected while there is no open session");
        return E_FAIL;
    }

    //
    // Figure out what the event is and call the appropriate function
    //
    switch (pEvent->EventCode)
    {
    case PTP_EVENTCODE_CANCELTRANSACTION:
        hr = S_OK;
        break;

    case PTP_EVENTCODE_OBJECTADDED:
        hr = AddNewObject(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_OBJECTREMOVED:
        hr = RemoveObject(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_STOREADDED:
        hr = AddNewStorage(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_STOREREMOVED:
        hr = RemoveStorage(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_DEVICEPROPCHANGED:
        hr = DevicePropChanged((WORD) pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_OBJECTINFOCHANGED:
        hr = ObjectInfoChanged(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_DEVICEINFOCHANGED:

        // WIAFIX-8/29/2000-davepar Need to handle this

        //hr = RebuildDrvItemTree(&DevErrVal);
        break;

    case PTP_EVENTCODE_REQUESTOBJECTTRANSFER:
        //
        // This event is ignored, because we don't know where to put the image. Maybe
        // it should cause a "button pushed" event.
        //
        break;
    
    case PTP_EVENTCODE_STOREFULL:
        hr = StorageFull(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_DEVICERESET:

        // WIAFIX-8/29/2000-davepar Need to handle this

        //hr = RebuildDrvItemTree(&DevErrVal);
        break;
    
    case PTP_EVENTCODE_STORAGEINFOCHANGED:
        hr = StorageInfoChanged(pEvent->Params[0]);
        break;

    case PTP_EVENTCODE_CAPTURECOMPLETE:
        hr = CaptureComplete();
        break;

    case PTP_EVENTCODE_UNREPORTEDSTATUS:

        // WIAFIX-8/29/2000-davepar Need to handle this

        //hr = RebuildDrvItemTree(&DevErrVal);
        break;


    default:

        //
        // If it is a vendor's event, post it
        //
        if (pEvent->EventCode & PTP_DATACODE_VENDORMASK)
        {
            hr = PostVendorEvent(pEvent->EventCode);
        }

        break;
    }

    return hr;
}

//
// This function adds a new object to the driver item tree. If a new driver
// item is added, a WIA_EVENT_ITEM_CREATED event will be signaled.
//
// Input:
//   ObjectHandle -- the new object handle
//
HRESULT
CWiaMiniDriver::AddNewObject(DWORD ObjectHandle)
{
    DBG_FN("CWiaMiniDriver::AddNewObject");
    
    HRESULT hr = S_OK;

    //
    // If there is a capture in progress, we need to wait until all new objects are reported, and
    // only then start querying imformation about them. See a sample sequence from the spec below:
    //
    // -> InitiateCapture Operation  -> 
    // <- InitiateCapture Response <- 
    // <- ObjectAdded Event(1)        <- 
    // <- ObjectAdded Event(2)        <- 
    // <- ObjectAdded Event(n)        <-  
    // <- CaptureComplete Event   <- 
    // -> GetObjectInfo Operation(1) -> 
    // <- ObjectInfo Dataset/Response(1) <- 
    // -> GetObjectInfo Operation(2) -> 
    // <- ObjectInfo Dataset/Response(2) <- 
    // -> GetObjectInfo Operation(n) -> 
    // <- ObjectInfo Dataset/Response(n) <- 
    //

    //
    // Check if there is a capture in progress
    //
    DWORD dwWait = WaitForSingleObject(m_TakePictureDoneEvent, 0);

    //
    // If there is no capture in progress, process the new object immediately
    //
    if (dwWait == WAIT_OBJECT_0)
    {
        hr = AddObject(ObjectHandle, TRUE);
        if (FAILED(hr))
        {
            wiauDbgError("AddNewObject", "AddObject failed");
            goto Cleanup;
        }
    }

    //
    // If there is a capture in progress, add the new object's handle to the list, 
    // all new objects will be processed once capture is finished
    //
    else if (dwWait == WAIT_TIMEOUT)
    {
        m_CapturedObjects.Add(ObjectHandle);
    }

    //
    // WAIT_FAILED or WAIT_ABANDONED - something's wrong
    //
    else
    {
        wiauDbgError("AddNewObject", "WaitForSingle object failed");
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}

//
// This function removes the given object handle from the driver item tree.
// If the object handle has a driver item associated with it and the
// driver item is removed, a WIA_EVENT_ITEM_REMOVED event will be signaled.
//
// Input:
//   ObjectHandle -- the object handle to be removed
//
HRESULT
CWiaMiniDriver::RemoveObject(DWORD ObjectHandle)
{
    DBG_FN("CWiaMiniDriver::RemoveObject");
    
    HRESULT hr = S_OK;

    //
    // Find the driver item for the object handle.
    //
    IWiaDrvItem *pDrvItem = m_HandleItem.Lookup(ObjectHandle);
    if (!pDrvItem)
    {
        wiauDbgError("RemoveObject", "tried to remove object that doesn't exist");
        return S_FALSE;
    }

    //
    // Try to remove the object from the ancillary assoc array, in case it's there too. Ancillary
    // association objects actually point to images in the handle/item map, so don't delete the
    // actual item
    //
    if (m_AncAssocParent.Remove(ObjectHandle))
    {
        wiauDbgTrace("RemoveObject", "ancillary association object removed");
    }
    else
    {
        BSTR bstrFullName;
        hr = pDrvItem->GetFullItemName(&bstrFullName);
        if (FAILED(hr))
        {
            wiauDbgError("RemoveObject", "GetFullItemName failed");
            return hr;
        }

        hr = pDrvItem->RemoveItemFromFolder(WiaItemTypeDisconnected);
        if (FAILED(hr))
        {
            wiauDbgError("RemoveObject", "UnlinkItemTree failed");
            return hr;
        }

        hr = wiasQueueEvent(m_bstrDeviceId, &WIA_EVENT_ITEM_DELETED, bstrFullName);
        if (FAILED(hr))
        {
            wiauDbgError("RemoveObject", "wiasQueueEvent failed");
            return hr;
        }

        SysFreeString(bstrFullName);
    }

    //
    // Remove the object from the handle/drvItem association
    //
    m_HandleItem.Remove(ObjectHandle);
    
    return hr;
}

//
// This function adds a new storage to the driver item tree.
// A WIA_EVENT_STORAGE_CREATED event will be singaled.
//
// Input:
//   StorageId   -- the new storage id to be added
//
HRESULT
CWiaMiniDriver::AddNewStorage(DWORD StorageId)
{
    DBG_FN("CWiaMiniDriver::AddNewStorage");
    
    HRESULT hr = S_OK;

    CArray32 StorageIdList;

    //
    // If several logical stores were added, the device may indicate
    // to re-enumerate the stores
    //
    if (StorageId == PTP_STORAGEID_UNDEFINED)
    {
        hr = m_pPTPCamera->GetStorageIDs(&StorageIdList);
        if (FAILED(hr))
        {
            wiauDbgError("AddNewStorage", "GetStorageIDs failed");
            return hr;
        }

        //
        // Loop through the list of new storage ids, removing the ones
        // that have already been enumerated
        //
        int index;
        for (int count = 0; count < StorageIdList.GetSize(); count++)
        {
            index = m_StorageIds.Find(StorageIdList[count]);
            if (index >= 0)
            {
                StorageIdList.RemoveAt(index);
            }
        }
    }

    //
    // Otherwise there is just one storage id to work on
    //
    else
    {
        StorageIdList.Add(StorageId);
    }

    //
    // Loop through all of the new storage ids
    //
    CPtpStorageInfo tempSI;
    for (int storageIndex = 0; storageIndex < StorageIdList.GetSize(); storageIndex++)
    {
        //
        // Get info for the new storage
        //
        hr = m_pPTPCamera->GetStorageInfo(StorageIdList[storageIndex], &tempSI);
        if (FAILED(hr))
        {
            wiauDbgError("drvInitializeWia", "GetStorageInfo failed");
            return hr;
        }

        //
        // Add the storage id to the main list
        //
        if (!m_StorageIds.Add(StorageIdList[storageIndex]))
        {
            wiauDbgError("AddNewStorage", "add storage id failed");
            return E_OUTOFMEMORY;
        }

        //
        // Add storage info to array
        //
        if (!m_StorageInfos.Add(tempSI))
        {
            wiauDbgError("drvInitializeWia", "add storage info failed");
            return E_OUTOFMEMORY;
        }

        //
        // Add an empty entry to the DCIM handle array
        //
        ULONG dummy = 0;
        if (!m_DcimHandle.Add(dummy))
        {
            wiauDbgError("AddNewStorage", "add dcim handle failed");
            return E_OUTOFMEMORY;
        }
        
        //
        // Loop through all of the objects on the new storage, adding them one
        // at a time.
        //
        CArray32 ObjectHandleList;
    
        hr = m_pPTPCamera->GetObjectHandles(StorageIdList[storageIndex], PTP_FORMATCODE_ALL,
                                            PTP_OBJECTHANDLE_ALL, &ObjectHandleList);
        if (FAILED(hr))
        {
            wiauDbgError("AddNewStorage", "GetObjectHandles failed");
            return hr;
        }
    
        //
        // Iterate through the object handles, creating a WIA driver item for each
        //
        for (int objectindex = 0; objectindex < ObjectHandleList.GetSize(); objectindex++)
        {
            hr = AddObject(ObjectHandleList[objectindex], TRUE);
            if (FAILED(hr))
            {
                wiauDbgError("AddNewStorage", "AddObject failed");
                return hr;
            }
        }
    }

    return hr;
}

//
// This function removes all of the objects on a storage from the
// driver item tree, signalling WIA_EVENT_ITEM_DELETED as appropriate.
//
// Input:
//   StorageId -- storage to delete
//
HRESULT
CWiaMiniDriver::RemoveStorage(DWORD StorageId)
{
    DBG_FN("CWiaMiniDriver::RemoveStorage");
    
    HRESULT hr = S_OK;

    //
    // If the lower 16 bits of the storage id is 0xffff, an entire physical store
    // was removed--match only the upper 16 bits of the storage id
    //
    DWORD StorageIdMask = PTP_STORAGEID_ALL;
    if ((StorageId & PTP_STORAGEID_LOGICAL) == PTP_STORAGEID_LOGICAL)
    {
        StorageIdMask = PTP_STORAGEID_PHYSICAL;
        StorageId &= StorageIdMask;
    }

    //
    // Traverse the driver item tree depth-first looking for objects that were on
    // the removed storage
    //
    CWiaArray<IWiaDrvItem*> ItemStack;
    IWiaDrvItem *pCurrent = NULL;
    IWiaDrvItem *pChild = NULL;
    IWiaDrvItem *pSibling = NULL;
    
    if (m_pDrvItemRoot)
    {
        hr = m_pDrvItemRoot->GetFirstChildItem(&pCurrent);
        if (FAILED(hr))
        {
            wiauDbgError("RemoveStorage", "GetFirstChildItem failed");
            return hr;
        }
    }
    else
    {
        wiauDbgWarning("RemoveStorage", "Tree is not built yet (m_pDrvItemRoot is NULL)");
        pCurrent = NULL;
    }

    while (pCurrent)
    {
        hr = pCurrent->GetFirstChildItem(&pChild);
        
        //
        // GetFirstChildItem returns E_INVALIDARG if there are no child items
        //
        if (FAILED(hr) && hr != E_INVALIDARG)
        {
            wiauDbgError("RemoveStorage", "GetFirstChildItem failed");
            return hr;
        }

        //
        // Children exist, so traverse down the tree
        //
        if (hr != E_INVALIDARG && pChild)
        {
            if (!ItemStack.Push(pCurrent))
            {
                wiauDbgError("RemoveStorage", "memory allocation failed");
                return E_OUTOFMEMORY;
            }
            pCurrent = pChild;
            pChild = NULL;
        }

        //
        // No children, so look for siblings and potentially delete the current driver item
        //
        else
        {
            //
            // Loop through all of the siblings
            //
            while (TRUE)
            {
                hr = pCurrent->GetNextSiblingItem(&pSibling);
                if (FAILED(hr))
                {
                    wiauDbgError("RemoveStorage", "GetNextSiblingItem failed");
                    return hr;
                }

                //
                // See if the item is on the storage which was removed
                //
                PDRVITEM_CONTEXT pDrvItemContext;
                hr = pCurrent->GetDeviceSpecContext((BYTE **) &pDrvItemContext);
                if (FAILED(hr))
                {
                    wiauDbgError("RemoveStorage", "GetDeviceSpecContext failed");
                    return hr;
                }

                if ((pDrvItemContext->pObjectInfo->m_StorageId & StorageIdMask) == StorageId)
                {
                    //
                    // Remove the item
                    //
                    hr = RemoveObject(pDrvItemContext->pObjectInfo->m_ObjectHandle);
                    if (FAILED(hr))
                    {
                        wiauDbgError("RemoveStorage", "RemoveObject failed");
                        return hr;
                    }
                }

                //
                // Found a sibling, so go to the top and look for children
                //
                if (pSibling)
                {
                    pCurrent = pSibling;
                    pSibling = NULL;
                    break;
                }

                //
                // No sibling, so pop up a level
                //
                else
                {
                    if (ItemStack.GetSize() > 0)
                    {
                        if (!ItemStack.Pop(pCurrent))
                        {
                            wiauDbgError("RemoveStorage", "Pop failed");
                            return E_FAIL;
                        }
                    }
                    
                    //
                    // No more levels to pop, so the loop is done
                    //
                    else
                    {
                        pCurrent = NULL;
                        break;
                    }
                }
            }
        }
    }

    //
    // Remove the store from the appropriate arrays
    //
    for (int count = 0; count < m_StorageIds.GetSize(); count++)
    {
        if ((m_StorageIds[count] & StorageIdMask) == StorageId)
        {
            m_StorageIds.RemoveAt(count);
            m_StorageInfos.RemoveAt(count);
            m_DcimHandle.RemoveAt(count);
            count--;
        }
    }


    return hr;
}

//
// This function updates the value for a property
//
// Input:
//   PropCode -- property code that was updated
//
HRESULT
CWiaMiniDriver::DevicePropChanged(WORD PropCode)
{
    DBG_FN("CWiaMiniDriver::DevicePropChanged");

    HRESULT hr = S_OK;

    int idx = m_DeviceInfo.m_SupportedProps.Find(PropCode);
    if (idx < 0)
    {
        wiauDbgWarning("DevicePropChanged", "prop code not found %d", PropCode);
        return hr;
    }

    hr = m_pPTPCamera->GetDevicePropValue(PropCode, &m_PropDescs[idx]);
    if (FAILED(hr))
    {
        wiauDbgError("DevicePropChanged", "GetDevicePropValue failed");
        return hr;
    }

    return hr;
}

//
// This function updates the object info for an object
//
// Input:
//   ObjectHandle -- the object whose ObjectInfo needs updating
//
HRESULT
CWiaMiniDriver::ObjectInfoChanged(DWORD ObjectHandle)
{
    DBG_FN("CWiaMiniDriver::ObjectInfoChanged");
    
    HRESULT hr = S_OK;


    //
    // Find the driver item for the object handle.
    //
    IWiaDrvItem *pDrvItem = m_HandleItem.Lookup(ObjectHandle);
    if (!pDrvItem)
    {
        wiauDbgError("ObjectInfoChanged", "tried to update object that doesn't exist");
        return S_FALSE;
    }

    PDRVITEM_CONTEXT pDrvItemContext;
    hr = pDrvItem->GetDeviceSpecContext((BYTE **) &pDrvItemContext);
    if (FAILED(hr))
    {
        wiauDbgError("ObjectInfoChanged", "GetDeviceSpecContext failed");
        return hr;
    }

    hr = m_pPTPCamera->GetObjectInfo(ObjectHandle, pDrvItemContext->pObjectInfo);
    if (FAILED(hr))
    {
        wiauDbgError("ObjectInfoChanged", "GetObjectInfo failed");
        return hr;
    }

    return hr;
}

//
// This function marks a storage as full
//
// Input:
//   StorageId -- the storage to be marked
//
HRESULT
CWiaMiniDriver::StorageFull(DWORD StorageId)
{
    DBG_FN("CWiaMiniDriver::StorageFull");
    
    HRESULT hr = S_OK;

    INT index = m_StorageIds.Find(StorageId);
    if (index < 0)
    {
        wiauDbgError("StorageFull", "storage id not found");
        return S_FALSE;
    }

    CPtpStorageInfo *pStorageInfo = &m_StorageInfos[index];

    pStorageInfo->m_FreeSpaceInBytes = 0;
    pStorageInfo->m_FreeSpaceInImages = 0;
    
    //
    // Signal that the TakePicture command is complete, if the driver was waiting for one
    //
    if (!SetEvent(m_TakePictureDoneEvent))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "EventCallbackDispatch", "SetEvent failed");
        return hr;
    }

    return hr;
}

//
// This function updates a StorageInfo
//
// Input:
//   StorageId -- the storage id to be updated
//
HRESULT
CWiaMiniDriver::StorageInfoChanged(DWORD StorageId)
{
    DBG_FN("CWiaMiniDriver::StorageInfoChanged");
    
    HRESULT hr = S_OK;
    
    INT index = m_StorageIds.Find(StorageId);
    if (index < 0)
    {
        wiauDbgError("StorageInfoChanged", "storage id not found");
        return S_FALSE;
    }

    CPtpStorageInfo *pStorageInfo = &m_StorageInfos[index];

    hr = m_pPTPCamera->GetStorageInfo(StorageId, pStorageInfo);
    if (FAILED(hr))
    {
        wiauDbgError("StorageInfoChanged", "GetStorageInfo failed");
        return hr;
    }

    return hr;
}

//
// This function processes the CaptureComplete event
//
// Input:
//   StorageId -- the storage id to be updated
//
HRESULT
CWiaMiniDriver::CaptureComplete()
{
    DBG_FN("CWiaMiniDriver::CaptureComplete");
    
    HRESULT hr = S_OK;

    //
    // Signal that the TakePicture command is complete
    //
    if (!SetEvent(m_TakePictureDoneEvent))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "EventCallbackDispatch", "SetEvent failed");
        return hr;
    }

    return hr;
}

//
// This function posts a vendor defined event
//
// Input:
//   EventCode -- the event code
//
HRESULT
CWiaMiniDriver::PostVendorEvent(WORD EventCode)
{
    DBG_FN("CWiaMiniDriver::PostVendorEvent");
    
    HRESULT hr = S_OK;

    CVendorEventInfo *pEventInfo = NULL;

    pEventInfo = m_VendorEventMap.Lookup(EventCode);
    if (pEventInfo)
    {
        hr = wiasQueueEvent(m_bstrDeviceId, pEventInfo->pGuid, NULL);
        if (FAILED(hr))
        {
            wiauDbgError("PostVendorEvent", "wiasQueueEvent failed");
            return hr;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\factory.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    factory.h

Abstract:

    Header file that declares CClassFactory object

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef __FACTORY_H_
#define __FACTORY_H_


class CClassFactory : public IClassFactory
{
public:

    CClassFactory();

    ~CClassFactory();

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);

    STDMETHOD_(ULONG, AddRef) ();

    STDMETHOD_(ULONG, Release) ();

    STDMETHOD(CreateInstance)(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj);

    STDMETHOD(LockServer)(BOOL fLock);

    static HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, void** ppv);
    static HRESULT RegisterAll();
    static HRESULT UnregisterAll();
    static HRESULT CanUnloadNow(void);
    static  LONG    s_Locks;
    static  LONG    s_Objects;

private:
    ULONG   m_Refs;
};

#endif // __FACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\jpegutil.cpp ===
/***********************************************************************
 *
 * JPEG decompression utility functions
 *
 *   Implement (1) JPEG memory data source
 *             (2) JPEG error manager using setjmp/longjmp
 *
 *   Author : Indy Zhu    [indyz]
 *   Date   : 5/20/98
 *  
 ***********************************************************************/

#include "pch.h"

#include <setjmp.h>

//
// Workaround for redefinition of INT32
//

#define   XMD_H  1

//
// Header file for JPEG library
//

extern "C"
{
#include "jpeglib.h"
}
#include "utils.h"

//
// Buf source manager definition
//

typedef struct _buf_source_mgr
{
    struct jpeg_source_mgr  pub;

    //
    // Fields specific to buf_source_mgr
    //

    LPBYTE                  pJPEGBlob;
    DWORD                   dwSize;   
} buf_source_mgr;

//
// Jump error manager definition
//

typedef struct _jmp_error_mgr
{
    struct jpeg_error_mgr  pub;

    //
    // Private fields for jump error manager
    //

    jmp_buf                stackContext;
} jmp_error_mgr;

/******************************************************************************\
*
* init_source()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
init_source(
           j_decompress_ptr       pDecompInfo)
{
    //
    // No working necessary here
    //
}

/******************************************************************************\
*
* fill_input_buffer()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static boolean __cdecl
fill_input_buffer(
                 j_decompress_ptr       pDecompInfo)
{
    buf_source_mgr        *pBufSrcMgr;

    //
    // Recover buf source manager itself
    //

    pBufSrcMgr = (buf_source_mgr *)pDecompInfo->src;

    //
    // buf_source_mgr can only fire one shot    
    //

    pBufSrcMgr->pub.next_input_byte = pBufSrcMgr->pJPEGBlob;
    pBufSrcMgr->pub.bytes_in_buffer = pBufSrcMgr->dwSize;

    return(TRUE);
}

/******************************************************************************\
*
* skip_input_data()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
skip_input_data(
               j_decompress_ptr       pDecompInfo, 
               long                   lBytes)
{
    buf_source_mgr        *pBufSrcMgr;

    //
    // For buf source manager, it is very easy to implement
    //

    if (lBytes > 0)
    {

        pBufSrcMgr = (buf_source_mgr *)pDecompInfo->src;

        pBufSrcMgr->pub.next_input_byte += lBytes;
        pBufSrcMgr->pub.bytes_in_buffer -= lBytes;
    }
}

/******************************************************************************\
*
* term_source()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
term_source(
           j_decompress_ptr       pDecompInfo)
{
}

/******************************************************************************\
*
* jpeg_buf_src()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
jpeg_buf_src(
            j_decompress_ptr       pDecompInfo,
            LPBYTE                 pJPEGBlob, 
            DWORD                  dwSize)
{
    buf_source_mgr        *pBufSrcMgr;

    //
    // Allocate memory for the buf source manager
    //

    pBufSrcMgr = (buf_source_mgr *)
                 (pDecompInfo->mem->alloc_small)((j_common_ptr)pDecompInfo, 
                                                 JPOOL_PERMANENT, 
                                                 sizeof(buf_source_mgr));

    //
    // Record the pJPEGBlob
    //

    pBufSrcMgr->pJPEGBlob = pJPEGBlob;
    pBufSrcMgr->dwSize    = dwSize;

    //
    // Fill in the function pointers
    //

    pBufSrcMgr->pub.init_source       = init_source;
    pBufSrcMgr->pub.fill_input_buffer = fill_input_buffer;
    pBufSrcMgr->pub.skip_input_data   = skip_input_data;
    pBufSrcMgr->pub.resync_to_restart = jpeg_resync_to_restart;
    pBufSrcMgr->pub.term_source       = term_source;

    //
    // Initialize the pointer into the buffer
    //

    pBufSrcMgr->pub.bytes_in_buffer = 0;
    pBufSrcMgr->pub.next_input_byte = NULL;

    //
    // Ask the decompression context to remember it
    //

    pDecompInfo->src = (struct jpeg_source_mgr *)pBufSrcMgr;
}

/******************************************************************************\
*
* jmp_error_exit()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

static void __cdecl
jmp_error_exit(
              j_common_ptr           pDecompInfo)
{
    jmp_error_mgr         *pJmpErrorMgr;

    //
    // Get the jump error manager back
    //

    pJmpErrorMgr = (jmp_error_mgr *)pDecompInfo->err;

    //
    // Display the error message
    //

#ifdef _DEBUG
    (pDecompInfo->err->output_message)(pDecompInfo);
#endif

    //
    // Recover the original stack
    //

    longjmp(pJmpErrorMgr->stackContext, 1);
}

/******************************************************************************\
*
* jpeg_jmp_error()
*
* Arguments:
*
* Return Value:
*
*    Status
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

struct jpeg_error_mgr *
jpeg_jmp_error(
              jmp_error_mgr         *pJmpErrorMgr)
{
    //
    // Initialize the public part
    //

    jpeg_std_error(&pJmpErrorMgr->pub);

    //
    // Set up jump error manager exit method
    //

    pJmpErrorMgr->pub.error_exit = jmp_error_exit;

    return((jpeg_error_mgr *)pJmpErrorMgr);
}

/******************************************************************************\
*
* GetJpegDimensions
*
* Arguments:
*   pJpeg   -- jpeg file in memory. It could be in JFIF and EXIF
*          format
*   JpegSize -- the jpeg file size
*   pWidth  -- to return the image width in pixels
*   pHeight -- to return the image height in pixels
*   pBitDepth -- to return the image bit depth.
*
* Return Value:
*
*    HRESULT
*
* History:
*
*    11/4/1998 Original Version
*
\******************************************************************************/

HRESULT
WINAPI
GetJpegDimensions(
                 BYTE    *pJpeg,
                 UINT   JpegSize,
                 UINT   *pWidth,
                 UINT   *pHeight,
                 UINT   *pBitDepth
                 )
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;
    int ret;

    //
    // Step 1 : Initialize JPEG session data-structure
    //

    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);

    //
    // Reserve the state of the current stack
    //

    if (setjmp(jpegErrMgr.stackContext))
    {

        //
        // JPEG lib will longjump here when there is an error
        //

        jpeg_destroy_decompress(&decompInfo);

        return(E_FAIL);
    }

    //
    // Step 2 : Specify the source of the compressed data
    //

    jpeg_buf_src(&decompInfo, pJpeg, JpegSize);

    //
    // Step 3 : Read JPEG file header information
    //

    ret = jpeg_read_header(&decompInfo, TRUE);

    //
    // Release the decompression context
    //

    jpeg_destroy_decompress(&decompInfo);

    //
    // Fill in the dimension info for the caller
    //

    *pWidth   = decompInfo.image_width;
    *pHeight  = decompInfo.image_height;
    *pBitDepth = 24;

    if (ret != JPEG_HEADER_OK)
    {
        return(E_FAIL);
    }

    return S_OK;
}

//
// This function converts a jpeg file in memory to DIB bitmap
//
// Input:
//   pJpeg   -- jpeg file in memory. JFIF or EXIF are supported
//   JpegSize -- the jpeg file size
//   DIBBmpSize -- DIB bitmap buffer size
//   pDIBBmp    -- DIB bitmap buffer
//   LineSize    -- desitnation scanline size in bytes
//   MaxLines    -- maximum scanlines per transfer
//
HRESULT
WINAPI
Jpeg2DIBBitmap(
              BYTE *pJpeg,
              UINT JpegSize,
              BYTE *pDIBBmp,
              UINT DIBBmpSize,
              UINT LineSize,
              UINT MaxLines
              )
{
    struct jpeg_decompress_struct  decompInfo;
    jmp_error_mgr                  jpegErrMgr;


    //
    // Parameter checking
    //
    if (!pJpeg || !JpegSize || !DIBBmpSize || !pDIBBmp || !LineSize)
        return E_INVALIDARG;

    //
    // Step 1 : Initialize JPEG session data-structure
    //

    decompInfo.err = jpeg_jmp_error(&jpegErrMgr);
    jpeg_create_decompress(&decompInfo);

    //
    // Reserve the state of the current stack
    //

    if (setjmp(jpegErrMgr.stackContext))
    {

        //
        // JPEG lib will longjump here when there is an error
        //

        jpeg_destroy_decompress(&decompInfo);

        return(E_FAIL);
    }

    //
    // Step 2 : Specify the source of the compressed data
    //

    jpeg_buf_src(&decompInfo, pJpeg, JpegSize);

    //
    // Step 3 : Read JPEG file header information
    //

    if (jpeg_read_header(&decompInfo, TRUE) != JPEG_HEADER_OK)
    {

        jpeg_destroy_decompress(&decompInfo);
        return(E_FAIL);
    }

    //
    // Step 4 : Set parameter for decompression
    // Defaults are OK for this occasssion
    // Specify the JCS_BGR output colorspace so that the returned
    // decompressed image has the same format as DIB. Also, it forces
    // the decompressor to return a 24-bits RGB colors image
    //

    decompInfo.out_color_space = JCS_BGR;

    //
    // Calculate DIB scan line size, assuming 24bits color.
    //
    HRESULT hr;

    hr = S_OK;

    //
    // Step 5 : Start the real action
    //

    jpeg_start_decompress(&decompInfo);

    //
    // Step 6 : Acquire the scan line
    //

    while (S_OK == hr &&
           decompInfo.output_scanline < decompInfo.output_height)
    {
        if (DIBBmpSize >= LineSize)
        {
            //
            // Decompress line by line. Ignore the MaxLines since
            // we do not do more than one line at a time.
            //
            jpeg_read_scanlines(&decompInfo, &pDIBBmp, 1);
            pDIBBmp -= LineSize;
            DIBBmpSize -= LineSize;
        }
        else
        {
            //
            // The provided buffer is too small.
            //
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    //
    // Step 7 : Finish the job
    //

    if (SUCCEEDED(hr))
    {
        jpeg_finish_decompress(&decompInfo);
    }
    else
    {
        jpeg_abort_decompress(&decompInfo);
    }
    //
    // Step 8 : Garbage collection
    //

    jpeg_destroy_decompress(&decompInfo);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\imgitem.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    imgitem.cpp

Abstract:

    This module implements image item related function of CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

//
// Minimum data call back transfer buffer size
//
const LONG MIN_BUFFER_SIZE   = 0x8000;

//
// Arrays used for setting up valid value lists for properties
//
LONG g_TymedArray[] = {
    TYMED_FILE,
    TYMED_CALLBACK
};

//
// This function initializes the item's properties
// Input:
//  pWiasContext    -- wias service context
//  lFlags      -- misc flags
//  plDevErrVal -- to return device error;
//
HRESULT
CWiaMiniDriver::InitItemProperties(BYTE *pWiasContext)
{
    DBG_FN("CWiaMiniDriver::InitItemProperties");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    LONG ItemType = 0;
    FORMAT_INFO *pFormatInfo = NULL;
    BSTR bstrFileExt = NULL;
    CLSID *pImageFormats = NULL;


    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "wiasGetItemType failed");
        return hr;
    }

    BOOL bBitmap = FALSE;   // Indicates that preferred format is bitmap
    LONG lBytesPerLine = 0;

    //
    // There are no properties for storage items. In fact, there are no driver items created for
    // stores.
    //
    if (ItemType & WiaItemTypeStorage)
        return hr;

    DRVITEM_CONTEXT *pItemCtx;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx, NULL);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "WiasContextToItemContext failed");
        return hr;
    }

    //
    // Set up properties that are used for all item types
    //
    CWiauPropertyList ItemProps;
    CPtpObjectInfo *pObjectInfo = pItemCtx->pObjectInfo;

    const INT NUM_ITEM_PROPS = 24;
    hr = ItemProps.Init(NUM_ITEM_PROPS);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "Init failed");
        return hr;
    }

    INT index;

    //
    // WIA_IPA_ITEM_TIME
    //
    SYSTEMTIME SystemTime;
    hr = GetObjectTime(pObjectInfo, &SystemTime);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "GetObjectTime failed");
        return hr;
    }

    hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_TIME, WIA_IPA_ITEM_TIME_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;

    ItemProps.SetCurrentValue(index, &SystemTime);

    //
    // WIA_IPA_ACCESS_RIGHTS
    //
    LONG lProtection;
    hr = IsObjectProtected(pObjectInfo, lProtection);
    if (FAILED(hr))
    {
        wiauDbgError("InitItemProperties", "IsObjectProtected failed");
        return hr;
    }

    hr = ItemProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_FLAG | WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;

    //
    // If device does not support delete command, access rights are always Read-Only
    //
    if (m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_DELETEOBJECT) < 0)
    {
        lProtection = WIA_PROP_READ;
        ItemProps.SetCurrentValue(index, lProtection);
    }
    else
    {
        //
        // If device supports the SetObjectProtection command, item access rights is r/w
        //
        if (m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_SETOBJECTPROTECTION) >= 0)
        {
            ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_FLAG);
            ItemProps.SetValidValues(index, lProtection, lProtection, WIA_ITEM_RWD);
        }
        else
        {
            ItemProps.SetCurrentValue(index, lProtection);
        }
    }

    pFormatInfo = FormatCodeToFormatInfo(pObjectInfo->m_FormatCode);

    //
    // WIA_IPA_FILENAME_EXTENSION
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_FILENAME_EXTENSION, WIA_IPA_FILENAME_EXTENSION_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;
    if(pFormatInfo->ExtString && pFormatInfo->ExtString[0]) {
        bstrFileExt = SysAllocString(pFormatInfo->ExtString);
    } else {
        if(pObjectInfo->m_cbstrExtension.Length()) {
            bstrFileExt = SysAllocString(pObjectInfo->m_cbstrExtension.String());
        }
    }
    ItemProps.SetCurrentValue(index, bstrFileExt);
    
    //
    // Set up properties common to files
    //
    if (ItemType & WiaItemTypeFile)
    {
        // 
        // WIA_IPA_PREFERRED_FORMAT
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PREFERRED_FORMAT, WIA_IPA_PREFERRED_FORMAT_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pFormatInfo->FormatGuid);

        bBitmap = IsEqualGUID(WiaImgFmt_BMP, *pFormatInfo->FormatGuid) ||
                IsEqualGUID(WiaImgFmt_MEMORYBMP, *pFormatInfo->FormatGuid);

        // 
        // WIA_IPA_FORMAT
        //
        // For images, BMP may also be added below
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR,
                                        WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_LIST);
        ItemProps.SetCurrentValue(index, pFormatInfo->FormatGuid);
        ItemProps.SetValidValues(index, pFormatInfo->FormatGuid, pFormatInfo->FormatGuid,
                                    1, &pFormatInfo->FormatGuid);
        //
        // WIA_IPA_COMPRESSION
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_COMPRESSION, WIA_IPA_COMPRESSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_COMPRESSION_NONE);

        // 
        // WIA_IPA_TYMED
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_TYMED, WIA_IPA_TYMED_STR,
                                        WIA_PROP_RW, WIA_PROP_LIST);
        if (FAILED(hr)) goto failure;
        ItemProps.SetValidValues(index, TYMED_FILE, TYMED_FILE,
                                    sizeof(g_TymedArray) / sizeof(g_TymedArray[0]), g_TymedArray);

        // 
        // WIA_IPA_ITEM_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_SIZE, WIA_IPA_ITEM_SIZE_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        if (bBitmap) {
            lBytesPerLine = ((pObjectInfo->m_ImagePixWidth * pObjectInfo->m_ImageBitDepth + 31) & ~31) / 8;
            ItemProps.SetCurrentValue(index, (LONG) (lBytesPerLine * pObjectInfo->m_ImagePixHeight));
        }
        else
            ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_CompressedSize);

        // 
        // WIA_IPA_MIN_BUFFER_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_MIN_BUFFER_SIZE, WIA_IPA_MIN_BUFFER_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        LONG minBufSize;
        if (!bBitmap && pObjectInfo->m_CompressedSize > 0)
            minBufSize = min(MIN_BUFFER_SIZE, pObjectInfo->m_CompressedSize);
        else
            minBufSize = MIN_BUFFER_SIZE;
        ItemProps.SetCurrentValue(index, minBufSize);
    }

    //
    // Set up the image-only properties
    //
    if (ItemType & WiaItemTypeImage)
    {
        //
        // WIA_IPA_DATATYPE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_DATATYPE, WIA_IPA_DATATYPE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        if(pObjectInfo->m_ImageBitDepth <= 8) {
            ItemProps.SetCurrentValue(index, (LONG) WIA_DATA_GRAYSCALE);
        } else {
            ItemProps.SetCurrentValue(index, (LONG) WIA_DATA_COLOR);
        }

        //
        // WIA_IPA_DEPTH
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_DEPTH, WIA_IPA_DEPTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ImageBitDepth);

        //
        // WIA_IPA_FORMAT
        //
        // If the image format is something that can be converted, change the access to
        // read/write and add BMP to the valid value list.
        //
        if (pFormatInfo->FormatGuid) 
        {
            index = ItemProps.LookupPropId(WIA_IPA_FORMAT);
            ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_LIST);
            pImageFormats = new CLSID[3];
            if(!pImageFormats) {
                wiauDbgError("InitItemProperties", "failed to allocate 3 GUIDs");
                hr = E_OUTOFMEMORY;
                goto failure;
            }
            pImageFormats[0] = *pFormatInfo->FormatGuid;
            pImageFormats[1] = WiaImgFmt_BMP;
            pImageFormats[2] = WiaImgFmt_MEMORYBMP;
            ItemProps.SetValidValues(index, pFormatInfo->FormatGuid, pFormatInfo->FormatGuid,
                                     3,
                                     &pImageFormats);
        }

        //
        // WIA_IPA_CHANNELS_PER_PIXEL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_CHANNELS_PER_PIXEL, WIA_IPA_CHANNELS_PER_PIXEL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) (pObjectInfo->m_ImageBitDepth == 8 ? 1 : 3));

        //
        // WIA_IPA_BITS_PER_CHANNEL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_BITS_PER_CHANNEL, WIA_IPA_BITS_PER_CHANNEL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) 8);

        //
        // WIA_IPA_PLANAR
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PLANAR, WIA_IPA_PLANAR_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_PACKED_PIXEL);

        //
        // WIA_IPA_PIXELS_PER_LINE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PIXELS_PER_LINE, WIA_IPA_PIXELS_PER_LINE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ImagePixWidth);

        //
        // WIA_IPA_BYTES_PER_LINE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_BYTES_PER_LINE, WIA_IPA_BYTES_PER_LINE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        if (bBitmap)
            lBytesPerLine;
        else
            ItemProps.SetCurrentValue(index, (LONG) 0);

        //
        // WIA_IPA_NUMBER_OF_LINES
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_NUMBER_OF_LINES, WIA_IPA_NUMBER_OF_LINES_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ImagePixHeight);

        //
        // WIA_IPC_SEQUENCE
        //
        if (pObjectInfo->m_SequenceNumber > 0)
        {
            hr = ItemProps.DefineProperty(&index, WIA_IPC_SEQUENCE, WIA_IPC_SEQUENCE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            if (FAILED(hr)) goto failure;
            ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_SequenceNumber);
        }

        //
        // WIA_IPC_TIMEDELAY
        //
        // This property needs to be populated from the AssociationDesc field in the parent's ObjectInfo
        // structure, but only if the parent's AssociationType field is TimeSequence.

        // WIAFIX-10/3/2000-davepar Implement this property
    }

    //
    // Set up properties common to image and video items that have
    // thumbnails
    //
    if (ItemType & (WiaItemTypeImage | WiaItemTypeVideo) && pObjectInfo->m_ThumbPixWidth)
    {
        //
        // WIA_IPC_THUMBNAIL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (BYTE *) NULL, 0);

        //
        // WIA_IPC_THUMB_WIDTH
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ThumbPixWidth);

        //
        // WIA_IPC_THUMB_HEIGHT
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) pObjectInfo->m_ThumbPixHeight);

    }

    //
    // Last step: send all the properties to WIA
    //
    hr = ItemProps.SendToWia(pWiasContext);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "InitItemProperties", "SendToWia failed");
        goto failure;
    }

    if (bstrFileExt)
        SysFreeString(bstrFileExt);

    delete [] pImageFormats;

    return hr;

    //
    // Any failures from DefineProperty will end up here
    //
    failure:

        delete [] pImageFormats;
    
        if (bstrFileExt)
            SysFreeString(bstrFileExt);

        wiauDbgErrorHr(hr, "InitItemProperties", "DefineProperty failed");
        return hr;
}

//
// This function determines the protection status (whether an object can be
// deleted or written to) of an object on the device.
//
// Input:
//   pObjectInfo -- pointer to the ObjectInfo structure
// Output:
//   bProtected -- indicates whether the object is protected
//
HRESULT
CWiaMiniDriver::IsObjectProtected(
    CPtpObjectInfo *pObjectInfo,
    LONG &lProtection)
{
    DBG_FN("CWiaMiniDriver::IsObjectProtected");

    HRESULT hr = S_OK;
    lProtection = WIA_ITEM_READ;

    if (!pObjectInfo)
    {
        wiauDbgError("ObjectProtected", "invalid arg");
        return E_INVALIDARG;
    }

    if (pObjectInfo->m_ProtectionStatus == PTP_PROTECTIONSTATUS_READONLY)
        return hr;

    //
    // Check the protection status of the store as well
    //
    INT storeIndex = m_StorageIds.Find(pObjectInfo->m_StorageId);
    if (storeIndex < 0)
    {
        wiauDbgWarning("ObjectProtected", "couldn't find the object's store");
        return hr;
    }

    switch (m_StorageInfos[storeIndex].m_AccessCapability)
    {
    case PTP_STORAGEACCESS_RWD:
        lProtection = WIA_ITEM_RWD;
        break;

    case PTP_STORAGEACCESS_R:
        lProtection = WIA_ITEM_READ;
        break;

    case PTP_STORAGEACCESS_RD:
        lProtection = WIA_ITEM_RD;
        break;

    default:
        //
        // Not a fatal error, but this is an unknown access capability. Use read-only.
        //
        wiauDbgError("ObjectProtected", "unknown storage access capability");
        lProtection = WIA_ITEM_READ;
        break;
    }

    return hr;
}

//
// This function gets the object time and converts it to a system time
//
// Input:
//  pObjNode  -- the object
//  pSystemTime -- to receive the object time
// Output:
//  HRESULT
//
HRESULT
CWiaMiniDriver::GetObjectTime(
    CPtpObjectInfo *pObjectInfo,
    SYSTEMTIME  *pSystemTime
    )
{
    DBG_FN("CWiaMiniDriver::GetObjectTime");

    HRESULT hr = S_OK;

    CBstr *pTimeStr = NULL;

    if (!pObjectInfo || !pSystemTime)
    {
        wiauDbgError("GetObjectTime", "invalid arg");
        return E_INVALIDARG;
    }

    //
    // Try to use the modification date, then the capture date
    //
    if (pObjectInfo->m_cbstrModificationDate.Length() > 0)
        pTimeStr = &pObjectInfo->m_cbstrModificationDate;

    else if (pObjectInfo->m_cbstrCaptureDate.Length() > 0)
        pTimeStr = &pObjectInfo->m_cbstrCaptureDate;


    //
    // See if a valid date/time was found, otherwise use system time
    //
    if (pTimeStr)
    {
        hr = PtpTime2SystemTime(pTimeStr, pSystemTime);
        if (FAILED(hr))
        {
            wiauDbgError("GetObjectTime", "PtpTime2SystemTime failed");
            return hr;
        }
    }
    else
    {
        GetLocalTime(pSystemTime);
    }

    return hr;
}

//
// This function reads item properties. In this situation, only the thumbnail
// properties are important.
//
// Input:
//   pWiasContext -- wia service context
//   NumPropSpecs -- number of properties to read
//   pPropSpecs   -- what properties to read
//
HRESULT
CWiaMiniDriver::ReadItemProperties(
    BYTE    *pWiasContext,
    LONG    NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    DBG_FN("CWiaMiniDriver::ReadItemProperties");

    HRESULT hr = S_OK;

    LONG ItemType = 0;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("ReadItemProperties", "wiasGetItemType failed");
        return hr;
    }

    PDRVITEM_CONTEXT pItemCtx = NULL;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        wiauDbgError("ReadItemProperties", "WiasContextToItemContext failed");
        return hr;
    }

    //
    // For all items (except the root or stores), update the item time if requested. The time may
    // have been updated by an ObjectInfoChanged event.
    //
    if (IsItemTypeFolder(ItemType) || ItemType & WiaItemTypeFile)
    {
        if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_ITEM_TIME))
        {
            SYSTEMTIME SystemTime;
            hr = GetObjectTime(pItemCtx->pObjectInfo, &SystemTime);
            if (FAILED(hr))
            {
                wiauDbgError("ReadItemProperties", "GetObjectTime failed");
                return hr;
            }

            PROPVARIANT propVar;
            PROPSPEC    propSpec;
            propVar.vt = VT_VECTOR | VT_UI2;
            propVar.caui.cElems = sizeof(SystemTime) / sizeof(WORD);
            propVar.caui.pElems = (WORD *) &SystemTime;
            propSpec.ulKind = PRSPEC_PROPID;
            propSpec.propid = WIA_IPA_ITEM_TIME;
            hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar );
            if (FAILED(hr))
            {
                wiauDbgError("ReadItemProperties", "wiasWriteMultiple failed");
                return hr;
            }
        }
    }

    if(ItemType & WiaItemTypeImage && pItemCtx->pObjectInfo->m_ImagePixWidth == 0) {
        // image geometry is missing -- see if this is what we are asked 
        PROPID propsToUpdate[] = {
            WIA_IPA_PIXELS_PER_LINE,
            WIA_IPA_NUMBER_OF_LINES
            };
        
        if(wiauPropsInPropSpec(NumPropSpecs, pPropSpecs, sizeof(propsToUpdate) / sizeof(PROPID), propsToUpdate))
        {
            // we can deal with any image as long as GDI+ understands it
            UINT NativeImageSize = pItemCtx->pObjectInfo->m_CompressedSize;
            UINT width, height, depth;

            wiauDbgWarning("ReadImageProperties", "Retrieving missing geometry! Expensive!");
                
            //
            // Allocate memory for the native image
            //
            BYTE *pNativeImage = new BYTE[NativeImageSize];
            if(pNativeImage == NULL) {
                return E_OUTOFMEMORY;
            }

            //
            // Get the data from the camera
            //
            hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle,
                                             pNativeImage, &NativeImageSize,  (LPVOID) 0);
            if(hr == S_FALSE) {
                wiauDbgWarning("ReadItemProperties", "GetObjectData() cancelled");
                delete [] pNativeImage;
                return S_FALSE;
            }
            
            if(FAILED(hr)) {
                wiauDbgError("ReadItemProperties", "GetObjectData() failed");
                delete [] pNativeImage;
                return S_FALSE;
            }    

            //
            // get image geometry, discard native image
            //
            if(pItemCtx->pObjectInfo->m_FormatCode == PTP_FORMATCODE_IMAGE_EXIF ||
               pItemCtx->pObjectInfo->m_FormatCode == PTP_FORMATCODE_IMAGE_JFIF)
            {
                hr = GetJpegDimensions(pNativeImage, NativeImageSize, &width, &height, &depth);
            } else {
                hr = GetImageDimensions(pItemCtx->pObjectInfo->m_FormatCode, pNativeImage, NativeImageSize, &width, &height, &depth);
            }
            delete [] pNativeImage;
                
            if(FAILED(hr)) {
                wiauDbgError("ReadItemProperties", "failed to get image geometry from compressed image");
                return hr;
            }

            pItemCtx->pObjectInfo->m_ImagePixWidth = width;
            pItemCtx->pObjectInfo->m_ImagePixHeight = height;
            
            hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, width);
            if(FAILED(hr)) {
                wiauDbgError("ReadItemProperties", "failed to write image width");
                return hr;
            }
            
            hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, height);
            if(FAILED(hr)) {
                wiauDbgError("ReadItemProperties", "failed to set image height");
                return hr;
            }
        }
    }

    //
    // For images and video, update the thumbnail properties if requested
    //
    if (ItemType & (WiaItemTypeImage | WiaItemTypeVideo))
    {
        //
        // Get the thumbnail if requested to update any of the thumbnail properties and
        // the thumbnail is not already cached.
        //
        PROPID propsToUpdate[] = {
            WIA_IPC_THUMB_WIDTH,
            WIA_IPC_THUMB_HEIGHT,
            WIA_IPC_THUMBNAIL
            };

        if (wiauPropsInPropSpec(NumPropSpecs, pPropSpecs, sizeof(propsToUpdate) / sizeof(PROPID), propsToUpdate))
        {
            if (!pItemCtx->pThumb)
            {
                hr = CacheThumbnail(pItemCtx);
                if (FAILED(hr))
                {
                    wiauDbgError("ReadItemProperties", "CacheThumbnail failed");
                    return hr;
                }
            }

            //
            // Update the related thumbnail properties. Update the thumb width and height in case
            // the device didn't report them in the ObjectInfo structure (they are optional there).
            //
            PROPSPEC propSpecs[3];
            PROPVARIANT propVars[3];

            propSpecs[0].ulKind = PRSPEC_PROPID;
            propSpecs[0].propid = WIA_IPC_THUMB_WIDTH;
            propVars[0].vt = VT_I4;
            propVars[0].lVal = pItemCtx->pObjectInfo->m_ThumbPixWidth;

            propSpecs[1].ulKind = PRSPEC_PROPID;
            propSpecs[1].propid = WIA_IPC_THUMB_HEIGHT;
            propVars[1].vt = VT_I4;
            propVars[1].lVal = pItemCtx->pObjectInfo->m_ThumbPixHeight;

            propSpecs[2].ulKind = PRSPEC_PROPID;
            propSpecs[2].propid = WIA_IPC_THUMBNAIL;
            propVars[2].vt = VT_VECTOR | VT_UI1;
            propVars[2].caub.cElems = pItemCtx->ThumbSize;
            propVars[2].caub.pElems = pItemCtx->pThumb;

            hr = wiasWriteMultiple(pWiasContext, 3, propSpecs, propVars);
            if (FAILED(hr))
            {
                wiauDbgError("ReadItemProperties", "wiasWriteMultiple failed");
                delete pItemCtx->pThumb;
                pItemCtx->pThumb = NULL;
            }
        }
    }

    return hr;
}

//
// This function caches the thumbnail into the given DRVITEM_CONTEXT
//
// Input:
//   pItemCtx -- the designated DRVITEM_CONTEXT
//
HRESULT
CWiaMiniDriver::CacheThumbnail(PDRVITEM_CONTEXT pItemCtx)
{
    DBG_FN("CWiaMiniDriver::CacheThumbnail");

    HRESULT hr = S_OK;

    if (pItemCtx->pThumb)
    {
        wiauDbgError("CacheThumbnail", "thumbnail is already cached");
        return E_FAIL;
    }

    CPtpObjectInfo *pObjectInfo = pItemCtx->pObjectInfo;
    if (!pObjectInfo) {
        wiauDbgError("CacheThumbnail", "Object info pointer is null");
        return E_FAIL;
    }

    if (pObjectInfo->m_ThumbCompressedSize <= 0)
    {
        wiauDbgWarning("CacheThumbnail", "No thumbnail available for this item");
        return hr;
    }

    //
    // We have to load the thumbnail in its native format
    //
    BYTE *pNativeThumb;
    pNativeThumb = new BYTE[pObjectInfo->m_ThumbCompressedSize];
    if (!pNativeThumb)
    {
        wiauDbgError("CacheThumbnail", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    UINT size = pObjectInfo->m_ThumbCompressedSize;
    hr = m_pPTPCamera->GetThumb(pObjectInfo->m_ObjectHandle, pNativeThumb, &size);
    if (FAILED(hr))
    {
        wiauDbgError("CacheThumbnail", "GetThumb failed");
        delete []pNativeThumb;
        return hr;
    }

    //
    // Figure out what base image format the thumbnail is in. Note that BMP thumbnails
    // are not allowed currently.
    //
    BOOL bTiff = FALSE;
    BOOL bJpeg = FALSE;

    if (PTP_FORMATCODE_IMAGE_TIFF == pObjectInfo->m_ThumbFormat ||
        PTP_FORMATCODE_IMAGE_TIFFEP == pObjectInfo->m_ThumbFormat ||
        PTP_FORMATCODE_IMAGE_TIFFIT == pObjectInfo->m_ThumbFormat)
        bTiff = TRUE;

    else if (PTP_FORMATCODE_IMAGE_EXIF == pObjectInfo->m_ThumbFormat ||
             PTP_FORMATCODE_IMAGE_JFIF == pObjectInfo->m_ThumbFormat)
        bJpeg = TRUE;

    else
    {
        wiauDbgWarning("CacheThumbnail", "unknown thumbnail format");
        delete []pNativeThumb;
        return hr;
    }

    //
    // If the thumbnail format is JPEG or TIFF, get the real thumbnail
    // width and height from the header information.
    //
    UINT BitDepth;
    UINT width, height;
    if (bTiff)
    {
        hr = GetTiffDimensions(pNativeThumb,
                               pObjectInfo->m_ThumbCompressedSize,
                               &width,
                               &height,
                               &BitDepth);
    }

    else if (bJpeg)
    {
        hr  = GetJpegDimensions(pNativeThumb,
                                pObjectInfo->m_ThumbCompressedSize,
                                &width,
                                &height,
                                &BitDepth);
    }

    if (FAILED(hr))
    {
        wiauDbgError("CacheThumbnail", "get image dimensions failed");
        delete []pNativeThumb;
        return hr;
    }

    pObjectInfo->m_ThumbPixWidth  = width;
    pObjectInfo->m_ThumbPixHeight = height;

    //
    // Calculate the size of the headerless BMP and allocate space for it
    //
    ULONG LineSize;
    LineSize = GetDIBLineSize(pObjectInfo->m_ThumbPixWidth, 24);
    pItemCtx->ThumbSize = LineSize * pObjectInfo->m_ThumbPixHeight;
    pItemCtx->pThumb = new BYTE [pItemCtx->ThumbSize];
    if (!pItemCtx->pThumb)
    {
        wiauDbgError("CacheThumbnail", "memory allocation failure");
        delete []pNativeThumb;
        return E_OUTOFMEMORY;
    }

    //
    // Convert the thumbnail format to headerless BMP
    //
    if (bTiff)
    {
        hr = Tiff2DIBBitmap(pNativeThumb,
                            pObjectInfo->m_ThumbCompressedSize,
                            pItemCtx->pThumb + LineSize * (height - 1),
                            pItemCtx->ThumbSize,
                            LineSize,
                            0
                           );
    }
    else if (bJpeg)
    {
        hr = Jpeg2DIBBitmap(pNativeThumb,
                            pObjectInfo->m_ThumbCompressedSize,
                            pItemCtx->pThumb + LineSize * (height - 1),
                            pItemCtx->ThumbSize,
                            LineSize,
                            0
                           );
    }

    if (FAILED(hr))
    {
        wiauDbgError("CacheThumbnail", "conversion to bitmap failed");
        delete []pNativeThumb;
        delete []pItemCtx->pThumb;
        pItemCtx->pThumb = NULL;
        return hr;
    }

    delete []pNativeThumb;

    return hr;
}

//
// This function validates the given item properties.
//
// Input:
//   pWiasContext -- wia service context
//   NumPropSpecs -- number of properties to validate
//   pPropSpecs -- the properties
//
HRESULT
CWiaMiniDriver::ValidateItemProperties(
    BYTE    *pWiasContext,
    LONG    NumPropSpecs,
    const PROPSPEC *pPropSpecs,
    LONG ItemType
    )
{
    DBG_FN("CWiaMiniDriver::ValidateItemProperties");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    FORMAT_INFO *pFormatInfo = NULL;

    DRVITEM_CONTEXT *pItemCtx;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        wiauDbgError("ValidateItemProperties", "WiasContextToItemContext failed");
        return hr;
    }

    //
    // If access rights are changed, send the new value to the camera
    //
    // WIAFIX-10/3/2000-davepar To be 100% correct, a change in the store protection should
    // update the access rights for all of the items on the store. This could be done in response
    // to a StoreInfoChanged event.
    //
    if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_ACCESS_RIGHTS))
    {
        LONG rights;
        hr = wiasReadPropLong(pWiasContext, WIA_IPA_ACCESS_RIGHTS, &rights, NULL, TRUE);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateItemProperties", "wiasReadPropLong");
            return hr;
        }

        WORD objProt = (rights == WIA_ITEM_READ) ? PTP_PROTECTIONSTATUS_READONLY : PTP_PROTECTIONSTATUS_NONE;
        hr = m_pPTPCamera->SetObjectProtection(pItemCtx->pObjectInfo->m_ObjectHandle, objProt);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateItemProperties", "SetObjectProtection failed");
            return hr;
        }
    }

    //
    // Update the valid formats by calling a WIA service function
    //
    BOOL bFormatChanged = FALSE;

    if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_TYMED))
    {
        WIA_PROPERTY_CONTEXT PropContext;
        hr = wiasCreatePropContext(NumPropSpecs, (PROPSPEC*) pPropSpecs, 0, NULL, &PropContext);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateItemProperties", "wiasCreatePropContext failed");
            return hr;
        }

        hr = wiasUpdateValidFormat(pWiasContext, &PropContext, (IWiaMiniDrv*) this);
        if (FAILED(hr))
        {
            wiauDbgError("ValidateItemProperties", "wiasUpdateValidFormat failed");
            return hr;
        }

        hr = wiasFreePropContext(&PropContext);
        if (FAILED(hr)) {
            wiauDbgError("ValidateItemProperties", "wiasFreePropContext failed");
            return hr;
        }

        bFormatChanged = TRUE;
    }

    //
    // The only property change that needs to be validated is a change of format on an image
    // item. In that case, the item's size and bytes per line, and file extension need to be updated.
    //
    if (ItemType & WiaItemTypeImage &&
        (bFormatChanged || wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_FORMAT)))
    {

        if(pItemCtx->pObjectInfo->m_ImagePixWidth == 0) {
            // one of those cameras
            GUID fmt;
            hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &fmt, NULL, false);
            if(FAILED(hr)) {
                wiauDbgError("ValidateItemProperies", "Failed to retrieve new format GUID");
            }
            if(fmt == WiaImgFmt_BMP || fmt == WiaImgFmt_MEMORYBMP) {
                // for uncompressed transfers -- 
                // tell service we don't know item size 
                wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, 0);
            } else {
                // for any other transfers -- tell serivce that
                // compressed size is the item size
                wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, pItemCtx->pObjectInfo->m_CompressedSize);
            }
        } else {
            pFormatInfo = FormatCodeToFormatInfo(pItemCtx->pObjectInfo->m_FormatCode);

            hr = wiauSetImageItemSize(pWiasContext, pItemCtx->pObjectInfo->m_ImagePixWidth,
                                      pItemCtx->pObjectInfo->m_ImagePixHeight,
                                      pItemCtx->pObjectInfo->m_ImageBitDepth,
                                      pItemCtx->pObjectInfo->m_CompressedSize,
                                      pFormatInfo->ExtString);
            if (FAILED(hr))
            {
                wiauDbgError("ValidateItemProperties", "SetImageItemSize failed");
                return hr;
            }
        }
    }

    //
    // Call WIA service helper to check against valid values
    //
    hr = wiasValidateItemProperties(pWiasContext, NumPropSpecs, pPropSpecs);
    if (FAILED(hr))
    {
        wiauDbgWarning("ValidateDeviceProperties", "wiasValidateItemProperties failed");
        return hr;
    }

    return hr;
}

ULONG GetBitmapHeaderSize(PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    UINT colormapsize = 0;
    UINT size = sizeof(BITMAPINFOHEADER);
    
    switch(pmdtc->lCompression) {
    case WIA_COMPRESSION_NONE: // BI_RGB
    case WIA_COMPRESSION_BI_RLE4:
    case WIA_COMPRESSION_BI_RLE8:
        switch(pmdtc->lDepth) {
        case 1:
            colormapsize = 2;
            break;
        case 4:
            colormapsize = 16;
            break;
        case 8:
            colormapsize = 256;
            break;
        case 15:
        case 16:
        case 32:
            colormapsize = 3;
            break;
        case 24:
            colormapsize = 0;
            break;
        }
    }

    size += colormapsize * sizeof(RGBQUAD);
    
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP)) {
        size += sizeof(BITMAPFILEHEADER);
    }

    return size;
}

VOID
VerticalFlip(
    PBYTE pImageTop,
    LONG  iWidthInBytes,
    LONG  iHeight)
{
    //
    // try to allocat a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,iWidthInBytes);

    if (pBuffer != NULL) {

        LONG  index;
        PBYTE pImageBottom;

        pImageBottom = pImageTop + (iHeight-1) * iWidthInBytes;

        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,iWidthInBytes);
            memcpy(pImageTop,pImageBottom,iWidthInBytes);
            memcpy(pImageBottom,pBuffer,iWidthInBytes);

            pImageTop    += iWidthInBytes;
            pImageBottom -= iWidthInBytes;
        }

        LocalFree(pBuffer);
    }
}


HRESULT
CWiaMiniDriver::AcquireAndTranslateAnyImage(
    BYTE *pWiasContext,
    DRVITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
#define REQUIRE(x, y) if(!(x)) { wiauDbgError("AcquireAndTranslateAnyImage", y); goto Cleanup; }
    DBG_FN("CWiaMiniDriver::AcquireAndTranslateAnyImage");
    HRESULT hr = S_OK;
    BYTE *pNativeImage = NULL;
    BYTE *pRawImageBuffer = NULL;
    BOOL bPatchedMDTC = FALSE;
    UINT NativeImageSize = pItemCtx->pObjectInfo->m_CompressedSize;
    UINT width, height, depth, imagesize, headersize;
    BOOL bFileTransfer = (pmdtc->tymed & TYMED_FILE);
    LONG lMsg = (bFileTransfer ? IT_MSG_STATUS : IT_MSG_DATA);
    LONG percentComplete;


    // we can deal with any image as long as GDIPlus can handle it

    //
    // Allocate memory for the native image
    //
    pNativeImage = new BYTE[NativeImageSize];
    hr = E_OUTOFMEMORY;
    REQUIRE(pNativeImage, "memory allocation failed");

    //
    // Get the data from the camera
    //
    hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle,
                                     pNativeImage, &NativeImageSize, (LPVOID) pmdtc);
    REQUIRE(hr != S_FALSE, "transfer cancelled");
    REQUIRE(SUCCEEDED(hr), "GetObjectData failed");

    //
    // decompress image, retrieve its geometry
    //
    hr = ConvertAnyImageToBmp(pNativeImage, NativeImageSize, &width, &height, &depth, &pRawImageBuffer, &imagesize, &headersize);
    REQUIRE(hr == S_OK, "failed to convert image to bitmap format");

    pmdtc->lWidthInPixels = pItemCtx->pObjectInfo->m_ImagePixWidth = width;
    pmdtc->cbWidthInBytes = (width * depth) / 8L;
    pmdtc->lLines = pItemCtx->pObjectInfo->m_ImagePixHeight = height;
    pmdtc->lDepth = pItemCtx->pObjectInfo->m_ImageBitDepth = depth;
    pmdtc->lImageSize = imagesize = ((width * depth) / 8L) * height;
    
    if(IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        pmdtc->lHeaderSize = headersize - sizeof(BITMAPFILEHEADER); 
    } else {
        pmdtc->lHeaderSize = headersize;
    }
    pmdtc->lItemSize = pmdtc->lImageSize + pmdtc->lHeaderSize;

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, width);
    REQUIRE(hr == S_OK, "failed to set image width");

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, height);
    REQUIRE(hr == S_OK, "failed to set image height");

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, 0);
    REQUIRE(hr == S_OK, "failed to set item size");


    // setup buffer for uncompressed image
    if(pmdtc->pTransferBuffer == NULL) {
        if(IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
            pmdtc->pTransferBuffer = pRawImageBuffer + sizeof(BITMAPFILEHEADER);
        } else {
            pmdtc->pTransferBuffer = pRawImageBuffer;
        }
        pmdtc->lBufferSize = pmdtc->lItemSize;
        bPatchedMDTC = TRUE;
    } else {
        if(IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
            memcpy(pmdtc->pTransferBuffer, pRawImageBuffer + sizeof(BITMAPFILEHEADER),
                   pmdtc->lHeaderSize);
        } else {
            memcpy(pmdtc->pTransferBuffer, pRawImageBuffer, pmdtc->lHeaderSize);
        }
    }
    
    //
    // Send the header to the app
    //
    percentComplete = 90 + (10 * pmdtc->lHeaderSize) / pmdtc->lItemSize;

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
        percentComplete, 0, pmdtc->lHeaderSize, pmdtc, 0);
    REQUIRE(hr != S_FALSE, "transfer cancelled");
    REQUIRE(SUCCEEDED(hr), "sending header to app failed");

    if(bFileTransfer) {
        // write the whole image to file
        ULONG   ulWritten;
        BOOL    bRet;

        //
        //  NOTE:  The mini driver transfer context should have the
        //  file handle as a pointer, not a fixed 32-bit long.  This
        //  may not work on 64bit.
        //
        
        bRet = WriteFile((HANDLE)pmdtc->hFile,
                         pRawImageBuffer,
                         pmdtc->lItemSize,
                         &ulWritten,
                         NULL);
        
        if (!bRet) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgError("AcquireAndTranslateAnyImage", "WriteFile failed (0x%X)", hr);
        }
    } else {
        LONG BytesToWrite, BytesLeft = pmdtc->lImageSize;
        BYTE *pCurrent = pRawImageBuffer + headersize;
        UINT offset = pmdtc->lHeaderSize;

        while(BytesLeft) {
            BytesToWrite = min(pmdtc->lBufferSize, BytesLeft);
            memcpy(pmdtc->pTransferBuffer, pCurrent, BytesToWrite);

                //
                // Calculate the percentage done using 90 as a base. This makes a rough assumption that
                // transferring the data from the device takes 90% of the time. If the this is the last
                // transfer, set the percentage to 100, otherwise make sure it is never larger than 99.
                //
            if (BytesLeft == BytesToWrite)
                percentComplete = 100;
            else
                percentComplete = min(99, 90 + (10 * offset) / pmdtc->lItemSize);

            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                percentComplete, offset, BytesToWrite, pmdtc, 0);
            REQUIRE(hr != S_FALSE, "transfer cancelled");
            REQUIRE(SUCCEEDED(hr), "sending header to app failed");

            pCurrent += BytesToWrite;
            offset += BytesToWrite;
            BytesLeft -= BytesToWrite;
        }
    }

Cleanup:    
    delete [] pNativeImage;
    delete [] pRawImageBuffer;

    // restore mdtc
    pmdtc->lItemSize = 0;

    if(bPatchedMDTC) {
        pmdtc->pTransferBuffer = 0;
        pmdtc->lBufferSize = 0;
    }

    return hr;
#undef REQUIRE    
}



HRESULT
CWiaMiniDriver::AcquireAndTranslateJpegWithoutGeometry(
    BYTE *pWiasContext,
    DRVITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
#define REQUIRE(x, y) if(!(x)) { wiauDbgError("AcquireAndTranslateWithoutGeometry", y); goto Cleanup; }
    DBG_FN("CWiaMiniDriver::AcquireAndTranslateWithoutGeometry");
    HRESULT hr = E_FAIL;
    BYTE *pNativeImage = NULL;
    BYTE *pRawImageBuffer = NULL;
    BOOL bPatchedMDTC = FALSE;
    UINT NativeImageSize = pItemCtx->pObjectInfo->m_CompressedSize;
    UINT width, height, depth, imagesize, headersize;
    BOOL bFileTransfer = (pmdtc->tymed & TYMED_FILE);
    LONG lMsg = (bFileTransfer ? IT_MSG_STATUS : IT_MSG_DATA);
    LONG percentComplete;

    // we can only deal with JPEG images
    if(pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_JFIF &&
       pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_EXIF)
    {
        hr = E_INVALIDARG;
        REQUIRE(0, "don't know how to get image geometry from non-JPEG image");
    }

    //
    // Allocate memory for the native image
    //
    pNativeImage = new BYTE[NativeImageSize];
    hr = E_OUTOFMEMORY;
    REQUIRE(pNativeImage, "memory allocation failed");

    //
    // Get the data from the camera
    //
    hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle,
                                     pNativeImage, &NativeImageSize, (LPVOID) pmdtc);
    REQUIRE(hr != S_FALSE, "transfer cancelled");
    REQUIRE(SUCCEEDED(hr), "GetObjectData failed");


    //
    // get image geometry
    //
    hr = GetJpegDimensions(pNativeImage, NativeImageSize, &width, &height, &depth);
    REQUIRE(hr == S_OK, "failed to get image geometry from JPEG file");

    pmdtc->lWidthInPixels = pItemCtx->pObjectInfo->m_ImagePixWidth = width;
    pmdtc->lLines = pItemCtx->pObjectInfo->m_ImagePixHeight = height;
    pmdtc->lDepth = pItemCtx->pObjectInfo->m_ImageBitDepth = depth;
    pmdtc->lImageSize = imagesize = ((((width + 31) * depth) / 8L) & 0xFFFFFFFC) * height;
    pmdtc->lHeaderSize = headersize = GetBitmapHeaderSize(pmdtc);
    pmdtc->lItemSize = imagesize + headersize;

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, width);
    REQUIRE(hr == S_OK, "failed to set image width");

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, height);
    REQUIRE(hr == S_OK, "failed to set image height");

    hr = wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, 0);
    REQUIRE(hr == S_OK, "failed to set item size");


    // setup buffer for uncompressed image
    pRawImageBuffer = new BYTE[pmdtc->lImageSize + pmdtc->lHeaderSize];
    REQUIRE(pRawImageBuffer, "failed to allocate intermdiate buffer");
    if(pmdtc->pTransferBuffer == NULL) {
        pmdtc->pTransferBuffer = pRawImageBuffer;
        pmdtc->lBufferSize = pmdtc->lItemSize;
        bPatchedMDTC = TRUE;
    }

    hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);
    REQUIRE(SUCCEEDED(hr), "wiasGetImageInformation failed");

    percentComplete = 90 + (10 * pmdtc->lHeaderSize) / pmdtc->lItemSize;
    
    //
    // Send the header to the app
    //
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        UNALIGNED BITMAPINFOHEADER*   pbmih   = (BITMAPINFOHEADER*)pmdtc->pTransferBuffer;
        
        pbmih->biHeight = -pmdtc->lLines;
    }

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
        percentComplete, 0, pmdtc->lHeaderSize, pmdtc, 0);
    REQUIRE(hr != S_FALSE, "transfer cancelled");
    REQUIRE(SUCCEEDED(hr), "sending header to app failed");

    //
    // Convert the image to BMP
    //
    hr = Jpeg2DIBBitmap(pNativeImage, NativeImageSize,
                        pRawImageBuffer + pmdtc->lHeaderSize + pmdtc->cbWidthInBytes * (pmdtc->lLines - 1),
                        pmdtc->lImageSize, pmdtc->cbWidthInBytes, 1);
    REQUIRE(SUCCEEDED(hr), "image format conversion failed");

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        VerticalFlip(pRawImageBuffer + pmdtc->lHeaderSize, pmdtc->cbWidthInBytes, pmdtc->lLines);
    }
    
    if(bFileTransfer) {
        // write the whole image to file
#ifdef UNICODE        
        hr = wiasWriteBufToFile(0, pmdtc);
#else
        if (pmdtc->lItemSize <= pmdtc->lBufferSize) {
            ULONG   ulWritten;
            BOOL    bRet;

        //
        //  NOTE:  The mini driver transfer context should have the
        //  file handle as a pointer, not a fixed 32-bit long.  This
        //  may not work on 64bit.
        //

            bRet = WriteFile((HANDLE)pmdtc->hFile,
                             pmdtc->pTransferBuffer,
                             pmdtc->lItemSize,
                             &ulWritten,
                             NULL);

            if (!bRet) {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                wiauDbgError("AcquireDataAndTranslate", "WriteFile failed (0x%X)", hr);
            }
        }
        else {
            wiauDbgError("AcquireDataAndTranslate", "lItemSize is larger than buffer");
            hr = E_FAIL;
        }

#endif        
        REQUIRE(SUCCEEDED(hr), "writing image body to file");
    } else {
        LONG BytesToWrite, BytesLeft = pmdtc->lImageSize;
        BYTE *pCurrent = pRawImageBuffer + pmdtc->lHeaderSize;
        UINT offset = pmdtc->lHeaderSize;
        
        while(BytesLeft) {
            BytesToWrite = min(pmdtc->lBufferSize, BytesLeft);
            memcpy(pmdtc->pTransferBuffer, pCurrent, BytesToWrite);

                //
                // Calculate the percentage done using 90 as a base. This makes a rough assumption that
                // transferring the data from the device takes 90% of the time. If the this is the last
                // transfer, set the percentage to 100, otherwise make sure it is never larger than 99.
                //
            if (BytesLeft == BytesToWrite)
                percentComplete = 100;
            else
                percentComplete = min(99, 90 + (10 * offset) / pmdtc->lItemSize);

            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                percentComplete, offset, BytesToWrite, pmdtc, 0);
            REQUIRE(hr != S_FALSE, "transfer cancelled");
            REQUIRE(SUCCEEDED(hr), "sending header to app failed");
            
            pCurrent += BytesToWrite;
            offset += BytesToWrite;
            BytesLeft -= BytesToWrite;
        }
    }

Cleanup:    
    delete [] pNativeImage;
    delete [] pRawImageBuffer;

    // restore mdtc
    pmdtc->lItemSize = 0;
    
    if(bPatchedMDTC) {
        pmdtc->pTransferBuffer = 0;
        pmdtc->lBufferSize = 0;
    }
    
    return hr;
}
    
   

//
// This function transfers image from the camera and translates it to BMP
// format.
//
// Input:
//   pWiasContext -- wias context
//   pItemCtx     -- the mini driver item context
//   pmdtc        -- the transfer context
//
HRESULT
CWiaMiniDriver::AcquireDataAndTranslate(
    BYTE    *pWiasContext,
    DRVITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc
    )
{
    DBG_FN("CWiaMiniDriver::AcquireDataAndTranslate");
    HRESULT hr = S_OK;

    // non-jpeg images are handled by GDI+ process
    if(pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_JFIF &&
       pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_EXIF)
    {
        return AcquireAndTranslateAnyImage(pWiasContext, pItemCtx, pmdtc);
    }


    if(pItemCtx->pObjectInfo->m_ImagePixWidth == 0) {
        return AcquireAndTranslateJpegWithoutGeometry(pWiasContext, pItemCtx, pmdtc);
    }

    //
    // Allocate memory for the native image
    //
    UINT NativeImageSize = pItemCtx->pObjectInfo->m_CompressedSize;
    BYTE *pNativeImage = new BYTE[NativeImageSize];
    if (!pNativeImage)
    {
        wiauDbgError("AcquireDataAndTranslate", "memory allocation failed");
        return E_OUTOFMEMORY;
    }

    //
    // Get the data from the camera
    //
    hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle,
                                     pNativeImage, &NativeImageSize, (LPVOID) pmdtc);
    if (FAILED(hr))
    {
        wiauDbgError("AcquireDataAndTranslate", "GetObjectData failed");
        delete []pNativeImage;
        return hr;
    }
    if (hr == S_FALSE)
    {
        wiauDbgWarning("AcquireDataAndTranslate", "transfer cancelled");
        delete []pNativeImage;
        return hr;
    }

    //
    // Call the WIA service helper to fill in the BMP header
    //
    hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "AcquireDataAndTranslate", "wiasGetImageInformation failed");
        return hr;
    }

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        UNALIGNED BITMAPINFOHEADER*   pbmih   = (BITMAPINFOHEADER*)pmdtc->pTransferBuffer;
        
        pbmih->biHeight = -pmdtc->lLines;
    }

    //
    // Send the header to the app
    //
    BOOL bFileTransfer = (pmdtc->tymed & TYMED_FILE);
    LONG lMsg = (bFileTransfer ? IT_MSG_STATUS : IT_MSG_DATA);

    LONG percentComplete = 90 + (10 * pmdtc->lHeaderSize) / pmdtc->lItemSize;

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
        percentComplete, 0, pmdtc->lHeaderSize, pmdtc, 0);
    
    if (FAILED(hr))
    {
        wiauDbgError("AcquireDataAndTranslate", "sending header to app failed");
        return hr;
    }
    if (hr == S_FALSE)
    {
        wiauDbgWarning("AcquireDataAndTranslate", "transfer cancelled");
        delete []pNativeImage;
        return S_FALSE;
    }

    //
    // Set up the buffer for the rest of the transfer
    //
    BYTE *pTranslateBuffer = pmdtc->pTransferBuffer;
    LONG BytesLeft = pmdtc->lBufferSize;

    if (bFileTransfer)
    {
        pTranslateBuffer += pmdtc->lHeaderSize;
        BytesLeft -= pmdtc->lHeaderSize;
    }

    //
    // If the buffer is too small, allocate a new, bigger one
    //
    BOOL bIntermediateBuffer = FALSE;
    if (BytesLeft < pmdtc->lImageSize)
    {
        pTranslateBuffer = new BYTE[pmdtc->lImageSize];
        BytesLeft = pmdtc->lImageSize;
        bIntermediateBuffer = TRUE;
    }

    //
    // Convert the image to BMP
    //
    hr = Jpeg2DIBBitmap(pNativeImage, NativeImageSize,
                        pTranslateBuffer + pmdtc->cbWidthInBytes * (pmdtc->lLines - 1),
                        BytesLeft, pmdtc->cbWidthInBytes, 1);
    //
    // Free the native image buffer
    //
    delete []pNativeImage;
    pNativeImage = NULL;

    if (FAILED(hr))
    {
        wiauDbgError("AcquireDataAndTranslate", "image format conversion failed");
        if (bIntermediateBuffer)
            delete []pTranslateBuffer;
        return hr;
    }

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        VerticalFlip(pTranslateBuffer, pmdtc->cbWidthInBytes, pmdtc->lLines);
    }
    
    LONG lOffset = pmdtc->lHeaderSize;
    if (bIntermediateBuffer)
    {
    //
    // Send the data back a chunk at a time. This assumes that it is a callback transfer, e.g. the
    // buffer pointer is not being incremented.
    //
        LONG BytesToCopy = 0;
        BYTE *pCurrent = pTranslateBuffer;
        BytesLeft = pmdtc->lImageSize;


        while (BytesLeft > 0)
        {
            BytesToCopy = min(BytesLeft, pmdtc->lBufferSize);
            memcpy(pmdtc->pTransferBuffer, pCurrent, BytesToCopy);

                //
                // Calculate the percentage done using 90 as a base. This makes a rough assumption that
                // transferring the data from the device takes 90% of the time. If the this is the last
                // transfer, set the percentage to 100, otherwise make sure it is never larger than 99.
                //
            if (BytesLeft == BytesToCopy)
                percentComplete = 100;
            else
                percentComplete = min(99, 90 + (10 * lOffset) / pmdtc->lItemSize);

            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                percentComplete, lOffset, BytesToCopy, pmdtc, 0);
            if (FAILED(hr))
            {
                wiauDbgError("AcquireDataAndTranslate", "sending header to app failed");
                if (bIntermediateBuffer)
                    delete []pTranslateBuffer;
                return hr;
            }
            if (hr == S_FALSE)
            {
                wiauDbgWarning("AcquireDataAndTranslate", "transfer cancelled");
                if (bIntermediateBuffer)
                    delete []pTranslateBuffer;
                return S_FALSE;
            }

            pCurrent += BytesToCopy;
            lOffset += BytesToCopy;
            BytesLeft -= BytesToCopy;
        }
    }       
    else
    {
        //
        // Send the data to the app in one big chunk
        //
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
            100, lOffset, pmdtc->lImageSize, pmdtc, 0);
        if (FAILED(hr))
        {
            wiauDbgError("AcquireDataAndTranslate", "sending header to app failed");
            if (bIntermediateBuffer)
                delete []pTranslateBuffer;
            return hr;
        }
    }

    //
    // Free the translate buffer
    //
    if (bIntermediateBuffer)
        delete []pTranslateBuffer;

    return hr;
}

//
// This function transfers native data to the application without translating it.
//
// Input:
//   pItemCtx -- driver item context
//   pmdtc -- transfer context
//
HRESULT
CWiaMiniDriver::AcquireData(
    DRVITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc
    )
{
    DBG_FN("CWiaMiniDriver::AcquireData");

    HRESULT hr = S_OK;

    //
    // If the class driver does not allocate the transfer buffer,
    // we have to allocate a temporary one
    //
    if (!pmdtc->bClassDrvAllocBuf)
    {
        pmdtc->pTransferBuffer = new BYTE[pItemCtx->pObjectInfo->m_CompressedSize];
        if (!pmdtc->pTransferBuffer)
        {
            wiauDbgError("AcquireData", "memory allocation failed");
            return E_OUTOFMEMORY;
        }
        pmdtc->pBaseBuffer = pmdtc->pTransferBuffer;
        pmdtc->lBufferSize = pItemCtx->pObjectInfo->m_CompressedSize;
    }

    //
    // Get the data from the camera
    //
    UINT size = pmdtc->lBufferSize;
    hr = m_pPTPCamera->GetObjectData(pItemCtx->pObjectInfo->m_ObjectHandle, pmdtc->pTransferBuffer,
                                     &size, (LPVOID) pmdtc);
    //
    // Check the return code, but keep going so that the buffer gets freed
    //
    if (FAILED(hr))
        wiauDbgError("AcquireData", "GetObjectData failed");
    else if (hr == S_FALSE)
        wiauDbgWarning("AcquireData", "data transfer cancelled");

    //
    // Free the temporary buffer, if needed
    //
    if (!pmdtc->bClassDrvAllocBuf)
    {
        if (pmdtc->pTransferBuffer)
        {
            delete []pmdtc->pTransferBuffer;
            pmdtc->pBaseBuffer = NULL;
            pmdtc->pTransferBuffer = NULL;
            pmdtc->lBufferSize = 0;

        }
        else
        {
            wiauDbgWarning("AcquireData", "transfer buffer is NULL");
        }
    }

    return hr;
}

//
// This function passes the data transfer callback through to the
// IWiaMiniDrvCallBack interface using the appropriate
// parameters.
//
// Input:
//   pCallbackParam -- should hold a pointer to the transfer context
//   lPercentComplete -- percent of transfer completed
//   lOffset -- offset into the buffer where the data is located
//   lLength -- amount of data transferred
//
HRESULT
DataCallback(
    LPVOID pCallbackParam,
    LONG lPercentComplete,
    LONG lOffset,
    LONG lLength,
    BYTE **ppBuffer,
    LONG *plBufferSize
    )
{
    DBG_FN("DataCallback");

    HRESULT hr = S_OK;

    if (!pCallbackParam || !ppBuffer || !*ppBuffer || !plBufferSize)
    {
        wiauDbgError("DataCallback", "invalid argument");
        return E_INVALIDARG;
    }

    PMINIDRV_TRANSFER_CONTEXT pmdtc = (PMINIDRV_TRANSFER_CONTEXT) pCallbackParam;

    //
    // If app is asking for BMP, most likely it's being converted. Thus just give the app
    // status messages. Calculate percent done so that the transfer takes 90% of the time
    // and the conversion takes the last 10%.
    //
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP) ||
        IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP))
    {
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS, IT_STATUS_TRANSFER_FROM_DEVICE,
                                                          lPercentComplete * 9 / 10, lOffset, lLength, pmdtc, 0);
        *ppBuffer += lLength;
    }

    //
    // Otherwise, see if it's a file transfer
    //
    else if (pmdtc->tymed & TYMED_FILE)
    {
        if (pmdtc->bClassDrvAllocBuf && lPercentComplete == 100)
        {
            //
            // Call WIA to write the data to the file. There is a small a bug that causes
            // TIFF headers to be changed, so temporarily change the format GUID to null.
            //
            GUID tempFormat;
            tempFormat = pmdtc->guidFormatID;
            pmdtc->guidFormatID = GUID_NULL;

            hr = wiasWritePageBufToFile(pmdtc);
            pmdtc->guidFormatID = tempFormat;

            if (FAILED(hr))
            {
                wiauDbgError("DataCallback", "wiasWritePageBufToFile failed");
                return hr;
            }
        }

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS, IT_STATUS_TRANSFER_TO_CLIENT,
                                                          lPercentComplete, lOffset, lLength, pmdtc, 0);
        *ppBuffer += lLength;
    }

    //
    // Otherwise, it's a callback transfer
    //
    else
    {
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA, IT_STATUS_TRANSFER_TO_CLIENT,
                                                          lPercentComplete, lOffset, lLength, pmdtc, 0);
        //
        // Update the buffer pointer and size in case the app is using double buffering
        //
        *ppBuffer = pmdtc->pTransferBuffer;
        *plBufferSize = pmdtc->lBufferSize;
    }

    if (FAILED(hr))
    {
        wiauDbgError("DataCallback", "MiniDrvCallback failed");
    }
    else if (hr == S_FALSE)
    {
        wiauDbgWarning("DataCallback", "data transfer was cancelled by MiniDrvCallback");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\factory.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    factory.cpp

Abstract:

    This module implements CClassFactory class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

#include "dllmain.h"
#include "camera.h"
#include "utils.h"
#include "minidrv.h"
#include "factory.h"


//
// CClassFactory implmentation
//


LONG CClassFactory::s_Locks = 0;
LONG CClassFactory::s_Objects = 0;

CClassFactory::CClassFactory()
: m_Refs(1)
{
}
CClassFactory::~CClassFactory()
{
}

ULONG
CClassFactory::AddRef()
{
    ::InterlockedIncrement((LONG*)&m_Refs);
    return m_Refs;
}
ULONG
CClassFactory::Release()
{
    ::InterlockedDecrement((LONG*)&m_Refs);
    if (!m_Refs)
    {
        delete this;
        return 0;
    }
    return m_Refs;
}

STDMETHODIMP
CClassFactory::QueryInterface(
                             REFIID riid,
                             LPVOID*  ppv
                             )
{

    if (!ppv)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)(IClassFactory *)this;
    }
    else if (IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    if (SUCCEEDED(hr))
        AddRef();
    else
        *ppv = NULL;
    return hr;
}


STDMETHODIMP
CClassFactory::CreateInstance(
                             IUnknown    *pUnkOuter,
                             REFIID       riid,
                             LPVOID      *ppv
                             )
{

    if (!ppv)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    *ppv = NULL;
    CWiaMiniDriver *pWiaMiniDrv;

    if (pUnkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }

    pWiaMiniDrv = new CWiaMiniDriver(pUnkOuter);
    if (pWiaMiniDrv)
    {
        hr = pWiaMiniDrv->NonDelegatingQueryInterface(riid, ppv);
        pWiaMiniDrv->NonDelegatingRelease();
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    return hr;
}



STDMETHODIMP
CClassFactory::LockServer(
                         BOOL fLock
                         )
{
    if (fLock)
        ::InterlockedIncrement((LONG*)&s_Locks);
    else
        ::InterlockedDecrement((LONG*)&s_Locks);
    return S_OK;
}

HRESULT
CClassFactory::CanUnloadNow()
{
    return(s_Objects || s_Locks) ? S_FALSE : S_OK;
}


//
// This function create a CClassFactory. It is mainly called
// by DllGetClassObject API
// INPUT:
//  rclsid  -- reference to the CLSID
//  riid    -- reference to the interface IID
//  ppv -- interface pointer holder
//
// OUTPUT:
//  S_OK if succeeded else standard OLE error code
//
//
HRESULT
CClassFactory::GetClassObject(
                             REFCLSID rclsid,
                             REFIID   riid,
                             void**   ppv
                             )
{
    if (!ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    HRESULT hr = S_OK;


    CClassFactory* pClassFactory;
    pClassFactory = new CClassFactory();
    if (pClassFactory)
    {
        hr = pClassFactory->QueryInterface(riid, ppv);
        pClassFactory->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


HRESULT
CClassFactory::RegisterAll()
{

    //
    // We have nothing to register
    //
    return S_OK;
}

HRESULT
CClassFactory::UnregisterAll()
{

    //
    // We have nothing to unregister
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\minidrv.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    minidrv.cpp

Abstract:

    This module implements main part of CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

#include <atlbase.h>
#include <atlconv.h>
#include <wiatempl.h>
#include <stiregi.h>
#include "utils.h"

//
// Strings that will be loaded from resource
//
WCHAR UnknownString[MAX_PATH] = L"\0";
WCHAR FolderString[MAX_PATH] = L"\0";
WCHAR ScriptString[MAX_PATH] = L"\0";
WCHAR ExecString[MAX_PATH] = L"\0";
WCHAR TextString[MAX_PATH] = L"\0";
WCHAR HtmlString[MAX_PATH] = L"\0";
WCHAR DpofString[MAX_PATH] = L"\0";
WCHAR AudioString[MAX_PATH] = L"\0";
WCHAR VideoString[MAX_PATH] = L"\0";
WCHAR UnknownImgString[MAX_PATH] = L"\0";
WCHAR ImageString[MAX_PATH] = L"\0";
WCHAR AlbumString[MAX_PATH] = L"\0";
WCHAR BurstString[MAX_PATH] = L"\0";
WCHAR PanoramaString[MAX_PATH] = L"\0";


//
// Structures for setting up WIA capabilities
//
WCHAR DeviceConnectedString[MAX_PATH] = L"\0";
WCHAR DeviceDisconnectedString[MAX_PATH] = L"\0";
WCHAR ItemCreatedString[MAX_PATH] = L"\0";
WCHAR ItemDeletedString[MAX_PATH] = L"\0";
WCHAR TakePictureString[MAX_PATH] = L"\0";
WCHAR SynchronizeString[MAX_PATH] = L"\0";
WCHAR TreeUpdatedString[MAX_PATH] = L"\0";
WCHAR VendorEventIconString[MAX_PATH] = WIA_ICON_DEVICE_CONNECTED;

const BYTE     NUMEVENTCAPS = 5;
const BYTE     NUMCMDCAPS = 2;
WIA_DEV_CAP_DRV g_EventCaps[NUMEVENTCAPS] =
{
    {(GUID *)&WIA_EVENT_DEVICE_CONNECTED,
        WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT,
        DeviceConnectedString,
        DeviceConnectedString,
        WIA_ICON_DEVICE_CONNECTED
    },
    {(GUID *)&WIA_EVENT_DEVICE_DISCONNECTED,
        WIA_NOTIFICATION_EVENT,
        DeviceDisconnectedString,
        DeviceDisconnectedString,
        WIA_ICON_DEVICE_DISCONNECTED
    },
    {(GUID *)&WIA_EVENT_ITEM_CREATED,
        WIA_NOTIFICATION_EVENT,
        ItemCreatedString,
        ItemCreatedString,
        WIA_ICON_ITEM_CREATED
    },
    {(GUID *)&WIA_EVENT_ITEM_DELETED,
        WIA_NOTIFICATION_EVENT,
        ItemDeletedString,
        ItemDeletedString,
        WIA_ICON_ITEM_DELETED
    },
    {(GUID *)&WIA_EVENT_TREE_UPDATED,
        WIA_NOTIFICATION_EVENT,
        TreeUpdatedString,
        TreeUpdatedString,
        WIA_ICON_BUILD_DEVICE_TREE
    }
};

WIA_DEV_CAP_DRV g_CmdCaps[NUMCMDCAPS] =
{
    {(GUID*)&WIA_CMD_SYNCHRONIZE,
        0,
        SynchronizeString,
        SynchronizeString,
        WIA_ICON_SYNCHRONIZE
    },
    {(GUID*)&WIA_CMD_TAKE_PICTURE,
        0,
        TakePictureString,
        TakePictureString,
        WIA_ICON_TAKE_PICTURE
    }
};

//
// Constructor
//
CWiaMiniDriver::CWiaMiniDriver(LPUNKNOWN punkOuter) :
    m_Capabilities(NULL),  
    m_nEventCaps(0),
    m_nCmdCaps(0),
    m_fInitCaptureChecked(FALSE),

    m_OpenApps(0),
    m_pDrvItemRoot(NULL),
    m_pPTPCamera(NULL),
    m_NumImages(0),

    m_pStiDevice(NULL),
    m_bstrDeviceId(NULL),
    m_bstrRootItemFullName(NULL),
    m_pDcb(NULL),
    m_dwObjectBeingSent(0),

    m_TakePictureDoneEvent(NULL),
    m_hPtpMutex(NULL),
    m_bTwoDigitsMillisecondsOutput(FALSE),

    m_Refs(1)
{
    ::InterlockedIncrement(&CClassFactory::s_Objects);
    if (punkOuter)
        m_punkOuter = punkOuter;
    else
        m_punkOuter = (IUnknown *)(INonDelegatingUnknown *)this;
}

//
// Destructor
//
CWiaMiniDriver::~CWiaMiniDriver()
{
    HRESULT hr = S_OK;

    Shutdown();

    //
    // CWiaMap<WORD, PROP_INFO *> m_VendorPropMap - delete all PROP_INFO objects 
    // before calling RemoveAll()
    // 
    for (int i = 0; i < m_VendorPropMap.GetSize(); i++)
    {
        delete m_VendorPropMap.GetValueAt(i);
        m_VendorPropMap.GetValueAt(i) = NULL;
    }
    m_VendorPropMap.RemoveAll();

    //
    // CWiaMap<WORD, CVendorEventInfo*> m_VendorEventMap - delete all CVendorEventInfo 
    // objects before calling RemoveAll()
    //
    for (i = 0; i < m_VendorEventMap.GetSize(); i++)
    {
        delete m_VendorEventMap.GetValueAt(i);
        m_VendorEventMap.GetValueAt(i) = NULL;
    }
    m_VendorEventMap.RemoveAll();

    if (m_Capabilities)
    {
        delete[] m_Capabilities;
    }

    if (m_pStiDevice)
        m_pStiDevice->Release();

    if (m_pDcb)
        m_pDcb->Release();

    UnInitializeGDIPlus();

    ::InterlockedDecrement(&CClassFactory::s_Objects);
}

//
// INonDelegatingUnknown interface
//
STDMETHODIMP_(ULONG)
CWiaMiniDriver::NonDelegatingAddRef()
{
    ::InterlockedIncrement((LONG *)&m_Refs);
    return m_Refs;
}

STDMETHODIMP_(ULONG)
CWiaMiniDriver::NonDelegatingRelease()
{
    ::InterlockedDecrement((LONG*)&m_Refs);
    if (!m_Refs)
    {
        delete this;
        return 0;
    }
    return m_Refs;
}

STDMETHODIMP
CWiaMiniDriver::NonDelegatingQueryInterface(
                                           REFIID riid,
                                           void   **ppv
                                           )
{
    if (!ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<INonDelegatingUnknown *>(this);
    else if (IsEqualIID(riid, IID_IStiUSD))
        *ppv = static_cast<IStiUSD *>(this);
    else if (IsEqualIID(riid, IID_IWiaMiniDrv))
        *ppv = static_cast<IWiaMiniDrv *>(this);
    else
    {
        return E_NOINTERFACE;
    }
    //
    // Do not call NonDelegatingAddRef() ....
    //
    (reinterpret_cast<IUnknown *>(*ppv))->AddRef();
    return S_OK;
}

//
// IUnknown interface
//

STDMETHODIMP_(ULONG)
CWiaMiniDriver::AddRef()
{
    return m_punkOuter->AddRef();
}

STDMETHODIMP_(ULONG)
CWiaMiniDriver::Release()
{
    return m_punkOuter->Release();
}

STDMETHODIMP
CWiaMiniDriver::QueryInterface(
                              REFIID riid,
                              void   **ppv
                              )
{
    return m_punkOuter->QueryInterface(riid, ppv);
}

//
// IStiUSD interface
//
STDMETHODIMP
CWiaMiniDriver::Initialize(
                          PSTIDEVICECONTROL pDcb,
                          DWORD             dwStiVersion,
                          HKEY              hParametersKey
                          )
{
    USES_CONVERSION;

    HRESULT hr;

    wiauDbgInit(g_hInst);

    DBG_FN("CWiaMiniDriver::Initialize");

    if (!pDcb)
        return STIERR_INVALID_PARAM;

    //
    // Check STI specification version number
    //

    m_pDcb = pDcb;
    m_pDcb->AddRef();

    hr = InitVendorExtentions(hParametersKey);
    if (FAILED(hr))
    {
        wiauDbgError("Initialize", "vendor extensions not loaded");
        //
        // Ignore errors from loading vendor extensions
        //
        hr = S_OK;
    }

    return hr;
}


STDMETHODIMP
CWiaMiniDriver::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    DBG_FN("CWiaMiniDriver::GetCapabilities");

    if (!pUsdCaps)
        return STIERR_INVALID_PARAM;

    ZeroMemory(pUsdCaps, sizeof(*pUsdCaps));

    pUsdCaps->dwVersion = STI_VERSION;
    pUsdCaps->dwGenericCaps = STI_GENCAP_AUTO_PORTSELECT;


    return S_OK;
}


STDMETHODIMP
CWiaMiniDriver::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    DBG_FN("CWiaMiniDriver::GetStatus");

    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)
        pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
    return S_OK;
}

STDMETHODIMP
CWiaMiniDriver::DeviceReset(VOID)
{
    DBG_FN("CWiaMiniDriver::DeviceReset");

    //
    // Camera may not be open if this method is called before
    // drvInitializeWia. For now just return S_OK.

//  return HRESULT_FROM_WIN32(m_pPTPCamera->ResetDevice());

    return S_OK;

}

STDMETHODIMP
CWiaMiniDriver::Diagnostic(LPDIAG pBuffer)
{
    DBG_FN("CWiaMiniDriver::Diagnostic");

    HRESULT hr = STI_OK;

    // Initialize response buffer
    pBuffer->sErrorInfo.dwGenericError = STI_NOTCONNECTED;
    pBuffer->sErrorInfo.dwVendorError = 0;

    STI_DEVICE_STATUS DevStatus;

    //
    // Call status method to verify device is available
    //
    ::ZeroMemory(&DevStatus,sizeof(DevStatus));
    DevStatus.StatusMask = STI_DEVSTATUS_ONLINE_STATE;

    // WIAFIX-8/9/2000-davepar Should this function actually talk to the camera?

    hr = GetStatus(&DevStatus);

    if (SUCCEEDED(hr))
    {
        if (DevStatus.dwOnlineState & STI_ONLINESTATE_OPERATIONAL)
        {
            pBuffer->sErrorInfo.dwGenericError = STI_OK;
        }
    }

    return(hr);
}

STDMETHODIMP
CWiaMiniDriver::SetNotificationHandle(HANDLE hEvent)
{
    DBG_FN("CWiaMiniDriver::SetNotificationHandle");

    // Use wiasQueueEvent instead

    return(S_OK);
}


STDMETHODIMP
CWiaMiniDriver::GetNotificationData(LPSTINOTIFY pBuffer)
{
    DBG_FN("CWiaMiniDriver::GetNotificationData");

    // Use wiasQueueEvent instead

    return STIERR_NOEVENTS;
}

STDMETHODIMP
CWiaMiniDriver::Escape(
                      STI_RAW_CONTROL_CODE    EscapeFunction,
                      LPVOID                  pInData,
                      DWORD                   cbInDataSize,
                      LPVOID                  pOutData,
                      DWORD                   cbOutDataSize,
                      LPDWORD                 pcbActualDataSize
                      )
{
    DBG_FN("CWiaMiniDriver::Escape");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    PTP_VENDOR_DATA_IN *pVendorDataIn = NULL;
    PTP_VENDOR_DATA_OUT *pVendorDataOut = NULL;
    UINT NumCommandParams = 0;
    INT NextPhase = 0;
    BYTE *pReadData = NULL;
    BYTE *pWriteData = NULL;
    UINT ReadDataSize = 0;
    UINT WriteDataSize = 0;
    DWORD dwObjectToAdd = 0;
    DWORD dwObjectToRemove = 0;
    
    CPtpMutex cpm(m_hPtpMutex);

    if (EscapeFunction & ESCAPE_PTP_VENDOR_COMMAND) {

        REQUIRE_ARGS(!pInData || !pOutData || !pcbActualDataSize, hr, "Escape");

        if (cbInDataSize < SIZEOF_REQUIRED_VENDOR_DATA_IN) {
            wiauDbgError("Escape", "InDataSize is too small");
            hr = E_FAIL;
            goto Cleanup;
        }

        if (cbOutDataSize < SIZEOF_REQUIRED_VENDOR_DATA_OUT) {
            wiauDbgError("Escape", "OutDataSize is too small");
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // Set up some more convenient pointers
        //
        pVendorDataIn = (PTP_VENDOR_DATA_IN *) pInData;
        pVendorDataOut = (PTP_VENDOR_DATA_OUT *) pOutData;

        if (!(pVendorDataIn->OpCode & PTP_DATACODE_VENDORMASK))
        {
            wiauDbgWarning("VendorCommand", "executing non-vendor command");
        }

        NumCommandParams = pVendorDataIn->NumParams;
        NextPhase = pVendorDataIn->NextPhase;

        //
        // Verify that NumCommandParams and NextPhase are correct
        //
        if (NumCommandParams > COMMAND_NUMPARAMS_MAX ||
            (NextPhase != PTP_NEXTPHASE_READ_DATA &&
            NextPhase != PTP_NEXTPHASE_WRITE_DATA &&
            NextPhase != PTP_NEXTPHASE_NO_DATA))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //
        // Data to write and read buffer are right after command and response,
        // respectively
        //
        if (cbInDataSize > SIZEOF_REQUIRED_VENDOR_DATA_IN) {
            pWriteData = pVendorDataIn->VendorWriteData;
            WriteDataSize = cbInDataSize - SIZEOF_REQUIRED_VENDOR_DATA_IN;
        }

        if (cbOutDataSize > SIZEOF_REQUIRED_VENDOR_DATA_OUT) {
            pReadData = pVendorDataOut->VendorReadData;
            ReadDataSize = cbOutDataSize - SIZEOF_REQUIRED_VENDOR_DATA_OUT;
        }

        hr = m_pPTPCamera->VendorCommand((PTP_COMMAND *) pInData, (PTP_RESPONSE *) pOutData,
                                         &ReadDataSize, pReadData,
                                         WriteDataSize, pWriteData,
                                         NumCommandParams, NextPhase);
        REQUIRE_SUCCESS(hr, "Escape", "VendorCommand failed");

        *pcbActualDataSize = SIZEOF_REQUIRED_VENDOR_DATA_OUT + ReadDataSize;

        //
        // For SendObjectInfo, hand on to handle until SendObject command
        //
        if (pVendorDataIn->OpCode == PTP_OPCODE_SENDOBJECTINFO) {

            m_dwObjectBeingSent = pVendorDataOut->Params[2];

        //
        // For SendObject, add object
        //
        } else if (pVendorDataIn->OpCode == PTP_OPCODE_SENDOBJECT) {

            dwObjectToAdd = m_dwObjectBeingSent;
            m_dwObjectBeingSent = 0;


        //
        // Otherwise, see if add or remove flag is set
        //
        } else {

            if ((EscapeFunction & 0xf) >= PTP_MAX_PARAMS) {
                wiauDbgError("Escape", "Parameter number too large");
                hr = E_FAIL;
                goto Cleanup;
            }

            if (EscapeFunction & ESCAPE_PTP_ADD_OBJ_CMD) {
                dwObjectToAdd = pVendorDataIn->Params[EscapeFunction & 0xf];
            }

            if (EscapeFunction & ESCAPE_PTP_REM_OBJ_CMD) {
                dwObjectToRemove = pVendorDataIn->Params[EscapeFunction & 0xf];
            }

            if (EscapeFunction & ESCAPE_PTP_ADD_OBJ_RESP) {
                dwObjectToAdd = pVendorDataOut->Params[EscapeFunction & 0xf];
            }

            if (EscapeFunction & ESCAPE_PTP_REM_OBJ_RESP) {
                dwObjectToRemove = pVendorDataOut->Params[EscapeFunction & 0xf];
            }
        }

        if (dwObjectToAdd) {
            hr = AddObject(dwObjectToAdd, TRUE);
            REQUIRE_SUCCESS(hr, "Escape", "AddObject failed");
        }

        if (dwObjectToRemove) {
            hr = RemoveObject(dwObjectToRemove);
            REQUIRE_SUCCESS(hr, "Escape", "DeleteObject failed");
        }
    }

    else if(EscapeFunction == ESCAPE_PTP_CLEAR_STALLS) {
        hr = m_pPTPCamera->RecoverFromError();
    }

    else
        hr = STIERR_UNSUPPORTED;

Cleanup:
    return hr;
}


STDMETHODIMP
CWiaMiniDriver::GetLastError(LPDWORD pdwLastDeviceError)
{
    DBG_FN("CWiaMiniDriver::GetLastError");

    HRESULT hr = STI_OK;

    if (IsBadWritePtr(pdwLastDeviceError, 4))
    {
        hr = STIERR_INVALID_PARAM;
    }
    else
    {
        *pdwLastDeviceError = 0;
    }

    return(hr);
}

STDMETHODIMP
CWiaMiniDriver::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    DBG_FN("CWiaMiniDriver::GetLastErrorInfo");

    HRESULT hr = STI_OK;

    if (IsBadWritePtr(pLastErrorInfo, 4))
    {
        hr = STIERR_INVALID_PARAM;
    }
    else
    {
        pLastErrorInfo->dwGenericError = 0;
        pLastErrorInfo->szExtendedErrorText[0] = L'\0';
    }

    return(hr);
}

STDMETHODIMP
CWiaMiniDriver::LockDevice(VOID)
{
    DBG_FN("CWiaMiniDriver::LockDevice");

    return(S_OK);
}

STDMETHODIMP
CWiaMiniDriver::UnLockDevice(VOID)
{
    DBG_FN("CWiaMiniDriver::UnLockDevice");

    return(S_OK);
}

STDMETHODIMP
CWiaMiniDriver::RawReadData(
                           LPVOID lpBuffer,
                           LPDWORD lpdwNumberOfBytes,
                           LPOVERLAPPED lpOverlapped
                           )
{
    DBG_FN("CWiaMiniDriver::RawReadData");

    return(STIERR_UNSUPPORTED);
}

STDMETHODIMP
CWiaMiniDriver::RawWriteData(
                            LPVOID lpBuffer,
                            DWORD   dwNumberOfBytes,
                            LPOVERLAPPED lpOverlapped
                            )
{
    DBG_FN("CWiaMiniDriver::RawWriteData");

    return(STIERR_UNSUPPORTED);
}

STDMETHODIMP
CWiaMiniDriver::RawReadCommand(
                              LPVOID lpBuffer,
                              LPDWORD lpdwNumberOfBytes,
                              LPOVERLAPPED lpOverlapped
                              )
{
    DBG_FN("CWiaMiniDriver::RawReadCommand");

    return(STIERR_UNSUPPORTED);
}

STDMETHODIMP
CWiaMiniDriver::RawWriteCommand(
                               LPVOID lpBuffer,
                               DWORD nNumberOfBytes,
                               LPOVERLAPPED lpOverlapped
                               )
{
    DBG_FN("CWiaMiniDriver::RawWriteCommand");

    return(STIERR_UNSUPPORTED);
}

/////////////////////////////////////////////////////
//
// IWiaMiniDrvItem methods
//
/////////////////////////////////////////////////////

//
// This method is the first call to initialize the mini driver
// This is where a mini driver establish its IWiaDrvItem tree
//
// Input:
//   pWiasContext    -- context used to call Wias service
//   lFlags      -- misc flags. Not used for now
//   bstrDeviceId    -- the device id
//   bstrRootItemFullName -- the full name of root driver item
//   pStiDevice  -- IStiDevice interface pointer
//   punkOuter   -- not used.
//   ppDrvItemRoot   -- to return our root IWiaDrvItem
//   ppunkInner  -- mini driver special interface which allows
//              the applications to directly access.
//   plDevErrVal -- to return device error code.
//
HRESULT
CWiaMiniDriver::drvInitializeWia(
    BYTE        *pWiasContext,
    LONG        lFlags,
    BSTR        bstrDeviceID,
    BSTR        bstrRootItemFullName,
    IUnknown    *pStiDevice,
    IUnknown    *punkOuter,
    IWiaDrvItem **ppDrvItemRoot,
    IUnknown    **ppunkInner,
    LONG        *plDevErrVal
    )
{
#define REQUIRE(x, y) if(!(x)) { wiauDbgError("drvInitializeWia", y); hr = HRESULT_FROM_WIN32(::GetLastError()); goto Cleanup; }
#define REQUIRE_SUCCESS_(x, y) if(FAILED(x)) { wiauDbgError("drvInitializeWia", y); goto Cleanup; }
    DBG_FN("CWiaMiniDriver::drvInitializeWia");

    HRESULT hr = S_OK;
    *plDevErrVal = DEVERR_OK;

    if (!ppDrvItemRoot || !ppunkInner || !plDevErrVal)
    {
        wiauDbgError("drvInitializeWia", "invalid arg");
        return E_INVALIDARG;
    }

    *ppDrvItemRoot = NULL;
    *ppunkInner = NULL;

    m_OpenApps++;

    //
    // If this is the first app, create everything
    //
    if (m_OpenApps == 1)
    {
        //
        // Load the strings from the resource
        //
        hr = LoadStrings();
        REQUIRE_SUCCESS_(hr, "LoadStrings failed");

        //
        // Set up a mutex to guarantee exclusive access to the device and the minidriver's structures
        //
        if(!m_hPtpMutex) {
            m_hPtpMutex = CreateMutex(NULL, FALSE, NULL);
            REQUIRE(m_hPtpMutex, "CreateMutex failed");
        }

        {
            CPtpMutex cpm(m_hPtpMutex);

            *ppDrvItemRoot = NULL;

            //
            // Create event for waiting for TakePicture command to complete
            //
            if (!m_TakePictureDoneEvent)
            {
                m_TakePictureDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
                REQUIRE(m_TakePictureDoneEvent, "CreateEvent failed");
            }

            //
            // Allocate strings needed for later
            //
            if (!m_bstrDeviceId)
            {
                m_bstrDeviceId = SysAllocString(bstrDeviceID);
                REQUIRE(m_bstrDeviceId, "failed to allocate Device ID string");
            }

            if (!m_bstrRootItemFullName)
            {
                m_bstrRootItemFullName = SysAllocString(bstrRootItemFullName);
                REQUIRE(m_bstrRootItemFullName, "failed to allocate root item name");
            }

            //
            // Create a camera object. Right now we only handle USB, but in the future this could look at the
            // port name to figure out what type of camera to create.
            //
            if (!m_pPTPCamera)
            {
                m_pPTPCamera = new CUsbCamera;
                REQUIRE(m_pPTPCamera, "failed to new CUsbCamera");
            }

            //
            // Open the camera
            //
            if (!m_pPTPCamera->IsCameraOpen())
            {

                //
                // Retrieve the port name from the ISTIDeviceControl
                //
                WCHAR wcsPortName[MAX_PATH];
                hr = m_pDcb->GetMyDevicePortName(wcsPortName, sizeof(wcsPortName));
                REQUIRE_SUCCESS_(hr, "GetMyDevicePortName failed");
                
                hr = m_pPTPCamera->Open(wcsPortName, &EventCallback, &DataCallback, (LPVOID) this);
                REQUIRE_SUCCESS_(hr, "Camera open failed");
            }

            //
            // Open a session on the camera. Doesn't matter which session ID we use, so just use 1.
            //
            if (!m_pPTPCamera->IsCameraSessionOpen())
            {
                hr = m_pPTPCamera->OpenSession(WIA_SESSION_ID);
                REQUIRE_SUCCESS_(hr, "OpenSession failed");
            }

            //
            // Get the DeviceInfo for the camera
            //
            hr = m_pPTPCamera->GetDeviceInfo(&m_DeviceInfo);
            REQUIRE_SUCCESS_(hr, "GetDeviceInfo failed");

            //
            // Remove properties that aren't supported by WIA. RGB gain isn't supported
            // because PTP defines it as a string and WIA can't handle string ranges.
            //
            m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_RGBGAIN);
            m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_FUNCTIONMODE);

            //
            // Special hack for the Kodak DC4800
            //
            // Some property codes (which the camera says it supports) cause the camera to
            // stall the endpoint when the GetDevicePropDesc command is sent
            // The hack can be removed only if support of DC4800 is removed
            //
            if (m_pPTPCamera->GetHackModel() == HACK_MODEL_DC4800)
            {
                wiauDbgTrace("drvInitializeWia", "removing DC4800 unsupported props");

                const WORD KODAK_PROPCODE_D001 = 0xD001;

                m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_RGBGAIN);
                m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_FNUMBER);
                m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_FOCUSDISTANCE);
                m_DeviceInfo.m_SupportedProps.Remove(PTP_PROPERTYCODE_EXPOSURETIME);
                m_DeviceInfo.m_SupportedProps.Remove(KODAK_PROPCODE_D001);
            }

            //
            // Get all the StorageInfo structures
            //
            if (m_StorageIds.GetSize() == 0)
            {
                hr = m_pPTPCamera->GetStorageIDs(&m_StorageIds);
                REQUIRE_SUCCESS_(hr, "GetStorageIDs failed");

                CPtpStorageInfo tempSI;
                for (int count = 0; count < m_StorageIds.GetSize(); count++)
                {
                    REQUIRE(m_StorageInfos.Add(tempSI), "memory allocation failed");
                    
                    //
                    // Get info about logical storages only. If we ask for info about non-logical 
                    // storage (ejected media), it may stall the camera.
                    //
                    if (m_StorageIds[count] & PTP_STORAGEID_LOGICAL)
                    {
                        hr = m_pPTPCamera->GetStorageInfo(m_StorageIds[count], &m_StorageInfos[count]);
                        REQUIRE_SUCCESS_(hr, "GetStorageInfo failed");
                    }

                    //
                    // Add an empty entry to the DCIM handle array
                    //
                    ULONG dummy = 0;
                    REQUIRE(m_DcimHandle.Add(dummy), "add dcim handle failed");
                }
            }

            //
            // Get all of the property description structures supported by the device
            //
            if (m_PropDescs.GetSize() == 0)
            {
                CPtpPropDesc tempPD;
                int NumProps = m_DeviceInfo.m_SupportedProps.GetSize();
                REQUIRE(m_PropDescs.GrowTo(NumProps), "reallocation of supported properties array failed");

                PROP_INFO *pPropInfo = NULL;
                WORD PropCode = 0;

                for (int count = 0; count < NumProps; count++)
                {
                    PropCode = m_DeviceInfo.m_SupportedProps[count];

                    //
                    // Remove properties that aren't supported by this driver or by
                    // vendor entries in the INF
                    //
                    pPropInfo = PropCodeToPropInfo(PropCode);
                    if (!pPropInfo->PropId &&
                        PropCode != PTP_PROPERTYCODE_IMAGESIZE)
                    {
                        wiauDbgTrace("drvInitializeWia", "removing unsupported prop, 0x%04x", PropCode);

                        m_DeviceInfo.m_SupportedProps.RemoveAt(count);
                        NumProps--;
                        count--;
                    }

                    else
                    {
                        //
                        // Get the property description info from the device
                        //
                        REQUIRE(m_PropDescs.Add(tempPD), "add prop desc failed");

                        hr = m_pPTPCamera->GetDevicePropDesc(PropCode, &m_PropDescs[count]);
                        REQUIRE_SUCCESS_(hr, "GetDevicePropDesc failed");
                    }
                }
            }

            //
            // Cache the STI interface
            //
            if (!m_pStiDevice)
            {
                m_pStiDevice = (IStiDevice *)pStiDevice;
                m_pStiDevice->AddRef();
            }

            //
            // Build the tree, if we haven't already
            //
            if (!m_pDrvItemRoot)
            {
                hr = CreateDrvItemTree(&m_pDrvItemRoot);
                REQUIRE_SUCCESS_(hr, "CreateDrvItemTree failed");
            }
        }
    }

    *ppDrvItemRoot = m_pDrvItemRoot;
    
Cleanup:
    if(FAILED(hr)) {
        // force re-init to happen next time someone tries to create
        // device
        m_OpenApps = 0;
    }

    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();
    
    return hr;
}


//
// This methods gets called when a client connection is going away.
//
// Input:
//   pWiasContext -- Pointer to the WIA Root item context of the client's item tree.
//
HRESULT
CWiaMiniDriver::drvUnInitializeWia(BYTE *pWiasContext)
{
    DBG_FN("CWiaMiniDriver::drvUnInitializeWia");

    HRESULT hr = S_OK;

    if (!pWiasContext)
    {
        wiauDbgError("drvUnInitializeWia", "invalid arg");
        return E_INVALIDARG;
    }

    m_OpenApps--;

    if (m_OpenApps == 0)
    {
        Shutdown();
    }

    if(m_OpenApps < 0) {

        // allow unmatched drvUninializeWia calls and don't ever make
        // m_OpenApps negative
        
        m_OpenApps = 0;
    }

    return hr;
}

//
// This method executes a command on the device
//
// Input:
//   pWiasContext -- context used to call wias services
//   lFlags       -- Misc flags, not used
//   pCommandGuid -- the command guid
//   ppDrvItem    -- new IWiaDrvItem if the command creates new item
//   plDevErrVal  -- to return device error code
//
HRESULT
CWiaMiniDriver::drvDeviceCommand(
    BYTE    *pWiasContext,
    LONG    lFlags,
    const GUID  *pCommandGuid,
    IWiaDrvItem **ppDrvItem,
    LONG    *plDevErrVal
    )
{
    DBG_FN("CWiaMiniDriver::drvDeviceCommand");
    HRESULT hr = S_OK;

    if (!pWiasContext || !pCommandGuid || !ppDrvItem || !plDevErrVal)
    {
        wiauDbgError("drvDeviceCommand", "invalid arg");
        return E_INVALIDARG;
    }

    *ppDrvItem = NULL;
    *plDevErrVal = DEVERR_OK;

    if (*pCommandGuid == WIA_CMD_TAKE_PICTURE && m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_INITIATECAPTURE) >= 0)
    {
        LONG ItemType = 0;
        hr = wiasGetItemType(pWiasContext, &ItemType);
        if (FAILED(hr))
        {
            wiauDbgError("drvDeviceCommand", "wiasGetItemType failed");
            goto cleanup;
        }

        //
        // TakePicture only works on the root
        //

        if (WiaItemTypeRoot & ItemType)
        {
            hr = WriteDeviceProperties(pWiasContext);
            if (FAILED(hr))
            {
                wiauDbgError("drvDeviceCommand", "WriteDeviceProperties failed");
                goto cleanup;
            }

            hr = TakePicture(pWiasContext, ppDrvItem);
            if (FAILED(hr))
            {
                wiauDbgError("drvDeviceCommand", "TakePicture failed");
                goto cleanup;
            }
        }
    }

    else if (*pCommandGuid == WIA_CMD_SYNCHRONIZE)
    {
        //
        // Don't need to do anything, because the PTP driver is always in sync with the device
        //
    }

    else
    {
        hr = E_NOTIMPL;
    }

cleanup:
    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();

    return hr;
}

//
// This method deletes an object from the camera. The WIA service will ensure that
// the item has no children and has access rights to be deleted, and the service will
// take care of deleting the driver item and calling drvFreeItemContext.
//
// Input:
//   pWiasContext    -- wias context that identifies the item
//   lFlags      -- misc flags
//   plDevErrVal -- to return the device error
//
STDMETHODIMP
CWiaMiniDriver::drvDeleteItem(
                             BYTE *pWiasContext,
                             LONG lFlags,
                             LONG  *plDevErrVal
                             )
{
    DBG_FN("CWiaMiniDriver::drvDeleteItem");

    HRESULT hr = S_OK;

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvDeleteItem", "invalid arg");
        return E_INVALIDARG;
    }

    // 
    // Verify that PTP_OPCODE_DELETEOBJECT command is supported by the camera
    //
    if (m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_DELETEOBJECT) < 0)
    {
        wiauDbgError("drvDeleteItem", "PTP_OPCODE_DELETEOBJECT command is not supported by the camera");
        return E_NOTIMPL;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);
    
    IWiaDrvItem *pDrvItem;
    DRVITEM_CONTEXT *pItemCtx;

    hr = WiasContextToItemContext(pWiasContext, &pItemCtx, &pDrvItem);
    if (FAILED(hr))
    {
        wiauDbgError("drvDeleteItem", "WiasContextToItemContext failed");
        goto cleanup;
    }

    //
    // Delete the object on the camera
    //
    hr = m_pPTPCamera->DeleteObject(pItemCtx->pObjectInfo->m_ObjectHandle, 0);
    if (FAILED(hr))
    {
        wiauDbgError("drvDeleteItem", "DeleteObject failed");
        goto cleanup;
    }

    //
    // Keep count of the number of images
    //
    if (pItemCtx->pObjectInfo->m_FormatCode & PTP_FORMATMASK_IMAGE)
    {
        m_NumImages--;
    }

    //
    // Update Storage Info (we are especially interested in Free Space info)
    //
    hr  = UpdateStorageInfo(pItemCtx->pObjectInfo->m_StorageId);
    if (FAILED(hr))
    {
        wiauDbgError("drvDeleteItem", "UpdateStorageInfo failed");
        // we can proceed, even if storage info can't be updated
    }

    //
    // Remove the item from the m_HandleItem map
    //
    m_HandleItem.Remove(pItemCtx->pObjectInfo->m_ObjectHandle);

    //
    // Get the item's full name
    //
    BSTR bstrFullName;
    hr = pDrvItem->GetFullItemName(&bstrFullName);
    if (FAILED(hr))
    {
        wiauDbgError("drvDeleteItem", "GetFullItemName failed");
        goto cleanup;
    }
        
    //
    // Queue an "item deleted" event
    //
    hr = wiasQueueEvent(m_bstrDeviceId,
                        &WIA_EVENT_ITEM_DELETED,
                        bstrFullName);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "drvDeleteItem", "wiasQueueEvent failed");

        // Continue to free the string and return hr
    }

    SysFreeString(bstrFullName);

cleanup:
    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();

    return hr;
}

//
// This method updates Storage Info for the specified storage
// Input:
//   StorageId - ID of the sorage to be updated
//
HRESULT CWiaMiniDriver::UpdateStorageInfo(ULONG StorageId)
{
    HRESULT hr = S_FALSE;
    BOOL bDone = FALSE;
    for (int count = 0; (count < m_StorageIds.GetSize()) && (!bDone); count++)
    {
        if (m_StorageIds[count] == StorageId)
        {
            bDone = TRUE;
            hr = m_pPTPCamera->GetStorageInfo(m_StorageIds[count], &m_StorageInfos[count]);
        }
    }
    return hr;
}

//
// This method returns the device capabilities
//
// Input:
//   pWiasContext        -- wias service context
//   lFlags          -- indicate what capabilities to return
//   pCelt           -- to return number of entries are returned
//   ppCapbilities       -- to receive the capabilities
//   plDevErrVal     -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvGetCapabilities(
                                  BYTE        *pWiasContext,
                                  LONG        lFlags,
                                  LONG        *pCelt,
                                  WIA_DEV_CAP_DRV **ppCapabilities,
                                  LONG        *plDevErrVal
                                  )
{
    DBG_FN("CWiaMiniDriver::drvGetCapabilities");

    HRESULT hr = S_OK;

    if (!pCelt || !ppCapabilities || !plDevErrVal)
    {
        wiauDbgError("drvGetCapabilities", "invalid arg");
        return E_INVALIDARG;
    }
    
    *plDevErrVal = DEVERR_OK;
    
    //
    // Load the strings from the resource
    //
    hr = LoadStrings();
    if (FAILED(hr)) 
    {
        wiauDbgError("drvGetCapabilities", "LoadStrings failed");
        return E_FAIL;
    }

    //
    // check if we have already built the list of capabilities. If not, build it
    // It will have the following structure:
    //
    // XXXXXXXXXXXXXXXXXXXXXXXXX YYYYYYYYYYYYYYYYYYYYYYYYYYY ZZZZZZZZZZZZZZZZZZZZZZZ
    //    (predefined events)          (vendor events)        (predefined commands)
    //
    if (m_Capabilities == NULL)
    {
        UINT nVendorEvents = m_VendorEventMap.GetSize();
        if (nVendorEvents > MAX_VENDOR_EVENTS)
        {
            wiauDbgWarning("drvGetCapabilities", "vendor events limit exceeded, ignoring events over limit");
            nVendorEvents = MAX_VENDOR_EVENTS;
        }

        m_nEventCaps = NUMEVENTCAPS + nVendorEvents;
        m_nCmdCaps = NUMCMDCAPS; // we don't need to put vendor commands in the list. they are called through escape function

        m_Capabilities = new WIA_DEV_CAP_DRV[m_nEventCaps + m_nCmdCaps]; // WIA uses this array instead of copying, don't delete it
        if (m_Capabilities == NULL)
        {
            return E_OUTOFMEMORY;
        }

        //
        // create events first
        //
        memcpy(m_Capabilities, g_EventCaps, sizeof(g_EventCaps)); // default events

        for (UINT i = 0; i < nVendorEvents; i++) // vendor events
        {
            CVendorEventInfo *pEventInfo = m_VendorEventMap.GetValueAt(i);
            m_Capabilities[NUMEVENTCAPS + i].guid = pEventInfo->pGuid;
            m_Capabilities[NUMEVENTCAPS + i].ulFlags = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
            m_Capabilities[NUMEVENTCAPS + i].wszIcon = VendorEventIconString;
            m_Capabilities[NUMEVENTCAPS + i].wszName = pEventInfo->EventName;
            m_Capabilities[NUMEVENTCAPS + i].wszDescription = pEventInfo->EventName;
        }

        //
        // add commands
        //
        memcpy(m_Capabilities + m_nEventCaps, g_CmdCaps, sizeof(g_CmdCaps));
    }

    //
    // eventing code calls this entry point without first going
    // through drvInitializeWia
    //
    if(lFlags == WIA_DEVICE_EVENTS) 
    {
        *pCelt = m_nEventCaps;
        *ppCapabilities = m_Capabilities;
        return S_OK;
    }
    
    //
    // query if camera supports InitiateCapture command (if we hadn't already)
    //
    if (!m_fInitCaptureChecked)
    {
        m_fInitCaptureChecked = TRUE;
        CPtpMutex cpm(m_hPtpMutex); 
        
        if (m_DeviceInfo.m_SupportedOps.Find(PTP_OPCODE_INITIATECAPTURE) < 0)
        {
            m_nCmdCaps--;
        }
    }

    //
    // Report commands or (events and commands)
    //
    switch (lFlags)
    {
    case WIA_DEVICE_COMMANDS:
        *pCelt = m_nCmdCaps;
        //
        // Command capability list is right behind the event list
        //
        *ppCapabilities = m_Capabilities + m_nEventCaps;
        break;

    case (WIA_DEVICE_EVENTS | WIA_DEVICE_COMMANDS):
        *pCelt = m_nEventCaps + m_nCmdCaps;
        *ppCapabilities = m_Capabilities;
        break;

    default:
        break;
    }

    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();

    return hr;
}

//
// This method initializes an item's properties. If the item is the
// root item, this function initializes the device properties.
//
// Input:
//   pWiasContext -- wias service context
//   lFlags -- misc flags
//   plDevErrVal -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvInitItemProperties(
                                     BYTE    *pWiasContext,
                                     LONG    lFlags,
                                     LONG    *plDevErrVal
                                     )
{
    DBG_FN("CWiaMiniDriver::drvInitItemProperties");

    HRESULT hr = S_OK;

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvInitItemProperties", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "drvInitItemProperties", "wiasGetItemType failed");
        goto cleanup;
    }

    if (ItemType & WiaItemTypeRoot)
    {
        hr = InitDeviceProperties(pWiasContext);
        if (FAILED(hr))
        {
            wiauDbgError("drvInitItemProperties", "InitDeviceProperties failed");
            goto cleanup;
        }
    }
    else
    {
        hr = InitItemProperties(pWiasContext);
        if (FAILED(hr))
        {
            wiauDbgError("drvInitItemProperties", "InitItemProperties failed");
            goto cleanup;
        }
    }

cleanup:
    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();

    return hr;
}


//
// This method locks the device for exclusive use for the caller
//
// Input:
//   pWiasContext -- wias context
//   lFlags       -- misc flags
// Output:
//   plDevErrVal  -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvLockWiaDevice(
                                BYTE    *pWiasContext,
                                LONG    lFlags,
                                LONG    *plDevErrVal
                                )
{
    DBG_FN("CWiaMiniDriver::drvLockWiaDevice");
    *plDevErrVal = DEVERR_OK;
    return S_OK;
}

//
// This method unlocks the device
//
// Input:
//   pWiasContext -- wias context
//   lFlags       -- misc flags
// Output:
//   plDevErrVal  -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvUnLockWiaDevice(
                                  BYTE    *pWiasContext,
                                  LONG    lFlags,
                                  LONG    *plDevErrVal
                                  )
{
    DBG_FN("CWiaMiniDriver::drvUnLockWiaDevice");
    *plDevErrVal = DEVERR_OK;
    return S_OK;
}

//
// This method analyizes the given driver item. It is not implemented for cameras.
//
// Input:
//   pWiasContext -- wias context
//   lFlags       -- misc flags
// Output:
//   plDevErrVal  -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvAnalyzeItem(
                              BYTE *pWiasContext,
                              LONG lFlags,
                              LONG *plDevErrVal
                              )
{
    DBG_FN("CWiaMiniDriver::drvAnalyzeItem");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvAnalyzeItem", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    return E_NOTIMPL;
}

//
// This method returns the item's available format information. Every WIA
// minidriver must support WiaImgFmt_BMP and WiaImgFmt_MEMORYBMP. This could
// be a problem, because this driver can only decode JPEG and TIFF currently.
// For other formats, we will not advertise BMP formats.
//
// Input:
//   pWiasContext -- wias service context
//   lFlags       -- misc flags
//   pcelt        -- to return how many format info the item has
//   ppwfi        -- to hold a pointer to the format info
// Output:
//   plDevErrVal  -- to return device error code
//
STDMETHODIMP
CWiaMiniDriver::drvGetWiaFormatInfo(
                                   BYTE    *pWiasContext,
                                   LONG    lFlags,
                                   LONG    *pcelt,
                                   WIA_FORMAT_INFO **ppwfi,
                                   LONG    *plDevErrVal
                                   )
{
    DBG_FN("CWiaMiniDriver::drvGetWiaFormatInfo");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pcelt || !ppwfi || !plDevErrVal)
    {
        wiauDbgError("drvGetWiaFormatInfo", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    *pcelt = 0;
    *ppwfi = NULL;

    DRVITEM_CONTEXT *pItemCtx = NULL;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        wiauDbgError("drvGetWiaFormatInfo", "WiasContextToItemContext failed");
        goto cleanup;
    }

    if (!pItemCtx)
    {
        wiauDbgError("drvGetWiaFormatInfo", "item context is null");
        hr = E_FAIL;
        goto cleanup;
    }

    if (!pItemCtx->pFormatInfos)
    {
        //
        // The format info list is not intialized. Do it now.
        //

        LONG ItemType;
        DWORD ui32;

        hr = wiasGetItemType(pWiasContext, &ItemType);
        if (FAILED(hr))
        {
            wiauDbgErrorHr(hr, "drvGetWiaFormatInfo", "wiasGetItemType failed");
            goto cleanup;
        }

        if (ItemType & WiaItemTypeFile)
        {
            //
            // Create the supported format for the item, based on the format stored in the
            // ObjectInfo structure.
            //
            if (!pItemCtx->pObjectInfo)
            {
                wiauDbgError("drvGetWiaFormatInfo", "pObjectInfo not initialized");
                hr = E_FAIL;
                goto cleanup;
            }

            //
            // If the format is JPEG or TIFF based, add the BMP types to the format array,
            // since this driver can convert those to BMP
            //
            WORD FormatCode = pItemCtx->pObjectInfo->m_FormatCode;
            BOOL bAddBmp = (FormatCode == PTP_FORMATCODE_IMAGE_EXIF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_TIFFEP) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_TIFF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_JFIF) || 
                           (FormatCode == PTP_FORMATCODE_IMAGE_FLASHPIX) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_BMP) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_CIFF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_GIF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_JFIF) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_PCD) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_PICT) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_PNG) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_TIFFIT) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_JP2) ||
                           (FormatCode == PTP_FORMATCODE_IMAGE_JPX);


            ULONG NumWfi = bAddBmp ? 2 : 1;

            //
            // Allocate two entries for each format, one for file transfer and one for callback
            //
            WIA_FORMAT_INFO *pwfi = new WIA_FORMAT_INFO[2 * NumWfi];
            if (!pwfi)
            {
                wiauDbgError("drvGetWiaFormatInfo", "memory allocation failed");
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            FORMAT_INFO *pFormatInfo = FormatCodeToFormatInfo(FormatCode);
            pwfi[0].lTymed = TYMED_FILE;
            pwfi[1].lTymed = TYMED_CALLBACK;
            
            if(pFormatInfo->FormatGuid) {
                pwfi[0].guidFormatID = *pFormatInfo->FormatGuid;
                pwfi[1].guidFormatID = *pFormatInfo->FormatGuid;
            } else {
                pwfi[0].guidFormatID = WiaImgFmt_UNDEFINED;
                pwfi[1].guidFormatID = WiaImgFmt_UNDEFINED;
            }

            //
            // Add the BMP entries when appropriate
            //
            if (bAddBmp)
            {
                pwfi[2].guidFormatID = WiaImgFmt_BMP;
                pwfi[2].lTymed = TYMED_FILE;
                pwfi[3].guidFormatID = WiaImgFmt_MEMORYBMP;
                pwfi[3].lTymed = TYMED_CALLBACK;
            }

            pItemCtx->NumFormatInfos = 2 * NumWfi;
            pItemCtx->pFormatInfos = pwfi;

        }

        else if ((ItemType & WiaItemTypeFolder) ||
                 (ItemType & WiaItemTypeRoot))
        {
            //
            // Folders and the root don't really need format info, but some apps may fail
            // without it. Create a fake list just in case.
            //
            pItemCtx->pFormatInfos = new WIA_FORMAT_INFO[2];

            if (!pItemCtx->pFormatInfos)
            {
                wiauDbgError("drvGetWiaFormatInfo", "memory allocation failed");
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            pItemCtx->NumFormatInfos = 2;
            pItemCtx->pFormatInfos[0].lTymed = TYMED_FILE;
            pItemCtx->pFormatInfos[0].guidFormatID = FMT_NOTHING;
            pItemCtx->pFormatInfos[1].lTymed = TYMED_CALLBACK;
            pItemCtx->pFormatInfos[1].guidFormatID = FMT_NOTHING;
        }
    }

    *pcelt = pItemCtx->NumFormatInfos;
    *ppwfi = pItemCtx->pFormatInfos;

cleanup:
    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();

    return hr;
}

//
// This method processes pnp events
//
// Input:
//   pEventGuid   -- the event identifier
//   bstrDeviceId -- the designated device
//   ulReserved   -- reserved
//
STDMETHODIMP
CWiaMiniDriver::drvNotifyPnpEvent(
                                 const GUID  *pEventGuid,
                                 BSTR    bstrDeviceId,
                                 ULONG   ulReserved
                                 )
{
    return S_OK;
}

//
// This method reads the item properties
//
// Input:
//     pWiasContext     -- wias context
//     lFlags           -- misc flags
//     NumPropSpecs     -- number of properties to be read
//     pPropSpecs       -- an array of PROPSPEC that specifies
//                 what properties should be read
//     plDevErrVal      -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvReadItemProperties(
                                     BYTE    *pWiasContext,
                                     LONG    lFlags,
                                     ULONG   NumPropSpecs,
                                     const PROPSPEC *pPropSpecs,
                                     LONG    *plDevErrVal
                                     )
{
    DBG_FN("CWiaMiniDriver::drvReadItemProperties");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pPropSpecs || !plDevErrVal)
    {
        wiauDbgError("drvReadItemProperties", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType = 0;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("drvReadItemProperties", "wiasGetItemType failed");
        goto cleanup;
    }

    if (WiaItemTypeRoot & ItemType)
        hr = ReadDeviceProperties(pWiasContext, NumPropSpecs, pPropSpecs);
    else
        hr = ReadItemProperties(pWiasContext, NumPropSpecs, pPropSpecs);

cleanup:
    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();

    return hr;
}

//
// This method writes the item properties
//
// Input:
//     pWiasContext     -- wias context
//     lFlags           -- misc flags
//     pmdtc            -- mini driver transfer context
//     plDevErrVal      -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvWriteItemProperties(
                                      BYTE    *pWiasContext,
                                      LONG    lFlags,
                                      PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                      LONG    *plDevErrVal
                                      )
{
    DBG_FN("CWiaMiniDriver::drvWriteItemProperties");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pmdtc || !plDevErrVal)
    {
        wiauDbgError("drvWriteItemProperties", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType = 0;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("drvWriteItemProperties", "wiasGetItemType failed");
        goto cleanup;
    }

    //
    // Only properties to write are on the root
    //

    if (WiaItemTypeRoot & ItemType)
    {
        hr = WriteDeviceProperties(pWiasContext);
        if (FAILED(hr))
        {
            wiauDbgError("drvWriteItemProperties", "WriteDeviceProperties failed");
            goto cleanup;
        }
    }

cleanup:
    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();

    return hr;
}

//
// This method validates the item properties
//
// Input:
//     pWiasContext     -- wias context
//     lFlags           -- misc flags
//     NumPropSpecs     -- number of properties to be read
//     pPropSpecs       -- an array of PROPSPEC that specifies
//                 what properties should be read
//     plDevErrVal      -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvValidateItemProperties(
                                         BYTE    *pWiasContext,
                                         LONG    lFlags,
                                         ULONG   NumPropSpecs,
                                         const   PROPSPEC *pPropSpecs,
                                         LONG    *plDevErrVal
                                         )
{
    DBG_FN("CWiaMiniDriver::drvValidateItemProperties");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pPropSpecs || !plDevErrVal)
    {
        wiauDbgError("drvValidateItemProperties", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType = 0;
    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("drvValidateItemProperties", "wiasGetItemType failed");
        goto cleanup;
    }

    if (WiaItemTypeRoot & ItemType)
    {
        hr = ValidateDeviceProperties(pWiasContext, NumPropSpecs, pPropSpecs);
        if (FAILED(hr))
        {
            wiauDbgError("drvValidateItemProperties", "ValidateDeviceProperties failed");
            goto cleanup;
        }
    }
    else
    {
        hr = ValidateItemProperties(pWiasContext, NumPropSpecs, pPropSpecs, ItemType);
        if (FAILED(hr))
        {
            wiauDbgError("drvValidateItemProperties", "ValidateItemProperties failed");
            goto cleanup;
        }
    }

cleanup:
    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();

    return hr;
}

//
// This method acquires the item's data
//
// Input:
//     pWiasContext     -- wias context
//     lFlags           -- misc flags
//     pmdtc            -- mini driver transfer context
//     plDevErrVal      -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvAcquireItemData(
                                  BYTE    *pWiasContext,
                                  LONG    lFlags,
                                  PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                  LONG    *plDevErrVal
                                  )
{
    DBG_FN("CWiaMiniDriver::drvAcquireItemData");

    HRESULT hr = S_OK;

    if (!pWiasContext || !pmdtc || !plDevErrVal)
    {
        wiauDbgError("drvAcquireItemData", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    CPtpMutex cpm(m_hPtpMutex);

    LONG ItemType = 0;

    hr = wiasGetItemType(pWiasContext, &ItemType);
    if (FAILED(hr))
    {
        wiauDbgError("drvAcquireItemData", "wiasGetItemType failed");
        goto cleanup;
    }

    DRVITEM_CONTEXT *pItemCtx;
    hr = WiasContextToItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        wiauDbgError("AcquireData", "WiasContextToItemContext failed");
        goto cleanup;
    }

    wiauDbgTrace("drvAcquireItemData", "transferring image with tymed, 0x%08x", pmdtc->tymed);

    //
    // Translate to BMP, if needed. Otherwise just transfer the data.
    //
    if ((IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP) ||
         IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) &&
         (pItemCtx->pObjectInfo->m_FormatCode != PTP_FORMATCODE_IMAGE_BMP))
    {
        hr = AcquireDataAndTranslate(pWiasContext, pItemCtx, pmdtc);
        if (FAILED(hr))
        {
            wiauDbgError("drvAcquireItemData", "AcquireDataAndTranslate failed");
            goto cleanup;
        }
    }
    else
    {
        hr = AcquireData(pItemCtx, pmdtc);
        if (FAILED(hr))
        {
            wiauDbgError("drvAcquireItemData", "AcquireData failed");
            goto cleanup;
        }
    }

cleanup:
    //
    // Update WIA on any changes in camera's state, like 'camera was reset'
    //
    NotifyWiaOnStateChanges();

    return hr;
}

//
// This method returns a description about the given device error code
//
// Input:
//   lFlags      -- misc flags
//   lDevErrVal  -- the designated error code
//   ppDevErrStr -- to receive a string pointer to the description
//   plDevErrVal -- device error code(used to report error if this method
//                  need to retreive the string from the device
//
STDMETHODIMP
CWiaMiniDriver::drvGetDeviceErrorStr(
                                    LONG    lFlags,
                                    LONG    lDevErrVal,
                                    LPOLESTR    *ppDevErrStr,
                                    LONG    *plDevErrVal
                                    )
{
    DBG_FN("CWiaMiniDriver::drvGetDeviceErrorStr");

    HRESULT hr = S_OK;

    if (!ppDevErrStr || !plDevErrVal)
    {
        wiauDbgError("drvGetDeviceErrorStr", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal  = DEVERR_OK;

    //
    // WIAFIX-10/2/2000-davepar No device-specific errors at this time
    //

    return E_NOTIMPL;
}

//
// This method frees the given driver item context
//
// Input:
//   lFlags      -- misc flags
//   pItemCtx    -- the item context to be freed
//   plDevErrVal -- to return device error
//
STDMETHODIMP
CWiaMiniDriver::drvFreeDrvItemContext(
                                     LONG lFlags,
                                     BYTE  *pContext,
                                     LONG *plDevErrVal
                                     )
{
    DBG_FN("CWiaMiniDriver::drvFreeDrvItemContext");

    HRESULT hr = S_OK;

    if (!pContext || !plDevErrVal)
    {
        wiauDbgError("drvFreeDrvItemContext", "invalid arg");
        return E_INVALIDARG;
    }

    *plDevErrVal = DEVERR_OK;

    DRVITEM_CONTEXT *pItemCtx = (DRVITEM_CONTEXT *)pContext;

    if (pItemCtx)
    {
        if (pItemCtx->pThumb)
        {
            delete []pItemCtx->pThumb;
            pItemCtx->pThumb = NULL;
        }

        if (pItemCtx->pFormatInfos)
        {
            delete [] pItemCtx->pFormatInfos;
            pItemCtx->pFormatInfos = NULL;
        }

        if (pItemCtx->pObjectInfo)
        {
            delete pItemCtx->pObjectInfo;
        }
    }

    return hr;
}

//
// This function will shutdown the driver
//
HRESULT
CWiaMiniDriver::Shutdown()
{
    DBG_FN("CWiaMiniDriver::Shutdown");

    HRESULT hr = S_OK;

    //
    // Close the camera
    //
    wiauDbgTrace("Shutdown", "closing connection with camera");

    if (m_pPTPCamera) {
        hr = m_pPTPCamera->Close();
        if (FAILED(hr))
        {
            wiauDbgError("Shutdown", "Close failed");
        }
    }

    //
    // Free data structures
    //
    if (m_pDrvItemRoot)
    {
        m_pDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);
        m_pDrvItemRoot->Release();
        m_pDrvItemRoot = NULL;
    }

    if (m_pPTPCamera)
    {
        delete m_pPTPCamera;
        m_pPTPCamera = NULL;
    }

    m_StorageIds.RemoveAll();
    m_StorageInfos.RemoveAll();
    m_PropDescs.RemoveAll();

    //
    // CWiaMap<ULONG, IWiaDrvItem *> m_HandleItem - we don't need to delete IWiaDrvItem 
    // objects here, they are destroyed when items tree is unlinked
    //
    m_HandleItem.RemoveAll();

    m_NumImages = 0;

    if (m_bstrDeviceId)
    {
        SysFreeString(m_bstrDeviceId);
        m_bstrDeviceId = NULL;
    }

    if (m_bstrRootItemFullName)
    {
        SysFreeString(m_bstrRootItemFullName);
        m_bstrRootItemFullName = NULL;
    }

    if (m_TakePictureDoneEvent) {
        CloseHandle(m_TakePictureDoneEvent);
        m_TakePictureDoneEvent = NULL;
    }

    if (m_hPtpMutex) {
        CloseHandle(m_hPtpMutex);
        m_hPtpMutex = NULL;
    }

    m_DcimHandle.RemoveAll();

    //
    // CWiaMap<ULONG, IWiaDrvItem *> m_AncAssocParent - we don't need to delete IWiaDrvItem 
    // objects here, they are destroyed when items tree is unlinked
    //
    m_AncAssocParent.RemoveAll();

    return hr;
}

//
// This function asks the camera to take a picture. It also inserts
// the new picture into the drive item tree.
//
// Input:
//   pWiasContext        -- wias context
//   lFlags          -- misc flags
//   plDevErrVal     -- to return device error code
//
HRESULT
CWiaMiniDriver::TakePicture(
                           BYTE *pWiasContext,
                           IWiaDrvItem **ppNewItem
                           )
{
    DBG_FN("CWiaMiniDriver::TakePicture");

    HRESULT hr = S_OK;

    if (!pWiasContext || !ppNewItem)
    {
        wiauDbgError("TakePicture", "invalid arg");
        return E_INVALIDARG;
    }

    IWiaDrvItem     *pDrvItem, *pParentItem;
    DRVITEM_CONTEXT *pItemCtx = NULL;

    *ppNewItem = NULL;
    WORD FormatCode = 0;

    //
    // Kodak DC4800 must have the format code parameter set to zero
    // This hack can be removed only if support of Kodak DC4800 is removed
    //
    if (m_pPTPCamera->GetHackModel() == HACK_MODEL_DC4800)
    {
        FormatCode = 0;
    }
    else
    {
        //
        // Determine which format to capture
        //
        GUID FormatGuid;
        hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &FormatGuid, NULL, TRUE);
        if (FAILED(hr))
        {
            wiauDbgError("TakePicture", "wiasReadPropLong failed");
            return hr;
        }

        FormatCode = FormatGuidToFormatCode(&FormatGuid);
    }

    {
        CPtpMutex cpm(m_hPtpMutex);

        //
        // Reset the event that is waited upon below
        //
        if (!ResetEvent(m_TakePictureDoneEvent))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            wiauDbgErrorHr(hr, "TakePicture", "ResetEvent failed");
            return hr;
        }

        //
        // Clear the list of captured objects
        //
        m_CapturedObjects.RemoveAll();

        //
        // Start the image capture
        //
        hr = m_pPTPCamera->InitiateCapture(PTP_STORAGEID_DEFAULT, FormatCode);
        if (FAILED(hr))
        {
            wiauDbgError("TakePicture", "InitiateCapture failed");
            return hr;
        }
    }

    //
    // Estimate how long the capture may take. Assume 30 seconds for a simple single shot.
    //
    DWORD dwCaptureTimeout = 30000;

    //
    // Check if there is CaptureDelay, and add it to timeout
    //
    int nIndex = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_CAPTUREDELAY);
    if (nIndex != -1)
    {
        DWORD dwCaptureDelay = m_PropDescs[nIndex].m_lCurrent;
        dwCaptureTimeout += dwCaptureDelay;
    }

    //
    // Check if the camera is in Burst or Timelapse mode
    // 
    nIndex = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_STILLCAPTUREMODE);
    if (nIndex != -1)
    {
        DWORD dwFuncMode = m_PropDescs[nIndex].m_lCurrent;
        
        if (dwFuncMode == PTP_CAPTUREMODE_BURST)
        {
            //
            // Calculate how much time burst operation may take ((BurstNumber - 1) * BurstInterval)
            //
            DWORD dwBurstNumber = 1;
            DWORD dwBurstInterval = 1000; // assume 1 second per picture, if device does not specify interval

            nIndex = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_BURSTNUMBER);
            if (nIndex != -1)
            {
                dwBurstNumber = m_PropDescs[nIndex].m_lCurrent;
            }

            nIndex = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_BURSTINTERVAL);
            if (nIndex != -1)
            {
                dwBurstInterval = m_PropDescs[nIndex].m_lCurrent;
            }

            dwCaptureTimeout += (dwBurstNumber - 1) * dwBurstInterval;
        }
        else if (dwFuncMode == PTP_CAPTUREMODE_TIMELAPSE)
        {
            //
            // Calculate how much time timelapse operation may take ((TimelapseNumber - 1) * TimelapseInterval)
            //
            DWORD dwTimelapseNumber = 1;
            DWORD dwTimelapseInterval = 1000; // assume 1 second per picture, if device does not specify interval

            nIndex = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_TIMELAPSENUMBER);
            if (nIndex != -1)
            {
                dwTimelapseNumber = m_PropDescs[nIndex].m_lCurrent;
            }

            nIndex = m_DeviceInfo.m_SupportedProps.Find(PTP_PROPERTYCODE_TIMELAPSEINTERVAL);
            if (nIndex != -1)
            {
                dwTimelapseInterval = m_PropDescs[nIndex].m_lCurrent;
            }

            dwCaptureTimeout += (dwTimelapseNumber - 1) * dwTimelapseInterval;
        }
    }
    
    //
    // Wait for the TakePicture command to be done, indicated by CaptureComplete or StoreFull event.
    // 

    wiauDbgTrace("TakePicture", "Calling WaitForSingleObject with %d ms timeout", dwCaptureTimeout);

    if (WaitForSingleObject(m_TakePictureDoneEvent, dwCaptureTimeout) != WAIT_OBJECT_0)
    {
        wiauDbgWarning("TakePicture", "WaitForSingleObject timed out");
        return S_FALSE;
    }

    //
    // Process all objects reported during the capture (there may be many if camera supports burst capture)
    //
    CPtpMutex cpm(m_hPtpMutex); // Grab mutex until the end of the function

    int nCapturedObjects = m_CapturedObjects.GetSize();

    if (nCapturedObjects > 0)
    {
        wiauDbgTrace("TakePicture", "Processing %d objects", nCapturedObjects);

        //
        // Add the first object (in case of burst capture it should folder)
        //
        hr = AddObject(m_CapturedObjects[0], TRUE);
        if (FAILED(hr))
        {
            wiauDbgErrorHr(hr, "TakePicture", "AddObject failed");
            return hr;
        }

        //
        // The last item added to the m_HandleItem map will be the new object
        //
        // In case of burst capture, new images will be stored in a folder (TimeSequence association)
        // Handle of the folder must come first. Return the corresponding WIA item as a result of TakePicture.
        //
        wiauDbgTrace("TakePicture", "new item is 0x%08x", m_HandleItem.GetKeyAt(m_HandleItem.GetSize() - 1));
        *ppNewItem = m_HandleItem.GetValueAt(m_HandleItem.GetSize() - 1);

        //
        // Add the remaining objects
        //
        for (int i = 1; i < nCapturedObjects; i++)
        {
            hr = AddObject(m_CapturedObjects[i], TRUE);
            if (FAILED(hr))
            {
                wiauDbgErrorHr(hr, "TakePicture", "AddObject failed");
                return hr;
            }
        }

    }
    else
    {
        //
        // There are no new objects, storage filled up too quickly
        //
        wiauDbgError("TakePicture", "InitiateCapture did not produce any new objects");
        return HRESULT_FROM_PTP(PTP_RESPONSECODE_STOREFULL);
    }

    return hr;
}

//
// This function add up all the free image space on each storage.
//
LONG
CWiaMiniDriver::GetTotalFreeImageSpace()
{
    DBG_FN("CWiaMiniDriver::GetTotalFreeImageSpace");

    int count;
    LONG imageSpace = 0;
    for (count = 0; count < m_StorageInfos.GetSize(); count++)
    {
        imageSpace += m_StorageInfos[count].m_FreeSpaceInImages;
    }

    return imageSpace;
}

//
// This function gets the item context from the given wias context and
// optionally return the target IWiaDrvItem. At least one of ppItemContext
// and ppDrvItem must be valid.
//
// Input:
//   pWiasContext -- wias context obtained from every drvxxxx method
//   ppItemContext -- optional parameter to receive the item context
//   ppDrvItem -- optional parameter to receive the IWiaDrvItem
//
HRESULT
CWiaMiniDriver::WiasContextToItemContext(
    BYTE *pWiasContext,
    DRVITEM_CONTEXT **ppItemContext,
    IWiaDrvItem     **ppDrvItem
    )
{
    DBG_FN("CWiaMiniDriver::WiasContextToItemContext");

    HRESULT hr = S_OK;

    IWiaDrvItem *pWiaDrvItem;

    if (!pWiasContext || (!ppItemContext && !ppDrvItem))
    {
        wiauDbgError("WiasContextToItemContext", "invalid arg");
        return E_INVALIDARG;
    }

    if (ppDrvItem)
        *ppDrvItem = NULL;

    hr = wiasGetDrvItem(pWiasContext, &pWiaDrvItem);
    if (FAILED(hr))
    {
        wiauDbgErrorHr(hr, "WiasContextToItemContext", "wiasGetDrvItem failed");
        return hr;
    }

    if (ppDrvItem)
        *ppDrvItem = pWiaDrvItem;

    if (ppItemContext)
    {
        *ppItemContext = NULL;
        hr = pWiaDrvItem->GetDeviceSpecContext((BYTE **)ppItemContext);
        if (FAILED(hr))
        {
            wiauDbgError("WiasContextToItemContext", "GetDeviceSpecContext failed");
            return hr;
        }
    }

    return hr;
}

//
// This function loads all the object name strings
//
HRESULT
CWiaMiniDriver::LoadStrings()
{
    HRESULT hr = S_OK;

    if (UnknownString[0] != L'\0')
    {
        //
        // The strings are already loaded
        //
        return hr;
    }

    hr = GetResourceString(IDS_UNKNOWNSTRING, UnknownString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_FOLDERSTRING, FolderString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_SCRIPTSTRING, ScriptString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_EXECSTRING, ExecString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_TEXTSTRING, TextString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_HTMLSTRING, HtmlString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_DPOFSTRING, DpofString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_AUDIOSTRING, AudioString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_VIDEOSTRING, VideoString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_UNKNOWNIMGSTRING, UnknownImgString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_IMAGESTRING, ImageString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_ALBUMSTRING, AlbumString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_BURSTSTRING, BurstString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_PANORAMASTRING, PanoramaString, MAX_PATH);
    if (FAILED(hr)) return hr;

    hr = GetResourceString(IDS_DEVICECONNECTED, DeviceConnectedString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_DEVICEDISCONNECTED, DeviceDisconnectedString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_ITEMCREATED, ItemCreatedString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_ITEMDELETED, ItemDeletedString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_TAKEPICTURE, TakePictureString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_SYNCHRONIZE, SynchronizeString, MAX_PATH);
    if (FAILED(hr)) return hr;
    hr = GetResourceString(IDS_TREEUPDATED, TreeUpdatedString, MAX_PATH);
    if (FAILED(hr)) return hr;

    //
    // Concatenate %ld on the end of each object name string so they can be used in a sprintf statement
    //
    hr = StringCchCatW(UnknownString, ARRAYSIZE(UnknownString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(UnknownString, ARRAYSIZE(UnknownString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(FolderString, ARRAYSIZE(FolderString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(ScriptString, ARRAYSIZE(ScriptString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(ExecString, ARRAYSIZE(ExecString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(TextString, ARRAYSIZE(TextString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(HtmlString, ARRAYSIZE(HtmlString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(DpofString, ARRAYSIZE(DpofString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(AudioString, ARRAYSIZE(AudioString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(VideoString, ARRAYSIZE(VideoString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(UnknownImgString, ARRAYSIZE(UnknownImgString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(ImageString, ARRAYSIZE(ImageString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(AlbumString, ARRAYSIZE(AlbumString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(BurstString, ARRAYSIZE(BurstString), L"%ld");
    if (SUCCEEDED(hr)) hr = StringCchCatW(PanoramaString, ARRAYSIZE(PanoramaString), L"%ld");

    return hr;
}

//
// This function retrieves a string from the resource file and returns a Unicode string. The caller
// is responsible for allocating space for the string before calling this function.
//
// Input:
//   lResourceID -- resource id of the string
//   pString -- pointer to receive the string
//   length -- length of the string in characters
//
HRESULT
CWiaMiniDriver::GetResourceString(
    LONG lResourceID,
    WCHAR *pString,
    int length
    )
{
    HRESULT hr = S_OK;

#ifdef UNICODE
    if (::LoadString(g_hInst, lResourceID, pString, length) == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        wiauDbgErrorHr(hr, "GetResourceString", "LoadString failed");
        return hr;
    }

#else
       TCHAR szStringValue[255];
       if (::LoadString(g_hInst,lResourceID,szStringValue,255) == 0)
       {
           hr = HRESULT_FROM_WIN32(::GetLastError());
           wiauDbgErrorHr(hr, "GetResourceString", "LoadString failed");
           return hr;
       }

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           pString,
                           sizeof(length));

#endif

    return hr;
}

//
// To support vendor extension, new registry entries are defined under the
// DeviceData subkey. These entries are created from the vendor INF
// during device setup. Sample INF entries:
//
// [DeviceData]
// VendorExtID=0x12345678
// PropCode="0xD001,0xD002,0xD003"
// PropCodeD001="0x1C01,Vendor property 1"
// PropCodeD002="0x1C02,Vendor property 2"
// PropCodeD003="0x1C03,Vendor property 3"
// EventCode="0xC001,0xC002"
// EventCodeC001={191D9AE7-EE8C-443c-B3E8-A3F87E0CF3CC}
// EventCodeC002={8162F5ED-62B7-42c5-9C2B-B1625AC0DB93}
//
// The VendorExtID entry should be the PIMA assigned vendor extension code.
//
// The PropCode entry must list all of the vendor extended PropCodes.
// For each value in PropCode, an entry of the form PropCodeXXXX must be
// present, where XXXX is the hex value of the prop code (uppercase). The
// value for that entry is the WIA property ID and description (which does not
// need to be localized).
//
// The EventCode entry work similarly, where each EventCodeXXXX entry lists the event
// GUID that will be posted when the event occurs.
//

const TCHAR REGSTR_DEVICEDATA[]     = TEXT("DeviceData");
const TCHAR REGSTR_VENDORID[]       = TEXT("VendorExtID");
const TCHAR REGSTR_TWODIGITSMILLISECONDS[] = TEXT("TwoDigitsMillisecondsOutput");
const TCHAR REGSTR_PROPCODE[]       = TEXT("PropCode");
const TCHAR REGSTR_PROPCODE_MASK[]  = TEXT("PropCode%04X");
const TCHAR REGSTR_EVENTCODE[]      = TEXT("EventCode");
const TCHAR REGSTR_EVENTCODE_MASK[] = TEXT("EventCode%04X");
const TCHAR REGSTR_EVENTS_MASK[]    = TEXT("Events\\%s");

//
// This function initializes vendor extentions from the provided
// registry key
//
// Input:
//  hkDevParams -- the registry key under which the vendor extentions are defined.
//
HRESULT
CWiaMiniDriver::InitVendorExtentions(HKEY hkDevParams)
{
    USES_CONVERSION;
    
    DBG_FN("CWiaMiniDriver::InitVendorExtentions");

    HRESULT hr = S_OK;

    if (!hkDevParams)
    {
        wiauDbgError("InitVendorExtentions", "invalid arg");
        return E_INVALIDARG;
    }

    CPTPRegistry regDevData;

    hr = regDevData.Open(hkDevParams, REGSTR_DEVICEDATA);
    if (FAILED(hr))
    {
        wiauDbgError("InitVendorExtentions", "Open DeviceData failed");
        return hr;
    }

    //
    // Check if this device requires two digits for milliseconds in DATETIME string
    //
    DWORD dwTwoDigitsMs = 0;
    hr = regDevData.GetValueDword(REGSTR_TWODIGITSMILLISECONDS, &dwTwoDigitsMs);
    if (SUCCEEDED(hr) && dwTwoDigitsMs)
    {
        wiauDbgTrace("InitVendorExtensions", "This device requires two digits for milliseconds in DATETIME string");
        m_bTwoDigitsMillisecondsOutput = TRUE;
    }

    //
    // Get the vendor extension ID
    //
    hr = regDevData.GetValueDword(REGSTR_VENDORID, &m_VendorExtId);
    if (FAILED(hr))
        wiauDbgWarning("InitVendorExtentions", "couldn't read vendor extension id");

    wiauDbgTrace("InitVendorExtentions", "vendor extension id = 0x%08x", m_VendorExtId);

    //
    // Get the list of vendor extended property codes
    //
    CArray16 VendorPropCodes;
    hr = regDevData.GetValueCodes(REGSTR_PROPCODE, &VendorPropCodes);

    wiauDbgTrace("InitVendorExtentions", "%d vendor prop codes found", VendorPropCodes.GetSize());

    //
    // For each property code, get it's information, i.e. the WIA prop id and string
    //
    int count = 0;
    TCHAR name[MAX_PATH];
    TCHAR nameFormat[MAX_PATH];
    TCHAR value[MAX_PATH];
    
    DWORD valueLen = MAX_PATH;
    PROP_INFO *pPropInfo = NULL;
    WCHAR *pPropStr = NULL;

    const cchPropStrBuf = MAX_PATH;
    
    #ifndef UNICODE    
    TCHAR PropStrBuf[cchPropStrBuf];
    #else
    #define PropStrBuf pPropStr
    #endif
    
    int num;
    if (SUCCEEDED(hr))
    {
        // 
        // Read vendor property info.
        // sample key = "PropCodeD001", sample value = "0x00009802,Vendor property 1"
        //
        for (count = 0; count < VendorPropCodes.GetSize(); count++)
        {
            hr = StringCchPrintf(name, ARRAYSIZE(name), REGSTR_PROPCODE_MASK, VendorPropCodes[count]);
            if (FAILED(hr))
            {
                wiauDbgErrorHr(hr, "InitVendorExtensions", "StringCchPrintf failed");
                return hr;
            }

            valueLen = sizeof(value);
            hr = regDevData.GetValueStr(name, value, &valueLen);
            if (FAILED(hr))
            {
                wiauDbgError("InitVendorExtentions", "vendor extended PropCode not found 0x%04x", VendorPropCodes[count]);
                return hr;
            }

            pPropInfo = new PROP_INFO;
            pPropStr = new WCHAR[cchPropStrBuf];
            if (!pPropInfo || !pPropStr)
            {
                wiauDbgError("InitVendorExtentions", "memory allocation failed");
                return E_OUTOFMEMORY;
            }

            pPropInfo->PropName = pPropStr;
            *PropStrBuf = TEXT('\0');
            
            //
            // Parse property info
            //
            hr = E_FAIL;          // assume string is bad
            TCHAR *pTemp = NULL;

            pPropInfo->PropId = _tcstoul(value, &pTemp, 0); // determine number base automatically
            if (pPropInfo->PropId != 0)
            {
                pTemp = _tcschr(value, TEXT(','));
                if (pTemp != NULL && *(pTemp + 1) != TEXT('\0')) // empty property name is bad
                {
                    hr = StringCchCopy(PropStrBuf, cchPropStrBuf, pTemp + 1);
                }
            }

            if (FAILED(hr))
            {
                wiauDbgError("InitVendorExtentions", "invalid vendor property format");
                delete pPropInfo;
                delete [] pPropStr;
                return hr;
            }

            #ifndef UNICODE
            wcscpy(pPropStr, A2W(PropStrBuf));
            #endif            
            
            m_VendorPropMap.Add(VendorPropCodes[count], pPropInfo);
        }
    }
    else
        wiauDbgWarning("InitVendorExtentions", "couldn't read vendor prop codes");

    //
    // Get the list of vendor extended event codes
    //
    hr = S_OK;
    CArray16 VendorEventCodes;
    regDevData.GetValueCodes(REGSTR_EVENTCODE, &VendorEventCodes);

    wiauDbgTrace("InitVendorExtentions", "%d vendor event codes found", VendorEventCodes.GetSize());
    
    int nVendorEvents = VendorEventCodes.GetSize();
    if (nVendorEvents > MAX_VENDOR_EVENTS)
    {
        wiauDbgWarning("InitVendorExtensions", "vendor events limit exceeded, ignoring events over limit");
        nVendorEvents = MAX_VENDOR_EVENTS;
    }

    //
    // For each event code, get it's information, i.e. the WIA event GUID and event name
    //
    for (count = 0; count < nVendorEvents; count++)
    {
        hr = StringCchPrintf(name, ARRAYSIZE(name), REGSTR_EVENTCODE_MASK, VendorEventCodes[count]);
        if (FAILED(hr))
        {
            wiauDbgErrorHr(hr, "InitVendorExtensions", "StringCchPrintf failed");
            return hr;
        }

        valueLen = sizeof(value);
        hr = regDevData.GetValueStr(name, value, &valueLen); 
        if (FAILED(hr))
        {
            wiauDbgError("InitVendorExtentions", "vendor extended EventCode not found 0x%04x", VendorEventCodes[count]);
            return hr;
        }

        CVendorEventInfo *pEventInfo = new CVendorEventInfo;
        if (!pEventInfo)
        {
            wiauDbgError("InitVendorExtentions", "memory allocation failed");
            return E_OUTOFMEMORY;
        }

        pEventInfo->pGuid = new GUID;
        if (!pEventInfo->pGuid)
        {
            wiauDbgError("InitVendorExtentions", "memory allocation failed");
            delete pEventInfo;
            pEventInfo = NULL;
            return E_OUTOFMEMORY;
        }

        hr = CLSIDFromString(T2W(value), pEventInfo->pGuid);
        if (FAILED(hr))
        {
            wiauDbgError("InitVendorExtentions", "invalid guid format");
            delete pEventInfo;
            pEventInfo = NULL;
            return hr;
        }

        //
        // Open DevParams\Events\EventCodeXXXX key and read event's name - default value of the key
        //
        TCHAR szEventKey[MAX_PATH] = TEXT("");
        CPTPRegistry regEventKey;

        hr = StringCchPrintf(szEventKey, ARRAYSIZE(szEventKey), REGSTR_EVENTS_MASK, name);
        if (SUCCEEDED(hr))
        {
            hr = regEventKey.Open(hkDevParams, szEventKey);
            if (SUCCEEDED(hr))
            {
                valueLen = sizeof(value);
                hr = regEventKey.GetValueStr(_T(""), value, &valueLen); 
                if (SUCCEEDED(hr))
                {
                    pEventInfo->EventName = SysAllocString(T2W(value));
                    if (pEventInfo->EventName == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        
        if (FAILED(hr))
        {
            //
            // if event name is not provided, the event info will not be added to the map
            // just proceed to the next event in VendorEventCodes
            //
            wiauDbgError("InitVendorExtensions", "can't read vendor event name");
            delete pEventInfo;
            pEventInfo = NULL;
            hr = S_OK;
        }
        else
        {
            //
            // Add the EventInfo to the map. Map will be responsible for freeing EventInfo
            //
            m_VendorEventMap.Add(VendorEventCodes[count], pEventInfo);
        }
    }

    return hr;
}

//
// Event callback function
//
HRESULT
EventCallback(
    LPVOID pCallbackParam,
    PPTP_EVENT pEvent
    )
{
    HRESULT hr = S_OK;

    if (pEvent == NULL)
    {
        hr = CoInitialize(NULL);
        wiauDbgTrace("EventCallback", "CoInitialize called");
    }
    else
    {
        DBG_FN("EventCallback");

        CWiaMiniDriver *pDriver = (CWiaMiniDriver *) pCallbackParam;

        if (pDriver)
        {
            hr = pDriver->EventCallbackDispatch(pEvent);
            if (FAILED(hr))
            {
                wiauDbgError("EventCallback", "ProcessEvent failed");
                return hr;
            }
        }
    }

    return hr;
}

//
// Constructor
//
CPtpMutex::CPtpMutex(HANDLE hMutex) :
        m_hMutex(hMutex)
{
    DWORD ret = 0;
    const DWORD MUTEX_WAIT = 30 * 1000; // 30 seconds

    ret = WaitForSingleObject(hMutex, MUTEX_WAIT);
    if (ret == WAIT_TIMEOUT)
        wiauDbgError("CPtpMutex", "wait for mutex expired");
    else if (ret == WAIT_FAILED)
        wiauDbgError("CPtpMutex", "WaitForSingleObject failed");

    wiauDbgTrace("CPtpMutex", "Entering mutex");
}

//
// Destructor
//
CPtpMutex::~CPtpMutex()
{
    wiauDbgTrace("~CPtpMutex", "Leaving mutex");

    if (!ReleaseMutex(m_hMutex))
        wiauDbgError("~CPtpMutex", "ReleaseMutex failed");
}

//
// Notify WIA server on changes in camera's state, like "camera was reset"
//
HRESULT CWiaMiniDriver::NotifyWiaOnStateChanges()
{
    HRESULT hr = S_OK;

    if (m_pPTPCamera == NULL)
    {
        return E_UNEXPECTED;
    }

    //
    // Check if camera was reset
    //
    PBOOL pbWasReset = m_pPTPCamera->CameraWasReset();

    if (*pbWasReset)
    {
        //
        // Since device was reset, its context is invalid now
        // First, remove all objects
        //
        while (m_StorageIds.GetSize() > 0)
        {
            hr = RemoveStorage(m_StorageIds[0]);
            if (FAILED(hr))
            {
                wiauDbgError("NotifyWiaOnStateChanges", "Failed to remove storage");
            }
        }
        
        //
        // Unlink tree. 
        //
        if (m_pDrvItemRoot)
        {
            hr = m_pDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);
            if (FAILED(hr))
            {
                wiauDbgError("NotifyWiaOnStateChanges", "Failed to unlink tree");
            }
            m_pDrvItemRoot->Release();
            m_pDrvItemRoot = NULL;
        }

        //
        // Invalidate all property values
        //
        m_PropDescs.RemoveAll();

        //
        // Next call to drvInitializeWia should be able to re-initialize camera
        //
        m_OpenApps = 0;

        //
        // Notify WIA service and application that camera needs to be reinitialized
        //
        hr = wiasQueueEvent(m_bstrDeviceId, &WIA_EVENT_TREE_UPDATED, NULL);
        if (FAILED(hr))
        {
            wiauDbgError("NotifyWiaOnStateChanges", "Failed to queue WIA_EVENT_TREE_UPDATED event");
        }
        
        *pbWasReset = FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\pch.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled header

Author:

    DavePar

Revision History:


--*/


#ifndef _PCH_H
#define _PCH_H

#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <assert.h>

#include <wiamindr.h>
#include <gdiplus.h>
#include <wiautil.h>
#include <usbscan.h>

#define INITGUID
#include <initguid.h>
#include <sti.h>
#include <stiusd.h>

#include "wiatempl.h"
#include "iso15740.h"

#include "dllmain.h"
#include "utils.h"
#include "camera.h"
#include "camusb.h"
#include "factory.h"
#include "ptputil.h"
#include "resource.h"
#include "ptpusd.h"

#include "minidrv.h"
#include "trace.h"

#define STRSAFE_NO_DEPRECATE // don't deprecate old string functions
#define STRSAFE_NO_CB_FUNCTIONS // don't define byte count based functions, use character count only
#include "strsafe.h"

#endif // _PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\minidrv.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    minidrv.h

Abstract:

    This module declares CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef MINIDRV__H_
#define MINIDRV__H_


DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef) (THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease) (THIS) PURE;
};

//
// General purpose GUIDs
//
DEFINE_GUID(GUID_NULL, 0,0,0,0,0,0,0,0,0,0,0);

DEFINE_GUID(FMT_NOTHING,
            0x81a566e7,0x8620,0x4fba,0xbc,0x8e,0xb2,0x7c,0x17,0xad,0x9e,0xfd);

//
// This is the HRESULT code we used to report that a device error has occurred
//
const HRESULT   HRESULT_DEVICE_ERROR  = HRESULT_FROM_WIN32(ERROR_GEN_FAILURE);
const HRESULT   HRESULT_DEVICE_NOT_RESPONDING = HRESULT_FROM_WIN32(ERROR_TIMEOUT);

//
// Device error codes
//
enum
{
    DEVERR_OK = 0,
    DEVERR_UNKNOWN
};
#define DEVERR_MIN DEVERR_OK
#define DEVERR_MAX DEVERR_UNKNOWN

//
// Session ID to use
//
const ULONG WIA_SESSION_ID = 1;

//
// Handy constants for common item types
//
const ULONG ITEMTYPE_FILE   = WiaItemTypeFile;
const ULONG ITEMTYPE_IMAGE  = WiaItemTypeFile | WiaItemTypeImage;
const ULONG ITEMTYPE_AUDIO  = WiaItemTypeFile | WiaItemTypeAudio;
const ULONG ITEMTYPE_VIDEO  = WiaItemTypeFile | WiaItemTypeVideo;
const ULONG ITEMTYPE_FOLDER = WiaItemTypeFolder;
const ULONG ITEMTYPE_BURST  = WiaItemTypeFolder | WiaItemTypeBurst;
const ULONG ITEMTYPE_HPAN   = WiaItemTypeFolder | WiaItemTypeHPanorama;
const ULONG ITEMTYPE_VPAN   = WiaItemTypeFolder | WiaItemTypeVPanorama;

//
// Maximum number of vendor-defined events supported
//
const ULONG MAX_VENDOR_EVENTS = 128;

//
// Structure which holds everything needed for each format type.
//
typedef struct _FORMAT_INFO
{
    LPGUID  FormatGuid;     // WIA format GUID
    PWSTR   FormatString;   // item name in a printf-style format string
    LONG    ItemType;       // WIA item type
    PWSTR   ExtString;      // file name extension

} FORMAT_INFO, *PFORMAT_INFO;

//
// Structure for holding information about each property.
//
typedef struct _PROP_INFO
{
    PROPID      PropId;     // WIA property id
    LPOLESTR    PropName;   // WIA property name

} PROP_INFO, *PPROP_INFO;

//
// structure for holding information about vendor events
class CVendorEventInfo
{
public:
    GUID       *pGuid;      // WIA GUID for event
    BSTR        EventName;  // may be NULL if vendor did not provide event name in INF file
    CVendorEventInfo() : pGuid(NULL), EventName(NULL) {};
    ~CVendorEventInfo() 
    {
        if (pGuid) delete pGuid;
        SysFreeString(EventName);
    }
};

//
// Driver item context
//
typedef struct tagDrvItemContext
{
    CPtpObjectInfo  *pObjectInfo;        // pointer to the PTP ObjectInfo structure

    ULONG            NumFormatInfos;     // number of format infos stored
    WIA_FORMAT_INFO *pFormatInfos;       // supported formats array

    ULONG            ThumbSize;          // thumnail image size in bytes
    BYTE            *pThumb;             // thumnail bits

}DRVITEM_CONTEXT, *PDRVITEM_CONTEXT;

#ifdef DEADCODE
//
// Tree node. These are used to temporarily hold the items between reading
// all of the PTP objects and creating the PTP item tree.
//
typedef struct _OBJECT_TREE_NODE
{
    CPtpObjectInfo *pObjectInfo;
    struct _OBJECT_TREE_NODE *pNext;
    struct _OBJECT_TREE_NODE *pFirstChild;
} OBJECT_TREE_NODE, *POBJECT_TREE_NODE;
#endif // DEADCODE

//
// Our minidriver clsid. 
//
#if defined( _WIN32 ) && !defined( _NO_COM)
// b5ee90b0-d5c5-11d2-82d5-00c04f8ec183
DEFINE_GUID(CLSID_PTPWiaMiniDriver,
            0xb5ee90b0,0xd5c5,0x11d2,0x82,0xd5,0x00,0xc0,0x4f,0x8e,0xc1,0x83);
#endif

class CWiaMiniDriver :
public INonDelegatingUnknown,
public IStiUSD,
public IWiaMiniDrv
{
public:
    CWiaMiniDriver(LPUNKNOWN punkOuter);
    ~CWiaMiniDriver();
    //
    // INonDelegatingUnknown interface
    //
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);

    //
    // IUnknown interface
    //
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);

    //
    // IStiUSD interface
    //
    STDMETHODIMP Initialize(PSTIDEVICECONTROL pHelDcb, DWORD dwStiVersion, HKEY hParametersKey);
    STDMETHODIMP GetCapabilities (PSTI_USD_CAPS pDevCaps);
    STDMETHODIMP GetStatus (PSTI_DEVICE_STATUS pDevStatus);
    STDMETHODIMP DeviceReset();
    STDMETHODIMP Diagnostic(LPDIAG pBuffer);
    STDMETHODIMP SetNotificationHandle(HANDLE hEvent);
    STDMETHODIMP GetNotificationData(LPSTINOTIFY lpNotify);
    STDMETHODIMP Escape(STI_RAW_CONTROL_CODE EscapeFunction, LPVOID lpInData, DWORD  cbInDataSize,
                        LPVOID pOutData, DWORD dwOutDataSize, LPDWORD pdwActualDataSize);
    STDMETHODIMP GetLastError (LPDWORD pdwLastDeviceError);
    STDMETHODIMP GetLastErrorInfo (STI_ERROR_INFO *pLastErrorInfo);
    STDMETHODIMP LockDevice();
    STDMETHODIMP UnLockDevice();
    STDMETHODIMP RawReadData(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteData(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawReadCommand(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteCommand(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);

    //
    // IWiaMiniDrv interface
    //
    STDMETHODIMP drvInitializeWia(BYTE *pWiasContext, LONG lFlags, BSTR bstrDeviceID, BSTR bstrRootFullItemName,
                                  IUnknown *pStiDevice, IUnknown *pIUnknownOuter, IWiaDrvItem  **ppIDrvItemRoot,
                                  IUnknown **ppIUnknownInner, LONG *plDevErrVal);
    STDMETHODIMP drvUnInitializeWia(BYTE* pWiasContext);
    STDMETHODIMP drvDeviceCommand(BYTE *pWiasContext, LONG lFlags, const GUID *pGUIDCommand,
                                  IWiaDrvItem **ppMiniDrvItem, LONG *plDevErrVal);
    STDMETHODIMP drvDeleteItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetCapabilities(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                    WIA_DEV_CAP_DRV **ppCapabilities, LONG *plDevErrVal);
    STDMETHODIMP drvInitItemProperties(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvLockWiaDevice(BYTE  *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvUnLockWiaDevice(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvAnalyzeItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetWiaFormatInfo(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                     WIA_FORMAT_INFO **ppwfi, LONG *plDevErrVal);
    STDMETHODIMP drvNotifyPnpEvent(const GUID *pEventGUID, BSTR bstrDeviceID, ULONG ulReserved);
    STDMETHODIMP drvReadItemProperties(BYTE *pWiaItem, LONG lFlags, ULONG nPropSpec,
                                       const PROPSPEC *pPropSpec, LONG  *plDevErrVal);
    STDMETHODIMP drvWriteItemProperties(BYTE *pWiasContext, LONG lFLags,
                                        PMINIDRV_TRANSFER_CONTEXT pmdtc, LONG *plDevErrVal);
    STDMETHODIMP drvValidateItemProperties(BYTE *pWiasContext, LONG lFlags, ULONG nPropSpec,
                                           const PROPSPEC *pPropSpec, LONG *plDevErrVal);
    STDMETHODIMP drvAcquireItemData(BYTE *pWiasContext, LONG lFlags,
                                    PMINIDRV_TRANSFER_CONTEXT pDataContext, LONG *plDevErrVal);
    STDMETHODIMP drvGetDeviceErrorStr(LONG lFlags, LONG lDevErrVal, LPOLESTR *ppszDevErrStr, LONG *plDevErrVal);
    STDMETHODIMP drvFreeDrvItemContext(LONG lFlags, BYTE *pDevContext, LONG *plDevErrVal);

    //
    // Public helper functions (in eventcb.cpp)
    //
    HRESULT EventCallbackDispatch(PPTP_EVENT pEvent);

private:

    //
    // Private helper functions (in minidriver.cpp)
    //
    HRESULT Shutdown();
    HRESULT TakePicture(BYTE *pWiasContext, IWiaDrvItem **ppNewItem);
    LONG    GetTotalFreeImageSpace();
    HRESULT WiasContextToItemContext(BYTE *pWiasContext, DRVITEM_CONTEXT **ppItemContext,
                                     IWiaDrvItem **ppDrvItem = NULL);
    HRESULT LoadStrings();
    HRESULT GetResourceString(LONG lResourceID, WCHAR *pString, int length);
    HRESULT InitVendorExtentions(HKEY hkDevParams);
    HRESULT UpdateStorageInfo(ULONG StorageId);
    HRESULT NotifyWiaOnStateChanges();

    //
    // Private helper functions (in devitem.cpp)
    //
    HRESULT CreateDrvItemTree(IWiaDrvItem **ppRoot);
    HRESULT AddObject(DWORD ObjectHandle, BOOL bQueueEvent = FALSE, CPtpObjectInfo *pProvidedObjectInfo = NULL);
    HRESULT InitDeviceProperties(BYTE *pWiasContext);
    HRESULT ReadDeviceProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT WriteDeviceProperties(BYTE *pWiasContext);
    HRESULT ValidateDeviceProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT FindCorrDimension(BYTE *pWiasContext, LONG *pWidth, LONG *pHeight);
    int     FindProportionalValue(int valueX, int minX, int maxX, int minY, int maxY, int stepY);
    PPROP_INFO PropCodeToPropInfo(WORD PropCode);
    int     NumLogicalStorages();

    //
    // Private helper functions (in imgitem.cpp)
    //
    HRESULT InitItemProperties(BYTE *pWiasContext);
    HRESULT IsObjectProtected(CPtpObjectInfo *pObjectInfo, LONG &lProtection);
    HRESULT GetObjectTime(CPtpObjectInfo *pObjectInfo, SYSTEMTIME  *pSystemTime);
    HRESULT ReadItemProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT CacheThumbnail(PDRVITEM_CONTEXT pDrvItemCtx);
    HRESULT ValidateItemProperties(BYTE *pWiasContext, LONG NumPropSpecs, const PROPSPEC *pPropSpecs, LONG ItemType);
    HRESULT AcquireDataAndTranslate(BYTE *pWiasContext, DRVITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc);
    HRESULT AcquireAndTranslateJpegWithoutGeometry(BYTE *pWiasContext, DRVITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc);
    HRESULT AcquireAndTranslateAnyImage(BYTE *pWiasContext, DRVITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc);
    HRESULT AcquireData(DRVITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc);

    //
    // Event handling functions (in eventcb.cpp)
    //
    HRESULT AddNewObject(DWORD ObjectHandle);
    HRESULT RemoveObject(DWORD ObjectHandle);
    HRESULT AddNewStorage(DWORD StorageId);
    HRESULT RemoveStorage(DWORD StorageId);
    HRESULT DevicePropChanged(WORD PropCode);
    HRESULT ObjectInfoChanged(DWORD ObjectHandle);
    HRESULT StorageFull(DWORD StorageId);
    HRESULT StorageInfoChanged(DWORD StorageId);
    HRESULT CaptureComplete();
    HRESULT PostVendorEvent(WORD EventCode);

    //
    // Inline utilities
    //
    BOOL IsItemTypeFolder(LONG ItemType)
    {
        return ((WiaItemTypeFolder & ItemType) &&
                !(ItemType & (WiaItemTypeStorage | WiaItemTypeRoot)));
    }

    //
    // Member variables
    //
    WIA_DEV_CAP_DRV    *m_Capabilities;         // List of device capabilities. Build once and use every time we are asked
    UINT                m_nEventCaps;           // Number of events supported
    UINT                m_nCmdCaps;             // Number of commands supported
    BOOL                m_fInitCaptureChecked;  // Indicates if we have already queried camera for InitiateCapture command support

    int                 m_OpenApps;             // Number of apps that are communicating with this driver

    IWiaDrvItem        *m_pDrvItemRoot;         // Pointer to the root of the driver item tree

    CPTPCamera         *m_pPTPCamera;           // Pointer to camera object--actually holds CUsbCamera object
    CPtpDeviceInfo      m_DeviceInfo;           // DeviceInfo structure for the camera
    CArray32            m_StorageIds;           // Holds the current storage ids
    CWiaArray<CPtpStorageInfo>
                        m_StorageInfos;         // Holds the StorageInfo structures
    CWiaArray<CPtpPropDesc>
                        m_PropDescs;            // Property description structures
    CWiaMap<ULONG, IWiaDrvItem *>
                        m_HandleItem;           // Used to map PTP object handles to WIA driver items
    LONG                m_NumImages;            // The number of images currently on the device

    IStiDevice         *m_pStiDevice;           // Pointer to the driver's STI interface
    BSTR                m_bstrDeviceId;         // STI device ID
    BSTR                m_bstrRootItemFullName; // Full name of root item
    PSTIDEVICECONTROL   m_pDcb;                 // Pointer to the IStiDeviceControl interface

    HANDLE              m_TakePictureDoneEvent; // Event handle to indicate when TakePicture command is done
    
    DWORD               m_VendorExtId;          // Vendor extension id (from registry)
    CWiaMap<WORD, PROP_INFO *>
                        m_VendorPropMap;        // Maps PropCodes to PROP_INFO structures
    CWiaMap<WORD, CVendorEventInfo*>
                        m_VendorEventMap;       // Maps EventCodes to event info

    HANDLE              m_hPtpMutex;            // Mutex used for exclusive access to device

    CArray32            m_DcimHandle;           // ObjectHandle of the DCIM folder for each storage, if it exists
    CWiaMap<ULONG, IWiaDrvItem *>
                        m_AncAssocParent;       // Maps ancillary association handles to their parents
    DWORD               m_dwObjectBeingSent;    // Temporary location for object handle between SendObjectInfo and SendObject
    CWiaArray<DWORD>    m_CapturedObjects;      // List of new objects reported during capture operation, but not yet processed

    BOOL                m_bTwoDigitsMillisecondsOutput; // In XP, PTP driver was sending DATETIME string to camera with two digits 
                                                // for milliseconds (bug 699699). Some cameras may expect this format.

    ULONG               m_Refs;                 // Reference count on the object
    IUnknown           *m_punkOuter;            // Pointer to outer IUnknown
};

//
// Functions for handling PTP callbacks
//
HRESULT EventCallback(LPVOID pCallbackParam, PPTP_EVENT pEvent);
HRESULT DataCallback(LPVOID pCallbackParam, LONG lPercentComplete,
                     LONG lOffset, LONG lLength, BYTE **ppBuffer, LONG *plBufferSize);

//
// Helper functions
//
PFORMAT_INFO    FormatCodeToFormatInfo(WORD FormatCode, WORD AssocType = 0);
WORD            FormatGuidToFormatCode(GUID *pFormatGuid);
WORD            PropIdToPropCode(PROPID PropId);
VOID            SplitImageSize(CBstr cbstr, LONG *pWidth, LONG *pHeight);

//
// Simple object for handling mutexes. It will make sure that the mutex is released
// no matter how the function is exited.
//
class CPtpMutex
{
public:
    CPtpMutex(HANDLE hMutex);
    ~CPtpMutex();

private:
    HANDLE m_hMutex;
};

#endif  // #ifndef MINIDRV__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\resource.h ===
//
// Used by ptpusd.rc
//

#define IDS_UNKNOWNSTRING       102
#define IDS_FOLDERSTRING        103
#define IDS_SCRIPTSTRING        104
#define IDS_EXECSTRING          105
#define IDS_TEXTSTRING          106
#define IDS_HTMLSTRING          107
#define IDS_DPOFSTRING          108
#define IDS_AUDIOSTRING         109
#define IDS_VIDEOSTRING         110
#define IDS_UNKNOWNIMGSTRING    111
#define IDS_IMAGESTRING         112
#define IDS_ALBUMSTRING         113
#define IDS_BURSTSTRING         114
#define IDS_PANORAMASTRING      115

#define IDS_DEVICECONNECTED     120
#define IDS_DEVICEDISCONNECTED  121
#define IDS_ITEMCREATED         122
#define IDS_ITEMDELETED         123

#define IDS_TAKEPICTURE         124
#define IDS_SYNCHRONIZE         125

#define IDS_TREEUPDATED         126
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\ptpprop.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    ptpprop.h

Abstract:

    This module declares CProperty and its derived classes

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef PTPPROP__H_
#define PTPPROP__H_

//
// This class represnets a property.
//

class CPTPProperty
{
public:
    CPTPProperty()
    {
        m_bstrWiaPropName = NULL;
        m_WiaDataType = VT_EMPTY;
        ZeroMemory(&m_WiaPropInfo, sizeof(m_WiaPropInfo));
        ZeroMemory(&m_DefaultValue, sizeof(m_DefaultValue));
        ZeroMemory(&m_CurrentValue, sizeof(m_CurrentValue));
    }
    CPTPProperty(WORD PTPPropCode, WORD PTPDataType);
    virtual ~CPTPProperty();
    virtual HRESULT Initialize(PTP_PROPDESC *pPTPPropDesc, PROPID WiaPropId,
                               VARTYPE WiaDataType, LPCWSTR WiaPropName);
    HRESULT GetCurrentValue(PROPVARIANT *pPropVar);
    HRESULT GetCurrentValue(PTP_PROPVALUE *pPropValue);
    HRESULT GetDefaultValue(PROPVARIANT *pPropVar);
    HRESULT GetDefaultValue(PTP_PROPVALUE *pPropValue);
    HRESULT SetValue(PROPVARIANT *ppropVar);
    HRESULT SetValue(PTP_PROPVALUE *pPropValue);
    HRESULT Reset();

    const WIA_PROPERTY_INFO * GetWiaPropInfo()
    {
        return &m_WiaPropInfo;
    }
    const PTP_PROPVALUE * GetCurrentValue()
    {
        return &m_CurrentValue;
    }
    const PTP_PROPVALUE * GetDefaultValue()
    {
        return &m_DefaultValue;
    }
    const LPWSTR GetWiaPropName()
    {
        return m_bstrWiaPropName;
    }
    WORD GetPTPPropCode()
    {
        return m_PtpPropCode;
    }
    PROPID GetWiaPropId()
    {
        return m_WiaPropId;
    }
    WORD  GetPTPPropDataType()
    {
        return m_PtpDataType;
    }
    VARTYPE GetWiaPropDataType()
    {
        return m_WiaDataType;
    }
    LONG GetWiaAccessFlags()
    {
        return m_WiaPropInfo.lAccessFlags;
    }

protected:
    //
    // Override the following functions to provide different data
    // restreiving and recording methods
    //
    virtual HRESULT GetPropValueLong(PTP_PROPVALUE *pPropValue, long *plValue);
    virtual HRESULT GetPropValueBSTR(PTP_PROPVALUE *pPropValue, BSTR *pbstrValue);
    virtual HRESULT GetPropValueVector(PTP_PROPVALUE *pPropValue, void *pVector,
                                       VARTYPE BasicType);
    virtual HRESULT SetPropValueLong(PTP_PROPVALUE *pPropValue, long lValue);
    virtual HRESULT SetPropValueBSTR(PTP_PROPVALUE *pPropValue, BSTR bstrValue);
    virtual HRESULT SetPropValueVector(PTP_PROPVALUE *pPropValue,
                                       void *pVector, VARTYPE BasicType);
    HRESULT PropValue2Variant(PROPVARIANT *pPropVar, PTP_PROPVALUE *pPropValue);
    HRESULT Variant2PropValue(PTP_PROPVALUE *pPropValue, PROPVARIANT *pPropVar);

    WORD    m_PtpPropCode;
    PROPID              m_WiaPropId;
    WORD        m_PtpDataType;
    VARTYPE             m_WiaDataType;
    PTP_PROPVALUE       m_CurrentValue;
    PTP_PROPVALUE       m_DefaultValue;
    WIA_PROPERTY_INFO   m_WiaPropInfo;
    BSTR                m_bstrWiaPropName;
};


class CPTPPropertyDateTime : public CPTPProperty
{
public:
    CPTPPropertyDateTime(WORD PtpPropCode,
                         WORD     PtpDataType
                        );

protected:
    virtual HRESULT GetPropValueVector(PTP_PROPVALUE *pPropValue,
                                       void *pVector,
                                       VARTYPE BasicType
                                      );
    virtual HRESULT SetPropValueVector(PTP_PROPVALUE *pPropValue,
                                       void *pVector,
                                       VARTYPE BasicType
                                      );
};
#endif	    // #ifndef PTPPROP__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\testexe\ptp.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    ptp.cpp

Abstract:

    Program for testing the PTP camera library without using WIA

Author:

    DavePar

Revision History:


--*/

#include <windows.h>
#include <stddef.h>
#include <tchar.h>
#include <objbase.h>
#include <assert.h>
#include <stdio.h>
#include <usbscan.h>

#include "wiatempl.h"
#include "iso15740.h"
#include "camera.h"
#include "camusb.h"

// Software Tracing goo

// {9A716C69-7A13-437c-B4EC-C6D1CAAFBCD9}
#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Regular,(9A716C69,7A13,437c,B4EC,C6D1CAAFBCD9), \
    WPP_DEFINE_BIT(Entry)      \
    WPP_DEFINE_BIT(Exit)       \
    WPP_DEFINE_BIT(Error)      \
    WPP_DEFINE_BIT(Unusual)    \
    WPP_DEFINE_BIT(Noise)      \
    )        \

#include <ptp.tmh>

#define MAX_SIZE 255

HRESULT EventCallback(LPVOID pCallbackParam, PPTP_EVENT pEvent)
{
    if (pEvent)
        printf("EventCallback called, event = 0x%08x\n", pEvent->EventCode);
    else
        printf("EventCallback initialized\n");

    return S_OK;
}

HRESULT DataCallback(LPVOID pCallbackParam, LONG lPercentComplete,
                     LONG lOffset, LONG lLength, BYTE **ppBuffer, LONG *plBufferSize)
{
    printf("DataCallback called, %3d percent complete, %5d bytes transferred\n", lPercentComplete, lLength);

    return S_OK;
}


void PrintCommands()
{
    printf("Valid commands:\n");
    printf("  op <#>   - open handle to device named Usbscan<#>\n");
    printf("  gd       - get DeviceInfo from device\n");
    printf("  os       - OpenSession\n");
    printf("  cs       - CloseSession\n");
    printf("  gs       - GetStorageIDs\n");
    printf("  gsi <id> - GetStorageInfo for StoreID <id>\n");
    printf("  gon      - GetNumObjects\n");
    printf("  goh      - GetObjectHandles\n");
    printf("  goi <h>  - GetObjectInfo for ObjectHandle <h>\n");
    printf("  go <h>   - GetObject for ObjectHandle <h>\n");
    printf("  gt <h>   - GetThumb for ObjectHandle <h>\n");
    printf("  do <h>   - DeleteObject for ObjectHandle <h>\n");
    printf("  gpd <pc> - GetDevicePropDesc for PropCode <pc>\n");
    printf("  rs       - ResetDevice\n");
    printf("  tp <f>   - TakePicture in format <f>\n");
    printf("  gds      - GetDeviceStatus (only valid for USB)\n");
    printf("  ex\n\n");
}

int __cdecl main(int argc, CHAR *argv[], CHAR *envp[])
{
    WPP_INIT_TRACING(L"PTPTest");

    printf("\nPTP Camera Test Program\n");
    printf("Version 0.5\n");
    printf("July 28, 2000\n\n");

    HRESULT hr = S_OK;

    BOOL bSessionOpen = FALSE;

    char szCommand[MAX_SIZE];
    char *szToken;
    char szWhiteSpace[] = " \t";

    DoTraceMessage(Noise, "Entering main function\n");

    //
    // Create an USB camera object
    //
    CPTPCamera *pCamera = new CUsbCamera;


    while (true)
    {
        printf("Enter command: ");

        if (!gets(szCommand))
        {
            break;
        }
        printf("\n");

        szToken = strtok(szCommand, szWhiteSpace);

        if (!szToken)
        {
            printf("ERROR: Invalid command\n");
            PrintCommands();
            continue;
        }

        //
        // Interpret command
        //
        if (strcmp(szToken, "ex") == 0)
        {
            break;
        }

        if (strcmp(szToken, "help") == 0 ||
            strcmp(szToken, "?") == 0)
        {
            PrintCommands();
            continue;
        }

        else if (strcmp(szToken, "op") == 0)
        {
            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: Open needs a Usbscan number--look at CreateFileName registry key\n\n");
                continue;
            }

            WCHAR scratch1[MAX_SIZE];
            WCHAR scratch2[MAX_SIZE];

            mbstowcs(scratch1, szToken, MAX_SIZE);
            wcscpy(scratch2, L"\\\\.\\Usbscan");
            wcscat(scratch2, scratch1);

            printf("Opening device %S\n\n", scratch2);

            hr = pCamera->Open(scratch2, EventCallback, DataCallback, NULL);
        }
        
        else if (strcmp(szToken, "gd") == 0)
        {
            CPtpDeviceInfo DeviceInfo;

            hr = pCamera->GetDeviceInfo(&DeviceInfo);
        }
        
        else if (strcmp(szToken, "os") == 0)
        {
            ULONG sessionId;
            
            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: OpenSession needs a session number\n\n");
                continue;
            }

            sscanf(szToken, "%lu", &sessionId);

            if (sessionId == 0)
            {
                printf("ERROR: OpenSession needs a non-zero session number\n\n");
                continue;
            }

            printf("Opening session %d\n\n", sessionId);
            

            hr = pCamera->OpenSession(sessionId);

            if (SUCCEEDED(hr))
                bSessionOpen = TRUE;
        }

        else if (strcmp(szToken, "cs") == 0)
        {
            printf("Closing session\n\n");

            hr = pCamera->CloseSession();
        }

        else if (strcmp(szToken, "gs") == 0)
        {
            CArray32 StorageIds;

            printf("Getting storage ids\n\n");

            hr = pCamera->GetStorageIDs(&StorageIds);
        }

        else if (strcmp(szToken, "gsi") == 0)
        {
            ULONG StorageId;
            CPtpStorageInfo StorageInfo;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetStorageInfo needs a StorageID\n\n");
                continue;
            }

            sscanf(szToken, "%li", &StorageId);

            printf("Getting storage info for storage id 0x%08x\n\n", StorageId);

            hr = pCamera->GetStorageInfo(StorageId, &StorageInfo);
        }
        
        else if (strcmp(szToken, "gon") == 0)
        {
            UINT NumObjects;

            printf("Getting number of objects\n\n");

            hr = pCamera->GetNumObjects(PTP_STORAGEID_ALL, PTP_FORMATCODE_ALL, PTP_OBJECTHANDLE_ALL, &NumObjects);
        }
        
        else if (strcmp(szToken, "goh") == 0)
        {
            CArray32 ObjectIds;

            printf("Getting object ids\n\n");

            hr = pCamera->GetObjectHandles(PTP_STORAGEID_ALL, PTP_FORMATCODE_ALL, PTP_OBJECTHANDLE_ALL, &ObjectIds);
        }
        
        else if (strcmp(szToken, "goi") == 0)
        {
            DWORD ObjectHandle;
            CPtpObjectInfo ObjectInfo;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetObjectInfo needs an ObjectHandle\n\n");
                continue;
            }

            sscanf(szToken, "%li", &ObjectHandle);

            printf("Getting object info for object handle 0x%08x\n\n", ObjectHandle);

            hr = pCamera->GetObjectInfo(ObjectHandle, &ObjectInfo);
        }

        else if (strcmp(szToken, "go") == 0)
        {
            DWORD ObjectHandle;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetObject needs an ObjectHandle\n\n");
                continue;
            }

            sscanf(szToken, "%li", &ObjectHandle);

            printf("Getting object for object handle 0x%08x\n\n", ObjectHandle);

            UINT BufferSize = 32 * 1024;
            BYTE *pBuffer = new BYTE[BufferSize];
            if (!pBuffer)
            {
                printf("ERROR: Couldn't allocate the buffer\n\n");
                continue;
            }

            hr = pCamera->GetObjectData(ObjectHandle, pBuffer, &BufferSize, NULL);

            delete []pBuffer;
        }
        
        else if (strcmp(szToken, "gt") == 0)
        {
            DWORD ObjectHandle;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetThumb needs an ObjectHandle\n\n");
                continue;
            }

            sscanf(szToken, "%li", &ObjectHandle);

            printf("Getting thumbnail for object handle 0x%08x\n\n", ObjectHandle);

            UINT BufferSize = 16 * 1024;
            BYTE *pBuffer = new BYTE[BufferSize];
            if (!pBuffer)
            {
                printf("ERROR: Couldn't allocate the buffer\n\n");
                continue;
            }

            hr = pCamera->GetThumb(ObjectHandle, pBuffer, &BufferSize);

            delete []pBuffer;
        }
        
        else if (strcmp(szToken, "do") == 0)
        {
            DWORD ObjectHandle;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: DeleteObject needs an ObjectHandle\n\n");
                continue;
            }

            sscanf(szToken, "%li", &ObjectHandle);

            printf("Deleting object for object handle 0x%08x\n\n", ObjectHandle);

            hr = pCamera->DeleteObject(ObjectHandle, PTP_FORMATCODE_NOTUSED);
        }
        
        else if (strcmp(szToken, "gpd") == 0)
        {
            WORD PropCode;
            CPtpPropDesc PropDesc;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: GetDevicePropDesc needs a PropCode\n\n");
                continue;
            }

            sscanf(szToken, "%i", &PropCode);

            printf("Getting property description for prop code 0x%04x\n\n", PropCode);

            hr = pCamera->GetDevicePropDesc(PropCode, &PropDesc);
        }

        else if (strcmp(szToken, "rs") == 0)
        {
            printf("Resetting device...\n");

            hr = pCamera->ResetDevice();
        }
        
        else if (strcmp(szToken, "tp") == 0)
        {
            WORD Format;

            szToken = strtok(NULL, szWhiteSpace);

            if (!szToken)
            {
                printf("ERROR: TakePicture needs a format\n\n");
                continue;
            }

            sscanf(szToken, "%i", &Format);

            printf("Taking a picture in format 0x%04x\n\n", Format);

            hr = pCamera->InitiateCapture(PTP_STORAGEID_DEFAULT, Format);
        }
        
#ifdef DEADCODE
        else if (strcmp(szToken, "gds") == 0)
        {
            printf("Getting device status\n\n");

            USB_PTPDEVICESTATUS Status;
            hr = ((CUsbCamera *) pCamera)->GetDeviceStatus(&Status);
        }
#endif
        
        else
        {
            printf("ERROR: Invalid command\n");
            PrintCommands();
            continue;
        }

        if (SUCCEEDED(hr))
            printf("Success!!\n\n");
        else
            printf("FAILED\n\n");

    } // while (true)

    if (bSessionOpen)
    {
        printf("Closing session\n\n");

        hr = pCamera->CloseSession();
        if (SUCCEEDED(hr))
            printf("Success!!\n\n");
        else
            printf("FAILED\n\n");
    }

    WPP_CLEANUP();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\trace.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    trace.h

Abstract:

    This module declares software tracing stuff

Author:

    Dave Parsons (davepar)

Revision History:


--*/

#ifndef TRACE__H_
#define TRACE__H_

//
// Software tracing setup
//

#define WPP_CONTROL_GUIDS       \
    WPP_DEFINE_CONTROL_GUID(Regular,(09D38237,078D,4767,BF90,9227E75562DB), \
    WPP_DEFINE_BIT(Error)       \
    WPP_DEFINE_BIT(Warning)     \
    WPP_DEFINE_BIT(Trace)       \
    WPP_DEFINE_BIT(Entry)       \
    WPP_DEFINE_BIT(Exit)        \
    WPP_DEFINE_BIT(Dump)        \
    )

class CTraceProc {
private:
    CHAR m_szMessage[MAX_PATH];

public:
    CTraceProc(CHAR *pszMsg);
    ~CTraceProc();
};

VOID DoTraceHresult(HRESULT hr);

#endif // TRACE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\fakecam\fakecam.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       fakecam.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Camera device implementation
*
*   TODO: Every function in this file must be changed so that it actually
*         talks to a real camera.
*
***************************************************************************/

#include "pch.h"

//
// Globals
//
HINSTANCE g_hInst;
GUID      g_guidUnknownFormat;

//
// Initializes access to the camera and allocates the device info
// structure and private storage area
//
HRESULT WiaMCamInit(MCAM_DEVICE_INFO **ppDeviceInfo)
{
    wiauDbgInit(g_hInst);

    DBG_FN("WiaMCamInit");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    MCAM_DEVICE_INFO *pDeviceInfo = NULL;
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;

    REQUIRE_ARGS(!ppDeviceInfo, hr, "WiaMCamInit");
    *ppDeviceInfo = NULL;

    //
    // Allocate the MCAM_DEVICE_INFO structure
    //
    pDeviceInfo = new MCAM_DEVICE_INFO;
    REQUIRE_ALLOC(pDeviceInfo, hr, "WiaMCamInit");

    memset(pDeviceInfo, 0, sizeof(MCAM_DEVICE_INFO));
    pDeviceInfo->iSize = sizeof(MCAM_DEVICE_INFO);
    pDeviceInfo->iMcamVersion = MCAM_VERSION;
    
    //
    // Allocate the FAKECAM_DEVICE_INFO structure that the
    // microdriver uses to store info
    //
    pPrivateDeviceInfo = new FAKECAM_DEVICE_INFO;
    REQUIRE_ALLOC(pPrivateDeviceInfo, hr, "WiaMCamInit");

    memset(pPrivateDeviceInfo, 0, sizeof(FAKECAM_DEVICE_INFO));
    pDeviceInfo->pPrivateStorage = (BYTE *) pPrivateDeviceInfo;

Cleanup:
    if (FAILED(hr)) {
        if (pDeviceInfo) {
            delete pDeviceInfo;
            pDeviceInfo = NULL;
        }
        if (pPrivateDeviceInfo) {
            delete pPrivateDeviceInfo;
            pPrivateDeviceInfo = NULL;
        }
    }

    *ppDeviceInfo = pDeviceInfo;

    return hr;
}

//
// Frees any remaining structures held by the microdriver
//
HRESULT WiaMCamUnInit(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamUnInit");

    HRESULT hr = S_OK;

    if (pDeviceInfo)
    {
        //
        // Free anything that was dynamically allocated in the MCAM_DEVICE_INFO
        // structure
        //
        if (pDeviceInfo->pPrivateStorage) {
            delete pDeviceInfo->pPrivateStorage;
            pDeviceInfo->pPrivateStorage = NULL;
        }

        delete pDeviceInfo;
        pDeviceInfo = NULL;
    }

    return hr;
}

//
// Open a connection to the device
//
HRESULT WiaMCamOpen(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName)
{
    DBG_FN("WiaMCamOpen");

    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    TCHAR tszTempStr[MAX_PATH] = TEXT("");

    REQUIRE_ARGS(!pDeviceInfo || !pwszPortName, hr, "WiaMCamOpen");

    //
    // Convert the wide port string to a tstr
    //
    hr = wiauStrW2T(pwszPortName, tszTempStr, sizeof(tszTempStr));
    REQUIRE_SUCCESS(hr, "WiaMCamOpen", "wiauStrW2T failed");

    //
    // Open the camera
    //
    hr = FakeCamOpen(tszTempStr, pDeviceInfo);
    REQUIRE_SUCCESS(hr, "WiaMCamOpen", "FakeCamOpen failed");
    
Cleanup:
    return hr;
}

//
// Closes the connection with the camera
//
HRESULT WiaMCamClose(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamClose");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pDeviceInfo, hr, "WiaMCamClose");

    //
    // For a real camera, CloseHandle should be called here
    //

Cleanup:
    return hr;
}

//
// Returns information about the camera, the list of items on the camera,
// and starts monitoring events from the camera
//
HRESULT WiaMCamGetDeviceInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList)
{
    DBG_FN("WiaMCamGetDeviceInfo");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;
    PTSTR ptszRootPath = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !ppItemList || !pDeviceInfo->pPrivateStorage, hr, "WiaMCamGetDeviceInfo");
    *ppItemList = NULL;

    pPrivateDeviceInfo = (UNALIGNED FAKECAM_DEVICE_INFO *) pDeviceInfo->pPrivateStorage;
    ptszRootPath = pPrivateDeviceInfo->tszRootPath;

    //
    // Build a list of all items available. The fields in the item info
    // structure can either be filled in here, or for better performance
    // wait until GetItemInfo is called.
    //
    hr = SearchDir(pPrivateDeviceInfo, NULL, ptszRootPath);
    REQUIRE_SUCCESS(hr, "WiaMCamGetDeviceInfo", "SearchDir failed");

    //
    // Fill in the MCAM_DEVICE_INFO structure
    //
    //
    // Firmware version should be retrieved from the device, converting
    // to WSTR if necessary
    //
    pDeviceInfo->pwszFirmwareVer = L"04.18.65";

    // ISSUE-8/4/2000-davepar Put properties into an INI file

    pDeviceInfo->lPicturesTaken = pPrivateDeviceInfo->iNumImages;
    pDeviceInfo->lPicturesRemaining = 100 - pDeviceInfo->lPicturesTaken;
    pDeviceInfo->lTotalItems = pPrivateDeviceInfo->iNumItems;

    GetLocalTime(&pDeviceInfo->Time);

//    pDeviceInfo->lExposureMode = EXPOSUREMODE_MANUAL;
//    pDeviceInfo->lExposureComp = 0;

    *ppItemList = pPrivateDeviceInfo->pFirstItem;

Cleanup:
    return hr;
}

//
// Called to retrieve an event from the device
//
HRESULT WiaMCamReadEvent(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **ppEventList)
{
    DBG_FN("WiaMCamReadEvent");
    
    HRESULT hr = S_OK;

    return hr;
}

//
// Called when events are no longer needed
//
HRESULT WiaMCamStopEvents(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamStopEvents");
    
    HRESULT hr = S_OK;

    return hr;
}

//
// Fill in the item info structure
//
HRESULT WiaMCamGetItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo)
{
    DBG_FN("WiaMCamGetItemInfo");

    HRESULT hr = S_OK;

    //
    // This is where the driver should fill in all the fields in the
    // ITEM_INFO structure. For this fake driver, the fields are filled
    // in by WiaMCamGetDeviceInfo because it's easier.
    //

    return hr;
}

//
// Frees the item info structure
//
HRESULT WiaMCamFreeItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo)
{
    DBG_FN("WiaMCamFreeItemInfo");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !pItemInfo || !pDeviceInfo->pPrivateStorage, hr, "WiaMCamFreeItemInfo");

    if (pItemInfo->pPrivateStorage) {
        PTSTR ptszFullName = (PTSTR) pItemInfo->pPrivateStorage;

        wiauDbgTrace("WiaMCamFreeItemInfo", "Removing %" WIAU_DEBUG_TSTR, ptszFullName);

        delete []ptszFullName;
        ptszFullName = NULL;
        pItemInfo->pPrivateStorage = NULL;
    }

    if (pItemInfo->pwszName)
    {
        delete []pItemInfo->pwszName;
        pItemInfo->pwszName = NULL;
    }

    pPrivateDeviceInfo = (UNALIGNED FAKECAM_DEVICE_INFO *) pDeviceInfo->pPrivateStorage;

    hr = RemoveItem(pPrivateDeviceInfo, pItemInfo);
    REQUIRE_SUCCESS(hr, "WiaMCamFreeItemInfo", "RemoveItem failed");

    if (IsImageType(pItemInfo->pguidFormat)) {
        pPrivateDeviceInfo->iNumImages--;
    }

    pPrivateDeviceInfo->iNumItems--;

    delete pItemInfo;
    pItemInfo = NULL;

Cleanup:
    return hr;
}

//
// Retrieves the thumbnail for an item
//
HRESULT WiaMCamGetThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem,
                            int *pThumbSize, BYTE **ppThumb)
{
    DBG_FN("WiaMCamGetThumbnail");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    PTSTR ptszFullName = NULL;
    BYTE *pBuffer = NULL;
    LONG ThumbOffset = 0;

    REQUIRE_ARGS(!pDeviceInfo || !pItem || !pThumbSize || !ppThumb, hr, "WiaMCamGetThumbnail");
    *ppThumb = NULL;
    *pThumbSize = 0;

    ptszFullName = (PTSTR) pItem->pPrivateStorage;

    hr = ReadJpegHdr(ptszFullName, &pBuffer);
    REQUIRE_SUCCESS(hr, "WiaMCamGetThumbnail", "ReadJpegHdr failed");

    IFD ImageIfd, ThumbIfd;
    BOOL bSwap;
    hr = ReadExifJpeg(pBuffer, &ImageIfd, &ThumbIfd, &bSwap);
    REQUIRE_SUCCESS(hr, "WiaMCamGetThumbnail", "ReadExifJpeg failed");

    for (int count = 0; count < ThumbIfd.Count; count++)
    {
        if (ThumbIfd.pEntries[count].Tag == TIFF_JPEG_DATA) {
            ThumbOffset = ThumbIfd.pEntries[count].Offset;
        }
        else if (ThumbIfd.pEntries[count].Tag == TIFF_JPEG_LEN) {
            *pThumbSize = ThumbIfd.pEntries[count].Offset;
        }
    }

    if (!ThumbOffset || !*pThumbSize)
    {
        wiauDbgError("WiaMCamGetThumbnail", "Thumbnail not found");
        hr = E_FAIL;
        goto Cleanup;
    }

    *ppThumb = new BYTE[*pThumbSize];
    REQUIRE_ALLOC(*ppThumb, hr, "WiaMCamGetThumbnail");

    memcpy(*ppThumb, pBuffer + APP1_OFFSET + ThumbOffset, *pThumbSize);

Cleanup:
    if (pBuffer) {
        delete []pBuffer;
    }

    FreeIfd(&ImageIfd);
    FreeIfd(&ThumbIfd);

    return hr;
}

//
// Retrieves the data for an item
//
HRESULT WiaMCamGetItemData(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem,
                           UINT uiState, BYTE *pBuf, DWORD dwLength)
{
    DBG_FN("WiaMCamGetItemData");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    PTSTR ptszFullName = NULL;
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !pItem || !pDeviceInfo->pPrivateStorage, hr, "WiaMCamGetItemData");

    pPrivateDeviceInfo = (UNALIGNED  FAKECAM_DEVICE_INFO *) pDeviceInfo->pPrivateStorage;

    if (uiState & MCAM_STATE_FIRST)
    {
        if (pPrivateDeviceInfo->hFile != NULL)
        {
            wiauDbgError("WiaMCamGetItemData", "File handle is already open");
            hr = E_FAIL;
            goto Cleanup;
        }

        ptszFullName = (PTSTR) pItem->pPrivateStorage;

        wiauDbgTrace("WiaMCamGetItemData", "Opening %" WIAU_DEBUG_TSTR " for reading", ptszFullName);

        pPrivateDeviceInfo->hFile = CreateFile(ptszFullName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
        REQUIRE_FILEHANDLE(pPrivateDeviceInfo->hFile, hr, "WiaMCamGetItemData", "CreateFile failed");
    }

    if (!(uiState & MCAM_STATE_CANCEL))
    {
        DWORD dwReceived = 0;

        if (!pPrivateDeviceInfo->hFile) {
            wiauDbgError("WiaMCamGetItemData", "File handle is NULL");
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!pBuf) {
            wiauDbgError("WiaMCamGetItemData", "Data buffer is NULL");
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        ret = ReadFile(pPrivateDeviceInfo->hFile, pBuf, dwLength, &dwReceived, NULL);
        REQUIRE_FILEIO(ret, hr, "WiaMCamGetItemData", "ReadFile failed");

        if (dwLength != dwReceived)
        {
            wiauDbgError("WiaMCamGetItemData", "Incorrect amount read %d", dwReceived);
            hr = E_FAIL;
            goto Cleanup;
        }

        Sleep(100);
    }

    if (uiState & (MCAM_STATE_LAST | MCAM_STATE_CANCEL))
    {
        if (!pPrivateDeviceInfo->hFile) {
            wiauDbgError("WiaMCamGetItemData", "File handle is NULL");
            hr = E_FAIL;
            goto Cleanup;
        }

        CloseHandle(pPrivateDeviceInfo->hFile);
        pPrivateDeviceInfo->hFile = NULL;
    }

Cleanup:
    return hr;
}

//
// Deletes an item
//
HRESULT WiaMCamDeleteItem(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem)
{
    DBG_FN("WiaMCamDeleteItem");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    DWORD dwFileAttr = 0;
    PTSTR ptszFullName = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !pItem, hr, "WiaMCamDeleteItem");

    ptszFullName = (PTSTR) pItem->pPrivateStorage;

    dwFileAttr = GetFileAttributes(ptszFullName);
    REQUIRE_FILEIO(dwFileAttr != -1, hr, "WiaMCamDeleteItem", "GetFileAttributes failed");

    dwFileAttr |= FILE_ATTRIBUTE_HIDDEN;

    ret = SetFileAttributes(ptszFullName, dwFileAttr);
    REQUIRE_FILEIO(ret, hr, "WiaMCamDeleteItem", "SetFileAttributes failed");

    wiauDbgTrace("WiaMCamDeleteItem", "File %" WIAU_DEBUG_TSTR " is now hidden", ptszFullName);

Cleanup:
    return hr;
}

//
// Sets the protection for an item
//
HRESULT WiaMCamSetItemProt(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly)
{
    DBG_FN("WiaMCamSetItemProt");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    DWORD dwFileAttr = 0;
    PTSTR ptszFullName = NULL;

    REQUIRE_ARGS(!pDeviceInfo || !pItem, hr, "WiaMCamSetItemProt");

    ptszFullName = (PTSTR) pItem->pPrivateStorage;

    dwFileAttr = GetFileAttributes(ptszFullName);
    REQUIRE_FILEIO(dwFileAttr != -1, hr, "WiaMCamSetItemProt", "GetFileAttributes failed");

    if (bReadOnly)
        dwFileAttr |= FILE_ATTRIBUTE_READONLY;
    else
        dwFileAttr &= ~FILE_ATTRIBUTE_READONLY;

    ret = SetFileAttributes(ptszFullName, dwFileAttr);
    REQUIRE_FILEIO(ret, hr, "WiaMCamSetItemProt", "SetFileAttributes failed");

    wiauDbgTrace("WiaMCamSetItemProt", "Protection on file %" WIAU_DEBUG_TSTR " set to %d", ptszFullName, bReadOnly);

Cleanup:
    return hr;
}

//
// Captures a new image
//
HRESULT WiaMCamTakePicture(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItem)
{
    DBG_FN("WiaMCamTakePicture");
    
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pDeviceInfo || !ppItem, hr, "WiaMCamTakePicture");
    *ppItem = NULL;

Cleanup:
    return hr;
}

//
// See if the camera is active
//
HRESULT WiaMCamStatus(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamStatus");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pDeviceInfo, hr, "WiaMCamStatus");

    //
    // This sample device is always active, but your driver should contact the
    // device and return S_FALSE if it's not ready.
    //
    // if (NotReady)
    //   return S_FALSE;

Cleanup:
    return hr;
}

//
// Reset the camera
//
HRESULT WiaMCamReset(MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("WiaMCamReset");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pDeviceInfo, hr, "WiaMCamReset");

Cleanup:
    return hr;
}

////////////////////////////////
//
// Helper functions
//
////////////////////////////////

//
// This function pretends to open a camera. A real driver
// would call CreateDevice.
//
HRESULT FakeCamOpen(PTSTR ptszPortName, MCAM_DEVICE_INFO *pDeviceInfo)
{
    DBG_FN("FakeCamOpen");

    HRESULT hr = S_OK;
    BOOL ret = FALSE;

    //
    // Locals
    //
    FAKECAM_DEVICE_INFO *pPrivateDeviceInfo = NULL;
    DWORD dwFileAttr = 0;
    PTSTR ptszRootPath = NULL;
    UINT uiRootPathSize = 0;
    TCHAR tszPathTemplate[] = TEXT("%userprofile%\\image");

    //
    // Get a pointer to the private storage, so we can put the
    // directory name there
    //
    pPrivateDeviceInfo = (UNALIGNED  FAKECAM_DEVICE_INFO *) pDeviceInfo->pPrivateStorage;
    ptszRootPath = pPrivateDeviceInfo->tszRootPath;
    uiRootPathSize = sizeof(pPrivateDeviceInfo->tszRootPath) / sizeof(pPrivateDeviceInfo->tszRootPath[0]);

    //
    // Unless the port name is set to something other than COMx,
    // LPTx, or AUTO, use %userprofile%\image as the search directory.
    // Since driver runs in LOCAL SERVICE context, %userprofile% points to profile
    // of LOCAL SERVICE account, like "Documents and Settings\Local Service"
    //
    if (_tcsstr(ptszPortName, TEXT("COM")) ||
        _tcsstr(ptszPortName, TEXT("LPT")) ||
    	CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, ptszPortName, -1, TEXT("AUTO"), -1) == CSTR_EQUAL)
    {
        DWORD dwResult = ExpandEnvironmentStrings(tszPathTemplate, ptszRootPath, uiRootPathSize);
        if (dwResult == 0 || dwResult > uiRootPathSize)
        {
            wiauDbgError("WiaMCamOpen", "ExpandEnvironmentStrings failed");
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        lstrcpyn(ptszRootPath, ptszPortName, uiRootPathSize);
    }

    wiauDbgTrace("Open", "Image directory path is %" WIAU_DEBUG_TSTR, ptszRootPath);

    dwFileAttr = GetFileAttributes(ptszRootPath);
    if (dwFileAttr == -1)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
            ret = CreateDirectory(ptszRootPath, NULL);
            REQUIRE_FILEIO(ret, hr, "Open", "CreateDirectory failed");
        }
        else
        {
            wiauDbgErrorHr(hr, "Open", "GetFileAttributes failed");
            goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//
// This function searches a directory on the hard drive for
// items.
//
HRESULT SearchDir(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, PTSTR ptszPath)
{
    DBG_FN("SearchDir");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    HANDLE hFind = NULL;
    WIN32_FIND_DATA FindData;
    const cchTempStrSize = MAX_PATH;
    TCHAR tszTempStr[cchTempStrSize] = TEXT("");
    TCHAR tszFullName[MAX_PATH] = TEXT("");;
    MCAM_ITEM_INFO *pFolder = NULL;
    MCAM_ITEM_INFO *pImage = NULL;
    
    REQUIRE_ARGS(!pPrivateDeviceInfo || !ptszPath, hr, "SearchDir");

    //
    // Search for folders first
    //

    //
    // Make sure search path fits into the buffer and gets zero-terminated
    //
    if (_sntprintf(tszTempStr, cchTempStrSize, _T("%s\\*"), ptszPath) < 0)
    {
        wiauDbgError("SearchDir", "Too long path for search");
        hr = E_FAIL;
        goto Cleanup;
    }
    tszTempStr[cchTempStrSize - 1] = 0;

    wiauDbgTrace("SearchDir", "Searching directory %" WIAU_DEBUG_TSTR, tszTempStr);

    memset(&FindData, 0, sizeof(FindData));
    hFind = FindFirstFile(tszTempStr, &FindData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
            wiauDbgWarning("SearchDir", "Directory %" WIAU_DEBUG_TSTR " is empty", tszTempStr);
            goto Cleanup;
        }
        else
        {
            wiauDbgErrorHr(hr, "SearchDir", "FindFirstFile failed");
            goto Cleanup;
        }
    }

    while (hr == S_OK)
    {
        if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (FindData.cFileName[0] != L'.'))
        {
            hr = MakeFullName(tszFullName, sizeof(tszFullName) / sizeof(tszFullName[0]), 
                              ptszPath, FindData.cFileName);
            REQUIRE_SUCCESS(hr, "SearchDir", "MakeFullName failed");
            
            hr = CreateFolder(pPrivateDeviceInfo, pParent, &FindData, &pFolder, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchDir", "CreateFolder failed");

            hr = AddItem(pPrivateDeviceInfo, pFolder);
            REQUIRE_SUCCESS(hr, "SearchDir", "AddItem failed");

            hr = SearchDir(pPrivateDeviceInfo, pFolder, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchDir", "Recursive SearchDir failed");
        }

        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFile(hFind, &FindData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            {
                wiauDbgErrorHr(hr, "SearchDir", "FindNextFile failed");
                goto Cleanup;
            }
        }
    }
    FindClose(hFind);
    hr = S_OK;

    //
    // Search next for JPEGs
    //

    //
    // Make sure search path fits into the buffer and gets zero-terminated
    //
    if (_sntprintf(tszTempStr, cchTempStrSize, _T("%s\\*.jpg"), ptszPath) < 0)
    {
        wiauDbgError("SearchDir", "Too long path for search");
        hr = E_FAIL;
        goto Cleanup;
    }
    tszTempStr[cchTempStrSize - 1] = 0;

    memset(&FindData, 0, sizeof(FindData));

    hFind = FindFirstFile(tszTempStr, &FindData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
            wiauDbgWarning("SearchDir", "No JPEGs in directory %" WIAU_DEBUG_TSTR, tszTempStr);
            goto Cleanup;
        }
        else
        {
            wiauDbgErrorHr(hr, "SearchDir", "FindFirstFile failed");
            goto Cleanup;
        }
    }

    while (hr == S_OK)
    {
        if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
        {
            hr = MakeFullName(tszFullName, sizeof(tszFullName) / sizeof(tszFullName[0]), 
                              ptszPath, FindData.cFileName);
            REQUIRE_SUCCESS(hr, "SearchDir", "MakeFullName failed");

            hr = CreateImage(pPrivateDeviceInfo, pParent, &FindData, &pImage, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchDir", "CreateImage failed");

            hr = AddItem(pPrivateDeviceInfo, pImage);
            REQUIRE_SUCCESS(hr, "SearchDir", "AddItem failed");

            hr = SearchForAttachments(pPrivateDeviceInfo, pImage, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchDir", "SearchForAttachments failed");

            if (hr == S_OK)
                pImage->bHasAttachments = TRUE;

            hr = S_OK;
        }

        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFile(hFind, &FindData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            {
                wiauDbgErrorHr(hr, "SearchDir", "FindNextFile failed");
                goto Cleanup;
            }
        }
    }
    FindClose(hFind);
    hr = S_OK;

    //
    // ISSUE-10/18/2000-davepar Do the same for other image types
    //

Cleanup:
    return hr;
}

//
// Searches for attachments to an image item
//
HRESULT SearchForAttachments(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, PTSTR ptszMainItem)
{
    DBG_FN("SearchForAttachments");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    INT iNumAttachments = 0;
    HANDLE hFind = NULL;
    WIN32_FIND_DATA FindData;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");
    TCHAR tszFullName[MAX_PATH] = TEXT("");
    TCHAR *ptcSlash = NULL;
    TCHAR *ptcDot = NULL;
    MCAM_ITEM_INFO *pNonImage = NULL;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !ptszMainItem, hr, "SearchForAttachments");
    
    //
    // Find the last dot in the filename and replace the file extension with * and do the search
    //
    lstrcpyn(tszTempStr, ptszMainItem, sizeof(tszTempStr) / sizeof(tszTempStr[0]) - 1);
    ptcDot = _tcsrchr(tszTempStr, TEXT('.'));
    
    if (ptcDot)
    {
        *(ptcDot+1) = TEXT('*');
        *(ptcDot+2) = TEXT('\0');
    }
    else
    {
        wiauDbgError("SearchForAttachments", "Filename did not contain a dot");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Replace the first four "free" characters of the name with ? (attachments only need to match
    // the last four characters of the name)
    //
    ptcSlash = _tcsrchr(tszTempStr, TEXT('\\'));
    if (ptcSlash && ptcDot - ptcSlash > 4)
    {
        for (INT i = 1; i < 5; i++)
            *(ptcSlash+i) = TEXT('?');
    }

    memset(&FindData, 0, sizeof(FindData));
    hFind = FindFirstFile(tszTempStr, &FindData);
    REQUIRE_FILEHANDLE(hFind, hr, "SearchForAttachments", "FindFirstFile failed");

    while (hr == S_OK)
    {
        if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) &&
            !(_tcsstr(ptszMainItem, FindData.cFileName)))
        {
            //
            // Figure out the full name for the item
            //
            lstrcpyn(tszTempStr, ptszMainItem, sizeof(tszTempStr) / sizeof(tszTempStr[0]));
            ptcSlash = _tcsrchr(tszTempStr, TEXT('\\'));
            if (ptcSlash)
            {
                *ptcSlash = TEXT('\0');
            }

            hr = MakeFullName(tszFullName, sizeof(tszFullName) / sizeof(tszFullName[0]), 
                              tszTempStr, FindData.cFileName);
            REQUIRE_SUCCESS(hr, "SearchForAttachments", "MakeFullName failed");

            hr = CreateNonImage(pPrivateDeviceInfo, pParent, &FindData, &pNonImage, tszFullName);
            REQUIRE_SUCCESS(hr, "SearchForAttachments", "CreateNonImage failed");

            hr = AddItem(pPrivateDeviceInfo, pNonImage);
            REQUIRE_SUCCESS(hr, "SearchForAttachments", "AddItem failed");

            iNumAttachments++;
        }

        memset(&FindData, 0, sizeof(FindData));
        if (!FindNextFile(hFind, &FindData))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            if (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
            {
                wiauDbgErrorHr(hr, "SearchForAttachments", "FindNextFile failed");
                goto Cleanup;
            }
        }
    }
    FindClose(hFind);
    if (iNumAttachments > 0)
        hr = S_OK;
    else
        hr = S_FALSE;

Cleanup:
    return hr;    
}

HRESULT CreateFolder(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent,
                     WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppFolder, PTSTR ptszFullName)
{
    DBG_FN("CreateFolder");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    TCHAR *ptcDot = NULL;
    MCAM_ITEM_INFO *pItem = NULL;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pFindData || !ppFolder || !ptszFullName, hr, "CreateFolder");
    *ppFolder = NULL;

    pItem = new MCAM_ITEM_INFO;
    REQUIRE_ALLOC(pItem, hr, "CreateFolder");

    //
    // Chop off the filename extension from the name, if it exists
    //
    lstrcpyn(tszTempStr, pFindData->cFileName, sizeof(tszTempStr) / sizeof(tszTempStr[0]));
    ptcDot = _tcsrchr(tszTempStr, TEXT('.'));
    if (ptcDot)
        *ptcDot = TEXT('\0');

    //
    // Fill in the MCAM_ITEM_INFO structure
    //
    hr = SetCommonFields(pItem, tszTempStr, ptszFullName, pFindData);
    REQUIRE_SUCCESS(hr, "CreateFolder", "SetCommonFields failed");
    
    pItem->pParent = pParent;
    pItem->iType = WiaMCamTypeFolder;

    *ppFolder = pItem;

    pPrivateDeviceInfo->iNumItems++;

    wiauDbgTrace("CreateFolder", "Created folder %" WIAU_DEBUG_TSTR " at 0x%08x under 0x%08x", pFindData->cFileName, pItem, pParent);

Cleanup:
    return hr;
}

HRESULT CreateImage(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent,
                    WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppImage, PTSTR ptszFullName)
{
    DBG_FN("CreateImage");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    PTSTR ptszDot = NULL;
    MCAM_ITEM_INFO *pItem = NULL;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");
    WORD width = 0;
    WORD height = 0;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pFindData || !ppImage || !ptszFullName, hr, "CreateImage");
    *ppImage = NULL;

    pItem = new MCAM_ITEM_INFO;
    REQUIRE_ALLOC(pItem, hr, "CreateImage");

    //
    // Chop off the filename extension from the name, if it exists
    //
    lstrcpyn(tszTempStr, pFindData->cFileName, sizeof(tszTempStr) / sizeof(tszTempStr[0]));
    ptszDot = _tcsrchr(tszTempStr, TEXT('.'));
    if (ptszDot)
        *ptszDot = TEXT('\0');

    //
    // Fill in the MCAM_ITEM_INFO structure
    //
    hr = SetCommonFields(pItem, tszTempStr, ptszFullName, pFindData);
    REQUIRE_SUCCESS(hr, "CreateImage", "SetCommonFields failed");
    
    pItem->pParent = pParent;
    pItem->iType = WiaMCamTypeImage;
    pItem->pguidFormat = &WiaImgFmt_JPEG;
    pItem->lSize = pFindData->nFileSizeLow;
    pItem->pguidThumbFormat = &WiaImgFmt_JPEG;

    // 
    // Copy the file extension into the extension field
    //
    if (ptszDot) {
        hr = wiauStrT2W(ptszDot + 1, pItem->wszExt, MCAM_EXT_LEN * sizeof(pItem->wszExt[0]));
        REQUIRE_SUCCESS(hr, "CreateImage", "wiauStrT2W failed");
    }

    //
    // Interpret the JPEG image to get the image dimensions and thumbnail size
    //
    hr = ReadDimFromJpeg(ptszFullName, &width, &height);
    REQUIRE_SUCCESS(hr, "CreateImage", "ReadDimFromJpeg failed");

    pItem->lWidth = width;
    pItem->lHeight = height;
    pItem->lDepth = 24;
    pItem->lChannels = 3;
    pItem->lBitsPerChannel = 8;
    
    *ppImage = pItem;

    pPrivateDeviceInfo->iNumItems++;
    pPrivateDeviceInfo->iNumImages++;

    wiauDbgTrace("CreateImage", "Created image %" WIAU_DEBUG_TSTR " at 0x%08x under 0x%08x", pFindData->cFileName, pItem, pParent);

Cleanup:
    return hr;
}

HRESULT CreateNonImage(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent,
                       WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppNonImage, PTSTR ptszFullName)
{
    DBG_FN("CreateNonImage");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    PTSTR ptszDot = NULL;
    MCAM_ITEM_INFO *pItem = NULL;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");
    PTSTR ptszExt = NULL;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pFindData || !ppNonImage || !ptszFullName, hr, "CreateNonImage");
    *ppNonImage = NULL;

    pItem = new MCAM_ITEM_INFO;
    REQUIRE_ALLOC(pItem, hr, "CreateNonImage");

    //
    // The name cannot contain a dot and the name needs to be unique
    // wrt the parent image, so replace the dot with an underline character.
    //
    lstrcpyn(tszTempStr, pFindData->cFileName, sizeof(tszTempStr) / sizeof(tszTempStr[0]));
    ptszDot = _tcsrchr(tszTempStr, TEXT('.'));
    if (ptszDot)
        *ptszDot = TEXT('_');

    //
    // Fill in the MCAM_ITEM_INFO structure
    //
    hr = SetCommonFields(pItem, tszTempStr, ptszFullName, pFindData);
    REQUIRE_SUCCESS(hr, "CreateNonImage", "SetCommonFields failed");
    
    pItem->pParent = pParent;
    pItem->iType = WiaMCamTypeOther;
    pItem->lSize = pFindData->nFileSizeLow;

    //
    // Set the format of the item based on the file extension
    //
    if (ptszDot) {
        ptszExt = ptszDot + 1;

        // 
        // Copy the file extension into the extension field
        //
        hr = wiauStrT2W(ptszExt, pItem->wszExt, MCAM_EXT_LEN * sizeof(pItem->wszExt[0]));
        REQUIRE_SUCCESS(hr, "CreateNonImage", "wiauStrT2W failed");

        if (_tcsicmp(ptszExt, TEXT("wav")) == 0) {
            pItem->pguidFormat = &WiaAudFmt_WAV;
            pItem->iType = WiaMCamTypeAudio;
        }
        else if (_tcsicmp(ptszExt, TEXT("mp3")) == 0) {
            pItem->pguidFormat = &WiaAudFmt_MP3;
            pItem->iType = WiaMCamTypeAudio;
        }
        else if (_tcsicmp(ptszExt, TEXT("wma")) == 0) {
            pItem->pguidFormat = &WiaAudFmt_WMA;
            pItem->iType = WiaMCamTypeAudio;
        }
        else if (_tcsicmp(ptszExt, TEXT("rtf")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_RTF;
            pItem->iType = WiaMCamTypeOther;
        }
        else if (_tcsicmp(ptszExt, TEXT("htm")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_HTML;
            pItem->iType = WiaMCamTypeOther;
        }
        else if (_tcsicmp(ptszExt, TEXT("html")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_HTML;
            pItem->iType = WiaMCamTypeOther;
        }
        else if (_tcsicmp(ptszExt, TEXT("txt")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_TXT;
            pItem->iType = WiaMCamTypeOther;
        }
        else if (_tcsicmp(ptszExt, TEXT("mpg")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_MPG;
            pItem->iType = WiaMCamTypeVideo;
        }
        else if (_tcsicmp(ptszExt, TEXT("avi")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_AVI;
            pItem->iType = WiaMCamTypeVideo;
        }
        else if (_tcsicmp(ptszExt, TEXT("asf")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_ASF;
            pItem->iType = WiaMCamTypeVideo;
        }
        else if (_tcsicmp(ptszExt, TEXT("exe")) == 0) {
            pItem->pguidFormat = &WiaImgFmt_EXEC;
            pItem->iType = WiaMCamTypeOther;
        }
        else {
            //
            // Generate a random GUID for the format
            //
            if (g_guidUnknownFormat.Data1 == 0) {
                hr = CoCreateGuid(&g_guidUnknownFormat);
                REQUIRE_SUCCESS(hr, "CreateNonImage", "CoCreateGuid failed");
            }
            pItem->pguidFormat = &g_guidUnknownFormat;
            pItem->iType = WiaMCamTypeOther;
        }
    }

    *ppNonImage = pItem;

    pPrivateDeviceInfo->iNumItems++;

    wiauDbgTrace("CreateNonImage", "Created non-image %" WIAU_DEBUG_TSTR " at 0x%08x under 0x%08x", pFindData->cFileName, pItem, pParent);

Cleanup:
    return hr;
}

//
// Sets the fields of the MCAM_ITEM_INFO that are common to all items
//
HRESULT SetCommonFields(MCAM_ITEM_INFO *pItem,
                        PTSTR ptszShortName,
                        PTSTR ptszFullName,
                        WIN32_FIND_DATA *pFindData)
{
    DBG_FN("SetCommonFields");

    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    PTSTR ptszTempStr = NULL;
    INT iSize = 0;

    REQUIRE_ARGS(!pItem || !ptszShortName || !ptszFullName || !pFindData, hr, "SetFullName");

    //
    // Initialize the structure
    //
    memset(pItem, 0, sizeof(MCAM_ITEM_INFO));
    pItem->iSize = sizeof(MCAM_ITEM_INFO);
    
    iSize = lstrlen(ptszShortName) + 1;
    pItem->pwszName = new WCHAR[iSize];
    REQUIRE_ALLOC(pItem->pwszName, hr, "SetCommonFields");
    wiauStrT2W(ptszShortName, pItem->pwszName, iSize * sizeof(WCHAR));
    REQUIRE_SUCCESS(hr, "SetCommonFields", "wiauStrT2W failed");

    FILETIME ftLocalFileTime;
    memset(&pItem->Time, 0, sizeof(pItem->Time));
    memset(&ftLocalFileTime, 0, sizeof(FILETIME));
    ret = FileTimeToLocalFileTime(&pFindData->ftLastWriteTime, &ftLocalFileTime);
    REQUIRE_FILEIO(ret, hr, "SetCommonFields", "FileTimeToLocalFileTime failed");
    ret = FileTimeToSystemTime(&ftLocalFileTime, &pItem->Time);
    REQUIRE_FILEIO(ret, hr, "SetCommonFields", "FileTimeToSystemTime failed");

    pItem->bReadOnly = pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY;
    pItem->bCanSetReadOnly = TRUE;

    //
    // Set the private storage area of the MCAM_ITEM_INFO structure to the
    // full path name of the item
    //
    iSize = lstrlen(ptszFullName) + 1;
    ptszTempStr = new TCHAR[iSize];
    REQUIRE_ALLOC(ptszTempStr, hr, "SetCommonFields");
    lstrcpy(ptszTempStr, ptszFullName);
    pItem->pPrivateStorage = (BYTE *) ptszTempStr;

Cleanup:
    return hr;
}

HRESULT AddItem(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pItem)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pItem, hr, "AddItem");

    if (pPrivateDeviceInfo->pLastItem) {
        //
        // Insert the item at the end of the list
        //
        pPrivateDeviceInfo->pLastItem->pNext = pItem;
        pItem->pPrev = pPrivateDeviceInfo->pLastItem;
        pItem->pNext = NULL;
        pPrivateDeviceInfo->pLastItem = pItem;
    }
    else
    {
        //
        // List is currently empty, add this as first and only item
        //
        pPrivateDeviceInfo->pFirstItem = pPrivateDeviceInfo->pLastItem = pItem;
        pItem->pPrev = pItem->pNext = NULL;
    }

Cleanup:
    return hr;
}

HRESULT RemoveItem(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pItem)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pPrivateDeviceInfo || !pItem, hr, "RemoveItem");

    if (pItem->pPrev)
        pItem->pPrev->pNext = pItem->pNext;
    if (pItem->pNext)
        pItem->pNext->pPrev = pItem->pPrev;

    if (pPrivateDeviceInfo->pFirstItem == pItem)
        pPrivateDeviceInfo->pFirstItem = pItem->pNext;
    if (pPrivateDeviceInfo->pLastItem == pItem)
        pPrivateDeviceInfo->pLastItem = pItem->pPrev;

Cleanup:
    return hr;
}

//
// This function reads a JPEG file looking for the frame header, which contains
// the width and height of the image.
//
HRESULT ReadDimFromJpeg(PTSTR ptszFullName, WORD *pWidth, WORD *pHeight)
{
    DBG_FN("ReadDimFromJpeg");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    HANDLE hFile = NULL;
    BYTE *pBuffer = NULL;
    DWORD BytesRead = 0;
    BYTE *pCur = NULL;
    int SegmentLength = 0;
    const int Overlap = 8;  // if pCur gets within Overlap bytes of the end, read another chunk
    const DWORD BytesToRead = 32 * 1024;

    REQUIRE_ARGS(!ptszFullName || !pWidth || !pHeight, hr, "ReadDimFromJpeg");

    *pWidth = 0;
    *pHeight = 0;

    hFile = CreateFile(ptszFullName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    REQUIRE_FILEHANDLE(hFile, hr, "ReadDimFromJpeg", "CreateFile failed");
    
    pBuffer = new BYTE[BytesToRead];
    REQUIRE_ALLOC(pBuffer, hr, "ReadDimFromJpeg");

    ret = ReadFile(hFile, pBuffer, BytesToRead, &BytesRead, NULL);
    REQUIRE_FILEIO(ret, hr, "ReadDimFromJpeg", "ReadFile failed");

    wiauDbgTrace("ReadDimFromJpeg", "Read %d bytes", BytesRead);

    pCur = pBuffer;

    //
    // Pretend that we read Overlap fewer bytes than were actually read
    //
    BytesRead -= Overlap;

    while (SUCCEEDED(hr) &&
           BytesRead != 0 &&
           pCur[1] != 0xc0)
    {
        if (pCur[0] != 0xff)
        {
            wiauDbgError("ReadDimFromJpeg", "Not a JFIF format image");
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // if the marker is >= 0xd0 and <= 0xd9 or is equal to 0x01
        // there is no length field
        //
        if (((pCur[1] & 0xf0) == 0xd0 &&
             (pCur[1] & 0x0f) < 0xa) ||
            pCur[1] == 0x01)
        {
            SegmentLength = 0;
        }
        else
        {
            SegmentLength = ByteSwapWord(*((UNALIGNED WORD *) (pCur + 2)));
        }

        pCur += SegmentLength + 2;

        if (pCur >= pBuffer + BytesRead)
        {
            memcpy(pBuffer, pBuffer + BytesRead, Overlap);

            pCur -= BytesRead;

            ret = ReadFile(hFile, pBuffer + Overlap, BytesToRead - Overlap, &BytesRead, NULL);
            REQUIRE_FILEIO(ret, hr, "ReadDimFromJpeg", "ReadFile failed");

            wiauDbgTrace("ReadDimFromJpeg", "Read %d more bytes", BytesRead);
        }
    }

    if (pCur[0] != 0xff)
    {
        wiauDbgError("ReadDimFromJpeg", "Not a JFIF format image");
        return E_FAIL;
    }

    *pHeight = ByteSwapWord(*((UNALIGNED WORD *) (pCur + 5)));
    *pWidth =  ByteSwapWord(*((UNALIGNED WORD *) (pCur + 7)));

Cleanup:
    if (pBuffer) {
        delete []pBuffer;
    }
    if (hFile && hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return hr;
}

//
// The next section contains functions useful for reading information from
// Exif files.
//
HRESULT ReadJpegHdr(PTSTR ptszFullName, BYTE **ppBuf)
{
    DBG_FN("ReadJpegHdr");
    
    HRESULT hr = S_OK;
    BOOL ret;

    //
    // Locals
    //
    HANDLE hFile = NULL;
    BYTE JpegHdr[] = {0xff, 0xd8, 0xff, 0xe1};
    const int JpegHdrSize = sizeof(JpegHdr) + 2;
    BYTE tempBuf[JpegHdrSize];
    DWORD BytesRead = 0;
    WORD TagSize = 0;

    hFile = CreateFile(ptszFullName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    REQUIRE_FILEHANDLE(hFile, hr, "ReadJpegHdr", "CreateFile failed");


    ret = ReadFile(hFile, tempBuf, JpegHdrSize, &BytesRead, NULL);
    REQUIRE_FILEIO(ret, hr, "ReadJpegHdr", "ReadFile failed");
    
    if (BytesRead != JpegHdrSize) {
        wiauDbgError("ReadJpegHdr", "Wrong amount read %d", BytesRead);
        hr = E_FAIL;
        goto Cleanup;
    }
    
    if (memcmp(tempBuf, JpegHdr, sizeof(JpegHdr)) != 0)
    {
        wiauDbgError("ReadJpegHdr", "JPEG header not found");
        hr = E_FAIL;
        goto Cleanup;
    }

    TagSize = GetWord(tempBuf + sizeof(JpegHdr), TRUE);
    *ppBuf = new BYTE[TagSize];
    REQUIRE_ALLOC(ppBuf, hr, "ReadJpegHdr");

    ret = ReadFile(hFile, *ppBuf, TagSize, &BytesRead, NULL);
    REQUIRE_FILEIO(ret, hr, "ReadJpegHdr", "ReadFile failed");
     
    if (BytesRead != TagSize)
    {
        wiauDbgError("ReadJpegHdr", "Wrong amount read %d", BytesRead);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    if (hFile && hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return hr;
}


HRESULT ReadExifJpeg(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap)
{
    DBG_FN("ReadExifJpeg");
    
    HRESULT hr = S_OK;

    BYTE ExifTag[] = {0x45, 0x78, 0x69, 0x66, 0x00, 0x00};

    if (memcmp(pBuf, ExifTag, sizeof(ExifTag)) != 0)
    {
        wiauDbgError("ReadExifJpeg", "Exif tag not found");
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = ReadTiff(pBuf + APP1_OFFSET, pImageIfd, pThumbIfd, pbSwap);
    REQUIRE_SUCCESS(hr, "ReadExifJpeg", "ReadTiff failed");

Cleanup:
    return hr;
}

HRESULT ReadTiff(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap)
{
    DBG_FN("ReadTiff");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    WORD MagicNumber = 0;

    *pbSwap = FALSE;

    if (pBuf[0] == 0x4d) {
        *pbSwap = TRUE;
        if (pBuf[1] != 0x4d)
        {
            wiauDbgError("ReadTiff", "Second TIFF byte swap indicator not present");
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else if (pBuf[0] != 0x49 ||
             pBuf[1] != 0x49)
    {
        wiauDbgError("ReadTiff", "TIFF byte swap indicator not present");
        hr = E_FAIL;
        goto Cleanup;
    }

    MagicNumber = GetWord(pBuf+2, *pbSwap);
    if (MagicNumber != 42)
    {
        wiauDbgError("ReadTiff", "TIFF magic number not present");
        hr = E_FAIL;
        goto Cleanup;
    }

    wiauDbgTrace("ReadTiff", "Reading image IFD");

    pImageIfd->Offset = GetDword(pBuf + 4, *pbSwap);
    hr = ReadIfd(pBuf, pImageIfd, *pbSwap);
    REQUIRE_SUCCESS(hr, "ReadTiff", "ReadIfd failed");

    wiauDbgTrace("ReadTiff", "Reading thumb IFD");

    pThumbIfd->Offset = pImageIfd->NextIfdOffset;
    hr = ReadIfd(pBuf, pThumbIfd, *pbSwap);
    REQUIRE_SUCCESS(hr, "ReadTiff", "ReadIfd failed");

Cleanup:
    return hr;
}

HRESULT ReadIfd(BYTE *pBuf, IFD *pIfd, BOOL bSwap)
{
    DBG_FN("ReadIfd");
    
    HRESULT hr = S_OK;

    const int DIR_ENTRY_SIZE = 12;
    
    pBuf += pIfd->Offset;

    pIfd->Count = GetWord(pBuf, bSwap);

    pIfd->pEntries = new DIR_ENTRY[pIfd->Count];
    if (!pIfd->pEntries)
        return E_OUTOFMEMORY;

    pBuf += 2;
    for (int count = 0; count < pIfd->Count; count++)
    {
        pIfd->pEntries[count].Tag = GetWord(pBuf, bSwap);
        pIfd->pEntries[count].Type = GetWord(pBuf + 2, bSwap);
        pIfd->pEntries[count].Count = GetDword(pBuf + 4, bSwap);
        pIfd->pEntries[count].Offset = GetDword(pBuf + 8, bSwap);
        pBuf += DIR_ENTRY_SIZE;

        wiauDbgDump("ReadIfd", "Tag 0x%04x, type %2d offset/value 0x%08x",
                    pIfd->pEntries[count].Tag, pIfd->pEntries[count].Type, pIfd->pEntries[count].Offset);
    }

    pIfd->NextIfdOffset = GetDword(pBuf, bSwap);

    return hr;
}

VOID FreeIfd(IFD *pIfd)
{
    if (pIfd->pEntries)
        delete []pIfd->pEntries;
    pIfd->pEntries = NULL;
}

WORD ByteSwapWord(WORD w)
{
    return (w >> 8) | (w << 8);
}

DWORD ByteSwapDword(DWORD dw)
{
    return ByteSwapWord((WORD) (dw >> 16)) | (ByteSwapWord((WORD) (dw & 0xffff)) << 16);
}

WORD GetWord(BYTE *pBuf, BOOL bSwap)
{
    WORD w = *((UNALIGNED WORD *) pBuf);

    if (bSwap)
        w = ByteSwapWord(w);
    
    return w;
}

DWORD GetDword(BYTE *pBuf, BOOL bSwap)
{
    DWORD dw = *((UNALIGNED DWORD *) pBuf);

    if (bSwap)
        dw = ByteSwapDword(dw);

    return dw;
}

/*
//
// Set the default and valid values for a property
//
VOID
FakeCamera::SetValidValues(
    INT index,
    CWiaPropertyList *pPropertyList
    )
{
    HRESULT hr = S_OK;

    ULONG ExposureModeList[] = {
        EXPOSUREMODE_MANUAL,
        EXPOSUREMODE_AUTO,
        EXPOSUREMODE_APERTURE_PRIORITY,
        EXPOSUREMODE_SHUTTER_PRIORITY,
        EXPOSUREMODE_PROGRAM_CREATIVE,
        EXPOSUREMODE_PROGRAM_ACTION,
        EXPOSUREMODE_PORTRAIT
    };

    PROPID PropId = pPropertyList->GetPropId(index);
    WIA_PROPERTY_INFO *pPropInfo = pPropertyList->GetWiaPropInfo(index);

    //
    // Based on the property ID, populate the valid values range or list information
    //
    switch (PropId)
    {
    case WIA_DPC_EXPOSURE_MODE:
        pPropInfo->ValidVal.List.Nom      = EXPOSUREMODE_MANUAL;
        pPropInfo->ValidVal.List.cNumList = sizeof(ExposureModeList) / sizeof(ExposureModeList[0]);
        pPropInfo->ValidVal.List.pList    = (BYTE*) ExposureModeList;
        break;

    case WIA_DPC_EXPOSURE_COMP:
        pPropInfo->ValidVal.Range.Nom = 0;
        pPropInfo->ValidVal.Range.Min = -200;
        pPropInfo->ValidVal.Range.Max = 200;
        pPropInfo->ValidVal.Range.Inc = 50;
        break;

    default:
        WIAS_LERROR(g_pIWiaLog,WIALOG_NO_RESOURCE_ID,("FakeCamera::SetValidValues, property 0x%08x not defined", PropId));
        return;
    }

    return;
}
*/

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
\**************************************************************************/


extern "C" __declspec( dllexport )
BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            
            break;

        case DLL_PROCESS_DETACH:
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\fakecam\pch.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       pch.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Pre-compiled header for Fake Camera device
*
***************************************************************************/

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <objbase.h>
#include <tchar.h>

//#include <sti.h>
//#include <stiusd.h>

#include <wiamindr.h>
#include <wiacammc.h>
#include <wiautil.h>
#include <stdio.h>

#include "fakecam.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\tiffutil.cpp ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    minidrv.cpp

Abstract:

    This module implements main part of CWiaMiniDriver class

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#include "pch.h"

const WORD TIFFTAG_IMAGELENGTH              = 257;
const WORD TIFFTAG_IMAGEWIDTH               = 256;
const WORD TIFFTAG_RESOLUTIONUNIT           = 296;
const WORD TIFFTAG_PHOTOMETRIC              = 262;
const WORD TIFFTAG_COMPRESSION              = 259;
const WORD TIFFTAG_XRESOLUTION              = 282;
const WORD TIFFTAG_YRESOLUTION              = 283;
const WORD TIFFTAG_ROWSPERSTRIP             = 278;
const WORD TIFFTAG_STRIPOFFSETS             = 273;
const WORD TIFFTAG_STRIPBYTECOUNTS          = 279;
const WORD TIFFTAG_COLORMAP                 = 320;
const WORD TIFFTAG_BITSPERSAMPLE            = 258;
const WORD TIFFTAG_SAMPLESPERPIXEL          = 277;
const WORD TIFFTAG_ARTIST                   = 315;
const WORD TIFFTAG_COPYRIGHT                = 33432;
const WORD TIFFTAG_DATETIME                 = 306;
const WORD TIFFTAG_MAKE                     = 271;
const WORD TIFFTAG_IMAGEDESCRIPTION         = 270;
const WORD TIFFTAG_MAXSAMPLEVALUE           = 281;
const WORD TIFFTAG_MINSAMPLEVALUE           = 280;
const WORD TIFFTAG_MODEL                    = 272;
const WORD TIFFTAG_NEWSUBFILETYPE           = 254;
const WORD TIFFTAG_ORIENTATION              = 274;
const WORD TIFFTAG_PLANARCONFIGURATION      = 284;

const char  LITTLE_ENDIAN_MARKER = 'I';
const char  BIG_ENDIAN_MARKER    = 'M';
const WORD  TIFF_SIGNATURE_I  = 0x002A;
const WORD  TIFF_SIGNATURE_M  = 0x2A00;

const WORD  TIFF_PHOTOMETRIC_WHITE          = 0;
const WORD  TIFF_PHOTOMETRIC_BLACK          = 1;
const WORD  TIFF_PHOTOMETRIC_RGB            = 2;
const WORD  TIFF_PHOTOMETRIC_PALETTE        = 3;

const WORD  TIFF_COMPRESSION_NONE           = 1;

const WORD  TIFF_TYPE_BYTE                  = 1;
const WORD  TIFF_TYPE_ASCII                 = 2;
const WORD  TIFF_TYPE_SHORT                 = 3;
const WORD  TIFF_TYPE_LONG                  = 4;
const WORD  TIFF_TYPE_RATIONAL              = 5;
const WORD  TIFF_TYPE_SBYTE                 = 6;
const WORD  TIFF_TYPE_UNDEFINED             = 7;
const WORD  TIFF_TYPE_SSHORT                = 8;
const WORD  TIFF_TYPE_SLONG                 = 9;
const WORD  TIFF_TYPE_SRATIONAL             = 10;
const WORD  TIFF_TYPE_FLOAT                 = 11;
const WORD  TIFF_TYPE_DOUBLE                = 12;

typedef struct tagTiffHeader
{
    char    ByteOrder_1;
    char    ByteOrder_2;
    WORD    Signature;
    DWORD   IFDOffset;
}TIFF_HEADER, *PTIFF_HEADER;

typedef struct tagTiffTag
{
    WORD    TagId;          // tag id
    WORD    Type;           // tag data type
    DWORD   Count;          // how many items
    DWORD   ValOffset;      // offset to the data items
}TIFF_TAG, *PTIFF_TAG;

typedef struct tagTiffImageInfo
{
    DWORD    ImageHeight;
    DWORD    ImageWidth;
    DWORD    BitsPerSample;
    DWORD    SamplesPerPixel;
    DWORD    PhotoMetric;
    DWORD    Compression;
    DWORD    RowsPerStrip;
    DWORD    NumStrips;
    DWORD    *pStripOffsets;
    DWORD    *pStripByteCounts;
}TIFF_IMAGEINFO, *PTIFF_IMAGEINFO;


WORD
ByteSwapWord(WORD w)
{
    return((w &0xFF00) >> 8 | (w & 0xFF) << 8);
}


DWORD
ByteSwapDword(DWORD dw)
{
    return((DWORD)(ByteSwapWord((WORD)((dw &0xFFFF0000) >> 16))) |
           (DWORD)(ByteSwapWord((WORD)(dw & 0xFFFF))) << 16);
}

DWORD
GetDIBLineSize(
              DWORD   Width,
              DWORD   BitsCount
              )
{
    return(Width * (BitsCount / 8) + 3) & ~3;
}

DWORD
GetDIBSize(
          BITMAPINFO *pbmi
          )
{
    return GetDIBBitsOffset(pbmi) +
    GetDIBLineSize(pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biBitCount) *
    abs(pbmi->bmiHeader.biHeight);
}

DWORD
GetDIBBitsOffset(
                BITMAPINFO *pbmi
                )
{
    DWORD Offset = (DWORD)-1;
    if (pbmi && pbmi->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER))
    {
        Offset = pbmi->bmiHeader.biSize;
        if (pbmi->bmiHeader.biBitCount <= 8)
        {
            if (pbmi->bmiHeader.biClrUsed)
            {
                Offset += pbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD);
            }
            else
            {
                Offset += ((DWORD) 1 << pbmi->bmiHeader.biBitCount) * sizeof(RGBQUAD);
            }
        }
        if (BI_BITFIELDS == pbmi->bmiHeader.biCompression)
        {
            Offset += 3 * sizeof(DWORD);
        }
    }
    return Offset;
}


HRESULT
WINAPI
GetTiffDimensions(
                 BYTE *pTiff,
                 UINT TiffSize,
                 UINT *pWidth,
                 UINT *pHeight,
                 UINT *pBitDepth
                 )
{

    if (!pTiff || !TiffSize || !pWidth || !pHeight || !pBitDepth)
        return E_INVALIDARG;

    DWORD CurOffset;
    WORD  TagCounts;
    BOOL bByteSwap;

    TIFF_TAG *pTiffTags;

    HRESULT hr;

    DWORD BitsPerSample;
    DWORD SamplesPerPixel;

    if (BIG_ENDIAN_MARKER == *((CHAR *)pTiff) &&
        BIG_ENDIAN_MARKER == *((CHAR *)pTiff + 1))
    {
        if (TIFF_SIGNATURE_M != *((WORD *)pTiff + 1))
            return E_INVALIDARG;
        bByteSwap = TRUE;
        CurOffset = ByteSwapDword(*((DWORD *)(pTiff + 4)));
        TagCounts = ByteSwapWord(*((WORD *)(pTiff + CurOffset)));
    }
    else
    {
        if (TIFF_SIGNATURE_I != *((WORD *)pTiff + 1))
            return E_INVALIDARG;
        bByteSwap = FALSE;
        CurOffset = *((DWORD *)(pTiff + 4));
        TagCounts = *((WORD *)(pTiff + CurOffset));
    }
    pTiffTags = (TIFF_TAG *)(pTiff + CurOffset + sizeof(WORD));

    hr = S_OK;

    *pWidth = 0;
    *pHeight = 0;
    *pBitDepth = 0;
    //
    // Assuming it is 24bits color
    //
    BitsPerSample = 8;
    SamplesPerPixel = 3;

    while (TagCounts && S_OK == hr)
    {
        WORD TagId;
        WORD Type;
        DWORD Count;
        DWORD ValOffset;
        WORD i;
        DWORD *pdwOffset;
        WORD  *pwOffset;
        if (bByteSwap)
        {
            TagId = ByteSwapWord(pTiffTags->TagId);
            Type = ByteSwapWord(pTiffTags->Type);
            Count = ByteSwapDword(pTiffTags->Count);
            ValOffset = ByteSwapDword(pTiffTags->ValOffset);
        }
        else
        {
            TagId = pTiffTags->TagId;
            Type = pTiffTags->Type;
            Count = pTiffTags->Count;
            ValOffset = pTiffTags->ValOffset;
        }
        switch (TagId)
        {
        case TIFFTAG_IMAGELENGTH:
            if (TIFF_TYPE_SHORT == Type)
                *pHeight =  (WORD)ValOffset;
            else
                *pHeight = ValOffset;
            break;
        case TIFFTAG_IMAGEWIDTH:
            if (TIFF_TYPE_SHORT == Type)
                *pWidth = (WORD)ValOffset;
            else
                *pWidth = ValOffset;
            break;
        case TIFFTAG_PHOTOMETRIC:
            if (TIFF_PHOTOMETRIC_RGB != (WORD)ValOffset)
            {
                //
                // bi-level or grayscale or palette.
                //
                SamplesPerPixel = 1;
            }
            else
            {
                SamplesPerPixel = 3;
            }
            break;
        case TIFFTAG_BITSPERSAMPLE:
            BitsPerSample = (WORD)ValOffset;
            break;
        case TIFFTAG_SAMPLESPERPIXEL:
            SamplesPerPixel = (WORD)ValOffset;
            break;
        default:
            break;
        }
        pTiffTags++;
        TagCounts--;
    }
    *pBitDepth = SamplesPerPixel * BitsPerSample;
    return S_OK;
}


//
// This function converts a TIFF file in memory to DIB bitmap
// Input:
//	pTiff	-- Tiff file in memory. TIFF, TIFF/EP, TIFF/IT are supported
//	TiffSize -- the TIFF file size
//	DIBBmpSize -- DIB bitmap buffer size
//	pDIBBmp    -- DIB bitmap buffer
//	LineSize   -- destination scanline size in bytes
//	MaxLines   -- maximum scanline can be delivered per callback
//		      0 if we decide it.
//	pProgressCB -- optional callback
//	pCBContext  -- context for the callback.
//			If no callback is provided, the given dib
//			bitmap buffer must be big enough to
//			receive the entire bitmap.
// Output:
//	HRESULT     -- S_FALSE if the client aborted the transfer
//
HRESULT
WINAPI
Tiff2DIBBitmap(
              BYTE *pTiff,
              UINT TiffSize,
              BYTE  *pDIBBmp,
              UINT DIBBmpSize,
              UINT LineSize,
              UINT MaxLines
              )
{
    if (!pTiff || !TiffSize || !pDIBBmp || !DIBBmpSize || !LineSize)
        return E_INVALIDARG;

    HRESULT hr;
    DWORD CurOffset;
    WORD  TagCounts;
    BOOL bByteSwap;

    TIFF_TAG *pTiffTags;

    TIFF_IMAGEINFO TiffImageInfo;

    ZeroMemory(&TiffImageInfo, sizeof(TiffImageInfo));
    //
    // Set some default values
    //
    TiffImageInfo.PhotoMetric = TIFF_PHOTOMETRIC_RGB;
    TiffImageInfo.SamplesPerPixel = 3;
    TiffImageInfo.BitsPerSample = 8;
    TiffImageInfo.Compression = TIFF_COMPRESSION_NONE;

    if (BIG_ENDIAN_MARKER == *((CHAR *)pTiff) &&
        BIG_ENDIAN_MARKER == *((CHAR *)pTiff + 1))
    {
        if (TIFF_SIGNATURE_M != *((WORD *)pTiff + 1))
            return E_INVALIDARG;
        bByteSwap = TRUE;
        CurOffset = ByteSwapDword(*((DWORD *)(pTiff + 4)));
        TagCounts = ByteSwapWord(*((WORD *)(pTiff + CurOffset)));
    }
    else
    {
        if (TIFF_SIGNATURE_I != *((WORD *)pTiff + 1))
            return E_INVALIDARG;
        bByteSwap = FALSE;
        CurOffset = *((DWORD *)(pTiff + 4));
        TagCounts = *((WORD *)(pTiff + CurOffset));
    }
    pTiffTags = (TIFF_TAG *)(pTiff + CurOffset + sizeof(WORD));

    hr = S_OK;

    while (TagCounts && SUCCEEDED(hr))
    {
        WORD TagId;
        WORD Type;
        DWORD Count;
        DWORD ValOffset;
        WORD i;
        DWORD *pdwOffset;
        WORD  *pwOffset;
        if (bByteSwap)
        {
            TagId = ByteSwapWord(pTiffTags->TagId);
            Type = ByteSwapWord(pTiffTags->Type);
            Count = ByteSwapDword(pTiffTags->Count);
            ValOffset = ByteSwapDword(pTiffTags->ValOffset);
        }
        else
        {
            TagId = pTiffTags->TagId;
            Type = pTiffTags->Type;
            Count = pTiffTags->Count;
            ValOffset = pTiffTags->ValOffset;
        }
        switch (TagId)
        {
        case TIFFTAG_IMAGELENGTH:
            if (TIFF_TYPE_SHORT == Type)
                TiffImageInfo.ImageHeight = (WORD)ValOffset;
            else
                TiffImageInfo.ImageHeight = ValOffset;
            break;
        case TIFFTAG_IMAGEWIDTH:
            if (TIFF_TYPE_SHORT == Type)
                TiffImageInfo.ImageWidth = (WORD)ValOffset;
            else
                TiffImageInfo.ImageWidth = ValOffset;
            break;
        case TIFFTAG_PHOTOMETRIC:
            TiffImageInfo.PhotoMetric = (WORD)ValOffset;
            if (TIFF_PHOTOMETRIC_RGB != (WORD)ValOffset)
            {
                //
                // bi-level or grayscale or palette.
                //
                TiffImageInfo.SamplesPerPixel = 1;
            }
            else
            {
                TiffImageInfo.SamplesPerPixel = 3;
            }
            break;
        case TIFFTAG_COMPRESSION:
            TiffImageInfo.Compression = ValOffset;
            break;
        case TIFFTAG_ROWSPERSTRIP:
            if (TIFF_TYPE_SHORT == Type)
                TiffImageInfo.RowsPerStrip = (WORD)ValOffset;
            else
                TiffImageInfo.RowsPerStrip = ValOffset;
            break;
        case TIFFTAG_STRIPOFFSETS:
            TiffImageInfo.pStripOffsets = new DWORD[Count];
            TiffImageInfo.NumStrips = Count;
            if (!TiffImageInfo.pStripOffsets)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            for (i = 0; i < Count ; i++)
            {
                if (TIFF_TYPE_SHORT == Type)
                {
                    pwOffset = (WORD *)(pTiff + ValOffset);
                    if (bByteSwap)
                    {
                        TiffImageInfo.pStripOffsets[i] = ByteSwapWord(*pwOffset);
                    }
                    else
                    {
                        TiffImageInfo.pStripOffsets[i] = *pwOffset;
                    }
                }
                else if (TIFF_TYPE_LONG == Type)
                {
                    pdwOffset = (DWORD *)(pTiff + ValOffset);
                    if (bByteSwap)
                    {
                        TiffImageInfo.pStripOffsets[i] = ByteSwapDword(*pdwOffset);
                    }
                    else
                    {
                        TiffImageInfo.pStripOffsets[i] = *pdwOffset;
                    }
                }
            }
            break;
        case TIFFTAG_STRIPBYTECOUNTS:
            TiffImageInfo.pStripByteCounts = new DWORD[Count];
            TiffImageInfo.NumStrips = Count;
            if (!TiffImageInfo.pStripByteCounts)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            for (i = 0; i < Count ; i++)
            {
                if (TIFF_TYPE_SHORT == Type)
                {
                    pwOffset = (WORD *)(pTiff + ValOffset);
                    if (bByteSwap)
                    {
                        TiffImageInfo.pStripByteCounts[i] = ByteSwapWord(*pwOffset);
                    }
                    else
                    {
                        TiffImageInfo.pStripByteCounts[i] = *pwOffset;
                    }
                }
                else if (TIFF_TYPE_LONG == Type)
                {
                    pdwOffset = (DWORD *)(pTiff + ValOffset);
                    if (bByteSwap)
                    {
                        TiffImageInfo.pStripByteCounts[i] = ByteSwapDword(*pdwOffset);
                    }
                    else
                    {
                        TiffImageInfo.pStripByteCounts[i] = *pdwOffset;
                    }
                }
            }
            break;
        case TIFFTAG_BITSPERSAMPLE:
            TiffImageInfo.BitsPerSample = (WORD)ValOffset;
            break;
        case TIFFTAG_SAMPLESPERPIXEL:
            TiffImageInfo.SamplesPerPixel = (WORD)ValOffset;
            break;
        case TIFFTAG_XRESOLUTION:
        case TIFFTAG_YRESOLUTION:
        case TIFFTAG_RESOLUTIONUNIT:
            // do this later
            break;
        default:
            break;
        }
        pTiffTags++;
        TagCounts--;
    }
    if (!SUCCEEDED(hr))
    {
        //
        // If something wrong happen along the way, free
        // any memory we have allocated.
        //
        if (TiffImageInfo.pStripOffsets)
            delete [] TiffImageInfo.pStripOffsets;
        if (TiffImageInfo.pStripByteCounts)
            delete [] TiffImageInfo.pStripByteCounts;
        return hr;
    }

    //
    // Support RGB full color for now.
    // Also, we do not support any compression.
    //
    if (TIFF_PHOTOMETRIC_RGB != TiffImageInfo.PhotoMetric ||
        TIFF_COMPRESSION_NONE != TiffImageInfo.Compression ||
        DIBBmpSize < LineSize * TiffImageInfo.ImageHeight)
    {
        delete [] TiffImageInfo.pStripOffsets;
        delete [] TiffImageInfo.pStripByteCounts;
        return E_INVALIDARG;
    }

    if (1 == TiffImageInfo.NumStrips)
    {
        //
        // With single strip, the writer may write a
        // 2**31 -1(infinity) which would confuses our
        // code below. Here, we set it to the right value
        //
        TiffImageInfo.RowsPerStrip = TiffImageInfo.ImageHeight;
    }
    //
    // DIB scanlines are DWORD aligned while TIFF scanlines
    // are BYTE aligned(when the compression value is 1 which
    // is the case we enforce). Because of this, we copy the bitmap
    // scanline by scanline
    //

    DWORD NumStrips;
    DWORD *pStripOffsets;
    DWORD *pStripByteCounts;
    DWORD TiffLineSize;
    //
    // Tiff scanlines with compression 1 are byte aligned.
    //
    TiffLineSize = TiffImageInfo.ImageWidth * TiffImageInfo. BitsPerSample *
                   TiffImageInfo.SamplesPerPixel / 8;
    //
    // For convenience
    //
    pStripOffsets = TiffImageInfo.pStripOffsets;
    pStripByteCounts = TiffImageInfo.pStripByteCounts;
    NumStrips = TiffImageInfo.NumStrips;
    for (hr = S_OK, NumStrips = TiffImageInfo.NumStrips; NumStrips; NumStrips--)
    {
        DWORD Lines;
        BYTE  *pTiffBits;

        //
        // how many lines to copy in this strip. Ignore any remaining bytes
        //
        Lines = *pStripByteCounts / TiffLineSize;
        //
        // The bits
        //
        pTiffBits = pTiff + *pStripOffsets;
        for (hr = S_OK; Lines, S_OK == hr; Lines--)
        {
            if (DIBBmpSize >= LineSize)
            {
                memcpy(pDIBBmp, pTiffBits, TiffLineSize);
                pDIBBmp -= LineSize;
                DIBBmpSize -= LineSize;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            pTiffBits += TiffLineSize;
        }
        pStripOffsets++;
        pStripByteCounts++;
    }
    delete [] TiffImageInfo.pStripOffsets;
    delete [] TiffImageInfo.pStripByteCounts;
    return hr;
}

////////////////////////////// GDI+ dynamic linking, image geometry
////////////////////////////// retrieval & decompression 

#include <gdiplus.h>
#include <gdiplusflat.h>
#include <private.h>

HINSTANCE g_hGdiPlus = NULL;
ULONG_PTR g_GdiPlusToken = 0;
GUID g_guidCodecBmp;
Gdiplus::GdiplusStartupInput g_GdiPlusStartupInput;

Gdiplus::GpStatus (WINAPI *pGdipLoadImageFromStream)(IStream *pStream,  Gdiplus::GpImage **pImage) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipSaveImageToStream)(Gdiplus::GpImage *image, IStream* stream, 
    CLSID* clsidEncoder, Gdiplus::EncoderParameters* encoderParams) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipSaveImageToFile)(Gdiplus::GpImage *image, WCHAR * stream, 
    CLSID* clsidEncoder, Gdiplus::EncoderParameters* encoderParams) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImageWidth)(Gdiplus::GpImage *pImage, UINT *pWidth) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImageHeight)(Gdiplus::GpImage *pImage, UINT *pWidth) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImagePixelFormat)(Gdiplus::GpImage *pImage, Gdiplus::PixelFormat *pFormat) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipDisposeImage)(Gdiplus::GpImage *pImage) = NULL;
Gdiplus::GpStatus (WINAPI *pGdiplusStartup)(ULONG_PTR *token,
                                             const Gdiplus::GdiplusStartupInput *input,
                                             Gdiplus::GdiplusStartupOutput *output) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImageEncodersSize)(UINT *numEncoders, UINT *size) = NULL;
Gdiplus::GpStatus (WINAPI *pGdipGetImageEncoders)(UINT numEncoders, UINT size, Gdiplus::ImageCodecInfo *encoders) = NULL;
VOID (WINAPI *pGdiplusShutdown)(ULONG_PTR token) = NULL;

HRESULT InitializeGDIPlus(void)
{
    HRESULT hr = E_FAIL;
    Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;


    g_hGdiPlus = LoadLibraryA("gdiplus.dll");
    if(!g_hGdiPlus) {
        wiauDbgError("InitializeGDIPlus", "Failed to load gdiplus.dll");
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *((FARPROC*)&pGdipLoadImageFromStream) = GetProcAddress(g_hGdiPlus, "GdipLoadImageFromStream");
    *((FARPROC*)&pGdipSaveImageToStream) = GetProcAddress(g_hGdiPlus, "GdipSaveImageToStream");
    *((FARPROC*)&pGdipSaveImageToFile) = GetProcAddress(g_hGdiPlus, "GdipSaveImageToFile");
    *((FARPROC*)&pGdipGetImageWidth) = GetProcAddress(g_hGdiPlus, "GdipGetImageWidth");
    *((FARPROC*)&pGdipGetImageHeight) = GetProcAddress(g_hGdiPlus, "GdipGetImageHeight");
    *((FARPROC*)&pGdipGetImagePixelFormat) = GetProcAddress(g_hGdiPlus, "GdipGetImagePixelFormat");
    *((FARPROC*)&pGdipDisposeImage) = GetProcAddress(g_hGdiPlus, "GdipDisposeImage");
    *((FARPROC*)&pGdiplusStartup) = GetProcAddress(g_hGdiPlus, "GdiplusStartup");
    *((FARPROC*)&pGdipGetImageEncodersSize) = GetProcAddress(g_hGdiPlus, "GdipGetImageEncodersSize");
    *((FARPROC*)&pGdipGetImageEncoders) = GetProcAddress(g_hGdiPlus, "GdipGetImageEncoders");
    *((FARPROC*)&pGdiplusShutdown) = GetProcAddress(g_hGdiPlus, "GdiplusShutdown");


    if(!pGdipLoadImageFromStream ||
       !pGdipSaveImageToStream ||
       !pGdipGetImageWidth ||
       !pGdipGetImageHeight ||
       !pGdipGetImagePixelFormat ||
       !pGdipDisposeImage ||
       !pGdiplusStartup ||
       !pGdipGetImageEncodersSize ||
       !pGdipGetImageEncoders ||
       !pGdiplusShutdown)
    {
        wiauDbgError("InitializeGDIPlus", "Failed to retrieve all the entry points from GDIPLUS.DLL");
        hr = E_FAIL;
        goto Cleanup;
    }

    
    if(Gdiplus::Ok != pGdiplusStartup(&g_GdiPlusToken, &g_GdiPlusStartupInput, NULL)) {
        wiauDbgError("InitializeGDIPlus", "GdiPlusStartup() failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    UINT  num = 0;          // number of image encoders
    UINT  size = 0;         // size of the image encoder array in bytes

    pGdipGetImageEncodersSize(&num, &size);
    if(size == 0)
    {
        wiauDbgError("InitializeGDIPlus", "GetImageEncodersSize() failed");
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));
    if(pImageCodecInfo == NULL) {
        wiauDbgError("InitializeGDIPlus", "failed to allocate encoders data");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if(Gdiplus::Ok != pGdipGetImageEncoders(num, size, pImageCodecInfo))
    {
        wiauDbgError("InitializeGDIPlus", "failed to retrieve encoders data");
        hr = E_FAIL;
        goto Cleanup;
    }

    for(UINT j = 0; j < num; ++j)
    {
        if( pImageCodecInfo[j].FormatID == WiaImgFmt_BMP)
        {
            g_guidCodecBmp = pImageCodecInfo[j].Clsid;
            hr = S_OK;
            break;
        }    
    } // for

    
Cleanup:
    if(pImageCodecInfo) free(pImageCodecInfo);
    return hr;
}

void UnInitializeGDIPlus(void)
{
    if(!pGdipLoadImageFromStream) 
        return;
    if(pGdiplusShutdown)
        pGdiplusShutdown(g_GdiPlusToken);
    
    FreeLibrary(g_hGdiPlus);
    pGdipLoadImageFromStream = 0;
}

HRESULT LoadImageFromMemory(BYTE *pData, UINT CompressedDataSize, Gdiplus::GpImage **ppImage)
{
    HRESULT hr = S_OK;
    
    if(pData == NULL || CompressedDataSize == 0 || ppImage == NULL) {
        return E_INVALIDARG;
    }

    if(!pGdipLoadImageFromStream) {
        hr = InitializeGDIPlus();
        if(FAILED(hr)) {
            wiauDbgError("LoadImageFromMemory", "Failed to initialize GDI+");
            return hr;
        }
    }

    CImageStream *pStream = new CImageStream();
    if(!pStream) {
        wiauDbgError("LoadImageFromMemory", "Failed to create Image Stream");
        return E_OUTOFMEMORY;
    }

    hr = pStream->SetBuffer(pData, CompressedDataSize);
    if(FAILED(hr)) {
        wiauDbgError("LoadImageFromMemory", "Failed to create Image Stream");
        goto Cleanup;
    }

    if(Gdiplus::Ok == pGdipLoadImageFromStream(pStream, ppImage)) {
        hr = S_OK;
    } else {
        wiauDbgError("LoadImageFromMemory", "GDI+ failed to load image");
        hr = E_FAIL;
    }

    
Cleanup:
    if(pStream)
        pStream->Release();
    return hr;
}

HRESULT DisposeImage(Gdiplus::GpImage **ppImage)
{
    if(ppImage == NULL || *ppImage == NULL) {
        return E_INVALIDARG;
    }

    if(pGdipDisposeImage) {
        pGdipDisposeImage(*ppImage);
    }
    
    *ppImage = NULL;

    return S_OK;
}

HRESULT SaveImageToBitmap(Gdiplus::GpImage *pImage, BYTE *pBuffer, UINT BufferSize)
{
    HRESULT hr = S_OK;

    CImageStream *pOutStream = new CImageStream;

    if(!pOutStream) {
        wiauDbgError("SaveImageToBitmap", "failed to allocate CImageStream");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pOutStream->SetBuffer(pBuffer, BufferSize, SKIP_OFF);
    if(FAILED(hr)) {
        wiauDbgError("SaveImageToBitmap", "failed to set output buffer");
        goto Cleanup;
    }
    
    if(Gdiplus::Ok != pGdipSaveImageToStream(pImage, pOutStream, &g_guidCodecBmp, NULL)) {
        wiauDbgError("SaveImageToBitmap", "GDI+ save failed");
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    if(pOutStream) {
        pOutStream->Release();
    }

    return hr;
}

HRESULT
WINAPI
GetImageDimensions(
                   UINT ptpFormatCode,
                   BYTE *pCompressedData,
                   UINT CompressedDataSize,
                   UINT *pWidth,
                   UINT *pHeight,
                   UINT *pBitDepth
                  )
{
    HRESULT hr = S_OK;
    
    if(pWidth) *pWidth = 0;
    if(pHeight) *pHeight = 0;
    if(pBitDepth) *pBitDepth = 0;

    // locate GUID for this particular format
    FORMAT_INFO *pFormatInfo = FormatCodeToFormatInfo((WORD) ptpFormatCode);
    if(pFormatInfo == NULL ||
       pFormatInfo->FormatGuid == NULL ||
       IsEqualGUID(WiaImgFmt_UNDEFINED, *pFormatInfo->FormatGuid))
    {
        wiauDbgError("GetImageDimensions", "unrecoginzed PTP format code");
        return E_INVALIDARG;
    }

    Gdiplus::GpImage *pImage = NULL;

    hr = LoadImageFromMemory(pCompressedData, CompressedDataSize, &pImage);
    if(FAILED(hr) || !pImage) {
        wiauDbgError("GetImageDimensions", "failed to create GDI+ image from supplied data.");
        return hr;
    }

    if(pWidth) pGdipGetImageWidth(pImage, pWidth);
    if(pHeight) pGdipGetImageHeight(pImage, pHeight);
    if(pBitDepth) {
        Gdiplus::PixelFormat pf = 0;

        pGdipGetImagePixelFormat(pImage, &pf);
        *pBitDepth = Gdiplus::GetPixelFormatSize(pf);
    }

    DisposeImage(&pImage);
    
    return hr;
}


HRESULT WINAPI
ConvertAnyImageToBmp(BYTE *pCompressedImage,
                     UINT CompressedSize,
                     UINT *pWidth,
                     UINT *pHeight,
                     UINT *pBitDepth,
                     BYTE **pDIBBmp,
                     UINT *pImageSize,
                     UINT *pHeaderSize
                    )

{
    HRESULT hr = S_OK;
    Gdiplus::GpImage *pImage = NULL;
    Gdiplus::PixelFormat pf = 0;
    UINT headersize;
    UNALIGNED BITMAPINFOHEADER *pbi;
    UNALIGNED BITMAPFILEHEADER *pbf;
    

    if(!pCompressedImage || !CompressedSize || !pWidth || !pHeight || !pBitDepth || !pDIBBmp || !pImageSize || !pHeaderSize)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = LoadImageFromMemory(pCompressedImage, CompressedSize, &pImage);
    if(FAILED(hr) || !pImage) {
        wiauDbgError("ConvertAnyImageToBmp", "failed to create GDI+ image from supplied data.");
        goto Cleanup;
    }

    pGdipGetImageWidth(pImage, pWidth);
    pGdipGetImageHeight(pImage, pHeight);
    pGdipGetImagePixelFormat(pImage, &pf);
    *pBitDepth = Gdiplus::GetPixelFormatSize(pf);

    *pImageSize = ((*pWidth) * (*pBitDepth) / 8L) * *pHeight;
    headersize = 8192; // big enough to hold any bitmap header

    *pDIBBmp = new BYTE[*pImageSize + headersize];
    if(!*pDIBBmp) {
        wiauDbgError("ConvertAnyImageToBmp", "failed to convert GDI+ image to bitmap.");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = SaveImageToBitmap(pImage, *pDIBBmp, *pImageSize + headersize);
    if(FAILED(hr)) {
        wiauDbgError("ConvertAnyImageToBmp", "failed to convert GDI+ image to bitmap.");
        goto Cleanup;
    }

    // find out real header size
    pbf = (BITMAPFILEHEADER *)*pDIBBmp;    
    pbi = (BITMAPINFOHEADER *)(*pDIBBmp + sizeof(BITMAPFILEHEADER));

    if(*pBitDepth == 8 && pbi->biClrUsed == 2) {
        // expand color table for bilevel images
        // (TWAIN apps don't understand 2 entry colortable (0,0,0)(1,1,1)
        UNALIGNED RGBQUAD *pRgb = (RGBQUAD *)((BYTE *)pbi + pbi->biSize);
        BYTE *src = (BYTE *)(pRgb + 2);
        BYTE *dst = (BYTE *)(pRgb + 256);
        
        int i;
        
        // negate and move image
        for(i = *pImageSize - 1; i >= 0; i--) {
            dst[i] = src[i] ? 255 : 0;
        }

        pbi->biClrUsed = 256;
        pbi->biClrImportant = 256;

        pRgb[0].rgbBlue = pRgb[0].rgbRed = pRgb[0].rgbGreen = 0;
        pRgb[0].rgbReserved = 0;
        for(i = 1; i < 256; i++) {
            pRgb[i].rgbReserved = 0;
            pRgb[i].rgbBlue = pRgb[i].rgbRed = pRgb[i].rgbGreen = 255;
        }

        
        pbf->bfOffBits = sizeof(BITMAPFILEHEADER) + pbi->biSize + sizeof(RGBQUAD) * 256;
        pbf->bfSize = pbf->bfOffBits + *pImageSize;
    }
    
    *pHeaderSize = pbf->bfOffBits;

Cleanup:
    if(FAILED(hr)) {
        delete [] *pDIBBmp;
        *pDIBBmp = NULL;
    }
    
    DisposeImage(&pImage);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\sources.inc ===
#############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   DavePar
#
#Date:
#   20-Jul-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     ISO/PIMA 15740 Picture Transfer Protocol driver
#
#############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=ptpusd
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)

DLLDEF=..\ptpusd.def
DLLENTRY=_DllMainCRTStartup

USE_MSVCRT = 1

INCLUDES= \
        $(PROJECT_ROOT)\wia\common\jpeglib; \
        ..\..\common; \
        $(DDK_INC_PATH); \
        $(PROJECT_ROOT)\wia\drivers\inc; \
        $(SDK_INC_PATH)\atl30;                \
        $(INCLUDES); \
        $(PROJECT_ROOT)\wia\drivers\util; 


PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\pch.h
PRECOMPILED_OBJ = pch.obj

#
# Avoid boolean conflict with the jpeg library
#
C_DEFINES=$(C_DEFINES) -DHAVE_BOOLEAN -DWIAJPEG

!if defined(CHICAGO_PRODUCT )
LIB_SUFFIX=chicago
!else
LIB_SUFFIX=winnt
!endif

WPP_SOURCES=            \
        ..\minidrv.cpp  \
        ..\devitem.cpp  \
        ..\imgitem.cpp  \
        ..\eventcb.cpp

SOURCES=$(WPP_SOURCES)  \
        ..\jpegutil.cpp \
        ..\tiffutil.cpp \
        ..\dllmain.cpp  \
        ..\factory.cpp  \
        ..\ptpusd.rc

TARGETLIBS= $(TARGETLIBS) \
          ..\..\common\$(LIB_SUFFIX)\$(OBJ_DIR)\$(TARGET_DIRECTORY)\ptpusb.lib \
          $(WIA_LIB_PATH)\jpeg.lib        \
          $(SDK_LIB_PATH)\wiaguid.lib     \
          $(DDK_LIB_PATH)\wiaservc.lib    \
          $(SDK_LIB_PATH)\uuid.lib        \
          ..\..\..\..\util\$(LIB_SUFFIX)\$(OBJ_DIR)\$(TARGET_DIRECTORY)\wiautil.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\fakecam\fakecam.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       fakecam.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Camera device
*
***************************************************************************/

#pragma once

//
// Structure to hold information about the device
//
typedef struct _FAKECAM_DEVICE_INFO
{
    TCHAR           tszRootPath[MAX_PATH];
    MCAM_ITEM_INFO *pFirstItem;
    MCAM_ITEM_INFO *pLastItem;
    INT             iNumImages;
    INT             iNumItems;
    HANDLE          hFile;

} UNALIGNED FAKECAM_DEVICE_INFO, * UNALIGNED PFAKECAM_DEVICE_INFO;

//
// Functions
//
inline BOOL IsImageType(const GUID *pFormat)
{
    return (pFormat && 
               (IsEqualGUID(*pFormat, WiaImgFmt_JPEG) ||
                IsEqualGUID(*pFormat, WiaImgFmt_BMP) ||
                IsEqualGUID(*pFormat, WiaImgFmt_TIFF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_MEMORYBMP) ||
                IsEqualGUID(*pFormat, WiaImgFmt_EXIF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_FLASHPIX) ||
                IsEqualGUID(*pFormat, WiaImgFmt_JPEG2K) ||
                IsEqualGUID(*pFormat, WiaImgFmt_JPEG2KX) ||
                IsEqualGUID(*pFormat, WiaImgFmt_EMF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_WMF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_PNG) ||
                IsEqualGUID(*pFormat, WiaImgFmt_GIF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_PHOTOCD) ||
                IsEqualGUID(*pFormat, WiaImgFmt_ICO) ||
                IsEqualGUID(*pFormat, WiaImgFmt_CIFF) ||
                IsEqualGUID(*pFormat, WiaImgFmt_PICT)));
}

HRESULT FakeCamOpen(PTSTR ptszPortName, MCAM_DEVICE_INFO *pDeviceInfo);
HRESULT SearchDir(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, PTSTR ptszPath);
HRESULT SearchForAttachments(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, PTSTR ptszMainItem);
HRESULT CreateFolder(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppFolder, PTSTR ptszFullName);
HRESULT CreateImage(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppImage, PTSTR ptszFullName);
HRESULT CreateNonImage(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pParent, WIN32_FIND_DATA *pFindData, MCAM_ITEM_INFO **ppNonImage, PTSTR ptszFullName);
HRESULT SetCommonFields(MCAM_ITEM_INFO *pItem, PTSTR ptszShortName, PTSTR ptszFullName, WIN32_FIND_DATA *pFindData);

HRESULT AddItem(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pItem);
HRESULT RemoveItem(FAKECAM_DEVICE_INFO *pPrivateDeviceInfo, MCAM_ITEM_INFO *pItem);

//
// Helper function - generate full file name as "<Path>\<FileName>"
// cchFullNameSize - size of the buffer provided in ptszFullName. Function will return E_FAIL if
// the buffer is not big enough to accomodate full path and teminating zero character
//
inline HRESULT MakeFullName(PTSTR ptszFullName, UINT cchFullNameSize, PTSTR ptszPath, PTSTR ptszFileName)
{
    HRESULT hr = S_OK;
    if (_sntprintf(ptszFullName, cchFullNameSize, _T("%s\\%s"), ptszPath, ptszFileName) < 0)
    {
        hr = E_FAIL;
    }
    ptszFullName[cchFullNameSize - 1] = 0;
    return hr;
}

//
// Constants for reading Exif files
//
const WORD TIFF_XRESOLUTION =   0x11a;
const WORD TIFF_YRESOLUTION =   0x11b;
const WORD TIFF_JPEG_DATA =     0x201;
const WORD TIFF_JPEG_LEN =      0x202;

const int APP1_OFFSET = 6;      // Offset between the start of the APP1 segment and the start of the TIFF tags

//
// Structures for reading Exif files
//
typedef struct _DIR_ENTRY
{
    WORD    Tag;
    WORD    Type;
    DWORD   Count;
    DWORD   Offset;
} DIR_ENTRY, *PDIR_ENTRY;

typedef struct _IFD
{
    DWORD       Offset;
    WORD        Count;
    DIR_ENTRY  *pEntries;
    DWORD       NextIfdOffset;
} IFD, *PIFD;

//
// Functions for reading Exif files
//
HRESULT ReadDimFromJpeg(PTSTR ptszFullName, WORD *pWidth, WORD *pHeight);
HRESULT ReadJpegHdr(PTSTR ptszFileName, BYTE **ppBuf);
HRESULT ReadExifJpeg(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap);
HRESULT ReadTiff(BYTE *pBuf, IFD *pImageIfd, IFD *pThumbIfd, BOOL *pbSwap);
HRESULT ReadIfd(BYTE *pBuf, IFD *pIfd, BOOL bSwap);
VOID    FreeIfd(IFD *pIfd);
WORD    ByteSwapWord(WORD w);
DWORD   ByteSwapDword(DWORD dw);
WORD    GetWord(BYTE *pBuf, BOOL bSwap);
DWORD   GetDword(BYTE *pBuf, BOOL bSwap);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\iso15740\minidrv\utils.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module declares utilitiy functions

Author:

    William Hsieh (williamh) created

Revision History:


--*/

#ifndef UTILS__H_
#define UTILS__H_



WORD
ByteSwapWord(
            WORD w
            );


DWORD
ByteSwapDword(
             DWORD dw
             );

DWORD
GetDIBLineSize(
              DWORD   Width,
              DWORD   Bitsount
              );

DWORD
GetDIBSize(
          BITMAPINFO *pbmi
          );

DWORD
GetDIBBitsOffset(
                BITMAPINFO *pbmi
                );


HRESULT
WINAPI
GetTiffDimensions(
                 BYTE   *pTiff,
                 UINT  TiffSize,
                 UINT  *pWidth,
                 UINT  *pHeight,
                 UINT  *pBitDepth
                 );

HRESULT
WINAPI
Tiff2DIBBitmap(
              BYTE *pTiff,
              UINT TiffSize,
              BYTE  *pDIBBmp,
              UINT DIBBmpSize,
              UINT LineSize,
              UINT MaxLines
              );

HRESULT
WINAPI
GetJpegDimensions(
                 BYTE   *pJpeg,
                 UINT  JpegSize,
                 UINT  *pWidth,
                 UINT  *pHeight,
                 UINT  *pBitDepth
                 );

HRESULT
WINAPI
Jpeg2DIBBitmap(
              BYTE *pJpeg,
              UINT JpegSize,
              BYTE  *pDIBBmp,
              UINT DIBBmpSize,
              UINT LineSize,
              UINT MaxLines
              );

HRESULT
WINAPI
GetImageDimensions(
                   UINT ptpFormatCode,
                   BYTE *pCompressedData,
                   UINT CompressedSize,
                   UINT *pWidth,
                   UINT *pHeight,
                   UINT *pBitDepth
                  );

HRESULT
WINAPI
ConvertAnyImageToBmp(
                     BYTE *pImage,
                     UINT CompressedSize,
                     UINT *pWidth,
                     UINT *pHeight,
                     UINT *pBitDepth,
                     BYTE **pDIBBmp,
                     UINT *pImagesize,
                     UINT *pHeaderSize
                    );

void
WINAPI
UnInitializeGDIPlus(void);   


#endif // #ifndef UTILS__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\inc\wiacammc.h ===
/**************************************************************************** 
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        wiacammc.h
*
*  VERSION:     1.0
*
*  DATE:        12/16/2000
*
*  DESCRIPTION:
*    Header for WIA camera microdriver.
*
*****************************************************************************/

#pragma once

#define WIACAMMICRO_API __declspec(dllexport) HRESULT __stdcall

#include <pshpack8.h>

/****************************************************************************\
* Camera microdriver definitions
\****************************************************************************/

//
// GetItemData state bit masks
//
const UINT MCAM_STATE_NEXT   = 0x00;
const UINT MCAM_STATE_FIRST  = 0x01;
const UINT MCAM_STATE_LAST   = 0x02;
const UINT MCAM_STATE_CANCEL = 0x04;

//
// Item type definition
//
enum {
    WiaMCamTypeUndef,
    WiaMCamTypeFolder,
    WiaMCamTypeOther,
    WiaMCamTypeImage,
    WiaMCamTypeAudio,
    WiaMCamTypeVideo
};

enum {
    WiaMCamEventItemAdded,
    WiaMCamEventItemDeleted,
    WiaMCamEventPropChanged
};

//
// Other constants
//
const INT MCAM_VERSION = 100;
const INT MCAM_EXT_LEN = 4;

//
// Structures
//
typedef struct _MCAM_DEVICE_INFO {
    INT          iSize;                // Size of this structure
    INT          iMcamVersion;         // Microcamera architecture version
    BYTE        *pPrivateStorage;      // Pointer to an area where the microdriver can store it's own device information
    BOOL         bSyncNeeded;          // Should be set if the driver can get out-of-sync with the camera (i.e. for serial cameras)
    BOOL         bSlowConnection;      // Indicates that the driver should optimize for a slow connection (i.e. serial)
    BOOL         bExclusivePort;       // Indicates that the device should be opened/closed for every operation (i.e. serial)
    BOOL         bEventsSupported;     // Set if the driver supports events
    PWSTR        pwszFirmwareVer;      // String representing the firmware version of the device, set to NULL if unknown
    LONG         lPicturesTaken;       // Number of pictures stored on the camera
    LONG         lPicturesRemaining;   // Space available on the camera, in pictures at the current resolution
    LONG         lTotalItems;          // Total number of items on the camera, including folders, images, audio, etc.
    SYSTEMTIME   Time;                 // Current time on the device
    LONG         Reserved[8];          // Reserved for future use
} MCAM_DEVICE_INFO, *PMCAM_DEVICE_INFO;

typedef struct _MCAM_ITEM_INFO {
    INT          iSize;                // Size of this structure
    BYTE        *pPrivateStorage;      // Pointer to an area where the microdriver can store it's own item information
    IWiaDrvItem *pDrvItem;             // Pointer to the driver item created from this item--should not be used by microdriver

    struct _MCAM_ITEM_INFO *pParent;   // Pointer to this item's parent, equal to NULL if this is a top level item
    struct _MCAM_ITEM_INFO *pNext;     // Next item in the list
    struct _MCAM_ITEM_INFO *pPrev;     // Previous item in the list

    PWSTR        pwszName;             // Name of the item without the extension
    SYSTEMTIME   Time;                 // Last modified time of the item
    INT          iType;                // Type of the item (e.g. folder, image, etc.)
    const GUID  *pguidFormat;          // Format of the item
    const GUID  *pguidThumbFormat;     // Format of the thumbnail for the item
    LONG         lWidth;               // Width of the image in pixels, zero for non-images
    LONG         lHeight;              // Height of the image in pixels, zero for non-images
    LONG         lDepth;               // Pixel depth in pixels (e.g. 8, 16, 24)
    LONG         lChannels;            // Number of color channels per pixel (e.g. 1, 3)
    LONG         lBitsPerChannel;      // Number of bits per color channel, normally 8
    LONG         lSize;                // Size of the image in bytes
    LONG         lSequenceNum;         // If image is part of a sequence, the sequence number
    LONG         lThumbWidth;          // Width of thumbnail (can be set to zero until thumbnail is read by app)
    LONG         lThumbHeight;         // Height of thumbnail (can be set to zero until thumbnail is read by app)
    BOOL         bHasAttachments;      // Indicates whether an image has attachments
    BOOL         bReadOnly;            // Indicates if item can or cannot be deleted by app
    BOOL         bCanSetReadOnly;      // Indicates if the app can change the read-only status on and off
    WCHAR        wszExt[MCAM_EXT_LEN]; // Filename extension
    LONG         Reserved[8];          // Reserved for future use    
} MCAM_ITEM_INFO, *PMCAM_ITEM_INFO;

typedef struct _MCAM_PROP_INFO {
    INT          iSize;                // Size of this structure

    struct _MCAM_PROP_INFO *pNext;

    WIA_PROPERTY_INFO *pWiaPropInfo;

    LONG         Reserved[8];
} MCAM_PROP_INFO, *PMCAM_PROP_INFO;

typedef struct _MCAM_EVENT_INFO {
    INT          iSize;                // Size of this structure

    struct _MCAM_EVENT_INFO *pNext;

    INT          iType;                // Event type

    MCAM_ITEM_INFO *pItemInfo;
    MCAM_PROP_INFO *pPropInfo;

    LONG         Reserved[8];
} MCAM_EVENT_INFO, *PMCAM_EVENT_INFO;

//
// Interface to micro camera driver
//
WIACAMMICRO_API WiaMCamInit(MCAM_DEVICE_INFO **ppDeviceInfo);
WIACAMMICRO_API WiaMCamUnInit(MCAM_DEVICE_INFO *pDeviceInfo);
WIACAMMICRO_API WiaMCamOpen(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName);
WIACAMMICRO_API WiaMCamClose(MCAM_DEVICE_INFO *pDeviceInfo);
WIACAMMICRO_API WiaMCamGetDeviceInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList);
WIACAMMICRO_API WiaMCamReadEvent(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **ppEventList);
WIACAMMICRO_API WiaMCamStopEvents(MCAM_DEVICE_INFO *pDeviceInfo);
WIACAMMICRO_API WiaMCamGetItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
WIACAMMICRO_API WiaMCamFreeItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
WIACAMMICRO_API WiaMCamGetThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, INT *pThumbSize, BYTE **ppThumb);
WIACAMMICRO_API WiaMCamFreeThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, BYTE *pThumb);
WIACAMMICRO_API WiaMCamGetItemData(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, UINT uiState, BYTE *pBuf, DWORD dwLength);
WIACAMMICRO_API WiaMCamDeleteItem(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem);
WIACAMMICRO_API WiaMCamSetItemProt(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly);
WIACAMMICRO_API WiaMCamTakePicture(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemInfo);
WIACAMMICRO_API WiaMCamStatus(MCAM_DEVICE_INFO *pDeviceInfo);
WIACAMMICRO_API WiaMCamReset(MCAM_DEVICE_INFO *pDeviceInfo);

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\ccammicro.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        CCamMicro.h
*
*  VERSION:     1.0
*
*  DATE:        12/14/2000
*
*  DESCRIPTION:
*    Implements a simple class to wrap the microdriver DLL. This
*    class could instead call the SDK for a camera.
*
*****************************************************************************/

#pragma once

//
// Function pointer type definitions
//
typedef HRESULT (__stdcall *FPInit)(MCAM_DEVICE_INFO **ppDeviceInfo);
typedef HRESULT (__stdcall *FPUnInit)(MCAM_DEVICE_INFO *pDeviceInfo);
typedef HRESULT (__stdcall *FPOpen)(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName);
typedef HRESULT (__stdcall *FPClose)(MCAM_DEVICE_INFO *pDeviceInfo);
typedef HRESULT (__stdcall *FPGetDeviceInfo)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList);
typedef HRESULT (__stdcall *FPReadEvent)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **pEventList);
typedef HRESULT (__stdcall *FPStopEvents)(MCAM_DEVICE_INFO *pDeviceInfo);
typedef HRESULT (__stdcall *FPGetItemInfo)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
typedef HRESULT (__stdcall *FPFreeItemInfo)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
typedef HRESULT (__stdcall *FPGetThumbnail)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, INT *pThumbSize, BYTE **ppThumb);
typedef HRESULT (__stdcall *FPGetItemData)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, UINT uiState, BYTE *pBuf, DWORD dwLength);
typedef HRESULT (__stdcall *FPDeleteItem)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem);
typedef HRESULT (__stdcall *FPSetItemProt)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly);
typedef HRESULT (__stdcall *FPTakePicture)(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemInfo);
typedef HRESULT (__stdcall *FPStatus)(MCAM_DEVICE_INFO *pDeviceInfo);
typedef HRESULT (__stdcall *FPReset)(MCAM_DEVICE_INFO *pDeviceInfo);

//
// Wrapper class
//
class CCamMicro {
public:
    CCamMicro();
    ~CCamMicro();

    HRESULT Init(PTSTR ptszMicroDriverName, MCAM_DEVICE_INFO **ppDeviceInfo);
    HRESULT UnInit(MCAM_DEVICE_INFO *pDeviceInfo);
    HRESULT Open(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName);
    HRESULT Close(MCAM_DEVICE_INFO *pDeviceInfo);
    HRESULT GetDeviceInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList);
    HRESULT ReadEvent(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **ppEventList);
    HRESULT StopEvents(MCAM_DEVICE_INFO *pDeviceInfo);
    HRESULT GetItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
    HRESULT FreeItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
    HRESULT GetThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, INT *pThumbSize, BYTE **ppThumb);
    HRESULT GetItemData(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, UINT uiState, BYTE *pBuf, DWORD dwLength);
    HRESULT DeleteItem(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem);
    HRESULT SetItemProt(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly);
    HRESULT TakePicture(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemInfo);
    HRESULT Status(MCAM_DEVICE_INFO *pDeviceInfo);
    HRESULT Reset(MCAM_DEVICE_INFO *pDeviceInfo);

private:
    HMODULE         m_hModule;
    FPInit          m_pInit;
    FPUnInit        m_pUnInit;
    FPOpen          m_pOpen;
    FPClose         m_pClose;
    FPGetDeviceInfo m_pGetDeviceInfo;
    FPReadEvent     m_pReadEvent;
    FPStopEvents    m_pStopEvents;
    FPGetItemInfo   m_pGetItemInfo;
    FPFreeItemInfo  m_pFreeItemInfo;
    FPGetThumbnail  m_pGetThumbnail;
    FPGetItemData   m_pGetItemData;
    FPDeleteItem    m_pDeleteItem;
    FPSetItemProt   m_pSetItemProt;
    FPTakePicture   m_pTakePicture;
    FPStatus        m_pStatus;
    FPReset         m_pReset;


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\pch.h ===
#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <objbase.h>

#include <sti.h>
#include <stiusd.h>

#include <wiamindr.h>
#include <wiacammc.h>
#include <wiautil.h>

#include "resource.h"
#include "CCamMicro.h"
#include "wiacam.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample camera IWiaMiniDrv methods. This file
*   contains 3 sections. The first is the WIA minidriver entry points, all
*   starting with "drv". The next section is public help methods. The last
*   section is private helper methods.
*
*******************************************************************************/

#include "pch.h"

#ifndef INITGUID
#include <initguid.h>
#endif

//
// A few extra format GUIDs
//
DEFINE_GUID(GUID_NULL, 0,0,0,0,0,0,0,0,0,0,0);
DEFINE_GUID(FMT_NOTHING, 0x81a566e7,0x8620,0x4fba,0xbc,0x8e,0xb2,0x7c,0x17,0xad,0x9e,0xfd);

/**************************************************************************\
* CWiaCameraDevice::drvInitializeWia
*
*   Initialize the WIA mini driver. This function will be called each time an
*   application creates a device. The first time through, the driver item tree
*   will be created and other initialization will be done.
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvInitializeWia(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    BSTR                        bstrDeviceID,
    BSTR                        bstrRootFullItemName,
    IUnknown                    *pStiDevice,
    IUnknown                    *pIUnknownOuter,
    IWiaDrvItem                 **ppIDrvItemRoot,
    IUnknown                    **ppIUnknownInner,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvInitializeWia");
    
    if (!ppIUnknownInner || !pIUnknownOuter)
    {
        // optional arguments, may be NULLs
    }

    if (!pWiasContext || !bstrDeviceID || !bstrRootFullItemName || 
        !pStiDevice || !ppIDrvItemRoot || !plDevErrVal)
    {
        wiauDbgError("drvInitializeWia", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    //
    // Locals
    //
    MCAM_ITEM_INFO *pItem = NULL;

    wiauDbgTrace("drvInitializeWia", "device ID: %S", bstrDeviceID);

    *ppIDrvItemRoot = NULL;
    if (ppIUnknownInner)
    {
        *ppIUnknownInner = NULL;
    }

    //
    // Count the number of apps connected so that resources can be
    // freed when it reaches zero
    //
    m_iConnectedApps++;;

    wiauDbgTrace("drvInitializeWia", "Number of connected apps is now %d", m_iConnectedApps);

    if (m_iConnectedApps == 1)
    {
        //
        // Save STI device interface for calling locking functions
        //
        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID
        //
        m_bstrDeviceID = SysAllocString(bstrDeviceID);
        REQUIRE_ALLOC(m_bstrDeviceID, hr, "drvInitializeWia");

        //
        // Cache the root item name
        //
        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);
        REQUIRE_ALLOC(m_bstrRootFullItemName, hr, "drvInitializeWia");

        //
        // For devices connected to ports that can be shared (e.g. USB),
        // open the device and initialize access to the camera
        //
        if (!m_pDeviceInfo->bExclusivePort) {
            hr = m_pDevice->Open(m_pDeviceInfo, m_wszPortName);
            REQUIRE_SUCCESS(hr, "Initialize", "Open failed");
        }

        //
        // Get information from the device
        //
        hr = m_pDevice->GetDeviceInfo(m_pDeviceInfo, &pItem);
        REQUIRE_SUCCESS(hr, "drvInitializeWia", "GetDeviceInfo failed");
        
        //
        // Build the capabilities array
        //
        hr = BuildCapabilities();
        REQUIRE_SUCCESS(hr, "drvInitializeWia", "BuildCapabilities failed");

        //
        //  Build the device item tree
        //
        hr = BuildItemTree(pItem);
        REQUIRE_SUCCESS(hr, "drvInitializeWia", "BuildItemTree failed");

    }

    *ppIDrvItemRoot = m_pRootItem;

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvUnInitializeWia(BYTE *pWiasContext)
{
    DBG_FN("CWiaCameraDevice::drvUnInitializeWia");

    if (!pWiasContext)
    {
        wiauDbgError("drvUnInitializeWia", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    m_iConnectedApps--;

    if (m_iConnectedApps == 0)
    {
        hr = FreeResources();
        if (FAILED(hr))
            wiauDbgErrorHr(hr, "drvUnInitializeWia", "FreeResources failed, continuing...");

        //
        // Do not delete the device object here, because GetStatus may still be called later.
        //
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvInitItemProperties
*
*   Initialize the device item properties. Called during item
*   initialization.  This is called by the WIA Class driver
*   after the item tree has been built.  It is called once for every
*   item in the tree. For the root item, just set the properties already
*   set up in drvInitializeWia. For child items, access the camera for
*   information about the item and for images also get the thumbnail.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvInitItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvInitItemProperties");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvInitItemProperties", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    LONG lItemType;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    REQUIRE_SUCCESS(hr, "drvInitItemProperties", "wiasGetItemType failed");

    if (lItemType & WiaItemTypeRoot) {

        //
        // Build root item properties, initializing global
        // structures with their default and valid values
        //
        hr = BuildRootItemProperties(pWiasContext);
        REQUIRE_SUCCESS(hr, "drvInitItemProperties", "BuildRootItemProperties failed");
    }

    else {

        //
        // Build child item properties, initializing global
        // structures with their default and valid values
        //
        hr = BuildChildItemProperties(pWiasContext);
        REQUIRE_SUCCESS(hr, "drvInitItemProperties", "BuildChildItemProperties failed");
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvLockWiaDevice");

    if (!plDevErrVal)
    {
        wiauDbgError("drvLockWiaDevice", "invalid arguments");
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    return m_pStiDevice->LockDevice(100);
}

/**************************************************************************\
* CWiaCameraDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvUnLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvUnLockWiaDevice");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvUnLockWiaDevice", "invalid arguments");
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWiaCameraDevice::drvFreeDrvItemContext
*
*   Free any device specific context.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvFreeDrvItemContext(
    LONG                        lFlags,
    BYTE                        *pSpecContext,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvFreeDrvItemContext");

    if (!pSpecContext || !plDevErrVal)
    {
        wiauDbgError("drvFreeDrvItemContext", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    ITEM_CONTEXT *pItemCtx = (ITEM_CONTEXT *) pSpecContext;
    
    if (pItemCtx)
    {
        if (pItemCtx->pItemInfo) {
            hr = m_pDevice->FreeItemInfo(m_pDeviceInfo, pItemCtx->pItemInfo);
            if (FAILED(hr))
                wiauDbgErrorHr(hr, "drvFreeDrvItemContext", "FreeItemInfo failed");
        }
        pItemCtx->pItemInfo = NULL;

        if (pItemCtx->pFormatInfo)
        {
            delete []pItemCtx->pFormatInfo;
            pItemCtx->pFormatInfo = NULL;
        }
        pItemCtx->lNumFormatInfo = 0;
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvReadItemProperties
*
*   Read the device item properties.  When a client application tries to
*   read a WIA Item's properties, the WIA Class driver will first notify
*   the driver by calling this method.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvReadItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvReadItemProperties");

    if (!pWiasContext || !pPropSpec || !plDevErrVal)
    {
        wiauDbgError("drvReadItemProperties", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    LONG lItemType;
    hr = wiasGetItemType(pWiasContext, &lItemType);
    REQUIRE_SUCCESS(hr, "drvReadItemProperties", "wiasGetItemType failed");

    if (lItemType & WiaItemTypeRoot) {

        //
        // Build root item properties, initializing global
        // structures with their default and valid values
        //
        hr = ReadRootItemProperties(pWiasContext, nPropSpec, pPropSpec);
        REQUIRE_SUCCESS(hr, "drvReadItemProperties", "ReadRootItemProperties failed");
    }
    
    else {

        //
        // Build child item properties, initializing global
        // structures with their default and valid values
        //
        hr = ReadChildItemProperties(pWiasContext, nPropSpec, pPropSpec);
        REQUIRE_SUCCESS(hr, "drvReadItemProperties", "ReadChildItemProperties failed");
    }
    
Cleanup:    
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.  This is called by the
*   WIA Class driver prior to drvAcquireItemData when the client requests
*   a data transfer.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvWriteItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvWriteItemProperties");

    if (!pWiasContext || !pmdtc || !plDevErrVal)
    {
        wiauDbgError("drvWriteItemProperties", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    // This function doesn't need to do anything, because all of the camera
    // properties are written in drvValidateItemProperties
    //

    *plDevErrVal = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvAcquireItemData
*
*   Transfer data from a mini driver item to device manger.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   pmdtc           - Pointer to mini driver context. On entry, only the
*                     portion of the mini driver context which is derived
*                     from the item properties is filled in.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvAcquireItemData");
    
    if (!pWiasContext || !plDevErrVal || !pmdtc)
    {
        wiauDbgError("drvAcquireItemData", "invalid arguments");  
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;
    
    //
    // Locals
    //
    BYTE *pTempBuf = NULL;
    LONG lBufSize = 0;
    ITEM_CONTEXT *pItemCtx = NULL;
    BOOL bConvert = FALSE;

    //
    // Get item context
    //
    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx);
    REQUIRE_SUCCESS(hr, "drvAcquireItemData", "wiauGetDrvItemContext failed");

    //
    // If the format requested is BMP or DIB, and the image is not already in BMP
    // format, convert it
    //
    bConvert = (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP) ||
                IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) &&
               !IsEqualGUID(*(pItemCtx->pItemInfo->pguidFormat), WiaImgFmt_BMP);

    //
    // If the class driver did not allocate the transfer buffer or the image is being
    // converted to DIB or BMP, allocate a temporary buffer.
    //
    if (bConvert || !pmdtc->bClassDrvAllocBuf) {
        lBufSize = pItemCtx->pItemInfo->lSize;
        pTempBuf = new BYTE[lBufSize];
        REQUIRE_ALLOC(pTempBuf, hr, "drvAcquireItemData");
    }

    //
    // Acquire the data from the device
    //
    hr = AcquireData(pItemCtx, pmdtc, pTempBuf, lBufSize, bConvert);
    REQUIRE_SUCCESS(hr, "drvAcquireItemData", "AcquireData failed");
    if (hr == S_FALSE)
    {
        wiauDbgWarning("drvAcquireItemData", "Transfer cancelled");
        goto Cleanup;
    }

    //
    // Now convert the data to BMP, if necessary
    //
    if (bConvert)
    {
        hr = Convert(pWiasContext, pItemCtx, pmdtc, pTempBuf, lBufSize);
        REQUIRE_SUCCESS(hr, "drvAcquireItemData", "Convert failed");
    }

Cleanup:
    if (pTempBuf)
    {
        delete []pTempBuf;
        pTempBuf = NULL;
        lBufSize = 0;
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetWiaFormatInfo
*
*   Returns an array of WIA_FORMAT_INFO structs, which specify the format
*   and media type pairs that are supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvGetWiaFormatInfo");
    
    if (!pWiasContext || !pcelt || !ppwfi || !plDevErrVal)
    {
        wiauDbgError("drvGetWiaFormatInfo", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    //
    // Locals
    //
    IWiaDrvItem *pWiaDrvItem = NULL;
    ITEM_CONTEXT *pItemCtx = NULL;
    const GUID *pguidFormat = NULL;
    BOOL bAddBmp = FALSE;

    *pcelt = 0;
    *ppwfi = NULL;
    
    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx, &pWiaDrvItem);
    REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiauGetDrvItemContext failed");
    
    if (!pItemCtx->pFormatInfo)
    {
        //
        // The format info list is not intialized. Do it now.
        //
        LONG ItemType;
        DWORD ui32;
        
        hr = wiasGetItemType(pWiasContext, &ItemType);
        REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiasGetItemType");

        if ((ItemType & WiaItemTypeFolder) ||
            (ItemType & WiaItemTypeRoot))
        {
            //
            // Folders and the root don't really need format info, but some apps may fail
            // without it. Create a fake list just in case.
            //
            pItemCtx->pFormatInfo = new WIA_FORMAT_INFO[2];
            REQUIRE_ALLOC(pItemCtx->pFormatInfo, hr, "drvGetWiaFormatInfo");

            pItemCtx->lNumFormatInfo = 2;
            pItemCtx->pFormatInfo[0].lTymed = TYMED_FILE;
            pItemCtx->pFormatInfo[0].guidFormatID = FMT_NOTHING;
            pItemCtx->pFormatInfo[1].lTymed = TYMED_CALLBACK;
            pItemCtx->pFormatInfo[1].guidFormatID = FMT_NOTHING;
        }
        
        else if (ItemType & WiaItemTypeFile)
        {
            //
            // Create the supported format for the item, based on the format stored in the
            // ObjectInfo structure.
            //
            if (!pItemCtx->pItemInfo)
            {
                wiauDbgError("drvGetWiaFormatInfo", "Item info pointer in context is null");
                hr = E_FAIL;
                goto Cleanup;
            }

            pguidFormat = pItemCtx->pItemInfo->pguidFormat;

            //
            // If the format of the item is supported by the converter utility, add the
            // BMP types to the format array, since this driver can convert those to BMP
            //
            bAddBmp = m_Converter.IsFormatSupported(pguidFormat);

            ULONG NumWfi = bAddBmp ? 2 : 1;

            //
            // Allocate two entries for each format, one for file transfer and one for callback
            //
            WIA_FORMAT_INFO *pwfi = new WIA_FORMAT_INFO[2 * NumWfi];
            REQUIRE_ALLOC(pwfi, hr, "drvGetWiaFormatInfo");

            pwfi[0].guidFormatID = *pguidFormat;
            pwfi[0].lTymed = TYMED_FILE;
            pwfi[1].guidFormatID = *pguidFormat;
            pwfi[1].lTymed = TYMED_CALLBACK;

            //
            // Add the BMP entries when appropriate
            //
            if (bAddBmp)
            {
                pwfi[2].guidFormatID = WiaImgFmt_BMP;
                pwfi[2].lTymed = TYMED_FILE;
                pwfi[3].guidFormatID = WiaImgFmt_MEMORYBMP;
                pwfi[3].lTymed = TYMED_CALLBACK;
            }

            pItemCtx->lNumFormatInfo = 2 * NumWfi;
            pItemCtx->pFormatInfo = pwfi;
        }
    }

    *pcelt = pItemCtx->lNumFormatInfo;
    *ppwfi = pItemCtx->pFormatInfo;

Cleanup:    
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvValidateItemProperties
*
*   Validate the device item properties.  It is called when changes are made
*   to an item's properties.  Driver should not only check that the values
*   are valid, but must update any valid values that may change as a result.
*   If an a property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   nPropSpec       - The number of properties that are being written
*   pPropSpec       - An array of PropSpecs identifying the properties that
*                     are being written.
*   plDevErrVal     - Pointer to the device error value.
*
***************************************************************************/

HRESULT CWiaCameraDevice::drvValidateItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvValidateItemProperties");

    if (!pWiasContext || !pPropSpec || !plDevErrVal)
    {
        wiauDbgError("drvValidateItemProperties", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    //
    // Locals
    //
    LONG lItemType  = 0;
    ITEM_CONTEXT *pItemCtx = NULL;
    MCAM_ITEM_INFO *pItemInfo = NULL;
    BOOL bFormatUpdated = FALSE;
    LONG lRights = 0;
    BOOL bReadOnly = 0;

    //
    // Have the service validate against the valid values for each property
    //
    hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
    REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "wiasValidateItemProperties failed");

    //
    // Get the item type
    //
    hr = wiasGetItemType(pWiasContext, &lItemType);
    REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "wiasGetItemType");

    //
    // Validate root item properties
    //
    if (lItemType & WiaItemTypeRoot) {

        //
        // None yet
        //
    }
    
    //
    // Validate child item properties
    //
    else {

        //
        // Get the driver item context and item info pointer
        //
        hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx);
        REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiauGetDrvItemContext failed");

        pItemInfo = pItemCtx->pItemInfo;

        //
        // See if access rights were changed
        //
        if (wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_ACCESS_RIGHTS))
        {
            hr = wiasReadPropLong(pWiasContext, WIA_IPA_ACCESS_RIGHTS, &lRights, NULL, TRUE);
            REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "wiasReadPropLong failed");

            bReadOnly = (lRights == WIA_ITEM_READ);
            hr = m_pDevice->SetItemProt(m_pDeviceInfo, pItemInfo, bReadOnly);
            REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "SetItemProt failed");
            pItemInfo->bReadOnly = bReadOnly;
        }

        //
        // If tymed property was changed, update format and item size
        //
        if (wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_TYMED)) {

            //
            // Create a property context needed by some WIA Service
            // functions used below.
            //
            WIA_PROPERTY_CONTEXT Context;
            hr = wiasCreatePropContext(nPropSpec, (PROPSPEC*)pPropSpec, 0,
                                       NULL, &Context);
            REQUIRE_SUCCESS(hr, "drvValidateItemProperties", "wiasCreatePropContext failed");

            //
            // Use the WIA Service to update the valid values
            // for format. It will pull the values from the
            // structure returned by drvGetWiaFormatInfo, using the
            // new value for tymed.
            //
            hr = wiasUpdateValidFormat(pWiasContext, &Context, (IWiaMiniDrv*) this);
            REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiasUpdateValidFormat failed");

            //
            // Free the property context
            //
            hr = wiasFreePropContext(&Context);
            REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiasFreePropContext failed");

            //
            // The format may have changed, so update the properties
            // dependent on format
            //
            bFormatUpdated = TRUE;
        }

        //
        // If the format was changed, just update the item size
        //
        if (bFormatUpdated || wiauPropInPropSpec(nPropSpec, pPropSpec, WIA_IPA_FORMAT))
        {
            //
            //  Update the affected item properties
            //
            hr = wiauSetImageItemSize(pWiasContext, pItemInfo->lWidth, pItemInfo->lHeight,
                                      pItemInfo->lDepth, pItemInfo->lSize, pItemInfo->wszExt);
            REQUIRE_SUCCESS(hr, "drvGetWiaFormatInfo", "wiauSetImageItemSize failed");
        }
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvDeleteItem
*
*   Delete an item from the device.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvDeleteItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvDeleteItem");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvDeleteItem", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    //
    // Locals
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    IWiaDrvItem *pDrvItem = NULL;
    BSTR bstrFullName = NULL;

    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx, &pDrvItem);
    REQUIRE_SUCCESS(hr, "drvDeleteItem", "wiauGetDrvItemContext failed");
    
    hr = m_pDevice->DeleteItem(m_pDeviceInfo, pItemCtx->pItemInfo);
    REQUIRE_SUCCESS(hr, "drvDeleteItem", "DeleteItem failed");

    //
    // Get the item's full name
    //
    hr = pDrvItem->GetFullItemName(&bstrFullName);
    REQUIRE_SUCCESS(hr, "drvDeleteItem", "GetFullItemName failed");

    //
    // Queue an "item deleted" event
    //
    hr = wiasQueueEvent(m_bstrDeviceID, &WIA_EVENT_ITEM_DELETED, bstrFullName);
    REQUIRE_SUCCESS(hr, "drvDeleteItem", "wiasQueueEvent failed");

Cleanup:
    if (bstrFullName)
        SysFreeString(bstrFullName);

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvNotifyPnpEvent
*
*   Pnp Event received by device manager.  This is called when a Pnp event
*   is received for this device.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvNotifyPnpEvent(
    const GUID                  *pEventGUID,
    BSTR                        bstrDeviceID,
    ULONG                       ulReserved)
{
    DBG_FN("CWiaCameraDevice::DrvNotifyPnpEvent");
    if (!pEventGUID)
    {
        wiauDbgError("drvNotifyPnpEvent", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetCapabilities
*
*   Get supported device commands and events as an array of WIA_DEV_CAPS.
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned GUID array.
*   ppCapabilities - Pointer to returned GUID array.
*   plDevErrVal    - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetCapabilities(
    BYTE                        *pWiasContext,
    LONG                        ulFlags,
    LONG                        *pcelt,
    WIA_DEV_CAP_DRV             **ppCapabilities,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvGetCapabilites");

    if (!pWiasContext)
    {
        //
        // The WIA service may pass in a NULL for the pWiasContext. This is expected
        // because there is a case where no item was created at the time the event was fired.
        //
    }

    if (!pcelt || !ppCapabilities || !plDevErrVal)
    {
        wiauDbgError("drvGetCapabilities", "invalid arguments");
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    //
    //  Return values depend on the passed flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    if (ulFlags & (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS)) {

        //
        //  Return both events and commands
        //
        *pcelt          = m_lNumCapabilities;
        *ppCapabilities = m_pCapabilities;
    }
    else if (ulFlags & WIA_DEVICE_COMMANDS) {

        //
        //  Return commands only
        //
        *pcelt          = m_lNumSupportedCommands;
        *ppCapabilities = &m_pCapabilities[m_lNumSupportedEvents];
    }
    else if (ulFlags & WIA_DEVICE_EVENTS) {

        //
        //  Return events only
        //
        *pcelt          = m_lNumSupportedEvents;
        *ppCapabilities = m_pCapabilities;
    }

    return S_OK;
}

/**************************************************************************\
* CWiaCameraDevice::drvDeviceCommand
*
*   Issue a command to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   plCommand       - Pointer to command GUID.
*   ppWiaDrvItem    - Optional pointer to returned item, unused.
*   plDevErrVal     - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvDeviceCommand(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    const GUID                  *plCommand,
    IWiaDrvItem                 **ppWiaDrvItem,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvDeviceCommand");

    if (!pWiasContext || !plCommand || !ppWiaDrvItem || !plDevErrVal)
    {
        wiauDbgError("drvDeviceCommand", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    //
    // Locals
    //
    MCAM_ITEM_INFO *pItem = NULL;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        //
        // SYNCHRONIZE - Re-build the item tree, if the device needs it.
        //
        if (m_pDeviceInfo->bSyncNeeded)
        {
            hr = m_pDevice->StopEvents(m_pDeviceInfo);
            REQUIRE_SUCCESS(hr, "drvDeviceCommand", "StopEvents failed");

            hr = DeleteItemTree(WiaItemTypeDisconnected);
            REQUIRE_SUCCESS(hr, "drvDeviceCommand", "DeleteItemTree failed");

            hr = m_pDevice->GetDeviceInfo(m_pDeviceInfo, &pItem);
            REQUIRE_SUCCESS(hr, "drvDeviceCommand", "GetDeviceInfo failed");

            hr = BuildItemTree(pItem);
            REQUIRE_SUCCESS(hr, "drvDeviceCommand", "BuildItemTree failed");
        }
    }
    
#if DEADCODE
    
    //
    // Not implemented yet
    //
    else if (*plCommand == WIA_CMD_TAKE_PICTURE) {

        //
        // TAKE_PICTURE - Command the camera to capture a new image.
        //
        hr = m_pDevice->TakePicture(&pItem);
        REQUIRE_SUCCESS(hr, "drvDeviceCommand", "TakePicture failed");

        hr = AddObject(pItem);
        REQUIRE_SUCCESS(hr, "drvDeviceCommand", "AddObject failed");

        hr = LinkToParent(pItem);
        REQUIRE_SUCCESS(hr, "drvDeviceCommand", "LinkToParent failed");
    }
#endif
    
    else {
        wiauDbgWarning("drvDeviceCommand", "Unknown command 0x%08x", *plCommand);
        hr = E_NOTIMPL;
        goto Cleanup;
    }

Cleanup:    
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::drvAnalyzeItem
*
*   This device does not support image analysis, so return E_NOTIMPL.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvAnalyzeItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    DBG_FN("CWiaCameraDevice::drvAnalyzeItem");

    if (!pWiasContext || !plDevErrVal)
    {
        wiauDbgError("drvAnalyzeItem", "invalid arguments");
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    return E_NOTIMPL;
}

/**************************************************************************\
* CWiaCameraDevice::drvGetDeviceErrorStr
*
*   Map a device error value to a string.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
\**************************************************************************/

HRESULT CWiaCameraDevice::drvGetDeviceErrorStr(
    LONG                        lFlags,
    LONG                        lDevErrVal,
    LPOLESTR                    *ppszDevErrStr,
    LONG                        *plDevErr)
{
    DBG_FN("CWiaCameraDevice::drvGetDeviceErrorStr");

    if (!ppszDevErrStr || !plDevErr)
    {
        wiauDbgError("drvGetDeviceErrorStr", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    *plDevErr  = 0;

    //
    //  Map device errors to a string appropriate for showing to the user
    //

    switch (lDevErrVal) {
        case 0:
            *ppszDevErrStr = NULL;
            break;

        default:
            *ppszDevErrStr = NULL;
            hr = E_FAIL;
    }

    return hr;
}

/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* FreeResources
*
*   Cleans up all of the resources held by the driver.
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::FreeResources()
{
    DBG_FN("CWiaCameraDevice::FreeResources");

    HRESULT hr = S_OK;

    wiauDbgTrace("FreeResources", "Connected apps is now zero, freeing resources...");

    hr = m_pDevice->StopEvents(m_pDeviceInfo);
    if (FAILED(hr))
        wiauDbgErrorHr(hr, "FreeResources", "StopEvents failed");

    // Destroy the driver item tree
    hr = DeleteItemTree(WiaItemTypeDisconnected);
    if (FAILED(hr))
        wiauDbgErrorHr(hr, "FreeResources", "UnlinkItemTree failed");

    // Delete allocated arrays
    DeleteCapabilitiesArrayContents();

    //
    // For devices connected to ports that can be shared (e.g. USB),
    // close the device
    //
    if (m_pDeviceInfo && !m_pDeviceInfo->bExclusivePort) {
        hr = m_pDevice->Close(m_pDeviceInfo);
        if (FAILED(hr))
            wiauDbgErrorHr(hr, "FreeResources", "Close failed");
    }

    // Free the storage for the device ID
    if (m_bstrDeviceID) {
        SysFreeString(m_bstrDeviceID);
        m_bstrDeviceID = NULL;
    }

    // Free the storage for the root item name
    if (m_bstrRootFullItemName) {
        SysFreeString(m_bstrRootFullItemName);
        m_bstrRootFullItemName = NULL;
    }

/*
    // Kill notification thread if it exists.
    SetNotificationHandle(NULL);

    // Close event for syncronization of notifications shutdown.
    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }


    //
    // WIA member destruction
    //

    // Cleanup the WIA event sink.
    if (m_pIWiaEventCallback) {
        m_pIWiaEventCallback->Release();
        m_pIWiaEventCallback = NULL;
    }

*/

    return hr;
}

/**************************************************************************\
* DeleteItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::DeleteItemTree(LONG lReason)
{
    DBG_FN("CWiaCameraDevice::DeleteItemTree");

    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pRootItem)
        goto Cleanup;

    //
    //  Call device manager to unlink the driver item tree.
    //
    hr = m_pRootItem->UnlinkItemTree(lReason);
    REQUIRE_SUCCESS(hr, "DeleteItemTree", "UnlinkItemTree failed");

    m_pRootItem->Release();
    m_pRootItem = NULL;

Cleanup:
    return hr;
}

/**************************************************************************\
* BuildItemTree
*
*   The device uses the WIA Service functions to build up a tree of
*   device items.
*
* Arguments:
*
*
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::BuildItemTree(MCAM_ITEM_INFO *pItem)
{
    DBG_FN("CWiaCameraDevice::BuildItemTree");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    BSTR bstrRoot = NULL;
    ITEM_CONTEXT *pItemCtx = NULL;
    MCAM_ITEM_INFO *pCurItem = NULL;

    //
    // Make sure the item tree doesn't already exist
    //
    if (m_pRootItem)
    {
        wiauDbgError("BuildItemTree", "Item tree already exists");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Create the root item name
    //
    bstrRoot = SysAllocString(L"Root");
    REQUIRE_ALLOC(bstrRoot, hr, "BuildItemTree");

    //
    //  Create the root item
    //
    hr = wiasCreateDrvItem(WiaItemTypeFolder | WiaItemTypeDevice | WiaItemTypeRoot,
                           bstrRoot,
                           m_bstrRootFullItemName,
                           (IWiaMiniDrv *)this,
                           sizeof(ITEM_CONTEXT),
                           (BYTE **) &pItemCtx,
                           &m_pRootItem);
    REQUIRE_SUCCESS(hr, "BuildItemTree", "wiasCreateDrvItem failed");

    //
    // Initialize item context fields for the root
    //
    memset(pItemCtx, 0, sizeof(ITEM_CONTEXT));

    //
    // Create a driver item for each item on the camera
    //
    pCurItem = pItem;
    while (pCurItem) {

        hr = AddObject(pCurItem);
        REQUIRE_SUCCESS(hr, "BuildItemTree", "AddObject failed");

        pCurItem = pCurItem->pNext;
    }

    //
    // Link each item to its parent
    //
    pCurItem = pItem;
    while (pCurItem) {

        hr = LinkToParent(pCurItem);
        REQUIRE_SUCCESS(hr, "BuildItemTree", "LinkToParent failed");

        pCurItem = pCurItem->pNext;
    }

Cleanup:
    if (bstrRoot)
        SysFreeString(bstrRoot);

    return hr;
}

/**************************************************************************\
* AddObject
*
*   Helper function to add an item to the driver item tree
*
* Arguments:
*
*    pItemInfo - Pointer to the item info structure
*
\**************************************************************************/

HRESULT CWiaCameraDevice::AddObject(MCAM_ITEM_INFO *pItemInfo)
{
    DBG_FN("CWiaCameraDevice::AddObject");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    LONG lItemType = 0;
    BSTR bstrItemFullName = NULL;
    BSTR bstrItemName = NULL;
    WCHAR wszTemp[MAX_PATH];
    IWiaDrvItem *pItem = NULL;
    ITEM_CONTEXT *pItemCtx = NULL;

    REQUIRE_ARGS(!pItemInfo, hr, "AddObject");

    //
    // Create the item's full name
    //
    hr = ConstructFullName(pItemInfo, wszTemp, sizeof(wszTemp) / sizeof(wszTemp[0]));
    REQUIRE_SUCCESS(hr, "AddObject", "ConstructFullName failed");

    wiauDbgTrace("AddObject", "Adding item %S", wszTemp);

    bstrItemFullName = SysAllocString(wszTemp);
    REQUIRE_ALLOC(bstrItemFullName, hr, "AddObject");

    bstrItemName = SysAllocString(pItemInfo->pwszName);
    REQUIRE_ALLOC(bstrItemName, hr, "AddObject");

    //
    // Make sure there is no filename extension in the name
    //
    if (wcschr(bstrItemFullName, L'.'))
    {
        wiauDbgError("AddObject", "Item names must not contain filename extensions");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Set the item's type
    //
    switch (pItemInfo->iType) {
    case WiaMCamTypeFolder:
        lItemType = ITEMTYPE_FOLDER;
        break;
    case WiaMCamTypeImage:
        lItemType = ITEMTYPE_IMAGE;
        break;
    case WiaMCamTypeAudio:
        lItemType = ITEMTYPE_AUDIO;
        break;
    case WiaMCamTypeVideo:
        lItemType = ITEMTYPE_VIDEO;
        break;
    default:
        lItemType = ITEMTYPE_FILE;
        break;
    }

    //
    // See if the item has attachments
    //
    if (pItemInfo->bHasAttachments)
        lItemType |= WiaItemTypeHasAttachments;

    //
    // Create the driver item
    //
    hr = wiasCreateDrvItem(lItemType,
                           bstrItemName,
                           bstrItemFullName,
                           (IWiaMiniDrv *)this,
                           sizeof(ITEM_CONTEXT),
                           (BYTE **) &pItemCtx,
                           &pItem);

    REQUIRE_SUCCESS(hr, "AddObject", "wiasCreateDrvItem failed");

    //
    // Fill in the driver item context. Wait until the thumbnail is requested before
    // reading it in.
    //
    memset(pItemCtx, 0, sizeof(ITEM_CONTEXT));
    pItemCtx->pItemInfo = pItemInfo;

    //
    // Put a pointer to the driver item in the item info structure
    //
    pItemInfo->pDrvItem = pItem;

Cleanup:
    if (bstrItemFullName)
        SysFreeString(bstrItemFullName);

    if (bstrItemName)
        SysFreeString(bstrItemName);

    return hr;
}

/**************************************************************************\
* ConstructFullName
*
*   Helper function for creating the item's full name
*
* Arguments:
*
*    pItemInfo       - Pointer to the item info structure
*    pwszFullName    - Pointer to area to construct name
*    cchFullNameSize - size (in characters) of buffer provided in pwszFullName 
*
\**************************************************************************/

HRESULT CWiaCameraDevice::ConstructFullName(MCAM_ITEM_INFO *pItemInfo, 
                                            WCHAR *pwszFullName, 
                                            INT cchFullNameSize)
{
    DBG_FN("CWiaCameraDevice::ConstructFullName");
    HRESULT hr = S_OK;

    if (!pItemInfo) 
    {
        wiauDbgError("ConstructFullName", "pItemInfo arg is NULL");
        return E_INVALIDARG;
    }

    if (pItemInfo->pParent) 
    {
        hr = ConstructFullName(pItemInfo->pParent, pwszFullName, cchFullNameSize);
    }
    else 
    {
        if (lstrlenW(m_bstrRootFullItemName) < cchFullNameSize)
        {
            lstrcpyW(pwszFullName, m_bstrRootFullItemName);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr) && pItemInfo->pwszName) 
    {
        //
        // Verify that buffer is big enough to accommodate both strings + "\" + terminating zero
        //
        if (lstrlenW(pwszFullName) + lstrlenW(pItemInfo->pwszName) + 2 <= cchFullNameSize)
        {
            lstrcatW(pwszFullName, L"\\");
            lstrcatW(pwszFullName, pItemInfo->pwszName);
        }
        else
        {
            hr = E_FAIL; // buffer is not big enough
        }
    }

    return hr;
}

/**************************************************************************\
* LinkToParent
*
*   Helper function to link an item to its parent in the item tree
*
* Arguments:
*
*    pItemInfo   - Pointer to the item info structure
*    bQueueEvent - Indicates whether to queue an WIA event
*
\**************************************************************************/

HRESULT CWiaCameraDevice::LinkToParent(MCAM_ITEM_INFO *pItemInfo, BOOL bQueueEvent)
{
    DBG_FN("CWiaCameraDevice::LinkToParent");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    IWiaDrvItem *pParentDrvItem = NULL;
    IWiaDrvItem *pItem = NULL;
    BSTR bstrItemFullName = NULL;

    REQUIRE_ARGS(!pItemInfo, hr, "LinkToParent");

    //
    // Retrieve the driver item and make sure it's not null
    //
    pItem = pItemInfo->pDrvItem;
    if (!pItem) {
        wiauDbgError("LinkToParent", "Driver item pointer is null");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Find the item's parent driver item object
    //
    if (pItemInfo->pParent) {
        pParentDrvItem = pItemInfo->pParent->pDrvItem;
    }
    else {
        //
        // If the parent pointer is null, use the root as the parent
        //
        pParentDrvItem = m_pRootItem;
    }

    //
    // The driver item should exist for the parent, but just make sure
    //
    if (!pParentDrvItem) {
        wiauDbgError("LinkToParent", "Parent driver item is null");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Place the item under it's parent
    //
    hr = pItem->AddItemToFolder(pParentDrvItem);
    REQUIRE_SUCCESS(hr, "LinkToParent", "AddItemToFolder failed");

    //
    // The minidriver doesn't need the driver item pointer any more, so release it.
    // The service will still keep a reference until the item is deleted.
    //
    pItem->Release();

    //
    // Post an item added event, if requested
    //
    if (bQueueEvent)
    {
        hr = pItem->GetFullItemName(&bstrItemFullName);
        REQUIRE_SUCCESS(hr, "LinkToParent", "GetFullItemName failed");
        
        hr = wiasQueueEvent(m_bstrDeviceID, &WIA_EVENT_ITEM_CREATED, bstrItemFullName);
        REQUIRE_SUCCESS(hr, "LinkToParent", "wiasQueueEvent failed");
    }

Cleanup:
    if (bstrItemFullName)
        SysFreeString(bstrItemFullName);

    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string with CoTaskMemFree)
*
* Return Value:
*
*    Status
*
\**************************************************************************/
HRESULT CWiaCameraDevice::GetOLESTRResourceString(LONG lResourceID, LPOLESTR *ppsz)
{
    DBG_FN("GetOLESTRResourceString");
    if (!ppsz)
    {
        return E_INVALIDARG;
    }
    
    HRESULT hr = S_OK;
    TCHAR tszStringValue[255];

    if (LoadString(g_hInst, lResourceID, tszStringValue, 255) == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

#ifdef UNICODE
    //
    // just allocate memory and copy string
    //
    *ppsz = NULL;
    *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(tszStringValue));
    if (*ppsz != NULL) 
    {
        wcscpy(*ppsz, tszStringValue);
    } 
    else 
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#else
    WCHAR wszStringValue[255];

    //
    // convert szStringValue from char* to unsigned short* (ANSI only)
    //
    if (!MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             tszStringValue,
                             lstrlenA(tszStringValue)+1,
                             wszStringValue,
                             (sizeof(wszStringValue)/sizeof(wszStringValue[0]))))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }

    *ppsz = NULL;
    *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
    if (*ppsz != NULL) 
    {
        wcscpy(*ppsz,wszStringValue);
    } 
    else 
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
#endif

Cleanup:
    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
\**************************************************************************/

HRESULT CWiaCameraDevice::BuildCapabilities()
{
    DBG_FN("BuildCapabilities");
    
    HRESULT hr = S_OK;

    if (m_pCapabilities != NULL) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_lNumSupportedCommands  = 1;
    m_lNumSupportedEvents    = 3;
    m_lNumCapabilities       = (m_lNumSupportedCommands + m_lNumSupportedEvents);


    m_pCapabilities = new WIA_DEV_CAP_DRV[m_lNumCapabilities];
    REQUIRE_ALLOC(m_pCapabilities, hr, "BuildCapabilities");

    //
    // Initialize EVENTS
    //

    //
    // WIA_EVENT_DEVICE_CONNECTED
    //
    hr = GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME, &m_pCapabilities[0].wszName);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    hr = GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC, &m_pCapabilities[0].wszDescription);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    m_pCapabilities[0].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
    m_pCapabilities[0].ulFlags        = WIA_NOTIFICATION_EVENT;
    m_pCapabilities[0].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

    //
    // WIA_EVENT_DEVICE_DISCONNECTED
    //
    hr = GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME, &m_pCapabilities[1].wszName);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    hr = GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC, &m_pCapabilities[1].wszDescription);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    m_pCapabilities[1].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
    m_pCapabilities[1].ulFlags        = WIA_NOTIFICATION_EVENT;
    m_pCapabilities[1].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

    //
    // WIA_EVENT_ITEM_DELETED
    //
    hr = GetOLESTRResourceString(IDS_EVENT_ITEM_DELETED_NAME, &m_pCapabilities[2].wszName);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    hr = GetOLESTRResourceString(IDS_EVENT_ITEM_DELETED_DESC, &m_pCapabilities[2].wszDescription);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    m_pCapabilities[2].guid           = (GUID*)&WIA_EVENT_ITEM_DELETED;
    m_pCapabilities[2].ulFlags        = WIA_NOTIFICATION_EVENT;
    m_pCapabilities[2].wszIcon        = WIA_ICON_ITEM_DELETED;

    //
    // Initialize COMMANDS
    //

    //
    // WIA_CMD_SYNCHRONIZE
    //
    hr = GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME, &m_pCapabilities[3].wszName);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    hr = GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC, &m_pCapabilities[3].wszDescription);
    REQUIRE_SUCCESS(hr, "BuildCapabilities", "GetOLESTRResourceString failed");

    m_pCapabilities[3].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
    m_pCapabilities[3].ulFlags        = 0;
    m_pCapabilities[3].wszIcon        = WIA_ICON_SYNCHRONIZE;

Cleanup:
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
\**************************************************************************/

HRESULT CWiaCameraDevice::DeleteCapabilitiesArrayContents()
{
    DBG_FN("DeleteCapabilitiesArrayContents");
    
    HRESULT hr = S_OK;

    if (m_pCapabilities) {
        for (LONG i = 0; i < m_lNumCapabilities; i++) 
        {
            CoTaskMemFree(m_pCapabilities[i].wszName);
            CoTaskMemFree(m_pCapabilities[i].wszDescription);
        }

        delete []m_pCapabilities;
        m_pCapabilities = NULL;
    }

    m_lNumSupportedCommands = 0;
    m_lNumSupportedEvents = 0;
    m_lNumCapabilities = 0;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\ccammicro.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  TITLE:       CCamMicro.cpp
*
*  VERSION:     1.0
*
*  DATE:        Dec 13, 2000
*
*  DESCRIPTION:
*   Implementation of a simple class that wraps a camera microdriver DLL.
*   This class loads the DLL and retrieves the address for the exported
*   functions.
*
*******************************************************************************/

#include "pch.h"

//
// These macros make it easier to wrap the DLL functions
//
#define GET_PROC_ADDRESS(fn) \
    m_p ## fn = (FP ## fn) GetProcAddress(m_hModule, "WiaMCam" #fn); \
    REQUIRE_FILEIO(m_p ## fn != NULL, hr, "Init", "GetProcAddress failed on WiaMCam" #fn);


#define CALL_DLL_FUNCTION(fn, parm) \
    HRESULT hr = S_OK; \
    if (m_p ## fn) { \
        hr = m_p ## fn ## parm; \
    } \
    else { \
        wiauDbgError("CCamMicro::" #fn, "m_p" #fn " not initialized"); \
        hr = E_FAIL; \
    } \
    return hr;

//
// Implementation of DLL wrapper
//
CCamMicro::CCamMicro() :
    m_hModule(NULL),
    m_pInit(NULL),
    m_pUnInit(NULL),
    m_pOpen(NULL),
    m_pClose(NULL),        
    m_pGetDeviceInfo(NULL),  
    m_pReadEvent(NULL),   
    m_pStopEvents(NULL),   
    m_pGetItemInfo(NULL), 
    m_pFreeItemInfo(NULL), 
    m_pGetThumbnail(NULL), 
    m_pGetItemData(NULL),  
    m_pDeleteItem(NULL),   
    m_pSetItemProt(NULL),   
    m_pTakePicture(NULL),  
    m_pStatus(NULL),       
    m_pReset(NULL)
{
}

CCamMicro::~CCamMicro()
{
    if (m_hModule != NULL) {
        FreeLibrary(m_hModule);
    }
}

HRESULT CCamMicro::Init(PTSTR ptszMicroDriverName, MCAM_DEVICE_INFO **ppDeviceInfo)
{
    DBG_FN("CCamMicro::CCamMicro");

    HRESULT hr = S_OK;

    //
    // Load the camera microdriver
    //
    m_hModule = LoadLibrary(ptszMicroDriverName);
    REQUIRE_FILEHANDLE(m_hModule, hr, "CCamMicro::CCamMicro", "LoadLibrary failed");

    GET_PROC_ADDRESS(Init);
    GET_PROC_ADDRESS(UnInit);
    GET_PROC_ADDRESS(Open);
    GET_PROC_ADDRESS(Close);
    GET_PROC_ADDRESS(GetDeviceInfo);
    GET_PROC_ADDRESS(ReadEvent);
    GET_PROC_ADDRESS(StopEvents);
    GET_PROC_ADDRESS(GetItemInfo);
    GET_PROC_ADDRESS(FreeItemInfo);
    GET_PROC_ADDRESS(GetThumbnail);
    GET_PROC_ADDRESS(GetItemData);
    GET_PROC_ADDRESS(DeleteItem);
    GET_PROC_ADDRESS(SetItemProt);
    GET_PROC_ADDRESS(TakePicture);
    GET_PROC_ADDRESS(Status);
    GET_PROC_ADDRESS(Reset);

    if (m_pInit) {
        hr = m_pInit(ppDeviceInfo);
    }
    else {
        wiauDbgError("CCamMicro::Init", "m_pInit not initialized");
        hr = E_FAIL;
    }

Cleanup:
    return hr;
}

HRESULT CCamMicro::UnInit(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(UnInit, (pDeviceInfo));
}

HRESULT CCamMicro::Open(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName)
{
    CALL_DLL_FUNCTION(Open, (pDeviceInfo, pwszPortName));
}

HRESULT CCamMicro::Close(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(Close, (pDeviceInfo));
}

HRESULT CCamMicro::GetDeviceInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList)
{
    CALL_DLL_FUNCTION(GetDeviceInfo, (pDeviceInfo, ppItemList));
}

HRESULT CCamMicro::ReadEvent(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **ppEventList)
{
    CALL_DLL_FUNCTION(ReadEvent, (pDeviceInfo, ppEventList));
}

HRESULT CCamMicro::StopEvents(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(StopEvents, (pDeviceInfo));
}

HRESULT CCamMicro::GetItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo)
{
    CALL_DLL_FUNCTION(GetItemInfo, (pDeviceInfo, pItemInfo));
}

HRESULT CCamMicro::FreeItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo)
{
    CALL_DLL_FUNCTION(FreeItemInfo, (pDeviceInfo, pItemInfo));
}

HRESULT CCamMicro::GetThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, INT *pThumbSize, BYTE **ppThumb)
{
    CALL_DLL_FUNCTION(GetThumbnail, (pDeviceInfo, pItem, pThumbSize, ppThumb));
}

HRESULT CCamMicro::GetItemData(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, UINT uiState, BYTE *pBuf, DWORD dwLength)
{
    CALL_DLL_FUNCTION(GetItemData, (pDeviceInfo, pItem, uiState, pBuf, dwLength));
}

HRESULT CCamMicro::DeleteItem(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem)
{
    CALL_DLL_FUNCTION(DeleteItem, (pDeviceInfo, pItem));
}

HRESULT CCamMicro::SetItemProt(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly)
{
    CALL_DLL_FUNCTION(SetItemProt, (pDeviceInfo, pItem, bReadOnly));
}

HRESULT CCamMicro::TakePicture(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemInfo)
{
    CALL_DLL_FUNCTION(TakePicture, (pDeviceInfo, ppItemInfo));
}

HRESULT CCamMicro::Status(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(Status, (pDeviceInfo));
}

HRESULT CCamMicro::Reset(MCAM_DEVICE_INFO *pDeviceInfo)
{
    CALL_DLL_FUNCTION(Reset, (pDeviceInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\child.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  TITLE:       Child.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   This file implements the helper methods for IWiaMiniDrv for child items.
*
*******************************************************************************/

#include "pch.h"


/**************************************************************************\
* BuildChildItemProperties
*
*   This helper creates the properties for a child item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT CWiaCameraDevice::BuildChildItemProperties(
    BYTE *pWiasContext
    )
{
    DBG_FN("CWiaCameraDevice::BuildChildItemProperties");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    MCAM_ITEM_INFO *pItemInfo = NULL;
    CWiauPropertyList ItemProps;
    const INT NUM_ITEM_PROPS = 20;  // Make sure this number is large
                                    // enough to hold all child properties
    INT index = 0;
    LONG lAccessRights = 0;
    BOOL bBitmap = FALSE;
    LONG pTymedArray[] = { TYMED_FILE, TYMED_CALLBACK };
    int iNumFormats = 0;
    GUID *pguidFormatArray = NULL;
    BSTR bstrExtension = NULL;
    LONG lMinBufSize = 0;

    //
    // Get the driver item context
    //
    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "GetDrvItemContext failed");

    pItemInfo = pItemCtx->pItemInfo;

    //
    // Call the microdriver to fill in information about the item
    //
    hr = m_pDevice->GetItemInfo(m_pDeviceInfo, pItemInfo);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "GetItemInfo failed");

    //
    // Set up properties that are used for all item types
    //
    hr = ItemProps.Init(NUM_ITEM_PROPS);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "Init property list failed");

    //
    // WIA_IPA_ITEM_TIME
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_TIME, WIA_IPA_ITEM_TIME_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");

    ItemProps.SetCurrentValue(index, &pItemInfo->Time);

    //
    // WIA_IPA_ACCESS_RIGHTS
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_FLAG);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");

    //
    // If device supports changing the read-only status, item access rights is r/w
    //
    lAccessRights = pItemInfo->bReadOnly ? WIA_ITEM_READ : WIA_ITEM_RD;

    if (pItemInfo->bCanSetReadOnly)
    {
        ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_FLAG);
        ItemProps.SetValidValues(index, lAccessRights, lAccessRights, WIA_ITEM_RD);
    }
    else
    {
        ItemProps.SetCurrentValue(index, lAccessRights);
    }

    if (pItemInfo->iType == WiaMCamTypeUndef) {
        wiauDbgWarning("BuildChildItemProperties", "Item's type is undefined");
    }
    
    //
    // Set up non-folder properties
    //
    else if (pItemInfo->iType != WiaMCamTypeFolder) {
    
        //
        // WIA_IPA_PREFERRED_FORMAT
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PREFERRED_FORMAT, WIA_IPA_PREFERRED_FORMAT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
        ItemProps.SetCurrentValue(index, (GUID *) pItemInfo->pguidFormat);

        bBitmap = IsEqualGUID(WiaImgFmt_BMP, *pItemInfo->pguidFormat);

        //
        // WIA_IPA_TYMED
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_TYMED, WIA_IPA_TYMED_STR,
                                      WIA_PROP_RW, WIA_PROP_LIST);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
        ItemProps.SetValidValues(index, TYMED_FILE, TYMED_FILE,
                                 sizeof(pTymedArray) / sizeof(pTymedArray[0]), pTymedArray);

        //
        // WIA_IPA_FORMAT
        //
        // First call drvGetWiaFormatInfo to get the valid formats
        //
        hr = wiauGetValidFormats(this, pWiasContext, TYMED_FILE, &iNumFormats, &pguidFormatArray);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "wiauGetValidFormats failed");

        if (iNumFormats == 0)
        {
            wiauDbgError("BuildChildItemProperties", "wiauGetValidFormats returned zero formats");
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = ItemProps.DefineProperty(&index, WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR,
                                      WIA_PROP_RW, WIA_PROP_LIST);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
        ItemProps.SetValidValues(index, (GUID *) pItemInfo->pguidFormat, (GUID *) pItemInfo->pguidFormat,
                                 iNumFormats, &pguidFormatArray);

        //
        // WIA_IPA_FILENAME_EXTENSION
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_FILENAME_EXTENSION, WIA_IPA_FILENAME_EXTENSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");

        bstrExtension = SysAllocString(pItemInfo->wszExt);
        REQUIRE_ALLOC(bstrExtension, hr, "BuildChildItemProperties");

        ItemProps.SetCurrentValue(index, bstrExtension);

        //
        // WIA_IPA_ITEM_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_SIZE, WIA_IPA_ITEM_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");

        ItemProps.SetCurrentValue(index, pItemInfo->lSize);

        //
        // WIA_IPA_MIN_BUFFER_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_MIN_BUFFER_SIZE, WIA_IPA_MIN_BUFFER_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");


        if (!bBitmap && pItemInfo->lSize > 0)
            lMinBufSize = min(MIN_BUFFER_SIZE, pItemInfo->lSize);
        else
            lMinBufSize = MIN_BUFFER_SIZE;
        ItemProps.SetCurrentValue(index, lMinBufSize);

        //
        // Set up the image-only properties
        //
        if (pItemInfo->iType == WiaMCamTypeImage)
        {
            //
            // WIA_IPA_DATATYPE
            //
            // This property is mainly used by scanners. Set to color since most camera
            // images will be color.
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_DATATYPE, WIA_IPA_DATATYPE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, (LONG) WIA_DATA_COLOR);
    
            //
            // WIA_IPA_DEPTH
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_DEPTH, WIA_IPA_DEPTH_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lDepth);
            
            //
            // WIA_IPA_CHANNELS_PER_PIXEL
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_CHANNELS_PER_PIXEL, WIA_IPA_CHANNELS_PER_PIXEL_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lChannels);
    
            //
            // WIA_IPA_BITS_PER_CHANNEL
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_BITS_PER_CHANNEL, WIA_IPA_BITS_PER_CHANNEL_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lBitsPerChannel);
    
            //
            // WIA_IPA_PLANAR
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_PLANAR, WIA_IPA_PLANAR_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, (LONG) WIA_PACKED_PIXEL);
    
            //
            // WIA_IPA_PIXELS_PER_LINE
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_PIXELS_PER_LINE, WIA_IPA_PIXELS_PER_LINE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lWidth);
    
            //
            // WIA_IPA_BYTES_PER_LINE
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_BYTES_PER_LINE, WIA_IPA_BYTES_PER_LINE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
    
            if (bBitmap)
                ItemProps.SetCurrentValue(index, ((pItemInfo->lWidth * pItemInfo->lDepth + 31) & ~31) / 8);
            else
                ItemProps.SetCurrentValue(index, (LONG) 0);
    
            //
            // WIA_IPA_NUMBER_OF_LINES
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_NUMBER_OF_LINES, WIA_IPA_NUMBER_OF_LINES_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lHeight);
    
            //
            // WIA_IPC_THUMBNAIL
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, (BYTE *) NULL, 0);
    
            //
            // WIA_IPC_THUMB_WIDTH
            //
            // This field is probably zero until the thumbnail is read in, but set it anyway
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lThumbWidth);
    
            //
            // WIA_IPC_THUMB_HEIGHT
            //
            // This field is probably zero until the thumbnail is read in, but set it anyway
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, pItemInfo->lThumbHeight);
    
            //
            // WIA_IPC_SEQUENCE
            //
            if (pItemInfo->lSequenceNum > 0)
            {
                hr = ItemProps.DefineProperty(&index, WIA_IPC_SEQUENCE, WIA_IPC_SEQUENCE_STR,
                                              WIA_PROP_READ, WIA_PROP_NONE);
                REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
                ItemProps.SetCurrentValue(index, pItemInfo->lSequenceNum);
            }
            
            //
            // WIA_IPA_COMPRESSION
            //
            // This property is mainly used by scanners. Set to no compression.
            //
            hr = ItemProps.DefineProperty(&index, WIA_IPA_COMPRESSION, WIA_IPA_COMPRESSION_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "DefineProperty failed");
            ItemProps.SetCurrentValue(index, (LONG) WIA_COMPRESSION_NONE);
        }
    }

    //
    // Last step: send all the properties to WIA
    //
    hr = ItemProps.SendToWia(pWiasContext);
    REQUIRE_SUCCESS(hr, "BuildChildItemProperties", "SendToWia failed");

Cleanup:
    if (pguidFormatArray)
        delete []pguidFormatArray;
    if (bstrExtension)
        SysFreeString(bstrExtension);

    return hr;
}


/**************************************************************************\
* ReadChildItemProperties
*
*   Update the properties for the child items.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT CWiaCameraDevice::ReadChildItemProperties(
    BYTE *pWiasContext,
    LONG lNumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    DBG_FN("CWiaCameraDevice::ReadChildItemProperties");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    ITEM_CONTEXT *pItemCtx = NULL;
    MCAM_ITEM_INFO *pItemInfo = NULL;
    LONG lAccessRights = 0;
    LONG lThumbWidth = 0;
    INT iNativeThumbSize = 0;
    BYTE *pbNativeThumb = NULL;
    INT iConvertedThumbSize = 0;
    BYTE *pbConvertedThumb = NULL;
    BMP_IMAGE_INFO BmpImageInfo;

    REQUIRE_ARGS(!lNumPropSpecs || !pPropSpecs, hr, "ReadChildItemProperties");

    //
    // Get the driver item context
    //
    hr = wiauGetDrvItemContext(pWiasContext, (VOID **) &pItemCtx);
    REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiauGetDrvItemContext failed");

    pItemInfo = pItemCtx->pItemInfo;

    //
    // See if the item time is being read
    //
    if (wiauPropInPropSpec(lNumPropSpecs, pPropSpecs, WIA_IPA_ITEM_TIME))
    {
        PROPVARIANT propVar;
        PROPSPEC    propSpec;
        propVar.vt = VT_VECTOR | VT_UI2;
        propVar.caui.cElems = sizeof(SYSTEMTIME) / sizeof(WORD);
        propVar.caui.pElems = (WORD *) &pItemInfo->Time;
        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPA_ITEM_TIME;
        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar);
        REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiasWriteMultiple failed");
    }

    //
    // See if the access rights are being read
    //
    if (wiauPropInPropSpec(lNumPropSpecs, pPropSpecs, WIA_IPA_ACCESS_RIGHTS))
    {
        lAccessRights = pItemInfo->bReadOnly ? WIA_ITEM_READ : WIA_ITEM_RD;
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_ACCESS_RIGHTS, lAccessRights);
        REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiasWritePropLong failed");
    }

    //
    // For images, update the thumbnail properties if requested
    //
    if (pItemInfo->iType == WiaMCamTypeImage)
    {
        //
        // Get the thumbnail if requested to update any of the thumbnail properties and
        // the thumbnail is not already cached.
        //
        PROPID propsToUpdate[] = {
            WIA_IPC_THUMB_WIDTH,
            WIA_IPC_THUMB_HEIGHT,
            WIA_IPC_THUMBNAIL
            };

        if (wiauPropsInPropSpec(lNumPropSpecs, pPropSpecs, sizeof(propsToUpdate) / sizeof(PROPID), propsToUpdate))
        {
            //
            // See if the thumbnail has already been read
            //
            wiasReadPropLong(pWiasContext, WIA_IPC_THUMB_WIDTH, &lThumbWidth, NULL, TRUE);
            REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiasReadPropLong for thumbnail width failed");

            //
            // Get the thumbnail from the camera in it's native format
            //
            hr = m_pDevice->GetThumbnail(m_pDeviceInfo, pItemInfo, &iNativeThumbSize, &pbNativeThumb);
            REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "GetThumbnail failed");
            
            //
            // If the format isn't supported by GDI+, return an error
            //
            if (!m_Converter.IsFormatSupported(pItemInfo->pguidThumbFormat)) {
                wiauDbgError("ReadChildItemProperties", "Thumb format not supported");
                hr = E_FAIL;
                goto Cleanup;
            }

            //
            // Call the WIA driver helper to convert to BMP
            //
            hr = m_Converter.ConvertToBmp(pbNativeThumb, iNativeThumbSize,
                                          &pbConvertedThumb, &iConvertedThumbSize,
                                          &BmpImageInfo, SKIP_BOTHHDR);
            REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "ConvertToBmp failed");

            //
            // Fill in the thumbnail information based on the information returned from the helper
            //
            pItemInfo->lThumbWidth = BmpImageInfo.Width;
            pItemInfo->lThumbHeight = BmpImageInfo.Height;
            
            //
            // Update the related thumbnail properties. Update the thumb width and height in case
            // the device didn't report them in the ObjectInfo structure (they are optional there).
            //
            PROPSPEC propSpecs[3];
            PROPVARIANT propVars[3];
            
            propSpecs[0].ulKind = PRSPEC_PROPID;
            propSpecs[0].propid = WIA_IPC_THUMB_WIDTH;
            propVars[0].vt = VT_I4;
            propVars[0].lVal = pItemInfo->lThumbWidth;
            
            propSpecs[1].ulKind = PRSPEC_PROPID;
            propSpecs[1].propid = WIA_IPC_THUMB_HEIGHT;
            propVars[1].vt = VT_I4;
            propVars[1].lVal = pItemInfo->lThumbHeight;
            
            propSpecs[2].ulKind = PRSPEC_PROPID;
            propSpecs[2].propid = WIA_IPC_THUMBNAIL;
            propVars[2].vt = VT_VECTOR | VT_UI1;
            propVars[2].caub.cElems = iConvertedThumbSize;
            propVars[2].caub.pElems = pbConvertedThumb;

            hr = wiasWriteMultiple(pWiasContext, 3, propSpecs, propVars);
            REQUIRE_SUCCESS(hr, "ReadChildItemProperties", "wiasWriteMultiple failed");
        }
    }

Cleanup:
    if (pbNativeThumb) {
        delete []pbNativeThumb;
        pbNativeThumb = NULL;
    }

    if (pbConvertedThumb) {
        delete []pbConvertedThumb;
        pbConvertedThumb = NULL;
    }
    
    return hr;
}


/**************************************************************************\
* AcquireData
*
*   Transfers native data from the device.
*
* Arguments:
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::AcquireData(
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    BYTE *pBuf,
    LONG lBufSize,
    BOOL bConverting
    )
{
    DBG_FN("CWiaCameraDevice::AcquireData");
    
    HRESULT hr = S_OK;

    BYTE *pCur = NULL;
    UINT uiState = MCAM_STATE_FIRST;
    LONG lPercentComplete = 0;
    LONG lTotalToRead = pItemCtx->pItemInfo->lSize;
    LONG lOffset = 0;
    DWORD dwBytesToRead = 0;
    BOOL bFileTransfer = pmdtc->tymed & TYMED_FILE;
    LONG lMessage = 0;
    LONG lStatus = 0;

    //
    // If pBuf is non-null use that as the buffer, otherwise use the buffer
    // and size in pmdtc
    //
    if (pBuf)
    {
        pCur = pBuf;
        dwBytesToRead = lBufSize;
    }
    else
    {
        pCur = pmdtc->pTransferBuffer;
        dwBytesToRead = pmdtc->lBufferSize;
    }

    //
    // If the transfer size is the entire item, split it into approximately
    // 10 equal transfers in order to show progress to the app, but don't
    // make it smaller than 1k
    //
    if ((dwBytesToRead == (DWORD) lTotalToRead) &&
        (dwBytesToRead > 1024))
    {
        dwBytesToRead = (lTotalToRead / 10 + 3) & ~0x3;
    }

    //
    // Set up parameters for the callback function
    //
    if (bConverting)
    {
        lMessage = IT_MSG_STATUS;
        lStatus = IT_STATUS_TRANSFER_FROM_DEVICE;
    }
    else if (bFileTransfer)
    {
        lMessage = IT_MSG_STATUS;
        lStatus = IT_STATUS_TRANSFER_TO_CLIENT;
    }
    else  // e.g. memory transfer
    {
        lMessage = IT_MSG_DATA;
        lStatus = IT_STATUS_TRANSFER_TO_CLIENT;
    }

    //
    // Read data until finished
    //
    while (lOffset < lTotalToRead)
    {
        //
        // If this is the last read, adjust the amount of data to read
        // and the state
        //
        if (dwBytesToRead >= (DWORD) (lTotalToRead - lOffset))
        {
            dwBytesToRead = (lTotalToRead - lOffset);
            uiState |= MCAM_STATE_LAST;
        }
        
        //
        // Get the data from the camera
        //
        hr = m_pDevice->GetItemData(m_pDeviceInfo, pItemCtx->pItemInfo, uiState, pCur, dwBytesToRead);
        REQUIRE_SUCCESS(hr, "AcquireData", "GetItemData failed");

        //
        // Calculate the percent complete for the callback function. If converting,
        // report the percent complete as TRANSFER_PERCENT of the actual. From
        // TRANSFER_PERCENT to 100% will be reported during format conversion.
        //
        if (bConverting)
            lPercentComplete = (lOffset + dwBytesToRead) * TRANSFER_PERCENT / lTotalToRead;
        else
            lPercentComplete = (lOffset + dwBytesToRead) * 100 / lTotalToRead;


        //
        // Call the callback function to send status and/or data to the app
        //
        hr = pmdtc->pIWiaMiniDrvCallBack->
            MiniDrvCallback(lMessage, lStatus, lPercentComplete,
                            lOffset, dwBytesToRead, pmdtc, 0);
        REQUIRE_SUCCESS(hr, "AcquireData", "MiniDrvCallback failed");

        if (hr == S_FALSE)
        {
            //
            // Transfer is being cancelled by the app
            //
            wiauDbgWarning("AcquireData", "transfer cancelled");
            goto Cleanup;
        }

        //
        // Increment buffer pointer only if converting or this is a
        // file transfer
        //
        if (bConverting || bFileTransfer)
        {
            pCur += dwBytesToRead;
        }

        //
        // For a memory transfer not using a buffer allocated by the minidriver,
        // update the buffer pointer and size from the transfer context in case
        // of double buffering
        //
        else if (!pBuf)
        {
            pCur = pmdtc->pTransferBuffer;
            dwBytesToRead = pmdtc->lBufferSize;
        }
        
        //
        // Adjust variables for the next iteration
        //
        lOffset += dwBytesToRead;
        uiState &= ~MCAM_STATE_FIRST;
    }

    //
    // For file transfers, write the data to file
    //
    if (!pBuf && bFileTransfer)
    {
        //
        // Call WIA to write the data to the file
        //
        hr = wiasWriteBufToFile(0, pmdtc);
        REQUIRE_SUCCESS(hr, "AcquireData", "wiasWriteBufToFile failed");
    }

Cleanup:
    //
    // If the transfer wasn't completed, send cancel to the device
    //
    if (!(uiState & MCAM_STATE_LAST))
    {
        wiauDbgTrace("AcquireData", "Prematurely stopping transfer");

        uiState = MCAM_STATE_CANCEL;
        hr = m_pDevice->GetItemData(m_pDeviceInfo, pItemCtx->pItemInfo, uiState, NULL, 0);
        if (FAILED(hr))
            wiauDbgErrorHr(hr, "AcquireData", "GetItemData last failed");
    }

    return hr;
}


/**************************************************************************\
* Convert
*
*   Translates native data to BMP and sends the data to the app.
*
* Arguments:
*
*
\**************************************************************************/

HRESULT CWiaCameraDevice::Convert(
    BYTE *pWiasContext,
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    BYTE *pNativeImage,
    LONG lNativeSize
    )
{
    DBG_FN("CWiaCameraDevice::Convert");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    LONG  lMsg = 0;                 // Parameter to the callback function
    LONG  lPercentComplete = 0;     // Parameter to the callback function
    BOOL  bUseAppBuffer = FALSE;    // Indicates whether to transfer directly into the app's buffer
    BYTE *pBmpBuffer = NULL;        // Buffer used to hold converted image
    INT   iBmpBufferSize = 0;       // Size of the converted image buffer
    LONG  lBytesToCopy = 0;
    LONG  lOffset = 0;
    BYTE *pCurrent = NULL;
    BMP_IMAGE_INFO BmpImageInfo;
    SKIP_AMOUNT iSkipAmt = SKIP_OFF;

    //
    // Check arguments
    //
    REQUIRE_ARGS(!pNativeImage, hr, "Convert");
    
    //
    // The msg to send to the app via the callback depends on whether
    // this is a file or callback transfer
    //
    lMsg = ((pmdtc->tymed & TYMED_FILE) ? IT_MSG_STATUS : IT_MSG_DATA);

    //
    // If the class driver allocated a buffer and the buffer is large
    // enough, convert directly into that buffer. Otherwise, pass NULL
    // to the ConvertToBmp function so that it will allocate a buffer.
    //
    if (pmdtc->bClassDrvAllocBuf &&
        pmdtc->lBufferSize >= pmdtc->lItemSize) {

        bUseAppBuffer = TRUE;
        pBmpBuffer = pmdtc->pTransferBuffer;
        iBmpBufferSize = pmdtc->lBufferSize;
    }

    //
    // Convert the image to BMP. Skip the BMP file header if the app asked
    // for a "memory bitmap" (aka DIB).
    //
    memset(&BmpImageInfo, 0, sizeof(BmpImageInfo));
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        iSkipAmt = SKIP_FILEHDR;
    }
    hr = m_Converter.ConvertToBmp(pNativeImage, lNativeSize, &pBmpBuffer,
                                  &iBmpBufferSize, &BmpImageInfo, iSkipAmt);
    REQUIRE_SUCCESS(hr, "Convert", "ConvertToBmp failed");

    //
    // Send the data to the app. If the class driver allocated the buffer,
    // but it was too small, send the data back one chunk at a time.
    // Otherwise send all the data back at once.
    //
    if (pmdtc->bClassDrvAllocBuf &&
        pmdtc->lBufferSize < BmpImageInfo.Size) {

        pCurrent = pBmpBuffer;

        while (lOffset < BmpImageInfo.Size)
        {
            lBytesToCopy = BmpImageInfo.Size - lOffset;
            if (lBytesToCopy > pmdtc->lBufferSize) {

                lBytesToCopy = pmdtc->lBufferSize;

                //
                // Calculate how much of the data has been sent back so far. Report percentages to
                // the app between TRANSFER_PERCENT and 100 percent. Make sure it is never larger
                // than 99 until the end.
                //
                lPercentComplete = TRANSFER_PERCENT + ((100 - TRANSFER_PERCENT) * lOffset) / pmdtc->lItemSize;
                if (lPercentComplete > 99) {
                    lPercentComplete = 99;
                }
            }

            //
            // This will complete the transfer, so set the percentage to 100
            else {
                lPercentComplete = 100;
            }

            memcpy(pmdtc->pTransferBuffer, pCurrent, lBytesToCopy);
            
            //
            // Call the application's callback transfer to report status and/or transfer data
            //
            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                                                              lPercentComplete, lOffset, lBytesToCopy, pmdtc, 0);
            REQUIRE_SUCCESS(hr, "Convert", "MiniDrvCallback failed");
            if (hr == S_FALSE)
            {
                wiauDbgWarning("Convert", "transfer cancelled");
                hr = S_FALSE;
                goto Cleanup;
            }

            pCurrent += lBytesToCopy;
            lOffset += lBytesToCopy;
        }
    }

    else
    {
        //
        // Send the data to the app in one big chunk
        //
        pmdtc->pTransferBuffer = pBmpBuffer;
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100, 0, BmpImageInfo.Size, pmdtc, 0);
        REQUIRE_SUCCESS(hr, "Convert", "MiniDrvCallback failed");
    }
    
Cleanup:
    if (!bUseAppBuffer) {
        if (pBmpBuffer) {
            delete []pBmpBuffer;
            pBmpBuffer = NULL;
            iBmpBufferSize = 0;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\fakecam\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiacam.rc
//

// Device Events, and Commands (Name strings)
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_CMD_SYNCRONIZE_NAME            104
#define IDS_CMD_DELETE_ALL_ITEMS_NAME      105
#define IDS_CMD_DELETE_DEVICE_TREE_NAME    106
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     107

// Device Events, and Commands (Description strings)
#define IDS_EVENT_DEVICE_CONNECTED_DESC    108
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 109
#define IDS_CMD_SYNCRONIZE_DESC            110
#define IDS_CMD_DELETE_ALL_ITEMS_DESC      111
#define IDS_CMD_DELETE_DEVICE_TREE_DESC    112
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     113

#define IDS_FULLROOTITEM_NAME              114
#define IDS_ROOTITEM_NAME                  115
#define IDS_FULLTOPITEM_NAME               116
#define IDS_TOPITEM_NAME                   117

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        118
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           118
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample camera IStiUSD methods.
*
*******************************************************************************/

#include "pch.h"

/**************************************************************************\
* CWiaCameraDevice::CWiaCameraDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDevice::CWiaCameraDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_punkOuter(NULL),
    
    m_pIStiDevControl(NULL),
    m_pStiDevice(NULL),
    m_dwLastOperationError(0),
    
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pRootItem(NULL),

    m_lNumSupportedCommands(0),
    m_lNumSupportedEvents(0),
    m_lNumCapabilities(0),
    m_pCapabilities(NULL),

    m_pDevice(NULL),
    m_pDeviceInfo(NULL),

    m_iConnectedApps(0)

{

    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*> (static_cast<INonDelegatingUnknown*> (this));
    }
}

/**************************************************************************\
* CWiaCameraDevice::~CWiaCameraDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDevice::~CWiaCameraDevice(void)
{
    HRESULT hr = S_OK;

    //
    // Free all the resources held by the minidriver. Normally this is done by
    // drvUnInitializeWia, but there are situations (like WIA service shutdown) when
    // just this destructor is called
    //
    if (m_pDevice)
    {
        hr = FreeResources();
        if (FAILED(hr))
            wiauDbgErrorHr(hr, "~CWiaCameraDevice", "FreeResources failed, continuing...");

        hr = m_pDevice->UnInit(m_pDeviceInfo);
        if (FAILED(hr))
        {
            wiauDbgErrorHr(hr, "~CWiaCameraDevice", "UnInit failed, continuing...");
        }
        m_pDeviceInfo = NULL;

        delete m_pDevice;
        m_pDevice = NULL;
    }

    // Release the device control interface.
    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }
}

/**************************************************************************\
* CWiaCameraDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    -
*    dwStiVersion           -
*    hParametersKey         -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    HKEY hkeyDeviceData = NULL;
    TCHAR tszMicroName[MAX_PATH];
    DWORD dwNameSize = sizeof(tszMicroName);

    //
    // Initialize logging
    //
    wiauDbgInit(g_hInst);

    //
    // Check and cache the pointer to the IStiDeviceControl interface
    //
    if (!pIStiDevControl) {
        wiauDbgError("Initialize", "Invalid device control interface");
        return STIERR_INVALID_PARAM;
    }

    pIStiDevControl->AddRef();
    m_pIStiDevControl = pIStiDevControl;

    //
    // Retrieve the port name from the IStiDeviceControl interface
    //
    hr = m_pIStiDevControl->GetMyDevicePortName(m_wszPortName, sizeof(m_wszPortName) / sizeof(m_wszPortName[0]));
    REQUIRE_SUCCESS(hr, "Initialize", "GetMyDevicePortName failed");
    
    //
    // Get the microdriver name from the registry
    //
    hr = wiauRegOpenData(hParametersKey, &hkeyDeviceData);
    REQUIRE_SUCCESS(hr, "Initialize", "wiauRegOpenData failed");

    hr = wiauRegGetStr(hkeyDeviceData, TEXT("MicroDriver"), tszMicroName, &dwNameSize);
    REQUIRE_SUCCESS(hr, "Initialize", "wiauRegGetStr failed");

    //
    // Create the device object
    //
    m_pDevice = new CCamMicro;
    REQUIRE_ALLOC(m_pDevice, hr, "Initialize");

    hr = m_pDevice->Init(tszMicroName, &m_pDeviceInfo);
    REQUIRE_SUCCESS(hr, "Initialize", "Init failed");
    
    //
    // Intialize image format converter
    //
    hr = m_Converter.Init();
    REQUIRE_SUCCESS(hr, "Initialize", "Init failed");
    
Cleanup:
    if (hkeyDeviceData)
        RegCloseKey(hkeyDeviceData);

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    DBG_FN("CWiaCameraDevice::GetCapabilities");

    if (!pUsdCaps)
    {
        wiauDbgError("GetCapabilities", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    memset(pUsdCaps, 0, sizeof(STI_USD_CAPS));
    pUsdCaps->dwVersion     = STI_VERSION;
    pUsdCaps->dwGenericCaps = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    DBG_FN("CWiaCameraDevice::GetStatus");

    HRESULT hr = S_OK;

    //
    // Validate parameters
    //
    REQUIRE_ARGS(!pDevStatus, hr, "GetStatus");

    //
    // If requested, verify the device is online
    //
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {
        pDevStatus->dwOnlineState = 0L;

        hr = m_pDevice->Status(m_pDeviceInfo);

        if (hr == S_OK) {
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }

        else if (hr == S_FALSE) {
            hr = S_OK;
        }
        else {
            wiauDbgErrorHr(hr, "GetStatus", "Status failed");
            goto Cleanup;
        }
    }

    //
    // If requested, see if the device has signaled an event.
    // For cameras, there shouldn't be any events.
    //
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {
        pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;

    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::DeviceReset
*
*   Reset data file pointer to start of file.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::DeviceReset(void)
{
    DBG_FN("CWiaCameraDevice::DeviceReset");

    HRESULT hr = S_OK;

    hr = m_pDevice->Reset(m_pDeviceInfo);
    REQUIRE_SUCCESS(hr, "DeviceReset", "Reset failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    DBG_FN("CWiaCameraDevice::Diagnostic");

    if (!pBuffer)
    {
        wiauDbgError("Diagnostic", "invalid arguments");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    // Initialize response buffer
    //
    memset(&pBuffer->sErrorInfo, 0, sizeof(pBuffer->sErrorInfo));
    pBuffer->dwStatusMask = 0;
    pBuffer->sErrorInfo.dwGenericError  = NOERROR;
    pBuffer->sErrorInfo.dwVendorError   = 0;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::SetNotificationHandle(HANDLE hEvent)
{
    DBG_FN("CWiaCameraDevice::SetNotificationHandle");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetNotificationData
*
*   Provides data from an event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    DBG_FN("CWiaCameraDevice::GetNotificationData");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    DBG_FN("CWiaCameraDevice::Escape");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    DBG_FN("CWiaCameraDevice::GetLastError");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pdwLastDeviceError, hr, "GetLastError");

    *pdwLastDeviceError = m_dwLastOperationError;

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    DBG_FN("CWiaCameraDevice::GetLastErrorInfo");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pLastErrorInfo, hr, "GetLastErrorInfo");

    pLastErrorInfo->dwGenericError          = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0]  = '\0';

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::LockDevice(void)
{
    DBG_FN("CWiaCameraDevice::LockDevice");

    HRESULT hr = S_OK;

    //
    // For devices connected to ports that cannot be shared (e.g. serial),
    // open the device and initialize access to the camera
    //
    if (m_pDeviceInfo->bExclusivePort) {
        hr = m_pDevice->Open(m_pDeviceInfo, m_wszPortName);
        REQUIRE_SUCCESS(hr, "LockDevice", "Open failed");
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::UnLockDevice(void)
{
    DBG_FN("CWiaCameraDevice::UnLockDevice");

    HRESULT hr = S_OK;

    //
    // For devices connected to ports that cannot be shared (e.g. serial),
    // close the device
    //
    if (m_pDeviceInfo->bExclusivePort) {
        hr = m_pDevice->Close(m_pDeviceInfo);
        REQUIRE_SUCCESS(hr, "UnLockDevice", "Close failed");
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    DBG_FN("CWiaCameraDevice::RawReadData");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           -
*    dwNumberOfBytes    -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    DBG_FN("CWiaCameraDevice::RawWriteData");

    HRESULT hr = S_OK;

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::RawReadCommand
*
*   Read a command from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    DBG_FN("CWiaCameraDevice::RawReadCommand");

    HRESULT hr = S_OK;

    return E_NOTIMPL;
}

/**************************************************************************\
* CWiaCameraDevice::RawWriteCommand
*
*   Write a command to the device.
*
* Arguments:
*
*    lpBuffer       -
*    nNumberOfBytes -
*    lpOverlapped   -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    DBG_FN("CWiaCameraDevice::RawWriteCommand");

    HRESULT hr = S_OK;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\camxfer.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       memcam.cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      Mark Enstrom [marke]
*               Indy Zhu     [indyz]
*
*  DATE:        2/4/1998
*               5/18/1998
*
*  DESCRIPTION:
*   Implementation of an ImageIn test camera device object.
*
*******************************************************************************/

#include <stdio.h>
#include <objbase.h>
#include <tchar.h>
#include <sti.h>

extern HINSTANCE g_hInst; // Global hInstance

#include "testusd.h"


VOID
VerticalFlip(
    PBYTE   pImageTop,
    LONG    iHeight,
    LONG    iWidthInBytes);

/**************************************************************************\
* CamLoadPicture
*
*    load a bmp from disk and copy it to application
*
* Arguments:
*
*   pCameraImage    - pointer to data structure with image info
*   pDataTransCtx   - pointer to minidriver transfer context
*
* Return Value:
*
*   status
*
* History:
*
*    2/10/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamLoadPicture(
    MEMCAM_IMAGE_CONTEXT       *pMCamContext,
    PMINIDRV_TRANSFER_CONTEXT   pDataTransCtx,
    PLONG                       plCamErrVal)
{
    LONG                  lScanLineWidth;
    HRESULT               hr = S_OK;
    LONG                  cbNeeded;
    IWiaMiniDrvCallBack  *pIProgressCB;

    WIAS_TRACE((g_hInst,"CamLoadPicture"));

    //
    // verify some params
    //

    if (! pMCamContext) {
      return (E_INVALIDARG);
    }

    if (pDataTransCtx->guidFormatID != WiaImgFmt_BMP && pDataTransCtx->guidFormatID != WiaAudFmt_WAV) {
        return (E_NOTIMPL);
    }

    pIProgressCB = pDataTransCtx->pIWiaMiniDrvCallBack;

    //
    // Simulate the download of data from the camera
    //

    if (pIProgressCB) {
        hr = pIProgressCB->MiniDrvCallback(
                               IT_MSG_STATUS,
                               IT_STATUS_TRANSFER_FROM_DEVICE,
                               (LONG)0,     // Percentage Complete,
                               0,
                               0,
                               pDataTransCtx,
                               0);
        if (hr != S_OK) {
            return (hr);   // Client want to cancel the transfer or error
        }
    }

    HANDLE hFile = CreateFile(
                       pMCamContext->pszCameraImagePath,
                       GENERIC_WRITE | GENERIC_READ  ,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );

    if (hFile == INVALID_HANDLE_VALUE) {

        hr = HRESULT_FROM_WIN32(::GetLastError());
        return (hr);
    }

    if (pIProgressCB) {
        hr = pIProgressCB->MiniDrvCallback(
                               IT_MSG_STATUS,
                               IT_STATUS_TRANSFER_FROM_DEVICE,
                               (LONG)25,     // Percentage Complete,
                               0,
                               0,
                               pDataTransCtx,
                               0);
    }
    if (hr != S_OK) {
        CloseHandle(hFile);
        return (hr);
    }

    HANDLE hMap  = CreateFileMapping(
                       hFile,
                       NULL,
                       PAGE_READWRITE,
                       0,
                       0,
                       NULL);

    if (hMap == NULL) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    } else {
        if (pIProgressCB) {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)50,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0);
        }
    }

    if (hr != S_OK) {
        CloseHandle(hFile);
        return (hr);
    }

    PBYTE pFile = (PBYTE)MapViewOfFileEx(
                             hMap,
                             FILE_MAP_READ | FILE_MAP_WRITE,
                             0,
                             0,
                             0,
                             NULL);
    if (pFile == NULL) {

        hr = HRESULT_FROM_WIN32(::GetLastError());
    } else {
        if (pIProgressCB) {
            hr = pIProgressCB->MiniDrvCallback(
                                   IT_MSG_STATUS,
                                   IT_STATUS_TRANSFER_FROM_DEVICE,
                                   (LONG)100,     // Percentage Complete,
                                   0,
                                   0,
                                   pDataTransCtx,
                                   0);
        }
    }

    if (hr != S_OK) {
        CloseHandle(hFile);
        CloseHandle(hMap);
        return(hr);
    }

    if (pDataTransCtx->guidFormatID == WiaImgFmt_BMP)
    {


        //
        // File contains BITMAPFILEHEADER + BITMAPINFO structure.
        //
        // DIB Data is located bfOffBits after start of file
        //

        PBITMAPFILEHEADER pbmFile  = (PBITMAPFILEHEADER)pFile;
        PBITMAPINFO       pbmi     = (PBITMAPINFO)(pFile +
                                               sizeof(BITMAPFILEHEADER));

        //
        // validate bitmap
        //

        if (pbmFile->bfType != 'MB') {

            //
            // file is not a bitmap
            //

            UnmapViewOfFile(pFile);
            CloseHandle(hMap);
            CloseHandle(hFile);
            return(E_FAIL);
        }

        //
        // write image size
        //
        // make sure to align scanline to ULONG boundary
        //
        // calculate byte width
        //

        lScanLineWidth = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;

        //
        // round up to nearenst DWORD
        //

        lScanLineWidth = (lScanLineWidth + 31) >> 3;

        lScanLineWidth &= 0xfffffffc;

        cbNeeded = lScanLineWidth * pbmi->bmiHeader.biHeight;

        if (cbNeeded > ((LONG)pDataTransCtx->lItemSize - (LONG)pDataTransCtx->cbOffset)) {

            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);

        } else {

            //
            // copy only the bitmap bits (no headers)
            //

            memcpy(
                pDataTransCtx->pTransferBuffer + pDataTransCtx->cbOffset,
                pFile + pbmFile->bfOffBits,
                cbNeeded);
        }
    }
    else
    {
        memcpy (pDataTransCtx->pTransferBuffer,
                pFile,
                pDataTransCtx->lItemSize);
    }
    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return(S_OK);
}

/**************************************************************************\
* CamLoadPictureCB
*
*    return data by filling the data buffer and calling back to the client
*
* Arguments:
*
*    pCameraImage    -    image item
*    pTransCtx       -    mini driver transfer contect
*
* Return Value:
*
*   status
*
* History:
*
*    1/10/1999 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT TestUsdDevice::CamLoadPictureCB(
    MEMCAM_IMAGE_CONTEXT      *pMCamContext,
    MINIDRV_TRANSFER_CONTEXT  *pTransCtx,
    PLONG                      plCamErrVal)
{
    LONG                   lScanLineWidth;
    HRESULT                hr = E_FAIL;

    WIAS_TRACE((g_hInst,"CamLoadPictureCB"));

    //
    // verify parameters
    //

    if (!pMCamContext) {
      return (E_INVALIDARG);
    }

    if (pTransCtx == NULL) {
        return (E_INVALIDARG);
    }

    if ((pTransCtx->guidFormatID != WiaImgFmt_BMP) &&
        (pTransCtx->guidFormatID != WiaImgFmt_MEMORYBMP)) {
        return (E_NOTIMPL);
    }

    //
    // try to open disk file
    //

    HANDLE hFile = CreateFile(
                       pMCamContext->pszCameraImagePath,
                       GENERIC_WRITE | GENERIC_READ  ,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );
    if (hFile == INVALID_HANDLE_VALUE) {

        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    HANDLE hMap  = CreateFileMapping(
                       hFile,
                       NULL,
                       PAGE_READWRITE,
                       0,
                       0,
                       NULL);

    if (hMap == NULL) {
        CloseHandle(hFile);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    PBYTE pFile = (PBYTE)MapViewOfFileEx(
                             hMap,
                             FILE_MAP_READ | FILE_MAP_WRITE,
                             0,
                             0,
                             0,
                             NULL);
    if (pFile == NULL) {

        CloseHandle(hFile);
        CloseHandle(hMap);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    //
    // File contains BITMAPFILEHEADER + BITMAPINFO structure.
    //
    // DIB Data is located bfOffBits after start of file
    //

    PBITMAPFILEHEADER pbmFile  = (PBITMAPFILEHEADER)pFile;
    PBITMAPINFO       pbmi     = (PBITMAPINFO)(pFile +
                                               sizeof(BITMAPFILEHEADER));
    //
    // validate bitmap
    //

    if (pbmFile->bfType != 'MB') {

        //
        // file is not a bitmap
        //

        UnmapViewOfFile(pFile);
        CloseHandle(hMap);
        CloseHandle(hFile);
        return(E_FAIL);
    }

    //
    // get image size
    //
    // make sure to align scanline to ULONG boundary
    //
    // calculate byte width
    //

    lScanLineWidth = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;

    //
    // round up to nearenst DWORD
    //

    lScanLineWidth = (lScanLineWidth + 31) >> 3;

    lScanLineWidth &= 0xfffffffc;

    LONG lBytesRemaining = lScanLineWidth * pbmi->bmiHeader.biHeight;

    //
    // Flip the image vertically if WiaImgFmt_MEMORYBMP is requested
    //

    if (pTransCtx->guidFormatID == WiaImgFmt_MEMORYBMP) {
        VerticalFlip(
            (PBYTE)pFile + pbmFile->bfOffBits,
            pbmi->bmiHeader.biHeight,
            lScanLineWidth);
    }

    //
    // callback loop
    //

    PBYTE pSrc = (PBYTE)pFile + pbmFile->bfOffBits;

    LONG  lTransferSize;
    LONG  lPercentComplete;

    do {

        PBYTE pDst = pTransCtx->pTransferBuffer;

        //
        // transfer up to entire buffer size
        //

        lTransferSize = lBytesRemaining;

        if (lBytesRemaining > pTransCtx->lBufferSize) {
            lTransferSize = pTransCtx->lBufferSize;
        }

        //
        // copy data
        //

        memcpy(pDst, pSrc, lTransferSize);

        lPercentComplete = 100 * (pTransCtx->cbOffset + lTransferSize);
        lPercentComplete /= pTransCtx->lItemSize;

        //
        // make callback
        //

        hr = pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                     IT_MSG_DATA,
                                     IT_STATUS_TRANSFER_TO_CLIENT,
                                     lPercentComplete,
                                     pTransCtx->cbOffset,
                                     lTransferSize,
                                     pTransCtx,
                                     0);
        //
        // inc pointers (redundant pointers here)
        //

        pSrc                += lTransferSize;
        pTransCtx->cbOffset += lTransferSize;
        lBytesRemaining     -= lTransferSize;

        if (hr != S_OK) {
            break;
        }

    } while (lBytesRemaining > 0);

    //
    // Flip the image back if WiaImgFmt_MEMORYBMP is requested
    //

    if (pTransCtx->guidFormatID == WiaImgFmt_MEMORYBMP) {
        VerticalFlip(
            (PBYTE)pFile + pbmFile->bfOffBits,
            pbmi->bmiHeader.biHeight,
            lScanLineWidth);
    }

    //
    // Garbage collection
    //

    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return(hr);
}



/**************************************************************************\
* CamGetPictureInfo
*
*    Load file, get information from image
*
* Arguments:
*
*    pCameraImage    -    image item
*    pPictInfo       -    fill out ino about image
*    ppBITMAPINFO    -    alloc and fill out BITMAPINFO
*    pBITMAPINFOSize -    size
*
* Return Value:
*
*    status
*
* History:
*
*    1/17/1999 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamGetPictureInfo(
    MEMCAM_IMAGE_CONTEXT  *pMCamContext,
    PCAMERA_PICTURE_INFO   pPictInfo,
    PBYTE                 *ppBITMAPINFO,
    LONG                  *pBITMAPINFOSize)
{
    HRESULT                hr = S_OK;
    FILETIME               ftCreate;
    SYSTEMTIME             stCreate;

    WIAS_TRACE((g_hInst,"CamGetPictureInfo"));

    //
    // Try to open disk file
    //

    HANDLE hFile = CreateFile(
                       pMCamContext->pszCameraImagePath,
                       GENERIC_WRITE | GENERIC_READ,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );
    if (hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    //
    // Grab the creation time for this image
    //

    if (GetFileTime( hFile, &ftCreate, NULL, NULL)) {
        FileTimeToSystemTime( &ftCreate, &stCreate );
    } else {
        //
        // To return something, use the system time
        //

        GetLocalTime( &stCreate );
    }

    HANDLE hMap  = CreateFileMapping(
                       hFile,
                       NULL,
                       PAGE_READWRITE,
                       0,
                       0,
                       NULL
                       );
    if (hMap == NULL) {
        CloseHandle(hFile);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    PBYTE pFile = (PBYTE)MapViewOfFileEx(
                             hMap,
                             FILE_MAP_READ | FILE_MAP_WRITE,
                             0,
                             0,
                             0,
                             NULL);
    if (pFile == NULL) {
        CloseHandle(hFile);
        CloseHandle(hMap);
        hr = HRESULT_FROM_WIN32(::GetLastError());
        return(hr);
    }

    //
    // File contains BITMAPFILEHEADER + BITMAPINFO structure.
    //
    // DIB Data is located bfOffBits after start of file
    //

    PBITMAPFILEHEADER  pbmFile    = (PBITMAPFILEHEADER)pFile;
    PBITMAPINFOHEADER  pbmiHeader =
                           (PBITMAPINFOHEADER)(pFile +
                                               sizeof(BITMAPFILEHEADER));
    PBYTE              pDIBFile   = pFile + pbmFile->bfOffBits;

    //
    // validate bitmap.
    //

    if (pbmFile->bfType != 'MB') {
        //
        // file is not a bitmap
        //


        UnmapViewOfFile(pFile);
        CloseHandle(hFile);
        CloseHandle(hMap);
        return(E_FAIL);
    }

    //
    // fill out image information
    //

    pPictInfo->PictNumber       = 0;  // ??? Should support picture handle ???
    pPictInfo->ThumbWidth       = 80;
    pPictInfo->ThumbHeight      = 60;
    pPictInfo->PictWidth        = pbmiHeader->biWidth;
    pPictInfo->PictHeight       = pbmiHeader->biHeight;
    pPictInfo->PictCompSize     = 0;
    pPictInfo->PictFormat       = 0;
    pPictInfo->PictBitsPerPixel = pbmiHeader->biBitCount;

    {
        LONG lScanLineWidth = (pbmiHeader->biWidth *
                              pbmiHeader->biBitCount);

        //
        // round up to nearenst DWORD
        //

        lScanLineWidth = (lScanLineWidth + 31) >> 3;

        //
        // remove extra bytes
        //

        lScanLineWidth &= 0xfffffffc;

        pPictInfo->PictBytesPerRow  = lScanLineWidth;
    }

    //
    // is there a color table
    //

    LONG ColorMapSize = 0;
    LONG bmiSize;

    if (pbmiHeader->biBitCount == 1) {
        ColorMapSize = 2;
    } else if (pbmiHeader->biBitCount == 4) {
        ColorMapSize = 16;
    } else if (pbmiHeader->biBitCount == 8) {
        ColorMapSize = 256;
    }

    //
    // Changed by Indy on 5/18/98 to BITMAPINFOHEADER
    //

    bmiSize = sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * ColorMapSize;

    *ppBITMAPINFO = (PBYTE)ALLOC(bmiSize);

    if (*ppBITMAPINFO != NULL) {
        memcpy(*ppBITMAPINFO, pbmiHeader, bmiSize);
        *pBITMAPINFOSize = bmiSize;
    } else {

        UnmapViewOfFile(pFile);
        CloseHandle(hFile);
        CloseHandle(hMap);
        return(E_OUTOFMEMORY);
    }

    //
    // Set the time for the image
    //

    memcpy(&pPictInfo->TimeStamp, &stCreate, sizeof(pPictInfo->TimeStamp));

    //
    // close up the file
    //

    UnmapViewOfFile(pFile);
    CloseHandle(hMap);
    CloseHandle(hFile);

    return(hr);
}


/**************************************************************************\
* CamLoadThumbnail
*
*   Load the thumbnail of the specified picture
*
* Arguments:
*
*   pCameraImage    - image item
*   pThumbnail      - buffer for thumbnail
*   pThumbSize      - size of thumbnail
*
* Return Value:
*
*   status
*
* History:
*
*    2/9/1998  Mark Enstrom [marke]
*    6/9/1998  Indy Zhu     [indyz]
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamLoadThumbnail(
    MEMCAM_IMAGE_CONTEXT  *pMCamContext ,
    PBYTE                 *pThumbnail,
    LONG                  *pThumbSize
    )
{
    TCHAR                  pszThumbName[MAX_PATH];
    HRESULT                hr;
    BOOL                   bCacheThumb  = TRUE;
    BOOL                   bThumbExists = TRUE;

    PBYTE                  pTmbPixels;
    HBITMAP                hbmThumb     = NULL;
    PBYTE                  pThumb       = NULL;
    HANDLE                 hTmbFile     = INVALID_HANDLE_VALUE;
    HANDLE                 hTmbMap      = NULL;
    PBYTE                  pTmbFile     = NULL;

    HANDLE                 hFile        = INVALID_HANDLE_VALUE;
    HANDLE                 hMap         = NULL;
    PBYTE                  pFile        = NULL;

    BITMAPINFO             bmiDIB;
    HDC                    hdc          = NULL;
    HDC                    hdcm1        = NULL;

    WIAS_TRACE((g_hInst,"CamLoadThumbnail"));

    //
    // Initialize the return values
    //

    *pThumbnail = NULL;
    *pThumbSize = 0;

    //
    // Fill in the size of the tumbnail pixel buffer
    //

    bmiDIB.bmiHeader.biSizeImage = 80*60*3;

    //
    // Build thumbnail filename Image.bmp.tmb
    //

    _tcscpy(pszThumbName, pMCamContext->pszCameraImagePath);
    _tcscat(pszThumbName, TEXT(".tmb"));

    __try {

        hTmbFile = CreateFile(
                       pszThumbName,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );

        //
        // See if cached thumbnail already exists
        //

        if (hTmbFile == INVALID_HANDLE_VALUE) {

            //
            // Try to create a new one
            //

            hTmbFile = CreateFile(
                           pszThumbName,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_WRITE,
                           NULL,
                           CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           );

            //
            // Thumbnail need to be created
            //

            bThumbExists = FALSE;

        }

        //
        // thumbnail file exists
        //

        if (hTmbFile != INVALID_HANDLE_VALUE) {

            hTmbMap = CreateFileMapping(
                          hTmbFile,
                          NULL,
                          PAGE_READWRITE,
                          0,
                          80 * 60 * 3,
                          NULL);

            if (hTmbMap != NULL) {

                pTmbFile = (PBYTE)MapViewOfFileEx(
                                      hTmbMap,
                                      FILE_MAP_READ | FILE_MAP_WRITE,
                                      0,
                                      0,
                                      0,
                                      NULL);

                if (pTmbFile) {

                    if (bThumbExists) {

                        //
                        // Alloca memory for thumbnail pixels
                        //

                        pTmbPixels = (PBYTE)ALLOC(bmiDIB.bmiHeader.biSizeImage);

                        if (! pTmbPixels) {
                            return(E_OUTOFMEMORY);
                        }

                        //
                        // Pull the thumbnail from the cached file
                        //

                        memcpy(pTmbPixels, pTmbFile,
                               bmiDIB.bmiHeader.biSizeImage);

                        //
                        // All the handles will be closed in __finally block
                        //

                        *pThumbnail = pTmbPixels;
                        *pThumbSize = bmiDIB.bmiHeader.biSizeImage;

                        return(S_OK);
                    }
                } else {

                    bCacheThumb  = FALSE;
                }
            } else {

                bCacheThumb  = FALSE;
            }
        } else {

            //
            // Can't cache thumbnail
            //

            bCacheThumb  = FALSE;
        }

        //
        // Try to create a thumbnail from the full-size image
        // and cache it if the thumbnail cache file is created
        //

        hFile = CreateFile(
                    pMCamContext->pszCameraImagePath,
                    GENERIC_WRITE | GENERIC_READ,
                    FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
        if (hFile == INVALID_HANDLE_VALUE) {


            hr = HRESULT_FROM_WIN32(::GetLastError());
            return(hr);
        }

        hMap = CreateFileMapping(
                   hFile,
                   NULL,
                   PAGE_READWRITE,
                   0,
                   0,
                   NULL
                   );
        if (hMap == NULL) {

          hr = HRESULT_FROM_WIN32(::GetLastError());
          return(hr);
        }

        pFile = (PBYTE)MapViewOfFileEx(
                           hMap,
                           FILE_MAP_READ | FILE_MAP_WRITE,
                           0,
                           0,
                           0,
                           NULL
                           );
        if (pFile == NULL) {

            hr = HRESULT_FROM_WIN32(::GetLastError());
            return(hr);
        }

        PBITMAPFILEHEADER pbmFile = (PBITMAPFILEHEADER)pFile;
        PBITMAPINFO       pbmi    = (PBITMAPINFO)(pFile +
                                                 sizeof(BITMAPFILEHEADER));
        PBYTE             pPixels = pFile + pbmFile->bfOffBits;

        //
        // Generate the thumbnail from the full-size image
        //

        hdc   = GetDC(NULL);
        hdcm1 = CreateCompatibleDC(hdc);
        SetStretchBltMode(hdcm1, COLORONCOLOR);



        //
        // Create a BITMAP for rendering the thumbnail
        //

        bmiDIB.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        bmiDIB.bmiHeader.biBitCount      = 24;
        bmiDIB.bmiHeader.biWidth         = 80;
        bmiDIB.bmiHeader.biHeight        = 60;
        bmiDIB.bmiHeader.biPlanes        = 1;
        bmiDIB.bmiHeader.biCompression   = BI_RGB;
        bmiDIB.bmiHeader.biXPelsPerMeter = 100;
        bmiDIB.bmiHeader.biYPelsPerMeter = 100;
        bmiDIB.bmiHeader.biClrUsed       = 0;
        bmiDIB.bmiHeader.biClrImportant  = 0;

        hbmThumb = CreateDIBSection(hdc, &bmiDIB, DIB_RGB_COLORS,
                                    (VOID **)&pThumb, NULL, 0);

        if (! hbmThumb) {

            hr = HRESULT_FROM_WIN32(::GetLastError());
            return hr;
        }

        HBITMAP     hbmDef = (HBITMAP)SelectObject(hdcm1, hbmThumb);

        //
        // Init DIB
        //

        memset(pThumb, 0, bmiDIB.bmiHeader.biSizeImage);

        //
        // create 80x60 thumbnail while preserving image
        // aspect ratio
        //

        LONG        lThumbWidth;
        LONG        lThumbHeight;

        double      fImageWidth  = (double)pbmi->bmiHeader.biWidth;
        double      fImageHeight = (double)pbmi->bmiHeader.biHeight;
        double      fAspect      = fImageWidth / fImageHeight;
        double      fDefAspect   = 80.0 / 60.0;

        if (fAspect > fDefAspect) {

            lThumbWidth  = 80;
            lThumbHeight = (LONG)(80.0 / fAspect);
        } else {

            lThumbHeight = 60;
            lThumbWidth  = (LONG)(60.0 * fAspect);
        }

        int i = StretchDIBits(
                    hdcm1,
                    0,
                    0,
                    lThumbWidth,
                    lThumbHeight,
                    0,
                    0,
                    pbmi->bmiHeader.biWidth,
                    pbmi->bmiHeader.biHeight,
                    pPixels,
                    pbmi,
                    DIB_RGB_COLORS,
                    SRCCOPY
                    );

        SelectObject(hdcm1, hbmDef);

        //
        // Cache ?
        //

        if (bCacheThumb) {
            memcpy(pTmbFile, pThumb, bmiDIB.bmiHeader.biSizeImage);
        }

        //
        // Alloca memory for thumbnail pixels
        //
        pTmbPixels = (PBYTE)ALLOC(bmiDIB.bmiHeader.biSizeImage);
        if (! pTmbPixels) {
            return(E_OUTOFMEMORY);
        }

        //
        // Write out data
        //

        memcpy(pTmbPixels, pThumb, bmiDIB.bmiHeader.biSizeImage);
        *pThumbnail = pTmbPixels;
        *pThumbSize = bmiDIB.bmiHeader.biSizeImage;

        return(S_OK);

    } // End of __try { ... } block

    __finally {

        if (pTmbFile) {
            UnmapViewOfFile(pTmbFile);
        }
        if (hTmbMap) {
            CloseHandle(hTmbMap);
        }
        if (hTmbFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hTmbFile);
        }

        if (pFile) {
            UnmapViewOfFile(pFile);
        }
        if (hMap) {
            CloseHandle(hMap);
        }
        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hFile);
        }

        if (hbmThumb) {
            DeleteObject(hbmThumb);
        }

        if (hdcm1) {
            DeleteDC(hdcm1);
        }
        if (hdc) {
            ReleaseDC(NULL, hdc);
        }

    }

    return(E_FAIL);
}


/**************************************************************************\
* CamDeletePicture
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    6/3/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
CamDeletePicture(
    MEMCAM_IMAGE_CONTEXT  *pMCamContext)
{
    return(E_NOTIMPL);
}


/**************************************************************************\
* CamTakePicture
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    6/3/1998 Mark Enstrom [marke]
*
\**************************************************************************/
HRESULT
CamTakePicture(
    MEMCAM_IMAGE_CONTEXT  *pMCamContext ,
    ULONG                 *pHandle)
{
    return (E_NOTIMPL);
}

/**************************************************************************\
* VertivalFlip
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    11/18/1998 Original Version
*
\**************************************************************************/

VOID
VerticalFlip(
    PBYTE pImageTop,
    LONG  iHeight,
    LONG  iWidthInBytes)
{
    //
    // try to allocat a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,iWidthInBytes);

    if (pBuffer != NULL) {

        LONG  index;
        PBYTE pImageBottom;

        pImageBottom = pImageTop + (iHeight-1) * iWidthInBytes;

        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,iWidthInBytes);
            memcpy(pImageTop,pImageBottom,iWidthInBytes);
            memcpy(pImageBottom,pBuffer,iWidthInBytes);

            pImageTop    += iWidthInBytes;
            pImageBottom -= iWidthInBytes;
        }

        LocalFree(pBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\root.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  TITLE:       Root.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   This file implements the helper methods for IWiaMiniDrv for the root item.
*
*******************************************************************************/

#include "pch.h"

/**************************************************************************\
* BuildRootItemProperties
*
*   Create the properties for the root item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::BuildRootItemProperties(
    BYTE *pWiasContext
    )
{
    DBG_FN("CWiaCameraDevice::BuildRootItemProperties");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    BSTR bstrFirmwareVer = NULL;

    //
    // Create a WIA property list and allocate enough space for all
    // the properties created below
    //
    CWiauPropertyList RootProps;

    hr = RootProps.Init(50);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "Init property list failed");

    //
    // These are the WHQL required properties for cameras:
    //
    INT index;

    hr = RootProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, (LONG) WIA_ITEM_READ | WIA_ITEM_WRITE);

    if (m_pDeviceInfo->pwszFirmwareVer) {
        hr = RootProps.DefineProperty(&index, WIA_DPA_FIRMWARE_VERSION, WIA_DPA_FIRMWARE_VERSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
        bstrFirmwareVer = SysAllocString(m_pDeviceInfo->pwszFirmwareVer);
        REQUIRE_ALLOC(bstrFirmwareVer, hr, "BuildRootItemProperties");
        RootProps.SetCurrentValue(index, bstrFirmwareVer);
    }

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_TAKEN, WIA_DPC_PICTURES_TAKEN_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, m_pDeviceInfo->lPicturesTaken);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICTURES_REMAINING, WIA_DPC_PICTURES_REMAINING_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, m_pDeviceInfo->lPicturesRemaining);

    //
    // These are WHQL optional properties
    //

    hr = RootProps.DefineProperty(&index, WIA_DPA_DEVICE_TIME, WIA_DPA_DEVICE_TIME_STR,
                                  WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, &m_pDeviceInfo->Time);


#if DEADCODE
    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_MODE, WIA_DPC_EXPOSURE_MODE_STR,
                                  WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureMode);
    FakeCamera_SetValidValues(index, pRootProperties);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_COMP, WIA_DPC_EXPOSURE_COMP_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureComp);
    FakeCamera_SetValidValues(index, pRootProperties);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_TIME, WIA_DPC_EXPOSURE_TIME_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureTime);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FNUMBER, WIA_DPC_FNUMBER_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FNumber);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FLASH_MODE, WIA_DPC_FLASH_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FlashMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_MODE, WIA_DPC_FOCUS_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FocusMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PAN_POSITION, WIA_DPC_PAN_POSITION_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.PanPosition);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TILT_POSITION, WIA_DPC_TILT_POSITION_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.TiltPosition);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMER_MODE, WIA_DPC_TIMER_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.TimerMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMER_VALUE, WIA_DPC_TIMER_VALUE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.TimerValue);

    hr = RootProps.DefineProperty(&index, WIA_DPC_POWER_MODE, WIA_DPC_POWER_MODE_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.PowerMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BATTERY_STATUS, WIA_DPC_BATTERY_STATUS_STR,
                                    WIA_PROP_READ, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.BatteryStatus);

    hr = RootProps.DefineProperty(&index, WIA_DPC_THUMB_WIDTH, WIA_DPC_THUMB_WIDTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ThumbWidth);

    hr = RootProps.DefineProperty(&index, WIA_DPC_THUMB_HEIGHT, WIA_DPC_THUMB_HEIGHT_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ThumbHeight);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_WIDTH, WIA_DPC_PICT_WIDTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.PictWidth);

    hr = RootProps.DefineProperty(&index, WIA_DPC_PICT_HEIGHT, WIA_DPC_PICT_HEIGHT_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.PictHeight);

    hr = RootProps.DefineProperty(&index, WIA_DPC_COMPRESSION_SETTING, WIA_DPC_COMPRESSION_SETTING_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.CompressionSetting);

    hr = RootProps.DefineProperty(&index, WIA_DPC_TIMELAPSE_INTERVAL, WIA_DPC_TIMELAPSE_INTERVAL_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.TimelapseInterval);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BURST_INTERVAL, WIA_DPC_BURST_INTERVAL_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.BurstInterval);

    hr = RootProps.DefineProperty(&index, WIA_DPC_BURST_NUMBER, WIA_DPC_BURST_NUMBER_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.BurstNumber);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EFFECT_MODE, WIA_DPC_EFFECT_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.EffectMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_DIGITAL_ZOOM, WIA_DPC_DIGITAL_ZOOM_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.DigitalZoom);

    hr = RootProps.DefineProperty(&index, WIA_DPC_SHARPNESS, WIA_DPC_SHARPNESS_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.Sharpness);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CONTRAST, WIA_DPC_CONTRAST_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.Constrast);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CAPTURE_MODE, WIA_DPC_CAPTURE_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.CaptureMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_CAPTURE_DELAY, WIA_DPC_CAPTURE_DELAY_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.CaptureDelay);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_INDEX, WIA_DPC_EXPOSURE_INDEX_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureIndex);

    hr = RootProps.DefineProperty(&index, WIA_DPC_EXPOSURE_METERING_MODE, WIA_DPC_EXPOSURE_METERING_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.ExposureMeteringMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_METERING_MODE, WIA_DPC_FOCUS_METERING_MODE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FocusMeteringMode);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCUS_DISTANCE, WIA_DPC_FOCUS_DISTANCE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FocusDistance);

    hr = RootProps.DefineProperty(&index, WIA_DPC_FOCAL_LENGTH, WIA_DPC_FOCAL_LENGTH_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.FocalLength);

    hr = RootProps.DefineProperty(&index, WIA_DPC_RGBGAIN, WIA_DPC_RGBGAIN_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.RGBGain);

    hr = RootProps.DefineProperty(&index, WIA_DPC_WHITE_BALANCE, WIA_DPC_WHITE_BALANCE_STR,
                                    WIA_PROP_RW, WIA_PROP_NONE);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "DefineProperty failed");
    RootProps.SetCurrentValue(index, CameraStats.WhiteBalance);

#endif // DEADCODE

    //
    // TODO: Add other optional properties that your device supports here
    //


    // Last step: send all the properties to WIA

    hr = RootProps.SendToWia(pWiasContext);
    REQUIRE_SUCCESS(hr, "BuildRootItemProperties", "SendToWia failed");

Cleanup:
    if (bstrFirmwareVer)
        SysFreeString(bstrFirmwareVer);
    return hr;
}

/**************************************************************************\
* ReadRootItemProperties
*
*   Update the properties for the root item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::ReadRootItemProperties(
    BYTE           *pWiasContext,
    LONG            NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    DBG_FN("CWiaCameraDevice::ReadRootItemProperties");

    HRESULT hr = S_OK;

    REQUIRE_ARGS(!NumPropSpecs || !pPropSpecs, hr, "ReadRootItemProperties");

    //
    // Loop through all of the PropSpecs
    //
    for (int count = 0; count < NumPropSpecs; count++)
    {
        PROPID propId = pPropSpecs[count].propid;
        
        switch (propId)
        {
        case WIA_DPC_PICTURES_TAKEN:
            hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_TAKEN, m_pDeviceInfo->lPicturesTaken);
            break;

        case WIA_DPC_PICTURES_REMAINING:
            hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_REMAINING, m_pDeviceInfo->lPicturesRemaining);
            break;

        default:
            break;
        }
        
        REQUIRE_SUCCESS(hr, "ReadRootItemProperties", "wiasWritePropLong failed");
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\defprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       DefProp.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        30 July, 1998
*
*  DESCRIPTION:
*   Default property Declarations and definitions for the
*   WIA test scanner.
*
*******************************************************************************/

#include  "tcamprop.h"


#define  NUM_CAP_ENTRIES            5
#define  NUM_EVENTS                 3

#define  PREFFERED_FORMAT_NOM       &WiaImgFmt_BMP
#define  FORMAT_NOM                 &WiaImgFmt_BMP

#define  NUM_CAM_ITEM_PROPS         (19)
#define  NUM_CAM_DEV_PROPS          (17)
#define  NUM_AUDIO_PROPS            (6)

#define  NUM_FORMAT                 2
#define  FORMAT_INDEX               10

#ifdef __GLOBALPROPVARS__

PROPID gAudioPropIDs[NUM_AUDIO_PROPS] =
{

    WIA_IPA_ITEM_TIME,
    WIA_IPA_PREFERRED_FORMAT,
    WIA_IPA_ITEM_SIZE,
    WIA_IPA_FORMAT,
    WIA_IPA_TYMED,
    WIA_IPA_ACCESS_RIGHTS,
};

LPOLESTR gAudioPropNames[NUM_AUDIO_PROPS] =
{

    WIA_IPA_ITEM_TIME_STR,
    WIA_IPA_PREFERRED_FORMAT_STR,
    WIA_IPA_ITEM_SIZE_STR,
    WIA_IPA_FORMAT_STR,
    WIA_IPA_TYMED_STR,
    WIA_IPA_ACCESS_RIGHTS_STR,
};

PROPID gItemPropIDs[NUM_CAM_ITEM_PROPS] = {
    WIA_IPA_DATATYPE,
    WIA_IPA_DEPTH,
    WIA_IPA_PIXELS_PER_LINE,
    WIA_IPA_NUMBER_OF_LINES,
    WIA_IPC_THUMBNAIL,
    WIA_IPA_ITEM_TIME,
    WIA_IPC_THUMB_WIDTH,
    WIA_IPC_THUMB_HEIGHT,
    WIA_IPA_PREFERRED_FORMAT,
    WIA_IPA_ITEM_SIZE,
    WIA_IPA_FORMAT,
    WIA_IPA_TYMED,
    WIA_IPA_COMPRESSION,
    WIA_IPA_CHANNELS_PER_PIXEL,
    WIA_IPA_BITS_PER_CHANNEL,
    WIA_IPA_PLANAR,
    WIA_IPA_BYTES_PER_LINE,
    WIA_IPA_ACCESS_RIGHTS,
    WIA_IPA_MIN_BUFFER_SIZE
};

LPOLESTR gItemPropNames[NUM_CAM_ITEM_PROPS] =
{
    WIA_IPA_DATATYPE_STR,
    WIA_IPA_DEPTH_STR,
    WIA_IPA_PIXELS_PER_LINE_STR,
    WIA_IPA_NUMBER_OF_LINES_STR,
    WIA_IPC_THUMBNAIL_STR,
    WIA_IPA_ITEM_TIME_STR,
    WIA_IPC_THUMB_WIDTH_STR,
    WIA_IPC_THUMB_HEIGHT_STR,
    WIA_IPA_PREFERRED_FORMAT_STR,
    WIA_IPA_ITEM_SIZE_STR,
    WIA_IPA_FORMAT_STR,
    WIA_IPA_TYMED_STR,
    WIA_IPA_COMPRESSION_STR,
    WIA_IPA_CHANNELS_PER_PIXEL_STR,
    WIA_IPA_BITS_PER_CHANNEL_STR,
    WIA_IPA_PLANAR_STR,
    WIA_IPA_BYTES_PER_LINE_STR,
    WIA_IPA_ACCESS_RIGHTS_STR,
    WIA_IPA_MIN_BUFFER_SIZE_STR
};

PROPID gItemCameraPropIDs[WIA_NUM_IPC] = {
    WIA_IPC_AUDIO_AVAILABLE,
    WIA_IPC_AUDIO_DATA
};

LPOLESTR gItemCameraPropNames[WIA_NUM_IPC] =
{
    WIA_IPC_AUDIO_AVAILABLE_STR,
    WIA_IPC_AUDIO_DATA_STR,
};

PROPID gDevicePropIDs[NUM_CAM_DEV_PROPS] =
{
    WIA_DPA_FIRMWARE_VERSION,
    WIA_DPA_CONNECT_STATUS,
    WIA_DPA_DEVICE_TIME,
    WIA_DPC_PICTURES_TAKEN,
    WIA_DPC_PICTURES_REMAINING,
    WIA_DPC_THUMB_WIDTH,
    WIA_DPC_THUMB_HEIGHT,
    WIA_DPC_PICT_WIDTH,
    WIA_DPC_PICT_HEIGHT,
    WIA_DPC_EXPOSURE_MODE,
    WIA_DPC_FLASH_MODE,
    WIA_DPC_FOCUS_MODE,
    WIA_DPC_ZOOM_POSITION,
    WIA_DPC_BATTERY_STATUS,
    WIA_DPC_TIMER_MODE,
    WIA_DPC_TIMER_VALUE,
    WIA_DPP_TCAM_ROOT_PATH
};

LPOLESTR gDevicePropNames[NUM_CAM_DEV_PROPS] =
{
    WIA_DPA_FIRMWARE_VERSION_STR,
    WIA_DPA_CONNECT_STATUS_STR,
    WIA_DPA_DEVICE_TIME_STR,
    WIA_DPC_PICTURES_TAKEN_STR,
    WIA_DPC_PICTURES_REMAINING_STR,
    WIA_DPC_THUMB_WIDTH_STR,
    WIA_DPC_THUMB_HEIGHT_STR,
    WIA_DPC_PICT_WIDTH_STR,
    WIA_DPC_PICT_HEIGHT_STR,
    WIA_DPC_EXPOSURE_MODE_STR,
    WIA_DPC_FLASH_MODE_STR,
    WIA_DPC_FOCUS_MODE_STR,
    WIA_DPC_ZOOM_POSITION_STR,
    WIA_DPC_BATTERY_STATUS_STR,
    WIA_DPC_TIMER_MODE_STR,
    WIA_DPC_TIMER_VALUE_STR,
    WIA_DPP_TCAM_ROOT_PATH_STR
};

PROPSPEC gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS] = {

    {PRSPEC_PROPID, WIA_DPA_FIRMWARE_VERSION},
    {PRSPEC_PROPID, WIA_DPA_CONNECT_STATUS},
    {PRSPEC_PROPID, WIA_DPA_DEVICE_TIME},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_TAKEN},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_REMAINING},
    {PRSPEC_PROPID, WIA_DPC_THUMB_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_THUMB_HEIGHT},
    {PRSPEC_PROPID, WIA_DPC_PICT_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_PICT_HEIGHT},
    {PRSPEC_PROPID, WIA_DPC_EXPOSURE_MODE},
    {PRSPEC_PROPID, WIA_DPC_FLASH_MODE},
    {PRSPEC_PROPID, WIA_DPC_FOCUS_MODE},
    {PRSPEC_PROPID, WIA_DPC_ZOOM_POSITION},
    {PRSPEC_PROPID, WIA_DPC_BATTERY_STATUS},
    {PRSPEC_PROPID, WIA_DPC_TIMER_MODE},
    {PRSPEC_PROPID, WIA_DPC_TIMER_VALUE},
    {PRSPEC_PROPID, WIA_DPP_TCAM_ROOT_PATH}
};

WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS] = {
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_FIRMWARE_VERSION
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_CONNECT_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPA_DEVICE_TIME
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICTURES_TAKEN
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICTURES_REMAINING
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICT_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_PICT_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_EXPOSURE_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_FLASH_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_FOCUS_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_ZOOM_POSITION
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_BATTERY_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_TIMER_MODE
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}, // WIA_DPC_TIMER_VALUE
    {WIA_PROP_RW   | WIA_PROP_NONE,    VT_I4, 0,    0,    0,    0}  // WIA_DPP_ROOT_PATH
};

PROPSPEC gPropSpecDefaults[NUM_CAM_ITEM_PROPS] = {
   {PRSPEC_PROPID, WIA_IPA_DATATYPE},
   {PRSPEC_PROPID, WIA_IPA_DEPTH},
   {PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE},
   {PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES},
   {PRSPEC_PROPID, WIA_IPC_THUMBNAIL},
   {PRSPEC_PROPID, WIA_IPA_ITEM_TIME},
   {PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH},
   {PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT},
   {PRSPEC_PROPID, WIA_IPA_PREFERRED_FORMAT},
   {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
   {PRSPEC_PROPID, WIA_IPA_FORMAT},
   {PRSPEC_PROPID, WIA_IPA_TYMED},
   {PRSPEC_PROPID, WIA_IPA_COMPRESSION},
   {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
   {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL},
   {PRSPEC_PROPID, WIA_IPA_PLANAR},
   {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
   {PRSPEC_PROPID, WIA_IPA_ACCESS_RIGHTS},
   {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE},
};

#ifdef _WIN64
#define FPTR(x) (LONG_PTR)NULL
#else
#define FPTR(x) x
#endif

PROPSPEC gAudioPropDefaults[NUM_AUDIO_PROPS] =
{

    {PRSPEC_PROPID, WIA_IPA_ITEM_TIME},
    {PRSPEC_PROPID,WIA_IPA_PREFERRED_FORMAT},
    {PRSPEC_PROPID,WIA_IPA_ITEM_SIZE},
    {PRSPEC_PROPID,WIA_IPA_FORMAT},
    {PRSPEC_PROPID,WIA_IPA_TYMED},
    {PRSPEC_PROPID,WIA_IPA_ACCESS_RIGHTS},
};

LONG gAudioDefaults[(sizeof(PROPVARIANT) / sizeof(LONG)) * (NUM_AUDIO_PROPS)] =
{
    VT_VECTOR | VT_I4, 0, 0, 0,
    VT_CLSID, 0, (LONG)(LONG_PTR)FPTR(&WiaAudFmt_WAV), 0,
    VT_I4, 0, 0, 0,
    VT_CLSID, 0, (LONG)(LONG_PTR)FPTR(&WiaAudFmt_WAV), 0,
    VT_I4, 0, TYMED_FILE, 0,
    VT_I4, 0, WIA_ITEM_RD, 0
};


LONG  gPropVarDefaults[(sizeof(PROPVARIANT) / sizeof(LONG)) * (NUM_CAM_ITEM_PROPS)] = {
   // VARTYPE                 reserved    val               pad/array ptr
   (LONG)VT_I4,               0x00000000, WIA_DATA_GRAYSCALE,0x00000000,            // WIA_IPA_DATATYPE
   (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_DEPTH

   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_PIXELS_PER_LINE
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_NUMBER_OF_LINES

   (LONG)VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMBNAIL
   (LONG)VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_TIME
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_WIDTH
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_HEIGHT
   (LONG)VT_CLSID,            0x00000000, (LONG)(LONG_PTR)FPTR(PREFFERED_FORMAT_NOM),0x00000000,    // WIA_IPA_PREFERRED_FORMAT
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_SIZE
   (LONG)VT_CLSID,            0x00000000, (LONG)(LONG_PTR)FPTR(FORMAT_NOM),  0x00000000,            // WIA_IPA_FORMAT
   (LONG)VT_I4,               0x00000000, TYMED_FILE,        0x00000000,            // WIA_IPA_TYMED
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_COMPRESSION
   (LONG)VT_I4,               0x00000000, 3,                 0x00000000,            // WIA_IPA_CHANNELS PER PIXEL
   (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_BITS PER CHANNEL
   (LONG)VT_I4,               0x00000000, WIA_PACKED_PIXEL,  0x00000000,            // WIA_IPA_PLANAR
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_WIDTH IN BYTES
   (LONG)VT_I4,               0x00000000, WIA_ITEM_RD,       0x00000000,             // WIA_IPA_ACCESS_RIGHTS

   (LONG)VT_I4,               0x00000000, 65535,             0x00000000,            // WIA_IPA_MIN_BUFFER_SIZE
};


// Default device extended properties.

#define NUM_DATATYPE 3
LONG lDataTypes[NUM_DATATYPE] = {
    WIA_DATA_THRESHOLD,
    WIA_DATA_GRAYSCALE,
    WIA_DATA_COLOR
};

#define NUM_DEPTH 3
LONG lDepths[NUM_DEPTH] = {
    1,
    8,
    24
};


GUID gGuidFormats[NUM_FORMAT];   // FormatID's specified in pguidFormats are copied to gGuidFormats
                                  // during SetFormatAttribs

//
//  This is an array of WIA_FORMAT_INFOs, describing the different formats
//  and their corresponding media types.  Initialized in minidrvr.cpp
//

WIA_FORMAT_INFO  *g_wfiTable = NULL;

//
//  Different media types supported
//

#define NUM_TYMED  2
LONG lTymeds [NUM_TYMED]= {
    TYMED_FILE,
    TYMED_CALLBACK,
};

//
// Extended information for each property
//

WIA_PROPERTY_INFO  gItemPropInfos[NUM_CAM_ITEM_PROPS] = {

    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DATATYPE, WIA_DATA_GRAYSCALE, (LONG)FPTR( lDataTypes), 0}, // WIA_IPA_DATATYPE
    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DEPTH,    8,                  (LONG)FPTR( lDepths),    0}, // WIA_IPA_DEPTH

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PIXELS_PER_LINE
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_NUMBER_OF_LINES
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMBNAIL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_TIME
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_PREFERRED_FORMAT, set later
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_SIZE

    {WIA_PROP_RW   | WIA_PROP_LIST, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_FORMAT, set later
    {WIA_PROP_RW   | WIA_PROP_LIST, VT_I4,    NUM_TYMED,    TYMED_FILE, (LONG)FPTR(lTymeds),     0}, // WIA_IPA_TYMED
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_COMPRESSION
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_CHANNELS
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BITS_PER_CHANNEL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PLANAR
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BYTES_PER_LINE
    {WIA_PROP_RW   | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ACCESS_RIGHTS

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_MIN_BUFFER_SIZE

};

//
// Device capabilities.  Events are listed before commands to simplify the
// implementation of drvGetCapabilities(...)
//

#define N   WIA_NOTIFICATION_EVENT
#define A   WIA_ACTION_EVENT
#define NA  (WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT)

WIA_DEV_CAP_DRV gCapabilities[NUM_CAP_ENTRIES] =
{
    {(GUID *)&WIA_EVENT_DEVICE_CONNECTED,    NA, L"Device connected",    L"Device connected",    WIA_ICON_DEVICE_CONNECTED},
    {(GUID *)&WIA_EVENT_DEVICE_DISCONNECTED, N,  L"Device disconnected", L"Device disconnected", WIA_ICON_DEVICE_DISCONNECTED},
    {(GUID *)&WIA_EVENT_NAME_CHANGE,         NA, L"Root path changed",   L"Root path changed",   WIA_ICON_ITEM_CREATED},
    {(GUID *)&WIA_CMD_SYNCHRONIZE,           0,  L"Synchronize",         L"Synchronize",         WIA_ICON_SYNCHRONIZE},
    {(GUID *)&WIA_CMD_TAKE_PICTURE,          0,  L"Take a new picture",  L"Take a new picture",  WIA_ICON_TAKE_PICTURE}
};

#else

extern PROPID               gItemPropIDs[NUM_CAM_ITEM_PROPS];
extern LPOLESTR             gItemPropNames[NUM_CAM_ITEM_PROPS];
extern PROPID               gItemCameraPropIDs[WIA_NUM_IPC];
extern LPOLESTR             gItemCameraPropNames[WIA_NUM_IPC];
extern PROPID               gDevicePropIDs[NUM_CAM_DEV_PROPS];
extern LPOLESTR             gDevicePropNames[NUM_CAM_DEV_PROPS];
extern PROPSPEC             gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS];
extern WIA_PROPERTY_INFO    gDevPropInfoDefaults[NUM_CAM_DEV_PROPS];
extern PROPSPEC             gPropSpecDefaults[NUM_CAM_ITEM_PROPS];
extern LONG                 gPropVarDefaults[];
extern WIA_PROPERTY_INFO    gItemPropInfos[NUM_CAM_ITEM_PROPS];
extern WIA_DEV_CAP_DRV      gCapabilities[];
extern GUID                 gGuidFormats[NUM_FORMAT];
extern PROPID               gAudioPropIDs[NUM_AUDIO_PROPS];
extern LPOLESTR             gAudioPropNames[NUM_AUDIO_PROPS];
extern PROPSPEC             gAudioPropDefaults [];
extern LONG                 gAudioDefaults [];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiacam.rc
//

// Device Events, and Commands (Name strings)
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_EVENT_ITEM_DELETED_NAME        104
#define IDS_CMD_SYNCRONIZE_NAME            105
#define IDS_CMD_DELETE_ALL_ITEMS_NAME      106
#define IDS_CMD_DELETE_DEVICE_TREE_NAME    107
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     108

// Device Events, and Commands (Description strings)
#define IDS_EVENT_DEVICE_CONNECTED_DESC    109
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 110
#define IDS_EVENT_ITEM_DELETED_DESC        111
#define IDS_CMD_SYNCRONIZE_DESC            112
#define IDS_CMD_DELETE_ALL_ITEMS_DESC      113
#define IDS_CMD_DELETE_DEVICE_TREE_DESC    114
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     115

#define IDS_FULLROOTITEM_NAME              116
#define IDS_ROOTITEM_NAME                  117
#define IDS_FULLTOPITEM_NAME               118
#define IDS_TOPITEM_NAME                   119

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           120
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\wiacam.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiacam.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*
*
***************************************************************************/

#pragma once

//
// Globals
//
extern HINSTANCE  g_hInst;     // DLL module instance

//
// Driver item context
//
typedef struct _ITEM_CONTEXT{
    MCAM_ITEM_INFO     *pItemInfo;      // Handle to the camera item
    BOOL                bItemChanged;   // Indicates the item has changed on the device
    LONG                lNumFormatInfo; // Number of entries in format info array
    WIA_FORMAT_INFO    *pFormatInfo;    // Pointer to format info array 
} ITEM_CONTEXT, *PITEM_CONTEXT;

//
// Handy constants for common item types
//
const LONG ITEMTYPE_FILE   = WiaItemTypeFile;
const LONG ITEMTYPE_IMAGE  = WiaItemTypeFile | WiaItemTypeImage;
const LONG ITEMTYPE_AUDIO  = WiaItemTypeFile | WiaItemTypeAudio;
const LONG ITEMTYPE_VIDEO  = WiaItemTypeFile | WiaItemTypeVideo;
const LONG ITEMTYPE_FOLDER = WiaItemTypeFolder;
const LONG ITEMTYPE_BURST  = WiaItemTypeFolder | WiaItemTypeBurst;
const LONG ITEMTYPE_HPAN   = WiaItemTypeFolder | WiaItemTypeHPanorama;
const LONG ITEMTYPE_VPAN   = WiaItemTypeFolder | WiaItemTypeVPanorama;

//
// Minimum data call back transfer buffer size
//
const LONG MIN_BUFFER_SIZE   = 0x8000;

//
// When doing a transfer and convert to BMP, this value
// represents how much of the time is spent doing the
// transfer of data from the device.
//
const LONG TRANSFER_PERCENT = 90;

//
// Base structure for supporting non-delegating IUnknown for contained objects
//
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD (NonDelegatingQueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef) (THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease) (THIS) PURE;
};

//
// Class definition for sample WIA scanner object
//
class CWiaCameraDevice : public IStiUSD,               // STI USD interface
                         public IWiaMiniDrv,           // WIA Minidriver interface
                         public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWiaCameraDevice(LPUNKNOWN punkOuter);
    ~CWiaCameraDevice();

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHODIMP Initialize(PSTIDEVICECONTROL pHelDcb, DWORD dwStiVersion, HKEY hParametersKey);
    STDMETHODIMP GetCapabilities(PSTI_USD_CAPS pDevCaps);
    STDMETHODIMP GetStatus(PSTI_DEVICE_STATUS pDevStatus);
    STDMETHODIMP DeviceReset();
    STDMETHODIMP Diagnostic(LPDIAG pBuffer);
    STDMETHODIMP Escape(STI_RAW_CONTROL_CODE EscapeFunction, LPVOID lpInData, DWORD cbInDataSize,
                        LPVOID pOutData, DWORD dwOutDataSize, LPDWORD pdwActualData);
    STDMETHODIMP GetLastError(LPDWORD pdwLastDeviceError);
    STDMETHODIMP LockDevice();
    STDMETHODIMP UnLockDevice();
    STDMETHODIMP RawReadData(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteData(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawReadCommand(LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteCommand(LPVOID lpBuffer, DWORD nNumberOfBytes, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNotificationHandle(HANDLE hEvent);
    STDMETHODIMP GetNotificationData(LPSTINOTIFY lpNotify);
    STDMETHODIMP GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHODIMP drvInitializeWia(BYTE *pWiasContext, LONG lFlags, BSTR bstrDeviceID, BSTR bstrRootFullItemName,
                                  IUnknown *pStiDevice, IUnknown *pIUnknownOuter, IWiaDrvItem  **ppIDrvItemRoot,
                                  IUnknown **ppIUnknownInner, LONG *plDevErrVal);
    STDMETHODIMP drvUnInitializeWia(BYTE* pWiasContext);
    STDMETHODIMP drvDeviceCommand(BYTE *pWiasContext, LONG lFlags, const GUID *pGUIDCommand,
                                  IWiaDrvItem **ppMiniDrvItem, LONG *plDevErrVal);
    STDMETHODIMP drvDeleteItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetCapabilities(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                    WIA_DEV_CAP_DRV **ppCapabilities, LONG *plDevErrVal);
    STDMETHODIMP drvInitItemProperties(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvLockWiaDevice(BYTE  *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvUnLockWiaDevice(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvAnalyzeItem(BYTE *pWiasContext, LONG lFlags, LONG *plDevErrVal);
    STDMETHODIMP drvGetWiaFormatInfo(BYTE *pWiasContext, LONG lFlags, LONG *pCelt,
                                     WIA_FORMAT_INFO **ppwfi, LONG *plDevErrVal);
    STDMETHODIMP drvNotifyPnpEvent(const GUID *pEventGUID, BSTR bstrDeviceID, ULONG ulReserved);
    STDMETHODIMP drvReadItemProperties(BYTE *pWiaItem, LONG lFlags, ULONG nPropSpec,
                                       const PROPSPEC *pPropSpec, LONG  *plDevErrVal);
    STDMETHODIMP drvWriteItemProperties(BYTE *pWiasContext, LONG lFLags,
                                        PMINIDRV_TRANSFER_CONTEXT pmdtc, LONG *plDevErrVal);
    STDMETHODIMP drvValidateItemProperties(BYTE *pWiasContext, LONG lFlags, ULONG nPropSpec,
                                           const PROPSPEC *pPropSpec, LONG *plDevErrVal);
    STDMETHODIMP drvAcquireItemData(BYTE *pWiasContext, LONG lFlags,
                                    PMINIDRV_TRANSFER_CONTEXT pDataContext, LONG *plDevErrVal);
    STDMETHODIMP drvGetDeviceErrorStr(LONG lFlags, LONG lDevErrVal, LPOLESTR *ppszDevErrStr, LONG *plDevErrVal);
    STDMETHODIMP drvFreeDrvItemContext(LONG lFlags, BYTE *pDevContext, LONG *plDevErrVal);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    VOID RunNotifications(VOID);

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////

    HRESULT FreeResources();
    HRESULT GetOLESTRResourceString(LONG lResourceID, LPOLESTR *ppsz);

    //
    // WIA Item Management Helpers
    //
    HRESULT BuildItemTree(MCAM_ITEM_INFO *pItem);
    HRESULT AddObject(MCAM_ITEM_INFO *pItem);
    HRESULT ConstructFullName(MCAM_ITEM_INFO *pItemInfo, WCHAR *pwszFullName, INT cchFullNameSize);
    HRESULT LinkToParent(MCAM_ITEM_INFO *pItem, BOOL bQueueEvent = FALSE);
    HRESULT DeleteItemTree(LONG lReason);

    //
    // WIA Property Management Helpers
    //
    HRESULT BuildRootItemProperties(BYTE *pWiasContext);
    HRESULT ReadRootItemProperties(BYTE *pWiasContext, LONG lNumPropSpecs, const PROPSPEC *pPropSpecs);
    
    HRESULT BuildChildItemProperties(BYTE *pWiasContext);
    HRESULT GetValidFormats(BYTE *pWiasContext, LONG lTymedValue, INT *piNumFormats, GUID **ppFormatArray);
    HRESULT ReadChildItemProperties(BYTE *pWiasContext, LONG lNumPropSpecs, const PROPSPEC *pPropSpecs);
    HRESULT AcquireData(ITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc,
                        BYTE *pBuf, LONG lBufSize, BOOL bConverting);
    HRESULT Convert(BYTE *pWiasContext, ITEM_CONTEXT *pItemCtx, PMINIDRV_TRANSFER_CONTEXT pmdtc,
                    BYTE *pNativeImage, LONG lNativeSize);

    //
    // WIA Capability Management Helpers
    //
    HRESULT BuildCapabilities();
    HRESULT DeleteCapabilitiesArrayContents();

private:

    // COM object data
    ULONG                m_cRef;                  // Device object reference count
    LPUNKNOWN            m_punkOuter;             // Pointer to outer unknown

    // STI data
    PSTIDEVICECONTROL    m_pIStiDevControl;       // Device control interface
    IStiDevice          *m_pStiDevice;            // Sti object
    DWORD                m_dwLastOperationError;  // Last error
    WCHAR                m_wszPortName[MAX_PATH]; // Port name for accessing the device

    // WIA data
    BSTR                 m_bstrDeviceID;          // WIA unique device ID
    BSTR                 m_bstrRootFullItemName;  // Root item name
    IWiaDrvItem         *m_pRootItem;             // Root item

    LONG                 m_lNumSupportedCommands; // Number of supported commands
    LONG                 m_lNumSupportedEvents;   // Number of supported events
    LONG                 m_lNumCapabilities;      // Number of capabilities
    WIA_DEV_CAP_DRV     *m_pCapabilities;         // Capabilities array

    // Device data
    CCamMicro           *m_pDevice;               // Pointer to DLL wrapper class
    MCAM_DEVICE_INFO    *m_pDeviceInfo;           // Device information
    
    // Misc data
    INT                  m_iConnectedApps;        // Number of app connected to this driver
    CWiauFormatConverter m_Converter;
};

typedef CWiaCameraDevice *PWIACAMERADEVICE;

/***************************************************************************\
*
*  CWiaCameraDeviceClassFactory
*
\****************************************************************************/

class CWiaCameraDeviceClassFactory : public IClassFactory
{
public:
    CWiaCameraDeviceClassFactory();
    ~CWiaCameraDeviceClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP CreateInstance(IUnknown __RPC_FAR *pUnkOuter, REFIID riid,
                                void __RPC_FAR *__RPC_FAR *ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

private:
    ULONG   m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\camevent.cpp ===
/*++

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    camevent.cpp

Abstract:

    Enumerate disk images to emulate camera

Environment:

    user mode

Revision History:

--*/

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "testusd.h"
#include "tcamprop.h"
#include "resource.h"

extern HINSTANCE g_hInst; // Global hInstance

CAM_EVENT gCamEvent[] = {

    {
        TEXT("Pathname Change"),
        &WIA_EVENT_NAME_CHANGE
    },
    {
        TEXT("Disconnect"),
        &WIA_EVENT_DEVICE_DISCONNECTED
    },
    {
        TEXT("Connect"),
        &WIA_EVENT_DEVICE_CONNECTED
    }
};

TCHAR   gpszPath[MAX_PATH];


/**************************************************************************\
* CameraEventDlgProc
*
*
* Arguments:
*
*   hDlg
*   message
*   wParam
*   lParam
*
* Return Value:
*
*    Status
*
* History:
*
*    1/11/1999 Original Version
*
\**************************************************************************/

BOOL  _stdcall
CameraEventDlgProc(
   HWND       hDlg,
   unsigned   message,
   DWORD      wParam,
   LONG       lParam
   )

/*++

Routine Description:

   Process message for about box, show a dialog box that says what the
   name of the program is.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    //
    // Setting pDevice to a LONG will not work on 64-bit. Since this dialog is going away soon, just
    // comment out this function for now.
    //
#if 0
    static TestUsdDevice *pDevice;

    switch (message) {
    case WM_INITDIALOG:
        {
            //
            // get event list from device
            //
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 0, (LPARAM)gCamEvent[0].pszEvent);
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 1, (LPARAM)gCamEvent[1].pszEvent);
            SendDlgItemMessage(
                hDlg,
                IDC_COMBO1,
                CB_INSERTSTRING, 2, (LPARAM)gCamEvent[2].pszEvent);

            SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, 0, 0);

            pDevice = (TestUsdDevice *)lParam;
            pDevice->m_hDlg = hDlg;

            SetDlgItemText(hDlg, IDC_EDIT1, gpszPath);

        }
        break;

    case WM_COMMAND:
        switch(wParam) {

            case IDCANCEL:
            case IDOK:
                {
                    //if (IDYES == MessageBox( hDlg, TEXT("Are you sure you want to close the event dialog?"), TEXT("Test Camera"), MB_ICONQUESTION|MB_YESNOCANCEL ))
                        EndDialog( hDlg, wParam );
                }
                break;

            case IDD_GEN_EVENT:
                {
                    //
                    // if event is not already set
                    //

                    //
                    // get selected
                    //

                    LRESULT i = SendDlgItemMessage(
                                hDlg,
                                IDC_COMBO1,
                                CB_GETCURSEL, 0, 0);

                    pDevice->m_guidLastEvent = *gCamEvent[i].pguid;

                    //
                    // private event
                    //

                    if (IsEqualIID(
                            pDevice->m_guidLastEvent, WIA_EVENT_NAME_CHANGE)) {

                        UINT ui = GetDlgItemText(
                                      hDlg, IDC_EDIT1, gpszPath, MAX_PATH);
                    }

                    wiasQueueEvent (pDevice->m_bstrDeviceID, &pDevice->m_guidLastEvent, NULL);
                    WIAS_TRACE((g_hInst,"TestUsdDevice::TestUsdDevice"));
                    return (TRUE);
                }
        }
        break;
    }

    return (FALSE);
#endif

    if (message == WM_COMMAND &&
        (wParam == IDCANCEL ||
         wParam == IDOK))
        EndDialog( hDlg, wParam );

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\microsft\wiacam\wiacam.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiacam.cpp
*
*  VERSION:     1.0
*
*  DATE:        16 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA Sample camera class factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"

#ifndef INITGUID
#include <initguid.h>
#endif

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

HINSTANCE g_hInst;  // DLL module instance.

//
// This clsid will eventually be in uuid.lib, at which point it should be removed
// from here.
//
// {0C9BB460-51AC-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiUSD, 0x0C9BB460L, 0x51AC, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

//
// Class ID for this WIA minidriver. Change this GUID here and in the
// INF for your driver.
//
DEFINE_GUID(CLSID_SampleWIACameraDevice, 
            0x8e3f2bae, 0xc8ff, 0x4eff, 0xaa, 0xbd, 0xc, 0x58, 0x69, 0x53, 0x89, 0xe8);


/**************************************************************************\
* CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDeviceClassFactory::CWiaCameraDeviceClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::~CWiaCameraDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

CWiaCameraDeviceClassFactory::~CWiaCameraDeviceClassFactory(void)
{
    // Destructor logic
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDeviceClassFactory::AddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDeviceClassFactory::Release(void)
{
    ULONG ulRef = 0;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    HRESULT hr = S_OK;
    CWiaCameraDevice   *pDev = NULL;

    pDev = new CWiaCameraDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hr = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hr;
}

/**************************************************************************\
* CWiaCameraDeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDeviceClassFactory::LockServer(BOOL fLock)
{
    return NOERROR;
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    LPVOID  *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hr =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hr)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hr;
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWiaCameraDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::NonDelegatingRelease(void)
{
    ULONG ulRef = 0;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWiaCameraDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP CWiaCameraDevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWiaCameraDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWiaCameraDevice::Release
*
*
*
* Arguments:
*
*    None
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWiaCameraDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
\**************************************************************************/


extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            
            break;

        case DLL_PROCESS_DETACH:
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if (!IsEqualCLSID(rclsid, CLSID_SampleWIACameraDevice) ) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return E_NOINTERFACE;
    }

    if (IsEqualCLSID(rclsid, CLSID_SampleWIACameraDevice)) {
        CWiaCameraDeviceClassFactory *pcf = new CWiaCameraDeviceClassFactory;
        if (!pcf) {
            return E_OUTOFMEMORY;
        }
        *ppv = (LPVOID)pcf;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\tcamprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       TCamProp.H
*
*  VERSION:     1.0
*
*  DATE:        16 May, 1999
*
*  DESCRIPTION:
*   Definitions and declarations for test camera's private properties.
*
*******************************************************************************/

#ifndef __TCAMPROP_H__
#define __TCAMPROP_H__

#include  <guiddef.h>

//
// Path where test camera builds its item tree, BSTR & RW
//

#define  WIA_DPP_TCAM_ROOT_PATH         WIA_PRIVATE_DEVPROP
#define  WIA_DPP_TCAM_ROOT_PATH_STR     L"Test Camera Root Path"

//
// Private event after the Root Path is changed
//

const GUID WIA_EVENT_NAME_CHANGE =
{ /* 88f80f75-af08-11d2-a094-00c04f72dc3c */
    0x88f80f75,
    0xaf08,
    0x11d2,
    {0xa0, 0x94, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\camopen.cpp ===
/*++

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    camopen.cpp

Abstract:

    Enumerate disk images to emulate camera

Author:

    Mark Enstrom (marke) 1/13/1999


Environment:

    user mode

Revision History:

--*/

#include <stdio.h>
#include <objbase.h>
#include <tchar.h>
#include "sti.h"
#include "testusd.h"

extern HINSTANCE g_hInst; // Global hInstance

#define  __GLOBALPROPVARS__

#include "defprop.h"

/**************************************************************************\
* CamOpenCamera
*
*   Load the camera driver
*
* Arguments:
*
*   pGenericStatus    -    camera status
*
* Return Value:
*
*   status
*
* History:
*
*    2/5/1998        Mark Enstrom [marke]
*
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamOpenCamera(
    CAMERA_STATUS *pGenericStatus
    )
{
    HRESULT  hr = S_OK;

    WIAS_TRACE((g_hInst,"CamOpenCamera"));

    //
    // init memory camera
    //

    pGenericStatus->FirmwareVersion            = 0x00000001;
    pGenericStatus->NumPictTaken               = 20;
    pGenericStatus->NumPictRemaining           = 0;
    pGenericStatus->ThumbWidth                 = 80;
    pGenericStatus->ThumbHeight                = 60;
    pGenericStatus->PictWidth                  = 300;
    pGenericStatus->PictHeight                 = 300;
    pGenericStatus->CameraTime.wSecond         = 30;
    pGenericStatus->CameraTime.wMinute         = 20;
    pGenericStatus->CameraTime.wHour           = 13;
    pGenericStatus->CameraTime.wDay            = 13;
    pGenericStatus->CameraTime.wMonth          = 2;
    pGenericStatus->CameraTime.wYear           = 98;
    pGenericStatus->CameraTime.wDayOfWeek      = 6;
    pGenericStatus->CameraTime.wMilliseconds   = 1;

    return(hr);
}


/**************************************************************************\
* CamBuildImageTree
*
*    Build the tree of camera images by enumerating a disk directory
*
* Arguments:
*
*    pCamStatus  -    device status
*    ppRootItem  -    return new root of item tree
*
* Return Value:
*
*    status
*
* History:
*
*    6/26/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::CamBuildImageTree(
    CAMERA_STATUS   *pCamStatus,
    IWiaDrvItem    **ppRootItem)
{
    HRESULT          hr = S_OK;

    WIAS_TRACE((g_hInst,"CamBuildImageTree"));

    //
    // Create the new root
    //

    BSTR bstrRoot = SysAllocString(L"Root");

    if (bstrRoot == NULL) {
        return E_OUTOFMEMORY;
    }

    //
    // Call Wia service library to create new root item
    //

    hr = wiasCreateDrvItem(
             WiaItemTypeFolder | WiaItemTypeRoot | WiaItemTypeDevice,
             bstrRoot,
             m_bstrRootFullItemName,
             (IWiaMiniDrv *)this,
             sizeof(MEMCAM_IMAGE_CONTEXT),
             NULL,
             ppRootItem);

    SysFreeString(bstrRoot);

    if (FAILED(hr)) {
        WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, CreateDeviceItem failed"));
        return hr;
    }

    //
    // Enumerate throught the root directory
    //

    hr = EnumDiskImages(*ppRootItem, gpszPath);

    return (hr);
}

/**************************************************************************\

   FindExtension

**************************************************************************/

LPTSTR
FindExtension (LPTSTR pszPath)
{

    LPTSTR pszDot = NULL;

    if (pszPath)
    {
        for (; *pszPath; pszPath = CharNext(pszPath))
        {
            switch (*pszPath)
            {
                case TEXT('.'):
                    pszDot = pszPath;   // remember the last dot
                    break;

                case '\\':
                case TEXT(' '):         // extensions can't have spaces
                    pszDot = NULL;      // forget last dot, it was in a directory
                    break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension)
    return pszDot ? pszDot : pszPath;
}

/**************************************************************************\
* EnumDiskImages
*
*   Walk through disk looking for BMP and WAV files to use as camera images
*
* Arguments:
*
*   pRootItem
*   pwszDirName
*
* Return Value:
*
*   status
*
* History:
*
*    2/17/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::EnumDiskImages(
    IWiaDrvItem     *pRootItem,
    LPTSTR           pszDirName)
{
    HRESULT          hr = E_FAIL;
    WIN32_FIND_DATA  FindData;
    PTCHAR           pTempName = (PTCHAR)ALLOC(MAX_PATH);

    WIAS_TRACE((g_hInst,"EnumDiskImages"));

    if (pTempName != NULL) {

        HANDLE hFile;
        _tcscpy(pTempName, pszDirName);
        _tcscat(pTempName, TEXT("\\*.*"));

        //
        // look for image,audio files and directories at this level
        //

        hFile = FindFirstFile(pTempName, &FindData);

        if (hFile != INVALID_HANDLE_VALUE) {
            BOOL bStatus;
            do
            {

                _tcscpy(pTempName, pszDirName);
                _tcscat(pTempName, TEXT("\\"));
                _tcscat(pTempName, FindData.cFileName);

                if ( (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    && lstrcmp(FindData.cFileName, TEXT("."))
                     && lstrcmp(FindData.cFileName, TEXT("..")))

                {
                    //
                    // create a new folder for the sub-directory
                    //
                    IWiaDrvItem *pNewFolder;

                    hr = CreateItemFromFileName(
                        WiaItemTypeFolder,
                        pTempName,
                        FindData.cFileName,
                        &pNewFolder);

                    if (SUCCEEDED(hr)) {

                        hr = pNewFolder->AddItemToFolder(pRootItem);


                        if (hr == S_OK) {
                            //
                            // enumerate sub-folder
                            //

                            EnumDiskImages(pNewFolder, pTempName);
                        }
                        pNewFolder->Release();
                    }
                }
                else
                {
                    LONG lType = WiaItemTypeFile;
                    //
                    // add an image to this folder
                    //
                    // generate file name
                    //
                    //
                    // Create a new DrvItem for this image and add it to the
                    // DrvItem tree.
                    //
                    LPTSTR pExt = FindExtension (FindData.cFileName);
                    if (!lstrcmpi(pExt, TEXT(".bmp")))
                    {
                        lType |= WiaItemTypeImage;
                    }
                    else if (!lstrcmpi(pExt,TEXT(".wav")))
                    {
                        lType |= WiaItemTypeAudio;
                    }
                    else
                    {
                        lType = 0;
                    }
                    if (lType)
                    {

                        IWiaDrvItem *pNewFolder;

                        hr = CreateItemFromFileName(
                            lType,
                            pTempName,
                            FindData.cFileName,
                            &pNewFolder);


                        if (SUCCEEDED(hr)) {
                            pNewFolder->AddItemToFolder(pRootItem);

                            pNewFolder->Release();
                        }
                    }
                }

                bStatus = FindNextFile(hFile,&FindData);

            } while (bStatus);

            FindClose(hFile);
        }
        FREE(pTempName);
    }

    return (S_OK);
}


/**************************************************************************\
* CreateItemFromFileName
*
*    helper funtion to create dev items and names
*
* Arguments:
*
*    FolderType    -    type of item to create
*    pszPath        -    complete path name
*    pszName        -    file name
*    ppNewFolder    -    return new item
*
* Return Value:
*
*   status
*
* History:
*
*    1/17/1999 Mark Enstrom [marke]
*
\**************************************************************************/


HRESULT
TestUsdDevice::CreateItemFromFileName(
    LONG             FolderType,
    PTCHAR           pszPath,
    PTCHAR           pszName,
    IWiaDrvItem    **ppNewFolder
    )
{
    HRESULT          hr = S_OK;
    IWiaDrvItem     *pNewFolder;
    WCHAR            szFullItemName[MAX_PATH];
    WCHAR            szTemp[MAX_PATH];
    BSTR             bstrItemName;
    BSTR             bstrFullItemName;

    WIAS_TRACE((g_hInst,"CreateItemFromFileName"));

    *ppNewFolder = NULL;

    //
    // convert path to wide char
    //

#ifndef UNICODE
    MultiByteToWideChar(
        CP_ACP,
        0,
        pszPath + strlen(gpszPath),
        -1,
        szTemp, MAX_PATH);

#else
    wcscpy(szTemp, pszPath + wcslen(gpszPath));
#endif
    if (FolderType & ~WiaItemTypeFolder) {
        szTemp[_tcslen(pszPath) - _tcslen(gpszPath) - 4] = 0;
    }

    wcscpy(szFullItemName, m_bstrRootFullItemName);
    wcscat(szFullItemName, szTemp);

    //
    // convert item name to wide char
    //

#ifndef UNICODE
    MultiByteToWideChar(
        CP_ACP, 0, pszName, -1,  szTemp, MAX_PATH);
#else
    wcscpy(szTemp, pszName);
#endif
    if (FolderType & ~WiaItemTypeFolder) {
        szTemp[_tcslen(pszName)-4] = 0;
    }

    bstrItemName = SysAllocString(szTemp);

    if (bstrItemName) {

        bstrFullItemName = SysAllocString(szFullItemName);

        if (bstrFullItemName) {

            //
            // call Wia to create new DrvItem
            //

            PMEMCAM_IMAGE_CONTEXT pContext;

            hr = wiasCreateDrvItem(
                     FolderType,
                     bstrItemName,
                     bstrFullItemName,
                     (IWiaMiniDrv *)this,
                     sizeof(MEMCAM_IMAGE_CONTEXT),
                     (BYTE **)&pContext,
                     &pNewFolder);

            if (hr == S_OK) {

                //
                // init device specific context (image path)
                //

                pContext->pszCameraImagePath = _tcsdup(pszPath);

            } else {
                WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, wiasCreateDrvItem failed"));
            }

            SysFreeString(bstrFullItemName);
        }
        else {
            WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, unable to allocate full item name"));
            hr = E_OUTOFMEMORY;
        }

        SysFreeString(bstrItemName);
    }
    else {
        WIAS_ERROR((g_hInst,"ddevBuildDeviceItemTree, unable to allocate item name"));
        hr = E_OUTOFMEMORY;
    }

    //
    // assign output value or cleanup
    //

    if (hr == S_OK) {
        *ppNewFolder = pNewFolder;
    } else {
        //
        // delete item
        //
    }

    return hr;
}

/**************************************************************************\
* GetItemSize
*
*   call wias to calc new item size
*
* Arguments:
*
*   pWiasContext       - item
*   pItemSize   - return size of item
*
* Return Value:
*
*    Status
*
* History:
*
*    4/21/1999 Original Version
*
\**************************************************************************/

HRESULT
SetItemSize(BYTE*   pWiasContext)
{
    HRESULT                    hr;
    MINIDRV_TRANSFER_CONTEXT   drvTranCtx;

    memset(&drvTranCtx, 0, sizeof(MINIDRV_TRANSFER_CONTEXT));

    GUID guidFormatID;

    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, (GUID*)&drvTranCtx.guidFormatID, NULL, FALSE);
    if (FAILED(hr)) {
        return hr;
    }

    hr = wiasReadPropLong(pWiasContext, WIA_IPA_TYMED, (LONG*)&drvTranCtx.tymed, NULL, false);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // wias works for DIB,TIFF formats
    //
    // driver doesn't support JPEG
    //

    hr = wiasGetImageInformation(pWiasContext,
                                 WIAS_INIT_CONTEXT,
                                 &drvTranCtx);

    if (hr == S_OK) {
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_ITEM_SIZE, drvTranCtx.lItemSize);
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_BYTES_PER_LINE, drvTranCtx.cbWidthInBytes);
    }

    return hr;
}

/**************************************************************************\
* InitImageInformation
*
*    Init image properties
*
* Arguments:
*
*    pFile                 MINI_DEV_OBJECT to support item
*    pszCameraImagePath    path and name of bmp file
*
* Return Value:
*
*   Status
*
* History:
*
*    2/12/1998 Mark Enstrom [marke]
*
\**************************************************************************/

HRESULT
TestUsdDevice::InitImageInformation(
    BYTE                   *pWiasContext,
    PMEMCAM_IMAGE_CONTEXT   pContext,
    LONG                   *plDevErrVal)
{
    HRESULT                  hr = S_OK;
    CAMERA_PICTURE_INFO      camInfo;
    PBITMAPINFO              pBitmapinfo   = NULL;
    LONG                     szBitmapInfo  = 0;
    int                      i;
    PROPVARIANT              propVar;

    WIAS_TRACE((g_hInst,"InitImageInformation"));

    //
    // GET image info
    //

    hr = CamGetPictureInfo(
             pContext, &camInfo, (PBYTE*)&pBitmapinfo, &szBitmapInfo);

    if (hr != S_OK) {

        if (pBitmapinfo != NULL) {
            FREE(pBitmapinfo);
        }

        return (hr);
    }


    //
    // Use WIA services to write image properties.
    //

    wiasWritePropLong(pWiasContext, WIA_IPC_THUMB_WIDTH, camInfo.ThumbWidth);
    wiasWritePropLong(pWiasContext, WIA_IPC_THUMB_HEIGHT, camInfo.ThumbHeight);

    wiasWritePropLong(
        pWiasContext, WIA_IPA_PIXELS_PER_LINE, pBitmapinfo->bmiHeader.biWidth);
    wiasWritePropLong(
        pWiasContext, WIA_IPA_NUMBER_OF_LINES, pBitmapinfo->bmiHeader.biHeight);



    wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, WiaImgFmt_BMP);

    wiasWritePropLong(
        pWiasContext, WIA_IPA_DEPTH, pBitmapinfo->bmiHeader.biBitCount);

    wiasWritePropBin(
        pWiasContext, WIA_IPA_ITEM_TIME,
        sizeof(SYSTEMTIME), (PBYTE)&camInfo.TimeStamp);

    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_COLOR);

    //
    // Free the BITMAPINFO
    //

    FREE(pBitmapinfo);

    //
    // calc item size
    //

    hr = SetItemSize(pWiasContext);

    //
    // load thumbnail
    //

    PBYTE pThumb;
    LONG  lSize;

    hr = CamLoadThumbnail(pContext, &pThumb, &lSize);

    if (hr == S_OK) {

        //
        // write thumb property
        //

        PROPSPEC    propSpec;
        PROPVARIANT propVar;

        propVar.vt          = VT_VECTOR | VT_UI1;
        propVar.caub.cElems = lSize;
        propVar.caub.pElems = pThumb;

        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPC_THUMBNAIL;

        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar);

        FREE(pThumb);
    }

    hr = SetFormatAttribs();
    if (FAILED(hr)) {
        return (hr);
    }

    //
    // Use WIA services to set the extended property access and
    // valid value information from gItemPropInfos.
    //

    hr =  wiasSetItemPropAttribs(pWiasContext,
                                 NUM_CAM_ITEM_PROPS,
                                 gPropSpecDefaults,
                                 gItemPropInfos);
    return (hr);
}

HRESULT
TestUsdDevice::InitAudioInformation(
    BYTE                   *pWiasContext,
    PMEMCAM_IMAGE_CONTEXT   pContext,
    LONG                   *plDevErrVal)
{
    HRESULT                  hr = E_FAIL;
    WIN32_FILE_ATTRIBUTE_DATA wfd;

    if (GetFileAttributesEx (pContext->pszCameraImagePath, GetFileExInfoStandard, &wfd))
    {
        SYSTEMTIME st;
        FileTimeToSystemTime (&wfd.ftLastWriteTime, &st);
        wiasWritePropLong (pWiasContext, WIA_IPA_ITEM_SIZE, wfd.nFileSizeLow);
        wiasWritePropBin (pWiasContext, WIA_IPA_ITEM_TIME, sizeof(SYSTEMTIME),
                          (PBYTE)&st);
        hr = S_OK;

    }
    return hr;

}

/**************************************************************************\
* SetFormatAttribs
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/5/2000 Original Version
*
\**************************************************************************/

HRESULT
SetFormatAttribs()
{
    gItemPropInfos[FORMAT_INDEX].lAccessFlags = WIA_PROP_RW | WIA_PROP_LIST;
    gItemPropInfos[FORMAT_INDEX].vt           = VT_CLSID;

    gItemPropInfos[FORMAT_INDEX].ValidVal.ListGuid.cNumList = NUM_FORMAT;
    gItemPropInfos[FORMAT_INDEX].ValidVal.ListGuid.pList    = gGuidFormats;

    //
    // Set the norm
    //

    gItemPropInfos[FORMAT_INDEX].ValidVal.ListGuid.Nom      = WiaImgFmt_BMP;

    //
    // Set up the format clsid list
    //

    gGuidFormats[0] = WiaImgFmt_BMP;
    gGuidFormats[1] = WiaImgFmt_MEMORYBMP;

    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\version.h ===
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Windows Image Acquisition Demo"
#define VER_INTERNALNAME_STR            "imgtest"
#define VER_LEGALCOPYRIGHT_YEARS        "1998"
#define VER_ORIGINALFILENAME_STR        "imgtest.exe"

#include <ntverp.h>
#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\wiadev.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       WiaDev.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        30 Aug, 1998
*
*  DESCRIPTION:
*   Implementation of the WIA test scanner mini driver
*   device methods.
*
*******************************************************************************/

#define __FORMATS_AND_MEDIA_TYPES__

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#include "testusd.h"
#include "defprop.h"


extern HINSTANCE g_hInst; // Global hInstance
extern WIA_FORMAT_INFO* g_wfiTable;
/**************************************************************************\
* TestUsdDevice::InitializWia
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvInitializeWia(
    BYTE                            *pWiasContext,
    LONG                            lFlags,
    BSTR                            bstrDeviceID,
    BSTR                            bstrRootFullItemName,
    IUnknown                        *pStiDevice,
    IUnknown                        *pIUnknownOuter,
    IWiaDrvItem                     **ppIDrvItemRoot,
    IUnknown                        **ppIUnknownInner,
    LONG                            *plDevErrVal)
{
    HRESULT              hr;
    LONG                 lDevErrVal;

    WIAS_TRACE((g_hInst,"drvInitializeWia, device ID: %ws", bstrDeviceID));

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;
    *plDevErrVal = 0;

    //
    // Need to init names and STI pointer?
    //

    if (m_pStiDevice == NULL) {

        //
        // save STI device inteface for locking
        //

        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID
        //

        m_bstrDeviceID = SysAllocString(bstrDeviceID);
        if (! m_bstrDeviceID) {
            return (E_OUTOFMEMORY);
        }

        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (! m_bstrRootFullItemName) {
            return (E_OUTOFMEMORY);
        }
    }

    //
    // Build the device item tree
    //

    hr = drvDeviceCommand(NULL, 0, &WIA_CMD_SYNCHRONIZE, NULL, &lDevErrVal);

    if (SUCCEEDED(hr)) {
        *ppIDrvItemRoot = m_pIDrvItemRoot;
    }

    return (hr);
}

/**************************************************************************\
* TestUsdDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
* Return Value:
*    Status
*
* History:
*
*   30/12/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvUnInitializeWia(
    BYTE                *pWiasContext)
{
    return S_OK;
}

/**************************************************************************\
*
*   Mini Driver Device Services
*
\**************************************************************************/



/**************************************************************************\
* drvGetDeviceErrorStr
*
*     Map a device error value to a string.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvGetDeviceErrorStr(
    LONG        lFlags,
    LONG        lDevErrVal,
    LPOLESTR    *ppszDevErrStr,
    LONG        *plDevErr)
{
    *plDevErr = 0;
    if (!ppszDevErrStr) {
        WIAS_ERROR((g_hInst,"drvGetDeviceErrorStr, NULL ppszDevErrStr"));
        return E_POINTER;
    }

    // Map device errors to a string to be placed in the event log.
    switch (lDevErrVal) {

        case 0:
            *ppszDevErrStr = L"No Error";
            break;

        default:
            *ppszDevErrStr = L"Device Error, Unknown Error";
            return E_FAIL;
    }
    return S_OK;
}

/**************************************************************************\
* DeleteDeviceItemTree
*
*   Recursive device item tree delete routine. Deletes the whole tree.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::DeleteDeviceItemTree(
    LONG                       *plDevErrVal)
{
    HRESULT hr;

    //
    // does tree exist
    //

    if (m_pIDrvItemRoot == NULL) {
        return S_OK;
    }

    //
    // Unlink and release the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    m_pIDrvItemRoot = NULL;

    return hr;
}

/**************************************************************************\
* BuildDeviceItemTree
*
*   The device uses the IWiaDrvServices methods to build up a tree of
*   device items.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::BuildDeviceItemTree(
    LONG                       *plDevErrVal)
{
    HRESULT hr = S_OK;

    //
    // This device doesn't touch hardware to build the tree.
    //

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    CAMERA_STATUS camStatus;

    if (! m_pIDrvItemRoot) {
        hr = CamBuildImageTree(&camStatus, &m_pIDrvItemRoot);
    }

    return hr;
}

/**************************************************************************\
* InitDeviceProperties
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::InitDeviceProperties(
    BYTE                    *pWiasContext,
    LONG                    *plDevErrVal)
{
    HRESULT                  hr;
    BSTR                     bstrFirmwreVer;
    SYSTEMTIME               camTime;
    int                      i;
    PROPVARIANT              propVar;

    //
    // This device doesn't touch hardware to initialize the device properties.
    //

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    //
    // Parameter validation.
    //

    if (! pWiasContext) {
        WIAS_ERROR((g_hInst,"InitDeviceProperties, invalid input pointers"));
        return E_POINTER;
    }

    //
    // Write standard property names
    //

    hr = wiasSetItemPropNames(pWiasContext,
                              sizeof(gDevicePropIDs)/sizeof(PROPID),
                              gDevicePropIDs,
                              gDevicePropNames);
    if (FAILED(hr)) {
        WIAS_TRACE((g_hInst,"InitDeviceProperties() WritePropertyNames() failed"));
        return (hr);
    }

    //
    // Write the properties supported by all WIA devices
    //

    bstrFirmwreVer = SysAllocString(L"02161999");
    if (bstrFirmwreVer) {
        wiasWritePropStr(
            pWiasContext, WIA_DPA_FIRMWARE_VERSION, bstrFirmwreVer);
        SysFreeString(bstrFirmwreVer);
    }

    wiasWritePropLong(
        pWiasContext, WIA_DPA_CONNECT_STATUS, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICTURES_TAKEN, 0);
    GetSystemTime(&camTime);
    wiasWritePropBin(
        pWiasContext, WIA_DPA_DEVICE_TIME,
        sizeof(SYSTEMTIME), (PBYTE)&camTime);

    //
    // Write the camera properties, just default values, it may vary with items
    //

    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICTURES_REMAINING, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_THUMB_WIDTH, 80);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_THUMB_HEIGHT, 60);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICT_WIDTH, 1024);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_PICT_HEIGHT, 768);

    // Give WIA_DPC_EXPOSURE_MODE to WIA_DPC_TIMER_VALUE some default.

    wiasWritePropLong(
        pWiasContext, WIA_DPC_EXPOSURE_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_FLASH_MODE, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_FOCUS_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_ZOOM_POSITION, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_BATTERY_STATUS, 1);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_TIMER_MODE, 0);
    wiasWritePropLong(
        pWiasContext, WIA_DPC_TIMER_VALUE, 0);

    //
    // Write the WIA_DPP_TCAM_ROOT_PATH property
    //

    BSTR   bstrRootPath;

#ifdef UNICODE
    bstrRootPath = SysAllocString(gpszPath);
#else
    WCHAR   wszPath[MAX_PATH];

    mbstowcs(wszPath, gpszPath, strlen(gpszPath)+1);
    bstrRootPath = SysAllocString(wszPath);
#endif

    if (! bstrRootPath) {
        return (E_OUTOFMEMORY);
    }

    wiasWritePropStr(pWiasContext, WIA_DPP_TCAM_ROOT_PATH, bstrRootPath);

    //
    // Use WIA services to set the property access and
    // valid value information from gDevPropInfoDefaults.
    //

    hr =  wiasSetItemPropAttribs(pWiasContext,
                                 NUM_CAM_DEV_PROPS,
                                 gDevicePropSpecDefaults,
                                 gDevPropInfoDefaults);
    return (S_OK);
}

/**************************************************************************\
* drvDeviceCommand
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvDeviceCommand(
   BYTE                         *pWiasContext,
   LONG                         lFlags,
   const GUID                   *plCommand,
   IWiaDrvItem                  **ppWiaDrvItem,
   LONG                         *plErr)
{
    HRESULT hr;

    //
    // init return value
    //

    if (ppWiaDrvItem != NULL) {
        *ppWiaDrvItem = NULL;
    }

    //
    // dispatch command
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        hr = drvLockWiaDevice(pWiasContext, lFlags, plErr);
        if (FAILED(hr)) {
            return (hr);
        }

        //
        // SYNCHRONIZE - make sure tree is up to date with device
        //
        // The driver's responsibility is to make sure the tree is accurate.
        //

        hr = BuildDeviceItemTree(plErr);

        drvUnLockWiaDevice(pWiasContext, lFlags, plErr);

        return (hr);

    } else {

        WIAS_TRACE((g_hInst,"drvDeviceCommand: Unsupported command"));

        hr = E_NOTIMPL;

    }

    return hr;
}

/**************************************************************************\
* drvGetCapabilities
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    17/3/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvGetCapabilities(
    BYTE                *pWiasContext,
    LONG                ulFlags,
    LONG                *pCelt,
    WIA_DEV_CAP_DRV     **ppCapabilities,
    LONG                *plDevErrVal)
{
    *plDevErrVal = 0;

    //
    // Return Commmand &| Events depending on flags
    //

    switch (ulFlags) {
        case WIA_DEVICE_COMMANDS:

            //
            //  Only commands
            //

            *pCelt = NUM_CAP_ENTRIES - NUM_EVENTS;
            *ppCapabilities = &gCapabilities[NUM_EVENTS];
            break;

        case WIA_DEVICE_EVENTS:

            //
            //  Only events
            //

            *pCelt = NUM_EVENTS;
            *ppCapabilities = gCapabilities;
            break;

        case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

            //
            //  Both events and commands
            //

            *pCelt = NUM_CAP_ENTRIES;
            *ppCapabilities = gCapabilities;
            break;

        default:

            //
            // Flags is invalid
            //

            WIAS_ERROR((g_hInst, "drvGetCapabilities, flags was invalid"));
            return (E_INVALIDARG);
    }

    return (S_OK);
}

/**************************************************************************\
* drvGetWiaFormatInfo
*
*   Returns an array of formats and media types supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WiaFormatInfo array.
*   ppfe            - Pointer to returned WiaFormatInfo array.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*    A pointer to an array of FORMATETC.  These are the formats and media
*    types supported.
*
*    Status
*
* History:
*
*   16/03/1999 Original Version
*
\**************************************************************************/

#define NUM_WIA_FORMAT_INFO 3

HRESULT _stdcall TestUsdDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{

    //
    //  If it hasn't been done already, set up the g_wfiTable table
    //

    if (! g_wfiTable) {

        g_wfiTable = (WIA_FORMAT_INFO*)
            CoTaskMemAlloc(sizeof(WIA_FORMAT_INFO) * NUM_WIA_FORMAT_INFO);

        if (! g_wfiTable) {
            WIAS_ERROR((g_hInst, "drvGetWiaFormatInfo, out of memory"));
            return (E_OUTOFMEMORY);
        }

        //
        //  Set up the format/tymed pairs
        //

        g_wfiTable[0].guidFormatID = WiaImgFmt_MEMORYBMP;
        g_wfiTable[0].lTymed = TYMED_CALLBACK;
        g_wfiTable[1].guidFormatID = WiaImgFmt_BMP;
        g_wfiTable[1].lTymed = TYMED_FILE;
        g_wfiTable[2].guidFormatID = WiaAudFmt_WAV;
        g_wfiTable[2].lTymed = TYMED_FILE;
    }

    *plDevErrVal = 0;

    *pcelt = NUM_WIA_FORMAT_INFO;
    *ppwfi = g_wfiTable;
    return S_OK;
}



/**************************************************************************\
* drvNotifyPnpEvent
*
*    Notify Pnp Event received by device manager
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    Aug/3rd/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvNotifyPnpEvent(
    const GUID          *pEventGUID,
    BSTR                 bstrDeviceID,
    ULONG                ulReserved)
{
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\testusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       TestUsd.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        5 Jan, 1999
*
*  DESCRIPTION:
*   Implementation of the WIA test scanner class factory and IUNKNOWN interface.
*
*******************************************************************************/

#define INITGUID

#include "testusd.h"
#include "resource.h"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
CRITICAL_SECTION    g_csCOM;           // COM initialize syncronization.

// Can we use UNICODE APIs
//BOOL    g_NoUnicodePlatform = TRUE;

// Is COM initialized
BOOL    g_COMInitialized = FALSE;

// Debugging interface, has TestUsdClassFactory lifetime.
WIA_DECLARE_DEBUGGER();

/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }
    LeaveCriticalSection(&g_csCOM);

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    LeaveCriticalSection(&g_csCOM);
    return TRUE;
}

/***************************************************************************\
*
*  TestUsdClassFactory
*
\****************************************************************************/

class TestUsdClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    TestUsdClassFactory();
    ~TestUsdClassFactory();
};

/**************************************************************************\
* TestUsdClassFactory::TestUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdClassFactory::TestUsdClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

    WIAS_TRACE((g_hInst,"Creating TestUsdClassFactory"));
}

/**************************************************************************\
* TestUsdClassFactory::~TestUsdClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdClassFactory::~TestUsdClassFactory(void)
{
    // Destructor logic
    WIAS_TRACE((g_hInst,"Destroying TestUsdClassFactory"));
}

/**************************************************************************\
* TestUsdClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR  *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* TestUsdClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* TestUsdClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* TestUsdClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                       riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{

    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IWiaItem) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    TestUsdDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new TestUsdDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    hres = pDev->PrivateInitialize();
    if(hres != S_OK) {
        delete pDev;
        return hres;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* TestUsdClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* TestUsdDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::NonDelegatingQueryInterface(
    REFIID   riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!IsValid() || !ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* TestUsdDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* TestUsdDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* TestUsdDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* TestUsdDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* TestUsdDevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) TestUsdDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/


extern "C"
BOOL APIENTRY
DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            __try {
                if(!InitializeCriticalSectionAndSpinCount(&g_csCOM, MINLONG)) {
                    return FALSE;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {
                OutputDebugStringA("TestUsd: Unloaded before all objects releaseed!\n");
            }
            
            DeleteCriticalSection(&g_csCOM);
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_TestUsd) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_TestUsd)) {
        TestUsdClassFactory *pcf = new TestUsdClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testusd.rc
//
#define IDD_EVENT_DLG                   101
#define IDD_GEN_EVENT                   1000
#define IDC_COMBO1                      1001
#define IDC_EDIT1                       1002
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\testusd.h ===
/****************************************************************************
 *
 *  TESTUSD.H
 *
 *  Copyright (c) Microsoft Corporation 1996-1997
 *  All rights reserved
 *
 ***************************************************************************/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include "sti.h"
#include "stierr.h"
#include "stiusd.h"

#include "wiamindr.h"

#define DATA_SRC_NAME L"TESTUSD.BMP"   // Data source file name.


// GUID's

#if defined( _WIN32 ) && !defined( _NO_COM)


// {ACBF6AF6-51C9-46a9-87D8-A93F352BCB3E}
DEFINE_GUID(CLSID_TestUsd,
0xacbf6af6, 0x51c9, 0x46a9, 0x87, 0xd8, 0xa9, 0x3f, 0x35, 0x2b, 0xcb, 0x3e);


// {61127F40-E1A5-11D0-B454-00A02438AD48}
DEFINE_GUID(guidEventTimeChanged, 0x61127F40L, 0xE1A5, 0x11D0, 0xB4, 0x54, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventSizeChanged, 0x052ED270L, 0x28A3, 0x11D1, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventFirstLoaded, 0x052ED270L, 0x28A3, 0x11D3, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

#endif


#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"

#define DATASEG_DEFAULT         DATASEG_SHARED

#pragma data_seg(DATASEG_PERINSTANCE)

// Set the default data segment
#pragma data_seg(DATASEG_DEFAULT)

//
// Module ref counting
//
extern UINT g_cRefThisDll;
extern UINT g_cLocks;

extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);

extern void DllAddRef(void);
extern void DllRelease(void);

typedef struct _MEMCAM_IMAGE_CONTEXT
{
    PTCHAR  pszCameraImagePath;
}MEMCAM_IMAGE_CONTEXT,*PMEMCAM_IMAGE_CONTEXT;

typedef struct _CAMERA_PICTURE_INFO
{
    LONG    PictNumber       ;
    LONG    ThumbWidth       ;
    LONG    ThumbHeight      ;
    LONG    PictWidth        ;
    LONG    PictHeight       ;
    LONG    PictCompSize     ;
    LONG    PictFormat       ;
    LONG    PictBitsPerPixel ;
    LONG    PictBytesPerRow  ;
    SYSTEMTIME TimeStamp;
}CAMERA_PICTURE_INFO,*PCAMERA_PICTURE_INFO;


typedef struct _CAMERA_STATUS
{
    LONG    FirmwareVersion            ;
    LONG    NumPictTaken               ;
    LONG    NumPictRemaining           ;
    LONG    ThumbWidth                 ;
    LONG    ThumbHeight                ;
    LONG    PictWidth                  ;
    LONG    PictHeight                 ;
    SYSTEMTIME CameraTime;
} CAMERA_STATUS,*PCAMERA_STATUS;

#define ALLOC(s) LocalAlloc(0,s)
#define FREE(s)  LocalFree(s)


//
// Base class for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // *** IUnknown-like methods ***
    STDMETHOD(NonDelegatingQueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};


//
// Class definition for object
//

class TestUsdDevice : public IStiUSD,
                      public IWiaMiniDrv,
                      public INonDelegatingUnknown
{

private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    BOOL                m_fValid;               // Is object initialized?
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    PSTIDEVICECONTROL   m_pIStiDevControl;      // Device control interface.
    BOOLEAN             m_bUsdLoadEvent;        // Controls load event.
    DWORD               m_dwLastOperationError; // Last error.

    // Data source file information.
    TCHAR               m_szSrcDataName[MAX_PATH];  // Path of data source file.
    FILETIME            m_ftLastWriteTime;          // Last time of source data file.
    LARGE_INTEGER       m_dwLastHugeSize;           // Last size of source data file.

    // Event information
    CRITICAL_SECTION    m_csShutdown;           // Syncronizes shutdown.
    HANDLE              m_hShutdownEvent;       // Shutdown event handle.
    HANDLE              m_hEventNotifyThread;   // Does event notification.

    // WIA information, one time initialization.
    IStiDevice         *m_pStiDevice;               // Sti object.

    BSTR                m_bstrRootFullItemName;    // Device name for prop streams.
    IWiaEventCallback     *m_pIWiaEventCallback;          // WIA event sink.
    IWiaDrvItem        *m_pIDrvItemRoot;            // root item

    BOOL inline IsValid(VOID) {
        return m_fValid;
    }

    //
    // make public until dlg proc is a member
    //

public:
    BSTR                m_bstrDeviceID;             // WIA unique device ID.
    HANDLE              m_hSignalEvent;         // Signal event handle.
    HWND                m_hDlg;
    GUID                m_guidLastEvent;        // Last event ID.

public:
    // *** IUnknown-like methods ***
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /*** IStiUSD methods ***/
    STDMETHOD(Initialize) (THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey)  ;
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps)  ;
    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus)  ;
    STDMETHOD(DeviceReset)(THIS )  ;
    STDMETHOD(Diagnostic)(THIS_ LPDIAG pBuffer)  ;
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData)   ;
    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError)  ;
    STDMETHOD(LockDevice) (THIS )  ;
    STDMETHOD(UnLockDevice) (THIS )  ;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent)  ;
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY   lpNotify)  ;
    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo);

    //
    // MiniDrv methods
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE*                       pWiasContext,
        LONG                        lFlags,
        BSTR                        bstrDeviceID,
        BSTR                        bstrRootFullItemName,
        IUnknown                   *pStiDevice,
        IUnknown                   *pIUnknownOuter,
        IWiaDrvItem               **ppIDrvItemRoot,
        IUnknown                  **ppIUnknownInner,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG                        lFlags,
        LONG                        lDevErrVal,
        LPOLESTR                   *ppszDevErrStr,
        LONG                       *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        const GUID                 *pGUIDCommand,
        IWiaDrvItem               **ppMiniDrvItem,
        LONG                       *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        PMINIDRV_TRANSFER_CONTEXT   pDataContext,
        LONG                       *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        ULONG                       nPropSpec,
        const PROPSPEC             *pPropSpec,
        LONG                       *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFLags,
        PMINIDRV_TRANSFER_CONTEXT   pmdtc,
        LONG                       *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE                       *pWiaItem,
        LONG                        lFlags,
        ULONG                       nPropSpec,
        const PROPSPEC             *pPropSpec,
        LONG                       *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal );

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG                        lFlags,
        BYTE                       *pDevContext,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *pCelt,
        WIA_DEV_CAP_DRV           **ppCapabilities,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *pCelt,
        WIA_FORMAT_INFO            **ppwfi,
        LONG                       *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID                 *pEventGUID,
        BSTR                        bstrDeviceID,
        ULONG                       ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE*);

    /*** Private helper methods ***/
private:

    HRESULT InitImageInformation(
        BYTE                       *pWiasContext,
        MEMCAM_IMAGE_CONTEXT       *pContext,
        LONG                       *plDevErrVal);

    HRESULT InitAudioInformation(
        BYTE                       *pWiasContext,
        MEMCAM_IMAGE_CONTEXT       *pContext,
        LONG                       *plDevErrVal);

    HRESULT EnumDiskImages(
        IWiaDrvItem                *pRootItem,
        LPTSTR                      pszDirName);

    HRESULT CreateItemFromFileName(
        LONG                        lFolderType,
        PTCHAR                      pszPath,
        PTCHAR                      pszName,
        IWiaDrvItem               **ppNewFolder);

    HRESULT CamLoadPicture(
        PMEMCAM_IMAGE_CONTEXT       pMCamContext,
        PMINIDRV_TRANSFER_CONTEXT   pDataTransCtx,
        PLONG                       plDevErrVal);

    HRESULT CamLoadPictureCB(
        PMEMCAM_IMAGE_CONTEXT       pMCamContext,
        MINIDRV_TRANSFER_CONTEXT   *pDataTransCtx,
        PLONG                       plDevErrVal);

    HRESULT CamGetPictureInfo(
        PMEMCAM_IMAGE_CONTEXT       pMCamContext,
        PCAMERA_PICTURE_INFO        pPictInfo,
        PBYTE                      *ppBITMAPINFO,
        LONG                       *pBITMAPINFOSize);

    HRESULT CamLoadThumbnail(PMEMCAM_IMAGE_CONTEXT, PBYTE *,LONG *);

    HRESULT CamBuildImageTree(CAMERA_STATUS *,IWiaDrvItem **);

    HRESULT CamOpenCamera(CAMERA_STATUS *);

    HRESULT BuildDeviceItemTree(LONG *plDevErrVal);
    HRESULT DeleteDeviceItemTree(LONG *plDevErrVal);
    HRESULT InitDeviceProperties(BYTE *, LONG *plDevErrVal);

public:
    TestUsdDevice(LPUNKNOWN punkOuter);
    HRESULT PrivateInitialize();
    ~TestUsdDevice();

    VOID RunNotifications(VOID);
};

typedef TestUsdDevice *PTestUsdDevice;


HRESULT SetItemSize(BYTE*);

//
// Utility function to set up the attributes for format property
//

HRESULT SetFormatAttribs();

//
// Syncronization mechanisms
//
#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);


// Device constants:
const LEN_INQUIRE_BUTTON = 8;
const BYTE INQUIRE_BUTTON[LEN_INQUIRE_BUTTON + 1] = "INQUIREB";

const LEN_INQUIRE_BUTTON_READ = 10;

const LEN_CLEAR_BUTTON = 5;
const BYTE CLEAR_BUTTON[LEN_CLEAR_BUTTON + 1] = "CLRBT";

const LEN_CURRENT_ERROR = 7;
const BYTE CURRENT_ERROR[LEN_CURRENT_ERROR + 1] = "CURERR";

const LEN_DIAGS = 5;
const BYTE TURN_ON_LAMP[LEN_DIAGS + 1] = "LAMPO";
const BYTE TURN_OFF_LAMP[LEN_DIAGS + 1] = "LAMPF";
const BYTE SELF_TEST[LEN_DIAGS + 1] = "SELFT";
const BYTE STATUS_STRING[LEN_DIAGS + 1] = "STATS";


BOOL
_stdcall CameraEventDlgProc(
   HWND     hDlg,
   unsigned message,
   DWORD    wParam,
   LONG     lParam
   );

typedef struct _CAM_EVENT
{
    PTCHAR       pszEvent;
    const GUID  *pguid;
}CAM_EVENT,*PCAM_EVENT;

extern TCHAR gpszPath[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\inc\wiatempl.h ===
/*++

Copyright (C) 1999- Microsoft Corporation

Module Name:

    typeutil.h

Abstract:

    This module declares useful types such as CWiaArray and CWiaMap.
    These were lifted from the ATL library (atlbase.h).

Author:

    DavePar
    
Revision History:


--*/

#ifndef TYPEUTIL__H_
#define TYPEUTIL__H_

#ifndef ASSERT
#define ASSERT(x)
#endif

/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CWiaArray & CWiaMap

template <class T>
class CWiaArray
{
public:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;

// Construction/destruction
    CWiaArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }

    ~CWiaArray()
    {
        RemoveAll();
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL GrowTo(int size)
    {
        if (size > m_nAllocSize)
        {
            T* aT;
            aT = (T*) realloc(m_aT, size * sizeof(T));
            if (aT == NULL)
                return FALSE;
            m_nAllocSize = size;
            m_aT = aT;
        }
        return TRUE;
    }
    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
            if (!GrowTo(nNewAllocSize))
                return FALSE;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }
    int AddN(T& t) // Adds the new item and returns its index
    {
        if (Add(t))
            return m_nSize - 1;
        else
            return -1;
    }
    BOOL Push(T& t)
    {
        return Add(t);
    }
    BOOL Pop(T& t)
    {
        if (m_nSize == 0)
            return FALSE;
        t = m_aT[m_nSize - 1];
        return RemoveAt(m_nSize - 1);
    }
    BOOL Remove(const T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }
    BOOL RemoveAt(int nIndex)
    {

        if(nIndex >= m_nSize)
            return FALSE;
        
        //---- always call the dtr ----
#if _MSC_VER >= 1200
        m_aT[nIndex].~T();
#else
        T* MyT;
        MyT = &m_aT[nIndex];
        MyT->~T();
#endif

        //---- if target entry is not at end, compact the array ----
        if(nIndex != (m_nSize - 1))
        {
            
            memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
        }

        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aT != NULL)
        {
            for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
                m_aT[i].~T();
#else
                T* MyT;
                MyT = &m_aT[i];
                MyT->~T();
#endif
            }
            free(m_aT);
            m_aT = NULL;
        }
        m_nSize = 0;
        m_nAllocSize = 0;
    }
    T& operator[] (int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aT[nIndex];
    }
    T* GetData() const
    {
        return m_aT;
    }

// Implementation
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <class _Ty>
        void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, T& t)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        new(m_aT + nIndex) Wrapper(t);
    }
    int Find(const T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
    BOOL Parse(BYTE **ppRaw, int NumSize = 4)
    {
        if (!ppRaw || !*ppRaw)
            return FALSE;
    
        RemoveAll();
    
        // Get the number of elements from the raw data
        ULONG NumElems;
        switch (NumSize)
        {
        case 4:
            NumElems = MAKELONG(MAKEWORD((*ppRaw)[0], (*ppRaw)[1]), MAKEWORD((*ppRaw)[2], (*ppRaw)[3]));
            break;
        case 2:
            NumElems = MAKEWORD((*ppRaw)[0], (*ppRaw)[1]);
            break;
        case 1:
            NumElems = **ppRaw;
            break;
        default:
            return FALSE;
        }

        *ppRaw += NumSize;
    
        // Allocate space for the array
        if (!GrowTo(NumElems))
            return FALSE;
    
        // Copy in the elements
        memcpy(m_aT, *ppRaw, NumElems * sizeof(T));
        m_nSize = NumElems;
    
        // Advance the raw pointer past the array and number of elements field
        *ppRaw += NumElems * sizeof(T);
    
        return TRUE;
    }
};

// for arrays of simple types
template <class T>
class CWiaValArray : public CWiaArray< T >
{
public:
    BOOL Add(T t)
    {
        return CWiaArray< T >::Add(t);
    }
    BOOL Remove(T t)
    {
        return CWiaArray< T >::Remove(t);
    }
    T operator[] (int nIndex) const
    {
        return CWiaArray< T >::operator[](nIndex);
    }
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CWiaMap
{
public:
    TKey* m_aKey;
    TVal* m_aVal;
    int m_nSize;

// Construction/destruction
    CWiaMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
    { }

    ~CWiaMap()
    {
        RemoveAll();
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL Add(TKey key, TVal val)
    {
        TKey* pKey;
        pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
        if(pKey == NULL)
            return FALSE;
        m_aKey = pKey;
        TVal* pVal;
        pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
        if(pVal == NULL)
            return FALSE;
        m_aVal = pVal;
        m_nSize++;
        SetAtIndex(m_nSize - 1, key, val);
        return TRUE;
    }
    BOOL Remove(TKey key)
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return FALSE;
        if(nIndex != (m_nSize - 1))
        {
#if 0
            // This code seems to be causing problems. Since it's not
            // needed, ifdef it out for now.

            m_aKey[nIndex].~TKey();
#if _MSC_VER >= 1200
            m_aVal[nIndex].~TVal();
#else
            TVal * t1;
            t1 = &m_aVal[nIndex];
            t1->~TVal();
#endif
#endif
            memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
            memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
        }
        TKey* pKey;
        pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
        if(pKey != NULL || m_nSize == 1)
            m_aKey = pKey;
        TVal* pVal;
        pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
        if(pVal != NULL || m_nSize == 1)
            m_aVal = pVal;
        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aKey != NULL)
        {
            for(int i = 0; i < m_nSize; i++)
            {
                m_aKey[i].~TKey();
#if _MSC_VER >= 1200
                m_aVal[i].~TVal();
#else
                TVal * t1;
                t1 = &m_aVal[i];
                t1->~TVal();
#endif
            }
            free(m_aKey);
            m_aKey = NULL;
        }
        if(m_aVal != NULL)
        {
            free(m_aVal);
            m_aVal = NULL;
        }

        m_nSize = 0;
    }
    BOOL SetAt(TKey key, TVal val)
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return FALSE;
        SetAtIndex(nIndex, key, val);
        return TRUE;
    }
    TVal Lookup(TKey key) const
    {
        int nIndex = FindKey(key);
        if(nIndex == -1)
            return NULL;    // must be able to convert
        return GetValueAt(nIndex);
    }
    TKey ReverseLookup(TVal val) const
    {
        int nIndex = FindVal(val);
        if(nIndex == -1)
            return NULL;    // must be able to convert
        return GetKeyAt(nIndex);
    }
    TKey& GetKeyAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aKey[nIndex];
    }
    TVal& GetValueAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aVal[nIndex];
    }

// Implementation

    template <typename T>
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <typename _Ty>
        void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, TKey& key, TVal& val)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        new(m_aKey + nIndex) Wrapper<TKey>(key);
        new(m_aVal + nIndex) Wrapper<TVal>(val);
    }
    int FindKey(TKey& key) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aKey[i] == key)
                return i;
        }
        return -1;  // not found
    }
    int FindVal(TVal& val) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aVal[i] == val)
                return i;
        }
        return -1;  // not found
    }
};

#endif // TYPEUTIL__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\miniitem.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       MiniItem.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      marke
*
*  DATE:        30 Aug, 1998
*
*  DESCRIPTION:
*   Implementation of the WIA test camera item methods.
*
*******************************************************************************/

#include <stdio.h>
#include <objbase.h>
#include <sti.h>

#ifdef TEST_PER_USER_DATA
#ifdef UNICODE
#include <userenv.h>
#endif
#endif

#include "testusd.h"

#include "defprop.h"

extern HINSTANCE g_hInst; // Global hInstance

/*******************************************************************************
*
*  ValidateDataTransferContext
*
*  DESCRIPTION:
*    Validate the data transfer context.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT
ValidateDataTransferContext(
    PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext)
{
   if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT)) {
      WIAS_ERROR((g_hInst,"ValidateDataTransferContext, invalid data transfer context"));
      return E_INVALIDARG;;
   }

   //
   // for tymed file or hglobal, only WiaImgFmt_MEMORYBMP is allowed
   //

   if ((pDataTransferContext->tymed == TYMED_FILE) ||
       (pDataTransferContext->tymed == TYMED_HGLOBAL)) {

       if (pDataTransferContext->guidFormatID != WiaImgFmt_BMP && pDataTransferContext->guidFormatID != WiaAudFmt_WAV) {
          WIAS_ERROR((g_hInst,"ValidateDataTransferContext, invalid format"));
          return E_INVALIDARG;;
       }

   }

   //
   // for tymed CALLBACK, only WiaImgFmt_MEMORYBMP is allowed
   //

   if (pDataTransferContext->tymed == TYMED_CALLBACK) {

       if ((pDataTransferContext->guidFormatID != WiaImgFmt_BMP) &&
           (pDataTransferContext->guidFormatID != WiaImgFmt_MEMORYBMP)) {
          WIAS_ERROR((g_hInst,"AcquireDeviceData, invalid format"));
          return E_INVALIDARG;;
       }
   }


   //
   // callback is always double buffered, non-callback never is
   //

   if (pDataTransferContext->pTransferBuffer == NULL) {
       WIAS_ERROR((g_hInst, "AcquireDeviceData, invalid transfer buffer"));
       return E_INVALIDARG;
   }

   return S_OK;
}


/**************************************************************************\
* SendBitmapHeader
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    11/17/1998 Original Version
*
\**************************************************************************/

HRESULT SendBitmapHeader(
    IWiaDrvItem                *pDrvItem,
    PMINIDRV_TRANSFER_CONTEXT   pTranCtx)
{
    HRESULT hr;

    WIAS_ASSERT(g_hInst, pDrvItem != NULL);
    WIAS_ASSERT(g_hInst, pTranCtx != NULL);
    WIAS_ASSERT(g_hInst, pTranCtx->tymed == TYMED_CALLBACK);

    //
    // driver is sending TOPDOWN data, must swap biHeight
    //
    // this routine assumes pTranCtx->pHeader points to a
    // BITMAPINFO header (TYMED_FILE doesn't use this path
    // and DIB is the only format supported now)
    //

    PBITMAPINFO pbmi = (PBITMAPINFO)pTranCtx->pTransferBuffer;

    if (pTranCtx->guidFormatID == WiaImgFmt_MEMORYBMP) {
        pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
    }

    hr = pTranCtx->
            pIWiaMiniDrvCallBack->
                MiniDrvCallback(
                    IT_MSG_DATA,
                    IT_STATUS_TRANSFER_TO_CLIENT,
                    0,
                    0,
                    pTranCtx->lHeaderSize,
                    pTranCtx,
                    0);

    if (hr == S_OK) {

        //
        // advance offset for destination copy
        //

        pTranCtx->cbOffset += pTranCtx->lHeaderSize;

    }

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvDeleteItem
*
*   Try to delete a device item. Device items for the test scanner may
*   not be modified.
*
* Arguments:
*
*   pWiasContext    -   The context of the item to delete
*   lFlags          -   unused
*   plDevErrVal     -   unused
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvDeleteItem(
    BYTE*       pWiasContext,
    LONG        lFlags,
    LONG*       plDevErrVal)
{
    *plDevErrVal = 0;
    return STG_E_ACCESSDENIED;
}

/**************************************************************************\
* TestUsdDevice::drvAcquireItemData
*
*   Scan data into buffer. This routine scans the entire contents into
*   the destination buffer in one call. Status will be sent back if
*   the callback routine is provided
*
* Arguments:
*
*   pWiasContext    - identifies ITEM context
*   lFlags          - unused
*   pTranCtx        - buffer and callback information
*   plDevErrVal     - error value
*
* Return Value:
*
*    Status
*
* History:
*
*    11/17/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pTranCtx,
    LONG                        *plDevErrVal)
{
    HRESULT                     hr;
// #define TEST_PER_USER_DATA 1
#ifdef TEST_PER_USER_DATA
#ifdef UNICODE
    BOOL                        bRet;
    TCHAR                       tszUserName[MAX_PATH];
    DWORD                       dwBufSize;
    HANDLE                      hToken;
    PROFILEINFO                 profileInfo;
    LONG                        lRet;
    HKEY                        hKeyCurUser;
#endif
#endif

    *plDevErrVal = 0;

    //
    // How to access per user setting in the USD
    //

#ifdef TEST_PER_USER_DATA
#ifdef UNICODE
#ifdef DEBUG

    dwBufSize = MAX_PATH;
    bRet = GetUserName(tszUserName, &dwBufSize);
#endif
#endif
#endif

#ifdef TEST_PER_USER_DATA
#ifdef UNICODE

    hToken = NULL;

    __try {

        hr = CoImpersonateClient();
        if (FAILED(hr)) {
            __leave;
        }

#ifdef NEED_USER_PROFILE

        bRet = OpenThreadToken(
                   GetCurrentThread(),
                   TOKEN_ALL_ACCESS,
                   TRUE,
                   &hToken);

        if (! bRet) {

            __leave;
        }

        //
        // Get the client's user name
        //

        dwBufSize = MAX_PATH;
        bRet = GetUserName(tszUserName, &dwBufSize);

        //
        // Revert to system account
        //

        hr = CoRevertToSelf();
        if (FAILED(hr)) {
            __leave;
        }
        hr = S_FALSE;

        //
        // Load the user profile
        //

        ZeroMemory(&profileInfo, sizeof(profileInfo));
        profileInfo.dwSize     = sizeof(profileInfo);
        profileInfo.dwFlags    = PI_NOUI;
        profileInfo.lpUserName = tszUserName;

        bRet = LoadUserProfile(hToken, &profileInfo);
        if (! bRet) {
            __leave;
        }

        //
        // Access user portion of the registry
        //
        // Use profileInfo.hProfile instead of HKEY_CURRENT_USER
        //
        //

        hKeyCurUser = (HKEY)profileInfo.hProfile;
#else

        lRet = RegOpenCurrentUser(KEY_ALL_ACCESS, &hKeyCurUser);
        if (lRet != ERROR_SUCCESS) {
            __leave;
        }

#endif

        HKEY  hKeyEnv;

        lRet = RegOpenKey(
                   hKeyCurUser,
                   TEXT("Environment"),
                   &hKeyEnv);
        if (lRet == ERROR_SUCCESS) {
            RegCloseKey(hKeyEnv);
        }
    }
    __finally {

        if (hr == S_OK) {

            CoRevertToSelf();
        }

#ifdef NEED_USER_PROFILE

        if (bRet) {

            UnloadUserProfile(hToken, profileInfo.hProfile);
        }

        if (hToken) {

            CloseHandle(hToken);
        }
#else

        if (hKeyCurUser) {

            RegCloseKey(hKeyCurUser);
        }
#endif
    }

#endif
#endif

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Validate the data transfer context.
    //

    hr = ValidateDataTransferContext(pTranCtx);

    if (FAILED(hr)) {
        return hr;
    }

    //
    // get item specific driver data
    //

    MEMCAM_IMAGE_CONTEXT  *pMCamContext;

    pDrvItem->GetDeviceSpecContext((BYTE **)&pMCamContext);

    if (!pMCamContext) {
        WIAS_ERROR((g_hInst,"drvAcquireItemData, NULL item context"));
        return E_POINTER;
    }

    //
    // Use WIA services to fetch format specific info.
    //

    if (!IsEqualGUID (pTranCtx->guidFormatID, WiaAudFmt_WAV) )
    {
        hr = wiasGetImageInformation(pWiasContext,
                                 0,
                                 pTranCtx);
    }
    else
    {

        WIN32_FILE_ATTRIBUTE_DATA wfd;
        GetFileAttributesEx (pMCamContext->pszCameraImagePath,GetFileExInfoStandard, &wfd);
        pTranCtx->lItemSize = (LONG)wfd.nFileSizeLow;
    }


    if (hr != S_OK) {
        return hr;
    }

    //
    // determine if this is a callback or buffered transfer
    //

    if (pTranCtx->tymed == TYMED_CALLBACK) {

        //
        // For formats that have a data header, send it to the client
        //

        if (pTranCtx->lHeaderSize > 0) {

            hr = SendBitmapHeader(
                     pDrvItem,
                     pTranCtx);
        }

        if (hr == S_OK) {
            hr = CamLoadPictureCB(
                     pMCamContext,
                     pTranCtx,
                     plDevErrVal);
        }

    } else {

        //
        // inc past header
        //

        pTranCtx->cbOffset += pTranCtx->lHeaderSize;

        hr = CamLoadPicture(
                 pMCamContext,
                 pTranCtx,
                 plDevErrVal);

    }

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvInitItemProperties
*
*   Initialize the device item properties.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item context.
*   lFLags          - unused
*   plDevErrVal     - pointer to hardware error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvInitItemProperties(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    HRESULT                  hr;
    LONG                     lItemType;
    PMEMCAM_IMAGE_CONTEXT    pContext;

    //
    // This device doesn't touch hardware to initialize the
    // device item properties.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if (!pWiasContext) {
        WIAS_ERROR((g_hInst,"drvInitItemProperties, invalid input pointers"));
        return (E_INVALIDARG);
    }

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Root item has the all the device properties
    //

    hr = pDrvItem->GetItemFlags(&lItemType);
    if (FAILED(hr)) {
        return (hr);
    }

    if (lItemType & WiaItemTypeRoot) {

        // Root item property init finishes here
        return (InitDeviceProperties(pWiasContext,
                                     plDevErrVal));
    }

    //
    // If this is a file, init the properties
    //

    if (lItemType & WiaItemTypeImage) {

        //
        // Add the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  NUM_CAM_ITEM_PROPS,
                                  gItemPropIDs,
                                  gItemPropNames);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties, wiasSetItemPropNames() failed"));
            return (hr);
        }

        //
        // Use WIA services to set the defaul item properties.
        //


        hr = wiasWriteMultiple(pWiasContext,
                               NUM_CAM_ITEM_PROPS,
                               gPropSpecDefaults,
                               (PROPVARIANT*)gPropVarDefaults);

        if (FAILED(hr)) {
            return (hr);
        }

        hr = pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties, GetDeviceSpecContext failed"));
            return (hr);
        }

        hr = InitImageInformation(pWiasContext,
                                  pContext,
                                  plDevErrVal);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties InitImageInformation() failed"));
            return (hr);
        }

    }
    else if (lItemType & WiaItemTypeAudio)
    {
        //
        // Add the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  NUM_AUDIO_PROPS,
                                  gAudioPropIDs,
                                  gAudioPropNames);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties, wiasSetItemPropNames() failed"));
            return (hr);
        }

        //
        // Use WIA services to set the defaul item properties.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               NUM_AUDIO_PROPS,
                               gAudioPropDefaults,
                               (PROPVARIANT*)gAudioDefaults);

        if (FAILED(hr)) {
            return (hr);
        }

        hr = pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

        if (FAILED(hr)) {
            WIAS_ERROR((g_hInst,"drvInitItemProperties, GetDeviceSpecContext failed"));
            return (hr);
        }
        hr = InitAudioInformation (pWiasContext,
                                   pContext,
                                   plDevErrVal);
    }


    return (S_OK);
}

/**************************************************************************\
* TestUsdDevice::drvValidateItemProperties
*
*   Validate the device item properties.
*
* Arguments:
*
*   pWiasContext    - wia item context
*   lFlags          - unused
*   nPropSpec       -
*   pPropSpec       -
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvValidateItemProperties(
    BYTE                *pWiasContext,
    LONG                lFlags,
    ULONG               nPropSpec,
    const PROPSPEC      *pPropSpec,
    LONG                *plDevErrVal)
{
    //
    // This device doesn't touch hardware to validate the device item properties.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if (!pWiasContext || !pPropSpec) {
        WIAS_ERROR((g_hInst,"drvValidateItemProperties, invalid input pointers"));
        return E_POINTER;
    }

    //
    // validate size
    //

    HRESULT hr = S_OK;

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    LONG lItemType;

    hr = pDrvItem->GetItemFlags(&lItemType);

    if (hr == S_OK) {

        if (lItemType & WiaItemTypeImage) {

            //
            // calc item size
            //

            hr = SetItemSize(pWiasContext);

            //
            //  Change MinBufferSize property.  Need to get Tymed and
            //  ItemSize first, since MinBufferSize in dependant on these
            //  properties.
            //

            LONG        lTymed;
            LONG        lItemSize;
            LONG        lMinBufSize = 0;
            HRESULT     hr = S_OK;

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_TYMED, &lTymed, NULL, TRUE);
            if (FAILED(hr)) {
                WIAS_ERROR((g_hInst,"drvValidateItemProperties, could not read TYMED property"));
                return hr;
            }

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_ITEM_SIZE, &lItemSize, NULL, TRUE);
            if (SUCCEEDED(hr)) {

                //
                //  Update the MinBufferSize property.
                //

                switch (lTymed) {
                    case TYMED_CALLBACK:
                        lMinBufSize = 65535;
                        break;

                    default:
                        lMinBufSize = lItemSize;
                }
                if (lMinBufSize) {
                    hr = wiasWritePropLong(pWiasContext, WIA_IPA_MIN_BUFFER_SIZE, lMinBufSize);
                    if (FAILED(hr)) {
                        WIAS_ERROR((g_hInst, "drvValidateItemProperties, could not write value for WIA_IPA_MIN_BUFFER_SIZE"));
                    }
                }
            } else {
                WIAS_ERROR((g_hInst, "drvValidateItemProperties, could not read value for ItemSize"));
            }

        } else if (lItemType & WiaItemTypeRoot) {

            //
            // Find out whether the Root Path property is changed
            //

            for (ULONG i = 0; i < nPropSpec; i++) {

                if (((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
                          (pPropSpec[i].propid == WIA_DPP_TCAM_ROOT_PATH)) ||
                    ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) &&
                          (wcscmp(pPropSpec[i].lpwstr, WIA_DPP_TCAM_ROOT_PATH_STR) == 0))) {

                    BSTR   bstrRootPath;

                    //
                    // Retrieve the new value for Root Path property
                    //

                    hr = wiasReadPropStr(
                             pWiasContext,
                             WIA_DPP_TCAM_ROOT_PATH,
                             &bstrRootPath,
                             NULL,
                             TRUE);
                    if (FAILED(hr)) {
                        return (hr);
                    }

#ifdef UNICODE
                    wcscpy(gpszPath, bstrRootPath);
#else
                    wcstombs(gpszPath, bstrRootPath, MAX_PATH);
#endif
                    //
                    // Release the Root Path bstr
                    //

                    SysFreeString(bstrRootPath);

                    //
                    // Rebuild the item tree and send event notification
                    //

                    hr = DeleteDeviceItemTree(plDevErrVal);
                    if (FAILED(hr)) {
                        break;
                    }

                    hr = BuildDeviceItemTree(plDevErrVal);
                    if (FAILED(hr)) {
                        break;
                    }

                    m_guidLastEvent = WIA_EVENT_DEVICE_CONNECTED;
                    SetEvent(m_hSignalEvent);

                    break;
                }
            }
        }
    }

    return (hr);
}

/**************************************************************************\
* TestUsdDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.
*
* Arguments:
*
*   pWiasContext    - the corresponding wia item context
*   pmdtc           - pointer to mini driver context
*   pFlags          - unused
*   plDevErrVal     - the device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvWriteItemProperties(
    BYTE                       *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                       *plDevErrVal)
{
    //
    // Assume no device hardware errors.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if ((! pWiasContext) || (! pmdtc)) {
        WIAS_ERROR((g_hInst,"drvWriteItemProperties, invalid input pointers"));
        return E_POINTER;
    }

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    HRESULT hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    PMEMCAM_IMAGE_CONTEXT pItemContext;

    hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

    if (FAILED(hr)) {
        WIAS_ERROR((g_hInst,"drvWriteItemProperties, NULL item context"));
        return E_POINTER;
    }

    //
    // Write the device item properties to the hardware here.
    //

    return hr;
}

/**************************************************************************\
* TestUsdDevice::drvReadItemProperties
*
*   Read the device item properties from the hardware.
*
* Arguments:
*
*   pWiasContext    - wia item context
*   lFlags          - unused
*   nPropSpec       -
*   pPropSpec       -
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvReadItemProperties(
    BYTE            *pWiasContext,
    LONG                lFlags,
    ULONG               nPropSpec,
    const PROPSPEC      *pPropSpec,
    LONG                *plDevErrVal)
{
    // For most scanner devices, item properties are stored in the driver
    // and written out at acquire image time. Some devices support properties
    // which should be updated on every property read. This can be done here.


    *plDevErrVal = 0;

    return S_OK;
}


/**************************************************************************\
* TestUsdDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext    - unused,
*   lFlags          - unused
*   plDevErrVal     - device error value
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::drvLockWiaDevice(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    *plDevErrVal = 0;
    if (m_pStiDevice)
    {
        return m_pStiDevice->LockDevice(100);
    }
    return S_OK;

}

/**************************************************************************\
* TestUsdDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - unused
*   lFlags          - unused
*   plDevErrVal     - device error value
*
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

HRESULT TestUsdDevice::drvUnLockWiaDevice(
    BYTE        *pWiasContext,
    LONG        lFlags,
    LONG        *plDevErrVal)
{
    plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* TestUsdDevice::drvAnalyzeItem
*
*   The test camera does not support imag analysis.
*
* Arguments:
*
*   pWiasContext    - Pointer to the device item context to be analyzed.
*   lFlags          - Operation flags.
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvAnalyzeItem(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *plDevErrVal)
{
    *plDevErrVal = 0;
    return E_NOTIMPL;
}

/**************************************************************************\
* TestUsdDevice::drvFreeDrvItemContext
*
*   The test scanner does not support imag analysis.
*
* Arguments:
*
*   lFlags          - unused
*   pSpecContext    - Pointer to item specific context.
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    10/15/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall TestUsdDevice::drvFreeDrvItemContext(
    LONG                lFlags,
    BYTE                *pSpecContext,
    LONG                *plDevErrVal)
{
    PMEMCAM_IMAGE_CONTEXT pContext = (PMEMCAM_IMAGE_CONTEXT)pSpecContext;

    if (pContext != NULL) {
        if (pContext->pszCameraImagePath != NULL) {

            free(pContext->pszCameraImagePath);
            pContext->pszCameraImagePath = NULL;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\camera\testcam\device.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       Device.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        5 Jan, 1999
*
*  DESCRIPTION:
*   Implementation of the WIA test scanner device methods. This sample WIA USD
*   supports push events by detecting when %windir%\temp\TESTUSD.BMP file has
*   been modified. This file becomes the new source of scanning data. An
*   event is generated the first time the device is loaded.
*
*******************************************************************************/

#include <windows.h>
#include <tchar.h>

#include "testusd.h"
#include "resource.h"
#include "tcamprop.h"

extern HINSTANCE g_hInst;

//
// Function prototypes, implemented in this file:
//

VOID FileChangeThread(LPVOID  lpParameter);

/**************************************************************************\
* TestUsdDevice::TestUsdDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdDevice::TestUsdDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_punkOuter(NULL),
    m_fValid(FALSE),
    m_pIStiDevControl(NULL),
    m_hShutdownEvent(INVALID_HANDLE_VALUE),
    m_hSignalEvent(INVALID_HANDLE_VALUE),
    m_hEventNotifyThread(NULL),
    m_guidLastEvent(GUID_NULL),
    m_pIWiaEventCallback(NULL),
    m_pStiDevice(NULL),
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pIDrvItemRoot(NULL)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::TestUsdDevice"));

    *m_szSrcDataName = L'\0';

    //
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    //

    if (punkOuter) {
        m_punkOuter = punkOuter;
    }
    else {

        //
        // Cast below is needed in order to point to right virtual table
        //

        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }

    //
    // init camera search path
    //

    LPTSTR lpwszEnvString = TEXT("%CAMERA_ROOT%");

    DWORD dwRet = ExpandEnvironmentStrings(lpwszEnvString,
                                           gpszPath, MAX_PATH);

    if ((dwRet == 0) || (dwRet == (ULONG)_tcslen(lpwszEnvString)+1)) {

        _tcscpy(gpszPath, TEXT("C:\\Image"));
    }

}

/**************************************************************************\
* TestUsdDevice::PrivateInitialize
*
*   Device class private initialization
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
\**************************************************************************/
HRESULT TestUsdDevice::PrivateInitialize()
{
    HRESULT hr = S_OK;

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_csShutdown, MINLONG)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_ERROR((g_hInst,"TestUsdDevice::PrivateInitialize init CritSect failed"));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    if(hr == S_OK) {
        //
        // Create event for syncronization of notifications shutdown.
        //

        m_hShutdownEvent =  CreateEvent(NULL,
                                        FALSE,
                                        FALSE,
                                        NULL);

        if (m_hShutdownEvent && (INVALID_HANDLE_VALUE != m_hShutdownEvent)) {
            m_fValid = TRUE;
        }
        else {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_ERROR((g_hInst,"TestUsdDevice::PrivateInitialize, create shutdown event failed"));
        }
    }

    return hr;
}

/**************************************************************************\
* TestUsdDevice::~TestUsdDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

TestUsdDevice::~TestUsdDevice(void)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::~TestUsdDevice"));


    //
    // Kill notification thread if it exists.
    //

    SetNotificationHandle(NULL);

    //
    // Close event for syncronization of notifications shutdown.
    //

    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hShutdownEvent);
    }

    //
    // Release the device control interface.
    //

    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }

    //
    // WIA member destruction
    //
    // Cleanup the WIA event sink.
    //

    if (m_pIWiaEventCallback) {
        m_pIWiaEventCallback->Release();
    }

    //
    // Free the storage for the device ID.
    //

    if (m_bstrDeviceID) {
        SysFreeString(m_bstrDeviceID);
    }

    //
    // Release the objects supporting device property storage.
    //

    if (m_bstrRootFullItemName) {
        SysFreeString(m_bstrRootFullItemName);
    }

    //
    // Free the critical section.
    //

    DeleteCriticalSection(&m_csShutdown);
}

/**************************************************************************\
* TestUsdDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    ZeroMemory(pUsdCaps, sizeof(*pUsdCaps));

    pUsdCaps->dwVersion = STI_VERSION;

    //
    // We do support device notifications, but do not requiring polling.
    //

    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT;

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::GetStatus"));

    //
    // Validate parameters.
    //

    if (!pDevStatus) {
        WIAS_ERROR((g_hInst,"TestUsdDevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    //
    // If we are asked, verify whether device is online.
    //

    pDevStatus->dwOnlineState = 0L;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {

        //
        // The test device is always on-line.
        //

        pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
    }

    //
    // If we are asked, verify state of event.
    //

    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;

    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {

        //
        // Generate an event the first time we load.
        //

        if (m_bUsdLoadEvent) {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;

            m_guidLastEvent = guidEventFirstLoaded;

            m_bUsdLoadEvent = FALSE;
        }

        //
        // event pending ???
        //

    }

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::DeviceReset
*
*   Reset data file pointer to start of file.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::DeviceReset(void)
{
    WIAS_TRACE((g_hInst,"DeviceReset"));

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::Diagnostic"));

    //
    // Initialize response buffer
    //

    pBuffer->dwStatusMask = 0;

    ZeroMemory(&pBuffer->sErrorInfo,sizeof(pBuffer->sErrorInfo));

    pBuffer->sErrorInfo.dwGenericError = NOERROR;
    pBuffer->sErrorInfo.dwVendorError = 0;

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::SetNotificationHandle(HANDLE hEvent)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::SetNotificationHandle"));

    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csShutdown);

    //
    // Are we starting or stopping the notification thread?
    //

    if (hEvent && (hEvent != INVALID_HANDLE_VALUE)) {

        m_hSignalEvent = hEvent;

        //
        // Initialize to no event.
        //

        m_guidLastEvent = GUID_NULL;

        //
        // Create the notification thread.
        //

        if (!m_hEventNotifyThread) {

            DWORD   dwThread;

            m_hEventNotifyThread = CreateThread(NULL,
                                                0,
                                                (LPTHREAD_START_ROUTINE)FileChangeThread,
                                                (LPVOID)this,
                                                0,
                                                &dwThread);

            if (m_hEventNotifyThread) {
                WIAS_TRACE((g_hInst,"TestUsdDevice::SetNotificationHandle, Enabling event notification"));
            }
            else {
                WIAS_ERROR((g_hInst,"TestUsdDevice::SetNotificationHandle, unable to create notification thread"));
                hr = HRESULT_FROM_WIN32(::GetLastError());
            }
        }
        else {
            WIAS_ERROR((g_hInst,"TestUsdDevice::SetNotificationHandle, spurious notification thread"));
            hr = STIERR_UNSUPPORTED;
        }
    }
    else {

        //
        // Disable event notifications.
        //

        SetEvent(m_hShutdownEvent);
        if (m_hEventNotifyThread) {
            WIAS_TRACE((g_hInst,"Disabling event notification"));
            WaitForSingleObject(m_hEventNotifyThread, 400);
            CloseHandle(m_hEventNotifyThread);
            m_hEventNotifyThread = NULL;
            m_guidLastEvent = GUID_NULL;

            //
            // close dlg
            //

            if (m_hDlg != NULL) {
                SendMessage(m_hDlg,WM_COMMAND,IDOK,0);
                m_hDlg = NULL;
            }

        }
    }
    LeaveCriticalSection(&m_csShutdown);
    return hr;
}

/**************************************************************************\
* TestUsdDevice::GetNotificationData
*
*   Provides data on n event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::GetNotificationData"));

    //
    // If we have notification ready - return it's guid
    //

    if (!IsEqualIID(m_guidLastEvent, GUID_NULL)) {

        pBuffer->guidNotificationCode  = m_guidLastEvent;

        m_guidLastEvent = GUID_NULL;

        pBuffer->dwSize = sizeof(STINOTIFY);

        ZeroMemory(&pBuffer->abNotificationData, sizeof(pBuffer->abNotificationData));

        //
        // private event
        //


        if (IsEqualIID(m_guidLastEvent, WIA_EVENT_NAME_CHANGE)) {

        }
    }
    else {
        return STIERR_NOEVENTS;
    }

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::Escape, unsupported"));

    //
    // Write command to device if needed.
    //

    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* TestUsdDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::GetLastError"));

    if (IsBadWritePtr(pdwLastDeviceError, sizeof(DWORD))) {
        return STIERR_INVALID_PARAM;
    }

    *pdwLastDeviceError = m_dwLastOperationError;

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::GetLastErrorInfo"));

    if (IsBadWritePtr(pLastErrorInfo, sizeof(STI_ERROR_INFO))) {
        return STIERR_INVALID_PARAM;
    }

    pLastErrorInfo->dwGenericError = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0] = '\0';

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::LockDevice(void)
{
    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::UnLockDevice(void)
{
    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::RawReadData"));

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           -
*    dwNumberOfBytes    -
*    lpOverlapped       -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::RawWriteData"));

    return STI_OK;
}

/**************************************************************************\
* TestUsdDevice::RawReadCommand
*
*
*
* Arguments:
*
*    lpBuffer           -
*    lpdwNumberOfBytes  -
*    lpOverlapped       -
*
* Return Value:
*
*    Status
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::RawReadCommand, unsupported"));

    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* TestUsdDevice::RawWriteCommand
*
*
*
* Arguments:
*
*    lpBuffer       -
*    nNumberOfBytes -
*    lpOverlapped   -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::RawWriteCommand, unsupported"));

    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* TestUsdDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    -
*    dwStiVersion           -
*    hParametersKey         -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP TestUsdDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    HRESULT         hr = STI_OK;
    UINT            uiNameLen = 0;
    CAMERA_STATUS   camStatus;

    WIAS_TRACE((g_hInst,"TestUsdDevice::Initialize"));

    if (!pIStiDevControl) {
        WIAS_ERROR((g_hInst,"TestUsdDevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    //
    // Cache the device control interface.
    //

    m_pIStiDevControl = pIStiDevControl;
    m_pIStiDevControl->AddRef();

    //
    // Try to open the camera only once here during Initialize
    //

    hr = CamOpenCamera(&camStatus);

    return (hr);
}

/**************************************************************************\
* TestUsdDevice::RunNotifications
*
*   Monitor changes to the source data file parent directory.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

VOID TestUsdDevice::RunNotifications(void)
{
    //
    // start up camera event dlg
    //

    WIAS_TRACE((g_hInst,"TestUsdDevice::RunNotifications: start up event dlg"));

    HWND hWnd = GetDesktopWindow();

    int iret = (int)DialogBoxParam(
        g_hInst,
        MAKEINTRESOURCE(IDD_EVENT_DLG),
        hWnd,
        CameraEventDlgProc,
        (LPARAM)this
        );

    WIAS_TRACE((g_hInst,"TestUsdDevice::RunNotifications, iret = 0x%lx",iret));

    if (iret == -1) {
        int err = ::GetLastError();
        WIAS_TRACE((g_hInst,"TestUsdDevice::RunNotifications, dlg error = 0x%lx",err));
    }
}

/**************************************************************************\
* FileChangeThread
*
*   Calls RunNotifications to detect changing source data file.
*
* Arguments:
*
*    lpParameter    - Pointer to device object.
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

VOID FileChangeThread(LPVOID  lpParameter)
{
    WIAS_TRACE((g_hInst,"TestUsdDevice::"));

    TestUsdDevice   *pThisDevice = (TestUsdDevice *)lpParameter;

    pThisDevice->RunNotifications();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\microdrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testmcro.rc
//

#define IDS_SCAN_BUTTON_NAME  700
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        701
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           701
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanapi\pch.h ===
#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <sti.h>
#include <assert.h>
#include <windows.h>
#include <stierr.h>

#define INITGUID
#include "initguid.h"
#include <stiusd.h>

#pragma intrinsic(memcmp,memset)

#include "resource.h"
#include "wiamindr.h"
#include "fscanapi.h"
#include "scanapi.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\microdrv\testmcro.cpp ===
#include "testmcro.h"
#include "wiamicro.h"
#include "resource.h"

#include <STI.H>
#include <math.h>
#include <winioctl.h>
#include <usbscan.h>

#ifdef DEBUG
#include <stdio.h>
#endif


// #define BUTTON_SUPPORT // (uncomment this to allow BUTTON SUPPORT)
                          // button support is not functional in the test device

#define MAX_BUTTONS 1
#define MAX_BUTTON_NAME 255

HINSTANCE g_hInst; // instance of this MicroDriver (used for loading from a resource)


// note: MEMORYBMP, and BMP file will be added by wiafbdrv host driver.
//       do not include them in your extended list.
//

// #define _USE_EXTENDED_FORMAT_LIST (uncomment this to allow Extented file and memory formats)

#define NUM_SUPPORTED_FILEFORMATS 1
GUID g_SupportedFileFormats[NUM_SUPPORTED_FILEFORMATS];

#define NUM_SUPPORTED_MEMORYFORMATS 2
GUID g_SupportedMemoryFormats[NUM_SUPPORTED_MEMORYFORMATS];

//
// Button GUID array used in Capability negotiation.
// Set your BUTTON guids here.  These must match the GUIDS specified in
// your INF.  The Scan Button GUID is public to all scanners with a
// scan button.
//

GUID g_Buttons[MAX_BUTTONS] ={{0xa6c5a715, 0x8c6e, 0x11d2,{ 0x97, 0x7a,  0x0,  0x0, 0xf8, 0x7a, 0x92, 0x6f}}};
BOOL g_bButtonNamesCreated = FALSE;
WCHAR* g_ButtonNames[MAX_BUTTONS];

INT g_PalIndex = 0;     // simple palette index counter (test driver specific)
BOOL g_bDown = FALSE;   // simple band direction bool   (test drvier specific)

BOOL    InitializeScanner(PSCANINFO pScanInfo);
VOID    InitScannerDefaults(PSCANINFO pScanInfo);
BOOL    SetScannerSettings(PSCANINFO pScanInfo);
VOID    CheckButtonStatus(PVAL pValue);
VOID    GetButtonPress(LONG *pButtonValue);
HRESULT GetInterruptEvent(PVAL pValue);
LONG    GetButtonCount();
HRESULT GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal);
VOID    ReadRegistryInformation(PVAL pValue);

BOOL APIENTRY DllMain( HANDLE hModule,DWORD  dwreason, LPVOID lpReserved)
{
    g_hInst = (HINSTANCE)hModule;
    switch(dwreason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

/**************************************************************************\
* MicroEntry (MicroDriver Entry point)
*
*   Called by the WIA driver to communicate with the MicroDriver.
*
* Arguments:
*
*   lCommand     - MicroDriver Command, sent from the WIA driver
*   pValue       - VAL structure used for settings
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

WIAMICRO_API HRESULT MicroEntry(LONG lCommand, PVAL pValue)
{
    HRESULT hr = E_NOTIMPL;
    DWORD dwBytesWritten = 0;
    INT index = 0;

//#define _DEBUG_COMMANDS

#ifdef _DEBUG_COMMANDS
    if(lCommand != CMD_STI_GETSTATUS)
        Trace(TEXT("Command Value (%d)"),lCommand);
#endif

    if(pValue->pScanInfo == NULL) {
        return E_INVALIDARG;
    }

    switch(lCommand) {
    case CMD_INITIALIZE:
        hr = S_OK;

        //
        // create any DeviceIO handles needed, use index (1 - MAX_IO_HANDLES) to store these handles.
        // Index '0' is reserved by the WIA flatbed driver. The CreateFile Name is stored in the szVal
        // member of the VAL structure.
        //

        // pValue->pScanInfo->DeviceIOHandles[1] = CreateFileA( pValue->szVal,
        //                                   GENERIC_READ | GENERIC_WRITE, // Access mask
        //                                   0,                            // Share mode
        //                                   NULL,                         // SA
        //                                   OPEN_EXISTING,                // Create disposition
        //                                   FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED,        // Attributes
        //                                   NULL );

        //
        // if your device supports buttons, create the BUTTON name information here..
        //

        if(!g_bButtonNamesCreated) {
            for(index = 0; index < MAX_BUTTONS; index++){
                g_ButtonNames[index] = (WCHAR*)CoTaskMemAlloc(MAX_BUTTON_NAME);
            }

            hr = GetOLESTRResourceString(IDS_SCAN_BUTTON_NAME,&g_ButtonNames[0],TRUE);
            if(SUCCEEDED(hr)){
                g_bButtonNamesCreated = TRUE;
            }
        }

        //
        // Initialize the scanner's default settings
        //

        InitScannerDefaults(pValue->pScanInfo);

        break;
    case CMD_UNINITIALIZE:

        //
        // close any open handles created by the Micro driver
        //

        if(pValue->pScanInfo->DeviceIOHandles[1] != NULL){
            CloseHandle(pValue->pScanInfo->DeviceIOHandles[1]);
        }


        //
        // if your device supports buttons, free/destroy the BUTTON name information here..
        //

        if(g_bButtonNamesCreated) {
            for(index = 0; index < MAX_BUTTONS; index++){
                CoTaskMemFree(g_ButtonNames[index]);
            }
        }

        //
        // close/unload libraries
        //

        hr = S_OK;
        break;
    case CMD_RESETSCANNER:

        //
        // reset scanner
        //

        hr = S_OK;
        break;
    case CMD_STI_DIAGNOSTIC:
    case CMD_STI_DEVICERESET:

        //
        // reset device
        //

        hr = S_OK;
        break;
    case CMD_STI_GETSTATUS:

        //
        // set status flag to ON-LINE
        //

        pValue->lVal = MCRO_STATUS_OK;
        pValue->pGuid = (GUID*) &GUID_NULL;

        //
        // button polling support
        //

#ifdef BUTTON_SUPPORT
        CheckButtonStatus(pValue);
#endif

        hr = S_OK;
        break;
    case CMD_SETXRESOLUTION:
        pValue->pScanInfo->Xresolution = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETYRESOLUTION:
        pValue->pScanInfo->Yresolution = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETCONTRAST:
        pValue->pScanInfo->Contrast    = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETINTENSITY:
        pValue->pScanInfo->Intensity   = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETDATATYPE:
        pValue->pScanInfo->DataType    = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_SETNEGATIVE:
        pValue->pScanInfo->Negative    = pValue->lVal;
        hr = S_OK;
        break;
    case CMD_GETADFSTATUS:
    case CMD_GETADFHASPAPER:
        // pValue->lVal = MCRO_ERROR_PAPER_EMPTY;
        // hr = S_OK;
        break;
    case CMD_GET_INTERRUPT_EVENT:
        hr = GetInterruptEvent(pValue);
        break;
    case CMD_GETCAPABILITIES:
        pValue->lVal = 0;
        pValue->pGuid = NULL;
        pValue->ppButtonNames = NULL;
        hr = S_OK;
        break;

    case CMD_SETSCANMODE:
        hr = S_OK;
        switch(pValue->lVal){
        case SCANMODE_FINALSCAN:
            Trace(TEXT("Final Scan"));
            break;
        case SCANMODE_PREVIEWSCAN:
            Trace(TEXT("Preview Scan"));
            break;
        default:
            Trace(TEXT("Unknown Scan Mode (%d)"),pValue->lVal);
            hr = E_FAIL;
            break;
        }
        break;
    case CMD_SETSTIDEVICEHKEY:
        ReadRegistryInformation(pValue);
        break;

#ifdef _USE_EXTENDED_FORMAT_LIST

    // note: MEMORYBMP, and BMP file will be added by wiafbdrv host driver.
    //       do not include them in your extended list.
    //

    case CMD_GETSUPPORTEDFILEFORMATS:
        g_SupportedFileFormats[0] = WiaImgFmt_JPEG;
        pValue->lVal = NUM_SUPPORTED_FILEFORMATS;
        pValue->pGuid = g_SupportedFileFormats;
        hr = S_OK;
        break;

    case CMD_GETSUPPORTEDMEMORYFORMATS:
        g_SupportedMemoryFormats[0] = WiaImgFmt_TIFF;
        g_SupportedMemoryFormats[1] = WiaImgFmt_MYNEWFORMAT;
        pValue->lVal = NUM_SUPPORTED_MEMORYFORMATS;
        pValue->pGuid = g_SupportedMemoryFormats;
        hr = S_OK;
        break;
#endif

    default:
        Trace(TEXT("Unknown Command (%d)"),lCommand);
        break;
    }

    return hr;
}

/**************************************************************************\
* Scan (MicroDriver Entry point)
*
*   Called by the WIA driver to acquire data from the MicroDriver.
*
* Arguments:
*
*   pScanInfo    - SCANINFO structure used for settings
*   lPhase       - Current Scan phase, SCAN_FIRST, SCAN_NEXT, SCAN_FINISH...
*   pBuffer      - data buffer to be filled with scanned data
*   lLength      - Maximum length of pBuffer
*   plReceived   - Number of actual bytes written to pBuffer.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

WIAMICRO_API HRESULT Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived)
{
    if(pScanInfo == NULL) {
        return E_INVALIDARG;
    }

    INT i = 0;

    Trace(TEXT("------ Scan Requesting %d ------"),lLength);
    switch (lPhase) {
    case SCAN_FIRST:
        if (!SetScannerSettings(pScanInfo)) {
            return E_FAIL;
        }

        Trace(TEXT("SCAN_FIRST"));

        g_PalIndex = 0;
        g_bDown = FALSE;

        //
        // first phase
        //

        Trace(TEXT("Start Scan.."));

    case SCAN_NEXT: // SCAN_FIRST will fall through to SCAN_NEXT (because it is expecting data)

        //
        // next phase
        //

        if(lPhase == SCAN_NEXT)
            Trace(TEXT("SCAN_NEXT"));

        //
        // get data from the scanner and set plReceived value
        //

        //
        // read data
        //

        switch(pScanInfo->DataType) {
        case WIA_DATA_THRESHOLD:

            //
            // make buffer alternate black/White, for sample 1-bit data
            //

            memset(pBuffer,0,lLength);
            memset(pBuffer,255,lLength/2);
            break;
        case WIA_DATA_GRAYSCALE:

            //
            // make buffer grayscale data, for sample 8-bit data
            //

            if(!g_bDown){
                g_PalIndex+=10;
                if(g_PalIndex > 255){
                    g_PalIndex = 255;
                    g_bDown = TRUE;
                }
            }
            else {
                g_PalIndex-=10;
                if(g_PalIndex < 0){
                    g_PalIndex = 0;
                    g_bDown = FALSE;
                }
            }
            memset(pBuffer,g_PalIndex,lLength);
            break;
        case WIA_DATA_COLOR:

            //
            // make buffer red, for sample color data
            //

            for (i = 0;i+2<lLength;i+=3) {
                memset(pBuffer+i,255,1);
                memset(pBuffer+(i+1),0,1);
                memset(pBuffer+(i+2),0,1);
            }
            break;
        default:
            break;
        }

        //
        // test device always returns the exact amount of scanned data
        //

        *plReceived = lLength;
        break;
    case SCAN_FINISHED:
    default:
        Trace(TEXT("SCAN_FINISHED"));

        //
        // stop scanner, do not set lRecieved, or write any data to pBuffer.  Those values
        // will be NULL.  This lPhase is only to allow you to stop scanning, and return the
        // scan head to the HOME position. SCAN_FINISHED will be called always for regular scans, and
        // for cancelled scans.
        //

        break;
    }

    return S_OK;
}

/**************************************************************************\
* SetPixelWindow (MicroDriver Entry point)
*
*   Called by the WIA driver to set the scan selection area to the MicroDriver.
*
* Arguments:
*
*   pScanInfo    - SCANINFO structure used for settings
*   pValue       - VAL structure used for settings
*   x            - X Position of scan rect (upper left x coordinate)
*   y            - Y Position of scan rect (upper left y coordinate)
*   xExtent      - Width of scan rect  (in pixels)
*   yExtent      - Height of scan rect (in pixels)
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

WIAMICRO_API HRESULT SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent)
{
    if(pScanInfo == NULL) {
        return E_INVALIDARG;
    }

    pScanInfo->Window.xPos = x;
    pScanInfo->Window.yPos = y;
    pScanInfo->Window.xExtent = xExtent;
    pScanInfo->Window.yExtent = yExtent;
    return S_OK;
}


/**************************************************************************\
* ReadRegistryInformation (helper)
*
*   Called by the MicroDriver to Read registry information from the device's
*   installed device section. The HKEY passed in will be closed by the host
*   driver after CMD_INITIALIZE is completed.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    void
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/
VOID ReadRegistryInformation(PVAL pValue)
{
    HKEY hKey = NULL;
    if(NULL != pValue->pHandle){
        hKey = (HKEY)*pValue->pHandle;

        //
        // Open DeviceData section to read driver specific information
        //

        HKEY hOpenKey = NULL;
        if (RegOpenKeyEx(hKey,                     // handle to open key
                         TEXT("DeviceData"),       // address of name of subkey to open
                         0,                        // options (must be NULL)
                         KEY_QUERY_VALUE|KEY_READ, // just want to QUERY a value
                         &hOpenKey                 // address of handle to open key
                        ) == ERROR_SUCCESS) {

            DWORD dwWritten = sizeof(DWORD);
            DWORD dwType = REG_DWORD;

            LONG lSampleEntry = 0;
            RegQueryValueEx(hOpenKey,
                            TEXT("Sample Entry"),
                            NULL,
                            &dwType,
                            (LPBYTE)&lSampleEntry,
                            &dwWritten);
            Trace(TEXT("lSampleEntry Value = %d"),lSampleEntry);
        } else {
            Trace(TEXT("Could not open DeviceData section"));
        }
    }
}

/**************************************************************************\
* InitScannerDefaults (helper)
*
*   Called by the MicroDriver to Initialize the SCANINFO structure
*
* Arguments:
*
*    none
*
* Return Value:
*
*    void
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

VOID InitScannerDefaults(PSCANINFO pScanInfo)
{

    pScanInfo->ADF                    = 0; // set to no ADF in Test device
    pScanInfo->RawDataFormat          = WIA_PACKED_PIXEL;
    pScanInfo->RawPixelOrder          = WIA_ORDER_BGR;
    pScanInfo->bNeedDataAlignment     = TRUE;

    pScanInfo->SupportedCompressionType = 0;
    pScanInfo->SupportedDataTypes     = SUPPORT_BW|SUPPORT_GRAYSCALE|SUPPORT_COLOR;

    pScanInfo->BedWidth               = 8500;  // 1000's of an inch (WIA compatible unit)
    pScanInfo->BedHeight              = 11000; // 1000's of an inch (WIA compatible unit)

    pScanInfo->OpticalXResolution     = 300;
    pScanInfo->OpticalYResolution     = 300;

    pScanInfo->IntensityRange.lMin    = -127;
    pScanInfo->IntensityRange.lMax    =  127;
    pScanInfo->IntensityRange.lStep   = 1;

    pScanInfo->ContrastRange.lMin     = -127;
    pScanInfo->ContrastRange.lMax     = 127;
    pScanInfo->ContrastRange.lStep    = 1;

    // Scanner settings
    pScanInfo->Intensity              = 0;
    pScanInfo->Contrast               = 0;

    pScanInfo->Xresolution            = 150;
    pScanInfo->Yresolution            = 150;

    pScanInfo->Window.xPos            = 0;
    pScanInfo->Window.yPos            = 0;
    pScanInfo->Window.xExtent         = (pScanInfo->Xresolution * pScanInfo->BedWidth)/1000;
    pScanInfo->Window.yExtent         = (pScanInfo->Yresolution * pScanInfo->BedHeight)/1000;

    // Scanner options
    pScanInfo->DitherPattern          = 0;
    pScanInfo->Negative               = 0;
    pScanInfo->Mirror                 = 0;
    pScanInfo->AutoBack               = 0;
    pScanInfo->ColorDitherPattern     = 0;
    pScanInfo->ToneMap                = 0;
    pScanInfo->Compression            = 0;

        // Image Info
    pScanInfo->DataType               = WIA_DATA_GRAYSCALE;
    pScanInfo->WidthPixels            = (pScanInfo->Window.xExtent)-(pScanInfo->Window.xPos);

    switch(pScanInfo->DataType) {
    case WIA_DATA_THRESHOLD:
        pScanInfo->PixelBits = 1;
        break;
    case WIA_DATA_COLOR:
        pScanInfo->PixelBits = 24;
        break;
    case WIA_DATA_GRAYSCALE:
    default:
        pScanInfo->PixelBits = 8;
        break;
    }

    pScanInfo->WidthBytes = pScanInfo->Window.xExtent * (pScanInfo->PixelBits/8);
    pScanInfo->Lines      = pScanInfo->Window.yExtent;
}

/**************************************************************************\
* SetScannerSettings (helper)
*
*   Called by the MicroDriver to set the values stored in the SCANINFO structure
*   to the actual device.
*
* Arguments:
*
*     none
*
*
* Return Value:
*
*    TRUE - Success, FALSE - Failure
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

BOOL SetScannerSettings(PSCANINFO pScanInfo)
{
    if(pScanInfo->DataType == WIA_DATA_THRESHOLD) {
        pScanInfo->PixelBits = 1;
        pScanInfo->WidthBytes         = (pScanInfo->Window.xExtent)-(pScanInfo->Window.xPos) * (pScanInfo->PixelBits/7);

        //
        // Set data type to device
        //

        // if the set fails..
        // return FALSE;
    }
    else if(pScanInfo->DataType == WIA_DATA_GRAYSCALE) {
        pScanInfo->PixelBits = 8;
        pScanInfo->WidthBytes         = (pScanInfo->Window.xExtent)-(pScanInfo->Window.xPos) * (pScanInfo->PixelBits/8);

        //
        // Set data type to device
        //

        // if the set fails..
        // return FALSE;

    }
    else {
        pScanInfo->PixelBits = 24;
        pScanInfo->WidthBytes         = (pScanInfo->Window.xExtent)-(pScanInfo->Window.xPos) * (pScanInfo->PixelBits/8);

        //
        // Set data type to device
        //

        // if the set fails..
        // return FALSE;

    }

#ifdef DEBUG
    Trace(TEXT("ScanInfo"));
    Trace(TEXT("x res = %d"),pScanInfo->Xresolution);
    Trace(TEXT("y res = %d"),pScanInfo->Yresolution);
    Trace(TEXT("bpp   = %d"),pScanInfo->PixelBits);
    Trace(TEXT("xpos  = %d"),pScanInfo->Window.xPos);
    Trace(TEXT("ypos  = %d"),pScanInfo->Window.yPos);
    Trace(TEXT("xext  = %d"),pScanInfo->Window.xExtent);
    Trace(TEXT("yext  = %d"),pScanInfo->Window.yExtent);
#endif

    //
    // send other values to device, use the values set in pScanInfo to set them to your
    // device.
    //

    return TRUE;
}

/**************************************************************************\
* InitializeScanner (helper)
*
*   Called by the MicroDriver to Iniitialize any device specific operations
*
* Arguments:
*
*    none
*
* Return Value:
*
*    TRUE - Success, FALSE - Failure
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

BOOL InitializeScanner(PSCANINFO pScanInfo)
{
    HRESULT hr = S_OK;

    //
    // Do any device initialization here...
    // The test device does not need any.
    //

    if (SUCCEEDED(hr)) {
        return TRUE;
    }
    return FALSE;
}

/**************************************************************************\
* CheckButtonStatus (helper)
*
*   Called by the MicroDriver to Set the current Button pressed value.
*
* Arguments:
*
*   pValue       - VAL structure used for settings
*
*
* Return Value:
*
*    VOID
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/


VOID CheckButtonStatus(PVAL pValue)
{
    //
    // Button Polling is done here...
    //

    //
    // Check your device for button presses
    //

    LONG lButtonValue = 0;

    GetButtonPress(&lButtonValue);
    switch (lButtonValue) {
    case 1:
        pValue->pGuid = (GUID*) &guidScanButton;
        Trace(TEXT("Scan Button Pressed!"));
        break;
    default:
        pValue->pGuid = (GUID*) &GUID_NULL;
        break;
    }
}
/**************************************************************************\
* GetInterruptEvent (helper)
*
*   Called by the MicroDriver to handle USB interrupt events.
*
* Arguments:
*
*   pValue       - VAL structure used for settings
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

HRESULT GetInterruptEvent(PVAL pValue)
{
    //
    // Below is a simple example of how DeviceIOControl() can be used to
    // determine interrupts with a USB device.
    //
    // The test device does not support events,
    // So this should not be called.
    //

    BYTE    InterruptData;
    DWORD   dwIndex;
    DWORD   dwError;

    OVERLAPPED Overlapped;
    ZeroMemory( &Overlapped, sizeof( Overlapped ));
    Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    HANDLE  hEventArray[2] = {pValue->handle, Overlapped.hEvent};
    BOOL    fLooping = TRUE;
    BOOL    bRet = TRUE;

    //
    // use the Handle created in CMD_INITIALIZE.
    //

    HANDLE  InterruptHandle = pValue->pScanInfo->DeviceIOHandles[1];

    while (fLooping) {

        //
        // Set the wait event, for the interrupt
        //

        bRet = DeviceIoControl( InterruptHandle,
                                IOCTL_WAIT_ON_DEVICE_EVENT,
                                NULL,
                                0,
                                &InterruptData,
                                sizeof(InterruptData),
                                &dwError,
                                &Overlapped );

        if ( bRet || ( !bRet && ( ::GetLastError() == ERROR_IO_PENDING ))) {

            //
            // Wait for the event to happen
            //

            dwIndex = WaitForMultipleObjects( 2,
                                              hEventArray,
                                              FALSE,
                                              INFINITE );

            //
            // Trap the result of the event
            //

            switch ( dwIndex ) {
                case WAIT_OBJECT_0+1:
                    DWORD dwBytesRet;
                    bRet = GetOverlappedResult( InterruptHandle, &Overlapped, &dwBytesRet, FALSE );

                    if ( dwBytesRet ) {

                        //
                        // assign the corresponding button GUID to the *pValue->pGuid
                        // member., and Set the event.
                        //

                        // Change detected - signal
                        if (*pValue->pHandle != INVALID_HANDLE_VALUE) {
                            switch ( InterruptData ) {
                            case 1:
                                *pValue->pGuid = guidScanButton;
                                Trace(TEXT("Scan Button Pressed!"));
                                break;
                            default:
                                *pValue->pGuid = GUID_NULL;
                                break;
                            }
                            Trace(TEXT("Setting This Event by Handle %d"),*pValue->pHandle);

                            //
                            // signal the event, after a button GUID was assigned.
                            //

                            SetEvent(*pValue->pHandle);
                        }
                        break;
                    }

                    //
                    // reset the overlapped event
                    //

                    ResetEvent( Overlapped.hEvent );
                    break;

                case WAIT_OBJECT_0:
                    // Fall through
                default:
                    fLooping = FALSE;
            }
        }
        else {
            dwError = ::GetLastError();
            break;
        }
    }
    return S_OK;
}

/**************************************************************************\
* GetButtonPress (helper)
*
*   Called by the MicroDriver to set the actual button value pressed
*
* Arguments:
*
*   pButtonValue       - actual button pressed
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

VOID GetButtonPress(LONG *pButtonValue)
{

    //
    // This where you can set your button value
    //

    pButtonValue = 0;
}

/**************************************************************************\
* GetButtonCount (helper)
*
*   Called by the MicroDriver to get the number of buttons a device supports
*
* Arguments:
*
*    none
*
* Return Value:
*
*    LONG - number of supported buttons
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

LONG GetButtonCount()
{
    LONG ButtonCount  = 0;

    //
    // Since the test device does not have a button,
    // set this value to 0.  For a real device with a button,
    // set (LONG ButtonCount  = 1;)
    //

    //
    // determine the button count of your device
    //

    return ButtonCount;
}

/**************************************************************************\
* GetOLDSTRResourceString (helper)
*
*   Called by the MicroDriver to Load a resource string in OLESTR format
*
* Arguments:
*
*   lResourceID  - String resource ID
*   ppsz         - Pointer to a OLESTR to be filled with the loaded string
*                  value
*   bLocal       - Possible, other source for loading a resource string.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

HRESULT GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        INT NumTCHARs = LoadString(g_hInst,lResourceID,szStringValue,sizeof(szStringValue));
        DWORD dwError = GetLastError();

        if (NumTCHARs <= 0) {

#ifdef UNICODE
            Trace(TEXT("NumTCHARs = %d dwError = %d Resource ID = %d (UNICODE)szString = %ws"),
                  NumTCHARs,
                  dwError,
                  lResourceID,
                  szStringValue);
#else
            Trace(TEXT("NumTCHARs = %d dwError = %d Resource ID = %d (ANSI)szString = %s"),
                  NumTCHARs,
                  dwError,
                  lResourceID,
                  szStringValue);
#endif

            return E_FAIL;
        }

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[255];
       ZeroMemory(wszStringValue,sizeof(wszStringValue));

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // looking another place for resources??
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* Trace
*
*   Called by the MicroDriver to output strings to a debugger
*
* Arguments:
*
*   format       - formatted string to output
*
*
* Return Value:
*
*    VOID
*
* History:
*
*    1/20/2000 Original Version
*
\**************************************************************************/

VOID Trace(LPCTSTR format,...)
{

#ifdef DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\microdrv\testmcro.h ===
#ifndef TESTMCRO
#define TESTMCRO

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define INITGUID
#include <windows.h>

//
// Button GUIDS
//

DEFINE_GUID( guidScanButton, 0xa6c5a715, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);

// copy any known formats defined in wiadef.h to this location for use in your driver.

DEFINE_GUID(WiaImgFmt_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

// define your custom-defined supported formats here
// {3B5DE639-B2C6-4952-98A9-1DC06F3703BD}
DEFINE_GUID(WiaImgFmt_MYNEWFORMAT, 0x3b5de639, 0xb2c6, 0x4952, 0x98, 0xa9, 0x1d, 0xc0, 0x6f, 0x37, 0x3, 0xbd);

#undef INITGUID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\inc\fscanapi.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       fscanapi.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#ifndef _FSCANAPI_H
#define _FSCANAPI_H

//
// ID mappings to events
//

#define ID_FAKE_NOEVENT             0
#define ID_FAKE_SCANBUTTON          100
#define ID_FAKE_COPYBUTTON          200
#define ID_FAKE_FAXBUTTON           300
#define ID_FAKE_ADFEVENT            400

//
// Scanner library modes
//

#define FLATBED_SCANNER_MODE        100
#define SCROLLFED_SCANNER_MODE      200
#define MULTIFUNCTION_DEVICE_MODE   300

//
// Scanning states
//

#define SCAN_START                  0
#define SCAN_CONTINUE               1
#define SCAN_END                    3

//
// Root Item information (for property initialization)
//

typedef struct _ROOT_ITEM_INFORMATION {
    LONG ScanBedWidth;          // 1/1000ths of an inch
    LONG ScanBedHeight;         // 1/1000ths of an inch
    LONG OpticalXResolution;    // Optical X Resolution of device
    LONG OpticalYResolution;    // Optical X Resolution of device
    LONG MaxScanTime;           // Milliseconds (total scan time)

    LONG DocumentFeederWidth;   // 1/1000ths of an inch
    LONG DocumentFeederHeight;  // 1/1000ths of an inch
    LONG DocumentFeederCaps;    // Capabilites of the device with feeder
    LONG DocumentFeederStatus;  // Status of document feeder
    LONG MaxPageCapacity;       // Maximum page capacity of feeder
    LONG DocumentFeederReg;     // document feeder alignment
    LONG DocumentFeederHReg;    // document feeder justification alignment (HORIZONTAL)
    LONG DocumentFeederVReg;    // document feeder justification alignment (VERTICAL)
    WCHAR FirmwareVersion[25];  // Firmware version of device
}ROOT_ITEM_INFORMATION, *PROOT_ITEM_INFORMATION;

//
// Range data type helper structure (used below)
//

typedef struct _RANGEPROPERTY {
    LONG lMin;  // minimum value
    LONG lMax;  // maximum value
    LONG lNom;  // numinal value
    LONG lInc;  // increment/step value
} RANGEPROPERTY,*PRANGEPROPERTY;

//
// Top Item information (for property initialization)
//

typedef struct _TOP_ITEM_INFORMATION {
    BOOL          bUseResolutionList;   // TRUE - use default Resolution list,
                                        // FALSE - use RANGEPROPERTY values
    RANGEPROPERTY Contrast;             // valid values for contrast
    RANGEPROPERTY Brightness;           // valid values for brightness
    RANGEPROPERTY Threshold;            // valid values for threshold
    RANGEPROPERTY XResolution;          // valid values for x resolution
    RANGEPROPERTY YResolution;          // valid values for y resolution
    LONG          lMinimumBufferSize;   // minimum buffer size
    LONG          lMaxLampWarmupTime;   // maximum lamp warmup time
} TOP_ITEM_INFORMATION, *PTOP_ITEM_INFORMATION;

class CFakeScanAPI {
public:

    //
    // constructor/destructor
    //

    CFakeScanAPI()
    {

    }
    ~CFakeScanAPI()
    {

    }
    
    //
    // device initialization function
    //

    virtual HRESULT FakeScanner_Initialize() = 0;

    //
    // device setting functions
    //

    virtual HRESULT FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo) = 0;
    virtual HRESULT FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo)    = 0;
    virtual HRESULT FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight)         = 0;

    //
    // device event functions
    //

    virtual HRESULT FakeScanner_GetDeviceEvent(LONG *pEvent)           = 0;
    virtual VOID    FakeScanner_SetInterruptEventHandle(HANDLE hEvent) = 0;
    virtual HRESULT DoEventProcessing()                                = 0;

    //
    // data acquisition functions
    //

    virtual HRESULT FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten) = 0;
    virtual HRESULT FakeScanner_SetDataType(LONG lDataType)   = 0;
    virtual HRESULT FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution) = 0;
    virtual HRESULT FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt) = 0;
    virtual HRESULT FakeScanner_SetContrast(LONG lContrast)   = 0;
    virtual HRESULT FakeScanner_SetIntensity(LONG lIntensity) = 0;

    //
    // standard device operations
    //

    virtual HRESULT FakeScanner_ResetDevice()   = 0;
    virtual HRESULT FakeScanner_SetEmulationMode(LONG lDeviceMode) = 0;
    virtual HRESULT FakeScanner_DisableDevice() = 0;
    virtual HRESULT FakeScanner_EnableDevice()  = 0;
    virtual HRESULT FakeScanner_DeviceOnline()  = 0;
    virtual HRESULT FakeScanner_Diagnostic()    = 0;

    //
    // Automatic document feeder functions
    //

    virtual HRESULT FakeScanner_ADFAttached()   = 0;
    virtual HRESULT FakeScanner_ADFHasPaper()   = 0;
    virtual HRESULT FakeScanner_ADFAvailable()  = 0;
    virtual HRESULT FakeScanner_ADFFeedPage()   = 0;
    virtual HRESULT FakeScanner_ADFUnFeedPage() = 0;
    virtual HRESULT FakeScanner_ADFStatus()     = 0;    
};

HRESULT CreateInstance(CFakeScanAPI **ppFakeScanAPI, LONG lMode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanapi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scanapi.rc
//

#define IDS_SYSTRAY_TOOL_TIP    100
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanapi\scanapi.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       scanapi.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#include "pch.h"
#include "scanapi.h"    // private header for SCANAPI
#include "time.h"

#define THREAD_TERMINATION_TIMEOUT 10000

CFScanAPI::CFScanAPI()
{

#ifdef _USE_BITMAP_DATA

    m_hSrcFileHandle        = NULL;
    m_hSrcMappingHandle     = NULL;
    m_pSrcData              = NULL; // 24-bit only
    m_pRawData              = NULL;
    m_hRawDataFileHandle    = NULL;
    m_hRawDataMappingHandle = NULL;

#endif

    m_hEventHandle          = NULL;
    m_hKillEventThread      = NULL;
    m_hEventNotifyThread    = NULL;
    m_lLastEvent            = ID_FAKE_NOEVENT;
    m_hrLastADFError        = S_OK;
    m_bGreen                = TRUE;
    m_dwBytesWrittenSoFAR   = 0;
    m_TotalDataInDevice     = 0;

    memset(&m_ftScanButton,0,sizeof(FILETIME));
    memset(&m_ftCopyButton,0,sizeof(FILETIME));
    memset(&m_ftFaxButton, 0,sizeof(FILETIME));
    memset(&m_RawDataInfo, 0,sizeof(RAW_DATA_INFORMATION));
    memset(&m_SrcDataInfo, 0,sizeof(RAW_DATA_INFORMATION));

}

CFScanAPI::~CFScanAPI()
{

#ifdef _USE_BITMAP_DATA

    if(m_hSrcMappingHandle){
        CloseHandle(m_hSrcMappingHandle);
        m_hSrcMappingHandle = NULL;
    }

    if(m_hSrcFileHandle){
        CloseHandle(m_hSrcFileHandle);
        m_hSrcFileHandle = NULL;
    }

    CloseRAW();

#endif

}

HRESULT CFScanAPI::FakeScanner_Initialize()
{
    HRESULT hr = E_FAIL;
    if (NULL == m_hEventNotifyThread) {

        //
        // create KILL event to signal, for device
        // shutdown of the fake scanner's events
        //

        m_hKillEventThread = CreateEvent(NULL,FALSE,FALSE,NULL);
        ::ResetEvent(m_hKillEventThread);
        if(NULL != m_hKillEventThread){

            //
            // create event thread, for file change status to fake scanner events
            //

            DWORD dwThread = 0;
            m_hEventNotifyThread = ::CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)FakeScannerEventThread,
                                                 (LPVOID)this,0,&dwThread);
            if(NULL != m_hEventNotifyThread){
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CFScanAPI::Load24bitScanData(LPTSTR szBitmapFileName)
{
    HRESULT hr = S_OK;

#ifdef _USE_BITMAP_DATA

    m_hSrcFileHandle = NULL;
    m_hSrcFileHandle = CreateFile(szBitmapFileName,GENERIC_READ,FILE_SHARE_READ,NULL,
                OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

    if(NULL != m_hSrcFileHandle && INVALID_HANDLE_VALUE != m_hSrcFileHandle){

        m_hSrcMappingHandle = CreateFileMapping(m_hSrcFileHandle, NULL, PAGE_READONLY, 0, 0, NULL);
        m_pSrcData = (PBYTE)MapViewOfFileEx(m_hSrcMappingHandle, FILE_MAP_READ, 0, 0, 0,NULL);

        DWORD dwBytesRead = 0;
        m_pSrcData = m_pSrcData + sizeof(BITMAPFILEHEADER);
        if(m_pSrcData){

            //
            // check bitmap info
            //

            BITMAPINFOHEADER *pbmih;
            pbmih = (BITMAPINFOHEADER*)m_pSrcData;
            if(pbmih->biBitCount != 24){
                hr = E_INVALIDARG;
            } else {
                m_SrcDataInfo.bpp           = pbmih->biBitCount;
                m_SrcDataInfo.lHeightPixels = pbmih->biHeight;
                m_SrcDataInfo.lWidthPixels  = pbmih->biWidth;
                m_SrcDataInfo.lOffset       = 0;
            }
        }

    } else {
        hr = E_FAIL;
    }

    if(FAILED(hr)){
        CloseHandle(m_hSrcMappingHandle);
        m_hSrcMappingHandle = NULL;
        CloseHandle(m_hSrcFileHandle);
        m_hSrcFileHandle = NULL;
    }

#endif

    return hr;
}

HRESULT CFScanAPI::FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo)
{
    HRESULT hr = S_OK;

    //
    // Fill in Root item property defaults
    //

    if(m_lMode == SCROLLFED_SCANNER_MODE){
        pRootItemInfo->DocumentFeederCaps   = FEEDER;
        pRootItemInfo->DocumentFeederStatus = FEED_READY;
        pRootItemInfo->DocumentFeederHReg   = CENTERED;
        pRootItemInfo->DocumentFeederReg    = CENTERED;
    } else {
        pRootItemInfo->DocumentFeederCaps   = FEEDER|FLATBED;
        pRootItemInfo->DocumentFeederStatus = FLAT_READY;
        pRootItemInfo->DocumentFeederHReg   = LEFT_JUSTIFIED;
        pRootItemInfo->DocumentFeederReg    = LEFT_JUSTIFIED;
    }

    pRootItemInfo->DocumentFeederWidth  = 8500;
    pRootItemInfo->DocumentFeederHeight = 11000;
    pRootItemInfo->DocumentFeederHReg   = LEFT_JUSTIFIED;
    pRootItemInfo->DocumentFeederReg    = LEFT_JUSTIFIED;
    pRootItemInfo->DocumentFeederVReg   = TOP_JUSTIFIED;
    pRootItemInfo->MaxPageCapacity      = MAX_PAGE_CAPACITY;
    pRootItemInfo->MaxScanTime          = MAX_SCANNING_TIME;
    pRootItemInfo->OpticalXResolution   = 300;
    pRootItemInfo->OpticalYResolution   = 300;
    pRootItemInfo->ScanBedWidth         = 8500;
    pRootItemInfo->ScanBedHeight        = 11000;

    //
    // copy firmware version in string form to WCHAR array
    //

    lstrcpy(pRootItemInfo->FirmwareVersion,L"1.0a");

    return hr;
}
HRESULT CFScanAPI::FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo)
{
    HRESULT hr = S_OK;
    pTopItemInfo->bUseResolutionList    = TRUE; // use default resolution list

    pTopItemInfo->Brightness.lInc       = 1;
    pTopItemInfo->Brightness.lMax       = 200;
    pTopItemInfo->Brightness.lMin       = -200;
    pTopItemInfo->Brightness.lNom       = 10;

    pTopItemInfo->Contrast.lInc         = 1;
    pTopItemInfo->Contrast.lMax         = 200;
    pTopItemInfo->Contrast.lMin         = -200;
    pTopItemInfo->Contrast.lNom         = 10;

    pTopItemInfo->Threshold.lInc        = 1;
    pTopItemInfo->Threshold.lMax        = 200;
    pTopItemInfo->Threshold.lMin        = -200;
    pTopItemInfo->Threshold.lNom        = 10;

    pTopItemInfo->lMaxLampWarmupTime    = MAX_LAMP_WARMUP_TIME;
    pTopItemInfo->lMinimumBufferSize    = 262140;

    pTopItemInfo->XResolution.lInc      = 1;
    pTopItemInfo->XResolution.lMax      = 600;
    pTopItemInfo->XResolution.lMin      = 75;
    pTopItemInfo->XResolution.lNom      = 150;

    pTopItemInfo->YResolution.lInc      = 1;
    pTopItemInfo->YResolution.lMax      = 600;
    pTopItemInfo->YResolution.lMin      = 75;
    pTopItemInfo->YResolution.lNom      = 150;

    return hr;
}

HRESULT CFScanAPI::FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten)
{
    HRESULT hr = S_OK;

    switch (lState) {
    case SCAN_START:
        m_dwBytesWrittenSoFAR = 0;
        m_TotalDataInDevice   = CalcRandomDeviceDataTotalBytes();
        break;
    case SCAN_CONTINUE:
        break;
    case SCAN_END:
        m_bGreen = TRUE; // set back to green
        return S_OK;
    default:
        break;
    }

    //Trace(TEXT("Requesting %d, of %d Total Image bytes"),dwBytesToRead,m_TotalDataInDevice);

    if (NULL != pData) {
        switch (m_RawDataInfo.bpp) {
        case 24:
            {
                //
                // write green data for color
                //

                BYTE *pTempData = pData;
                for (DWORD dwBytes = 0; dwBytes < dwBytesToRead; dwBytes+=3) {
                    if(m_bGreen){
                        pTempData[0] = 0;
                        pTempData[1] = 128;  // green
                        pTempData[2] = 0;
                    } else {
                        pTempData[0] = 0;
                        pTempData[1] = 0;
                        pTempData[2] = 128;  // blue
                    }
                    pTempData += 3;
                }
            }
            break;
        case 1:
        case 8:
        default:

            //
            // write simple gray for grayscale,
            // write vertical B/W stripes for threshold
            //

            if(m_bGreen){
                memset(pData,128,dwBytesToRead);
            } else {
                memset(pData,200,dwBytesToRead);
            }
            break;
        }
    }

    //
    // fill out bytes written
    //

    if(NULL != pdwBytesWritten){
        *pdwBytesWritten = dwBytesToRead;
    }

    if (m_bGreen) {
        m_bGreen = FALSE;
    } else {
        m_bGreen = TRUE;
    }

    if(m_lMode == SCROLLFED_SCANNER_MODE){

        //
        // keep track of bytes written so far
        //

        if(m_TotalDataInDevice == 0){

            //
            // no data left in device
            //

            *pdwBytesWritten = 0;
            Trace(TEXT("Device is out of Data..."));
            return hr;
        }

        if((LONG)dwBytesToRead > m_TotalDataInDevice){

            //
            // only give what is left in device
            //

            *pdwBytesWritten = dwBytesToRead;
            //*pdwBytesWritten    = m_TotalDataInDevice;
            //Trace(TEXT("Device only has %d left..."),m_TotalDataInDevice);
            m_TotalDataInDevice = 0;
        } else {

            //
            // give full amount requested
            //

            m_TotalDataInDevice -= dwBytesToRead;
            if(m_TotalDataInDevice < 0){
                m_TotalDataInDevice = 0;
            }
        }

    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetDataType(LONG lDataType)
{
    HRESULT hr = S_OK;
    switch(lDataType){
    case WIA_DATA_COLOR:
        m_RawDataInfo.bpp = 24;
        break;
    case WIA_DATA_THRESHOLD:
        m_RawDataInfo.bpp = 1;
        break;
    case WIA_DATA_GRAYSCALE:
        m_RawDataInfo.bpp = 8;
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }
    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution)
{
    HRESULT hr = S_OK;
    m_RawDataInfo.lXRes = lXResolution;
    m_RawDataInfo.lYRes = lYResolution;
    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt)
{
    HRESULT hr = S_OK;

    //
    // record RAW data width and height
    //

    m_RawDataInfo.lWidthPixels  = lXExt;
    m_RawDataInfo.lHeightPixels = lYExt;
    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetContrast(LONG lContrast)
{
    HRESULT hr = S_OK;

    //
    // do nothing.. we are not concerned with Contrast
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_SetIntensity(LONG lIntensity)
{
    HRESULT hr = S_OK;

    //
    // do nothing.. we are not concerned with Intensity
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_DisableDevice()
{
    HRESULT hr = S_OK;

    if (m_hKillEventThread) {

        //
        // signal event thread to shutdown
        //

        //::SetEvent(m_hKillEventThread);

        if (!SetEvent(m_hKillEventThread)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        } else {

            if (NULL != m_hEventNotifyThread) {

                //
                // WAIT for thread to terminate, if one exists
                //

                DWORD dwResult = WaitForSingleObject(m_hEventNotifyThread,THREAD_TERMINATION_TIMEOUT);
                switch (dwResult) {
                case WAIT_TIMEOUT:
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                case WAIT_OBJECT_0:
                    hr = S_OK;
                    break;
                case WAIT_ABANDONED:
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                case WAIT_FAILED:
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                default:
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                }
            }

            //
            // Close event for syncronization of notifications shutdown.
            //

            CloseHandle(m_hKillEventThread);
            m_hKillEventThread = NULL;
        }
    }

    //
    // terminate thread
    //

    if (NULL != m_hEventNotifyThread) {
        CloseHandle(m_hEventNotifyThread);
        m_hEventNotifyThread = NULL;
    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_EnableDevice()
{
    HRESULT hr = S_OK;

    //
    // do nothing.. (unused at this time)
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_DeviceOnline()
{
    HRESULT hr = S_OK;

    //
    // Fake device is always on-line
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_Diagnostic()
{
    HRESULT hr = S_OK;

    //
    // Fake device is always healthy
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight)
{
    HRESULT hr = E_FAIL;

    //
    // get our Root item settings, so we can use the width and height values
    //

    ROOT_ITEM_INFORMATION RootItemInfo;
    hr = FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if(SUCCEEDED(hr)) {
        *pWidth  = RootItemInfo.ScanBedWidth;
        *pHeight = RootItemInfo.ScanBedHeight;
    }
    return hr;
}

HRESULT CFScanAPI::FakeScanner_GetDeviceEvent(LONG *pEvent)
{
    HRESULT hr = S_OK;
    if(pEvent){

        //
        // assign event ID
        //

        *pEvent      = m_lLastEvent;

        //Trace(TEXT("FakeScanner_GetDeviceEvent() ,m_lLastEvent = %d"),m_lLastEvent);

        //
        // reset event ID
        //

        m_lLastEvent = ID_FAKE_NOEVENT;

    } else {
        hr = E_INVALIDARG;
    }
    return hr;
}

VOID CFScanAPI::FakeScanner_SetInterruptEventHandle(HANDLE hEvent)
{

    //
    // save event handle, created by main driver, so we can signal it
    // when we have a "hardware" event (like button presses)
    //

    m_hEventHandle = hEvent;
    //Trace(TEXT("Interrupt Handle Set in Fake Device = %d"),m_hEventHandle);
}

//
// standard device operations
//

HRESULT CFScanAPI::FakeScanner_ResetDevice()
{
    HRESULT hr = S_OK;

    //
    // do nothing..
    //

    return hr;
}
HRESULT CFScanAPI::FakeScanner_SetEmulationMode(LONG lDeviceMode)
{
    HRESULT hr = S_OK;

    switch(lDeviceMode){
    case SCROLLFED_SCANNER_MODE:
        {

            //
            // set any library restrictions for scroll fed scanners
            //

            m_lMode = SCROLLFED_SCANNER_MODE;
        }
        break;
    case MULTIFUNCTION_DEVICE_MODE:
        {

            //
            // set any library restrictions for multi-function devices
            //

            m_lMode = SCROLLFED_SCANNER_MODE;
        }
        break;
    default:
        {

            //
            // set any library restrictions for scroll flatbed scanners
            //

            m_lMode = FLATBED_SCANNER_MODE;
        }
        break;
    }

    return hr;
}

//
// Automatic document feeder functions
//

HRESULT CFScanAPI::FakeScanner_ADFHasPaper()
{
    HRESULT hr = S_OK;

    //
    // check paper count
    //

    if(m_PagesInADF <= 0){
         hr = S_FALSE;
    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_ADFAvailable()
{
    HRESULT hr = S_OK;

    //
    // check ADF on-line
    //

    if(!m_ADFIsAvailable){
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_ADFFeedPage()
{
    HRESULT hr = S_OK;

    if(S_OK != FakeScanner_ADFHasPaper()){

        //
        // set paper empty error code
        //

        hr = WIA_ERROR_PAPER_EMPTY;
    }

    //
    // update paper count for ADF
    //

    m_PagesInADF--;

    if(m_PagesInADF <0){
        m_PagesInADF = 0;
    }

    return hr;
}

HRESULT CFScanAPI::FakeScanner_ADFUnFeedPage()
{
    HRESULT hr = S_OK;

    //
    // do nothing.. paper will always eject
    //

    return hr;
}

HRESULT CFScanAPI::FakeScanner_ADFStatus()
{
    return m_hrLastADFError;
}

HRESULT CFScanAPI::FakeScanner_ADFAttached()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CFScanAPI::Raw24bitToRawXbitData(LONG DestDepth, BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight)
{
    HRESULT hr = E_INVALIDARG;
    switch(DestDepth){
    case 1:
        hr = Raw24bitToRaw1bitBW(pDestBuffer, pSrcBuffer, lSrcWidth, lSrcHeight);
        break;
    case 8:
        hr = Raw24bitToRaw8bitGray(pDestBuffer, pSrcBuffer, lSrcWidth, lSrcHeight);
        break;
    case 24:
        hr = Raw24bitToRaw24bitColor(pDestBuffer, pSrcBuffer, lSrcWidth, lSrcHeight);
        break;
    default:
        break;
    }
    return hr;
}

HRESULT CFScanAPI::Raw24bitToRaw1bitBW(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight)
{
    HRESULT hr = S_OK;
    BYTE* ptDest = NULL;
    BYTE* ptSrc  = NULL;

    int BitIdx    = 0;
    BYTE Bits     = 0;
    BYTE GrayByte = 0;

    for (LONG lHeight =0; lHeight < lSrcHeight; lHeight++) {
        ptDest = pDestBuffer + (lHeight*((lSrcWidth+7)/8));
        ptSrc  = pSrcBuffer + lHeight*lSrcWidth*3;
        BitIdx = 0;
        Bits   = 0;
        for (LONG lWidth =0; lWidth < lSrcWidth; lWidth++) {
            GrayByte = (BYTE)((ptSrc[0] * 11 + ptSrc[1] * 59 + ptSrc[2] * 30)/100);
            Bits *= 2;
            if (GrayByte > 128) Bits +=  1;
            BitIdx++;
            if (BitIdx >= 8) {
                BitIdx = 0;
                *ptDest++ = Bits;
            }
            ptSrc += 3;
        }
        // Write out the last byte if matters
        if (BitIdx)
            *ptDest = Bits;
    }
    return hr;
}

HRESULT CFScanAPI::Raw24bitToRaw8bitGray(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight)
{
    HRESULT hr   = S_OK;
    BYTE* ptDest = NULL;
    BYTE* ptSrc  = NULL;

    for (LONG lHeight=0; lHeight < lSrcHeight; lHeight++) {
        ptDest = pDestBuffer + (lHeight*lSrcWidth);
        ptSrc  = pSrcBuffer  + lHeight*lSrcWidth*3;
        for (LONG lWidth =0; lWidth < lSrcWidth; lWidth++) {
            *ptDest++ = (BYTE)((ptSrc[0] * 11 + ptSrc[1] * 59 + ptSrc[2] * 30)/100);
            ptSrc += 3;
        }
    }
    return hr;
}

HRESULT CFScanAPI::Raw24bitToRaw24bitColor(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight)
{
    HRESULT hr = S_OK;
    BYTE* ptDest = NULL;
    BYTE* ptSrc  = NULL;

    for (LONG lHeight=0; lHeight < lSrcHeight; lHeight++) {
        ptDest = pDestBuffer + lHeight*lSrcWidth*3;
        ptSrc  = pSrcBuffer  + lHeight*lSrcWidth*3;
        for (LONG lWidth =0; lWidth < lSrcWidth; lWidth++) {
            ptDest[0] = ptSrc[2];
            ptDest[1] = ptSrc[1];
            ptDest[2] = ptSrc[0];
            ptDest+=3;
            ptSrc+=3;
        }
    }
    return hr;
}

LONG CFScanAPI::WidthToDIBWidth(LONG lWidth)
{
    return(lWidth+3)&0xfffffffc;
}

VOID CFScanAPI::CloseRAW()
{
#ifdef _USE_BITMAP_DATA

    CloseHandle(m_hRawDataMappingHandle);
    m_hRawDataMappingHandle = NULL;
    CloseHandle(m_hRawDataFileHandle);
    m_hRawDataFileHandle = NULL;
    m_pRawData = NULL;
#endif
}

BOOL CFScanAPI::SrcToRAW()
{
#ifdef _USE_BITMAP_DATA
    CloseRAW();
    UNALIGNED BITMAPINFOHEADER *pbmih;
    pbmih = (BITMAPINFOHEADER*)m_pSrcData;
    if(pbmih){
        BYTE* pSrc = m_pSrcData + sizeof(BITMAPINFOHEADER);
        if(pSrc){

            //
            // allocate buffer large enough for entire RAW data set
            //

            LONG lTotalImageSize = CalcTotalImageSize();
            m_hRawDataFileHandle = CreateFile(TEXT("Raw.RAW"), GENERIC_WRITE | GENERIC_READ,
                                              FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                                              NULL);

            DWORD   dwHighSize = 0;
            DWORD   dwLowSize  = 0;

            dwLowSize  = lTotalImageSize;


            m_hRawDataMappingHandle = CreateFileMapping(m_hRawDataFileHandle,NULL,
                                           PAGE_READWRITE,dwHighSize, dwLowSize, NULL);

            m_pRawData = (PBYTE)MapViewOfFileEx(m_hRawDataMappingHandle, FILE_MAP_WRITE,
                                         0,0, dwLowSize, NULL);

            if (m_pRawData) {

                memset(m_pRawData,255,lTotalImageSize);

                //
                // copy SRC to RAW buffer
                //

                LONG lRawWidthBytes    = CalcRawByteWidth();
                LONG lPadPerLineBytes  = pbmih->biWidth % 4;
                LONG lSrcWidthBytes    = ((pbmih->biWidth *3) + lPadPerLineBytes);
                LONG lPixPerPixCount   = (LONG)((m_RawDataInfo.lWidthPixels / pbmih->biWidth));
                LONG lLinePerLineCount = (LONG)((m_RawDataInfo.lHeightPixels / pbmih->biHeight));

                BYTE *pDst     = m_pRawData;
                BYTE *pCurDst  = pDst;
                BYTE *pCurSrc  = pSrc;
                BYTE *pTempSrc = pSrc;

                DWORD dwBytesWritten = 0;
                DWORD dwBytesRead    = 0;
                DWORD dwRawWidthBytes = 0;

                for (LONG lHeight = 0; lHeight < pbmih->biHeight; lHeight++){

                    // up sample data..
                    for (LONG lRawHeight = 0; lRawHeight < lLinePerLineCount; lRawHeight++) {
                        pTempSrc = pCurSrc;
                        for (LONG lWidth = 0; lWidth < pbmih->biWidth; lWidth++) {
                            for (LONG lPixCount = 0; lPixCount < lPixPerPixCount; lPixCount++) {
                                memcpy(pCurDst,pTempSrc,3);
                                pCurDst         += 3;
                                dwBytesWritten  += 3;
                            }
                            pTempSrc    += 3;
                            dwBytesRead += 3;
                        }
                        pTempSrc    += lPadPerLineBytes;
                        dwBytesRead += lPadPerLineBytes;
                        dwRawWidthBytes = 0;
                    }
                    pCurSrc = pTempSrc;

                    // same data to same data...
                    /*
                    memcpy(pCurDst,pCurSrc,lSrcWidthBytes - lPadPerLineBytes);
                    pCurSrc         += lSrcWidthBytes;
                    dwBytesRead     += lSrcWidthBytes;
                    pCurDst         += lRawWidthBytes;
                    dwBytesWritten  += lRawWidthBytes;
                    */
                }
                m_RawDataInfo.lOffset = 0;
                return TRUE;
            }
        }
    }
#endif
    return FALSE;
}

LONG CFScanAPI::CalcTotalImageSize()
{
    LONG lTotalSize = 0;
    switch(m_RawDataInfo.bpp){
    case 1:
        lTotalSize = ((m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lTotalSize = m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels;
        break;
    case 24:
        lTotalSize = (m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lTotalSize;
}

LONG CFScanAPI::CalcRawByteWidth()
{
    LONG lRawWidthBytes = 0;
    switch(m_RawDataInfo.bpp){
    case 1:
        lRawWidthBytes = ((m_RawDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lRawWidthBytes = m_RawDataInfo.lWidthPixels;
        break;
    case 24:
        lRawWidthBytes = (m_RawDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lRawWidthBytes;
}

LONG CFScanAPI::CalcSrcByteWidth()
{
    LONG lSrcWidthBytes = 0;
    switch(m_SrcDataInfo.bpp){
    case 1:
        lSrcWidthBytes = ((m_SrcDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lSrcWidthBytes = m_SrcDataInfo.lWidthPixels;
        break;
    case 24:
        lSrcWidthBytes = (m_SrcDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lSrcWidthBytes;
}

HRESULT CFScanAPI::BQADScale(BYTE* pSrcBuffer, LONG  lSrcWidth, LONG  lSrcHeight, LONG  lSrcDepth,
                                BYTE* pDestBuffer,LONG  lDestWidth,LONG  lDestHeight)
{
    //
    //  We only deal with 1, 8 and 24 bit data
    //

    if ((lSrcDepth != 8) && (lSrcDepth != 1) && (lSrcDepth != 24)) {
        return E_INVALIDARG;
    }

    //
    // Make adjustments so we also work in all supported bit depths.  We can get a performance increase
    // by having separate implementations of all of these, but for now, we stick to a single generic
    // implementation.
    //

    LONG    lBytesPerPixel = (lSrcDepth + 7) / 8;
    ULONG   lSrcRawWidth = ((lSrcWidth * lSrcDepth) + 7) / 8;     // This is the width in pixels
    ULONG   lSrcWidthInBytes;                                     // This is the DWORD-aligned width in bytes
    ULONG   lDestWidthInBytes;                                    // This is the DWORD-aligned width in bytes

    //
    // We need to work out the DWORD aligned width in bytes.  Normally we would do this in one step
    // using the supplied lSrcDepth, but we avoid arithmetic overflow conditions that happen
    // in 24bit if we do it in 2 steps like this instead.
    //

    if (lSrcDepth == 1) {
        lSrcWidthInBytes    = (lSrcWidth + 7) / 8;
        lDestWidthInBytes   = (lDestWidth + 7) / 8;
    } else {
        lSrcWidthInBytes    = (lSrcWidth * lBytesPerPixel);
        lDestWidthInBytes   = (lDestWidth * lBytesPerPixel);
    }
    lSrcWidthInBytes    += (lSrcWidthInBytes % 4) ? (4 - (lSrcWidthInBytes % 4)) : 0;

    //
    // uncomment to work with ALIGNED data
    // lDestWidthInBytes   += (lDestWidthInBytes % 4) ? (4 - (lDestWidthInBytes % 4)) : 0;
    //

    //
    //  Define local variables and do the initial calculations needed for
    //  the scaling algorithm
    //

    BYTE    *pDestPixel     = NULL;
    BYTE    *pSrcPixel      = NULL;
    BYTE    *pEnd           = NULL;
    BYTE    *pDestLine      = NULL;
    BYTE    *pSrcLine       = NULL;
    BYTE    *pEndLine       = NULL;

    LONG    lXEndSize = lBytesPerPixel * lDestWidth;

    LONG    lXNum = lSrcWidth;      // Numerator in X direction
    LONG    lXDen = lDestWidth;     // Denomiator in X direction
    LONG    lXInc = (lXNum / lXDen) * lBytesPerPixel;  // Increment in X direction

    LONG    lXDeltaInc = lXNum % lXDen;     // DeltaIncrement in X direction
    LONG    lXRem = 0;              // Remainder in X direction

    LONG    lYNum = lSrcHeight;     // Numerator in Y direction
    LONG    lYDen = lDestHeight;    // Denomiator in Y direction
    LONG    lYInc = (lYNum / lYDen) * lSrcWidthInBytes; // Increment in Y direction
    LONG    lYDeltaInc = lYNum % lYDen;     // DeltaIncrement in Y direction
    LONG    lYDestInc = lDestWidthInBytes;
    LONG    lYRem = 0;              // Remainder in Y direction

    pSrcLine    = pSrcBuffer;       // This is where we start in the source
    pDestLine   = pDestBuffer;      // This is the start of the destination buffer
                                    // This is where we end overall
    pEndLine    = pDestBuffer + ((lDestWidthInBytes - 1) * lDestHeight);

    while (pDestLine < pEndLine) {  // Start LoopY (Decides where the src and dest lines start)

        pSrcPixel   = pSrcLine;     // We're starting at the beginning of a new line
        pDestPixel  = pDestLine;
                                    // Calc. where we end the line
        pEnd = pDestPixel + lXEndSize;
        lXRem = 0;                  // Reset the remainder for the horizontal direction

        while (pDestPixel < pEnd) {     // Start LoopX (puts pixels in the destination line)

                                        // Put the pixel
            if (lBytesPerPixel > 1) {
                pDestPixel[0] = pSrcPixel[0];
                pDestPixel[1] = pSrcPixel[1];
                pDestPixel[2] = pSrcPixel[2];
            } else {
                *pDestPixel = *pSrcPixel;
            }
                                        // Move the destination pointer to the next pixel
            pDestPixel += lBytesPerPixel;
            pSrcPixel += lXInc;         // Move the source pointer over by the horizontal increment
            lXRem += lXDeltaInc;        // Increase the horizontal remainder - this decides when we "overflow"

            if (lXRem >= lXDen) {       // This is our "overflow" condition.  It means we're now one
                                        // pixel off.
                pSrcPixel += lBytesPerPixel;                // In Overflow case, we need to shift one pixel over
                lXRem -= lXDen;         // Decrease the remainder by the X denominator.  This is essentially
                                        // lXRem MOD lXDen.
            }
        }                               // End LoopX   (puts pixels in the destination line)

        pSrcLine += lYInc;          // We've finished a horizontal line, time to move to the next one
        lYRem += lYDeltaInc;        // Increase our vertical remainder.  This decides when we "overflow"

        if (lYRem > lYDen) {        // This is our vertical overflow condition.
                                    // We need to move to the next line down
            pSrcLine += lSrcWidthInBytes;
            lYRem -= lYDen;         // Decrease the remainder by the Y denominator.    This is essentially
                                    // lYRem MOD lYDen.
        }
        pDestLine += lYDestInc;     // Move the destination pointer to the start of the next line in the
                                    // destination buffer
    }                               // End LoopY   (Decides where the src and dest lines start)
    return S_OK;
}

LONG CFScanAPI::CalcRandomDeviceDataTotalBytes()
{
    LONG lTotalBytes = 0;
    srand((unsigned)time(NULL));
    LONG lPageLengthInches = ((rand()%17) + 5);// max 22 inches, and min of 5 inches
    Trace(TEXT("Random Page Length is %d inches"),lPageLengthInches);

    LONG lImageHeight = m_RawDataInfo.lYRes * lPageLengthInches;
    Trace(TEXT("Random Page Length is %d pixels"),lImageHeight);

    lTotalBytes = (CalcRawByteWidth() * lImageHeight);
    Trace(TEXT("Random Page Total Data Size = %d"),lTotalBytes);
    return lTotalBytes;
}

HRESULT CFScanAPI::CreateButtonEventFiles()
{
    HRESULT hr = E_FAIL;
    HANDLE hFileHandle = NULL;
    TCHAR   szSystemDirectory[MAX_PATH];    // system directory
    UINT    uiSystemPathLen      = 0;       // length of system path
    uiSystemPathLen = GetSystemDirectory(szSystemDirectory,MAX_PATH);
    if (uiSystemPathLen <= 0) {
        return E_FAIL;
    }

    memset(m_ScanButtonFile,0,(sizeof(TCHAR) * MAX_PATH));
    lstrcpy(m_ScanButtonFile,szSystemDirectory);
    lstrcat(m_ScanButtonFile,TEXT("\\"));
    lstrcat(m_ScanButtonFile,SCANBUTTON_FILE);

    //
    // create Scan button event file
    //

    hFileHandle = CreateFile(m_ScanButtonFile, GENERIC_WRITE | GENERIC_READ,FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,NULL);
    if (INVALID_HANDLE_VALUE != hFileHandle && NULL != hFileHandle) {
        CloseHandle(hFileHandle);
        hFileHandle = NULL;
        memset(m_CopyButtonFile,0,(sizeof(TCHAR) * MAX_PATH));
        lstrcpy(m_CopyButtonFile,szSystemDirectory);
        lstrcat(m_CopyButtonFile,TEXT("\\"));
        lstrcat(m_CopyButtonFile,COPYBUTTON_FILE);

        //
        // create Copy button event file
        //

        hFileHandle = CreateFile(m_CopyButtonFile, GENERIC_WRITE | GENERIC_READ,FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,NULL);
        if (INVALID_HANDLE_VALUE != hFileHandle && NULL != hFileHandle) {
            CloseHandle(hFileHandle);
            hFileHandle = NULL;
            memset(m_FaxButtonFile,0,(sizeof(TCHAR) * MAX_PATH));
            lstrcpy(m_FaxButtonFile,szSystemDirectory);
            lstrcat(m_FaxButtonFile,TEXT("\\"));
            lstrcat(m_FaxButtonFile,FAXBUTTON_FILE);

            //
            // create Fax button event file
            //

            hFileHandle = CreateFile(m_FaxButtonFile, GENERIC_WRITE | GENERIC_READ,FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,NULL);
            if (INVALID_HANDLE_VALUE != hFileHandle && NULL != hFileHandle) {
                CloseHandle(hFileHandle);
                hFileHandle = NULL;
                memset(m_ADFEventFile,0,(sizeof(TCHAR) * MAX_PATH));
                lstrcpy(m_ADFEventFile,szSystemDirectory);
                lstrcat(m_ADFEventFile,TEXT("\\"));
                lstrcat(m_ADFEventFile,ADF_FILE);

                //
                // create ADF load event file
                //

                hFileHandle = CreateFile(m_ADFEventFile, GENERIC_WRITE | GENERIC_READ,FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,NULL);
                if (INVALID_HANDLE_VALUE != hFileHandle && NULL != hFileHandle) {

                    //
                    // write default headers to ADF event file
                    //

                    SetEndOfFile(hFileHandle);

                    TCHAR szBuffer[1024];
                    memset(szBuffer,0,sizeof(szBuffer));
                    _stprintf(szBuffer,TEXT("%s\r\n%s10\r\n%s\r\n%s\r\n"),LOADPAGES_HEADER,
                                                                        LOADPAGES_PAGES,
                                                                        ADFERRORS_HEADER,
                                                                        ADFERRORS_ERROR);

                    DWORD dwBytesWritten = 0;
                    WriteFile(hFileHandle,szBuffer,(lstrlen(szBuffer)*sizeof(TCHAR)),&dwBytesWritten,NULL);
                    CloseHandle(hFileHandle);
                    hFileHandle = NULL;
                    hr = S_OK;
                }
            }
        }
    }
    return hr;
}

HRESULT CFScanAPI::DoEventProcessing()
{
    HRESULT hr = E_FAIL;

    //
    // loop checking for file change messages
    //

    if(FAILED(CreateButtonEventFiles())){
        return E_FAIL;
    }

    //
    // call IsValidDeviceEvent() once, to set internal variables
    //

    IsValidDeviceEvent();

    HANDLE  hNotifyFileSysChange = NULL;    // handle to file change object
    DWORD   dwErr                = 0;       // error return value
    TCHAR   szSystemDirectory[MAX_PATH];    // system directory
    UINT    uiSystemPathLen      = 0;       // length of system path
    uiSystemPathLen = GetSystemDirectory(szSystemDirectory,MAX_PATH);
    if(uiSystemPathLen <= 0){
        return E_FAIL;
    }

    hNotifyFileSysChange = FindFirstChangeNotification(szSystemDirectory,
                                                       FALSE,
                                                       FILE_NOTIFY_CHANGE_SIZE |
                                                       FILE_NOTIFY_CHANGE_LAST_WRITE |
                                                       FILE_NOTIFY_CHANGE_FILE_NAME |
                                                       FILE_NOTIFY_CHANGE_DIR_NAME);

    if (hNotifyFileSysChange == INVALID_HANDLE_VALUE) {
        return E_FAIL;
    }

    //
    // set up event handle array. (Kill Thread handle, and File change handle)
    //

    HANDLE  hEvents[2] = {m_hKillEventThread,hNotifyFileSysChange};

    //
    // set looping to TRUE
    //

    BOOL    bLooping = TRUE;

    //
    // Wait for file system change or kill event thread event.
    //

    while (bLooping) {

        //
        // Wait
        //

        dwErr = ::WaitForMultipleObjects(2,hEvents,FALSE,INFINITE);

        //
        // process signal
        //

        switch (dwErr) {
        case WAIT_OBJECT_0+1:   // FILE CHANGED EVENT

            //
            // check to see if it was one of our "known" files that
            // changed
            //

            if(IsValidDeviceEvent()){

                //
                // signal the interrupt handle if it exists
                //

                if(NULL != m_hEventHandle){

                    //
                    // set the event
                    //
                    //Trace(TEXT("signaling Event Handle (%d)"),m_hEventHandle);
                    ::SetEvent(m_hEventHandle);
                } else {
                    //Trace(TEXT("No Event Handle to signal"));
                }
            }

            //
            // Wait again.. for next file system event
            //

            FindNextChangeNotification(hNotifyFileSysChange);
            break;
        case WAIT_OBJECT_0:     // SHUTDOWN EVENT

            //
            // set looping boolean to FALSE, so we exit out thread
            //

            bLooping = FALSE;
            break;
        default:

            //
            // do nothing...we don't know
            //

            break;
        }
    }

    //
    // close file system event handle
    //

    FindCloseChangeNotification(hNotifyFileSysChange);
    return S_OK;
}

BOOL CFScanAPI::IsValidDeviceEvent()
{
    BOOL bValidEvent = FALSE;

    LARGE_INTEGER   liNewHugeSize;
    FILETIME        ftLastWriteTime;
    WIN32_FIND_DATA sNewFileAttributes;

    HANDLE          hFind   = INVALID_HANDLE_VALUE;
    DWORD           dwError = NOERROR;

    ////////////////////////////////////////////////////////////
    // Scan Button file check
    ////////////////////////////////////////////////////////////

    //
    // Get the file attributes.
    //

    ZeroMemory(&sNewFileAttributes, sizeof(sNewFileAttributes));
    hFind = FindFirstFile( m_ScanButtonFile, &sNewFileAttributes );

    if (hFind != INVALID_HANDLE_VALUE) {
        ftLastWriteTime         = sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart   = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart  = sNewFileAttributes.nFileSizeHigh;
        FindClose( hFind );
    } else {
        dwError = ::GetLastError();
    }

    if (NOERROR == dwError) {

        //
        // check file date/time.
        //

        if (CompareFileTime(&m_ftScanButton,&ftLastWriteTime) == -1) {

            //
            // we have a Button event...so set the event flag to TRUE
            // and set the BUTTON ID to the correct event.
            //
            //Trace(TEXT("Scan button pressed on fake Hardware"));
            bValidEvent  = TRUE;
            m_lLastEvent = ID_FAKE_SCANBUTTON;
        }
        m_ftScanButton = ftLastWriteTime;

    }

    ////////////////////////////////////////////////////////////
    // Copy Button file check
    ////////////////////////////////////////////////////////////

    //
    // Get the file attributes.
    //

    ZeroMemory(&sNewFileAttributes, sizeof(sNewFileAttributes));
    hFind = FindFirstFile( m_CopyButtonFile, &sNewFileAttributes );

    if (hFind != INVALID_HANDLE_VALUE) {
        ftLastWriteTime         = sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart   = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart  = sNewFileAttributes.nFileSizeHigh;
        FindClose( hFind );
    } else {
        dwError = ::GetLastError();
    }

    if (NOERROR == dwError) {

        //
        // check file date/time.
        //

        if (CompareFileTime(&m_ftCopyButton,&ftLastWriteTime) == -1) {

            //
            // we have a Button event...so set the event flag to TRUE
            // and set the BUTTON ID to the correct event.
            //

            bValidEvent  = TRUE;
            m_lLastEvent = ID_FAKE_COPYBUTTON;
        }
        m_ftCopyButton = ftLastWriteTime;
    }

    ////////////////////////////////////////////////////////////
    // Fax Button file check
    ////////////////////////////////////////////////////////////

    //
    // Get the file attributes.
    //

    ZeroMemory(&sNewFileAttributes, sizeof(sNewFileAttributes));
    hFind = FindFirstFile( m_FaxButtonFile, &sNewFileAttributes );

    if (hFind != INVALID_HANDLE_VALUE) {
        ftLastWriteTime         = sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart   = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart  = sNewFileAttributes.nFileSizeHigh;
        FindClose( hFind );
    } else {
        dwError = ::GetLastError();
    }

    if (NOERROR == dwError) {

        //
        // check file date/time.
        //

        if (CompareFileTime(&m_ftFaxButton,&ftLastWriteTime) == -1) {

            //
            // we have a Button event...so set the event flag to TRUE
            // and set the BUTTON ID to the correct event.
            //

            bValidEvent  = TRUE;
            m_lLastEvent = ID_FAKE_FAXBUTTON;
        }
        m_ftFaxButton = ftLastWriteTime;
    }

    ////////////////////////////////////////////////////////////
    // ADF Event file check
    ////////////////////////////////////////////////////////////

    //
    // Get the file attributes.
    //

    ZeroMemory(&sNewFileAttributes, sizeof(sNewFileAttributes));
    hFind = FindFirstFile( m_ADFEventFile, &sNewFileAttributes );

    if (hFind != INVALID_HANDLE_VALUE) {
        ftLastWriteTime         = sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart   = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart  = sNewFileAttributes.nFileSizeHigh;
        FindClose( hFind );
    } else {
        dwError = ::GetLastError();
    }

    if (NOERROR == dwError) {

        //
        // check file date/time.
        //

        if (CompareFileTime(&m_ftFaxButton,&ftLastWriteTime) == -1) {

            //
            // we have an ADF event...so set the event flag to TRUE
            // and set the ID to the correct event.
            //

            //bValidEvent  = TRUE;
            //m_lLastEvent = ID_FAKE_ADFEVENT;
            ProcessADFEvent();
        }
        m_ftFaxButton = ftLastWriteTime;
    }

    return bValidEvent;
}

HRESULT CFScanAPI::ProcessADFEvent()
{
    HRESULT hr = S_OK;

    m_PagesInADF = GetPrivateProfileInt(TEXT("Load Pages"),
                                  TEXT("Pages"),
                                  10,
                                  m_ADFEventFile);

    Trace(TEXT("ADF has %d pages loaded"),m_PagesInADF);

    DWORD dwReturn = 0;
    TCHAR szError[MAX_PATH];
    memset(szError,0,sizeof(szError));

    dwReturn = GetPrivateProfileString(TEXT("ADF Error"),
                                       TEXT("Error"),
                                       TEXT(""),
                                       szError,
                                       (sizeof(szError)/sizeof(TCHAR)),
                                       m_ADFEventFile);

    if (lstrlen(szError) > 0) {
        if (lstrcmpi(szError,ADFERRORS_JAM) == 0) {
            m_hrLastADFError = WIA_ERROR_PAPER_JAM;
            Trace(TEXT("ADF has a paper JAM"));
        } else if (lstrcmpi(szError,ADFERRORS_EMPTY) == 0) {
            m_hrLastADFError = WIA_ERROR_PAPER_EMPTY;
            Trace(TEXT("ADF has no paper"));
        } else if (lstrcmpi(szError,ADFERRORS_PROBLEM) == 0) {
            m_hrLastADFError = WIA_ERROR_PAPER_PROBLEM;
            Trace(TEXT("ADF has a paper problem"));
        } else if (lstrcmpi(szError,ADFERRORS_GENERAL) == 0) {
            m_hrLastADFError = WIA_ERROR_GENERAL_ERROR;
            Trace(TEXT("ADF encountered a general error"));
        } else if (lstrcmpi(szError,ADFERRORS_OFFLINE) == 0) {
            m_hrLastADFError = WIA_ERROR_OFFLINE;
            Trace(TEXT("ADF is off-line"));
        } else {
            Trace(TEXT("ADF is READY"));
            m_hrLastADFError = S_OK;
        }
    } else {
        Trace(TEXT("ADF is READY"));
        m_hrLastADFError = S_OK;
    }

    return hr;
}

VOID CFScanAPI::Trace(LPCTSTR format,...)
{

#ifdef DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}

HRESULT CreateInstance(CFakeScanAPI **ppFakeScanAPI, LONG lMode)
{
    HRESULT hr = S_OK;
    if(ppFakeScanAPI){
        *ppFakeScanAPI = NULL;
        *ppFakeScanAPI = new CFScanAPI;
        if(NULL == *ppFakeScanAPI){
            hr = E_OUTOFMEMORY;
        }
        CFScanAPI* pScanAPI = (CFScanAPI*)*ppFakeScanAPI;
        pScanAPI->FakeScanner_SetEmulationMode(lMode);
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// THREADS SECTION                                                                    //
////////////////////////////////////////////////////////////////////////////////////////

VOID FakeScannerEventThread( LPVOID  lpParameter )
{
    PSCANNERDEVICE pThisDevice = (PSCANNERDEVICE)lpParameter;
    pThisDevice->DoEventProcessing();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanpanl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scanpnl.rc
//

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif

#define IDC_STATIC                 (-1) // all static controls

#define IDD_SCANPANEL_DIALOG       1000
#define IDC_SCAN_BUTTON            1001
#define IDC_COPY_BUTTON            1002
#define IDC_FAX_BUTTON             1003

#define IDS_FIRE_FAKE_EVENT_FAILED 2000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanpanl\scanpnl.h ===
#pragma once

#include "resource.h"   // resource IDs

///////////////////////////////////////////////////////////////////////////////
// wia scanner sample defines

#define ID_FAKE_NOEVENT    0
#define ID_FAKE_SCANBUTTON 100
#define ID_FAKE_COPYBUTTON 200
#define ID_FAKE_FAXBUTTON  300

///////////////////////////////////////////////////////////////////////////////
// registry settings

#define HKEY_WIASCANR_FAKE_EVENTS TEXT(".DEFAULT\\Software\\Microsoft\\WIASCANR")
#define HKEY_WIASCANR_FAKE_EVENTS_LOCAL_SERVICE TEXT("S-1-5-19\\Software\\Microsoft\\WIASCANR")
#define WIASCANR_DWORD_FAKE_EVENT_CODE TEXT("EventCode")

///////////////////////////////////////////////////////////////////////////////
// main application

INT_PTR CALLBACK MainWindowProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
VOID FireFakeEvent(HWND hDlg, DWORD dwEventCode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanpanl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanpanl\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers
#endif
// Windows Header Files:
#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <windowsx.h>
#include <stdio.h>
#include <tchar.h>
// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// SCANPANL headers
#include "scanpnl.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanapi\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   coopp
#
#Date:
#   29-Aug-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#       WIA Sample Scanner Library (fake scanner device library)
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=scanapi
TARGETTYPE=LIBRARY
TARGETPATH=$(OBJ_DIR)

PASS1_PUBLISH= \
    {$(O)\scanapi.lib=$(DDK_LIB_PATH)\scanapi.lib}


COFFBASE=usermode

INCLUDES= $(INCLUDES); \
          $(DDK_INC_PATH)


TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\iprop.lib  \
            $(SDK_LIB_PATH)\wiaguid.lib
            
SOURCES= \
        ..\scanapi.cpp \
        ..\scanapi.rc
    
PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\pch.h
PRECOMPILED_OBJ = pch.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microdrv\inc\cio.h ===
#ifndef _CIO
#define _CIO

#include <STI.H>
#include <DEVIOCTL.H>
#include <SCSISCAN.H>

//
// These BUS_TYPE defines must match the ones in wiamicro.h
// I don't include wiamicro.h in this file, because
// the IO layer shouldn't know anything about the Micro driver
// except BUS_TYPE, and it makes a clean / non-circular include system
//

#define IO_BUS_TYPE_SCSI         200
#define IO_BUS_TYPE_USB          201
#define IO_BUS_TYPE_PARALLEL     202
#define IO_BUS_TYPE_FIREWIRE     203

//
// SCSI 
//

//
// SRB Functions
//

#define SRB_FUNCTION_EXECUTE_SCSI           0x00
#define SRB_FUNCTION_CLAIM_DEVICE           0x01
#define SRB_FUNCTION_IO_CONTROL             0x02
#define SRB_FUNCTION_RECEIVE_EVENT          0x03
#define SRB_FUNCTION_RELEASE_QUEUE          0x04
#define SRB_FUNCTION_ATTACH_DEVICE          0x05
#define SRB_FUNCTION_RELEASE_DEVICE         0x06
#define SRB_FUNCTION_SHUTDOWN               0x07
#define SRB_FUNCTION_FLUSH                  0x08
#define SRB_FUNCTION_ABORT_COMMAND          0x10
#define SRB_FUNCTION_RELEASE_RECOVERY       0x11
#define SRB_FUNCTION_RESET_BUS              0x12
#define SRB_FUNCTION_RESET_DEVICE           0x13
#define SRB_FUNCTION_TERMINATE_IO           0x14
#define SRB_FUNCTION_FLUSH_QUEUE            0x15
#define SRB_FUNCTION_REMOVE_DEVICE          0x16

//
// SRB Status
//

#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23

#define SCSI_DIR_NONE                          0
#define SCSI_DIR_IN                         0x08
#define SCSI_DIR_OUT                        0x10
#define MAX_CDB_LENGTH                        12
#define MAX_SENSE_LENGTH                      16
#define SCSIREQLEN                            16

typedef struct {
        BYTE   SRB_Cmd;
        BYTE   SRB_HaId;
        BYTE   SRB_Target;
        BYTE   SRB_HaStat;
        BYTE   SRB_TargStat;
        BYTE   SRB_Status;
        BYTE   SRB_CDBLen;
        BYTE   CDBByte[MAX_CDB_LENGTH];
        BYTE   SRB_SenseLen;
        DWORD  SRB_BufLen;
        BYTE   SRB_Flags;
        BYTE   bReserved;
        LPBYTE SRB_BufPointer;
        BYTE   SenseArea[MAX_SENSE_LENGTH];
        LPVOID lpUserArea;
} CFM_SRB_ExecSCSICmd, *PCFM_SRB_ExecSCSICmd;

#define    SENSE_LENGTH    18

class CIO {

public:
     CIO(HANDLE hIO = NULL);
    ~CIO();
    VOID   SetBusType(LONG lBusType);
    VOID   SetIOHandle(HANDLE hIO);
    VOID   IO_INIT_EXT6SCANNERCMD( BYTE bCommand, BYTE bDirection, DWORD dwLength, LPBYTE lpBuffer );
    VOID   IO_INIT_6SCANNERCMD(BYTE bCommand, BYTE bDirection, DWORD dwLength, LPBYTE lpBuffer);
    VOID   IO_INIT_10SCANNERCMD(BYTE bCommand, BYTE bDirection, DWORD dwLength, LPBYTE lpBuffer);
    VOID   IO_INIT_12SCANNERCMD(BYTE bCommand, BYTE bDirection, DWORD dwLength, LPBYTE lpBuffer);
    VOID   IO_SET_SCANNERCMDINDEX( USHORT usIndex, BYTE bNewValue );
    BYTE   IO_GET_DATAINDEX( USHORT usRequestedIndex );
    BOOL   IO_COMMAND_NOT_OK( VOID );
    BYTE   IO_GET_SENSEKEY( VOID );
    BYTE   IO_GET_SENSECODE( VOID );
    BYTE   IO_GET_SENSECODEQUALIFIER( VOID );
    USHORT IO_GET_FULLSENSE( VOID );
    BOOL   IO_BUFFER_TO_BIG( VOID );
    BOOL   IO_IS_EOM( VOID );
    BOOL   IO_IS_ILI( VOID );
    DWORD  IO_GET_MISSINGDATA( VOID );
    DWORD  IO_GET_VALIDDATA( VOID );
    VOID   IO_GETCOMMAND(CFM_SRB_ExecSCSICmd* psrb);
    VOID   IO_SENDCOMMAND();
    VOID   CreateScsiReadCommand(SCSISCAN_CMD *pScsiScan, BYTE bCommandLength, DWORD dwBufferLength);
    HRESULT SendCommand(STI_RAW_CONTROL_CODE    EscapeFunction,
                        LPVOID                  pInData,
                        DWORD                   cbInDataSize,
                        LPVOID                  pOutData,
                        DWORD                   cbOutDataSize,
                        LPDWORD                 pcbActualData);
    USHORT MOTOROLA_USHORT(USHORT us);
    ULONG MOTOROLA_ULONG(ULONG ul);
private:
    UCHAR  m_ucSrbStatus;
    BYTE   m_abSenseArea[SENSE_LENGTH + 1];
    HANDLE m_hIO;
    LONG   m_lBusType;      

protected:
    CFM_SRB_ExecSCSICmd m_srb;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanpanl\scanpnl.cpp ===
// scanpnl.cpp : Defines the entry point for the application.
//

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
// application globals

HINSTANCE g_hInst;                // current instance of main application
HKEY g_hFakeEventKey;             // event trigger key
HKEY g_hFakeEventKeyLocalService; // event trigger key

///////////////////////////////////////////////////////////////////////////////
// main application

int WINAPI wWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow )
{
    if (!hInstance) {
        return 0;
    }

    g_hInst = hInstance;

    //
    // open registry HKEY (Local System - legacy)
    //

    DWORD dwDisposition = 0;
    if (RegCreateKeyEx(HKEY_USERS,
                       HKEY_WIASCANR_FAKE_EVENTS,
                       0,
                       NULL,
                       0,
                       KEY_ALL_ACCESS,
                       NULL,
                       &g_hFakeEventKey,
                       &dwDisposition) == ERROR_SUCCESS) {
    }

    //
    // open registry HKEY (Local Service - .NET server release)
    //

    dwDisposition = 0;
    if (RegCreateKeyEx(HKEY_USERS,
                       HKEY_WIASCANR_FAKE_EVENTS_LOCAL_SERVICE,
                       0,
                       NULL,
                       0,
                       KEY_ALL_ACCESS,
                       NULL,
                       &g_hFakeEventKeyLocalService,
                       &dwDisposition) == ERROR_SUCCESS) {
    }

    //
    // display front panel dialog
    //

    DialogBox(hInstance, (LPCTSTR)IDD_SCANPANEL_DIALOG, NULL, MainWindowProc);

    //
    // close registry HKEY
    //

    if (g_hFakeEventKey) {
        RegCloseKey(g_hFakeEventKey);
        g_hFakeEventKey = NULL;
    }

    if (g_hFakeEventKeyLocalService) {
        RegCloseKey(g_hFakeEventKeyLocalService);
        g_hFakeEventKeyLocalService = NULL;
    }
    return 0;
}

INT_PTR CALLBACK MainWindowProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_SCAN_BUTTON:
            FireFakeEvent(hDlg,ID_FAKE_SCANBUTTON);
            break;
        case IDC_COPY_BUTTON:
            FireFakeEvent(hDlg,ID_FAKE_COPYBUTTON);
            break;
        case IDC_FAX_BUTTON:
            FireFakeEvent(hDlg,ID_FAKE_FAXBUTTON);
            break;
        default:
            break;
        }
        return TRUE;

    case WM_CLOSE:
        EndDialog(hDlg, LOWORD(wParam));
        return TRUE;

    default:
        break;
    }
    return FALSE;
}

VOID FireFakeEvent(HWND hDlg, DWORD dwEventCode)
{
    BOOL bEventSuccess = FALSE;
    if (g_hFakeEventKey) {

        //
        // write a clearing entry, to reset the previous event code
        //

        DWORD dwClearEventCode = 0;
        if (RegSetValueEx(g_hFakeEventKey,
                          WIASCANR_DWORD_FAKE_EVENT_CODE,
                          0,
                          REG_DWORD,
                          (BYTE*)&dwClearEventCode,
                          sizeof(dwClearEventCode)) == ERROR_SUCCESS) {

            //
            // event is cleared
            //

            if (RegSetValueEx(g_hFakeEventKey,
                              WIASCANR_DWORD_FAKE_EVENT_CODE,
                              0,
                              REG_DWORD,
                              (BYTE*)&dwEventCode,
                              sizeof(dwEventCode)) == ERROR_SUCCESS) {

                //
                // value was set
                //

                bEventSuccess = TRUE;
            }
        }
    }

    if(g_hFakeEventKeyLocalService) {

        //
        // write a clearing entry, to reset the previous event code
        //

        DWORD dwClearEventCode = 0;
        if (RegSetValueEx(g_hFakeEventKeyLocalService,
                          WIASCANR_DWORD_FAKE_EVENT_CODE,
                          0,
                          REG_DWORD,
                          (BYTE*)&dwClearEventCode,
                          sizeof(dwClearEventCode)) == ERROR_SUCCESS) {

            //
            // event is cleared
            //

            if (RegSetValueEx(g_hFakeEventKeyLocalService,
                              WIASCANR_DWORD_FAKE_EVENT_CODE,
                              0,
                              REG_DWORD,
                              (BYTE*)&dwEventCode,
                              sizeof(dwEventCode)) == ERROR_SUCCESS) {

                //
                // value was set
                //

                bEventSuccess = TRUE;
            }
        }
    }

    //
    // display an error message box, when the application can not fire the fake event
    //

    if(!bEventSuccess){
        TCHAR szErrorString[MAX_PATH];
        memset(szErrorString,0,sizeof(szErrorString));
        if(LoadString(g_hInst,IDS_FIRE_FAKE_EVENT_FAILED,szErrorString,(sizeof(szErrorString)/sizeof(szErrorString[0]))) > 0){

            //
            // display error message box
            //

            MessageBox(hDlg,szErrorString,NULL,MB_OK|MB_ICONEXCLAMATION);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\scanapi\scanapi.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       scanapi.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#ifndef _SCANAPI_H
#define _SCANAPI_H

#include "fscanapi.h"

//
// helpful utils.
//

#ifdef UNICODE
    #define TSTRSTR wcsstr
    #define TSSCANF swscanf
#else
    #define TSTRSTR strstr
    #define TSSCANF sscanf
#endif

//
// Event Thread
//

VOID FakeScannerEventThread( LPVOID  lpParameter );

//
// event file names
//

#define SCANBUTTON_FILE TEXT("ScanButton.wia")
#define COPYBUTTON_FILE TEXT("CopyButton.wia")
#define FAXBUTTON_FILE  TEXT("FaxButton.wia")
#define ADF_FILE        TEXT("ADF.wia")

//
// event headers
//

#define LOADPAGES_HEADER  TEXT("[Load Pages]")
#define LOADPAGES_PAGES   TEXT("Pages=")
#define ADFERRORS_HEADER  TEXT("[ADF Error]")
#define ADFERRORS_ERROR   TEXT("Error=")
#define ADFERRORS_JAM     TEXT("jam")
#define ADFERRORS_EMPTY   TEXT("empty")
#define ADFERRORS_PROBLEM TEXT("problem")
#define ADFERRORS_GENERAL TEXT("general")
#define ADFERRORS_OFFLINE TEXT("offline")

//
// Scanner device constants
//

#define MAX_SCANNING_TIME    40000  // 40 seconds
#define MAX_LAMP_WARMUP_TIME 10000  // 10 seconds
#define MAX_PAGE_CAPACITY    25     // 25 pages

typedef struct _RAW_DATA_INFORMATION {
    LONG bpp;           // bits per pixel;
    LONG lWidthPixels;  // width of image in pixels
    LONG lHeightPixels; // height of image in pixels
    LONG lOffset;       // raw copy offset from top of raw buffer;
    LONG lXRes;         // x resolution
    LONG lYRes;         // y resolution
} RAW_DATA_INFORMATION,*PRAW_DATA_INFORMATION;

class CFScanAPI :public CFakeScanAPI {
public:

    //
    // constructor/destructor
    //

    CFScanAPI();
    ~CFScanAPI();
    
    //
    // device initialization function
    //

    HRESULT FakeScanner_Initialize();

    //
    // device setting functions
    //

    HRESULT FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo);
    HRESULT FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo);
    HRESULT FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight);

    //
    // device event functions
    //

    HRESULT FakeScanner_GetDeviceEvent(LONG *pEvent);
    VOID    FakeScanner_SetInterruptEventHandle(HANDLE hEvent);
    HRESULT DoEventProcessing();

    //
    // data acquisition functions
    //

    HRESULT FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten);
    HRESULT FakeScanner_SetDataType(LONG lDataType);
    HRESULT FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution);
    HRESULT FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt);
    HRESULT FakeScanner_SetContrast(LONG lContrast);
    HRESULT FakeScanner_SetIntensity(LONG lIntensity);

    //
    // standard device operations
    //

    HRESULT FakeScanner_ResetDevice();
    HRESULT FakeScanner_SetEmulationMode(LONG lDeviceMode);
    HRESULT FakeScanner_DisableDevice();
    HRESULT FakeScanner_EnableDevice();
    HRESULT FakeScanner_DeviceOnline();
    HRESULT FakeScanner_Diagnostic();

    //
    // Automatic document feeder functions
    //

    HRESULT FakeScanner_ADFAttached();
    HRESULT FakeScanner_ADFHasPaper();
    HRESULT FakeScanner_ADFAvailable();
    HRESULT FakeScanner_ADFFeedPage();
    HRESULT FakeScanner_ADFUnFeedPage();
    HRESULT FakeScanner_ADFStatus();
           
private:

#ifdef _USE_BITMAP_DATA

    HANDLE  m_hSrcFileHandle;       // Source bitmap data file handle
    HANDLE  m_hSrcMappingHandle;    // Source file mapping handle
    BYTE*   m_pSrcData;             // Source DIB pointer (24-bit only)
    HANDLE  m_hRawDataFileHandle;   // RAW data file handle
    HANDLE  m_hRawDataMappingHandle;// RAW data file mapping handle
    BYTE*   m_pRawData;             // RAW data pointer

#endif

    HANDLE  m_hEventHandle;         // Event to signal for Interrupt events
    HANDLE  m_hKillEventThread;     // Event to signal for shutdown of internal Event thread
    HANDLE  m_hEventNotifyThread;   // Event Thread handle
    LONG    m_lLastEvent;           // Last Event ID
    LONG    m_lMode;                // Fake scanner library mode
    LONG    m_PagesInADF;           // Current number of pages in the ADF
    BOOL    m_ADFIsAvailable;       // ADF available TRUE/FALSE
    HRESULT m_hrLastADFError;       // ADF errors
    FILETIME m_ftScanButton;        // Last Scan button file time
    FILETIME m_ftCopyButton;        // Last Copy button file time
    FILETIME m_ftFaxButton;         // Last Fax  button file time
    BOOL    m_bGreen;               // Are We Green?
    LONG    m_dwBytesWrittenSoFAR;  // How much data have we read so far?
    LONG    m_TotalDataInDevice;    // How much will we read total?
    
protected:
    
    //
    // RAW and SRC data information members
    //

    RAW_DATA_INFORMATION m_RawDataInfo; // Information about RAW data
    RAW_DATA_INFORMATION m_SrcDataInfo; // Information about SRC data
       
    //
    // RAW data conversion functions
    //

    HRESULT Load24bitScanData(LPTSTR szBitmapFileName);
    HRESULT Raw24bitToRawXbitData(LONG DestDepth, BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight);
    HRESULT Raw24bitToRaw1bitBW(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight);
    HRESULT Raw24bitToRaw8bitGray(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight);
    HRESULT Raw24bitToRaw24bitColor(BYTE* pDestBuffer, BYTE* pSrcBuffer, LONG lSrcWidth, LONG lSrcHeight);
    BOOL    SrcToRAW();
    VOID    CloseRAW();

    //
    // RAW data calculation helper functions
    //

    LONG    WidthToDIBWidth(LONG lWidth);
    LONG    CalcTotalImageSize();
    LONG    CalcRawByteWidth();
    LONG    CalcSrcByteWidth();
    LONG    CalcRandomDeviceDataTotalBytes();
    
    //
    // Byron's Rock'n Scaling routine (handles UP and DOWN samples)
    //
    
    HRESULT BQADScale(BYTE* pSrcBuffer, LONG  lSrcWidth, LONG  lSrcHeight,LONG  lSrcDepth,
                      BYTE* pDestBuffer,LONG  lDestWidth,LONG  lDestHeight);
        
    //
    // event helper functions
    //

    HRESULT CreateButtonEventFiles();
    BOOL IsValidDeviceEvent();
    HRESULT ProcessADFEvent();

    //
    // event file names w/ path information
    //

    TCHAR m_ScanButtonFile[MAX_PATH];
    TCHAR m_CopyButtonFile[MAX_PATH];
    TCHAR m_FaxButtonFile[MAX_PATH];
    TCHAR m_ADFEventFile[MAX_PATH];

    //
    // debugger trace helper function
    //

    VOID Trace(LPCTSTR format,...);
    
};

//
// FAKE SCANNER API Class pointer (used for Event Thread)
//

typedef CFakeScanAPI *PSCANNERDEVICE;

HRESULT CreateInstance(CFakeScanAPI **ppFakeScanAPI, LONG lMode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devaction.cpp ===
// devaction.cpp : Implementation of CDeviceAction
#include "pch.h"
#include "wiafb.h"
#include "devaction.h"

/////////////////////////////////////////////////////////////////////////////
// CDeviceAction

STDMETHODIMP CDeviceAction::get_Value(VARIANT* pvValue)
{
    pvValue->vt = VT_I4;
    pvValue->lVal = m_lValue;
    return S_OK;
}

STDMETHODIMP CDeviceAction::put_Value(VARIANT* pvValue)
{
    return S_OK;
}

STDMETHODIMP CDeviceAction::Action(LONG *plActionID)
{
    if(NULL == plActionID){
        return E_INVALIDARG;
    }

    *plActionID = m_DeviceActionID;
    return S_OK;
}

STDMETHODIMP CDeviceAction::ValueID(LONG *plValueID)
{
    if(NULL == plValueID){
        return E_INVALIDARG;
    }

    *plValueID = m_DeviceValueID;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\cmicro.h ===
#ifndef _CMICRO
#define _CMICRO

#include "objidl.h"
#include "wiamicro.h"

typedef HRESULT (CALLBACK *FPMICROENTRY)(LONG, PVAL);
typedef HRESULT (CALLBACK *FPSCANENTRY)(PSCANINFO, LONG, PBYTE, LONG, PLONG );
typedef HRESULT (CALLBACK *FPSETPIXELWINDOWENTRY)(PSCANINFO, LONG, LONG, LONG, LONG);

class CMICRO {

public:
     CMICRO(TCHAR *pszMicroDriver);
    ~CMICRO();
    HRESULT MicroEntry(LONG lCommand, PVAL pValue);
    HRESULT Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, PLONG plRecieved);
    HRESULT SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent);
    HRESULT Disable();
    HRESULT UnInitialize(PSCANINFO pScanInfo);
private:
    FPMICROENTRY m_pMicroEntry;
    FPSCANENTRY  m_pScan;
    FPSETPIXELWINDOWENTRY m_pSetPixelWindow;
    HMODULE m_hModule;
    SCSISCAN_CMD m_ScsiScan;
    BOOL         m_bDisabled;

protected:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\cmicro.cpp ===
#include "pch.h"

CMICRO::CMICRO(TCHAR *pszMicroDriver)
{
    m_hModule         = NULL;
    m_pMicroEntry     = NULL;
    m_pScan           = NULL;
    m_pSetPixelWindow = NULL;
    m_bDisabled       = FALSE;

    //
    // Load Micro driver
    //

    m_hModule = LoadLibrary(pszMicroDriver);
    if (m_hModule != NULL) {

        //
        // Get entry point
        //

        m_pMicroEntry = (FPMICROENTRY)GetProcAddress(m_hModule,"MicroEntry");

        if (m_pMicroEntry != NULL) {

            //
            // Get Scan entry point
            //

            m_pScan = (FPSCANENTRY)GetProcAddress(m_hModule,"Scan");

            if (m_pScan != NULL) {

                //
                // Get SetPixelWindow entry point
                //

                m_pSetPixelWindow = (FPSETPIXELWINDOWENTRY)GetProcAddress(m_hModule,"SetPixelWindow");

                if (m_pSetPixelWindow != NULL) {

                    //
                    // we are GO!
                    //

                }

            }

        }

    }
}

CMICRO::~CMICRO()
{
    if (m_hModule != NULL) {
        FreeLibrary(m_hModule);
    }
}

HRESULT CMICRO::MicroEntry(LONG lCommand, PVAL pValue)
{
    HRESULT hr = E_FAIL;
    if (m_pMicroEntry != NULL) {

        //
        // call Micro driver's entry point
        //

        hr =  m_pMicroEntry(lCommand, pValue);
    }
    return hr;
}

HRESULT CMICRO::Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, PLONG plRecieved)
{
    HRESULT hr = E_FAIL;
    if (m_pMicroEntry != NULL) {

        if (!m_bDisabled) {
            //
            // call Micro driver's scan entry point
            //

            hr =  m_pScan(pScanInfo, lPhase, pBuffer, lLength, plRecieved);
        } else {
            UnInitialize(pScanInfo);
        }
    }
    return hr;
}

HRESULT CMICRO::SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent)
{
    HRESULT hr = E_FAIL;
    if (m_pSetPixelWindow != NULL) {

        //
        // call Micro driver's SetPixelWindow entry point
        //

        hr =  m_pSetPixelWindow(pScanInfo,x,y,xExtent,yExtent);
    }
    return hr;
}

HRESULT CMICRO::Disable()
{
    HRESULT hr = S_OK;

    m_bDisabled = TRUE;
    return hr;
}

HRESULT CMICRO::UnInitialize(PSCANINFO pScanInfo)
{
    HRESULT hr = E_FAIL;

    if ((m_pMicroEntry != NULL)) {
        //
        // call Micro driver's entry point to UnInitalize
        //

        VAL Val;

        memset(&Val, 0, sizeof(Val));
        Val.pScanInfo = pScanInfo;
        hr = m_pMicroEntry(CMD_UNINITIALIZE,&Val);
        m_pMicroEntry = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\cdibutil.h ===
#ifndef _CDIBUTIL
#define _CDIBUTIL

class CDIBUtil {
public:        
    CDIBUtil();
    ~CDIBUtil();

    BOOL SetupBmpHeader(BITMAPINFOHEADER *pbiHeader, int width, int height, int bits, BOOL TopDown, int Resolution)
    {
        BOOL bSuccess = TRUE;
        int WidthBytes              = 0;        
        pbiHeader->biSize           = sizeof(BITMAPINFOHEADER);
        pbiHeader->biWidth          = width;
        pbiHeader->biHeight         = height * ((TopDown==TRUE)?-1:1);
        pbiHeader->biPlanes         = 1;
        pbiHeader->biBitCount       = (BYTE)bits;
        pbiHeader->biCompression    = 0;
        pbiHeader->biXPelsPerMeter  = int(Resolution * 39.37);
        pbiHeader->biYPelsPerMeter  = int(Resolution * 39.37);
        pbiHeader->biClrUsed        = 0;
        pbiHeader->biClrImportant   = 0;
        switch (bits) {
        case 1:
            WidthBytes = (width+7)/8;
            pbiHeader->biClrUsed    = 2;
            break;
        case 8:
            WidthBytes = width;
            pbiHeader->biClrUsed    = 256;
            break;
        case 24:
            WidthBytes = width*3;
            pbiHeader->biClrUsed    = 0;
            break;
        default:
            WidthBytes = 0;
            bSuccess = FALSE;
            break;
        }
    
        pbiHeader->biSizeImage = WidthToDIBWidth(WidthBytes)*height; // not used for compression
        return bSuccess;
    }

    void FillPalette (int NumPaletteEntries, tagRGBQUAD* pPal)
    {        
        if (NumPaletteEntries>1) {
            for (int i=0; i<NumPaletteEntries; i++) {
                int Val             = i*255/(NumPaletteEntries-1);
                pPal->rgbRed        = (BYTE)Val;
                pPal->rgbGreen      = (BYTE)Val;
                pPal->rgbBlue       = (BYTE)Val;
                pPal->rgbReserved   = 0;
                pPal++;
            }
        }
    }

    void FillLogPalette (int NumPaletteEntries, LOGPALETTE* pPal)
    {
        if (NumPaletteEntries>2) {
            for (int i=0; i<NumPaletteEntries; i++) {    
                pPal->palPalEntry[i].peRed   = (BYTE)i;
                pPal->palPalEntry[i].peGreen = (BYTE)i;
                pPal->palPalEntry[i].peBlue  = (BYTE)i;
                pPal->palPalEntry[i].peFlags = 0;
            }
        } else { // B/W Palette
            pPal->palPalEntry[0].peRed   = (BYTE)255;
            pPal->palPalEntry[0].peGreen = (BYTE)255;
            pPal->palPalEntry[0].peBlue  = (BYTE)255;
            pPal->palPalEntry[0].peFlags = 0;
            pPal->palPalEntry[1].peRed   = (BYTE)0;
            pPal->palPalEntry[1].peGreen = (BYTE)0;
            pPal->palPalEntry[1].peBlue  = (BYTE)0;
            pPal->palPalEntry[1].peFlags = 0;
        }
    }

    BOOL RawColorToDIB(int BitsPerPixel, BYTE* pDest, BYTE* pSrc, int Width, int Height)
    {
        BOOL bSuccess = FALSE;
        switch (BitsPerPixel) {
        case 1:
            bSuccess = RawColorToBinaryDIB (pDest, pSrc, Width, Height);
            break;
        case 8:
            bSuccess = RawColorToGrayDIB (pDest, pSrc, Width, Height);
            break;
        case 24:
            bSuccess = RawColorToColorDIB(pDest, pSrc, Width, Height);
            break;
        default:
            break;
        }
        return bSuccess;
    }

    BOOL RawColorToBinaryDIB(BYTE* pDest, BYTE* pSrc, int Width, int Height)
    {
        BOOL bSuccess = TRUE;
        BYTE* ptDest = NULL;
        BYTE* ptSrc  = NULL;
        
        int BitIdx    = 0;    
        BYTE Bits     = 0;
        BYTE GrayByte = 0;
    
        for (int i=0; i < Height; i++) {
            ptDest = pDest + (i*WidthToDIBWidth((Width+7)/8));
            ptSrc  = pSrc + i*Width*3;
            BitIdx = 0;
            Bits   = 0;
            for (int j=0; j < Width; j++) {
                GrayByte = (BYTE)((ptSrc[0] * 11 + ptSrc[1] * 59 + ptSrc[2] * 30)/100);
                Bits *= 2;
                if (GrayByte > 128) Bits +=  1;
                BitIdx++;
                if (BitIdx >= 8) {
                    BitIdx = 0;
                    *ptDest++ = Bits;
                }
                ptSrc += 3;
            }
            // Write out the last byte if matters
            if (BitIdx)
                *ptDest = Bits;
        }
        return bSuccess;
    }

    BOOL RawColorToGrayDIB(BYTE* pDest, BYTE* pSrc, int Width, int Height)
    {
        BOOL bSuccess = TRUE;
        BYTE* ptDest = NULL;
        BYTE* ptSrc  = NULL;
        
        for (int i=0; i<Height; i++) {
            ptDest = pDest + (i*WidthToDIBWidth(Width));
            ptSrc = pSrc + i*Width*3;
            for (int j=0; j<Width; j++) {
                *ptDest++ = (BYTE)((ptSrc[0] * 11 + ptSrc[1] * 59 + ptSrc[2] * 30)/100);
                ptSrc += 3;
            }
        }
        return bSuccess;
    }

    BOOL RawColorToColorDIB(BYTE* pDest, BYTE* pSrc, int Width, int Height)
    {
        BOOL bSuccess = TRUE;
        BYTE* ptDest = NULL;
        BYTE* ptSrc  = NULL;
        
        for (int i=0; i<Height; i++) {
            ptDest = pDest + (i*WidthToDIBWidth(Width*3));
            ptSrc = pSrc + i*Width*3;
            memcpy (ptDest, ptSrc, Width*3);
        }
        return bSuccess;
    }

    int  WidthToDIBWidth(int Width)
    {
        return (Width+3)&0xfffffffc;
    }
    
    BOOL WriteDIBToBMP(LPTSTR strFileName, HANDLE hDIB, int nNumPaletteEntries)
    {
        return FALSE;   // force exit for now.
        BOOL bSuccess = FALSE;
    
        // lock memory
        BYTE* pDIB = (BYTE*)GlobalLock(hDIB);
        if (pDIB) {
            LPBITMAPINFO pBitmap = (LPBITMAPINFO)pDIB;
            
            // write BMP file header
            BITMAPFILEHEADER bmfHeader;
            bmfHeader.bfType      = 0x4d42;
            bmfHeader.bfReserved1 = bmfHeader.bfReserved2 = 0;
            bmfHeader.bfSize      = pBitmap->bmiHeader.biSizeImage + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*nNumPaletteEntries;
            bmfHeader.bfOffBits   = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*nNumPaletteEntries;
    
            
            // write to disk
            // Write(&bmfHeader,sizeof(BITMAPFILEHEADER));
            // Write(pDIB,sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*nNumPaletteEntries+pBitmap->bmiHeader.biSizeImage);
            
            // unlock memory
            GlobalUnlock(hDIB);
            bSuccess = TRUE;
        }
    
        return bSuccess;
    }

    void GrayTo24bitColorDIB(BYTE* pSrc,  int WidthPixels, int Height)
    {
        BYTE* pTemp = NULL;
        DWORD dwSizeBits = (WidthPixels * Height);
        pTemp = (BYTE*)GlobalAlloc(GPTR,dwSizeBits + 1024);
        if (pTemp) {    
            CopyMemory(pTemp,pSrc,dwSizeBits);                
            DWORD MemIndex = 0;
            DWORD SrcIndex = 0;
            while (MemIndex <= dwSizeBits) {
                for (int i = 0;i<=2;i++) {
                    pSrc[SrcIndex] = pTemp[MemIndex];
                    SrcIndex++;
                }
                MemIndex++;
            }    
            GlobalFree(pTemp);
        }
    }
    
private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devaction.h ===
// DeviceAction.h : Declaration of the CDeviceAction

#ifndef __DEVICEACTION_H_
#define __DEVICEACTION_H_

#include "resource.h"       // main symbols
#include "ioblockdefs.h"

template <class T>
class CProxy_IDeviceActionEvent : public IConnectionPointImpl<T, &DIID__IDeviceActionEvent, CComDynamicUnkArray>
{
public:
    HRESULT Fire_DeviceActionEvent()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
            }
        }
        return varResult.scode;

    }
};

/////////////////////////////////////////////////////////////////////////////
// CDeviceAction
class ATL_NO_VTABLE CDeviceAction :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeviceAction, &CLSID_DeviceAction>,
    public IConnectionPointContainerImpl<CDeviceAction>,
    public IDispatchImpl<IDeviceAction, &IID_IDeviceAction, &LIBID_WIAFBLib>,
    public CProxy_IDeviceActionEvent< CDeviceAction >,
    public IObjectSafetyImpl<CDeviceAction, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:

    SCANSETTINGS *m_pScannerSettings;
    LONG m_DeviceActionID;
    LONG m_DeviceValueID;
    LONG m_lValue;

    CDeviceAction()
    {
        m_DeviceActionID    = 0;
        m_DeviceValueID     = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICEACTION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceAction)
    COM_INTERFACE_ENTRY(IDeviceAction)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CDeviceAction)
CONNECTION_POINT_ENTRY(DIID__IDeviceActionEvent)
END_CONNECTION_POINT_MAP()


// IDeviceAction
public:
    STDMETHOD(get_Value)(VARIANT* pvValue);
    STDMETHOD(put_Value)(VARIANT* pvValue);
    STDMETHOD(Action)(LONG *plActionID);
    STDMETHOD(ValueID)(LONG *plValueID);
};

#endif //__DEVICEACTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devctrl.h ===
// DeviceControl.h : Declaration of the CDeviceControl

#ifndef __DEVICECONTROL_H_
#define __DEVICECONTROL_H_

#include "resource.h"       // main symbols
#include "ioblockdefs.h"

//////////////////////////////////////////
// Taken from NTDDK.H                   //
//////////////////////////////////////////

#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//////////////////////////////////////////
// Taken from USBSCAN.H                 //
//////////////////////////////////////////

#define FILE_DEVICE_USB_SCAN    0x8000
#define IOCTL_INDEX             0x0800

#define IOCTL_GET_VERSION               CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX,   METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_CANCEL_IO                 CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+1, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WAIT_ON_DEVICE_EVENT      CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+2, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_READ_REGISTERS            CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+3, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WRITE_REGISTERS           CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+4, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_CHANNEL_ALIGN_RQST    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+5, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_DEVICE_DESCRIPTOR     CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+6, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RESET_PIPE                CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+7, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_USB_DESCRIPTOR        CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+8, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SEND_USB_REQUEST          CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+9, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_PIPE_CONFIGURATION    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+10,METHOD_BUFFERED,FILE_ANY_ACCESS)

typedef struct _IO_BLOCK {
    IN      unsigned    uOffset;
    IN      unsigned    uLength;
    IN OUT  PUCHAR      pbyData;
    IN      unsigned    uIndex;
} IO_BLOCK, *PIO_BLOCK;

///////////////////////////////////////////

#define IOCTL_GET_DEVICE_INFO   0x0
#define IOCTL_GET_DEVICE_STATUS 0x1
#define IOCTL_READ_WRITE_DATA   0x82
#define IOCTL_EPP_ADDR          0x83
#define IOCTL_EPP_READ          0x84
#define IOCTL_EPP_WRITE         0x85
#define IOCTL_SPP_STATUS        0x86
#define IOCTL_SPP_CONTROL       0x87
#define IOCTL_SPP_DATA_BUS      0x88
#define IOCTL_GPIO_OE           0x89
#define IOCTL_GPIO_READ         0x8A
#define IOCTL_GPIO_WRITE        0x8B

////////////////////////////////////////////////
// Custom BITS structure for bit manipulation //
////////////////////////////////////////////////

typedef struct _BITS{
    BYTE b0 :1;
    BYTE b1 :1;
    BYTE b2 :1;
    BYTE b3 :1;
    BYTE b4 :1;
    BYTE b5 :1;
    BYTE b6 :1;
    BYTE b7 :1;
}BITS;

/////////////////////////////////////////////////////////////////////////////
// CDeviceControl
class ATL_NO_VTABLE CDeviceControl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeviceControl, &CLSID_DeviceControl>,
    public IDispatchImpl<IDeviceControl, &IID_IDeviceControl, &LIBID_WIAFBLib>,
    public IObjectSafetyImpl<CDeviceControl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:

    SCANSETTINGS *m_pScannerSettings;
    BYTE *m_pBuffer;
    LONG  m_lBufferSize;
    DWORD m_dwBytesRead;

    CDeviceControl()
    {
        m_pBuffer = NULL;
        m_lBufferSize = 0;
        m_dwBytesRead = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICECONTROL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceControl)
    COM_INTERFACE_ENTRY(IDeviceControl)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDeviceControl
public:
    STDMETHOD(RawWrite)(LONG lPipeNum,VARIANT *pvbuffer,LONG lbuffersize,LONG lTimeout);
    STDMETHOD(RawRead)(LONG lPipeNum,VARIANT *pvbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout);
    STDMETHOD(ScanRead)(LONG lPipeNum,LONG lBytesToRead, LONG *plBytesRead, LONG lTimeout);
    STDMETHOD(RegisterWrite)(LONG lPipeNum,VARIANT *pvbuffer,LONG lTimeout);
    STDMETHOD(RegisterRead)(LONG lPipeNum,LONG lRegNumber, VARIANT *pvbuffer,LONG lTimeout);
    STDMETHOD(SetBitsInByte)(BYTE bMask, BYTE bValue, BYTE *pbyte);
};

#endif //__DEVICECONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devprop.cpp ===
// devprop.cpp : Implementation of CDeviceProperty
#include "pch.h"
#include "wiafb.h"
#include "devprop.h"

/////////////////////////////////////////////////////////////////////////////
// CDeviceProperty

STDMETHODIMP CDeviceProperty::SetCurrentValue(LONG lValueID, VARIANT Value)
{
    switch(lValueID){
    case XRESOLUTION_ID:
        m_pScannerSettings->CurrentXResolution = Value.lVal;
        break;
    case YRESOLUTION_ID:
        m_pScannerSettings->CurrentYResolution = Value.lVal;
        break;
    case XPOS_ID:
        m_pScannerSettings->CurrentXPos = Value.lVal;
        break;
    case YPOS_ID:
        m_pScannerSettings->CurrentYPos = Value.lVal;
        break;
    case XEXT_ID:
        m_pScannerSettings->CurrentXExtent = Value.lVal;
        break;
    case YEXT_ID:
        m_pScannerSettings->CurrentYExtent = Value.lVal;
        break;
    case BRIGHTNESS_ID:
        m_pScannerSettings->CurrentBrightness = Value.lVal;
        break;
    case CONTRAST_ID:
        m_pScannerSettings->CurrentContrast = Value.lVal;
        break;
    case DATA_TYPE_ID:
        m_pScannerSettings->CurrentDataType = (LONG)Value.iVal;
        break;
    case BIT_DEPTH_ID:
        m_pScannerSettings->CurrentBitDepth = (LONG)Value.iVal;
        break;
    case NEGATIVE_ID:
        m_pScannerSettings->bNegative = (BOOL)Value.boolVal;
        break;
    case PIXEL_PACKING_ID:
        m_pScannerSettings->RawPixelPackingOrder = (LONG)Value.iVal;
        break;
    case PIXEL_FORMAT_ID:
        m_pScannerSettings->RawPixelFormat = (LONG)Value.iVal;
        break;
    case DATA_ALIGN_ID:
        m_pScannerSettings->RawDataAlignment = (LONG)Value.iVal;
        break;
    case BED_WIDTH_ID:
        m_pScannerSettings->BedWidth = Value.lVal;
        break;
    case BED_HEIGHT_ID:
        m_pScannerSettings->BedHeight = Value.lVal;
        break;
    case XOPTICAL_ID:
        m_pScannerSettings->XOpticalResolution = Value.lVal;
        break;
    case YOPTICAL_ID:
        m_pScannerSettings->YOpticalResolution = Value.lVal;
        break;
    case ADF_ID:
        m_pScannerSettings->ADFSupport = Value.lVal;
        break;
    case TPA_ID:
        m_pScannerSettings->TPASupport = Value.lVal;
        break;
    case ADF_WIDTH_ID:
        m_pScannerSettings->FeederWidth = Value.lVal;
        break;
    case ADF_HEIGHT_ID:
        m_pScannerSettings->FeederHeight = Value.lVal;
        break;
    case ADF_VJUSTIFY_ID:
        m_pScannerSettings->VFeederJustification = Value.lVal;
        break;
    case ADF_HJUSTIFY_ID:
        m_pScannerSettings->HFeederJustification = Value.lVal;
        break;
    case ADF_MAX_PAGES_ID:
        m_pScannerSettings->MaxADFPageCapacity = Value.lVal;
        break;
    case FIRMWARE_VER_ID:
        //lstrcpy(m_pScannerSettings->FirmwareVersion,Value.cVal);
        break;
    default:
        return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP CDeviceProperty::GetCurrentValue(LONG lValueID, VARIANT *pvValue)
{
    // default to LONG type
    pvValue->vt = VT_I4;

    switch(lValueID){
    case XRESOLUTION_ID:
        pvValue->lVal = m_pScannerSettings->CurrentXResolution;
        break;
    case YRESOLUTION_ID:
        pvValue->lVal = m_pScannerSettings->CurrentYResolution;
        break;
    case XPOS_ID:
        pvValue->lVal = m_pScannerSettings->CurrentXPos;
        break;
    case YPOS_ID:
        pvValue->lVal = m_pScannerSettings->CurrentYPos;
        break;
    case XEXT_ID:
        pvValue->lVal = m_pScannerSettings->CurrentXExtent;
        break;
    case YEXT_ID:
        pvValue->lVal = m_pScannerSettings->CurrentYExtent;
        break;
    case BRIGHTNESS_ID:
        pvValue->lVal = m_pScannerSettings->CurrentBrightness;
        break;
    case CONTRAST_ID:
        pvValue->lVal = m_pScannerSettings->CurrentContrast;
        break;
    case DATA_TYPE_ID:
        pvValue->vt = VT_I2;
        pvValue->iVal = (INT)m_pScannerSettings->CurrentDataType;
        break;
    case BIT_DEPTH_ID:
        pvValue->vt = VT_I2;
        pvValue->iVal = (INT)m_pScannerSettings->CurrentBitDepth;
        break;
    case NEGATIVE_ID:
        pvValue->lVal = (LONG)m_pScannerSettings->bNegative;
        break;
    case PIXEL_PACKING_ID:
        pvValue->lVal = m_pScannerSettings->RawPixelPackingOrder;
        break;
    case PIXEL_FORMAT_ID:
        pvValue->lVal = m_pScannerSettings->RawPixelFormat;
        break;
    case DATA_ALIGN_ID:
        pvValue->lVal = m_pScannerSettings->RawDataAlignment;
        break;
    case BED_WIDTH_ID:
        pvValue->lVal = m_pScannerSettings->BedWidth;
        break;
    case BED_HEIGHT_ID:
        pvValue->lVal = m_pScannerSettings->BedHeight;
        break;
    case XOPTICAL_ID:
        pvValue->lVal = m_pScannerSettings->XOpticalResolution;
        break;
    case YOPTICAL_ID:
        pvValue->lVal = m_pScannerSettings->YOpticalResolution;
        break;
    case ADF_ID:
        pvValue->lVal = m_pScannerSettings->ADFSupport;
        break;
    case TPA_ID:
        pvValue->lVal = m_pScannerSettings->TPASupport;
        break;
    case ADF_WIDTH_ID:
        pvValue->lVal = m_pScannerSettings->FeederWidth;
        break;
    case ADF_HEIGHT_ID:
        pvValue->lVal = m_pScannerSettings->FeederHeight;
        break;
    case ADF_VJUSTIFY_ID:
        pvValue->lVal = m_pScannerSettings->VFeederJustification;
        break;
    case ADF_HJUSTIFY_ID:
        pvValue->lVal = m_pScannerSettings->HFeederJustification;
        break;
    case ADF_MAX_PAGES_ID:
        pvValue->lVal = m_pScannerSettings->MaxADFPageCapacity;
        break;
    case FIRMWARE_VER_ID:
        //lstrcpy(m_pScannerSettings->FirmwareVersion,Value.cVal);
        break;
    default:
        return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP CDeviceProperty::SetValidRange(LONG lValueID, LONG lMin, LONG lMax, LONG lNom, LONG lInc)
{

    switch(lValueID){
    case XRESOLUTION_ID:
        m_pScannerSettings->XSupportedResolutionsRange.lMax  = lMax;
        m_pScannerSettings->XSupportedResolutionsRange.lMin  = lMin;
        m_pScannerSettings->XSupportedResolutionsRange.lNom  = lNom;
        m_pScannerSettings->XSupportedResolutionsRange.lStep = lInc;
        break;
    case YRESOLUTION_ID:
        m_pScannerSettings->YSupportedResolutionsRange.lMax  = lMax;
        m_pScannerSettings->YSupportedResolutionsRange.lMin  = lMin;
        m_pScannerSettings->YSupportedResolutionsRange.lNom  = lNom;
        m_pScannerSettings->YSupportedResolutionsRange.lStep = lInc;
        break;
    case XPOS_ID:
        m_pScannerSettings->XPosRange.lMax = lMax;
        m_pScannerSettings->XPosRange.lMin = lMin;
        m_pScannerSettings->XPosRange.lNom = lNom;
        m_pScannerSettings->XPosRange.lStep = lInc;
        break;
    case YPOS_ID:
        m_pScannerSettings->YPosRange.lMax = lMax;
        m_pScannerSettings->YPosRange.lMin = lMin;
        m_pScannerSettings->YPosRange.lNom = lNom;
        m_pScannerSettings->YPosRange.lStep = lInc;
        break;
    case XEXT_ID:
        m_pScannerSettings->XExtentsRange.lMax = lMax;
        m_pScannerSettings->XExtentsRange.lMin = lMin;
        m_pScannerSettings->XExtentsRange.lNom = lNom;
        m_pScannerSettings->XExtentsRange.lStep = lInc;
        break;
    case YEXT_ID:
        m_pScannerSettings->YExtentsRange.lMax  = lMax;
        m_pScannerSettings->YExtentsRange.lMin  = lMin;
        m_pScannerSettings->YExtentsRange.lNom  = lNom;
        m_pScannerSettings->YExtentsRange.lStep = lInc;
        break;
    case BRIGHTNESS_ID:
        m_pScannerSettings->BrightnessRange.lMax = lMax;
        m_pScannerSettings->BrightnessRange.lMin = lMin;
        m_pScannerSettings->BrightnessRange.lNom = lNom;
        m_pScannerSettings->BrightnessRange.lStep = lInc;
        break;
    case CONTRAST_ID:
        m_pScannerSettings->ContrastRange.lMax = lMax;
        m_pScannerSettings->ContrastRange.lMin = lMin;
        m_pScannerSettings->ContrastRange.lNom = lNom;
        m_pScannerSettings->ContrastRange.lStep = lInc;
        break;
    default:
        return E_FAIL;
    }
    return S_OK;
}

STDMETHODIMP CDeviceProperty::SetValidList(LONG lValueID, VARIANT Value)
{
    HRESULT hr     = S_OK;
    INT iNumValues = 0;
    INT index      = 1;
    LONG lLBound   = 0;
    LONG lUBound   = 0;
    VARIANT *pVariant = NULL;

    //
    // incoming, array of VARIANTS:
    // use Value to get actual VARIANT Array
    //

    VARIANTARG *pVariantArg = Value.pvarVal;

    if(SafeArrayGetDim(pVariantArg->parray) != 1){
        return E_INVALIDARG;
    }

    //
    // get upper bounds of array
    //

    hr = SafeArrayGetUBound(pVariantArg->parray, 1, (long *)&lUBound);
    hr = SafeArrayAccessData(pVariantArg->parray, (void**)&pVariant);
    if (SUCCEEDED(hr)) {
        iNumValues = lUBound + 1;
        switch (lValueID) {
        case XRESOLUTION_ID:
            m_pScannerSettings->XSupportedResolutionsList  = (PLONG)LocalAlloc(LPTR,(sizeof(LONG) * iNumValues));
            if (m_pScannerSettings->XSupportedResolutionsList) {
                m_pScannerSettings->XSupportedResolutionsList[0] = iNumValues;
                for (index = 0; index < iNumValues; index++) {
                    m_pScannerSettings->XSupportedResolutionsList[index+1] = pVariant[index].iVal;
                }
            }
            break;
        case YRESOLUTION_ID:
            m_pScannerSettings->YSupportedResolutionsList  = (PLONG)LocalAlloc(LPTR,(sizeof(LONG) * iNumValues));
            if (m_pScannerSettings->YSupportedResolutionsList) {
                m_pScannerSettings->YSupportedResolutionsList[0] = iNumValues;
                for (index = 0; index < iNumValues; index++) {
                    m_pScannerSettings->YSupportedResolutionsList[index+1] = pVariant[index].iVal;
                }
            }
            break;
        case DATA_TYPE_ID:
            m_pScannerSettings->SupportedDataTypesList  = (PLONG)LocalAlloc(LPTR,(sizeof(LONG) * iNumValues));
            if (m_pScannerSettings->SupportedDataTypesList) {
                m_pScannerSettings->SupportedDataTypesList[0] = iNumValues;
                for (index = 0; index < iNumValues; index++) {
                    m_pScannerSettings->SupportedDataTypesList[index+1] = pVariant[index].iVal;
                }
            }
            break;
        default:
            hr =  E_FAIL;
            break;
        }
        SafeArrayUnaccessData(pVariantArg->parray);
    }
    return hr;
}

STDMETHODIMP CDeviceProperty::TestCall()
{
    ::MessageBox(NULL,TEXT("Test CALL"),TEXT("Test CALL"),MB_OK);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devctrl.cpp ===
// devctrl.cpp : Implementation of CDeviceControl
#include "pch.h"
#include "wiafb.h"
#include "devctrl.h"

#define IOCTL_EPP_WRITE         0x85 // remove at a later data.. Visioneer specific ( this is for
                                     // proof of concept.)
#define IOCTL_EPP_READ          0x84

/////////////////////////////////////////////////////////////////////////////
// CDeviceControl

STDMETHODIMP CDeviceControl::RawWrite(LONG lPipeNum,VARIANT *pvbuffer,LONG lbuffersize,LONG lTimeout)
{

    HRESULT hr = E_FAIL;
    /*
    UINT uiBufferLen = 0;
    CHAR *pData = NULL;
    DWORD dwBytesWritten = 0;

    switch (pvbuffer->vt) {
    case VT_BSTR:
        {
            if(NULL != pvbuffer->bstrVal){

                uiBufferLen = WideCharToMultiByte(CP_ACP, 0, pvbuffer->bstrVal, -1, NULL, NULL, 0, 0);
                if (!uiBufferLen) {

                    // SetLastErrorCode
                }

                pData = new CHAR[uiBufferLen+1];
                if (!pData) {

                    // SetLastErrorCode
                    return E_OUTOFMEMORY;
                }

                WideCharToMultiByte(CP_ACP, 0, pvbuffer->bstrVal, -1, pData, uiBufferLen, 0, 0);

                //
                // send data to device
                //

                // DeviceIOControl(....)

                if(!WriteFile(m_pScannerSettings->DeviceIOHandles[lPipeNum],
                          pData,
                          lbuffersize,
                          &dwBytesWritten,NULL)){

                    // SetLastErrorCode
                }

                //
                // delete any allocated memory
                //

                delete pData;


            } else {

                // SetLastErrorCode
            }
        }
        break;
    default:
        hr = E_FAIL;
        break;
    }
    */
    return hr;
}

STDMETHODIMP CDeviceControl::RawRead(LONG lPipeNum,VARIANT *pvbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout)
{
    HRESULT hr = S_OK;
    WCHAR wszBuffer[255];
    CHAR *pBuffer = NULL;
    DWORD dwBytesRead = 0;

    VariantClear(pvbuffer);

    //
    // clean out buffer
    //

    memset(wszBuffer,0,sizeof(wszBuffer));

    //
    // alloc/clean in buffer
    //

    pBuffer = new CHAR[(lbuffersize+1)];

    if(NULL == pBuffer){
        return E_OUTOFMEMORY;
    }

    memset(pBuffer,0,lbuffersize+1);

    //
    // read from device
    //

    if(!ReadFile(m_pScannerSettings->DeviceIOHandles[lPipeNum],pBuffer,lbuffersize,&dwBytesRead,NULL)) {
        return E_FAIL;
    }

    pBuffer[dwBytesRead] = '\0';

    //
    // set number of bytes read
    //

    *plbytesread = dwBytesRead;

    //
    // construct VARIANT properly, for out buffer
    //

    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        pBuffer,
                        lstrlenA(pBuffer)+1,
                        wszBuffer,
                        (sizeof(wszBuffer)/sizeof(WCHAR)));

    pvbuffer->vt = VT_BSTR;
    pvbuffer->bstrVal = SysAllocString(wszBuffer);

    delete pBuffer;

    return hr;
}

STDMETHODIMP CDeviceControl::ScanRead(LONG lPipeNum,LONG lBytesToRead, LONG *plBytesRead, LONG lTimeout)
{

    if(!ReadFile(m_pScannerSettings->DeviceIOHandles[lPipeNum],
                 m_pBuffer,
                 m_lBufferSize,
                 &m_dwBytesRead,NULL)) {

        //
        // SetLastErrorCode
        //

    }

    return S_OK;
}

STDMETHODIMP CDeviceControl::RegisterWrite(LONG lPipeNum,VARIANT *pvbuffer,LONG lTimeout)
{
    HRESULT hr           = S_OK;
    PBYTE pData          = NULL;
    DWORD dwBytesWritten = 0;
    IO_BLOCK IoBlock;
    memset(&IoBlock,0,sizeof(IO_BLOCK));
    VARIANT *pVariant    = NULL;
    VARIANTARG *pVariantArg = pvbuffer->pvarVal;
    LONG lUBound         = 0;
    LONG lNumItems       = 0;

    if(SafeArrayGetDim(pVariantArg->parray)!=1){
        return E_INVALIDARG;
    }

    //
    // get upper bounds
    //

    hr = SafeArrayGetUBound(pVariantArg->parray,1,(LONG*)&lUBound);
    if (SUCCEEDED(hr)) {
        hr = SafeArrayAccessData(pVariantArg->parray,(void**)&pVariant);
        if (SUCCEEDED(hr)) {
            lNumItems = (lUBound + 1);
            pData     = (PBYTE)LocalAlloc(LPTR,sizeof(BYTE) * lNumItems);
            if(NULL != pData){

                //
                // copy contents of VARIANT into BYTE array, for writing to
                // the device.
                //

                for(INT index = 0;index <lUBound;index++){
                    pData[index] = pVariant[index].bVal;
                }

                IoBlock.uOffset = (BYTE)IOCTL_EPP_WRITE;
                IoBlock.uLength = (BYTE)(sizeof(BYTE) * lNumItems);
                IoBlock.pbyData = pData;

                DeviceIoControl(m_pScannerSettings->DeviceIOHandles[lPipeNum],
                                           (DWORD) IOCTL_WRITE_REGISTERS,
                                           &IoBlock,
                                           sizeof(IO_BLOCK),
                                           NULL,
                                           0,
                                           &dwBytesWritten,
                                           NULL);

                //
                // free array block, after operation is complete
                //

                LocalFree(pData);
                pData = NULL;
            }
        }
    }

    return hr;
}

STDMETHODIMP CDeviceControl::RegisterRead(LONG lPipeNum,LONG lRegNumber, VARIANT *pvbuffer,LONG lTimeout)
{
    HRESULT hr = S_OK;
    DWORD dwBytesRead = 0;

    pvbuffer->vt = VT_UI1;

    //
    // read from device
    //

    IO_BLOCK IoBlock;

    IoBlock.uOffset = MAKEWORD(IOCTL_EPP_READ, (BYTE)lRegNumber);
    IoBlock.uLength = 1;
    IoBlock.pbyData = &pvbuffer->bVal;

    if (!DeviceIoControl(m_pScannerSettings->DeviceIOHandles[lPipeNum],
                         (DWORD) IOCTL_READ_REGISTERS,
                         (PVOID)&IoBlock,
                         (DWORD)sizeof(IO_BLOCK),
                         (PVOID)&pvbuffer->bVal,
                         (DWORD)sizeof(BYTE),
                         &dwBytesRead,
                         NULL)){
        return E_FAIL;
    };
    return hr;
}

STDMETHODIMP CDeviceControl::SetBitsInByte(BYTE bMask, BYTE bValue, BYTE *pbyte)
{
    LONG lBitIndex = 0;

    if(((BITS*)&bMask)->b0 == 1)
        lBitIndex = 0;
    else if(((BITS*)&bMask)->b1 == 1)
        lBitIndex = 1;
    else if(((BITS*)&bMask)->b2 == 1)
        lBitIndex = 2;
    else if(((BITS*)&bMask)->b3 == 1)
        lBitIndex = 3;
    else if(((BITS*)&bMask)->b4 == 1)
        lBitIndex = 4;
    else if(((BITS*)&bMask)->b5 == 1)
        lBitIndex = 5;
    else if(((BITS*)&bMask)->b6 == 1)
        lBitIndex = 6;
    else if(((BITS*)&bMask)->b7 == 1)
        lBitIndex = 7;

        *pbyte  = (*pbyte & ~bMask) | ((bValue << lBitIndex) & bMask);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\dlihook.cpp ===
#include "pch.h"
#include <delayimp.h>

FARPROC WINAPI DliHook(unsigned dliNotify, PDelayLoadInfo pdli)
{    
#ifdef DEBUG
    switch (dliNotify) {
    case dliStartProcessing:             // used to bypass or note helper only
        OutputDebugString(TEXT("dliStartProcessing reported from DliHook"));
        break;
    case dliNotePreLoadLibrary:          // called just before LoadLibrary, can
        OutputDebugString(TEXT("dliNotePreLoadLibrary reported from DliHook"));                   //  override w/ new HMODULE return val
        break;                           
    case dliNotePreGetProcAddress:       // called just before GetProcAddress, can
        OutputDebugString(TEXT("dliNotePreGetProcAddress reported from DliHook"));                   //  override w/ new FARPROC return value
        break;                           
    case dliFailLoadLib:                 // failed to load library, fix it by
        OutputDebugString(TEXT("dliFailLoadLib reported from DliHook"));                   //  returning a valid HMODULE
        break;                           
    case dliFailGetProc:                 // failed to get proc address, fix it by                                         
        OutputDebugString(TEXT("dliFailGetProc reported from DliHook"));                   //  returning a valid FARPROC
        break;                           
    case dliNoteEndProcessing:           // called after all processing is done, no
        OutputDebugString(TEXT("dliNoteEndProcessing reported from DliHook"));                   //  no bypass possible at this point except
                                         //  by longjmp()/throw()/RaiseException.
        break;
    default:
        break;
    }
#endif
    return 0;
}

PfnDliHook __pfnDliFailureHook = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\ioblock.cpp ===
#include "pch.h"
CComModule _Module;
#include <initguid.h>
DEFINE_GUID(CLSID_VBScript, 0xb54f3741, 0x5b07, 0x11cf, 0xa4, 0xb0, 0x0, 0xaa, 0x0, 0x4a, 0x55, 0xe8);

CIOBlock::CIOBlock()
{
    memset(m_szFileName,0,sizeof(m_szFileName));
}

CIOBlock::~CIOBlock()
{
    StopScriptEngine();
}

void CIOBlock::Initialize(PGSD_INFO pGSDInfo)
{
    // SBB - RAID 370299 - orenr - 2001/04/18 - Security fix - 
    // potential buffer overrun.  Changed lstrcpy to use
    // _tcsncpy instead.
    //
    ZeroMemory(m_szFileName, sizeof(m_szFileName));
    _tcsncpy(m_szFileName, 
             pGSDInfo->szProductFileName,
             (sizeof(m_szFileName) / sizeof(TCHAR)) - 1);
}

HRESULT CIOBlock::StartScriptEngine()
{
    HRESULT hr = S_OK;

    //
    // load scriptlets
    //

    hr = LoadScript();
    if(FAILED(hr)){
        return hr;
    }

    m_pDeviceScriptSite = new CDeviceScriptSite;
    if(m_pDeviceScriptSite){
        m_pDeviceProperty   = new CComObject<CDeviceProperty>;
        if(m_pDeviceProperty){
            m_pDeviceAction     = new CComObject<CDeviceAction>;
            if(m_pDeviceAction){
                m_pDeviceControl    = new CComObject<CDeviceControl>;
                if(m_pDeviceControl){
                    m_pLastError        = new CComObject<CLastError>;
                    if(!m_pLastError){
                        hr = E_OUTOFMEMORY;    
                    }
                } else {
                    hr = E_OUTOFMEMORY;
                }
            } else {
                hr = E_OUTOFMEMORY;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_OUTOFMEMORY;
    }
    
    if(FAILED(hr)){

        //
        // Delete site & objects
        //

        if (m_pDeviceScriptSite) {
            delete m_pDeviceScriptSite;
            m_pDeviceScriptSite = NULL;
        }
        if (m_pDeviceProperty) {
            delete m_pDeviceProperty;
            m_pDeviceProperty = NULL;
        }
        if (m_pDeviceAction) {
            delete m_pDeviceAction;
            m_pDeviceAction = NULL;
        }

        if (m_pLastError) {
            m_pLastError = NULL;
        }
    }

    //
    // Initialize objects
    //

    m_pDeviceProperty->m_pScannerSettings = &m_ScannerSettings;
    m_pDeviceControl->m_pScannerSettings = &m_ScannerSettings;
    m_pDeviceAction->m_pScannerSettings = &m_ScannerSettings;

    //
    // get type library information
    //

    ITypeLib *ptLib = 0;
    // hr = LoadTypeLib(L"wiafb.tlb", &ptLib);           // type library as a separate file
    hr = LoadTypeLib(OLESTR("wiafbdrv.dll\\2"), &ptLib); // type library as a resource
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Type library loaded"));
    } else {
        Trace(TEXT("Type library failed to load"));
    }

    ptLib->GetTypeInfoOfGuid(CLSID_DeviceProperty, &m_pDeviceScriptSite->m_pTypeInfo);
    ptLib->GetTypeInfoOfGuid(CLSID_DeviceAction, &m_pDeviceScriptSite->m_pTypeInfoDeviceAction);
    ptLib->GetTypeInfoOfGuid(CLSID_DeviceControl, &m_pDeviceScriptSite->m_pTypeInfoDeviceControl);
    ptLib->GetTypeInfoOfGuid(CLSID_LastError, &m_pDeviceScriptSite->m_pTypeInfoLastError);
    ptLib->Release();

    //
    // Intialize DeviceScriptSite with IUnknowns of scripting objects
    //

    hr = m_pDeviceProperty->QueryInterface(IID_IUnknown,(void **)&m_pDeviceScriptSite->m_pUnkScriptObject);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI on DeviceProperty success"));
    } else {
        Trace(TEXT("QI on DeviceProperty FAILED"));
    }

    hr = m_pDeviceAction->QueryInterface(IID_IUnknown,(void **)&m_pDeviceScriptSite->m_pUnkScriptObjectDeviceAction);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI on DeviceAction success"));
    } else {
        Trace(TEXT("QI on DeviceAction FAILED"));
    }

    hr = m_pDeviceControl->QueryInterface(IID_IUnknown,(void **)&m_pDeviceScriptSite->m_pUnkScriptObjectDeviceControl);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI on DeviceControl success"));
    } else {
        Trace(TEXT("QI on DeviceControl FAILED"));
    }

    hr = m_pLastError->QueryInterface(IID_IUnknown,(void **)&m_pDeviceScriptSite->m_pUnkScriptObjectLastError);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI on LastError success"));
    } else {
        Trace(TEXT("QI on LastError FAILED"));
    }

    //
    // Start inproc script engine, VBSCRIPT.DLL
    //

    hr = CoCreateInstance(CLSID_VBScript,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IActiveScript, (void **)&m_pActiveScript);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("CoCreateInstance, VBScript"));
    } else {
        Trace(TEXT("CoCreateInstance, VBScript FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Get engine's IActiveScriptParse interface.
    //

    hr = m_pActiveScript->QueryInterface(IID_IActiveScriptParse,
                             (void **)&m_pActiveScriptParser);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI pm ActiveParse success"));
    } else {
        Trace(TEXT("QI pm ActiveParse FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Give engine our DeviceScriptSite interface...
    //

    hr = m_pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite "));
    } else {
        Trace(TEXT("SetScriptSite FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Intialize Engine
    //

    hr = m_pActiveScriptParser->InitNew();
    if (SUCCEEDED(hr)) {
        Trace(TEXT("InitNew"));
    } else {
        Trace(TEXT("InitNew FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Add object names to ActiveScript's known named item list
    //

    hr = m_pActiveScript->AddNamedItem(L"DeviceProperty", SCRIPTITEM_ISVISIBLE);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("added item"));
    } else {
        Trace(TEXT("added item FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = m_pActiveScript->AddNamedItem(L"DeviceAction", SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("added item"));
    } else {
        Trace(TEXT("added item FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = m_pActiveScript->AddNamedItem(L"DeviceControl", SCRIPTITEM_ISVISIBLE);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("added item"));
    } else {
        Trace(TEXT("added item FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = m_pActiveScript->AddNamedItem(L"LastError", SCRIPTITEM_ISVISIBLE);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("added item"));
    } else {
        Trace(TEXT("added item FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    return ProcessScript();
}

HRESULT CIOBlock::StopScriptEngine()
{
    HRESULT hr = S_OK;

    //
    // Release interfaces
    //

    if(m_pActiveScriptParser){
        m_pActiveScriptParser->Release();
        m_pActiveScriptParser = NULL;
    }

    if (m_pActiveScript) {
        m_pActiveScript->Release();
        m_pActiveScript = NULL;
    }

    //
    // Delete site & objects
    //

    if (m_pDeviceScriptSite) {
        delete m_pDeviceScriptSite;
        m_pDeviceScriptSite = NULL;
    }
    if (m_pDeviceProperty) {
        delete m_pDeviceProperty;
        m_pDeviceProperty = NULL;
    }
    if (m_pDeviceAction) {
        delete m_pDeviceAction;
        m_pDeviceAction = NULL;
    }

    if (m_pLastError) {
        m_pLastError = NULL;
    }

    //
    // free scriptlets
    //

    if(m_wszScriptText){
        LocalFree(m_wszScriptText);
    }

    return hr;
}

HRESULT CIOBlock::LoadScript()
{
    HRESULT hr          = S_OK;
    DWORD dwFileSize    = 0;
    DWORD dwBytesRead   = 0;
    CHAR *pBytes        = NULL;
    HANDLE hGSDProductLineFile = NULL;

    BY_HANDLE_FILE_INFORMATION FileInfo;

    //
    // construct Window's system path
    //

    TCHAR szFullFilePath[255];
    GetSystemDirectory(szFullFilePath,(sizeof(szFullFilePath)/sizeof(TCHAR)));
    lstrcat(szFullFilePath,TEXT("\\"));
    lstrcat(szFullFilePath,m_szFileName);

    //
    // open script file
    //

    Trace(TEXT("Opening this script file: %ws"),szFullFilePath);
    hGSDProductLineFile = CreateFile(szFullFilePath,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);

    if (NULL == hGSDProductLineFile || INVALID_HANDLE_VALUE == hGSDProductLineFile) {
        DWORD dwError = 0;
        dwError = GetLastError();
        Trace(TEXT("CreateFile() LastError reports %d "),dwError);
        return E_FAIL;
    }

    //
    // calculate needed space, for script text buffer
    //

    GetFileInformationByHandle(hGSDProductLineFile,&FileInfo);
    dwFileSize = FileInfo.nFileSizeLow;

    //
    // alloc temp memory, for reading script file, read file, and close file
    //

    pBytes = (CHAR*)LocalAlloc(LPTR,(dwFileSize + 1024));
    if (NULL != pBytes) {

        ReadFile(hGSDProductLineFile,pBytes,dwFileSize,&dwBytesRead,NULL);
        CloseHandle(hGSDProductLineFile);

        if ((dwBytesRead == dwFileSize)) {

            //
            // allocate text buffer
            //

            m_wszScriptText = (WCHAR*)LocalAlloc(LPTR,(dwFileSize * 2) + 1024);
            if(NULL != m_wszScriptText){
                memset(m_wszScriptText,0,(dwFileSize * 2) + 1024);
                MultiByteToWideChar(CP_ACP, 0, pBytes, dwBytesRead, m_wszScriptText, (dwFileSize*2) + 1024);
            }
        } else {
            hr = E_FAIL;
        }

        //
        // free temp buffer
        //

        LocalFree(pBytes);
    }
    return hr;
}

HRESULT CIOBlock::ProcessScript()
{
    HRESULT hr = S_OK;
    EXCEPINFO ei;

    //
    // parse scriptlet
    // note: we are alloc a copy here... should we keep the original
    //       around for extra processing...manually??
    //

    BSTR pParseText = ::SysAllocString(m_wszScriptText);
    hr = m_pActiveScriptParser->ParseScriptText(pParseText, NULL,
                               NULL, NULL, 0, 0, 0L, NULL, &ei);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("script parsed"));
    } else {
        Trace(TEXT("script parse FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    ::SysFreeString(pParseText);

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    return hr;
}

HRESULT CIOBlock::DebugDumpScannerSettings()
{
    HRESULT hr = S_OK;

    // #define _USE_DUMMY_VALUES
#ifdef _USE_DUMMY_VALUES
    lstrcpy(m_ScannerSettings.Version,TEXT("1.0"));
    lstrcpy(m_ScannerSettings.DeviceName,TEXT("HP 5P Driver"));
    lstrcpy(m_ScannerSettings.FirmwareVersion,TEXT("1.01"));

    m_ScannerSettings.BUSType                          = BUS_TYPE_SCSI;
    m_ScannerSettings.bNegative                        = TRUE;
    m_ScannerSettings.CurrentXResolution               = 300;
    m_ScannerSettings.CurrentYResolution               = 300;
    m_ScannerSettings.BedWidth                         = 8500;
    m_ScannerSettings.BedHeight                        = 11693;
    m_ScannerSettings.XOpticalResolution               = 300;
    m_ScannerSettings.YOpticalResolution               = 300;
    m_ScannerSettings.CurrentBrightness                = 32;
    m_ScannerSettings.CurrentContrast                  = 12;
    m_ScannerSettings.ADFSupport                       = FALSE;
    m_ScannerSettings.TPASupport                       = FALSE;
    m_ScannerSettings.RawPixelPackingOrder             = WIA_PACKED_PIXEL;
    m_ScannerSettings.RawPixelFormat                   = WIA_ORDER_BGR;
    m_ScannerSettings.RawDataAlignment                 = DWORD_ALIGN;

    m_ScannerSettings.FeederWidth                      = m_ScannerSettings.BedWidth;
    m_ScannerSettings.FeederHeight                     = m_ScannerSettings.BedHeight;
    m_ScannerSettings.VFeederJustification              = LEFT_JUSTIFIED;
    m_ScannerSettings.HFeederJustification              = TOP_JUSTIFIED;
    m_ScannerSettings.MaxADFPageCapacity               = 30;
    m_ScannerSettings.CurrentDataType                  = WIA_DATA_GRAYSCALE;
    m_ScannerSettings.CurrentBitDepth                  = 8;

    m_ScannerSettings.XSupportedResolutionsRange.lMax  = 1200;
    m_ScannerSettings.XSupportedResolutionsRange.lMin  = 12;
    m_ScannerSettings.XSupportedResolutionsRange.lStep = 1;

    m_ScannerSettings.YSupportedResolutionsRange.lMax  = 1200;
    m_ScannerSettings.YSupportedResolutionsRange.lMin  = 12;
    m_ScannerSettings.YSupportedResolutionsRange.lStep = 1;

    m_ScannerSettings.XExtentsRange.lMax               = 2550;
    m_ScannerSettings.XExtentsRange.lMin               = 1;
    m_ScannerSettings.XExtentsRange.lStep              = 1;

    m_ScannerSettings.YExtentsRange.lMax               = 3507;
    m_ScannerSettings.YExtentsRange.lMin               = 1;
    m_ScannerSettings.YExtentsRange.lStep              = 1;

    m_ScannerSettings.XPosRange.lMax                   = 2549;
    m_ScannerSettings.XPosRange.lMin                   = 0;
    m_ScannerSettings.XPosRange.lStep                  = 1;

    m_ScannerSettings.YPosRange.lMax                   = 3506;
    m_ScannerSettings.YPosRange.lMin                   = 0;
    m_ScannerSettings.YPosRange.lStep                  = 1;

    m_ScannerSettings.CurrentXPos                      = 0;
    m_ScannerSettings.CurrentYPos                      = 0;
    m_ScannerSettings.CurrentXExtent                   = m_ScannerSettings.XExtentsRange.lMax;
    m_ScannerSettings.CurrentYExtent                   = m_ScannerSettings.YExtentsRange.lMax;

    m_ScannerSettings.BrightnessRange.lMax             = 127;
    m_ScannerSettings.BrightnessRange.lMin             = -127;
    m_ScannerSettings.BrightnessRange.lStep            = 1;

    m_ScannerSettings.ContrastRange.lMax               = 127;
    m_ScannerSettings.ContrastRange.lMin               = -127;
    m_ScannerSettings.ContrastRange.lStep              = 1;

    m_ScannerSettings.XSupportedResolutionsList        = NULL;
    m_ScannerSettings.YSupportedResolutionsList        = NULL;

    INT iNumValues = 4; // add 1 extra for header node
    m_ScannerSettings.SupportedDataTypesList  = (PLONG)LocalAlloc(LPTR,(sizeof(LONG) * iNumValues));
    if(m_ScannerSettings.SupportedDataTypesList){
        m_ScannerSettings.SupportedDataTypesList[0] = (iNumValues - 1);
        m_ScannerSettings.SupportedDataTypesList[1] = WIA_DATA_THRESHOLD;
        m_ScannerSettings.SupportedDataTypesList[2] = WIA_DATA_GRAYSCALE;
        m_ScannerSettings.SupportedDataTypesList[3] = WIA_DATA_COLOR;
    } else {
        m_ScannerSettings.SupportedDataTypesList = NULL;
    }
#endif

    Trace(TEXT(" -- m_ScannerSettings structure dump --"));
    Trace(TEXT("BUSType = %d"),m_ScannerSettings.BUSType);
    Trace(TEXT("bNegative = %d"),m_ScannerSettings.bNegative);
    Trace(TEXT("CurrentXResolution = %d"),m_ScannerSettings.CurrentXResolution);
    Trace(TEXT("CurrentYResolution = %d"),m_ScannerSettings.CurrentYResolution);
    Trace(TEXT("BedWidth = %d"),m_ScannerSettings.BedWidth);
    Trace(TEXT("BedHeight = %d"),m_ScannerSettings.BedHeight);
    Trace(TEXT("XOpticalResolution = %d"),m_ScannerSettings.XOpticalResolution);
    Trace(TEXT("YOpticalResolution = %d"),m_ScannerSettings.YOpticalResolution);
    Trace(TEXT("CurrentBrightness = %d"),m_ScannerSettings.CurrentBrightness);
    Trace(TEXT("CurrentContrast = %d"),m_ScannerSettings.CurrentContrast);
    Trace(TEXT("ADFSupport = %d"),m_ScannerSettings.ADFSupport);
    Trace(TEXT("TPASupport = %d"),m_ScannerSettings.TPASupport);
    Trace(TEXT("RawPixelPackingOrder = %d"),m_ScannerSettings.RawPixelPackingOrder);
    Trace(TEXT("RawPixelFormat = %d"),m_ScannerSettings.RawPixelFormat);
    Trace(TEXT("RawDataAlignment = %d"),m_ScannerSettings.RawDataAlignment);
    Trace(TEXT("FeederWidth = %d"),m_ScannerSettings.FeederWidth);
    Trace(TEXT("FeederHeight = %d"),m_ScannerSettings.FeederHeight);
    Trace(TEXT("VFeederJustification = %d"),m_ScannerSettings.VFeederJustification);
    Trace(TEXT("HFeederJustification = %d"),m_ScannerSettings.HFeederJustification);
    Trace(TEXT("MaxADFPageCapacity = %d"),m_ScannerSettings.MaxADFPageCapacity);
    Trace(TEXT("CurrentDataType = %d"),m_ScannerSettings.CurrentDataType );
    Trace(TEXT("CurrentBitDepth = %d"),m_ScannerSettings.CurrentBitDepth);
    Trace(TEXT("XSupportedResolutionsRange.lMax = %d"),m_ScannerSettings.XSupportedResolutionsRange.lMax);
    Trace(TEXT("XSupportedResolutionsRange.lMin = %d"),m_ScannerSettings.XSupportedResolutionsRange.lMin);
    Trace(TEXT("XSupportedResolutionsRange.lNom = %d"),m_ScannerSettings.XSupportedResolutionsRange.lNom);
    Trace(TEXT("XSupportedResolutionsRange.lStep = %d"),m_ScannerSettings.XSupportedResolutionsRange.lStep);
    Trace(TEXT("YSupportedResolutionsRange.lMax = %d"),m_ScannerSettings.YSupportedResolutionsRange.lMax);
    Trace(TEXT("YSupportedResolutionsRange.lMin = %d"),m_ScannerSettings.YSupportedResolutionsRange.lMin);
    Trace(TEXT("YSupportedResolutionsRange.lNom = %d"),m_ScannerSettings.YSupportedResolutionsRange.lNom);
    Trace(TEXT("YSupportedResolutionsRange.lStep = %d"),m_ScannerSettings.YSupportedResolutionsRange.lStep);
    Trace(TEXT("XExtentsRange.lMax = %d"),m_ScannerSettings.XExtentsRange.lMax);
    Trace(TEXT("XExtentsRange.lMin = %d"),m_ScannerSettings.XExtentsRange.lMin);
    Trace(TEXT("XExtentsRange.lNom = %d"),m_ScannerSettings.XExtentsRange.lNom);
    Trace(TEXT("XExtentsRange.lStep = %d"),m_ScannerSettings.XExtentsRange.lStep);
    Trace(TEXT("YExtentsRange.lMax = %d"),m_ScannerSettings.YExtentsRange.lMax);
    Trace(TEXT("YExtentsRange.lMin = %d"),m_ScannerSettings.YExtentsRange.lMin);
    Trace(TEXT("YExtentsRange.lNom = %d"),m_ScannerSettings.YExtentsRange.lNom);
    Trace(TEXT("YExtentsRange.lStep = %d"),m_ScannerSettings.YExtentsRange.lStep);
    Trace(TEXT("XPosRange.lMax = %d"),m_ScannerSettings.XPosRange.lMax);
    Trace(TEXT("XPosRange.lMin = %d"),m_ScannerSettings.XPosRange.lMin);
    Trace(TEXT("XPosRange.lNom = %d"),m_ScannerSettings.XPosRange.lNom);
    Trace(TEXT("XPosRange.lStep = %d"),m_ScannerSettings.XPosRange.lStep);
    Trace(TEXT("YPosRange.lMax = %d"),m_ScannerSettings.YPosRange.lMax);
    Trace(TEXT("YPosRange.lMin = %d"),m_ScannerSettings.YPosRange.lMin);
    Trace(TEXT("YPosRange.lNom = %d"),m_ScannerSettings.YPosRange.lNom);
    Trace(TEXT("YPosRange.lStep = %d"),m_ScannerSettings.YPosRange.lStep);
    Trace(TEXT("CurrentXPos = %d"),m_ScannerSettings.CurrentXPos);
    Trace(TEXT("CurrentYPos = %d"),m_ScannerSettings.CurrentYPos);
    Trace(TEXT("CurrentXExtent = %d"),m_ScannerSettings.CurrentXExtent);
    Trace(TEXT("CurrentYExtent = %d"),m_ScannerSettings.CurrentYExtent);
    Trace(TEXT("BrightnessRange.lMax = %d"),m_ScannerSettings.BrightnessRange.lMax);
    Trace(TEXT("BrightnessRange.lMin = %d"),m_ScannerSettings.BrightnessRange.lMin);
    Trace(TEXT("BrightnessRange.lNom = %d"),m_ScannerSettings.BrightnessRange.lNom);
    Trace(TEXT("BrightnessRange.lStep = %d"),m_ScannerSettings.BrightnessRange.lStep);
    Trace(TEXT("ContrastRange.lMax = %d"),m_ScannerSettings.ContrastRange.lMax);
    Trace(TEXT("ContrastRange.lMin = %d"),m_ScannerSettings.ContrastRange.lMin);
    Trace(TEXT("ContrastRange.lNom = %d"),m_ScannerSettings.ContrastRange.lNom);
    Trace(TEXT("ContrastRange.lStep = %d"),m_ScannerSettings.ContrastRange.lStep);
    Trace(TEXT("XSupportedResolutionsList = %x"),m_ScannerSettings.XSupportedResolutionsList);
    Trace(TEXT("YSupportedResolutionsList = %x"),m_ScannerSettings.YSupportedResolutionsList);

    if(m_ScannerSettings.XSupportedResolutionsList) {
        LONG lNumResolutions = m_ScannerSettings.XSupportedResolutionsList[0];
        Trace(TEXT("Number of Supported X Resolutions = %d"),lNumResolutions);
        for(LONG i = 1;i<=lNumResolutions;i++){
            Trace(TEXT("Supported Resolution #%d = %d"),i,m_ScannerSettings.XSupportedResolutionsList[i]);
        }
    }

    if(m_ScannerSettings.YSupportedResolutionsList) {
        LONG lNumResolutions = m_ScannerSettings.YSupportedResolutionsList[0];
        Trace(TEXT("Number of Supported Y Resolutions = %d"),lNumResolutions);
        for(LONG i = 1;i<=lNumResolutions;i++){
            Trace(TEXT("Supported Resolution #%d = %d"),i,m_ScannerSettings.YSupportedResolutionsList[i]);
        }
    }

    return hr;
}

HRESULT CIOBlock::ReadValue(LONG ValueID, PLONG plValue)
{
    HRESULT hr = S_OK;

    if(NULL == plValue){
        return E_INVALIDARG;
    }

    //
    // set returned long value to 0
    //

    *plValue = 0;

    //
    // initialize LastError Object to SUCCESS
    //

    m_pLastError->m_hr            = S_OK;

    //
    // set action ID
    //

    m_pDeviceAction->m_DeviceActionID         = 102; // make #define

    //
    // set value ID
    //

    m_pDeviceAction->m_DeviceValueID   = ValueID;

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // Give engine our DeviceScriptSite interface...
    //

    IActiveScript  *pActiveScript = NULL;
    hr = m_pActiveScript->Clone(&pActiveScript);

    if (SUCCEEDED(hr)) {
        Trace(TEXT("cloning script success"));
    } else {
        Trace(TEXT("cloning script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite on cloned script"));
    } else {
        Trace(TEXT("SetScriptSite on cloned script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // signal script event (DeviceActionEvent)
    //

    hr = m_pDeviceAction->Fire_DeviceActionEvent();
    if(SUCCEEDED(hr)){

        //
        // check for any script-returned errors
        //

        hr = m_pLastError->m_hr;
        if(SUCCEEDED(hr)){
            *plValue = m_pDeviceAction->m_lValue;
        }
    }
    return hr;
}

HRESULT CIOBlock::WriteValue(LONG ValueID, LONG lValue)
{
    HRESULT hr = S_OK;

    //
    // initialize LastError Object to SUCCESS
    //

    m_pLastError->m_hr            = S_OK;

    //
    // set action ID
    //

    m_pDeviceAction->m_DeviceActionID         = 101; // make #define

    //
    // set value ID
    //

    m_pDeviceAction->m_DeviceValueID   = ValueID;

    //
    // set value
    //

    m_pDeviceAction->m_lValue = lValue;

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // Give engine our DeviceScriptSite interface...
    //

    IActiveScript  *pActiveScript = NULL;
    hr = m_pActiveScript->Clone(&pActiveScript);

    if (SUCCEEDED(hr)) {
        Trace(TEXT("cloning script success"));
    } else {
        Trace(TEXT("cloning script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite on cloned script"));
    } else {
        Trace(TEXT("SetScriptSite on cloned script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // signal script event (DeviceActionEvent)
    //

    hr = m_pDeviceAction->Fire_DeviceActionEvent();
    if(SUCCEEDED(hr)){

        //
        // check for any script-returned errors
        //

        hr = m_pLastError->m_hr;
    }

    pActiveScript->Release();

    return hr;
}

HRESULT CIOBlock::InitializeProperties()
{
    HRESULT hr = S_OK;

    //
    // initialize LastError Object to SUCCESS
    //

    m_pLastError->m_hr            = S_OK;

    //
    // set action ID
    //

    m_pDeviceAction->m_DeviceActionID         = 100; // make #define

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // Give engine our DeviceScriptSite interface...
    //

    IActiveScript  *pActiveScript = NULL;
    hr = m_pActiveScript->Clone(&pActiveScript);

    if (SUCCEEDED(hr)) {
        Trace(TEXT("cloning script success"));
    } else {
        Trace(TEXT("cloning script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite on cloned script"));
    } else {
        Trace(TEXT("SetScriptSite on cloned script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // signal script event (DeviceActionEvent)
    //

    hr = m_pDeviceAction->Fire_DeviceActionEvent();
    if(SUCCEEDED(hr)){

        //
        // check for any script-returned errors
        //

        hr = m_pLastError->m_hr;
    }

    pActiveScript->Release();

    return hr;
}

HRESULT CIOBlock::Scan(LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived)
{
    m_pDeviceControl->m_pBuffer      = pBuffer;
    m_pDeviceControl->m_lBufferSize  = lLength;
    m_pDeviceControl->m_dwBytesRead = 0;

    HRESULT hr = S_OK;

    //
    // initialize LastError Object to SUCCESS
    //

    m_pLastError->m_hr            = S_OK;
    m_pDeviceAction->m_lValue     = lLength; // set data amount requested

    //
    // set action ID
    //

    switch(lPhase){
    case SCAN_FIRST:
        m_pDeviceAction->m_DeviceActionID         = 104; // make #define
        break;
    case SCAN_NEXT:
        m_pDeviceAction->m_DeviceActionID         = 105; // make #define
        break;
    case SCAN_FINISHED:
        m_pDeviceAction->m_DeviceActionID         = 106; // make #define
        break;
    default:
        break;
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // Give engine our DeviceScriptSite interface...
    //

    IActiveScript  *pActiveScript = NULL;
    hr = m_pActiveScript->Clone(&pActiveScript);

    if (SUCCEEDED(hr)) {
        Trace(TEXT("cloning script success"));
    } else {
        Trace(TEXT("cloning script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite on cloned script"));
    } else {
        Trace(TEXT("SetScriptSite on cloned script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // signal script event (DeviceActionEvent)
    //

    hr = m_pDeviceAction->Fire_DeviceActionEvent();
    if(SUCCEEDED(hr)){

        //
        // check for any script-returned errors
        //

        hr = m_pLastError->m_hr;
    }

    pActiveScript->Release();

    if(NULL != plReceived){
        *plReceived = m_pDeviceControl->m_dwBytesRead;
    }

    return hr;
}

BOOL CIOBlock::GetEventStatus(PGSD_EVENT_INFO pGSDEventInfo)
{

    //
    // ask script about device reporting an event...
    // if there is an event, fill out pGSDEventInfo structure
    // and return TRUE, letting WIAFBDRV know that an event has
    // occured....or return FALSE, that nothing has happened.
    //

    // Dispatch a GETEVENT_STATUS event action to script here.

    //
    // check returned status flag... if no event happened, return FALSE;
    // else..somthing did happen..so check the returned mapping key.
    //

    //
    // script will return a mapping key that corresponds to
    // the device event.
    //

    //
    // use key to look up correct GUID from the driver's reported supported
    // event list, set GUID, and continue to return TRUE
    //

    return FALSE;
}

BOOL CIOBlock::DeviceOnLine()
{

    //
    // ask script to check that the device is ON-LINE, and
    // funtional. Return TRUE, if it is, and FALSE if it is not.
    //

    // Dispatch a DEVICE_ONLINE event action to script here.

    return TRUE;
}

HRESULT CIOBlock::ResetDevice()
{
    HRESULT hr = S_OK;

    //
    // ask script to reset the device to a power-on state.
    // Return TRUE, if it succeeded, and FALSE if it did not.
    //

    // Dispatch a DEVICE_RESET event action to script here.

    return hr;
}

HRESULT CIOBlock::EventInterrupt(PGSD_EVENT_INFO pGSDEventInfo)
{
    BYTE  InterruptData = 0;
    DWORD dwIndex       = 0;
    DWORD dwError       = 0;
    BOOL  fLooping      = TRUE;
    BOOL  bRet          = TRUE;
    DWORD dwBytesRet    = 0;

    OVERLAPPED Overlapped;
    memset(&Overlapped,0,sizeof(OVERLAPPED));

    //
    // create an event to wait on
    //

    Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    HANDLE  hEventArray[2] = {pGSDEventInfo->hShutDownEvent, Overlapped.hEvent};
    HANDLE  InterruptHandle = m_ScannerSettings.DeviceIOHandles[0]; // <- SET INTERRUPT PIPE INDEX
                                                                    //    WITH REAL INDEX VALUE!!
    while (fLooping) {
        bRet = DeviceIoControl( InterruptHandle,
                                IOCTL_WAIT_ON_DEVICE_EVENT,
                                NULL,
                                0,
                                &InterruptData,
                                sizeof(InterruptData),
                                &dwError,
                                &Overlapped );

        if ( bRet || ( !bRet && ( ::GetLastError() == ERROR_IO_PENDING ))) {
            dwIndex = WaitForMultipleObjects( 2,
                                              hEventArray,
                                              FALSE,
                                              INFINITE );
            switch ( dwIndex ) {
                case WAIT_OBJECT_0+1:
                    bRet = GetOverlappedResult( InterruptHandle, &Overlapped, &dwBytesRet, FALSE );
                    if (dwBytesRet) {
                        // Change detected - signal
                        if (*pGSDEventInfo->phSignalEvent != INVALID_HANDLE_VALUE) {

                            //
                            // InterruptData contains result from device
                            // *pGSDEventInfo->pEventGUID needs to be set to
                            // the correct EVENT. (map event to result here??)
                            //

                            //
                            // ask script to report a mapping key that corresponds to
                            // the InterruptData returned information from device event.
                            //
                            // Dispatch a MAP_EVENT_RESULT_TO_KEY event action to script here.
                            //

                            //
                            // use key to look up correct GUID from the driver's reported supported
                            // event list, set GUID, and continue to set
                            // "SignalEvent" for service notification.
                            //

                            //
                            // signal service about the event
                            //

                            SetEvent(*pGSDEventInfo->phSignalEvent);
                        }
                        break;
                    }

                    //
                    // reset the overlapped event
                    //

                    ResetEvent( Overlapped.hEvent );
                    break;

                case WAIT_OBJECT_0:
                default:
                    fLooping = FALSE;
            }
        }
        else {
            dwError = ::GetLastError();
            break;
        }
    }
    return S_OK;
}

////////////////////////////////////////////////////////////
// helpers called internally, or wrapped by a script call //
////////////////////////////////////////////////////////////

LONG CIOBlock::InsertINTIntoByteBuffer(PBYTE szDest, PBYTE szSrc, BYTE cPlaceHolder, INT iValueToInsert)
{
    LONG lFinalStringSize = 0;
    INT iSrcIndex         = 0;
    INT iValueIndex       = 0;
    CHAR szValue[10];

    // clean value string, and convert INT to characters
    memset(szValue,0,sizeof(szValue));
    _itoa(iValueToInsert,szValue,10);

    while(szSrc[iSrcIndex] != '\0'){
        // check for place holder
        if (szSrc[iSrcIndex] != cPlaceHolder) {
            szDest[lFinalStringSize] = szSrc[iSrcIndex];
            iSrcIndex++;
            lFinalStringSize++; // increment size of buffer
        } else {
            // replace placeholder with integer value (in string format)
            iValueIndex = 0;
            while (szValue[iValueIndex] != '\0') {
                szDest[lFinalStringSize] = szValue[iValueIndex];
                iValueIndex++;
                lFinalStringSize++; // increment size of command buffer
            }
            iSrcIndex++;
        }
    }
    // terminate buffer with NULL character
    szDest[lFinalStringSize] = '\0';
    lFinalStringSize++;
    return lFinalStringSize;
}

LONG CIOBlock::ExtractINTFromByteBuffer(PINT iDest, PBYTE szSrc, BYTE cTerminatorByte, INT iOffset)
{
    *iDest = 0;
    BYTE szTempBuffer[25];
    INT iValueIndex = 0;
    memset(szTempBuffer,0,sizeof(szTempBuffer));

    while (szSrc[iOffset] != cTerminatorByte) {
        szTempBuffer[iValueIndex] = szSrc[iOffset];
        iValueIndex++;
        iOffset++;
    }
    iValueIndex++;
    szTempBuffer[iValueIndex] = '\0';

    *iDest = atoi((char*)szTempBuffer);
    return (LONG)*iDest;
}

VOID Trace(LPCTSTR format,...)
{

#ifdef DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devprop.h ===
// DeviceProperty.h : Declaration of the CDeviceProperty

#ifndef __DEVICEPROPERTY_H_
#define __DEVICEPROPERTY_H_

#include "resource.h"       // main symbols
#include "ioblockdefs.h"

/////////////////////////////////////////////////////////////////////////////
// CDeviceProperty
class ATL_NO_VTABLE CDeviceProperty :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeviceProperty, &CLSID_DeviceProperty>,
    public IDispatchImpl<IDeviceProperty, &IID_IDeviceProperty, &LIBID_WIAFBLib>,
    public IObjectSafetyImpl<CDeviceProperty, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:

    SCANSETTINGS *m_pScannerSettings;

    CDeviceProperty()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICEPROPERTY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceProperty)
    COM_INTERFACE_ENTRY(IDeviceProperty)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDeviceProperty
public:
    STDMETHOD(SetCurrentValue)(LONG lValueID, VARIANT Value);
    STDMETHOD(GetCurrentValue)(LONG lValueID, VARIANT *pvValue);
    STDMETHOD(SetValidRange)(LONG lValueID, LONG lMin, LONG lMax, LONG lNom, LONG lInc);
    STDMETHOD(SetValidList)(LONG lValueID, VARIANT Value);
    STDMETHOD(TestCall)();
};

#endif //__DEVICEPROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\devscriptsite.h ===
#include <windows.h>
#include <activscp.h>

class CDeviceScriptSite : public IActiveScriptSite {
private:
    ULONG m_dwRef;
public:
    IUnknown *m_pUnkScriptObject;
    ITypeInfo *m_pTypeInfo;

    IUnknown *m_pUnkScriptObjectDeviceAction;
    ITypeInfo *m_pTypeInfoDeviceAction;

    IUnknown *m_pUnkScriptObjectDeviceControl;
    ITypeInfo *m_pTypeInfoDeviceControl;

    IUnknown *m_pUnkScriptObjectLastError;
    ITypeInfo *m_pTypeInfoLastError;

    CDeviceScriptSite::CDeviceScriptSite() {
        m_pUnkScriptObject = 0;
        m_pTypeInfo = 0;

        m_pUnkScriptObjectDeviceAction = 0;
        m_pTypeInfoDeviceAction = 0;

        m_pUnkScriptObjectDeviceControl = 0;
        m_pTypeInfoDeviceControl = 0;

        m_pUnkScriptObjectLastError = 0;
        m_pTypeInfoLastError = 0;

        m_dwRef = 1;
    }

    // IUnknown methods...
    virtual HRESULT __stdcall QueryInterface(REFIID riid,
        void **ppvObject) {
        *ppvObject = NULL;
        return E_NOTIMPL;
    }
    virtual ULONG _stdcall AddRef(void) {
        return ++m_dwRef;
    }
    virtual ULONG _stdcall Release(void) {
        if(--m_dwRef == 0) return 0;
        return m_dwRef;
    }

    // IActiveScriptSite methods...
    virtual HRESULT __stdcall GetLCID(LCID *plcid) {
        return S_OK;
    }

    virtual HRESULT __stdcall GetItemInfo(LPCOLESTR pstrName,
        DWORD dwReturnMask, IUnknown **ppunkItem, ITypeInfo **ppti) {
        // Is it expecting an ITypeInfo?
        if(ppti) {
            // Default to NULL.
            *ppti = NULL;

            // See if asking about ITypeInfo...

            //
            // Note: This needs to be done in a more efficient
            //       way.
            //

            if(dwReturnMask & SCRIPTINFO_ITYPEINFO) {
                if (!_wcsicmp(L"DeviceProperty", pstrName)) {
                    *ppti = m_pTypeInfo;
                } else if (!_wcsicmp(L"DeviceAction", pstrName)) {
                    *ppti = m_pTypeInfoDeviceAction;
                } else if (!_wcsicmp(L"DeviceControl", pstrName)) {
                    *ppti = m_pTypeInfoDeviceControl;
                } else if (!_wcsicmp(L"LastError", pstrName)) {
                    *ppti = m_pTypeInfoLastError;
                }
            }
        }

        // Is the engine passing an IUnknown buffer?
        if(ppunkItem) {
            // Default to NULL.
            *ppunkItem = NULL;

            // Is Script Engine looking for an IUnknown for our object?

            //
            // Note: This needs to be done in a more efficient
            //       way.
            //

            if(dwReturnMask & SCRIPTINFO_IUNKNOWN) {
                if (!_wcsicmp(L"DeviceProperty", pstrName)) {
                    *ppunkItem = m_pUnkScriptObject;
                    m_pUnkScriptObject->AddRef();
                } else if (!_wcsicmp(L"DeviceAction", pstrName)) {
                    *ppunkItem = m_pUnkScriptObjectDeviceAction;
                    m_pUnkScriptObjectDeviceAction->AddRef();
                } else if (!_wcsicmp(L"DeviceControl", pstrName)) {
                    *ppunkItem = m_pUnkScriptObjectDeviceControl;
                    m_pUnkScriptObjectDeviceControl->AddRef();
                } else if (!_wcsicmp(L"LastError", pstrName)) {
                    *ppunkItem = m_pUnkScriptObjectLastError;
                    m_pUnkScriptObjectLastError->AddRef();
                }
            }
        }
        return S_OK;
    }

    virtual HRESULT __stdcall GetDocVersionString(BSTR *pbstrVersion) {
        return S_OK;
    }

    virtual HRESULT __stdcall OnScriptTerminate(
        const VARIANT *pvarResult, const EXCEPINFO *pexcepInfo) {
        return S_OK;
    }

    virtual HRESULT __stdcall OnStateChange(SCRIPTSTATE ssScriptState) {
        return S_OK;
    }

    virtual HRESULT __stdcall OnScriptError(
        IActiveScriptError *pscriptError) {
        BSTR bstrSourceLine;
        DWORD dwSourceContext = 0;
        ULONG ulLineNumber    = 0;
        LONG  lchPosition     = 0;
        HRESULT hr = S_OK;
        hr = pscriptError->GetSourceLineText(&bstrSourceLine);
        hr = pscriptError->GetSourcePosition(&dwSourceContext,&ulLineNumber,&lchPosition);

        TCHAR szErrorDescription[1024];
        memset(szErrorDescription,0,sizeof(szErrorDescription));
#ifdef UNICODE
        swprintf(szErrorDescription,TEXT("SOURCE: %ws\nLINE: %d\nCHARACTER POS: %d"),
                bstrSourceLine,
                ulLineNumber,
                lchPosition);
#else
        sprintf(szErrorDescription,TEXT("SOURCE: %ws\nLINE: %d\nCHARACTER POS: %d"),
                bstrSourceLine,
                ulLineNumber,
                lchPosition);
#endif

#ifdef DEBUG
        ::MessageBox(NULL, szErrorDescription, TEXT("WIA Driver Script Error"), MB_SETFOREGROUND);
#endif
        return S_OK;
    }

    virtual HRESULT __stdcall OnEnterScript(void) {
        return S_OK;
    }

    virtual HRESULT __stdcall OnLeaveScript(void) {
        return S_OK;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\ioblock.h ===
#ifndef __IOBLOCK
#define __IOBLOCK

#include "ioblockdefs.h"
#include "devscriptsite.h"
#include "devprop.h"
#include "devaction.h"
#include "devctrl.h"
#include "lasterr.h"

class CIOBlock {
public:
    CIOBlock();
    ~CIOBlock();

    void    Initialize(PGSD_INFO pGSDInfo);
    HRESULT DebugDumpScannerSettings();
    HRESULT StartScriptEngine();
    HRESULT StopScriptEngine();
    HRESULT LoadScript();
    HRESULT ProcessScript();
    HRESULT InitializeProperties();

    // operations
    HRESULT ReadValue(LONG ValueID, PLONG plValue);
    HRESULT WriteValue(LONG ValueID, LONG lValue);
    HRESULT Scan(LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived);
    BOOL    GetEventStatus(PGSD_EVENT_INFO pGSDEventInfo);
    BOOL    DeviceOnLine();
    HRESULT ResetDevice();
    HRESULT EventInterrupt(PGSD_EVENT_INFO pGSDEventInfo);

    SCANSETTINGS m_ScannerSettings; // scanner model settings
private:

    // helpers
    LONG InsertINTIntoByteBuffer(PBYTE szDest, PBYTE szSrc, BYTE cPlaceHolder, INT iValueToInsert);
    LONG ExtractINTFromByteBuffer(PINT iDest, PBYTE szSrc, BYTE cTerminatorByte, INT iOffset);

protected:
    TCHAR        m_szFileName[255]; // main product line file name

    CDeviceScriptSite           *m_pDeviceScriptSite;   // scripting site
    CComObject<CDeviceProperty> *m_pDeviceProperty;     // IDeviceProperty Interface
    CComObject<CDeviceAction>   *m_pDeviceAction;       // IDeviceAction Interface
    CComObject<CDeviceControl>  *m_pDeviceControl;      // IDeviceControl Interface
    CComObject<CLastError>      *m_pLastError;          // ILastError Interface
    IActiveScript               *m_pActiveScript;       // IActiveScript Interface
    IActiveScriptParse          *m_pActiveScriptParser; // IActiveScriptParse Interface
    WCHAR                       *m_wszScriptText;         // scriptlet
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\ioblockdefs.h ===
#ifndef __IOBLOCKDEFS
#define __IOBLOCKDEFS

#include "pch.h"

#define MAX_IO_HANDLES   16
#define DWORD_ALIGN      0
#define LEFT_JUSTIFIED   0
#define CENTERED         1
#define RIGHT_JUSTIFIED  2
#define TOP_JUSTIFIED    0
#define CENTERED         1
#define BOTTOM_JUSTIFIED 2

#define XRESOLUTION_ID   2
#define YRESOLUTION_ID   3
#define XPOS_ID          4
#define YPOS_ID          5
#define XEXT_ID          6
#define YEXT_ID          7
#define BRIGHTNESS_ID    8
#define CONTRAST_ID      9
#define DATA_TYPE_ID     10
#define BIT_DEPTH_ID     11
#define NEGATIVE_ID      12
#define PIXEL_PACKING_ID 13
#define PIXEL_FORMAT_ID  14
#define BED_WIDTH_ID     15
#define BED_HEIGHT_ID    16
#define XOPTICAL_ID      17
#define YOPTICAL_ID      18
#define ADF_ID           19
#define TPA_ID           20
#define ADF_WIDTH_ID     21
#define ADF_HEIGHT_ID    22
#define ADF_VJUSTIFY_ID  23
#define ADF_HJUSTIFY_ID  24
#define ADF_MAX_PAGES_ID 25
#define FIRMWARE_VER_ID  26
#define DATA_ALIGN_ID    27

typedef struct _GSD_EVENT_INFO {
    GUID *pEventGUID;       // pointer to the GUID of event that just occurred
    HANDLE hShutDownEvent;  // handle to the shutdown event (interrupt usage only)
    HANDLE *phSignalEvent;  // pointer to event handle to used to signal service (interrupt usage only)
} GSD_EVENT_INFO, *PGSD_EVENT_INFO;

typedef struct _GSD_INFO {
    LPTSTR szDeviceName;        // Device Name (Device Description from DeviceData section)
    LPTSTR szProductFileName;   // Product initialization script
    LPTSTR szFamilyFileName;    // Product family script
} GSD_INFO, *PGSD_INFO;

typedef struct _RANGEVALUEEX {
    LONG lMin;                  // minimum value
    LONG lMax;                  // maximum value
    LONG lNom;                  // nominal value
    LONG lStep;                 // increment/step value
} RANGEVALUEEX, *PRANGEVALUEEX;

typedef struct _SCANSETTINGS {
    HANDLE     DeviceIOHandles[MAX_IO_HANDLES]; // data pipes
    // string values
    TCHAR      Version[10];                 // GSD version
    TCHAR      DeviceName[255];             // Device Name ??(needed?)
    TCHAR      FirmwareVersion[10];         // firmware version
    // current values
    LONG       BUSType;                     // bus type ??(needed?)
    LONG       bNegative;                   // negative on/off
    LONG       CurrentXResolution;          // current x resolution setting
    LONG       CurrentYResolution;          // current y resolution setting
    LONG       BedWidth;                    // bed width (1/1000th inch)
    LONG       BedHeight;                   // bed height (1/1000th inch)
    LONG       FeederWidth;                 // feeder width (1/1000th inch)
    LONG       FeederHeight;                // feeder height (1/1000th inch)
    LONG       FeederJustification;         // feeder justification
    LONG       HFeederJustification;        // feeder horizontal justification
    LONG       VFeederJustification;        // feeder vertical justification
    LONG       MaxADFPageCapacity;          // max page capacity of feeder
    LONG       XOpticalResolution;          // optical x resolution
    LONG       YOpticalResolution;          // optical y resolution
    LONG       CurrentBrightness;           // current brightness setting
    LONG       CurrentContrast;             // current contrast setting
    LONG       CurrentDataType;             // current data type setting
    LONG       CurrentBitDepth;             // current bit depth setting
    LONG       CurrentXPos;                 // current x position setting
    LONG       CurrentYPos;                 // current u position setting
    LONG       CurrentXExtent;              // current x extent setting
    LONG       CurrentYExtent;              // current y extent setting
    LONG       ADFSupport;                  // ADF support TRUE/FALSE
    LONG       TPASupport;                  // TPA support TRUE/FALSE
    LONG       RawPixelPackingOrder;        // raw pixel packing order
    LONG       RawPixelFormat;              // raw pixel format
    LONG       RawDataAlignment;            // raw data alignment
    // Range values
    RANGEVALUEEX XSupportedResolutionsRange;  // valid values for x resolution
    RANGEVALUEEX YSupportedResolutionsRange;  // valid values for y resolution
    RANGEVALUEEX XExtentsRange;               // valid values for x extent
    RANGEVALUEEX YExtentsRange;               // valid values for y extent
    RANGEVALUEEX XPosRange;                   // valid values for x position
    RANGEVALUEEX YPosRange;                   // valid values for y position
    RANGEVALUEEX BrightnessRange;             // valid values for brightness
    RANGEVALUEEX ContrastRange;               // valid values for contrast
    // List values
    PLONG      XSupportedResolutionsList;   // valid values for x resolution (LIST)
    PLONG      YSupportedResolutionsList;   // valid values for y resolution (LIST)
    PLONG      SupportedDataTypesList;      // supported data types (LIST)

}SCANSETTINGS, *PSCANSETTIINGS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\lasterr.h ===
// LastError.h : Declaration of the CLastError

#ifndef __LASTERROR_H_
#define __LASTERROR_H_

#include "resource.h"       // main symbols
#include "ioblockdefs.h"

/////////////////////////////////////////////////////////////////////////////
// CLastError
class ATL_NO_VTABLE CLastError :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CLastError, &CLSID_LastError>,
    public IDispatchImpl<ILastError, &IID_ILastError, &LIBID_WIAFBLib>,
    public IObjectSafetyImpl<CLastError, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:

    SCANSETTINGS *m_pScannerSettings;
    HRESULT m_hr;

    CLastError()
    {
        m_hr = S_OK;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_LASTERROR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLastError)
    COM_INTERFACE_ENTRY(ILastError)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ILastError
public:
};

#endif //__LASTERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\pch.h ===
#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <sti.h>
#include <assert.h>
#include <windows.h>
#include <stierr.h>

#define INITGUID
#include "initguid.h"
#include <stiusd.h>

#pragma intrinsic(memcmp,memset)

#include "resource.h"
#include "wiamindr.h"
#include "wiaprop.h"
#include "wiamicro.h"

#include "cmicro.h"
#include "scanapi.h"
#include "wiafbdrv.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\lasterr.cpp ===
// lasterr.cpp : Implementation of CLastError
#include "pch.h"
#include "wiafb.h"
#include "lasterr.h"

/////////////////////////////////////////////////////////////////////////////
// CLastError
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IStiUSD methods.
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

#define THREAD_TERMINATION_TIMEOUT  10000
VOID EventThread( LPVOID  lpParameter ); // event thread

/**************************************************************************\
* CWIAScannerDevice::CWIAScannerDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

CWIAScannerDevice::CWIAScannerDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_fValid(FALSE),
    m_punkOuter(NULL),
    m_pIStiDevControl(NULL),
    m_bUsdLoadEvent(FALSE),
    m_dwLastOperationError(0),
    m_dwLockTimeout(100),
    m_hSignalEvent(NULL),
    m_hShutdownEvent(NULL),
    m_hEventNotifyThread(NULL),
    m_guidLastEvent(GUID_NULL),
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pIWiaEventCallback(NULL),
    m_pIDrvItemRoot(NULL),
    m_pStiDevice(NULL),
    m_hInstance(NULL),
    m_pIWiaLog(NULL),
    m_NumSupportedFormats(0),
    m_NumCapabilities(0),
    m_NumSupportedTYMED(0),
    m_NumInitialFormats(0),
    m_NumSupportedDataTypes(0),
    m_NumSupportedIntents(0),
    m_NumSupportedCompressionTypes(0),
    m_NumSupportedResolutions(0),
    m_pSupportedFormats(NULL),
    m_pInitialFormats(NULL),
    m_pCapabilities(NULL),
    m_pSupportedTYMED(NULL),
    m_pSupportedDataTypes(NULL),
    m_pSupportedIntents(NULL),
    m_pSupportedCompressionTypes(NULL),
    m_pSupportedResolutions(NULL),
    m_pSupportedPreviewModes(NULL),
    m_pszRootItemDefaults(NULL),
    m_piRootItemDefaults(NULL),
    m_pvRootItemDefaults(NULL),
    m_psRootItemDefaults(NULL),
    m_wpiRootItemDefaults(NULL),
    m_pszItemDefaults(NULL),
    m_piItemDefaults(NULL),
    m_pvItemDefaults(NULL),
    m_psItemDefaults(NULL),
    m_wpiItemDefaults(NULL),
    m_NumRootItemProperties(0),
    m_NumItemProperties(0),
    m_MaxBufferSize(65535),
    m_MinBufferSize(65535),
    m_bDeviceLocked(FALSE),
    m_DeviceDefaultDataHandle(NULL),
    m_bLegacyBWRestriction(FALSE),
    m_pszDeviceNameA(NULL),
    m_pScanAPI(NULL)
{

    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }

}

/**************************************************************************\
* CWIAScannerDevice::PrivateInitialize
*
*   Device class private initialization code
*
* Arguments:
*
*    None
*
* Return Value:
*
*    HRESULT
*
\**************************************************************************/
HRESULT CWIAScannerDevice::PrivateInitialize()
{
    HRESULT hr = S_OK;

#ifdef USE_SERVICE_LOG_CREATION
    hr = wiasCreateLogInstance(g_hInst, &m_pIWiaLog);
#else

    hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWiaLog,(void**)&m_pIWiaLog);

    if (SUCCEEDED(hr)) {
        m_pIWiaLog->InitializeLog((LONG)(LONG_PTR)g_hInst);
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Logging COM object created successfully for wiafbdrv.dll"));
    } else {
#ifdef DEBUG
        OutputDebugString(TEXT("Could not CoCreateInstance on Logging COM object for wiafbdrv.dll, because we are STI only\n"));
        OutputDebugString(TEXT("********* (Device must have been created for STI only) *********\n"));
#endif
    hr = S_OK;
    }

#endif

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_csShutdown, MINLONG)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::PrivateInitialize, create shutdown critsect failed"));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }

    if(hr == S_OK) {

        // Create event for syncronization of notifications shutdown.
        m_hShutdownEvent =  CreateEvent(NULL,FALSE,FALSE,NULL);

        if (m_hShutdownEvent && (INVALID_HANDLE_VALUE != m_hShutdownEvent)) {
            m_fValid = TRUE;
        } else {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::PrivateInitialize, create shutdown event failed"));
        }
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::~CWIAScannerDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

CWIAScannerDevice::~CWIAScannerDevice(void)
{

    if(m_pScanAPI)
        m_pScanAPI->UnInitialize();

    // Kill notification thread if it exists.
    SetNotificationHandle(NULL);

    // Close event for syncronization of notifications shutdown.
    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }

    // Release the device control interface.
    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }

    //
    // WIA member destruction
    //

    // Tear down the driver item tree.
    if (m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIAScannerDevice, Deleting Device Item Tree (this is OK)"));
        DeleteItemTree();
        m_pIDrvItemRoot = NULL;
    }

    // free any IO handles opened
    if(m_DeviceDefaultDataHandle){
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIAScannerDevice, Closing DefaultDeviceDataHandle"));
        CloseHandle(m_DeviceDefaultDataHandle);
        m_DeviceDefaultDataHandle = NULL;
    }

    // Cleanup the WIA event sink.
    if (m_pIWiaEventCallback) {
        m_pIWiaEventCallback->Release();
        m_pIWiaEventCallback = NULL;
    }

    // Free the storage for the device ID.
    if (m_bstrDeviceID) {
        SysFreeString(m_bstrDeviceID);
        m_bstrDeviceID = NULL;
    }

    // Release the objects supporting device property storage.
    if (m_bstrRootFullItemName) {
        SysFreeString(m_bstrRootFullItemName);
        m_bstrRootFullItemName = NULL;
    }

    // Delete allocated arrays
    DeleteCapabilitiesArrayContents();
    DeleteSupportedIntentsArrayContents();

    // Free the critical section.
    DeleteCriticalSection(&m_csShutdown);
    if(m_pIWiaLog)
        m_pIWiaLog->Release();

    if(m_pScanAPI)
        delete m_pScanAPI;
}

/**************************************************************************\
* CWIAScannerDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetCapabilities");
    memset(pUsdCaps, 0, sizeof(STI_USD_CAPS));
    pUsdCaps->dwVersion     = STI_VERSION;
    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT|
                              STI_GENCAP_NOTIFICATIONS |
                              STI_GENCAP_POLLING_NEEDED;
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetStatus");
    HRESULT hr = S_OK;

    // Validate parameters.
    if (!pDevStatus) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    // If we are asked, verify the device is online.
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, WIA is asking the device if we are ONLINE"));
        pDevStatus->dwOnlineState = 0L;
        hr = m_pScanAPI->DeviceOnline();
        if(SUCCEEDED(hr)){
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Device is ONLINE"));
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetStatus, Device is OFFLINE"));
        }
    }

    // If we are asked, verify state of event.
    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {

        // Generate an event the first time we load.
        if (m_bUsdLoadEvent) {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;
            m_guidLastEvent                  = guidEventFirstLoaded;
            m_bUsdLoadEvent                  = FALSE;
        }

        // check for device events
        hr = m_pScanAPI->GetDeviceEvent(&m_guidLastEvent);
        if(SUCCEEDED(hr)){
            if(m_guidLastEvent != GUID_NULL){
                pDevStatus->dwEventHandlingState |= STI_EVENTHANDLING_PENDING;
            }
        }
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::DeviceReset
*
*   Reset device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::DeviceReset(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::DeviceReset");

    return m_pScanAPI->ResetDevice();
}

/**************************************************************************\
* CWIAScannerDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Diagnostic");

    // Initialize response buffer
    memset(&pBuffer->sErrorInfo,0,sizeof(pBuffer->sErrorInfo));
    pBuffer->dwStatusMask = 0;
    pBuffer->sErrorInfo.dwGenericError  = NOERROR;
    pBuffer->sErrorInfo.dwVendorError   = 0;

    return m_pScanAPI->Diagnostic();
}

/**************************************************************************\
* CWIAScannerDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::SetNotificationHandle(HANDLE hEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SetNotificationHandle");
    HRESULT hr = STI_OK;

    EnterCriticalSection(&m_csShutdown);

    // Are we starting or stopping the notification thread?
    if (hEvent && (hEvent != INVALID_HANDLE_VALUE)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, hEvent = %d",hEvent));
        m_hSignalEvent  = hEvent;
        m_guidLastEvent = GUID_NULL;

        if (NULL == m_hEventNotifyThread) {
            DWORD dwThread = 0;
            m_hEventNotifyThread = ::CreateThread(NULL,
                                                  0,
                                                  (LPTHREAD_START_ROUTINE)EventThread,
                                                  (LPVOID)this,
                                                  0,
                                                  &dwThread);
            if (!m_hEventNotifyThread) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("FlatbedScannerUsdDevice::SetNotificationHandle, CreateThread failed"));
                hr = STIERR_UNSUPPORTED;
            }
        }
    } else {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Disabling event Notifications"));
        // Disable event notifications.
        if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
            if (!SetEvent(m_hShutdownEvent)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Setting Shutdown event failed.."));
            } else {

                //
                // WAIT for thread to terminate, only if the m_hEventNotifyThread is not NULL
                //

                if (NULL != m_hEventNotifyThread) {
                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Waiting for Event Thread to terminate (%d ms timeout)",THREAD_TERMINATION_TIMEOUT));
                    DWORD dwResult = WaitForSingleObject(m_hEventNotifyThread,THREAD_TERMINATION_TIMEOUT);
                    switch (dwResult) {
                    case WAIT_TIMEOUT:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread termination TIMED OUT!"));
                        break;
                    case WAIT_OBJECT_0:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, We are signaled...YAY!"));
                        break;
                    case WAIT_ABANDONED:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread was abandoned.."));
                        break;
                    default:
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Unknown signal (%d) received from WaitForSingleObject() call",dwResult));
                        break;
                    }
                }

                //
                // Close event for syncronization of notifications shutdown.
                //

                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Closing m_hShutdownEvent handle (it has been signaled)"));
                CloseHandle(m_hShutdownEvent);
                m_hShutdownEvent = NULL;
            }
        }

        //
        // terminate thread
        //

        if (NULL != m_hEventNotifyThread) {
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, closing event Notifications thread handle"));
            CloseHandle(m_hEventNotifyThread);
            m_hEventNotifyThread = NULL;
        }

        m_guidLastEvent      = GUID_NULL;
    }

    LeaveCriticalSection(&m_csShutdown);
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::GetNotificationData
*
*   Provides data on an event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetNotificationData");
    // If we have notification ready - return it's guid
    if (!IsEqualIID(m_guidLastEvent, GUID_NULL)) {
        memset(&pBuffer->abNotificationData,0,sizeof(pBuffer->abNotificationData));
        pBuffer->dwSize               = sizeof(STINOTIFY);
        pBuffer->guidNotificationCode = m_guidLastEvent;
        m_guidLastEvent               = GUID_NULL;
    } else {
        return STIERR_NOEVENTS;
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Escape");

    // Write command to device if needed.
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetLastError");

    if (IsBadWritePtr(pdwLastDeviceError, sizeof(DWORD))) {
        return STIERR_INVALID_PARAM;
    }

    *pdwLastDeviceError = m_dwLastOperationError;
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetLastErrorInfo");

    if (IsBadWritePtr(pLastErrorInfo, sizeof(STI_ERROR_INFO))) {
        return STIERR_INVALID_PARAM;
    }

    pLastErrorInfo->dwGenericError          = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0]  = '\0';

    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::LockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::LockDevice");
    HRESULT hr = STI_OK;
    if(m_bDeviceLocked){
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("LockDevice, Device is already locked!!"));
        hr = STIERR_DEVICE_LOCKED;
    } else {
        m_bDeviceLocked = TRUE;
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("LockDevice, Locking Device successful"));
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::UnLockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::UnLockDevice");
    HRESULT hr = STI_OK;
    if(!m_bDeviceLocked)
        hr = STIERR_NEEDS_LOCK;
    else {
        m_bDeviceLocked = FALSE;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    lpdwNumberOfBytes  - number of bytes to read/returned
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawReadData");
    HRESULT hr = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDefaultDataHandle) {
        fRet = ReadFile( m_DeviceDefaultDataHandle,
                         lpBuffer,
                         *lpdwNumberOfBytes,
                         &dwBytesReturned,
                         lpOverlapped );

        m_dwLastOperationError = ::GetLastError();
        hr = fRet ? STI_OK : HRESULT_FROM_WIN32(m_dwLastOperationError);

        *lpdwNumberOfBytes = (fRet) ? dwBytesReturned : 0;
    } else {
        hr = STIERR_NOT_INITIALIZED;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    dwNumberOfBytes    - number of bytes to write
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawWriteData");
    HRESULT hr   = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDefaultDataHandle) {
        fRet = WriteFile(m_DeviceDefaultDataHandle,lpBuffer,dwNumberOfBytes,&dwBytesReturned,lpOverlapped);
        m_dwLastOperationError = ::GetLastError();
        hr = fRet ? STI_OK : HRESULT_FROM_WIN32(m_dwLastOperationError);
    } else {
        hr = STIERR_NOT_INITIALIZED;
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::RawReadCommand
*
*
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    lpdwNumberOfBytes  - number of bytes to read/returned
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawReadCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::RawWriteCommand
*
*
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    nNumberOfBytes     - number of bytes to write
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawWriteCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    - device interface
*    dwStiVersion           - STI version
*    hParametersKey         - HKEY for registry reading/writing
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Initialize");

    HRESULT hr = STI_OK;
    WCHAR szDeviceNameW[255];
    TCHAR szGSDName[255];
    TCHAR szMICRO[255];
    TCHAR szResolutions[255];
    UINT uiNameLen = 0;
    INITINFO InitInfo;

    memset(&InitInfo,0,sizeof(InitInfo));

    if (!pIStiDevControl) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    // Cache the device control interface.
    m_pIStiDevControl = pIStiDevControl;
    m_pIStiDevControl->AddRef();

    //
    // Get the name of the device port
    //

    hr = m_pIStiDevControl->GetMyDevicePortName(szDeviceNameW,sizeof(szDeviceNameW)/sizeof(WCHAR));
    if (!SUCCEEDED(hr) || !*szDeviceNameW) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, couldn't get device port"));
        return hr;
    }

    uiNameLen = WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, NULL, NULL, 0, 0);
    if (!uiNameLen) {
        return STIERR_INVALID_PARAM;
    }

    m_pszDeviceNameA = new CHAR[uiNameLen+1];
    if (!m_pszDeviceNameA) {
        return STIERR_INVALID_PARAM;
    }

    WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, m_pszDeviceNameA, uiNameLen, 0, 0);

    //
    // Open kernel mode device driver.
    //

    m_DeviceDefaultDataHandle = CreateFileA(m_pszDeviceNameA,
                                     GENERIC_READ | GENERIC_WRITE, // Access mask
                                     0,                            // Share mode
                                     NULL,                         // SA
                                     OPEN_EXISTING,                // Create disposition
                                     FILE_ATTRIBUTE_SYSTEM,        // Attributes
                                     NULL );

    m_dwLastOperationError = ::GetLastError();

    hr = (m_DeviceDefaultDataHandle != INVALID_HANDLE_VALUE) ?
                S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,m_dwLastOperationError);

    if (FAILED(hr)) {
        return hr;
    }

    InitInfo.hDeviceDataHandle = m_DeviceDefaultDataHandle;
    InitInfo.szCreateFileName  = m_pszDeviceNameA;

    //
    // Open DeviceData section to read driver specific information
    //

    HKEY hKey = hParametersKey;
    HKEY hOpenKey = NULL;
    if (RegOpenKeyEx(hKey,                     // handle to open key
                     TEXT("DeviceData"),       // address of name of subkey to open
                     0,                        // options (must be NULL)
                     KEY_QUERY_VALUE|KEY_READ, // just want to QUERY a value
                     &hOpenKey                 // address of handle to open key
                    ) == ERROR_SUCCESS) {

        DWORD dwWritten = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        /////////////////////////////////////////////////////////////////////////////
        // legacy MicroDriver registry entries, for BW scanners                    //
        /////////////////////////////////////////////////////////////////////////////

        LONG lNoColor = 0;
        RegQueryValueEx(hOpenKey,
                        TEXT("NoColor"),
                        NULL,
                        &dwType,
                        (LPBYTE)&lNoColor,
                        &dwWritten);
        if (lNoColor == 1) {
            m_bLegacyBWRestriction = TRUE;
        }

        /////////////////////////////////////////////////////////////////////////////
        // Micro driver registry entries, for ***mcro.dll loading                  //
        /////////////////////////////////////////////////////////////////////////////

        dwWritten = sizeof(szMICRO);
        dwType = REG_SZ;
        ZeroMemory(szMICRO,sizeof(szMICRO));

        //
        // Read Micro driver name
        //

        if (RegQueryValueEx(hOpenKey,
                            TEXT("MicroDriver"),
                            NULL,
                            &dwType,
                            (LPBYTE)szMICRO,
                            &dwWritten) == ERROR_SUCCESS) {

            m_pScanAPI = new CMicroDriverAPI;
            InitInfo.szModuleFileName  = szMICRO;
        }

        /////////////////////////////////////////////////////////////////////////////
        // resolution registry entries, for micro driver resolution restrictions   //
        /////////////////////////////////////////////////////////////////////////////

        dwWritten = sizeof(szResolutions);
        dwType = REG_SZ;
        ZeroMemory(szGSDName,sizeof(szResolutions));

        if (RegQueryValueEx(hOpenKey,
                            TEXT("Resolutions"),
                            NULL,
                            &dwType,
                            (LPBYTE)szResolutions,
                            &dwWritten) == ERROR_SUCCESS) {
            if(m_pScanAPI){
                m_pScanAPI->SetResolutionRestrictionString(szResolutions);
            }
        }

        RegCloseKey(hOpenKey);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, couldn't open DeviceData KEY"));
        return E_FAIL;
    }

    //
    // give logging interface to SCANAPI object
    // so it can log too! (shouldn't leave the little guys out. ;) )
    //

    m_pScanAPI->SetLoggingInterface(m_pIWiaLog);

    // set the HKEY for micro driver's device section
    InitInfo.hKEY = hParametersKey;

    // initialize the micro driver
    hr = m_pScanAPI->Initialize(&InitInfo);

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::DoEventProcessing
*
*   Process device events
*
* Arguments:
*
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DoEventProcessing()
{
    HRESULT hr = S_OK;

    INTERRUPTEVENTINFO EventInfo;

    EventInfo.phSignalEvent  = &m_hSignalEvent;
    EventInfo.hShutdownEvent = m_hShutdownEvent;
    EventInfo.pguidEvent     = &m_guidLastEvent;
    EventInfo.szDeviceName   = m_pszDeviceNameA;

    hr = m_pScanAPI->DoInterruptEventThread(&EventInfo);

    // close the thread handle, when the thread exits
    CloseHandle(m_hEventNotifyThread);
    m_hEventNotifyThread = NULL;
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// THREADS SECTION                                                                    //
////////////////////////////////////////////////////////////////////////////////////////

VOID EventThread( LPVOID  lpParameter )
{
    PWIASCANNERDEVICE pThisDevice = (PWIASCANNERDEVICE)lpParameter;
    pThisDevice->DoEventProcessing();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiafbdrv.rc
//

// Device Events, and Commands (Name strings)
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_CMD_SYNCRONIZE_NAME            104
#define IDS_CMD_DELETE_ALL_ITEMS_NAME      105
#define IDS_CMD_DELETE_DEVICE_TREE_NAME    106
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     107

// Device Events, and Commands (Description strings)
#define IDS_EVENT_DEVICE_CONNECTED_DESC    108
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 109
#define IDS_CMD_SYNCRONIZE_DESC            110
#define IDS_CMD_DELETE_ALL_ITEMS_DESC      111
#define IDS_CMD_DELETE_DEVICE_TREE_DESC    112
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     113

#define IDS_FULLROOTITEM_NAME              114
#define IDS_ROOTITEM_NAME                  115
#define IDS_FULLTOPITEM_NAME               116
#define IDS_TOPITEM_NAME                   117

#define IDR_DEVICEPROPERTY                 118
#define IDR_DEVICEACTION                   119
#define IDR_DEVICECONTROL                  120
#define IDR_LASTERROR                      121

#define IDS_DEFAULT_EVENT_NAME             122

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        123
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           123
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\scanapi.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       scanapi.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#include "pch.h"

#ifdef UNICODE
    #define TSTRSTR wcsstr
    #define TSSCANF swscanf
#else
    #define TSTRSTR strstr
    #define TSSCANF sscanf
#endif

#define MAX_CAPABILITIES 65535

extern HINSTANCE g_hInst;

////////////////////////////////////////////////////////////////////////////////
// MICRO DRIVER SYSTEM SUPPORT                                                //
////////////////////////////////////////////////////////////////////////////////
CMicroDriverAPI::CMicroDriverAPI()
{
    // wipe supported resolutions string
    memset(m_szResolutions,0,sizeof(m_szResolutions));
    // wipe scaninfo structure
    memset(&m_ScanInfo,0,sizeof(m_ScanInfo));
    m_bDisconnected = FALSE;
}

CMicroDriverAPI::~CMicroDriverAPI()
{

    //
    // close any open Device Data handles left open by Micro Driver
    // skip index 0 because WIAFBDRV owns that handle..
    //

    for(int i = 1; i < MAX_IO_HANDLES ; i++){
        if((NULL != m_ScanInfo.DeviceIOHandles[i]) && (INVALID_HANDLE_VALUE != m_ScanInfo.DeviceIOHandles[i])){
            CloseHandle(m_ScanInfo.DeviceIOHandles[i]);
            m_ScanInfo.DeviceIOHandles[i] = NULL;
        }
    }

    if(m_pMicroDriver){
        delete m_pMicroDriver;
        m_pMicroDriver = NULL;
    }
}

//
// data acquisition functions
//

HRESULT CMicroDriverAPI::Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::Scan");

    HRESULT hr = S_OK;
    LONG lLine = SCAN_FIRST;

    switch (lState) {
    case SCAN_START:
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, SCAN_START"));
        lLine = SCAN_FIRST;
        break;
    case SCAN_CONTINUE:
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, SCAN_CONTINUE"));
        lLine = SCAN_NEXT;
        break;
    case SCAN_END:
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, SCAN_END"));
        lLine = SCAN_FINISHED;
    default:
        break;
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, Requesting %d bytes from caller",dwBytesToRead));
    hr = m_pMicroDriver->Scan(&m_ScanInfo,lLine,pData,dwBytesToRead,(LONG*)pdwBytesWritten);
    if(pdwBytesWritten){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, Returning  %d bytes to caller",*pdwBytesWritten));
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, Returning  0 bytes to caller"));
    }

    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CMicroDriverAPI::Scan, Failed to Acquire data"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, Data Pointer = %x",pData));
    }

    //
    // handle device disconnection error
    //

    if(m_bDisconnected){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Scan, Device was disconnected, returning WIA_ERROR_OFFLINE to caller"));
        return WIA_ERROR_OFFLINE;
    }
    return hr;
}

HRESULT CMicroDriverAPI::SetDataType(LONG lDataType)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetDataType");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;

    Val.lVal = lDataType;
    hr = m_pMicroDriver->MicroEntry(CMD_SETDATATYPE, &Val);

    return hr;
}

HRESULT CMicroDriverAPI::SetXYResolution(LONG lXResolution, LONG lYResolution)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetXYResolution");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;

    Val.lVal = lXResolution;
    hr = m_pMicroDriver->MicroEntry(CMD_SETXRESOLUTION, &Val);
    if (FAILED(hr))
        return hr;

    Val.lVal = lYResolution;
    hr = m_pMicroDriver->MicroEntry(CMD_SETYRESOLUTION, &Val);

    return hr;
}

HRESULT CMicroDriverAPI::SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetSelectionArea");

    HRESULT hr = S_OK;
    hr = m_pMicroDriver->SetPixelWindow(&m_ScanInfo,lXPos,lYPos,lXExt,lYExt);
    return hr;
}

HRESULT CMicroDriverAPI::SetContrast(LONG lContrast)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetContrast");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;

    Val.lVal = lContrast;
    hr = m_pMicroDriver->MicroEntry(CMD_SETCONTRAST, &Val);

    return hr;
}

HRESULT CMicroDriverAPI::SetIntensity(LONG lIntensity)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetIntensity");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;

    Val.lVal = lIntensity;
    hr = m_pMicroDriver->MicroEntry(CMD_SETINTENSITY, &Val);

    return hr;
}

HRESULT CMicroDriverAPI::DisableDevice()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::DisableDevice");

    HRESULT hr = S_OK;
    m_bDisconnected = TRUE;
    return hr;
}

HRESULT CMicroDriverAPI::EnableDevice()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::EnableDevice");

    HRESULT hr = S_OK;
    m_bDisconnected = FALSE;
    return hr;
}

HRESULT CMicroDriverAPI::DeviceOnline()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::DeviceOnline");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    hr = m_pMicroDriver->MicroEntry(CMD_STI_GETSTATUS,&Val);
    if (SUCCEEDED(hr)) {
        if (Val.lVal != 1)
            hr = E_FAIL;
    }
    return hr;
}

HRESULT CMicroDriverAPI::GetDeviceEvent(GUID *pEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::GetDeviceEvent");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    *pEvent = GUID_NULL;
    hr = m_pMicroDriver->MicroEntry(CMD_STI_GETSTATUS,&Val);
    if (SUCCEEDED(hr)) {
        if (Val.pGuid != NULL)
            *pEvent = *Val.pGuid;
        else
            *pEvent = GUID_NULL;
    }
    return hr;
}

HRESULT CMicroDriverAPI::DoInterruptEventThread(PINTERRUPTEVENTINFO pEventInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::DoInterruptEventThread");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pHandle   = pEventInfo->phSignalEvent;
    Val.handle    = pEventInfo->hShutdownEvent;
    Val.pGuid     = pEventInfo->pguidEvent;
    Val.pScanInfo = &m_ScanInfo;
    lstrcpyA(Val.szVal,pEventInfo->szDeviceName);

    hr = m_pMicroDriver->MicroEntry(CMD_GET_INTERRUPT_EVENT,&Val);
    return hr;
}

HRESULT CMicroDriverAPI::Diagnostic()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::Diagnostic");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    hr = m_pMicroDriver->MicroEntry(CMD_STI_DIAGNOSTIC,&Val);

    return hr;
}

HRESULT CMicroDriverAPI::Initialize(PINITINFO pInitInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::Initialize");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));

    m_pMicroDriver = NULL;
    m_pMicroDriver = new CMICRO(pInitInfo->szModuleFileName);
    if (NULL != m_pMicroDriver) {

        // set DeviceIOHandles
        m_ScanInfo.DeviceIOHandles[0] = pInitInfo->hDeviceDataHandle;
        // send HKEY
        hr = SetSTIDeviceHKEY(&pInitInfo->hKEY);
        // send Initialize call
        Val.pScanInfo  = &m_ScanInfo;
        lstrcpyA(Val.szVal,pInitInfo->szCreateFileName);
        hr = m_pMicroDriver->MicroEntry(CMD_INITIALIZE,&Val);
        if(hr == S_OK){

            //
            // perform a quick validation sweep, to make sure we didn't get bad values
            // from a micro driver
            //

            //
            // check current values, for strange negative values...or 0
            //

            if(m_ScanInfo.BedHeight <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.BedWidth <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.Xresolution <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.Yresolution <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.OpticalXResolution <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.OpticalYResolution <= 0){
                hr = E_INVALIDARG;
            }

            if(SUCCEEDED(hr)){

                //
                // check logical values
                //

            }
        }
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}

HRESULT CMicroDriverAPI::UnInitialize()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::UnInitialize");
    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    // send UnInitialize call
    Val.pScanInfo  = &m_ScanInfo;
    hr = m_pMicroDriver->MicroEntry(CMD_UNINITIALIZE,&Val);
    if(E_NOTIMPL == hr){
        hr = S_OK;
    }
    return hr;
}

//
// standard device operations
//

HRESULT CMicroDriverAPI::ResetDevice()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ResetDevice");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    hr = m_pMicroDriver->MicroEntry(CMD_STI_DEVICERESET,&Val);

    return hr;
}
HRESULT CMicroDriverAPI::SetEmulationMode(LONG lDeviceMode)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetEmulationMode");

    HRESULT hr = S_OK;
    return hr;
}

//
// Automatic document feeder functions
//

HRESULT CMicroDriverAPI::ADFAttached()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFAttached");

    if(m_ScanInfo.ADF == 1)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CMicroDriverAPI::ADFHasPaper()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFHasPaper");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_GETADFHASPAPER,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    if(MicroDriverErrorToWIAError(Val.lVal) == WIA_ERROR_PAPER_EMPTY){
        hr = S_FALSE;
    }
    return hr;
}

HRESULT CMicroDriverAPI::ADFAvailable()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFAvailable");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_GETADFAVAILABLE,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return MicroDriverErrorToWIAError(Val.lVal);
}

HRESULT CMicroDriverAPI::ADFFeedPage()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFFeedPage");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_LOAD_ADF,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return MicroDriverErrorToWIAError(Val.lVal);
}

HRESULT CMicroDriverAPI::ADFUnFeedPage()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFUnFeedPage");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_UNLOAD_ADF,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return MicroDriverErrorToWIAError(Val.lVal);
}

HRESULT CMicroDriverAPI::ADFStatus()
{
    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_GETADFSTATUS,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return MicroDriverErrorToWIAError(Val.lVal);
}

HRESULT CMicroDriverAPI::SetFormat(GUID *pguidFormat)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetFormat");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.pGuid = pguidFormat;

    hr = m_pMicroDriver->MicroEntry(CMD_SETFORMAT,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return hr;
}

HRESULT CMicroDriverAPI::MicroDriverErrorToWIAError(LONG lMicroDriverError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::MicroDriverErrorToWIAError");

    HRESULT hr = E_FAIL;
    switch(lMicroDriverError){
    case MCRO_STATUS_OK:
        hr =  S_OK;
        break;
    case MCRO_ERROR_USER_INTERVENTION:
        hr =  WIA_ERROR_USER_INTERVENTION;
        break;
    case MCRO_ERROR_PAPER_JAM:
        hr =  WIA_ERROR_PAPER_JAM;
        break;
    case MCRO_ERROR_PAPER_PROBLEM:
        hr =  WIA_ERROR_PAPER_PROBLEM;
        break;
    case MCRO_ERROR_OFFLINE:
        hr =  WIA_ERROR_OFFLINE;
        break;
    case MCRO_ERROR_GENERAL_ERROR:
        hr =  WIA_ERROR_GENERAL_ERROR;
        break;
    case MCRO_ERROR_PAPER_EMPTY:
        hr =  WIA_ERROR_PAPER_EMPTY;
        break;
    default:
        break;
    }
    return hr;
}

//
// EXPECTED FORMAT:
// Range: "MIN 75,MAX 1200,NOM 150,INC 1"
// list:  "75, 100, 150, 200, 600, 1200"
//

BOOL CMicroDriverAPI::IsValidRestriction(LONG **ppList, LONG *plNumItems, RANGEVALUEEX *pRangeValues)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::IsValidRestriction");

    // set list pointer to null
    *ppList       = NULL;
    LONG *pList   = NULL;

    // set number of items to zero
    LONG lNumItems = 0;
    *plNumItems   = 0;

    // set range stucture to zeros
    pRangeValues->lMax  = 0;
    pRangeValues->lMin  = 0;
    pRangeValues->lNom  = 0;
    pRangeValues->lStep = 0;

    // string size check
    if(lstrlen(m_szResolutions) <= 0)
        return FALSE;

    // valid range or list check
    TCHAR *psz = NULL;

    CHAR szTemp[20];

    // valid range?
    INT iErrorCode = EOF;

    BOOL bValidRange = FALSE;
    psz = TSTRSTR(m_szResolutions,TEXT("MIN"));
    if (psz) {
        psz = TSTRSTR(psz,TEXT(" "));
        if (psz) {
            iErrorCode = TSSCANF(psz,TEXT("%d"),&pRangeValues->lMin);
            psz = NULL;
            psz = TSTRSTR(m_szResolutions,TEXT("MAX"));
            if ((psz)&&(iErrorCode != 0)&&(iErrorCode != EOF)) {
                psz = TSTRSTR(psz,TEXT(" "));
                if (psz) {
                    iErrorCode = TSSCANF(psz,TEXT("%d"),&pRangeValues->lMax);
                    psz = NULL;
                    psz = TSTRSTR(m_szResolutions,TEXT("NOM"));
                    if ((psz)&&(iErrorCode != 0)&&(iErrorCode != EOF)) {
                        psz = TSTRSTR(psz,TEXT(" "));
                        if (psz) {
                            iErrorCode = TSSCANF(psz,TEXT("%d"),&pRangeValues->lNom);
                            psz = NULL;
                            psz = TSTRSTR(m_szResolutions,TEXT("INC"));
                            if ((psz)&&(iErrorCode != 0)&&(iErrorCode != EOF)) {
                                psz = TSTRSTR(psz,TEXT(" "));
                                if (psz) {
                                    iErrorCode = TSSCANF(psz,TEXT("%d"),&pRangeValues->lStep);
                                    if ((iErrorCode != 0)&&(iErrorCode != EOF)) {
                                        bValidRange = TRUE;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // check that range values are valid (to the definition of a RANGE)
        if (bValidRange) {
            if (pRangeValues->lMin > pRangeValues->lMax)
                return FALSE;
            if (pRangeValues->lNom > pRangeValues->lMax)
                return FALSE;
            if (pRangeValues->lStep > pRangeValues->lMax)
                return FALSE;
            if (pRangeValues->lNom < pRangeValues->lMin)
                return FALSE;
        }
    }

    if(!bValidRange){

        // set range stucture to zeros (invalid range settings)
        pRangeValues->lMax  = 0;
        pRangeValues->lMin  = 0;
        pRangeValues->lNom  = 0;
        pRangeValues->lStep = 0;

        LONG lTempResArray[255];
        memset(lTempResArray,0,sizeof(lTempResArray));
        // not valid range?..what about a valid list?

        // valid list?

        psz = m_szResolutions;
        while(psz){

            // save value if one is found
            if(psz){
                iErrorCode = TSSCANF(psz,TEXT("%d"),&lTempResArray[lNumItems]);
                if((iErrorCode == EOF)||(iErrorCode == 0)) {
                    // could not extract a value, assume invalid Resolution
                    // was found.
                    lNumItems = 0;
                    break;
                }
                if(lTempResArray[lNumItems] <= 0){
                    // quit list iteration.. an invalid Resolution was found
                    lNumItems = 0;
                    break;
                }
                lNumItems++;
            }

            // seek to next value
            psz = TSTRSTR(psz,TEXT(","));
            if(psz) {
                // move past ',' marker
                psz++;
            }
        }

        if (lNumItems > 0) {
            // create list, and send it back to caller
            pList = new LONG[lNumItems];
            if (!pList)
                return FALSE;

            for (LONG i = 0; i < lNumItems ; i++) {
                pList[i] = lTempResArray[i];
            }

            *plNumItems = lNumItems;
            *ppList     = pList;
        } else {
            return FALSE;
        }
    }

    return TRUE;
}

//
// button
//

HRESULT CMicroDriverAPI::QueryButtonPanel(PDEVICE_BUTTON_INFO pButtonInformation)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CMicroDriverAPI::BuildCapabilities(PWIACAPABILITIES pCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::BuildCapabilities");

    //
    // validate incoming parameters, and return E_INVALIDARG as needed
    //

    if (!pCaps) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    WCHAR **ppszButtonNames = NULL;

    hr = m_pMicroDriver->MicroEntry(CMD_GETCAPABILITIES,&Val);
    if (SUCCEEDED(hr)) {

        //
        // if this API is called with pCaps->pCapabilities == NULL, then return the
        // total number of additional events.
        //

        if (NULL == pCaps->pCapabilities) {
            if ((Val.lVal >= 0) && (Val.lVal < MAX_CAPABILITIES)) {
                *pCaps->pNumSupportedEvents = Val.lVal;
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildCapabilities, Additional Supported Events from MicroDriver = %d",Val.lVal));
            } else {
                hr = E_INVALIDARG;
            }

        } else {

            //
            // populate the capabilities array with names and descriptions
            //

            for (LONG index = 0; index < Val.lVal; index++) {

                ppszButtonNames = Val.ppButtonNames;

                //
                // allocate capability memory, for names, and descriptions
                //

                //
                // calculate size in BYTES for maximium string value
                // allowed by a capability
                //

                LONG lMaxCapabilityString = (MAX_PATH * sizeof(WCHAR));
                pCaps->pCapabilities[index].wszName = (LPOLESTR)CoTaskMemAlloc(lMaxCapabilityString);
                pCaps->pCapabilities[index].wszDescription = (LPOLESTR)CoTaskMemAlloc(lMaxCapabilityString);

                if ((pCaps->pCapabilities[index].wszDescription)&&
                    (pCaps->pCapabilities[index].wszName)) {

                    pCaps->pCapabilities[index].wszName[(lMaxCapabilityString/sizeof(WCHAR)) - 1] = L'\0';
                    pCaps->pCapabilities[index].wszDescription[(lMaxCapabilityString/sizeof(WCHAR)) - 1] = L'\0';

                    if (ppszButtonNames) {

                        //
                        // copy button name
                        //

                        if (lstrcpyn(pCaps->pCapabilities[index].wszName,ppszButtonNames[index],(lMaxCapabilityString/sizeof(WCHAR)) - 1)) {

                            //
                            // copy button name, into button description (they are the same for Micro drivers)
                            //

                            if (!lstrcpyn(pCaps->pCapabilities[index].wszDescription,pCaps->pCapabilities[index].wszName,(lMaxCapabilityString/sizeof(WCHAR)) - 1)) {

                                //
                                // continue, allowing the other events to be read
                                //

                            }
                        }
                    } else {

                        //
                        // do default WIA provided Names for buttons (1,2,3,4,5,...etc)
                        //

                        WCHAR wszEventName[MAX_PATH];
                        memset(wszEventName,0,sizeof(wszEventName));

                        //
                        // load default button name from resource
                        //

                        if(LoadStringW(g_hInst,IDS_DEFAULT_EVENT_NAME,wszEventName,(sizeof(wszEventName)/sizeof(wszEventName[0])))) {

                            _snwprintf(pCaps->pCapabilities[index].wszName,
                                       ((lMaxCapabilityString/sizeof(WCHAR)) - 1),
                                       L"%ws %d",
                                       wszEventName,
                                       (index + 1));
                            if (!lstrcpyn(pCaps->pCapabilities[index].wszDescription,pCaps->pCapabilities[index].wszName,(lMaxCapabilityString/sizeof(WCHAR)) - 1)) {

                                //
                                // continue, allowing the other events to be read
                                //

                            }
                        }
                    }

                    //
                    // assign 'ACTION' to events
                    //

                    if(Val.pGuid) {
                        pCaps->pCapabilities[index].guid    = &Val.pGuid[index];
                    }

                    pCaps->pCapabilities[index].ulFlags = WIA_NOTIFICATION_EVENT|WIA_ACTION_EVENT;
                    pCaps->pCapabilities[index].wszIcon = WIA_ICON_SCAN_BUTTON_PRESS;

                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildCapabilities, Button Name = %ws",pCaps->pCapabilities[index].wszName));
                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildCapabilities, Button Desc = %ws",pCaps->pCapabilities[index].wszDescription));

                } else {
                    hr = E_OUTOFMEMORY;
                }// if ((pCaps->pCapabilities[index].wszDescription)&&(pCaps->pCapabilities[index].wszName))
            } // for (LONG index = 0; index < Val.lVal; index++)
        }
    }
    return hr;
}

HRESULT CMicroDriverAPI::GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::GetBedWidthAndHeight");

    HRESULT hr = S_OK;
    *pWidth  = m_ScanInfo.BedWidth;
    *pHeight = m_ScanInfo.BedHeight;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::GetBedWidthAndHeight, Width = %d, Height = %d",m_ScanInfo.BedWidth,m_ScanInfo.BedHeight));
    return hr;
}

HRESULT CMicroDriverAPI::BuildRootItemProperties(PWIAPROPERTIES pProperties)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::BuildRootItemProperties");

    HRESULT hr = S_OK;
    LONG PropIndex = 0;
    //
    // set the number of properties
    //

    hr = ADFAttached();
    if(hr == S_OK){
        pProperties->NumItemProperties = 19;   // standard properties + ADF specific
    } else {
        pProperties->NumItemProperties = 10;    // standard properties only
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::BuildRootItemProperties, Number of Properties = %d",pProperties->NumItemProperties));

    hr = AllocateAllProperties(pProperties);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CMicroDriverAPI::BuildRootItemProperties, AllocateAllProperties failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteAllProperties(pProperties);
        return hr;
    }

    // Intialize WIA_DPS_HORIZONTAL_BED_SIZE
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_BED_SIZE_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_BED_SIZE;
    pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.BedWidth;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_VERTICAL_BED_SIZE
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_VERTICAL_BED_SIZE_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPS_VERTICAL_BED_SIZE;
    pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.BedHeight;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ACCESS_RIGHTS
    pProperties->pszItemDefaults[PropIndex]              = WIA_IPA_ACCESS_RIGHTS_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_IPA_ACCESS_RIGHTS;
    pProperties->pvItemDefaults [PropIndex].lVal         = WIA_ITEM_READ|WIA_ITEM_WRITE;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_UI4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_XRES
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_OPTICAL_XRES_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPS_OPTICAL_XRES;
    pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.OpticalXResolution;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_YRES
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_OPTICAL_YRES_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPS_OPTICAL_YRES;
    pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.OpticalYResolution;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_DPA_FIRMWARE_VERSION
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPA_FIRMWARE_VERSION_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPA_FIRMWARE_VERSION;
    pProperties->pvItemDefaults [PropIndex].bstrVal      = SysAllocString(SCANNER_FIRMWARE_VERSION);
    pProperties->pvItemDefaults [PropIndex].vt           = VT_BSTR;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    pProperties->pszItemDefaults[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    pProperties->pvItemDefaults [PropIndex].lVal         = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;

    PropIndex++;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_DPS_MAX_SCAN_TIME;
    pProperties->pvItemDefaults [PropIndex].lVal               = 10000;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_PREVIEW (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_DPS_PREVIEW_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_DPS_PREVIEW;
    pProperties->pvItemDefaults [PropIndex].lVal               = WIA_FINAL_SCAN;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedPreviewModes;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedPreviewModes;

    PropIndex++;

    // Initialize WIA_DPS_SHOW_PREVIEW_CONTROL (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL;
    pProperties->pvItemDefaults [PropIndex].lVal               = WIA_SHOW_PREVIEW_CONTROL;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    if(m_ScanInfo.ADF == 1) {

        // Initialize WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE;
        pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.BedWidth;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_SHEET_FEED_SIZE
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE;
        pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.BedHeight;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES;
        pProperties->pvItemDefaults [PropIndex].lVal         = FLAT | FEED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_STATUS
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS;
        pProperties->pvItemDefaults [PropIndex].lVal         = FLAT_READY;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_SELECT
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT;
        pProperties->pvItemDefaults [PropIndex].lVal         = FLATBED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_FLAG;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = FEEDER | FLATBED;

        PropIndex++;

        // Initialize WIA_DPS_PAGES
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_PAGES_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_PAGES;
        pProperties->pvItemDefaults [PropIndex].lVal         = 1;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_RANGE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 0;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = 25;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = 1;

        PropIndex++;

        // Initialize WIA_DPS_SHEET_FEEDER_REGISTRATION
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION;
        pProperties->pvItemDefaults [PropIndex].lVal         = LEFT_JUSTIFIED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_HORIZONTAL_BED_REGISTRATION
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION;
        pProperties->pvItemDefaults [PropIndex].lVal         = LEFT_JUSTIFIED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_BED_REGISTRATION
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION;
        pProperties->pvItemDefaults [PropIndex].lVal         = TOP_JUSTIFIED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

    }
    return hr;
}

HRESULT CMicroDriverAPI::DeleteAllProperties(PWIAPROPERTIES pProperties)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::DeleteAllProperties");

    if(pProperties->pszItemDefaults){
        delete [] pProperties->pszItemDefaults;
        pProperties->pszItemDefaults = NULL;
    }

    if(pProperties->piItemDefaults){
        delete [] pProperties->piItemDefaults;
        pProperties->piItemDefaults = NULL;
    }

    if(pProperties->pvItemDefaults){
        delete [] pProperties->pvItemDefaults;
        pProperties->pvItemDefaults = NULL;
    }

    if(pProperties->psItemDefaults){
        delete [] pProperties->psItemDefaults;
        pProperties->psItemDefaults = NULL;
    }

    if(pProperties->wpiItemDefaults){
        delete [] pProperties->wpiItemDefaults;
        pProperties->wpiItemDefaults = NULL;
    }

    return S_OK;
}

HRESULT CMicroDriverAPI::AllocateAllProperties(PWIAPROPERTIES pProperties)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::AllocateAllProperties");

    HRESULT hr = S_OK;

    pProperties->pszItemDefaults   = new LPOLESTR[pProperties->NumItemProperties];
    if(NULL != pProperties->pszItemDefaults){
        pProperties->piItemDefaults    = new PROPID[pProperties->NumItemProperties];
        if (NULL != pProperties->piItemDefaults) {
            pProperties->pvItemDefaults    = new PROPVARIANT[pProperties->NumItemProperties];
            if(NULL != pProperties->pvItemDefaults){
                pProperties->psItemDefaults    = new PROPSPEC[pProperties->NumItemProperties];
                if(NULL != pProperties->psItemDefaults){
                    pProperties->wpiItemDefaults   = new WIA_PROPERTY_INFO[pProperties->NumItemProperties];
                    if(NULL == pProperties->wpiItemDefaults)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT CMicroDriverAPI::BuildTopItemProperties(PWIAPROPERTIES pProperties)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::BuildTopItemProperties");

    HRESULT hr = S_OK;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;

    hr = m_pMicroDriver->MicroEntry(CMD_RESETSCANNER,&Value);
    if(FAILED(hr)){
        return hr;
    }

    //
    // set the number of properties
    //

    pProperties->NumItemProperties = 29;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::BuildTopItemProperties, Number of Properties = %d",pProperties->NumItemProperties));

    hr = AllocateAllProperties(pProperties);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CMicroDriverAPI::BuildTopItemProperties, AllocateAllProperties failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteAllProperties(pProperties);
        return hr;
    }

    //
    // Get Data type restrictions (backup original data types)
    // Memory used for the original set will be reused to write back
    // the new valid values.
    //

    if(pProperties->bLegacyBWRestrictions){
        //
        // The NoColor=1 registry key was set to restrict this driver from supporting
        // color... remove the valid bits, just incase the bits were set..
        // This will automatically restrict our Data type array to report
        // the correct valid values.
        m_ScanInfo.SupportedDataTypes &= ~SUPPORT_COLOR;
    }

    LONG lSupportedDataTypesArray[3];   // 3 is the maximum data type set allowed
    LONG lNumSupportedDataTypes = 0;
    memcpy(lSupportedDataTypesArray,pProperties->pSupportedDataTypes,(sizeof(lSupportedDataTypesArray)));

    //
    // Set New Data type restrictions
    //

    if (m_ScanInfo.SupportedDataTypes != 0) {
        // check for 24-bit color support
        if (m_ScanInfo.SupportedDataTypes & SUPPORT_COLOR) {
            pProperties->pSupportedDataTypes[lNumSupportedDataTypes] = WIA_DATA_COLOR;
            lNumSupportedDataTypes++;
        }
        // check for 1-bit BW support
        if (m_ScanInfo.SupportedDataTypes & SUPPORT_BW) {
            pProperties->pSupportedDataTypes[lNumSupportedDataTypes] = WIA_DATA_THRESHOLD;
            lNumSupportedDataTypes++;
        }
        // check for 8-bit grayscale support
        if (m_ScanInfo.SupportedDataTypes & SUPPORT_GRAYSCALE) {
            pProperties->pSupportedDataTypes[lNumSupportedDataTypes] = WIA_DATA_GRAYSCALE;
            lNumSupportedDataTypes++;
        }

        // set new supported data type count
        pProperties->NumSupportedDataTypes = lNumSupportedDataTypes;
    }

    LONG PropIndex = 0;

    PLONG pResolutions = NULL;
    LONG lNumItems = 0;
    RANGEVALUEEX RangeValues;
    if(IsValidRestriction(&pResolutions, &lNumItems, &RangeValues)) {
        if(lNumItems > 0){
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildTopItemProperties, Using .INF provided Resolutions (LIST)"));
            // we have a list
            if(pProperties->pSupportedResolutions){
                //delete [] pProperties->pSupportedResolutions;
                pProperties->pSupportedResolutions = NULL;
                pProperties->pSupportedResolutions = pResolutions;
                pProperties->NumSupportedResolutions = lNumItems;
            }

            // Intialize WIA_IPS_XRES (LIST)
            pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
            pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
            pProperties->pvItemDefaults [PropIndex].lVal               = pProperties->pSupportedResolutions[PropIndex];
            pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
            pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
            pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
            pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
            pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedResolutions;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedResolutions;

            PropIndex++;

            // Intialize WIA_IPS_YRES (LIST)
            pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
            pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
            pProperties->pvItemDefaults [PropIndex].lVal               = pProperties->pSupportedResolutions[PropIndex-1];
            pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
            pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
            pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
            pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
            pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedResolutions;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedResolutions;

            PropIndex++;

        } else {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildTopItemProperties, Using .INF provided Resolutions (RANGE)"));
            // we have a range
            // Intialize WIA_IPS_XRES (RANGE)
            pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
            pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
            pProperties->pvItemDefaults [PropIndex].lVal               = RangeValues.lNom;
            pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
            pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
            pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
            pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
            pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = RangeValues.lStep;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = RangeValues.lMin;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = RangeValues.lMax;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = RangeValues.lNom;

            PropIndex++;

            // Intialize WIA_IPS_YRES (RANGE)
            pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
            pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
            pProperties->pvItemDefaults [PropIndex].lVal               = RangeValues.lNom;
            pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
            pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
            pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
            pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
            pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = RangeValues.lStep;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = RangeValues.lMin;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = RangeValues.lMax;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = RangeValues.lNom;

            PropIndex++;
        }
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildTopItemProperties, Using HOST Provided Resolution Restrictions"));
#ifdef USE_RANGE_VALUES

        // Intialize WIA_IPS_XRES (RANGE)
        pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
        pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
        pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_XRESOLUTION;
        pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 12;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = 1200;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

        PropIndex++;

        // Intialize WIA_IPS_YRES (RANGE)
        pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
        pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
        pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_YRESOLUTION;
        pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 12;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = 1200;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

        PropIndex++;

#else   // USE_RANGE_VALUES (different property sets for different drivers)

        // Intialize WIA_IPS_XRES (LIST)
        pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
        pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
        pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_XRESOLUTION;
        pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedResolutions;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedResolutions;

        PropIndex++;

        // Intialize WIA_IPS_YRES (LIST)
        pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
        pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
        pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_YRESOLUTION;
        pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedResolutions;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedResolutions;

        PropIndex++;

#endif

    }

    // Intialize WIA_IPS_XEXTENT (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XEXTENT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XEXTENT;
    pProperties->pvItemDefaults [PropIndex].lVal               = (pProperties->pvItemDefaults [PropIndex-2].lVal * m_ScanInfo.BedWidth)/1000;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_YEXTENT (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YEXTENT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YEXTENT;
    pProperties->pvItemDefaults [PropIndex].lVal               = (pProperties->pvItemDefaults [PropIndex-2].lVal * m_ScanInfo.BedHeight)/1000;;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_XPOS (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XPOS_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XPOS;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 0;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = (pProperties->wpiItemDefaults[PropIndex-2].ValidVal.Range.Max - 1);
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_YPOS (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YPOS_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YPOS;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 0;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = (pProperties->wpiItemDefaults[PropIndex-2].ValidVal.Range.Max - 1);
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPA_DATATYPE (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_DATATYPE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_DATATYPE;
    pProperties->pvItemDefaults [PropIndex].lVal               = m_ScanInfo.DataType;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)pProperties->pSupportedDataTypes;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom      = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedDataTypes;

    PropIndex++;

    // Intialize WIA_IPA_DEPTH (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_DEPTH_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_DEPTH;
    pProperties->pvItemDefaults [PropIndex].lVal               = m_ScanInfo.PixelBits;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_BRIGHTNESS (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_BRIGHTNESS_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_BRIGHTNESS;
    pProperties->pvItemDefaults [PropIndex].lVal               = m_ScanInfo.Intensity;//INITIAL_BRIGHTNESS;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = m_ScanInfo.IntensityRange.lStep; //   1
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = m_ScanInfo.IntensityRange.lMin;  //-127;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = m_ScanInfo.IntensityRange.lMax;  // 128;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_CONTRAST (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_CONTRAST_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_CONTRAST;
    pProperties->pvItemDefaults [PropIndex].lVal               = m_ScanInfo.Contrast;//INITIAL_CONTRAST;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = m_ScanInfo.ContrastRange.lStep; //   1
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = m_ScanInfo.ContrastRange.lMin;  //-127;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = m_ScanInfo.ContrastRange.lMax;  // 128;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_CUR_INTENT (FLAG)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_CUR_INTENT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_CUR_INTENT;
    pProperties->pvItemDefaults [PropIndex].lVal               = WIA_INTENT_NONE;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_FLAG;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WIA_INTENT_MINIMIZE_SIZE | WIA_INTENT_MAXIMIZE_QUALITY;

    // check for 24-bit color support
    if (m_ScanInfo.SupportedDataTypes & SUPPORT_COLOR) {
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits |= WIA_INTENT_IMAGE_TYPE_COLOR;
    }

    // check for 1-bit BW support
    if (m_ScanInfo.SupportedDataTypes & SUPPORT_BW) {
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits |= WIA_INTENT_IMAGE_TYPE_TEXT;
    }

    // check for 8-bit grayscale support
    if (m_ScanInfo.SupportedDataTypes & SUPPORT_GRAYSCALE) {
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits |= WIA_INTENT_IMAGE_TYPE_GRAYSCALE;
    }

    if(pProperties->bLegacyBWRestrictions){
        //
        // The NoColor=1 registry key was set to restrict this driver from supporting
        // color... remove the valid bits, just incase the bits were set..
        // note: NoColor overrides all driver settings
        //
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits &= ~ WIA_INTENT_IMAGE_TYPE_COLOR;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // The full valid bits for intent for information only                                          //
    //////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WIA_INTENT_IMAGE_TYPE_COLOR |
    //                                                                   WIA_INTENT_IMAGE_TYPE_GRAYSCALE |
    //                                                                   WIA_INTENT_IMAGE_TYPE_TEXT  |
    //                                                                   WIA_INTENT_MINIMIZE_SIZE |
    //                                                                   WIA_INTENT_MAXIMIZE_QUALITY;
    //////////////////////////////////////////////////////////////////////////////////////////////////

    PropIndex++;

    // Intialize WIA_IPA_PIXELS_PER_LINE (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_PIXELS_PER_LINE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_PIXELS_PER_LINE;
    pProperties->pvItemDefaults [PropIndex].lVal               = pProperties->pvItemDefaults [PropIndex-9].lVal;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_NUMER_OF_LINES (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_NUMBER_OF_LINES_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_NUMBER_OF_LINES;
    pProperties->pvItemDefaults [PropIndex].lVal               = pProperties->pvItemDefaults [PropIndex-9].lVal;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_DPS_MAX_SCAN_TIME;
    pProperties->pvItemDefaults [PropIndex].lVal               = 10000;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PREFERRED_FORMAT (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_PREFERRED_FORMAT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_PREFERRED_FORMAT;
    pProperties->pvItemDefaults [PropIndex].puuid              = &pProperties->pInitialFormats[0];;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_CLSID;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ITEM_SIZE (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_ITEM_SIZE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_ITEM_SIZE;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_THRESHOLD (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_THRESHOLD_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_THRESHOLD;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = -127;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = 128;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPA_FORMAT (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_FORMAT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_FORMAT;
    pProperties->pvItemDefaults [PropIndex].puuid              = &pProperties->pInitialFormats[0];
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_CLSID;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.ListGuid.pList    = pProperties->pInitialFormats;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.ListGuid.Nom      = *pProperties->pvItemDefaults [PropIndex].puuid;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.ListGuid.cNumList = pProperties->NumInitialFormats;

    PropIndex++;

    // Intialize WIA_IPA_TYMED (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_TYMED_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_TYMED;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_TYMED;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)pProperties->pSupportedTYMED;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom      = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedTYMED;

    PropIndex++;

    // Intialize WIA_IPA_CHANNELS_PER_PIXEL (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_CHANNELS_PER_PIXEL;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BITS_PER_CHANNEL (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_BITS_PER_CHANNEL;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PLANAR (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_PLANAR_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_PLANAR;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_PLANAR;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BYTES_PER_LINE (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_BYTES_PER_LINE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_BYTES_PER_LINE;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_MIN_BUFFER_SIZE (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE;
    pProperties->pvItemDefaults [PropIndex].lVal               = MIN_BUFFER_SIZE;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ACCESS_RIGHTS (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_ACCESS_RIGHTS_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_ACCESS_RIGHTS;
    pProperties->pvItemDefaults [PropIndex].lVal               = WIA_ITEM_READ|WIA_ITEM_WRITE;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_COMPRESSION (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_COMPRESSION_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_COMPRESSION;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_COMPRESSION;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)pProperties->pSupportedCompressionTypes;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom      = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedCompressionTypes;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    pProperties->pszItemDefaults[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    pProperties->pvItemDefaults [PropIndex].lVal         = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;

    PropIndex++;

    // Initialize WIA_IPS_PHOTOMETRIC_INTERP
    pProperties->pszItemDefaults[PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP;
    pProperties->pvItemDefaults [PropIndex].lVal         = INITIAL_PHOTOMETRIC_INTERP;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_WARM_UP_TIME_STR (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_WARM_UP_TIME_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_WARM_UP_TIME;
    pProperties->pvItemDefaults [PropIndex].lVal               = 10000;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    return hr;
}

HRESULT CMicroDriverAPI::SetResolutionRestrictionString(TCHAR *szResolutions)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetResolutionRestrictionString");
    //
    // SBB - RAID 370299 - orenr - 2001/04/18 - Security fix -
    // potential buffer overrun.  Changed lstrcpy to use
    // _tcsncpy instead.
    //
    ZeroMemory(m_szResolutions, sizeof(m_szResolutions));
    _tcsncpy(m_szResolutions,
             szResolutions,
             (sizeof(m_szResolutions) / sizeof(TCHAR)) - 1);

#ifdef UNICODE
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::SetResolutionRestrictionString, szResolutions = %ws",szResolutions));
#else
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::SetResolutionRestrictionString, szResolutions = %s",szResolutions));
#endif
    return S_OK;
}

HRESULT CMicroDriverAPI::SetScanMode(INT iScanMode)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "SetScanMode");

    HRESULT hr = S_OK;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;
    Value.lVal = iScanMode;

    hr = m_pMicroDriver->MicroEntry(CMD_SETSCANMODE,&Value);
    if(FAILED(hr)){
        if(E_NOTIMPL == hr){
            hr = S_OK;
        }
        return hr;
    }
    return hr;
}

HRESULT CMicroDriverAPI::SetSTIDeviceHKEY(HKEY *pHKEY)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "SetSTIDeviceHKEY");

    HRESULT hr = S_OK;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;
    Value.pHandle = (HANDLE*)pHKEY;

    hr = m_pMicroDriver->MicroEntry(CMD_SETSTIDEVICEHKEY,&Value);
    if(FAILED(hr)){
        if(E_NOTIMPL == hr){
            hr = S_OK;
        }
        return hr;
    }
    return hr;
}

HRESULT CMicroDriverAPI::GetSupportedFileFormats(GUID **ppguid, LONG *plNumSupportedFormats)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "GetSupportedFileFormats");

    HRESULT hr = S_OK;
    *plNumSupportedFormats = 0;
    *ppguid = NULL;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;

    hr = m_pMicroDriver->MicroEntry(CMD_GETSUPPORTEDFILEFORMATS,&Value);
    if(FAILED(hr)){
        return hr;
    }

    *plNumSupportedFormats = Value.lVal;
    *ppguid = Value.pGuid;

    return hr;
}

HRESULT CMicroDriverAPI::GetSupportedMemoryFormats(GUID **ppguid, LONG *plNumSupportedFormats)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "GetSupportedMemoryFormats");

    HRESULT hr = S_OK;
    *plNumSupportedFormats = 0;
    *ppguid = NULL;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;

    hr = m_pMicroDriver->MicroEntry(CMD_GETSUPPORTEDMEMORYFORMATS,&Value);
    if(FAILED(hr)){
        return hr;
    }

    *plNumSupportedFormats = Value.lVal;
    *ppguid = Value.pGuid;

    return hr;
}

HRESULT CMicroDriverAPI::IsColorDataBGR(BOOL *pbBGR)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "IsColorDataBGR");

    HRESULT hr = S_OK;
    // WIA_ORDER_RGB 0
    // WIA_ORDER_BGR 1
    *pbBGR = (m_ScanInfo.RawPixelOrder == WIA_ORDER_BGR);
    return hr;
}

HRESULT CMicroDriverAPI::IsAlignmentNeeded(BOOL *pbALIGN)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                         WIALOG_NO_RESOURCE_ID,
                         WIALOG_LEVEL1,
                         "IsAlignmentNeeded");
    HRESULT hr = S_OK;
    *pbALIGN = m_ScanInfo.bNeedDataAlignment;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\scanapi.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       scanapi.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#ifndef _SCANAPI_H
#define _SCANAPI_H

#include "ioblockdefs.h"

typedef GUID* PGUID;

#define FLATBED_SCANNER_MODE        100
#define SCROLLFED_SCANNER_MODE      200
#define MULTIFUNCTION_DEVICE_MODE   300

#define SCAN_START                  0
#define SCAN_CONTINUE               1
#define SCAN_END                    3

typedef struct _DEVICE_BUTTON_INFO {
    BYTE ScanButton;
    BYTE FaxButton;
    BYTE EMailButton;
    BYTE DocumentButton;
    BYTE CancelButton;
}DEVICE_BUTTON_INFO,*PDEVICE_BUTTON_INFO;

typedef struct _INITINFO {
    HANDLE hDeviceDataHandle;
    TCHAR *szModuleFileName;
    CHAR *szCreateFileName;
    HKEY hKEY;
}INITINFO,*PINITINFO;

typedef struct _INTERRUPTEVENTINFO {
    CHAR   *szDeviceName;
    HANDLE *phSignalEvent;
    HANDLE hShutdownEvent;
    GUID   *pguidEvent;
}INTERRUPTEVENTINFO,*PINTERRUPTEVENTINFO;

typedef struct _WIAPROPERTIES {
    LONG                NumItemProperties;    // Number of item properties
    LPOLESTR            *pszItemDefaults;     // item property names
    PROPID              *piItemDefaults;      // item property ids
    PROPVARIANT         *pvItemDefaults;      // item property prop variants
    PROPSPEC            *psItemDefaults;      // item property propspecs
    WIA_PROPERTY_INFO   *wpiItemDefaults;     // item property attributes

    // valid values
    LONG                NumSupportedFormats;  // Number of supported formats
    LONG                NumSupportedTYMED;    // Number of supported TYMED
    LONG                NumInitialFormats;    // Number of Initial formats
    LONG                NumSupportedDataTypes;// Number of supported data types
    LONG                NumSupportedIntents;  // Number of supported intents
    LONG                NumSupportedCompressionTypes; // Number of supported compression types
    LONG                NumSupportedResolutions;// Number of supported resolutions
    LONG                NumSupportedPreviewModes;// Number of supported preview modes

    WIA_FORMAT_INFO     *pSupportedFormats;   // supported formats
    LONG                *pSupportedTYMED;     // supported TYMED
    GUID                *pInitialFormats;     // initial formats
    LONG                *pSupportedDataTypes; // supported data types
    LONG                *pSupportedIntents;   // supported intents
    LONG                *pSupportedCompressionTypes; // supported compression types
    LONG                *pSupportedResolutions;// supproted resolutions
    LONG                *pSupportedPreviewModes;// supported preview modes

    BOOL                bLegacyBWRestrictions;// backward compatible with older system

}WIAPROPERTIES,*PWIAPROPERTIES;

typedef struct _WIACAPABILITIES {
    PLONG pNumSupportedEvents;
    PLONG pNumSupportedCommands;
    WIA_DEV_CAP_DRV *pCapabilities;
}WIACAPABILITIES,*PWIACAPABILITIES;

class CScanAPI {
public:
    CScanAPI() :
        m_pIWiaLog(NULL) {

    }
    ~CScanAPI(){

    }

    IWiaLog  *m_pIWiaLog;            // WIA logging object

    virtual HRESULT SetLoggingInterface(IWiaLog *pLogInterface){
        if(pLogInterface){
            m_pIWiaLog = pLogInterface;
        } else {
            return E_INVALIDARG;
        }
        return S_OK;
    }

    // data acquisition functions
    virtual HRESULT Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten){
        return E_NOTIMPL;
    }
    virtual HRESULT SetDataType(LONG lDataType){
        return E_NOTIMPL;
    }
    virtual HRESULT SetXYResolution(LONG lXResolution, LONG lYResolution){
        return E_NOTIMPL;
    }
    virtual HRESULT SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt){
        return E_NOTIMPL;
    }
    virtual HRESULT SetContrast(LONG lContrast){
        return E_NOTIMPL;
    }
    virtual HRESULT SetIntensity(LONG lIntensity){
        return E_NOTIMPL;
    }
    virtual HRESULT ResetDevice(){
        return E_NOTIMPL;
    }
    virtual HRESULT SetEmulationMode(LONG lDeviceMode){
        return E_NOTIMPL;
    }
    virtual HRESULT DisableDevice(){
        return E_NOTIMPL;
    }
    virtual HRESULT EnableDevice(){
        return E_NOTIMPL;
    }
    virtual HRESULT DeviceOnline(){
        return E_NOTIMPL;
    }
    virtual HRESULT GetDeviceEvent(GUID *pEvent){
        return E_NOTIMPL;
    }
    virtual HRESULT Diagnostic(){
        return E_NOTIMPL;
    }
    virtual HRESULT Initialize(PINITINFO pInitInfo){
        return E_NOTIMPL;
    }
    virtual HRESULT UnInitialize(){
        return E_NOTIMPL;
    }
    virtual HRESULT DoInterruptEventThread(PINTERRUPTEVENTINFO pEventInfo){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFAttached(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFHasPaper(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFAvailable(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFFeedPage(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFUnFeedPage(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFStatus(){
        return E_NOTIMPL;
    }
    virtual HRESULT QueryButtonPanel(PDEVICE_BUTTON_INFO pButtonInformation){
        return E_NOTIMPL;
    }
    virtual HRESULT BuildRootItemProperties(PWIAPROPERTIES pProperties){
        return E_NOTIMPL;
    }
    virtual HRESULT BuildTopItemProperties(PWIAPROPERTIES pProperties){
        return E_NOTIMPL;
    }
    virtual HRESULT BuildCapabilities(PWIACAPABILITIES pCapabilities){
        return E_NOTIMPL;
    }
    virtual HRESULT GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight){
        return E_NOTIMPL;
    }
    virtual HRESULT SetResolutionRestrictionString(TCHAR *szResolutions){
        return E_NOTIMPL;
    }
    virtual HRESULT SetScanMode(INT iScanMode){
        return E_NOTIMPL;
    }
    virtual HRESULT SetSTIDeviceHKEY(HKEY *pHKEY){
        return E_NOTIMPL;
    }
    virtual HRESULT GetSupportedFileFormats(GUID **ppguid, LONG *plNumSupportedFormats){
        return E_NOTIMPL;
    }
    virtual HRESULT GetSupportedMemoryFormats(GUID **ppguid, LONG *plNumSupportedFormats){
        return E_NOTIMPL;
    }
    virtual HRESULT IsColorDataBGR(BOOL *pbBGR){
        return E_NOTIMPL;
    }
    virtual HRESULT IsAlignmentNeeded(BOOL *pbALIGN){
        return E_NOTIMPL;
    }
    virtual HRESULT SetFormat(GUID *pguidFormat){
        return E_NOTIMPL;
    }
};

///////////////////////////////////////////////////////////////////////////////////
// MICRO DRIVER SYSTEM SUPPORT                                                   //
///////////////////////////////////////////////////////////////////////////////////

class CMicroDriverAPI :public CScanAPI {
public:
    CMicroDriverAPI();
    ~CMicroDriverAPI();

    CMICRO *m_pMicroDriver;         // Micro driver communication
    SCANINFO m_ScanInfo;            // ScanInfo structure
    TCHAR  m_szResolutions[255];    // restricted resolutions string
    BOOL   m_bDisconnected;         // device disconnected during operation

    HRESULT Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten);
    HRESULT SetDataType(LONG lDataType);
    HRESULT SetXYResolution(LONG lXResolution, LONG lYResolution);
    HRESULT SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt);
    HRESULT SetContrast(LONG lContrast);
    HRESULT SetIntensity(LONG lIntensity);
    HRESULT ResetDevice();
    HRESULT SetEmulationMode(LONG lDeviceMode);
    HRESULT DisableDevice();
    HRESULT EnableDevice();
    HRESULT DeviceOnline();
    HRESULT GetDeviceEvent(GUID *pEvent);
    HRESULT Diagnostic();
    HRESULT Initialize(PINITINFO pInitInfo);
    HRESULT UnInitialize();
    HRESULT DoInterruptEventThread(PINTERRUPTEVENTINFO pEventInfo);
    HRESULT ADFAttached();
    HRESULT ADFHasPaper();
    HRESULT ADFAvailable();
    HRESULT ADFFeedPage();
    HRESULT ADFUnFeedPage();
    HRESULT ADFStatus();
    HRESULT QueryButtonPanel(PDEVICE_BUTTON_INFO pButtonInformation);
    HRESULT BuildRootItemProperties(PWIAPROPERTIES pProperties);
    HRESULT BuildTopItemProperties(PWIAPROPERTIES pProperties);
    HRESULT BuildCapabilities(PWIACAPABILITIES pCapabilities);
    HRESULT GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight);
    HRESULT SetResolutionRestrictionString(TCHAR *szResolutions);
    HRESULT SetScanMode(INT iScanMode);
    HRESULT SetSTIDeviceHKEY(HKEY *pHKEY);
    HRESULT GetSupportedFileFormats(GUID **ppguid, LONG *plNumSupportedFormats);
    HRESULT GetSupportedMemoryFormats(GUID **ppguid, LONG *plNumSupportedFormats);
    HRESULT IsColorDataBGR(BOOL *pbBGR);
    HRESULT IsAlignmentNeeded(BOOL *pbALIGN);
    HRESULT SetFormat(GUID *pguidFormat);

    // helpers
    HRESULT MicroDriverErrorToWIAError(LONG lMicroDriverError);
    BOOL    IsValidRestriction(LONG **ppList, LONG *plNumItems, RANGEVALUEEX *pRangeValues);
    HRESULT DeleteAllProperties(PWIAPROPERTIES pProperties);
    HRESULT AllocateAllProperties(PWIAPROPERTIES pProperties);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IWiaMiniDrv methods.
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;           // used for WIAS_LOGPROC macro
#define _64BIT_ALIGNMENT          // the real 64-bit alignment fix
#define _SERVICE_EXTENT_VALIDATION  // let the WIA service validate the extent settings
//#define _OOB_DATA                   // Out Of Band data support (File Transfers only)

#define BUFFER_PAD 1024 // buffer padding

/**************************************************************************\
* CWIAScannerDevice::drvDeleteItem
*
*   This helper is called to delete a device item.
*   Note: Device items for this device may not be modified.
*         Return access denied.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*     7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvDeleteItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvDeleteItem");
    return STG_E_ACCESSDENIED;
}

/**************************************************************************\
* SendBitmapHeader
*
*   This helper is called to send the bitmap header info to the callback
*   routine.
*   Note: This is a helper function used in TYMED_CALLBACK transfers.
*
* Arguments:
*
*   pmdtc   -   a pointer to a transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SendBitmapHeader(
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SendBitmapHeader");

    HRESULT hr = S_OK;

    BITMAPINFO UNALIGNED *pbmi = (LPBITMAPINFO)pmdtc->pTransferBuffer;

#ifdef _64BIT_ALIGNMENT
    BITMAPINFOHEADER UNALIGNED *pbmih = &pbmi->bmiHeader;
    pbmih->biHeight = -pbmih->biHeight;
#else
    pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
#endif

    //
    //  Send to class driver.  WIA Class driver will pass
    //  data through to client.
    //

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                     IT_STATUS_TRANSFER_TO_CLIENT,
                                                     0,
                                                     0,
                                                     pmdtc->lHeaderSize,
                                                     pmdtc,
                                                     0);

    if (hr == S_OK) {

        //
        //  If the transfer was successfull, advance offset for
        //  destination copy by the size of the data just sent.
        //

        pmdtc->cbOffset += pmdtc->lHeaderSize;
    }
    return hr;
}

/**************************************************************************\
* SendFilePreviewBitmapHeader
*
*   This helper is called to send the bitmap header info to the callback
*   routine.
*   Note: This is a helper function used in TYMED_FILE transfers with
*         (out of band data) enabled.
*
* Arguments:
*
*   pmdtc   -   a pointer to a transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SendFilePreviewBitmapHeader(
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SendBitmapHeader");

    HRESULT hr = S_OK;

#ifdef _OOB_DATA

    WIAS_DOWN_SAMPLE_INFO DownSampleInfo;
    memset(&DownSampleInfo,0,sizeof(DownSampleInfo));

    DownSampleInfo.ulBitsPerPixel       = pmdtc->lDepth;
    DownSampleInfo.ulOriginalWidth      = pmdtc->lWidthInPixels;
    DownSampleInfo.ulOriginalHeight     = pmdtc->lLines;
    DownSampleInfo.ulDownSampledHeight  = 0;
    DownSampleInfo.ulDownSampledWidth   = 0;
    DownSampleInfo.ulXRes               = pmdtc->lXRes;
    DownSampleInfo.ulYRes               = pmdtc->lYRes;

    hr = wiasDownSampleBuffer(WIAS_GET_DOWNSAMPLED_SIZE_ONLY,
                              &DownSampleInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SendFilePreviewBitmapHeader, wiasDownSampleBuffer Failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    } else {

        //
        // acquire BITMAPHEADER pointer from pmdtc
        //

        LPBITMAPINFO UNALIGNED pbmi = (LPBITMAPINFO)pmdtc->pBaseBuffer;

#ifdef _64BIT_ALIGNMENT
        BITMAPINFOHEADER UNALIGNED *pbmih = &pbmi->bmiHeader;
        pbmih->biHeight = 0;                                 // set height to zero (0)
        pbmih->biWidth  = DownSampleInfo.ulDownSampledWidth; // set down sampled width
#else
        pmdtc->pBaseBuffer          = pmdtc->pTransferBuffer + sizeof(BITMAPFILEHEADER);
#endif



        //
        // adjust width and height
        //

        pbmi->bmiHeader.biHeight    = 0;                                 // set height to zero (0)
        pbmi->bmiHeader.biWidth     = DownSampleInfo.ulDownSampledWidth; // set down sampled width

        //
        //  Send to class driver.  WIA Class driver will pass
        //  data through to client.
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_FILE_PREVIEW_DATA,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          0,
                                                          0,
                                                          pmdtc->lHeaderSize - sizeof(BITMAPFILEHEADER),
                                                          pmdtc,
                                                          0);
    }

#endif

    return hr;
}

/**************************************************************************\
* ScanItem
*
*   This helper is called to do a FILE transfer.
*   Note: This routine must fill the complete buffer, and return percent
*         complete status back to the client if a callback routine is
*         provided.
*
* Arguments:
*
*   pItemContext        - private item data
*   pMiniTranCtx        - minidriver supplied transfer info
*   plDevErrVal         - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*     7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::ScanItem(
    PMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::ScanItem");
    HRESULT hr = S_OK;


    //
    // init buffer info
    //

    DWORD cbWritten    = 0;
    LONG  cbSize       = 0;
    LONG  cbRemaining  = pmdtc->lBufferSize - pmdtc->lHeaderSize;
    PBYTE pBuf         = pmdtc->pTransferBuffer + pmdtc->lHeaderSize;
    LONG  lItemSize    = pmdtc->lHeaderSize;
    BOOL  bSwapBGRData = TRUE;
    BOOL  bDWORDAlign  = TRUE;
    BOOL  bVerticalFlip= TRUE;
    LONG  lScanPhase   = SCAN_START;
    ULONG ulDestDataOffset = 0;
    BOOL bBitmapData   = ((pmdtc->guidFormatID == WiaImgFmt_BMP) || (pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP));
    LONG PercentComplete = 0;

#ifdef _OOB_DATA

    WIAS_DOWN_SAMPLE_INFO DownSampleInfo;
    memset(&DownSampleInfo,0,sizeof(DownSampleInfo));

    //
    //  SEND BITMAPHEADER to client
    //

    hr = SendFilePreviewBitmapHeader(pmdtc);
    if(hr == S_OK){

        //
        // move offset past file header
        //

        ulDestDataOffset += (pmdtc->lHeaderSize - sizeof(BITMAPFILEHEADER));
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, SendFilePreviewBitmapHeader Failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }


#endif

    if (bBitmapData) {

        //
        // check to see if the color data needs to be swapped
        //

        hr = m_pScanAPI->IsColorDataBGR(&bSwapBGRData);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, IsColorDataBGR() Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        //
        // check to see if data needs to be aligned
        //

        hr = m_pScanAPI->IsAlignmentNeeded(&bDWORDAlign);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, IsAlignmentNeeded() Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }

    //
    // scan until buffer runs out or scanner completes transfer
    //

    while ((lScanPhase == SCAN_START) || (cbWritten)) {

        //
        // default transfer size is m_MaxBufferSize
        //

        cbSize = m_MaxBufferSize;

        if (bBitmapData) {

            //
            // Limit requests to max buffer size or less.
            //

            cbSize = (cbRemaining > m_MaxBufferSize) ? m_MaxBufferSize : cbRemaining;

            //
            // Request size to scanner must be modula the raw bytes per scan row.
            // Enough space for the alignment padding must be reserved.
            // These are requirements for AlignInPlace
            //

            cbSize = (cbSize / pItemContext->lBytesPerScanLine) *
                     pItemContext->lBytesPerScanLineRaw;

            //
            // check if finished
            //

            if (cbSize == 0) {
                break;
            }
        }

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  lScanPhase indicates whether this is the first call to Scan,
        //  pBuf is a pointer to the buffer, cbSize is the amount of data
        //  requested from the scanner, and cbWritten will be set to the actual
        //  amount of data returned by the scanner.
        //

        hr = m_pScanAPI->Scan(lScanPhase, pBuf, cbSize, &cbWritten);

        //
        // set flag to SCAN_CONTINUE, for other calls
        //

        lScanPhase = SCAN_CONTINUE;

        if (hr == S_OK) {

            if (cbWritten) {

                if (bBitmapData) {

                    //
                    // Place the scan data in correct byte order for 3 bytes ber pixel data.
                    //

                    if ((pmdtc->lDepth == 24)) {

                        //
                        // swap data if needed
                        //

                        if (bSwapBGRData) {
                            SwapBuffer24(pBuf, cbWritten);
                        }
                    }

                    //
                    // Align the data on DWORD boundries.
                    //

                    if (bDWORDAlign) {
                        cbWritten = AlignInPlace(pBuf,
                                                 cbWritten,
                                                 pItemContext->lBytesPerScanLine,
                                                 pItemContext->lBytesPerScanLineRaw);
                    }
                }

                //
                // advance buffer
                //

                lItemSize   += cbWritten;
                pBuf        += cbWritten;
                cbRemaining -= cbWritten;

                //
                // If a status callback was specified callback the class driver.
                //

                if (pmdtc->pIWiaMiniDrvCallBack) {

                    FLOAT FractionComplete = 0.0f;

                    if (pmdtc->lBufferSize) {
                        if(bBitmapData){
                            PercentComplete  = 0;
                            FractionComplete = (FLOAT)(pmdtc->lBufferSize - cbRemaining) / (FLOAT)pmdtc->lBufferSize;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItemCB, pmdtc->lBufferSize = 0!"));
                    }

                    //
                    // calculate percent complete
                    //

                    if(bBitmapData){
                        PercentComplete = (LONG)(100 * FractionComplete);
                    } else {
                        PercentComplete  += 25;
                        if(PercentComplete >= 100){
                            PercentComplete = 90;
                        }
                    }

                    //
                    // call back client with status on the transfer
                    //

                    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,
                                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                                      PercentComplete,
                                                                      0,
                                                                      0,
                                                                      NULL,
                                                                      0);
                    //
                    // check for user cancel (from IT_MSG_STATUS callback)
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItem, Transfer canceled by client (IT_MSG_STATUS callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItem, MiniDrvCallback failed (IT_MSG_STATUS callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }

#ifdef _OOB_DATA
                    DownSampleInfo.pDestBuffer          = NULL; // allocate this for me?
                    DownSampleInfo.pSrcBuffer           = pBuf - cbWritten;
                    DownSampleInfo.ulActualSize         = 0;    // Actual of what? data written?
                    DownSampleInfo.ulBitsPerPixel       = pmdtc->lDepth;
                    DownSampleInfo.ulDestBufSize        = 0;
                    DownSampleInfo.ulDownSampledHeight  = 0;
                    DownSampleInfo.ulDownSampledWidth   = 0;
                    DownSampleInfo.ulOriginalHeight     = (cbWritten / pItemContext->lBytesPerScanLine);
                    DownSampleInfo.ulOriginalWidth      = pmdtc->lWidthInPixels;
                    DownSampleInfo.ulSrcBufSize         = cbWritten;
                    DownSampleInfo.ulXRes               = pmdtc->lXRes;
                    DownSampleInfo.ulYRes               = pmdtc->lYRes;

                    hr = wiasDownSampleBuffer(0, &DownSampleInfo);
                    if(FAILED(hr)){
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, wiasDownSampleBuffer Failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    } else {

                        pmdtc->pBaseBuffer = DownSampleInfo.pDestBuffer;

                        //
                        // call back client with down sampled buffer
                        //

                        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_FILE_PREVIEW_DATA,
                                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                                          PercentComplete,
                                                                          ulDestDataOffset,
                                                                          DownSampleInfo.ulActualSize,
                                                                          pmdtc,
                                                                          0);
                        //
                        // update offset
                        //

                        ulDestDataOffset += DownSampleInfo.ulActualSize;
                    }


                    //
                    // check for user cancel (from IT_MSG_FILE_PREVIEW_DATA callback)
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItem, Transfer canceled by client (IT_MSG_FILE_PREVIEW_DATA callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItem, MiniDrvCallback failed (IT_MSG_FILE_PREVIEW_DATA callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }
#endif
                }

                //
                // write the band of data here
                //

                if (!bBitmapData) {
                    if (hr == S_OK) {
                        if (!pmdtc->bClassDrvAllocBuf) {
                            pmdtc->lItemSize = cbWritten;
                            hr = wiasWritePageBufToFile(pmdtc);
                            if (FAILED(hr)) {
                                WIAS_LERROR(m_pIWiaLog,
                                            WIALOG_NO_RESOURCE_ID,
                                            ("ScanItem, WritePageBufToFile failed"));
                            }
                        }
                        pBuf = pmdtc->pTransferBuffer;
                    }
                }
            }

        } else {

            //
            //  Get the device error
            //
            if (plDevErrVal) {
                *plDevErrVal = (LONG) hr;
                WIAS_LERROR(m_pIWiaLog,
                            WIALOG_NO_RESOURCE_ID,
                            ("ScanItem, data transfer failed, status: 0x%X", hr));
            }
            break;
        }
    }

    if (hr == S_OK) {

        //
        // On success, flip the buffer about the vertical access if
        // we have a DIB header and data.
        //

        if (pmdtc->guidFormatID == WiaImgFmt_BMP) {
            if(bVerticalFlip){
                VerticalFlip(pItemContext, pmdtc);
            }
        }

        if (bBitmapData) {

            //
            //  If the mini driver allocated a page buffer, we need to write the
            //  buffer to the open file handle (opened by class driver).
            //

            if (!pmdtc->bClassDrvAllocBuf) {

                //
                //  Now that we know the true item size, update the mini driver
                //  context.
                //

                pmdtc->lItemSize = lItemSize;

                hr = wiasWritePageBufToFile(pmdtc);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,
                                WIALOG_NO_RESOURCE_ID,
                                ("ScanItem, WritePageBufToFile failed"));
                }
            }
        }
    }

    HRESULT Temphr = m_pScanAPI->Scan(SCAN_END, NULL, 0, NULL);
    if(FAILED(Temphr)){
        WIAS_LERROR(m_pIWiaLog,
                    WIALOG_NO_RESOURCE_ID,
                    ("ScanItem, Ending a scanning session failed"));
        hr = Temphr;
    }

#ifdef _OOB_DATA

    //
    // free down sampled, temporary buffer
    //

    if(DownSampleInfo.pDestBuffer){
        CoTaskMemFree(DownSampleInfo.pDestBuffer);
        DownSampleInfo.pDestBuffer = NULL;
    }

#endif

    if (!bBitmapData) {

        //
        // call back client with status on the transfer with 100% complete
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100,
                                                          0,
                                                          0,
                                                          NULL,
                                                          0);
    }

    return hr;
}

/**************************************************************************\
* ScanItemCB
*
*   This helper is called to do a MEMORY transfer.
*   Note: This routine must fill buffers, adjust the buffer offset and
*         return percent complete status back to the client via a callback
*         routine. (a callback interface must be supplied by the caller for
*         this routine to function).
*
* Arguments:
*
*   pItemContext    - private item data
*   pmdtc           - buffer and callback information
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::ScanItemCB(
    PMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::ScanItemCB");
    HRESULT hr = S_OK;

    //
    // init buffer info
    //

    DWORD cbWritten    = 0;
    LONG  cbSize       = 0;
    LONG  cbRemaining  = pmdtc->lImageSize; //pmdtc->lBufferSize - pmdtc->lHeaderSize;
    PBYTE pBuf         = pmdtc->pTransferBuffer + pmdtc->lHeaderSize;
    LONG  lItemSize    = pmdtc->lHeaderSize;
    BOOL  bSwapBGRData = TRUE;
    BOOL  bDWORDAlign  = TRUE;
    BOOL  bVerticalFlip= TRUE;
    LONG  lScanPhase   = SCAN_START;
    pmdtc->cbOffset    = 0;
    BOOL bBitmapData   = ((pmdtc->guidFormatID == WiaImgFmt_BMP) || (pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP));
    LONG PercentComplete = 0;

    //
    //  This must be a callback transfer request
    //

    if ((pmdtc->pIWiaMiniDrvCallBack == NULL) ||
        (!pmdtc->bTransferDataCB)) {
        WIAS_LERROR(m_pIWiaLog,
                    WIALOG_NO_RESOURCE_ID,
                    ("ScanItemCB, invalid callback params"));
        return E_INVALIDARG;
    }

    if (bBitmapData) {

        //
        //  SEND BITMAPHEADER to client
        //

        hr = SendBitmapHeader(pmdtc);
        if (hr != S_OK) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, SendBitmapHeader failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        //
        // check to see if the color data needs to be swapped
        //

        hr = m_pScanAPI->IsColorDataBGR(&bSwapBGRData);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, IsColorDataBGR() Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        //
        // check to see if data needs to be aligned
        //

        hr = m_pScanAPI->IsAlignmentNeeded(&bDWORDAlign);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, IsAlignmentNeeded() Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

    }

    //
    // scan until buffer runs out or scanner completes transfer
    //

    while ((lScanPhase == SCAN_START) || (cbWritten)) {

        //
        // assign the pointer to the transfer buffer
        //

        pBuf = pmdtc->pTransferBuffer;

        cbSize = m_MaxBufferSize; // default

        if (bBitmapData) {

            //
            // Limit requests to requested buffer size or less.
            //

            cbSize = (cbRemaining > pmdtc->lBufferSize) ? pmdtc->lBufferSize : cbRemaining;

            //
            // Request size to scanner must be modula the raw bytes per scan row.
            // Enough space for the alignment padding must be reserved.
            // These are requirements for AlignInPlace
            //

            cbSize = (cbSize / pItemContext->lBytesPerScanLine) *
                     pItemContext->lBytesPerScanLineRaw;

            //
            // check if finished
            //

            if (cbSize == 0) {
                break;
            }
        }

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  lScanPhase indicates whether this is the first call to Scan,
        //  pBuf is a pointer to the buffer, cbSize is the amount of data
        //  requested from the scanner, and cbWritten will be set to the actual
        //  amount of data returned by the scanner.
        //

        hr = m_pScanAPI->Scan(lScanPhase, pBuf, cbSize, &cbWritten);

        //
        // set flag to SCAN_CONTINUE, for other calls
        //

        lScanPhase = SCAN_CONTINUE;

        if (hr == S_OK) {

            if (cbWritten) {

                if (bBitmapData) {

                    //
                    // Place the scan data in correct byte order for 3 bytes ber pixel data.
                    //

                    if ((pmdtc->lDepth == 24)) {

                        //
                        // swap data if needed
                        //

                        if (bSwapBGRData) {
                            SwapBuffer24(pBuf, cbWritten);
                        }
                    }

                    //
                    // Align the data on DWORD boundries.
                    //

                    if (bDWORDAlign) {
                        cbWritten = AlignInPlace(pBuf,
                                                 cbWritten,
                                                 pItemContext->lBytesPerScanLine,
                                                 pItemContext->lBytesPerScanLineRaw);
                    }
                }

                //
                // advance buffer
                //

                cbRemaining -= cbWritten;

                //
                // If a status callback was specified callback the class driver.
                // There has to be a callback provided, this is the callback
                // transfer.
                //

                if (pmdtc->pIWiaMiniDrvCallBack) {

                    FLOAT FractionComplete = 0.0f;

                    if ((pmdtc->lImageSize + pmdtc->lHeaderSize)) {
                        if (bBitmapData) {
                            PercentComplete  = 0;
                            FractionComplete = (FLOAT) (pmdtc->cbOffset + cbWritten) /
                                               (FLOAT) (pmdtc->lImageSize + pmdtc->lHeaderSize);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItemCB, pmdtc->lBufferSize = 0!"));
                    }

                    //
                    // calculate percent complete
                    //

                    if (bBitmapData) {
                        PercentComplete = (LONG)(100 * FractionComplete);
                    } else {
                        PercentComplete += 25;
                        if (PercentComplete >= 100) {
                            PercentComplete = 90;
                        }
                    }

                    //
                    // call back client with status on the transfer and data offset
                    //

                    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                                      PercentComplete,
                                                                      pmdtc->cbOffset,
                                                                      cbWritten,
                                                                      pmdtc,
                                                                      0);

                    //
                    // check for user cancel
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItemCB, Transfer canceled by client (IT_MSG_DATA callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItemCB, MiniDrvCallback failed (IT_MSG_DATA callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }
                }

                //
                // move offset
                //

                pmdtc->cbOffset += cbWritten;
            }

        } else {

            //
            //  Get the device error
            //

            if (plDevErrVal) {
                *plDevErrVal = (LONG) hr;
                WIAS_LERROR(m_pIWiaLog,
                            WIALOG_NO_RESOURCE_ID,
                            ("ScanItemCB, data transfer failed, status: 0x%X", hr));
            }

            break;
        }
    }

    HRESULT Temphr = m_pScanAPI->Scan(SCAN_END, NULL, 0, NULL);
    if(FAILED(Temphr)){
        WIAS_LERROR(m_pIWiaLog,
                    WIALOG_NO_RESOURCE_ID,
                    ("ScanItemCB, Ending a scanning session failed"));
        return Temphr;
    }

    if (!bBitmapData) {

        //
        // call back client to show 100% with status on the transfer and data offset
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100,
                                                          pmdtc->cbOffset,
                                                          cbWritten,
                                                          pmdtc,
                                                          0);
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvAcquireItemData
*
*   This driver entry point is called when image data is requested from the
*   device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   pmdtc           - Pointer to mini driver context. On entry, only the
*                     portion of the mini driver context which is derived
*                     from the item properties is filled in.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvAcquireItemData");
    HRESULT hr = S_OK;
    BOOL bBitmapData   = ((pmdtc->guidFormatID == WiaImgFmt_BMP) || (pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP));
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetDrvItem() failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // Validate the data transfer context.
    //

    hr = ValidateDataTransferContext(pmdtc);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ValidateDataTransferContext() failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    //  Get item specific driver data
    //

    PMINIDRIVERITEMCONTEXT  pItemContext = NULL;

    hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, NULL item context"));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // allocate a buffer to be used for the data transfer.  This will only happen, when the
    // the data format is non-bitmap. Item Size is set to 0, telling the WIA service, that
    // we will be allocating the buffer for transfer.
    //

    if (!pmdtc->bClassDrvAllocBuf) {

        LONG lClassDrvAllocSize = m_MaxBufferSize + BUFFER_PAD; // max buffer band size
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Attempting to Allocate (%d)bytes for pmdtc->pTransferBuffer",lClassDrvAllocSize));

        pmdtc->pTransferBuffer = (PBYTE) CoTaskMemAlloc(lClassDrvAllocSize);
        if (!pmdtc->pTransferBuffer) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, unable to allocate temp transfer buffer, size: %d",(pmdtc->lImageSize + pmdtc->lHeaderSize)));
            return E_OUTOFMEMORY;
        }

        //
        // set new buffer size
        //

        pmdtc->lBufferSize = lClassDrvAllocSize;
    }

    if (bBitmapData) {

        //
        //  Use WIA services to fetch format specific info.  This information
        //  is based on the property settings.
        //

        hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);

        if (hr != S_OK) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetImageInformation failed."));
            WIAS_LHRESULT(m_pIWiaLog,hr);
            return hr;
        }

    }

    //
    // Check if we are in Preview Mode
    //

    if(IsPreviewScan(pWiasContext)){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Preview Property is SET"));
        m_pScanAPI->SetScanMode(SCANMODE_PREVIEWSCAN);
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Preview Property is NOT SET"));
        m_pScanAPI->SetScanMode(SCANMODE_FINALSCAN);
    }

    //
    // Get number of pages requested, for ADF scanning loop
    //

    BOOL bEmptyTheADF = FALSE;
    LONG lPagesRequested = GetPageCount(pWiasContext);
    if (lPagesRequested == 0) {
        bEmptyTheADF    = TRUE;
        lPagesRequested = 1;// set to 1 so we can enter our loop
                            // WIA_STATUS_END_OF_MEDIA will terminate
                            // the loop...or an error, or a cancel..
                            //
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages to Scan = %d",lPagesRequested));

    if (IsADFEnabled(pWiasContext)) { // FEEDER is enabled for scanning

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Feeder is enabled for use"));

        //
        // clear an potential paper that may be blocking the
        // scan pathway.
        //

        hr = m_pScanAPI->ADFUnFeedPage();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (begin transfer) Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

    } else {            // FLATBED is enabled for scanning

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Feeder is disabled or no feeder exists"));

        //
        // Transfer only a single image
        //

        bEmptyTheADF    = FALSE;
        lPagesRequested = 1;
    }

    //
    // WIA document scanning loop
    //

    LONG lPagesScanned      = 0;        // number of pages currently scanned
    BOOL bCallBackTransfer  = FALSE;    // callback transfer flag
    while (lPagesRequested > 0) {

        if (IsADFEnabled(pWiasContext)) {

            //
            // Check feeder for paper
            //

            hr = m_pScanAPI->ADFHasPaper();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFHasPaper Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            } else if(hr == S_FALSE){
                return WIA_ERROR_PAPER_EMPTY;
            }

            //
            // Attempt to load a page (only if needed)
            //

            hr = m_pScanAPI->ADFFeedPage();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFFeedPage Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // Check feeder's status
            //

            hr = m_pScanAPI->ADFStatus();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFStatus Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }
        }

        if (bBitmapData) {

            //
            // update image information
            //

            hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetImageInformation Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

        }

        //
        //  Determine if this is a callback or file transfer.
        //

        if (pmdtc->tymed == TYMED_CALLBACK) {

            //
            // Scan the page to memory
            //

            bCallBackTransfer = TRUE;

            hr = ScanItemCB(pItemContext,
                            pmdtc,
                            plDevErrVal);

        } else {

            //
            // Scan the page to file
            //

            hr = ScanItem(pItemContext,
                          pmdtc,
                          plDevErrVal);

        }

        if (!bEmptyTheADF) {

            //
            // update pages requested counter
            //

            lPagesRequested--;
        }

        if (hr == S_FALSE) {

            //
            // user canceled the scan
            //

            lPagesRequested = 0; // set pages to 0 to cleanly exit loop
        }

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages left to scan = %d",lPagesRequested));

        if (IsADFEnabled(pWiasContext)) {

            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Unloading a page from the feeder"));

            //
            // Attempt to unload the scanned page (only if needed)
            //

            hr = m_pScanAPI->ADFUnFeedPage();
            if (SUCCEEDED(hr)) {
                if (bCallBackTransfer) {

                    //
                    // send the NEW_PAGE message, when scanning multiple pages
                    // in callback mode.  This will let the calling application
                    // know when an end-of-page has been hit.
                    //

                    hr = wiasSendEndOfPage(pWiasContext, lPagesScanned, pmdtc);
                    if (FAILED(hr)) {
                        lPagesRequested = 0;
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasSendEndOfPage Failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                }

                //
                // increment pages scanned counter
                //

                lPagesScanned++;
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (end transfer) Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }
        }

        //
        // free any allocated memory between scans to avoid memory leaks
        //

        if (!pmdtc->bClassDrvAllocBuf) {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (single scan operation complete)"));
            if (NULL != pmdtc->pTransferBuffer) {
                CoTaskMemFree(pmdtc->pTransferBuffer);
                pmdtc->pTransferBuffer = NULL;
            }
        }

        if (IsADFEnabled(pWiasContext)) { // FEEDER is enabled for scanning

            //
            // Check feeder for paper, to avoid error conditions
            //

            hr = m_pScanAPI->ADFHasPaper();
            if (S_FALSE == hr) {

                LONG lPages = GetPageCount(pWiasContext);

                //
                // have we scanned more than 1 page?
                //

                if(lPagesScanned > 0){

                    //
                    // Pages is set to n, and we successfully scanned n pages, return S_OK
                    //

                    if(lPagesScanned == lPages){
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, We are out of paper, but we successfully scanned the requested amount"));
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, returning S_OK"));
                        return S_OK;
                    }

                    //
                    // Pages is set to 0, and 1 or more pages have been scanned, return S_OK
                    //

                    if(lPages == 0){
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, We are out of paper, but we successfully scanned more than 1 page"));
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, returning S_OK"));
                        return S_OK;
                    }

                    //
                    // Pages is set to n, and we successfully scanned lPagesScanned but
                    // that is less than n...and the file is OK, return WIA_STATUS_END_OF_MEDIA
                    //

                    if ((lPages > 0)&&(lPagesScanned < lPages)) {
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, We are out of paper, but we successfully scanned more than 1 page..but less than requested"));
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, returning WIA_STATUS_END_OF_MEDIA"));
                        return WIA_STATUS_END_OF_MEDIA;
                    }
                }
            }
        }
    }

    //
    // we are now finished scanning all documents
    //

    if (!pmdtc->bClassDrvAllocBuf) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (entire scan operation complete)"));
        if (NULL != pmdtc->pTransferBuffer) {
            CoTaskMemFree(pmdtc->pTransferBuffer);
            pmdtc->pTransferBuffer = NULL;
        }
    }

    return hr;
}

/**************************************************************************\
* IsPreviewScan
*
*   Get the current preview setting from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    TRUE - Preview is set, FALSE - Final is set
*
* History:
*
*    8/10/2000 Original Version
*
\**************************************************************************/

BOOL CWIAScannerDevice::IsPreviewScan(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::IsPreviewScan");
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, No Preview Property Found on ROOT item!"));
        return FALSE;
    }

    //
    //  Get the current preview setting.
    //

    LONG lPreview = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PREVIEW, &lPreview, NULL, true);
    if (hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, Failed to read Preview Property."));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return FALSE;
    }

    return (lPreview > 0);
}

/**************************************************************************\
* IsADFEnabled
*
*   Get the current Document Handling Select setting from the item properties.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    TRUE - enabled, FALSE - disabled
*
* History:
*
*    5/01/2001 Original Version
*
\**************************************************************************/
BOOL CWIAScannerDevice::IsADFEnabled(BYTE *pWiasContext)
{
    HRESULT hr = S_OK;
    BOOL bEnabled = FALSE;
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (SUCCEEDED(hr)) {

        //
        // read Document Handling Select property value
        //

        LONG lDocumentHandlingSelect = FLATBED;
        hr = wiasReadPropLong(pRootItemCtx,WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocumentHandlingSelect,NULL,TRUE);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsADFEnabled, wiasReadPropLong(WIA_DPS_DOCUMENT_HANDLING_SELECT) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        } else {
            if (lDocumentHandlingSelect & FEEDER) {

                //
                // FEEDER is set
                //

                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("IsADFEnabled - ADF Enabled"));
                bEnabled = TRUE;
            } else {

                //
                // FEEDER is not set, default to FLATBED (WIAFBDRV only supports simple Document feeders at this time)
                //

                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("IsADFEnabled  - ADF Disabled"));
                bEnabled = FALSE;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsADFEnabled, wiasGetRootItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }
    return bEnabled;
}

/**************************************************************************\
* GetPageCount
*
*   Get the requested number of pages to scan from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    Number of pages to scan.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

LONG CWIAScannerDevice::GetPageCount(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetPageCount");
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return 1;
    }

    //
    //  Get the requested page count.
    //

    LONG lPagesRequested = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PAGES, &lPagesRequested, NULL, true);
    if (hr != S_OK) {
        return 1;
    }

    return lPagesRequested;
}

/**************************************************************************\
* SetItemSize
*
*   Calulate the new item size, and write the new Item Size property value.
*
* Arguments:
*
*   pWiasContext       - item
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SetItemSize(
    BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SetItemSize");
    HRESULT  hr = S_OK;
    LONG lWidthInBytes = 0;
    LONG lMinBufSize   = 0;
    GUID guidFormatID  = GUID_NULL;
    MINIDRV_TRANSFER_CONTEXT mdtc;

    LONG lNumProperties = 3;
    PROPVARIANT pv[3];
    PROPSPEC ps[3] = {{PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
                      {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
                      {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE}};

    //
    //  Clear the MiniDrvTransferContext
    //

    memset(&mdtc,0,sizeof(MINIDRV_TRANSFER_CONTEXT));

    //
    // read format GUID
    //

    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &guidFormatID, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_FORMAT error"));
        return hr;
    }

    //
    // read TYMED
    //

    hr = wiasReadPropLong(pWiasContext,WIA_IPA_TYMED, (LONG*)&mdtc.tymed, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_TYMED error"));
        return hr;
    }

    if ((guidFormatID == WiaImgFmt_BMP)||(guidFormatID == WiaImgFmt_MEMORYBMP)) {

        //
        // wias works for DIB, or uncompressed standard TIFF formats
        // Standard TIFFs are constructed using a DIB-like implementation.
        // The data is stored as one huge strip, rather than multiple smaller
        // strips.
        //

        hr = wiasGetImageInformation(pWiasContext, WIAS_INIT_CONTEXT, &mdtc);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, could not get image information"));
            return hr;
        }

    } else {

        //
        // manually set the data transfer context members
        //

        mdtc.lImageSize     = 0;
        mdtc.lHeaderSize    = 0;
        mdtc.lItemSize      = 0;
        mdtc.cbWidthInBytes = 0;

    }

    //
    //  Set the MinBufferSize property.  MinBufferSize is the minimum buffer
    //  that a client can request for a data transfer.
    //

    switch (mdtc.tymed) {
    case TYMED_CALLBACK:

        //
        // callback uses driver's minimum buffer size.
        // This is could be taken from the micro driver at
        // initialization time.
        //

        lMinBufSize = m_MinBufferSize;
        break;

    case TYMED_FILE:

        //
        // file transfers, require that the minimum buffer size be the
        // entire length of the file.
        //

        lMinBufSize = mdtc.lImageSize + mdtc.lHeaderSize;
        break;

    default:

        //
        // unknown TYMED
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, unknown tymed: 0x%08X", mdtc.tymed));
        return E_INVALIDARG;
    }

    //
    //  Initialize propvar's.  Then write the values.  Don't need to call
    //  PropVariantClear when done, since there are only LONG values.
    //

    for (int i = 0; i < lNumProperties; i++) {
        PropVariantInit(&pv[i]);
        pv[i].vt = VT_I4;
    }

    pv[0].lVal = mdtc.lItemSize;
    pv[1].lVal = mdtc.cbWidthInBytes;
    pv[2].lVal = lMinBufSize;

    //
    // Write WIA_IPA_ITEM_SIZE, WIA_IPA_BYTES_PER_LINE, and  WIA_IPA_MIN_BUFFER_SIZE
    // property values
    //

    hr = wiasWriteMultiple(pWiasContext, lNumProperties, ps, pv);
    if (SUCCEEDED(hr)) {

        //
        // Now update the MINIDRIVER TRANSFER CONTEXT with new values
        //

        //
        // Get a pointer to the associated driver item.
        //

        IWiaDrvItem* pDrvItem = NULL;

        hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
        if (FAILED(hr)) {
            return hr;
        }

        //
        // Get driver item's context
        //

        PMINIDRIVERITEMCONTEXT pItemContext = NULL;

        hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);
        if (SUCCEEDED(hr)) {
            if ((guidFormatID == WiaImgFmt_BMP)||(guidFormatID == WiaImgFmt_MEMORYBMP)) {

                //
                // Calculate how many scan lines will fit in the buffer.
                //

                pItemContext->lBytesPerScanLineRaw = ((mdtc.lWidthInPixels * mdtc.lDepth) + 7)  / 8;
                pItemContext->lBytesPerScanLine    = (((mdtc.lWidthInPixels * mdtc.lDepth) + 31) / 8) & 0xfffffffc;
                pItemContext->lTotalRequested      = pItemContext->lBytesPerScanLineRaw * mdtc.lLines;
            } else {
                pItemContext->lBytesPerScanLineRaw = 0;
                pItemContext->lBytesPerScanLine    = 0;
                pItemContext->lTotalRequested      = 0;
            }
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvWriteItemProperties, NULL item context"));
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, WriteMultiple failed"));
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvInitItemProperties
*
*   Initialize the device item properties. Called during item
*   initialization.  This is called by the WIA Class driver
*   after the item tree has been built.  It is called once for every
*   item in the tree.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA context (item information).
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvInitItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvInitItemProperties");
    HRESULT hr = S_OK;

    //
    //  This device doesn't touch hardware to initialize the device item
    //  properties, so set plDevErrVal to 0.
    //

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    //
    //  Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasGetDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Set initial item properties.
    //

    LONG    lItemType = 0;

    pDrvItem->GetItemFlags(&lItemType);

    if (lItemType & WiaItemTypeRoot) {

        //
        //  This is for the root item.
        //

        //
        // Build Root Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildRootItemProperties();

        if(FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildRootItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Add the device specific root item property names,
        //  using WIA service.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_NumRootItemProperties,
                                  m_piRootItemDefaults,
                                  m_pszRootItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_piRootItemDefaults   = %x",m_piRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszRootItemDefaults  = %x",m_pszRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Set the device specific root item properties to
        //  their default values using WIA service.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_NumRootItemProperties,
                               m_psRootItemDefaults,
                               m_pvRootItemDefaults);
        //
        // Free PROPVARIANT array, This frees any memory that was allocated for a prop variant value.
        //

        // FreePropVariantArray(m_NumRootItemProperties,m_pvRootItemDefaults);


        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszRootItemDefaults  = %x",m_pszRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pvRootItemDefaults   = %x",m_pvRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_NumRootItemProperties,
                                     m_psRootItemDefaults,
                                     m_wpiRootItemDefaults);

        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_psRootItemDefaults   = %x",m_psRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_wpiRootItemDefaults  = %x",m_wpiRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteRootItemProperties();


    } else {

        //
        //  This is for the child item.(Top)
        //

        //
        // Build Top Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildTopItemProperties();

        if(FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildTopItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use the WIA service to set the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_NumItemProperties,
                                  m_piItemDefaults,
                                  m_pszItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_piItemDefaults   = %x",m_piItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszItemDefaults  = %x",m_pszItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the item properties to their default
        //  values.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_NumItemProperties,
                               m_psItemDefaults,
                               (PROPVARIANT*)m_pvItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszItemDefaults  = %x",m_pszItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pvItemDefaults   = %x",m_pvItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_NumItemProperties,
                                     m_psItemDefaults,
                                     m_wpiItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_psItemDefaults   = %x",m_psItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_wpiItemDefaults  = %x",m_wpiItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Set item size properties.
        //

        hr = SetItemSize(pWiasContext);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, SetItemSize failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteTopItemProperties();
    }
    return hr;
}


/**************************************************************************\
* CWIAScannerDevice::drvValidateItemProperties
*
*   Validate the device item properties.  It is called when changes are made
*   to an item's properties.  Driver should not only check that the values
*   are valid, but must update any valid values that may change as a result.
*   If an a property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   nPropSpec       - The number of properties that are being written
*   pPropSpec       - An array of PropSpecs identifying the properties that
*                     are being written.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
***************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvValidateItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvValidateItemProperties");

    HRESULT hr      = S_OK;
    LONG lItemType  = 0;
    WIA_PROPERTY_CONTEXT Context;

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (SUCCEEDED(hr)) {
        if (lItemType & WiaItemTypeRoot) {

            //
            //  Validate root item
            //


            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                // Check ADF to see if the status settings need to be updated
                // Also switch between FEEDER/FLATBED modes
                //

                hr = CheckADFStatus(pWiasContext, &Context);
                if(FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckADFStatus failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // check Preview Property only if validation is successful so far....
                //

                if (SUCCEEDED(hr)) {

                    //
                    // Check Preview property to see if the settings are valid
                    //

                    hr = CheckPreview(pWiasContext, &Context);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreview failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                }
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Root Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            // call WIA service helper to validate other properties
            //

            if (SUCCEEDED(hr)) {
                hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                    return hr;
                }
            }

        } else {

            //
            // validate item properties here
            //

            //
            //  Create a property context needed by some WIA Service
            //  functions used below.
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                //  Check Current Intent first
                //

                hr = CheckIntent(pWiasContext, &Context);
                if (SUCCEEDED(hr)) {

                    //
                    //  Check if DataType is being written
                    //

                    hr = CheckDataType(pWiasContext, &Context);
                    if (SUCCEEDED(hr)) {
#ifdef _SERVICE_EXTENT_VALIDATION

                        //
                        //  Use the WIA service to update the scan rect
                        //  properties and valid values.
                        //

                        LONG lBedWidth  = 0;
                        LONG lBedHeight = 0;
                        hr = m_pScanAPI->GetBedWidthAndHeight(&lBedWidth,&lBedHeight);
                        if(FAILED(hr)){
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, m_pScanAPI->GetBedWidthAndHeight failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                            return hr;
                        }

                        hr = wiasUpdateScanRect(pWiasContext,
                                                &Context,
                                                lBedWidth,
                                                lBedHeight);

#endif
                        if (SUCCEEDED(hr)) {

                            //
                            //  Use the WIA Service to update the valid values
                            //  for Format.  These are based on the value of
                            //  WIA_IPA_TYMED, so validation is also performed
                            //  on the tymed property by the service.
                            //

                            hr = wiasUpdateValidFormat(pWiasContext,
                                                       &Context,
                                                       (IWiaMiniDrv*) this);

                            if (SUCCEEDED(hr)) {

                                //
                                // Check Preferred format
                                //

                                hr = CheckPreferredFormat(pWiasContext, &Context);
                                if(FAILED(hr)){
                                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreferredFormat failed"));
                                    WIAS_LHRESULT(m_pIWiaLog, hr);
                                }
                            } else {
                                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateValidFormat failed"));
                                WIAS_LHRESULT(m_pIWiaLog, hr);
                            }
                        } else {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateScanRect failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckDataType failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckIntent failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
                wiasFreePropContext(&Context);
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Child Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            //  Update the item size
            //

            if (SUCCEEDED(hr)) {
                hr = SetItemSize(pWiasContext);
                if(FAILED(hr)){
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // call WIA service helper to validate other properties
                //

                if (SUCCEEDED(hr)) {
                    hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        return hr;
                    }
                }
            }

        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    //
    // log HRESULT sent back to caller
    //

    if(FAILED(hr)){
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.  This is called by the
*   WIA Class driver prior to drvAcquireItemData when the client requests
*   a data transfer.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvWriteItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvWriteItemProperties");
    HRESULT hr = S_OK;
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    LONG lNumProperties = 10;
    PROPVARIANT pv[10];

    //
    // The order of these should not change. They are referenced below
    // by index.
    //

    PROPSPEC ps[10] = {
        {PRSPEC_PROPID, WIA_IPS_XRES},
        {PRSPEC_PROPID, WIA_IPS_YRES},
        {PRSPEC_PROPID, WIA_IPS_XPOS},
        {PRSPEC_PROPID, WIA_IPS_YPOS},
        {PRSPEC_PROPID, WIA_IPS_XEXTENT},
        {PRSPEC_PROPID, WIA_IPS_YEXTENT},
        {PRSPEC_PROPID, WIA_IPA_DATATYPE},
        {PRSPEC_PROPID, WIA_IPS_BRIGHTNESS},
        {PRSPEC_PROPID, WIA_IPS_CONTRAST},
        {PRSPEC_PROPID, WIA_IPA_FORMAT}
    };

    //
    // initialize propvariant structures
    //

    for (int i = 0; i< lNumProperties;i++) {
        pv[i].vt = VT_I4;
    }

    //
    // read child item properties
    //

    hr = wiasReadMultiple(pWiasContext, lNumProperties, ps, pv, NULL);

    if (hr == S_OK) {

        hr = m_pScanAPI->SetXYResolution(pv[0].lVal,pv[1].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting x any y resolutions failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetDataType(pv[6].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting data type failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetIntensity(pv[7].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting intensity failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetContrast(pv[8].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting contrast failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetSelectionArea(pv[2].lVal, pv[3].lVal, pv[4].lVal, pv[5].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting selection area (extents) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetFormat((GUID*)pv[9].puuid);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting current format failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            PropVariantClear(&pv[9]);
            return hr;
        }
        PropVariantClear(&pv[9]);
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvReadItemProperties
*
*   Read the device item properties.  When a client application tries to
*   read a WIA Item's properties, the WIA Class driver will first notify
*   the driver by calling this method.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvReadItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvReadItemProperties");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    return S_OK;
}

/**************************************************************************\
* CWIAScannerDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvLockWiaDevice");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    return m_pStiDevice->LockDevice(m_dwLockTimeout);
}

/**************************************************************************\
* CWIAScannerDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvUnLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvUnLockWiaDevice");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWIAScannerDevice::drvAnalyzeItem
*
*   This device does not support image analysis, so return E_NOTIMPL.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvAnalyzeItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvAnalyzeItem");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    return E_NOTIMPL;
}

/**************************************************************************\
* CWIAScannerDevice::drvFreeDrvItemContext
*
*   Free any device specific context.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvFreeDrvItemContext(
    LONG                        lFlags,
    BYTE                        *pSpecContext,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvFreeDrvItemContext");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    PMINIDRIVERITEMCONTEXT pContext = NULL;
    pContext = (PMINIDRIVERITEMCONTEXT) pSpecContext;

    if (pContext){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvFreeDrvItemContext, Freeing my allocated context members"));
    }

    return S_OK;
}

/**************************************************************************\
* CWIAScannerDevice::drvInitializeWia
*
*   Initialize the WIA mini driver.  This will build up the driver item tree
*   and perform any other initialization code that's needed for WIA.
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvInitializeWia(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    BSTR                        bstrDeviceID,
    BSTR                        bstrRootFullItemName,
    IUnknown                    *pStiDevice,
    IUnknown                    *pIUnknownOuter,
    IWiaDrvItem                 **ppIDrvItemRoot,
    IUnknown                    **ppIUnknownInner,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvInitializeWia");
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrDeviceID         = %ws", bstrDeviceID));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrRootFullItemName = %ws",bstrRootFullItemName));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, lFlags               = %d",lFlags));
    HRESULT hr = S_OK;

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;

    //
    //  Need to init names and STI pointer?
    //

    if (m_pStiDevice == NULL) {

        //
        // save STI device interface for locking
        //

        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID.
        //

        m_bstrDeviceID = SysAllocString(bstrDeviceID);

        if (!m_bstrDeviceID) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate device ID string"));
            return E_OUTOFMEMORY;
        }

        //
        // Cache the root property stream name.
        //

        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (!m_bstrRootFullItemName) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate prop stream name"));
            return E_OUTOFMEMORY;
        }
    }

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if(FAILED(hr)) {
        DeleteCapabilitiesArrayContents();
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize SupportedFormats array
    //

    hr = BuildSupportedFormats();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Data Type array
    //

    hr = BuildSupportedDataTypes();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedDataTypes failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Intents array
    //

    hr = BuildSupportedIntents();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedIntents failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported TYMED array
    //

    hr = BuildSupportedTYMED();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSuportedTYMED failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported compression types array
    //

    hr = BuildSupportedCompressions();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedCompressions"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported Preview modes array
    //

    hr = BuildSupportedPreviewModes();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedPreviewModes"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  initial formats array
    //

    hr = BuildInitialFormats();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildInitialFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize supported resolutions array
    //

    hr = BuildSupportedResolutions();
    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedResolutions failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Build the device item tree, if it hasn't been built yet.
    //
    //  Send a Device Command to yourself, or Call BuildItemTree manually
    //

    if (!m_pIDrvItemRoot) {
        LONG    lDevErrVal = 0;
        hr = drvDeviceCommand(NULL, 0, &WIA_CMD_SYNCHRONIZE, NULL, &lDevErrVal);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, drvDeviceCommand(WIA_CMD_SYNCHRONIZE) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
    }

    //
    // save root item pointer. (REMEMBER TO RELEASE THIS INTERFACE)
    //

    *ppIDrvItemRoot = m_pIDrvItemRoot;

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
* Return Value:
*    Status
*
* History:
*
*   7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvUnInitializeWia(
    BYTE                *pWiasContext)
{
    return S_OK;
}


/**************************************************************************\
* drvGetDeviceErrorStr
*
*   Map a device error value to a string.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetDeviceErrorStr(
    LONG                        lFlags,
    LONG                        lDevErrVal,
    LPOLESTR                    *ppszDevErrStr,
    LONG                        *plDevErr)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetDeviceErrorStr");
    HRESULT hr = S_OK;

    //
    //  Map device errors to a string to be placed in the event log.
    //

    if (plDevErr) {
        if (*ppszDevErrStr) {

            //
            // look up error strings in resource file.
            //

            switch (lDevErrVal) {
            case 0:
                *ppszDevErrStr = L"No Error";                   // hard coded for now
                *plDevErr  = 0;
                hr = S_OK;
                break;
            default:
                *ppszDevErrStr = L"Device Error, Unknown Error";// hard coded for now
                *plDevErr  = 0;
                hr = E_FAIL;
                break;
            }
        }
    }
    return hr;
}

/**************************************************************************\
* drvDeviceCommand
*
*   Issue a command to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   plCommand       - Pointer to command GUID.
*   ppWiaDrvItem    - Optional pointer to returned item, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvDeviceCommand(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    const GUID                  *plCommand,
    IWiaDrvItem                 **ppWiaDrvItem,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvDeviceCommand");
    if(plDevErrVal){
        *plDevErrVal = 0;
    }

    HRESULT hr = S_OK;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        //
        // SYNCHRONIZE - Build the minidriver representation of
        //               the current item list, if it doesn't exist.
        //

        if (!m_pIDrvItemRoot) {
            hr = BuildItemTree();
        } else {
            hr = S_OK;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, unknown command sent to this device"));
        hr = E_NOTIMPL;
    }

    return hr;
}


/**************************************************************************\
* CWIAScannerDevice::drvGetCapabilities
*
*   Get supported device commands and events as an array of WIA_DEV_CAPS.
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned GUID array.
*   ppCapabilities - Pointer to returned GUID array.
*   plDevErrVal    - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetCapabilities(
    BYTE                        *pWiasContext,
    LONG                        ulFlags,
    LONG                        *pcelt,
    WIA_DEV_CAP_DRV             **ppCapabilities,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetCapabilites");
    if(plDevErrVal){
        *plDevErrVal = 0;
    }

    HRESULT hr = S_OK;

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if(FAILED(hr)) {
        DeleteCapabilitiesArrayContents();
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Return depends on flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    //

    switch (ulFlags) {
    case WIA_DEVICE_COMMANDS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS)"));

        //
        //  report commands only
        //

        *pcelt          = m_NumSupportedCommands;
        *ppCapabilities = &m_pCapabilities[m_NumSupportedEvents];
        break;
    case WIA_DEVICE_EVENTS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_EVENTS)"));

        //
        //  report events only
        //

        *pcelt          = m_NumSupportedEvents;
        *ppCapabilities = m_pCapabilities;
        break;
    case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS|WIA_DEVICE_EVENTS)"));

        //
        //  report both events and commands
        //

        *pcelt          = m_NumCapabilities;
        *ppCapabilities = m_pCapabilities;
        break;
    default:

        //
        //  invalid request
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, invalid flags"));
        return E_INVALIDARG;
    }
    return hr;
}

/**************************************************************************\
* drvGetWiaFormatInfo
*
*   Returns an array of WIA_FORMAT_INFO structs, which specify the format
*   and media type pairs that are supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*   7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetWiaFormatInfo");

    HRESULT hr = S_OK;

    if(NULL == m_pSupportedFormats){
        hr = BuildSupportedFormats();
    }

    if(plDevErrVal){
        *plDevErrVal = 0;
    }
    *pcelt       = m_NumSupportedFormats;
    *ppwfi       = m_pSupportedFormats;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_NumSupportedFormats = %d",m_NumSupportedFormats));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_pSupportedFormats   = %x",m_pSupportedFormats));
    return hr;
}

/**************************************************************************\
* drvNotifyPnpEvent
*
*   Pnp Event received by device manager.  This is called when a Pnp event
*   is received for this device.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvNotifyPnpEvent(
    const GUID                  *pEventGUID,
    BSTR                        bstrDeviceID,
    ULONG                       ulReserved)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvNotifyPnpEvent");
    HRESULT hr = S_OK;

    if (*pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (WIA_EVENT_DEVICE_DISCONNECTED)"));
        hr = m_pScanAPI->DisableDevice();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, disable failed"));
        }
    }

    if (*pEventGUID == WIA_EVENT_POWER_SUSPEND){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (WIA_EVENT_POWER_SUSPEND)"));
        hr = m_pScanAPI->DisableDevice();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, disable failed"));
        }
    }

    if (*pEventGUID == WIA_EVENT_POWER_RESUME){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (WIA_EVENT_POWER_RESUME)"));
        hr = m_pScanAPI->EnableDevice();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, enable failed"));
        }

        if (NULL != m_hSignalEvent) {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (restarting interrrupt event system)"));
            hr = SetNotificationHandle(m_hSignalEvent);
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, SetNotificationHandle failed"));
            }
        } else {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (not restarting interrrupt event system), device may not need it."));
        }
    }

    return hr;
}


/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* AlignInPlace
*
*   DWORD align a data buffer in place.
*
* Arguments:
*
*   pBuffer              - Pointer to the data buffer.
*   cbWritten            - Size of the data in bytes.
*   lBytesPerScanLine    - Number of bytes per scan line in the output data.
*   lBytesPerScanLineRaw - Number of bytes per scan line in the input data.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

UINT CWIAScannerDevice::AlignInPlace(
   PBYTE pBuffer,
   LONG  cbWritten,
   LONG  lBytesPerScanLine,
   LONG  lBytesPerScanLineRaw)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::AlignInPlace");
    if (lBytesPerScanLineRaw % 4) {

      UINT  uiPadBytes          = lBytesPerScanLine - lBytesPerScanLineRaw;
      UINT  uiDevLinesWritten   = cbWritten / lBytesPerScanLineRaw;

      PBYTE pSrc = pBuffer + cbWritten - 1;
      PBYTE pDst = pBuffer + (uiDevLinesWritten * lBytesPerScanLine) - 1;

      while (pSrc >= pBuffer) {
         pDst -= uiPadBytes;

         for (LONG i = 0; i < lBytesPerScanLineRaw; i++) {
            *pDst-- = *pSrc--;
         }
      }
      return uiDevLinesWritten * lBytesPerScanLine;
   }
   return cbWritten;
}

/**************************************************************************\
* UnlinkItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::DeleteItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::DeleteItemTree");
    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, no tree to delete..."));
        return S_OK;
    }

    //
    //  Call device manager to unlink the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    if (SUCCEEDED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, m_pIDrvItemRoot is being released!!"));
        m_pIDrvItemRoot->Release();
        m_pIDrvItemRoot = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildItemTree
*
*   The device uses the WIA Service functions to build up a tree of
*   device items. This device supports only a single data acquisition item so
*   build a device item tree with only one child off the root.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::BuildItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::BuildItemTree");
    //
    //  The device item tree must not exist.
    //

    WIAS_ASSERT( (g_hInst), (m_pIDrvItemRoot == NULL));

    //
    //  Call the class driver to create the root item.
    //

    HRESULT hr = E_FAIL;

    //
    //  Name the root.
    //

    BSTR bstrRootItemName = NULL;
    hr = GetBSTRResourceString(IDS_ROOTITEM_NAME,&bstrRootItemName,TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasCreateDrvItem(WiaItemTypeFolder |
                               WiaItemTypeDevice |
                               WiaItemTypeRoot,
                               bstrRootItemName,
                               m_bstrRootFullItemName,
                               (IWiaMiniDrv *)this,
                               sizeof(MINIDRIVERITEMCONTEXT),
                               NULL,
                               &m_pIDrvItemRoot);

        SysFreeString(bstrRootItemName);
    }

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Create and add the Top/Front and Bottom/Back device items.
    //

    for (INT i = 0; i < NUM_DEVICE_ITEM; i++) {

        //
        //  Build the item names.
        //

        BSTR bstrItemName = NULL;
        hr = GetBSTRResourceString(IDS_TOPITEM_NAME,&bstrItemName,TRUE);
        if (SUCCEEDED(hr)) {

            // SBB - RAID 370299 - orenr - 2001/04/18 - Security fix -
            // potential buffer overrun.  Changed wcscpy and wcscat
            // to use _snwprintf instead

            WCHAR  szFullItemName[MAX_PATH + 1] = {0};

            _snwprintf(szFullItemName,
                       (sizeof(szFullItemName) / sizeof(WCHAR)) - 1,
                       L"%ls\\%ls",
                       m_bstrRootFullItemName,
                       bstrItemName);

            //
            //  Call the class driver to create another driver item.
            //  This will be inserted as the child item.
            //

            PMINIDRIVERITEMCONTEXT pItemContext;
            IWiaDrvItem           *pItem = NULL;

            hr = wiasCreateDrvItem(WiaItemTypeFile  |
                                   WiaItemTypeImage |
                                   WiaItemTypeDevice,
                                   bstrItemName,
                                   szFullItemName,
                                   (IWiaMiniDrv *)this,
                                   sizeof(MINIDRIVERITEMCONTEXT),
                                   (PBYTE*) &pItemContext,
                                   &pItem);

            if (SUCCEEDED(hr)) {

                //
                // Initialize device specific context.
                //

                memset(pItemContext, 0, sizeof(MINIDRIVERITEMCONTEXT));
                pItemContext->lSize = sizeof(MINIDRIVERITEMCONTEXT);

                //
                //  Call the class driver to add pItem to the folder
                //  m_pIDrvItemRoot (i.e. make pItem a child of
                //  m_pIDrvItemRoot).
                //

                hr = pItem->AddItemToFolder(m_pIDrvItemRoot);

                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, AddItemToFolder failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // release and created items
                //

                pItem->Release();

            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            // free the BSTR allocated by the BSTRResourceString helper
            //

            SysFreeString(bstrItemName);

        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, unable to allocate item name"));
            hr = E_OUTOFMEMORY;
        }

        break;  // Error if here, quit iterating.
    }

    if (FAILED(hr)) {
        DeleteItemTree();
    }
    return hr;
}

/**************************************************************************\
* DeleteRootItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszRootItemDefaults - Property name  array         (LPOLESTR)
*   m_piRootItemDefaults  - Property ID array             (PROPID)
*   m_pvRootItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psRootItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiRootItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteRootItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedPreviewModesArrayContents();

    if(NULL != m_pszRootItemDefaults){
        delete [] m_pszRootItemDefaults;
        m_pszRootItemDefaults = NULL;
    }

    if(NULL != m_piRootItemDefaults){
        delete [] m_piRootItemDefaults;
        m_piRootItemDefaults = NULL;
    }

    if(NULL != m_pvRootItemDefaults){
        FreePropVariantArray(m_NumRootItemProperties,m_pvRootItemDefaults);
        delete [] m_pvRootItemDefaults;
        m_pvRootItemDefaults = NULL;
    }

    if(NULL != m_psRootItemDefaults){
        delete [] m_psRootItemDefaults;
        m_psRootItemDefaults = NULL;
    }

    if(NULL != m_wpiRootItemDefaults){
        delete [] m_wpiRootItemDefaults;
        m_wpiRootItemDefaults = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildRootItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszRootItemDefaults - Property name  array         (LPOLESTR)
*   m_piRootItemDefaults  - Property ID array             (PROPID)
*   m_pvRootItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psRootItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiRootItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildRootItemProperties");

    HRESULT hr = S_OK;

    if(m_pScanAPI->ADFAttached() == S_OK){
        m_bADFAttached = TRUE;
    }

    WIAPROPERTIES RootItemProperties;
    memset(&RootItemProperties,0,sizeof(RootItemProperties));

    // set host driver numeric values
    RootItemProperties.NumSupportedPreviewModes = m_NumSupportedPreviewModes;

    // set host driver allocated pointers
    RootItemProperties.pSupportedPreviewModes = m_pSupportedPreviewModes;

    hr = m_pScanAPI->BuildRootItemProperties(&RootItemProperties);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, m_pScanAPI->BuildRootItemProperties failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

    //
    // assign pointers to members
    //

    m_NumRootItemProperties = RootItemProperties.NumItemProperties;
    m_piRootItemDefaults    = RootItemProperties.piItemDefaults;
    m_psRootItemDefaults    = RootItemProperties.psItemDefaults;
    m_pszRootItemDefaults   = RootItemProperties.pszItemDefaults;
    m_pvRootItemDefaults    = RootItemProperties.pvItemDefaults;
    m_wpiRootItemDefaults   = RootItemProperties.wpiItemDefaults;

    return hr;
}

/**************************************************************************\
* DeleteTopItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszItemDefaults - Property name  array         (LPOLESTR)
*   m_piItemDefaults  - Property ID array             (PROPID)
*   m_pvItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteTopItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteTopItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedFormatsArrayContents();
    DeleteSupportedDataTypesArrayContents();
    DeleteSupportedCompressionsArrayContents();
    DeleteSupportedTYMEDArrayContents();
    DeleteInitialFormatsArrayContents();
    DeleteSupportedResolutionsArrayContents();

    if(NULL != m_pszItemDefaults){
        delete [] m_pszItemDefaults;
        m_pszItemDefaults = NULL;
    }

    if(NULL != m_piItemDefaults){
        delete [] m_piItemDefaults;
        m_piItemDefaults = NULL;
    }

    if(NULL != m_pvItemDefaults){
        for(LONG lPropIndex = 0; lPropIndex < m_NumItemProperties; lPropIndex++){

            //
            // set CLSID pointers to NULL, because we freed the memory above.
            // If this pointer is not NULL FreePropVariantArray would
            // try to free it again.
            //

            if(m_pvItemDefaults[lPropIndex].vt == VT_CLSID){
                m_pvItemDefaults[lPropIndex].puuid = NULL;
            }
        }
        FreePropVariantArray(m_NumItemProperties,m_pvItemDefaults);
        delete [] m_pvItemDefaults;
        m_pvItemDefaults = NULL;
    }

    if(NULL != m_psItemDefaults){
        delete [] m_psItemDefaults;
        m_psItemDefaults = NULL;
    }

    if(NULL != m_wpiItemDefaults){
        delete [] m_wpiItemDefaults;
        m_wpiItemDefaults = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildTopItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
*       [Array Name]        [Description]           [Array Type]
*
*   m_pszItemDefaults - Property name  array         (LPOLESTR)
*   m_piItemDefaults  - Property ID array             (PROPID)
*   m_pvItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildTopItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildTopItemProperties");

    HRESULT hr = S_OK;

    WIAPROPERTIES TopItemProperties;
    memset(&TopItemProperties,0,sizeof(TopItemProperties));

    // set host driver numeric values
    TopItemProperties.NumInitialFormats             = m_NumInitialFormats;
    TopItemProperties.NumSupportedCompressionTypes  = m_NumSupportedCompressionTypes;
    TopItemProperties.NumSupportedDataTypes         = m_NumSupportedDataTypes;
    TopItemProperties.NumSupportedFormats           = m_NumSupportedFormats;
    TopItemProperties.NumSupportedIntents           = m_NumSupportedIntents;
    TopItemProperties.NumSupportedTYMED             = m_NumSupportedTYMED;
    TopItemProperties.NumSupportedResolutions       = m_NumSupportedResolutions;

    // set host driver allocated pointers
    TopItemProperties.pInitialFormats               = m_pInitialFormats;
    TopItemProperties.pSupportedCompressionTypes    = m_pSupportedCompressionTypes;
    TopItemProperties.pSupportedDataTypes           = m_pSupportedDataTypes;
    TopItemProperties.pSupportedFormats             = m_pSupportedFormats;
    TopItemProperties.pSupportedIntents             = m_pSupportedIntents;
    TopItemProperties.pSupportedTYMED               = m_pSupportedTYMED;
    TopItemProperties.pSupportedResolutions         = m_pSupportedResolutions;
    TopItemProperties.bLegacyBWRestrictions         = m_bLegacyBWRestriction;

    hr = m_pScanAPI->BuildTopItemProperties(&TopItemProperties);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildTopItemProperties, m_pScanAPI->BuildTopItemProperties failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteTopItemProperties();
        return hr;
    }

    //
    // assign pointers to members
    //

    m_NumItemProperties = TopItemProperties.NumItemProperties;
    m_pszItemDefaults   = TopItemProperties.pszItemDefaults;
    m_piItemDefaults    = TopItemProperties.piItemDefaults;
    m_pvItemDefaults    = TopItemProperties.pvItemDefaults;
    m_psItemDefaults    = TopItemProperties.psItemDefaults;
    m_wpiItemDefaults   = TopItemProperties.wpiItemDefaults;

    return hr;
}

/**************************************************************************\
* BuildSupportedResolutions
*
*   This helper initializes the supported resolution array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedResolutions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedResolutions");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedResolutions) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedResolutions   = 6;
    m_pSupportedResolutions     = new LONG[m_NumSupportedResolutions];
    if(m_pSupportedResolutions){
        m_pSupportedResolutions[0] = 75;
        m_pSupportedResolutions[1] = 100;
        m_pSupportedResolutions[2] = 150;
        m_pSupportedResolutions[3] = 200;
        m_pSupportedResolutions[4] = 300;
        m_pSupportedResolutions[5] = 600;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedResolutionsArrayContents
*
*   This helper deletes the supported resolutions array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedResolutionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedResolutionsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedResolutions)
        delete [] m_pSupportedResolutions;

    m_pSupportedResolutions     = NULL;
    m_NumSupportedResolutions   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedIntents
*
*   This helper initializes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedIntents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedIntents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedIntents) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedIntents   = 6;
    m_pSupportedIntents     = new LONG[m_NumSupportedIntents];
    if(m_pSupportedIntents){
        m_pSupportedIntents[0] = WIA_INTENT_NONE;
        m_pSupportedIntents[1] = WIA_INTENT_IMAGE_TYPE_COLOR;
        m_pSupportedIntents[2] = WIA_INTENT_IMAGE_TYPE_GRAYSCALE;
        m_pSupportedIntents[3] = WIA_INTENT_IMAGE_TYPE_TEXT;
        m_pSupportedIntents[4] = WIA_INTENT_MINIMIZE_SIZE;
        m_pSupportedIntents[5] = WIA_INTENT_MAXIMIZE_QUALITY;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedIntentsArrayContents
*
*   This helper deletes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedIntentsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedIntentsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedIntents)
        delete [] m_pSupportedIntents;

    m_pSupportedIntents     = NULL;
    m_NumSupportedIntents   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedCompressions
*
*   This helper initializes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedCompressions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedCompressions");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedCompressionTypes) {

        //
        // Supported compression types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCompressionTypes  = 1;
    m_pSupportedCompressionTypes    = new LONG[m_NumSupportedCompressionTypes];
    if(m_pSupportedCompressionTypes){
        m_pSupportedCompressionTypes[0] = WIA_COMPRESSION_NONE;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedCompressionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedCompressionsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedCompressionTypes)
        delete [] m_pSupportedCompressionTypes;

    m_pSupportedCompressionTypes     = NULL;
    m_NumSupportedCompressionTypes   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedPreviewModes
*
*   This helper initializes the supported preview mode array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    8/17/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedPreviewModes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedPreviewModes");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedPreviewModes) {

        //
        // Supported preview modes have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedPreviewModes  = 2;
    m_pSupportedPreviewModes    = new LONG[m_NumSupportedPreviewModes];
    if(m_pSupportedPreviewModes){
        m_pSupportedPreviewModes[0] = WIA_FINAL_SCAN;
        m_pSupportedPreviewModes[1] = WIA_PREVIEW_SCAN;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    8/17/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedPreviewModesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedPreviewModesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedPreviewModes)
        delete [] m_pSupportedPreviewModes;

    m_pSupportedPreviewModes     = NULL;
    m_NumSupportedPreviewModes   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedDataTypes
*
*   This helper initializes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedDataTypes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedDataTypes");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedDataTypes) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    if (m_bLegacyBWRestriction) {
        m_NumSupportedDataTypes  = NUM_DATA_TYPES_LEGACY;
    } else {
        m_NumSupportedDataTypes  = NUM_DATA_TYPES_NONLEGACY;
    }
    m_pSupportedDataTypes = new LONG[m_NumSupportedDataTypes];

    if(m_pSupportedDataTypes){
        m_pSupportedDataTypes[0] = WIA_DATA_THRESHOLD;
        m_pSupportedDataTypes[1] = WIA_DATA_GRAYSCALE;

        //
        // Add color support to non-legacy devices only
        //

        if (m_NumSupportedDataTypes == NUM_DATA_TYPES_NONLEGACY) {
            m_pSupportedDataTypes[2] = WIA_DATA_COLOR;
        }
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedDataTypesArrayContents
*
*   This helper deletes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedDataTypesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedDataTypesArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedDataTypes)
        delete [] m_pSupportedDataTypes;

    m_pSupportedDataTypes     = NULL;
    m_NumSupportedDataTypes   = 0;
    return hr;
}

/**************************************************************************\
* BuildInitialFormats
*
*   This helper initializes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildInitialFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildInitialFormats");

    HRESULT hr = S_OK;

    if(NULL != m_pInitialFormats) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumInitialFormats = 1;
    m_pInitialFormats     = new GUID[m_NumInitialFormats];
    if(m_pInitialFormats){
        m_pInitialFormats[0] = WiaImgFmt_MEMORYBMP;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}
/**************************************************************************\
* DeleteInitialFormatsArrayContents
*
*   This helper deletes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteInitialFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteInitialFormatsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pInitialFormats)
        delete [] m_pInitialFormats;

    m_pInitialFormats     = NULL;
    m_NumInitialFormats   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedFormats
*
*   This helper initializes the supported format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedFormats");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedFormats) {

        //
        // Supported formats have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    LONG lNumFileFormats = 0;
    LONG lNumMemoryFormats = 0;
    GUID *pFileFormats = NULL;
    GUID *pMemoryFormats = NULL;

    hr = m_pScanAPI->GetSupportedFileFormats(&pFileFormats, &lNumFileFormats);
    if(SUCCEEDED(hr)){
        hr = m_pScanAPI->GetSupportedMemoryFormats(&pMemoryFormats, &lNumMemoryFormats);
        if (SUCCEEDED(hr)) {
            m_NumSupportedFormats = lNumFileFormats + lNumMemoryFormats + 2;
            m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
            LONG lIndex = 0;
            if (m_pSupportedFormats) {

                // fill out file formats
                m_pSupportedFormats[lIndex].guidFormatID = WiaImgFmt_BMP;
                m_pSupportedFormats[lIndex].lTymed       = TYMED_FILE;
                lIndex++;
                for(LONG lSrcIndex = 0;lSrcIndex < lNumFileFormats; lSrcIndex++){
                    m_pSupportedFormats[lIndex].guidFormatID = pFileFormats[lSrcIndex];
                    m_pSupportedFormats[lIndex].lTymed       = TYMED_FILE;
                    lIndex ++;
                }

                //fill out memory formats
                m_pSupportedFormats[lIndex].guidFormatID = WiaImgFmt_MEMORYBMP;
                m_pSupportedFormats[lIndex].lTymed       = TYMED_CALLBACK;
                lIndex++;
                for(lSrcIndex = 0;lSrcIndex < lNumMemoryFormats; lSrcIndex++){
                    m_pSupportedFormats[lIndex].guidFormatID = pMemoryFormats[lSrcIndex];
                    m_pSupportedFormats[lIndex].lTymed       = TYMED_CALLBACK;
                    lIndex++;
                }
            } else{
                hr = E_OUTOFMEMORY;
            }
        }
    } else if(E_NOTIMPL == hr){
        // do default processing of file formats
        hr = DeleteSupportedFormatsArrayContents();
        if (SUCCEEDED(hr)) {
            m_NumSupportedFormats = 2;

            m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
            if (m_pSupportedFormats) {
                m_pSupportedFormats[0].guidFormatID = WiaImgFmt_MEMORYBMP;
                m_pSupportedFormats[0].lTymed       = TYMED_CALLBACK;
                m_pSupportedFormats[1].guidFormatID = WiaImgFmt_BMP;
                m_pSupportedFormats[1].lTymed       = TYMED_FILE;
            } else
                hr = E_OUTOFMEMORY;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildSupportedFormats, GetSupportedFileFormats Failed "));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}
/**************************************************************************\
* DeleteSupportedFormatsArrayContents
*
*   This helper deletes the supported formats array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedFormatsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedFormats)
        delete [] m_pSupportedFormats;

    m_pSupportedFormats     = NULL;
    m_NumSupportedFormats   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedTYMED
*
*   This helper initializes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedTYMED()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedTYMED");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedTYMED) {

        //
        // Supported TYMED have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedTYMEDArrayContents();
    if (SUCCEEDED(hr)) {
        m_NumSupportedTYMED = 2;
        m_pSupportedTYMED   = new LONG[m_NumSupportedTYMED];
        if (m_pSupportedTYMED) {
            m_pSupportedTYMED[0] = TYMED_FILE;
            m_pSupportedTYMED[1] = TYMED_CALLBACK;

        } else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedTYMEDArrayContents
*
*   This helper deletes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedTYMEDArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedTYMEDArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedTYMED)
        delete [] m_pSupportedTYMED;

    m_pSupportedTYMED  = NULL;
    m_NumSupportedTYMED = 0;
    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildCapabilities()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildCapabilities");

    HRESULT hr = S_OK;
    if (NULL != m_pCapabilities) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCommands  = 0;
    m_NumSupportedEvents    = 0;
    m_NumCapabilities       = 0;

    WIACAPABILITIES WIACaps;
    memset(&WIACaps,0,sizeof(WIACaps));
    WIACaps.pCapabilities         = NULL;   // set to NULL, to ask for number of
                                            // capabilities
    WIACaps.pNumSupportedCommands = &m_NumSupportedCommands;
    WIACaps.pNumSupportedEvents   = &m_NumSupportedEvents;

    //
    // ask for number of capabilities
    //

    hr = m_pScanAPI->BuildCapabilities(&WIACaps);
    if (SUCCEEDED(hr)) {

        LONG lDriverAddedEvents = m_NumSupportedEvents;
        m_NumSupportedCommands  = 1;
        m_NumSupportedEvents    = (lDriverAddedEvents + 2);    // 2 required events (default events for all devices)
        m_NumCapabilities       = (m_NumSupportedCommands + m_NumSupportedEvents);

        //
        // allocate capabilities array memory
        //

        m_pCapabilities = new WIA_DEV_CAP_DRV[m_NumCapabilities];
        if (m_pCapabilities) {

            memset(&WIACaps,0,sizeof(WIACaps));
            WIACaps.pCapabilities         = m_pCapabilities;
            WIACaps.pNumSupportedCommands = NULL;
            WIACaps.pNumSupportedEvents   = NULL;

            //
            // get capabilities from micro driver
            //

            hr = m_pScanAPI->BuildCapabilities(&WIACaps);
            if (SUCCEEDED(hr)) {

                LONG lStartIndex = lDriverAddedEvents;

                //
                // Initialize EVENTS
                //

                // WIA_EVENT_DEVICE_CONNECTED
                GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME,&(m_pCapabilities[lStartIndex].wszName),TRUE);
                GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC,&(m_pCapabilities[lStartIndex].wszDescription),TRUE);
                m_pCapabilities[lStartIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
                m_pCapabilities[lStartIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
                m_pCapabilities[lStartIndex].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

                lStartIndex++;

                // WIA_EVENT_DEVICE_DISCONNECTED
                GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME,&(m_pCapabilities[lStartIndex].wszName),TRUE);
                GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC,&(m_pCapabilities[lStartIndex].wszDescription),TRUE);
                m_pCapabilities[lStartIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
                m_pCapabilities[lStartIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
                m_pCapabilities[lStartIndex].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

                lStartIndex++;

                //
                // Initialize COMMANDS
                //

                // WIA_CMD_SYNCHRONIZE
                GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME,&(m_pCapabilities[lStartIndex].wszName),TRUE);
                GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC,&(m_pCapabilities[lStartIndex].wszDescription),TRUE);
                m_pCapabilities[lStartIndex].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
                m_pCapabilities[lStartIndex].ulFlags        = 0;
                m_pCapabilities[lStartIndex].wszIcon        = WIA_ICON_SYNCHRONIZE;
            }

        } else {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteCapabilitiesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteCapabilitiesArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pCapabilities) {
        for (LONG i = 0; i < m_NumCapabilities;i++) {
            CoTaskMemFree(m_pCapabilities[i].wszName);
            CoTaskMemFree(m_pCapabilities[i].wszDescription);
        }
        delete [] m_pCapabilities;

        m_pCapabilities = NULL;
    }
    return hr;
}

/**************************************************************************\
* GetBSTRResourceString
*
*   This helper gets a BSTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   pBSTR       - pointer to a BSTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::GetBSTRResourceString(LONG lResourceID,BSTR *pBSTR,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::GetBSTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *pBSTR = SysAllocString(szStringValue);
#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *pBSTR = SysAllocString(wszStringValue);
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::GetOLESTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* VerticalFlip
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

VOID CWIAScannerDevice::VerticalFlip(
             PMINIDRIVERITEMCONTEXT     pDrvItemContext,
             PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext)

{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::VerticalFlip");

    LONG        iHeight         = 0;
    LONG        iWidth          = pDrvItemContext->lBytesPerScanLineRaw;
    ULONG       uiDepth         = pDrvItemContext->lDepth;
    LONG        ScanLineWidth   = pDrvItemContext->lBytesPerScanLine;
    BITMAPINFO  UNALIGNED *pbmi = NULL;
    PBYTE       pImageTop       = NULL;

    //
    // find out if data is TYMED_FILE or TYMED_HGLOBAL
    //

    if (pDataTransferContext->tymed == TYMED_FILE) {
        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer + sizeof(BITMAPFILEHEADER));
    } else {
        return;
    }

    //
    // init memory pointer and height
    //

    pImageTop = pDataTransferContext->pTransferBuffer + pDataTransferContext->lHeaderSize;

#ifdef _64BIT_ALIGNMENT
    BITMAPINFOHEADER UNALIGNED *pbmih = &pbmi->bmiHeader;
    iHeight = pbmih->biHeight;
#else
    iHeight = pbmi->bmiHeader.biHeight;
#endif

    //
    // try to allocate a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,ScanLineWidth);

    if (pBuffer != NULL) {

        LONG  index         = 0;
        PBYTE pImageBottom  = NULL;

        pImageBottom = pImageTop + (iHeight-1) * ScanLineWidth;
        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,ScanLineWidth);
            memcpy(pImageTop,pImageBottom,ScanLineWidth);
            memcpy(pImageBottom,pBuffer,ScanLineWidth);
            pImageTop    += ScanLineWidth;
            pImageBottom -= ScanLineWidth;
        }

        LocalFree(pBuffer);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("VerticalFlip, LocalAlloc failed allocating %d bytes",ScanLineWidth));
    }
}

/**************************************************************************\
* SwapBuffer24
*
*   Place RGB bytes in correct order for DIB format.
*
* Arguments:
*
*   pBuffer     - Pointer to the data buffer.
*   lByteCount  - Size of the data in bytes.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

VOID CWIAScannerDevice::SwapBuffer24(PBYTE pBuffer, LONG lByteCount)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::::SwapBuffer24");
    for (LONG i = 0; i < lByteCount; i+= 3) {
        BYTE bTemp = pBuffer[i];
        pBuffer[i]     = pBuffer[i + 2];
        pBuffer[i + 2] = bTemp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\dlihook.cpp ===
#include "pch.h"
#include <delayimp.h>

FARPROC WINAPI DliHook(unsigned dliNotify, PDelayLoadInfo pdli)
{    
#ifdef DEBUG
    switch (dliNotify) {
    case dliStartProcessing:             // used to bypass or note helper only
        OutputDebugString(TEXT("dliStartProcessing reported from DliHook"));
        break;
    case dliNotePreLoadLibrary:          // called just before LoadLibrary, can
        OutputDebugString(TEXT("dliNotePreLoadLibrary reported from DliHook"));                   //  override w/ new HMODULE return val
        break;                           
    case dliNotePreGetProcAddress:       // called just before GetProcAddress, can
        OutputDebugString(TEXT("dliNotePreGetProcAddress reported from DliHook"));                   //  override w/ new FARPROC return value
        break;                           
    case dliFailLoadLib:                 // failed to load library, fix it by
        OutputDebugString(TEXT("dliFailLoadLib reported from DliHook"));                   //  returning a valid HMODULE
        break;                           
    case dliFailGetProc:                 // failed to get proc address, fix it by                                         
        OutputDebugString(TEXT("dliFailGetProc reported from DliHook"));                   //  returning a valid FARPROC
        break;                           
    case dliNoteEndProcessing:           // called after all processing is done, no
        OutputDebugString(TEXT("dliNoteEndProcessing reported from DliHook"));                   //  no bypass possible at this point except
                                         //  by longjmp()/throw()/RaiseException.
        break;
    default:
        break;
    }
#endif
    return 0;
}

PfnDliHook __pfnDliFailureHook = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   coopp
#
#Date:
#   19-Jul-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#       WIA Flatbed Scanner USD (Micro Driver / Script-based Driver support)
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiafbdrv
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)

USE_ATL=1
ATL_VER=30
USE_STATIC_ATL=1

DLLDEF = ..\wiafbdrv.def
DLLENTRY=DllEntryPoint
COFFBASE=usermode

DELAYLOAD_SUPPORTED=1

INCLUDES= $(INCLUDES) \
          $(DDK_INC_PATH) \
          $(PROJECT_ROOT)\wia\drivers\scanner\microdrv\inc;


TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\iprop.lib           \
            $(SDK_LIB_PATH)\atl.lib             \
            $(SDK_LIB_PATH)\wiaguid.lib         \
            $(DDK_LIB_PATH)\wiaservc.lib

DELAYLOAD=wiaservc.dll

DLOAD_ERROR_HANDLER=DliHook

PASS0_HEADERDIR=$(O)
PASS0_SERVERDIR=$(O)
PASS0_CLIENTDIR=$(O)
PASS0_SOURCEDIR=$(O)

C_DEFINES=$(C_DEFINES) -DENTRY_PREFIX=WIAFB

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\pch.h
PRECOMPILED_OBJ = pch.obj

SOURCES= \
    ..\cmicro.cpp      \
    ..\wiafbdrv.cpp    \
    ..\IStiUSD.cpp     \
    ..\IWiaMiniDrv.cpp \
    ..\validate.cpp    \
    ..\scanapi.cpp     \
    ..\dlihook.cpp     \
    ..\wiafbdrv.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\validate.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       validate.cpp
*
*  VERSION:     1.0
*
*  DATE:        17 July, 2000
*
*  DESCRIPTION:
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

/**************************************************************************\
* ValidateDataTransferContext
*
*   Checks the data transfer context to ensure it's valid.
*
* Arguments:
*
*    pDataTransferContext - Pointer the data transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::ValidateDataTransferContext(
    PMINIDRV_TRANSFER_CONTEXT pDataTransferContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::ValidateDataTransferContext");

    if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid data transfer context"));
        return E_INVALIDARG;;
    }

    return S_OK;
}

/**************************************************************************\
* UpdateValidDepth
*
*   Helper that updates the valid value for depth based on the data type.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the WiaItem context
*   lDataType   -   the value of the DataType property.
*   lDepth      -   the address of the variable where the Depth's new value
*                   will be returned.
*
* Return Value:
*
*   Status      -   S_OK if successful
*                   E_INVALIDARG if lDataType is unknown
*                   Errors are those returned by wiasReadPropLong,
*                   and wiasWritePropLong.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::UpdateValidDepth(
    BYTE        *pWiasContext,
    LONG        lDataType,
    LONG        *lDepth)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::UpdateValidDepth");
    HRESULT hr = S_OK;
    LONG    pValidDepth[1];

    switch (lDataType) {
        case WIA_DATA_THRESHOLD:
            pValidDepth[0] = 1;
            break;
        case WIA_DATA_GRAYSCALE:
            pValidDepth[0] = 8;
            break;
        case WIA_DATA_COLOR:
            pValidDepth[0] = 24;
            break;
        default:
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("UpdateValidDepth, unknown data type"));
            return E_INVALIDARG;
    }

    if (lDepth) {
        *lDepth = pValidDepth[0];
    }

    return hr;
}

/**************************************************************************\
* CheckDataType
*
*   This helper method is called to check whether WIA_IPA_DATATYPE
*   property is changed.  When this property changes, other dependant
*   properties and their valid values must also be changed.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckDataType(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckDataType");
    WIAS_CHANGED_VALUE_INFO cviDataType, cviDepth;
    HRESULT                 hr = S_OK;

    //
    //  Call wiasGetChangedValue for DataType. It is checked first since it's
    //  not dependant on any other property.  All properties in this method
    //  that follow are dependant properties of DataType.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for DataType never change).  Also,
    //  the address of a variable for the old value is NULL, since the old
    //  value is not needed.  The address of bDataTypeChanged is passed
    //  so that dependant properties will know whether the DataType is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPA_DATATYPE,
                                 &cviDataType);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for Depth. Depth is a dependant property of
    //  DataType whose valid value changes according to what the current
    //  value of DataType is.
    //
    //  The call to wiasGetChangedValue specifies that validation should only
    //  be skipped if the DataType has changed.  This is because the valid
    //  values for Depth will change according to the new value for
    //  DataType.  The address of a variable for the old value is NULL, since
    //  the old value is not needed.  The address of bDepthChanged is passed
    //  so that dependant properties will know whether the Depth is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 cviDataType.bChanged,
                                 WIA_IPA_DEPTH,
                                 &cviDepth);
    if (FAILED(hr)) {
        return hr;
    }

    if (cviDataType.bChanged) {

        //
        //  DataType changed so update valid value for Depth
        //

        hr = UpdateValidDepth(pWiasContext, cviDataType.Current.lVal, &cviDepth.Current.lVal);

        if (SUCCEEDED(hr)) {

            //
            //  Check whether we must fold.  Depth will only be folded if it
            //  is not one of the properties that the app is changing.
            //

            if (!cviDepth.bChanged) {
                hr = wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, cviDepth.Current.lVal);
            }
        }
    }

    //
    //  Update properties dependant on DataType and Depth.
    //  Here, ChannelsPerPixel and BitsPerChannel are updated.
    //

    if (cviDataType.bChanged || cviDepth.bChanged) {
        if (SUCCEEDED(hr)) {
            #define NUM_PROPS_TO_SET 2
            PROPSPEC    ps[NUM_PROPS_TO_SET] = {
                            {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
                            {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL}};
            PROPVARIANT pv[NUM_PROPS_TO_SET];

            for (LONG index = 0; index < NUM_PROPS_TO_SET; index++) {
                PropVariantInit(&pv[index]);
                pv[index].vt = VT_I4;
            }

            switch (cviDataType.Current.lVal) {
                case WIA_DATA_THRESHOLD:
                    pv[0].lVal = 1;
                    pv[1].lVal = 1;
                    break;

                case WIA_DATA_GRAYSCALE:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;

                case WIA_DATA_COLOR:
                    pv[0].lVal = 3;
                    pv[1].lVal = 8;
                    break;

                default:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
            }
            hr = wiasWriteMultiple(pWiasContext, NUM_PROPS_TO_SET, ps, pv);
        }
    }

    return hr;
}

/**************************************************************************\
* CheckIntent
*
*   This helper method is called to make the relevant changes if the
*   Current Intent property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckIntent(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckIntent");
    HRESULT                 hr;
    WIAS_CHANGED_VALUE_INFO cviIntent;

    //
    //  Call wiasGetChangedValue for CurrentIntent. CurrentIntent is checked first
    //  since it's not dependant on any other property.  All properties in
    //  this method that follow are dependant properties of CurrentIntent.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for CurrentIntent never change). The
    //  address of the old value is specified as NULL, since it is not used.
    //  The address of bIntentChanged is passed so that dependant properties
    //  will know whether the YResolution is being changed or not.  This is
    //  important since dependant properties will need their valid values
    //  updated and may need to be folded to new valid values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPS_CUR_INTENT,
                                 &cviIntent);
    if (SUCCEEDED(hr)) {
        if (cviIntent.bChanged) {

            LONG lImageSizeIntent = (cviIntent.Current.lVal & WIA_INTENT_SIZE_MASK);
            LONG lImageTypeIntent = (cviIntent.Current.lVal & WIA_INTENT_IMAGE_TYPE_MASK);

            switch (lImageTypeIntent) {

                case WIA_INTENT_NONE:
                    break;

                case WIA_INTENT_IMAGE_TYPE_GRAYSCALE:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_GRAYSCALE);
                    UpdateValidDepth (pWiasContext, WIA_DATA_GRAYSCALE, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 8);
                    break;

                case WIA_INTENT_IMAGE_TYPE_TEXT:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_THRESHOLD);
                    UpdateValidDepth (pWiasContext, WIA_DATA_THRESHOLD, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 1);
                    break;

                case WIA_INTENT_IMAGE_TYPE_COLOR:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_COLOR);
                    UpdateValidDepth(pWiasContext, WIA_DATA_COLOR, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 24);
                    break;

                default:
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (TYPE) = %d",lImageTypeIntent));
                    return E_INVALIDARG;

            }

            switch (lImageSizeIntent) {
            case WIA_INTENT_NONE:
                    break;
            case WIA_INTENT_MINIMIZE_SIZE:
            case WIA_INTENT_MAXIMIZE_QUALITY:
                {

                    //
                    // Set the X and Y Resolutions.
                    //

                    wiasWritePropLong(pWiasContext, WIA_IPS_XRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);
                    wiasWritePropLong(pWiasContext, WIA_IPS_YRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);

                    //
                    //  The Resolutions and DataType were set, so update the property
                    //  context to indicate that they have changed.
                    //

                    wiasSetPropChanged(WIA_IPS_XRES, pContext, TRUE);
                    wiasSetPropChanged(WIA_IPS_YRES, pContext, TRUE);
                    wiasSetPropChanged(WIA_IPA_DATATYPE, pContext, TRUE);

                    //
                    // Reset any device item properties which may have changed due to validation.
                    //

                    //
                    // update IPA_NUMBER_OF_LINES property
                    //

                    LONG lLength = 0;

                    hr = wiasReadPropLong(pWiasContext, WIA_IPS_YEXTENT, &lLength, NULL, TRUE);
                    if (SUCCEEDED(hr)) {
                        hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, lLength);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_NUMBER_OF_LINES"));
                            return hr;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_YEXTENT"));
                        return hr;
                    }

                    //
                    // update IPA_PIXEL_PER_LINE property
                    //

                    LONG lWidth = 0;

                    hr = wiasReadPropLong(pWiasContext, WIA_IPS_XEXTENT, &lWidth, NULL, TRUE);
                    if (SUCCEEDED(hr)) {
                        hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lWidth);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_PIXELS_PER_LINE"));
                            return hr;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_XEXTENT"));
                        return hr;
                    }
                }
                break;
            default:
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (SIZE) = %d",lImageSizeIntent));
                return E_INVALIDARG;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, wiasGetChangedValue (intent) failed"));
    }
    return hr;
}

/**************************************************************************\
* CheckPreferredFormat
*
*   This helper method is called to make the relevant changes if the
*   Format property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckPreferredFormat(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    HRESULT hr = S_OK;

    //
    // update WIA_IPA_PREFERRED_FORMAT property
    //

    GUID FormatGUID;
    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &FormatGUID, NULL, TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, FormatGUID);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckPreferredFormat, could not write WIA_IPA_PREFERRED_FORMAT"));
            return hr;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPA_FORMAT"));
    }
    return hr;
}

/**************************************************************************\
* CheckADFStatus
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckADFStatus(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckADFStatus");

    if(!m_bADFAttached)
        return S_OK;

    HRESULT hr                 = S_OK;
    BYTE    *pRootItemCtx      = NULL;
    LONG    lDocHandlingSelect = FLATBED;

    //
    // get root item
    //

    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (SUCCEEDED(hr)) {

        //
        // read document handling select for validation
        //

        hr = wiasReadPropLong(pRootItemCtx,WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocHandlingSelect,NULL,FALSE);
        if (SUCCEEDED(hr)) {

            if (S_FALSE == hr) {
                lDocHandlingSelect = FLATBED; // default setting
            }

            if (lDocHandlingSelect & FEEDER) {
                // set to FEEDER, check hardware for status
                hr = m_pScanAPI->ADFAvailable();
                if (S_OK == hr) {
                    hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FEED_READY);
                } else {
                    hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,PAPER_JAM);
                }
            } else if (lDocHandlingSelect & FLATBED) {
                // set to FLATBED
                hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FLAT_READY);
            } else {
                // set to an invalid value
                hr = E_INVALIDARG;
            }

        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckADFStatus, wiasReadPropLong (WIA_DPS_DOCUMENT_HANDLING_SELECT) Failed"));
            WIAS_LHRESULT(m_pIWiaLog,hr);
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckADFStatus, wiasGetRootItem Failed"));
        WIAS_LHRESULT(m_pIWiaLog,hr);
    }
    return hr;
}

/**************************************************************************\
* CheckPreview
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    8/21/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckPreview(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckPreview");

    HRESULT hr = S_OK;

    BYTE    *pRootItemCtx   = NULL;
    LONG lPreview = 0;
    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    hr = wiasReadPropLong(pRootItemCtx,
                          WIA_DPS_PREVIEW,
                          &lPreview,
                          NULL,
                          FALSE);
    if(hr == S_FALSE){
        // property does not exist...so return S_OK
        return S_OK;
    }

    if (SUCCEEDED(hr)) {
        switch (lPreview) {
        case WIA_FINAL_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_FINAL_SCAN"));
            hr = S_OK;
            break;
        case WIA_PREVIEW_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_PREVIEW_SCAN"));
            hr = S_OK;
            break;
        default:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to invalid argument (%d)",lPreview));
            hr = E_INVALIDARG;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\wiafbdrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiafbdrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        16 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA flatbed scanner class factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
CRITICAL_SECTION    g_csCOM;           // COM initialize syncronization.
IWiaLog            *g_pIWiaLog = NULL; // WIA Logging Interface

// Is COM initialized
BOOL    g_COMInitialized = FALSE;


/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }
    LeaveCriticalSection(&g_csCOM);

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    LeaveCriticalSection(&g_csCOM);
    return TRUE;
}

/***************************************************************************\
*
*  CWIAScannerDeviceClassFactory
*
\****************************************************************************/

class CWIAScannerDeviceClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    CWIAScannerDeviceClassFactory();
    ~CWIAScannerDeviceClassFactory();
};

/**************************************************************************\
* CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory, (creating)"));
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::~CWIAScannerDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

CWIAScannerDeviceClassFactory::~CWIAScannerDeviceClassFactory(void)
{
    // Destructor logic
    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory, (destroy)"));
//    WIA_DEBUG_DESTROY();
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDeviceClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDeviceClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    CWIAScannerDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new CWIAScannerDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    hres = pDev->PrivateInitialize();
    if(hres != S_OK) {
        delete pDev;
        return hres;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!IsValid() || !ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWIAScannerDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWIAScannerDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWIAScannerDevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/


extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    HRESULT hr = E_FAIL;
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            __try {
                if(!InitializeCriticalSectionAndSpinCount(&g_csCOM, MINLONG)) {
                    return FALSE;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {

            }

            DeleteCriticalSection(&g_csCOM);
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_FlatbedScannerUsd) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_FlatbedScannerUsd)) {
        CWIAScannerDeviceClassFactory *pcf = new CWIAScannerDeviceClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\wiaprop.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       WIAProp.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Default property declarations and definitions for the
*   Sample WIA Scanner device.
*
***************************************************************************/

#ifndef _WIAPROP_H
#define _WIAPROP_H

#define SCANNER_FIRMWARE_VERSION L"1.0"
#define OPTICAL_XRESOLUTION      300
#define OPTICAL_YRESOLUTION      300
#define HORIZONTAL_BED_SIZE      8500   // in one thousandth's of an inch
#define VERTICAL_BED_SIZE        11000  // in one thousandth's of an inch

#define HORIZONTAL_ADF_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_ADF_BED_SIZE    11000  // in one thousandth's of an inch

#define HORIZONTAL_TPA_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_TPA_BED_SIZE    11000  // in one thousandth's of an inch

#define MIN_BUFFER_SIZE          65535

#define INITIAL_PHOTOMETRIC_INTERP WIA_PHOTO_WHITE_1
#define INITIAL_COMPRESSION        WIA_COMPRESSION_NONE
#define INITIAL_XRESOLUTION        150
#define INITIAL_YRESOLUTION        150
#define INITIAL_DATATYPE           WIA_DATA_GRAYSCALE
#define INITIAL_BITDEPTH           8
#define INITIAL_BRIGHTNESS         0
#define INITIAL_CONTRAST           0
#define INITIAL_CHANNELS_PER_PIXEL 1
#define INITIAL_BITS_PER_CHANNEL   8
#define INITIAL_PLANAR             WIA_PACKED_PIXEL
#define INITIAL_FORMAT             (GUID*) &WiaImgFmt_MEMORYBMP
#define INITIAL_TYMED              TYMED_CALLBACK

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\wiafbdrv.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiafbdrv.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*
*
***************************************************************************/

#include "pch.h"

typedef GUID* PGUID;

#if defined( _WIN32 ) && !defined( _NO_COM)
//////////////////////////////////////////////////////////////////////////
// GUID / CLSID definition section (for your specific device)           //
//                                                                      //
// IMPORTANT!! - REMEMBER TO CHANGE YOUR .INF FILE TO MATCH YOUR WIA    //
//               DRIVER'S CLSID!!                                       //
//                                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// BB6CF8E2-1511-40bd-91BA-80D43C53064E
DEFINE_GUID(CLSID_FlatbedScannerUsd, 0xBB6CF8E2L, 0x1511, 0x40bd, 0x91, 0xBA, 0x80, 0xD4, 0x3C, 0x53, 0x06, 0x4E);

// {48A89A69-C08C-482a-B3E5-CD50B50B5DFA}
DEFINE_GUID(guidEventFirstLoaded,
0x48a89a69, 0xc08c, 0x482a, 0xb3, 0xe5, 0xcd, 0x50, 0xb5, 0xb, 0x5d, 0xfa);

#endif

//////////////////////////////////////////////////////////////////////////
// DLL #define Section                                                  //
//////////////////////////////////////////////////////////////////////////

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"
#define DATASEG_DEFAULT         DATASEG_SHARED

#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);

#pragma data_seg(DATASEG_PERINSTANCE)
#pragma data_seg(DATASEG_DEFAULT)

extern UINT g_cRefThisDll;
extern UINT g_cLocks;
extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);
extern void DllAddRef(void);
extern void DllRelease(void);

//
// Base structure for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // IUnknown-like methods
    STDMETHOD(NonDelegatingQueryInterface)(THIS_
              REFIID riid,
              LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};

// This sample WIA scanner supports a single scanning context.
#define NUM_DEVICE_ITEM     1

// Device item specific context.
typedef struct _MINIDRIVERITEMCONTEXT{
   LONG     lSize;
   LONG     lTotalWritten;                      // Total image bytes written.
   // Scan parameters:
   LONG     lDepth;                             // image bit depth
   LONG     lBytesPerScanLine;                  // bytes per scan line     (scanned data)
   LONG     lBytesPerScanLineRaw;               // bytes per scan line RAW (scanned data)
   LONG     lTotalRequested;                    // Total image bytes requested.
} MINIDRIVERITEMCONTEXT, *PMINIDRIVERITEMCONTEXT;

//
// Definitions controlling COLOR/BW support
//

#define NUM_DATA_TYPES_NONLEGACY 3
#define NUM_DATA_TYPES_LEGACY    2

//
// Class definition for sample WIA scanner object
//

class CWIAScannerDevice : public IStiUSD,               // STI USD interface
                          public IWiaMiniDrv,           // WIA Minidriver interface
                          public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWIAScannerDevice(LPUNKNOWN punkOuter);
    HRESULT PrivateInitialize();
    ~CWIAScannerDevice();

private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    BOOL                m_fValid;               // Is object initialized?
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    PSTIDEVICECONTROL   m_pIStiDevControl;      // Device control interface.
    BOOLEAN             m_bUsdLoadEvent;        // Controls load event.
    DWORD               m_dwLastOperationError; // Last error.
    DWORD               m_dwLockTimeout;        // Lock timeout for LockDevice() calls
    BOOL                m_bDeviceLocked;        // device locked/unlocked
    CHAR                *m_pszDeviceNameA;      // CreateFileName for default RawRead/RawWrite handle
    HANDLE              m_DeviceDefaultDataHandle;//default RawRead/RawWrite handle

    // Event information
    CRITICAL_SECTION    m_csShutdown;           // Syncronizes shutdown.
    HANDLE              m_hSignalEvent;         // Signal event handle.
    HANDLE              m_hShutdownEvent;       // Shutdown event handle.
    HANDLE              m_hEventNotifyThread;   // Does event notification.
    GUID                m_guidLastEvent;        // Last event ID.

    // WIA information, one time initialization.
    BSTR                m_bstrDeviceID;         // WIA unique device ID.
    BSTR                m_bstrRootFullItemName; // Device name for prop streams.
    IWiaEventCallback   *m_pIWiaEventCallback;  // WIA event sink.
    IWiaDrvItem         *m_pIDrvItemRoot;       // The root item.
    IStiDevice          *m_pStiDevice;          // Sti object.

    HINSTANCE           m_hInstance;            // Module's HINSTANCE
    IWiaLog             *m_pIWiaLog;            // WIA logging object

    LONG                m_NumSupportedCommands; // Number of supported commands
    LONG                m_NumSupportedEvents;   // Number of supported events

    LONG                m_NumSupportedFormats;  // Number of supported formats
    LONG                m_NumCapabilities;      // Number of capabilities
    LONG                m_NumSupportedTYMED;    // Number of supported TYMED
    LONG                m_NumInitialFormats;    // Number of Initial formats
    LONG                m_NumSupportedDataTypes;// Number of supported data types
    LONG                m_NumSupportedIntents;  // Number of supported intents
    LONG                m_NumSupportedCompressionTypes; // Number of supported compression types
    LONG                m_NumSupportedResolutions; // Number of supported resolutions
    LONG                m_NumSupportedPreviewModes;// Number of supported preview modes

    WIA_FORMAT_INFO     *m_pSupportedFormats;   // supported formats
    WIA_DEV_CAP_DRV     *m_pCapabilities;       // capabilities
    LONG                *m_pSupportedTYMED;     // supported TYMED
    GUID                *m_pInitialFormats;     // initial formats
    LONG                *m_pSupportedDataTypes; // supported data types
    LONG                *m_pSupportedIntents;   // supported intents
    LONG                *m_pSupportedCompressionTypes; // supported compression types
    LONG                *m_pSupportedResolutions;// supported resolutions
    LONG                *m_pSupportedPreviewModes;// supported preview modes

    LONG                m_NumRootItemProperties;// Number of Root item properties
    LONG                m_NumItemProperties;    // Number of item properties

    LPOLESTR            *m_pszRootItemDefaults; // root item property names
    PROPID              *m_piRootItemDefaults;  // root item property ids
    PROPVARIANT         *m_pvRootItemDefaults;  // root item property prop variants
    PROPSPEC            *m_psRootItemDefaults;  // root item property propspecs
    WIA_PROPERTY_INFO   *m_wpiRootItemDefaults; // root item property attributes

    LPOLESTR            *m_pszItemDefaults;     // item property names
    PROPID              *m_piItemDefaults;      // item property ids
    PROPVARIANT         *m_pvItemDefaults;      // item property prop variants
    PROPSPEC            *m_psItemDefaults;      // item property propspecs
    WIA_PROPERTY_INFO   *m_wpiItemDefaults;     // item property attributes

    BOOL                m_bADFAttached;         // ADF attached

    BOOL                m_bTPAEnabled;          // TPA enabled
    BOOL                m_bTPAAttached;         // TPA attached

    LONG                m_MaxBufferSize;        // Maximum buffer for device
    LONG                m_MinBufferSize;        // Minimum buffer for device

    CScanAPI            *m_pScanAPI;            // Scanner device API class, (micro and script-based)
    BOOL                m_bLegacyBWRestriction; // flag to restrict devices to BW and Grayscale scanning only

    // inline member functions
    BOOL inline IsValid(VOID) {
        return m_fValid;
    }

public:

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHOD(Initialize)(THIS_
        PSTIDEVICECONTROL pHelDcb,
        DWORD             dwStiVersion,
        HKEY              hParametersKey);

    STDMETHOD(GetCapabilities)(THIS_
        PSTI_USD_CAPS pDevCaps);

    STDMETHOD(GetStatus)(THIS_
        PSTI_DEVICE_STATUS pDevStatus);

    STDMETHOD(DeviceReset)(THIS);

    STDMETHOD(Diagnostic)(THIS_
        LPDIAG pBuffer);

    STDMETHOD(Escape)(THIS_
        STI_RAW_CONTROL_CODE EscapeFunction,
        LPVOID               lpInData,
        DWORD                cbInDataSize,
        LPVOID               pOutData,
        DWORD                dwOutDataSize,
        LPDWORD              pdwActualData);

    STDMETHOD(GetLastError)(THIS_
        LPDWORD pdwLastDeviceError);

    STDMETHOD(LockDevice)(THIS);

    STDMETHOD(UnLockDevice)(THIS);

    STDMETHOD(RawReadData)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteData)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawReadCommand)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteCommand)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(SetNotificationHandle)(THIS_
        HANDLE hEvent);

    STDMETHOD(GetNotificationData)(THIS_
        LPSTINOTIFY lpNotify);

    STDMETHOD(GetLastErrorInfo)(THIS_
        STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        BSTR        bstrDeviceID,
        BSTR        bstrRootFullItemName,
        IUnknown    *pStiDevice,
        IUnknown    *pIUnknownOuter,
        IWiaDrvItem **ppIDrvItemRoot,
        IUnknown    **ppIUnknownInner,
        LONG        *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG     lFlags,
        LONG     lDevErrVal,
        LPOLESTR *ppszDevErrStr,
        LONG     *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        const GUID  *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG        *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG lFlags,
        BYTE *pSpecContext,
        LONG *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE            *pWiasContext,
        LONG            ulFlags,
        LONG            *pcelt,
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG            *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE            *pWiasContext,
        LONG            lFlags,
        LONG            *pcelt,
        WIA_FORMAT_INFO **ppwfi,
        LONG            *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID *pEventGUID,
        BSTR       bstrDeviceID,
        ULONG      ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE *pWiasContext);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // This section is for private helpers used for common WIA operations. //
    // These are custom to your driver.                                    //
    //                                                                     //
    //                                                                     //
    // -- WIA Item Management Helpers                                      //
    //    BuildItemTree()                                                  //
    //    DeleteItemTree()                                                 //
    //                                                                     //
    // -- WIA Property Management Helpers                                  //
    //    BuildRootItemProperties()                                        //
    //    BuildTopItemProperties()                                         //
    //                                                                     //
    // -- WIA Capability Management Helpers                                //
    //    BuildRootItemProperties()                                        //
    //    DeleteRootItemProperties()                                       //
    //    BuildTopItemProperties()                                         //
    //    DeleteTopItemProperties()                                        //
    //    BuildCapabilities()                                              //
    //    DeleteCapabilitiesArrayContents()                                //
    //    BuildSupportedFormats()                                          //
    //    DeleteSupportedFormatsArrayContents()                            //
    //    BuildSupportedDataTypes()                                        //
    //    DeleteSupportedDataTypesArrayContents()                          //
    //    BuildSupportedIntents()                                          //
    //    DeleteSupportedIntentsArrayContents()                            //
    //    BuildSupportedCompressions()                                     //
    //    DeleteSupportedCompressionsArrayContents()                       //
    //    BuildSupportedTYMED()                                            //
    //    DeleteSupportedTYMEDArrayContents()                              //
    //    BuildInitialFormats()                                            //
    //    DeleteInitialFormatsArrayContents()                              //
    //                                                                     //
    // -- WIA Validation Helpers                                           //
    //    CheckDataType()                                                  //
    //    CheckIntent()                                                    //
    //    CheckPreferredFormat()                                           //
    //    SetItemSize()                                                    //
    //    UpdateValidDepth()                                               //
    //    ValidateDataTransferContext()                                    //
    //                                                                     //
    // -- WIA Resource file Helpers                                        //
    //    GetBSTRResourceString()                                          //
    //    GetOLESTRResourceString()                                        //
    //                                                                     //
    // -- WIA Data acqusition Helpers                                      //
    //    ScanItem()                                                       //
    //    ScanItemCB()                                                     //
    //    SendBitmapHeader()                                               //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    HRESULT _stdcall BuildItemTree(void);

    HRESULT _stdcall DeleteItemTree(void);

    HRESULT BuildRootItemProperties();

    HRESULT DeleteRootItemProperties();

    HRESULT BuildTopItemProperties();

    HRESULT DeleteTopItemProperties();

    HRESULT BuildCapabilities();

    HRESULT DeleteCapabilitiesArrayContents();

    HRESULT BuildSupportedFormats();

    HRESULT DeleteSupportedFormatsArrayContents();

    HRESULT BuildSupportedDataTypes();

    HRESULT DeleteSupportedDataTypesArrayContents();

    HRESULT BuildSupportedIntents();

    HRESULT DeleteSupportedIntentsArrayContents();

    HRESULT BuildSupportedCompressions();

    HRESULT DeleteSupportedCompressionsArrayContents();

    HRESULT BuildSupportedPreviewModes();

    HRESULT DeleteSupportedPreviewModesArrayContents();

    HRESULT BuildSupportedTYMED();

    HRESULT DeleteSupportedTYMEDArrayContents();

    HRESULT BuildSupportedResolutions();

    HRESULT DeleteSupportedResolutionsArrayContents();

    HRESULT BuildInitialFormats();

    HRESULT DeleteInitialFormatsArrayContents();

    HRESULT CheckDataType(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckIntent(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckPreferredFormat(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckADFStatus(BYTE *pWiasContext,
                           WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckPreview(BYTE *pWiasContext,
                         WIA_PROPERTY_CONTEXT *pContext);

    HRESULT UpdateValidDepth(
        BYTE *pWiasContext,
        LONG lDataType,
        LONG *lDepth);

    HRESULT ValidateDataTransferContext(
        PMINIDRV_TRANSFER_CONTEXT pDataTransferContext);

    HRESULT SetItemSize(
        BYTE *pWiasContext);

    HRESULT _stdcall ScanItem(
        PMINIDRIVERITEMCONTEXT,
        PMINIDRV_TRANSFER_CONTEXT,
        LONG*);

    HRESULT _stdcall ScanItemCB(
        PMINIDRIVERITEMCONTEXT,
        PMINIDRV_TRANSFER_CONTEXT,
        LONG*);

    HRESULT SendBitmapHeader(
        PMINIDRV_TRANSFER_CONTEXT pmdtc);

    HRESULT SendFilePreviewBitmapHeader(
        PMINIDRV_TRANSFER_CONTEXT pmdtc);

    HRESULT GetBSTRResourceString(
        LONG lLocalResourceID,
        BSTR *pBSTR,
        BOOL bLocal);

    HRESULT GetOLESTRResourceString(
        LONG lLocalResourceID,
        LPOLESTR *ppsz,
        BOOL bLocal);

    UINT AlignInPlace(
        PBYTE   pBuffer,
        LONG    cbWritten,
        LONG    lBytesPerScanLine,
        LONG    lBytesPerScanLineRaw);

    VOID VerticalFlip(
        PMINIDRIVERITEMCONTEXT     pDrvItemContext,
        PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext);

    VOID SwapBuffer24(
        PBYTE pBuffer,
        LONG lByteCount);

    LONG GetPageCount(
        BYTE *pWiasContext);

    BOOL IsPreviewScan(
        BYTE *pWiasContext);

    BOOL IsADFEnabled(
        BYTE *pWiasContext);

public:
    HRESULT DoEventProcessing();
};

typedef CWIAScannerDevice *PWIASCANNERDEVICE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\pch.h ===
#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <objbase.h>

#include <sti.h>
#include <stiusd.h>
#include <wiamindr.h>

#ifdef USE_REAL_EVENTS

   #include <devioctl.h>
   #include <usbscan.h>

#endif // USE_REAL_EVENTS

#include "resource.h"
#include "wiaprop.h"
#include "scanapi.h"
#include "wiascanr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IStiUSD methods.
*
*******************************************************************************/
#include "pch.h"
#ifndef INITGUID
    #include <initguid.h>
#endif
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

/**************************************************************************\
* CWIADevice::CWIADevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

CWIADevice::CWIADevice(LPUNKNOWN punkOuter):
m_cRef(1),
m_punkOuter(NULL),
m_dwLastOperationError(0),
m_dwLockTimeout(DEFAULT_LOCK_TIMEOUT),
m_bDeviceLocked(FALSE),

m_hDeviceDataHandle(NULL),
m_bPolledEvent(FALSE),
m_hFakeEventKey(NULL),
m_guidLastEvent(GUID_NULL),

m_pIDrvItemRoot(NULL),
m_pStiDevice(NULL),
m_pIWiaLog(NULL),

m_bADFEnabled(FALSE),
m_bADFAttached(TRUE),
m_lClientsConnected(0),
m_pScanAPI(NULL),

m_NumSupportedFormats(0),
m_pSupportedFormats(NULL),
m_NumSupportedCommands(0),
m_NumSupportedEvents(0),
m_pCapabilities(NULL),
m_NumInitialFormats(0),
m_pInitialFormats(NULL)
{

    //
    // initialize internal structures
    //

    memset(&m_EventOverlapped,0,sizeof(m_EventOverlapped));
    memset(m_EventData,0,sizeof(m_EventData));
    memset(&m_SupportedTYMED,0,sizeof(m_SupportedTYMED));
    memset(&m_SupportedDataTypes,0,sizeof(m_SupportedDataTypes));
    memset(&m_SupportedIntents,0,sizeof(m_SupportedIntents));
    memset(&m_SupportedCompressionTypes,0,sizeof(m_SupportedCompressionTypes));
    memset(&m_SupportedResolutions,0,sizeof(m_SupportedResolutions));
    memset(&m_SupportedPreviewModes,0,sizeof(m_SupportedPreviewModes));
    memset(&m_RootItemInitInfo,0,sizeof(m_RootItemInitInfo));
    memset(&m_ChildItemInitInfo,0,sizeof(m_ChildItemInitInfo));

    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*>(static_cast<INonDelegatingUnknown*>(this));
    }

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // since this driver supports a scanner that has only a feeder, the
    // ADF Enabled flag needs to be set to TRUE by default.  This will
    // control the behavior of DrvAcquireItemData() method.
    //

    m_bADFEnabled = TRUE;

#endif

}

/**************************************************************************\
* CWIADevice::~CWIADevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

CWIADevice::~CWIADevice(void)
{
    SetNotificationHandle(NULL);

    //
    // WIA member destruction
    //

    // Tear down the driver item tree.
    if (m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIADevice, Deleting Device Item Tree (this is OK)"));
        DeleteItemTree();
        m_pIDrvItemRoot = NULL;
    }

    // free any IO handles opened
    if (m_hDeviceDataHandle) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIADevice, Closing DefaultDeviceDataHandle"));
        CloseHandle(m_hDeviceDataHandle);
        m_hDeviceDataHandle = NULL;
    }

    // Delete allocated arrays
    DeleteCapabilitiesArrayContents();
    DeleteSupportedIntentsArrayContents();

    if (m_pIWiaLog)
        m_pIWiaLog->Release();

    if (m_pScanAPI) {
        // disable fake scanner device
        m_pScanAPI->FakeScanner_DisableDevice();
        delete m_pScanAPI;
        m_pScanAPI = NULL;
    }
}

/**************************************************************************\
* CWIADevice::PrivateInitialize()
*
*   PrivateInitialize is called from the CreateInstance() method of the
*   WIA driver's class factory.  It is needed to initialize the WIA
*   driver object (CWIADevice).  If this initialization fails the
*   object will not be returned to the caller.  This prevents the creation
*   of a nonfunctional WIA device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    S_OK  - if the operation succeeded
*    E_xxx - Error code if the operation fails
*
\**************************************************************************/
HRESULT CWIADevice::PrivateInitialize()
{

    //
    // attempt to create the IWiaLog interface to log status and errors to
    // wiaservc.log file
    //

    HRESULT hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC_SERVER,IID_IWiaLog,(void**)&m_pIWiaLog);
    if (S_OK == hr) {
        m_pIWiaLog->InitializeLog((LONG)(LONG_PTR)g_hInst);
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Logging COM object created successfully for wiascanr.dll"));
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Logging COM object not be created successfully for wiascanr.dll (STI only?)"));
        hr = S_OK;
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::Initialize
*
*   Initialize is called by the WIA service when the driver is first loaded.
*   Initialize is also called when a client uses the legacy STI APIs and
*   calls IStillImage::CreateDevice() method.
*
*   This method should initialize the WIA driver and the device for use.
*   WIA drivers can store the pIStiDevControl interface if it needs it at a
*   later time.  IStiDevControl::AddRef() must be called before storing this
*   interface.  If you do not need to store the interface, then ignore it.
*   DO NOT RELEASE the IStiDevControl interface if you have not called
*   IStiDevControl::AddRef() first.  This may cause unpredictable results.
*
*   The IStiDeviceControl interface is needed to get information about your
*   device's ports.  The port name used in a CreateFile call can be obtained
*   by calling the IStiDeviceControl::GetMyDevicePortName() method.
*
*   For devices on shared ports, such as serial port devices, opening the port
*   in Initialize() is not recommended.  The port should only be opened in calls
*   to IStiUsd::LockDevice().  The closing of the ports should be internally
*   controlled to provide fast access. (opening and closing in
*   LockDevice/UnLockDevice is very inefficent. CreateFile() could cause a delay
*   making the user's experience appear slow, and nonresponsive)
*
*   If this WIA driver can not support multiple CreateFile() calls on the same
*   device port, then the IStiDevControl::GetMyDeviceOpenMode() should be called.
*
*   The WIA driver should check the returned MODE value for the flag
*   STI_DEVICE_CREATE_DATA and open the port accordingly.
*
*   The following flags could be set:
*
*       STI_DEVICE_CREATE_STATUS - open port for status
*       STI_DEVICE_CREATE_DATA   - open port for data
*       STI_DEVICE_CREATE_BOTH   - open port for status and data
*
*    If the device port needs to be opened, a call to CreateFile() should be
*    used.  When opening a port the flag FILE_FLAG_OVERLAPPED should be used.
*    This will allow OVERLAPPED i/o to be used when access the device.  Using
*    OVERLAPPED i/o will help control responsive access to the hardware.  When
*    a problem is detected the WIA driver can call CancelIo() to stop all
*    current hardware access.
*
* Arguments:
*
*    pIStiDevControl - device interface used for obtaining port information
*    dwStiVersion    - STI version
*    hParametersKey  - HKEY for registry reading/writing
*
* Return Value:
*
*    S_OK - if the operation was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::Initialize(
                                          PSTIDEVICECONTROL   pIStiDevControl,
                                          DWORD               dwStiVersion,
                                          HKEY                hParametersKey)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::Initialize");

    if (!pIStiDevControl) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    HRESULT hr = S_OK;

    //
    // Get the mode of the device to check why we were created.  status, data, or both...
    //

    DWORD dwMode = 0;
    hr = pIStiDevControl->GetMyDeviceOpenMode(&dwMode);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::Initialize, couldn't get device open mode"));
        return hr;
    }

    if(dwMode & STI_DEVICE_CREATE_DATA)
    {
        //
        // device is being opened for data
        //
    }

    if(dwMode & STI_DEVICE_CREATE_STATUS)
    {
        //
        // device is being opened for status
        //
    }

    if(dwMode & STI_DEVICE_CREATE_BOTH)
    {
        //
        // device is being opened for both data and status
        //
    }

    //
    // Get the name of the device port to be used in a call to CreateFile().
    //

    WCHAR szDevicePortNameW[MAX_PATH];
    memset(szDevicePortNameW,0,sizeof(szDevicePortNameW));

    hr = pIStiDevControl->GetMyDevicePortName(szDevicePortNameW,sizeof(szDevicePortNameW)/sizeof(WCHAR));
    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::Initialize, couldn't get device port"));
        return hr;
    }

    //
    // uncomment the code block below to have the driver create the kernel mode file
    // handles and open a communication channel to the device.
    //

    /*

    //
    // Open kernel mode device driver. Use the FILE_FLAG_OVERLAPPED flag for proper cancellation
    // of kernel mode operations and asynchronous file IO.  The CancelIo() call will function
    // properly if this flag is used.  It is recommended to use this flag.
    //

    m_hDeviceDataHandle = CreateFileW(szDevicePortNameW,
                                     GENERIC_READ | GENERIC_WRITE,               // Access mask
                                     0,                                          // Share mode
                                     NULL,                                       // SA
                                     OPEN_EXISTING,                              // Create disposition
                                     FILE_ATTRIBUTE_SYSTEM|FILE_FLAG_OVERLAPPED, // Attributes
                                     NULL );

    m_dwLastOperationError = ::GetLastError();

    hr = (m_hDeviceDataHandle != INVALID_HANDLE_VALUE) ?
                S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,m_dwLastOperationError);

    if (FAILED(hr)) {
        return hr;
    }

    */

    if (SUCCEEDED(hr)) {

        //
        // creation of fake scanner device is here.
        //


#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER
        hr = CreateFakeScanner(&m_pScanAPI,UNKNOWN_FEEDER_ONLY_SCANNER_MODE);
#else
        hr = CreateFakeScanner(&m_pScanAPI,FLATBED_SCANNER_MODE);
#endif

        if (m_pScanAPI) {

            //
            // initialize fake scanner device
            //

            hr = m_pScanAPI->FakeScanner_Initialize();
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, Could not create FakeScanner API object"));
            hr = E_OUTOFMEMORY;
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
    }


    //
    // Open DeviceData section to read driver specific information
    //

    HKEY hKey = hParametersKey;
    HKEY hOpenKey = NULL;
    if (RegOpenKeyEx(hKey,                     // handle to open key
                     TEXT("DeviceData"),       // address of name of subkey to open
                     0,                        // options (must be NULL)
                     KEY_QUERY_VALUE|KEY_READ, // just want to QUERY a value
                     &hOpenKey                 // address of handle to open key
                    ) == ERROR_SUCCESS) {



        //
        // This is where you read registry entries for your device.
        // The DeviceData section is the proper place to put this information.  Information about
        // your device should have been written using the WIA device's .INF installation file.
        // You can access this information from this location in the Registry.
        // The hParameters HKEY is owned by the WIA service.  DO NOT CLOSE THIS KEY.  Always close
        // any HKEYS opened by this WIA driver after you are finished.
        //

        //
        // close registry key when finished, reading DeviceData information.
        //

        RegCloseKey(hOpenKey);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::Initialize, couldn't open DeviceData KEY"));
        return E_FAIL;
    }
    return hr;
}


/**************************************************************************\
* CWIADevice::GetCapabilities
*
*   GetCapabilities is called by the WIA service to obtain the USD's
*   capabilities.  The WIA driver should fill out the following fields in the
*   STI_USD_CAPS structure:
*
*   1. dwVersion field with STI_VERSION letting the WIA service know what
*      version of STI this driver supports.
*   2. dwGenericCaps field with supported capabilities of the WIA device.
*
*
* Arguments:
*
*   pUsdCaps    - Pointer to a STI_USD_CAPS USD capabilities structure.
*
* Return Value:
*
*    S_OK  - if the data can be written correctly
*    E_xxx - Error code if the operation fails
*
*
* Remarks:
*
*   This WIA driver sets the following capability flags:
*
*   1. STI_GENCAP_WIA - This driver supports WIA
*   2. STI_USD_GENCAP_NATIVE_PUSHSUPPORT - This driver supports push buttons
*   3. STI_GENCAP_NOTIFICATIONS - This driver requires the use of interrupt
*      events.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetCapabilities");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pUsdCaps) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::GetCapabilities, NULL parameter"));
        return E_INVALIDARG;
    }

    memset(pUsdCaps, 0, sizeof(STI_USD_CAPS));
    pUsdCaps->dwVersion     = STI_VERSION;      // STI verison
    pUsdCaps->dwGenericCaps = STI_GENCAP_WIA|   // WIA support
                              STI_USD_GENCAP_NATIVE_PUSHSUPPORT| // button support
                              STI_GENCAP_NOTIFICATIONS; // interrupt event support
    return S_OK;
}

/**************************************************************************\
* CWIADevice::GetStatus
*
*   GetStatus is called by the WIA service for two major operations:
*
*   1. Checking device ON-LINE status.
*   2. Polling for device events. (like a push button event)
*
*   Determining the operation request can be done by checking the StatusMask
*   field of the STI_DEVICE_STATUS structure.  The StatusMask field can be
*   any of the following requests. (STI_DEVSTATUS_ONLINE_STATE or
*   STI_DEVSTATUS_EVENTS_STATE)
*
*   STI_DEVSTATUS_ONLINE_STATE = check if the device is ON-LINE.
*
*   This operation request should be fill by setting the dwOnlinesState
*   field of the STI_DEVICE_STATUS structure.
*   Value that should be used are:
*
*       STI_ONLINESTATE_OPERATIONAL   - Device is ON-LINE and operational
*       STI_ONLINESTATE_OFFLINE       - Device is OFF-LINE and NOT operational
*       STI_ONLINESTATE_PENDING       - Device has I/O operations pending
*       STI_ONLINESTATE_ERROR         - Device is currently in an error state
*       STI_ONLINESTATE_PAUSED        - Device is paused
*       STI_ONLINESTATE_PAPER_JAM     - Device has a paper jam
*       STI_ONLINESTATE_PAPER_PROBLEM - Device has a paper problem
*       STI_ONLINESTATE_IO_ACTIVE     - Device is active, but not accepting
*                                       commands at this time
*       STI_ONLINESTATE_BUSY          - Device is busy
*       STI_ONLINESTATE_TRANSFERRING  - Device is currently transferring data
*       STI_ONLINESTATE_INITIALIZING  - Device is being initialized
*       STI_ONLINESTATE_WARMING_UP    - Device is warming up
*       STI_ONLINESTATE_USER_INTERVENTION - Device requires user intervention
*                                           to resolve a problem
*       STI_ONLINESTATE_POWER_SAVE    - Device is in power save mode
*
*
*   STI_DEVSTATUS_EVENTS_STATE = check for device events.
*
*   This operation request should be filled by setting the dwEventHandlingState
*   field of the STI_DEVICE_STATUS structure.
*   Values that should be used are:
*
*       STI_EVENTHANDLING_PENDING - Device has an event pending and is wanting
*                                   to report it to the WIA service.
*
*   It is always a good idea to clear the STI_EVENTHANDLING_PENDING flag from
*   the dwEventHandlingState member to make sure that it is properly set when
*   a device event occurs.
*
*   When the STI_EVENTHANDLING_PENDING is set the WIA service is signaled that
*   an event has occured in the WIA driver.  The WIA service calls the
*   GetNotificationData() entry point to get more information about the event.
*   GetNotificationData() is called for polled events and interrupt events.
*   This is where you should fill out the proper event information to return to
*   the WIA service.
*
*
* Arguments:
*
*   pDevStatus  - Pointer to a STI_DEVICE_STATUS device status structure.
*
* Return Value:
*
*   S_OK         - if the data can be written correctly
*   E_INVALIDARG - if an invalid parameter was passed in to the GetStatus
*                  method.
*   E_xxx        - Error code if the operation fails
*
*
* Remarks:
*
*   This WIA driver should set the m_guidLastEvent to the proper event GUID when
*   an event is detected.  It should also set the m_bPolledEvent flag to TRUE
*   indicating that the event was received from a "polled source" (the GetStatus()
*   call).  The m_guidLastEvent is checked at a later time when the WIA service
*   calls GetNotificationData().
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetStatus");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!pDevStatus)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    // If we are asked, verify the device is online.
    //

    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE) {

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, WIA is asking the device if we are ONLINE"));

        //
        // assume the device is OFF-LINE before continuing.  This will validate
        // that the on-line check was successful.
        //

        pDevStatus->dwOnlineState = STI_ONLINESTATE_OFFLINE;

        hr = m_pScanAPI->FakeScanner_DeviceOnline();
        if (SUCCEEDED(hr)) {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Device is ONLINE"));

            //
            // device is ON-LINE and operational
            //

            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        } else {

            //
            // device is OFF-LINE and NOT operational
            //

            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetStatus, Device is OFFLINE"));
        }
    }

    //
    // If we are asked, verify state of an event handler (front panel buttons, user controlled attachments, etc..).
    //
    //
    // If your device requires polling, then this is where you would specify the event
    // result.
    //
    // *** It is not recommended to have polled events.  Interrupt events are better
    // for performance, and reliability.  See the SetNotificationsHandle() method for how to
    // implement interrupt events.
    //

    //
    // clear the dwEventHandlingState field first to make sure we are really setting
    // a pending event.
    //

    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {

        //
        // set the polled event source flag to true, because this will control the
        // behavior of the GetNotificationData() method.
        //

        m_bPolledEvent = TRUE;

        //
        // set the polled event result here, for the GetNotificationData() method to
        // read and report.
        //

        m_guidLastEvent = GUID_NULL;  // WIA_EVENT_SCAN_IMAGE is an example of an event GUID

        if (m_guidLastEvent != GUID_NULL) {

            //
            // if the event GUID is NOT GUID_NULL, set the STI_EVENTHANDLING_PENDING flag
            // letting the WIA service know that we have an event ready.  This will tell
            // the WIA service to call GetNotificationData() for the event specific information.
            //

            pDevStatus->dwEventHandlingState |= STI_EVENTHANDLING_PENDING;
        }
    }
    return S_OK;
}

/**************************************************************************\
* CWIADevice::DeviceReset
*
*   DeviceReset is called to reset the device to a power-on state.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   S_OK  - if device reset was successful
*   E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::DeviceReset(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::DeviceReset");
    if(!m_pScanAPI){
        return E_UNEXPECTED;
    }
    return m_pScanAPI->FakeScanner_ResetDevice();
}

/**************************************************************************\
* CWIADevice::Diagnostic
*
*   Diagnostic is called when the device needs to be tested.  The device
*   default property page "Test Device" button calls this method.
*
*   The WIA driver should set the following fields of the STI_DIAG structure:
*       sErrorInfo - error information contained in a STI_ERROR_INFO structure,
*                    detailing the test results of the the diagnostic method.
*                    The WIA device should set the following members:
*                       dwGenericError  - set to NOERROR if the device passed
*                                         the diagnostic test, or to an error
*                                         code if the device failed the test.
*                       dwVendorError   - set this to give more information
*                                         about the failure.  Remember that
*                                         this code is specific to this device
*                                         only.  The caller of Diagnostic will
*                                         not know the meaning of this vendor-
*                                         specific code.
*                       szExtendedErrorText - Extended error text.  This member
*                                             is limited to 255 characters.
*       dwBasicDiagCode - this code indicates the type of test to be performed.
*                         Currently this must be set to STI_DIAGCODE_HWPRESENCE.
*       dwVendorDiagCode - OPTIONAL - vendor supplied diagnostic test code.
*       dwStatusMask - RESERVED FOR FUTURE USE
*
* Arguments:
*
*    pBuffer    - Pointer to a STI_DIAG diagnostic result structure.
*
* Return Value:
*
*    S_OK  - if the data can be written correctly
*    E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::Diagnostic");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!pBuffer){
        return E_INVALIDARG;
    }

    if(!m_pScanAPI){
        return E_UNEXPECTED;
    }

    //
    // initialize response buffer
    //

    memset(&pBuffer->sErrorInfo,0,sizeof(pBuffer->sErrorInfo));

    //
    // This sample device does nothing during this diagnostic method call.
    // It is recommended to perform a quick test of the hardware to verify
    // that it is functional within operational parameters.
    //

    pBuffer->sErrorInfo.dwGenericError = NOERROR;
    pBuffer->sErrorInfo.dwVendorError  = 0;

    return m_pScanAPI->FakeScanner_Diagnostic();
}

/**************************************************************************\
* CWIADevice::Escape
*
*   Escape is called to pass information directly to the hardware.  This
*   method can be called directly using the original STI (legacy) APIs or
*   the IWiaItemExtras::Escape() method.
*   Any WIA application can obtain access to the IWiaItemExtras interface.
*   It is recommended that you validate all incoming and outgoing calls to
*   this method.
*
*   Recommended validation order:
*   1. validate the Function code first.  If it is not one your codes, fail
*      immediately.  This will help to prevent incorrect codes from being
*      processed in your driver.
*   2. validate the incoming buffer second.  If it is not valid, fail
*      immediately.  Bad incoming buffers coulsd crash the WIA driver.
*   3. validate the outgoing buffer third.  If it is not valid, fail
*      immediately.  If you can not complete the request by writing the
*      necessary data why process it?
*   4. validate the outgoing size buffer last.  This is important.  If you can
*      not write the amount of data you just wrote to the outgoing buffer
*      then that data can not be properly processed by the caller.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
* Return Value:
*
*    S_OK  - if the operation was successful
*    E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::Escape(
                                      STI_RAW_CONTROL_CODE    EscapeFunction,
                                      LPVOID                  pInData,
                                      DWORD                   cbInDataSize,
                                      LPVOID                  pOutData,
                                      DWORD                   cbOutDataSize,
                                      LPDWORD                 pcbActualData)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::Escape");

    //
    // only process EscapeFunction codes that are known to your driver.
    // Any application can send escape calls to your driver using the
    // IWiaItemExtras interface Escape() method call.  The driver must
    // be prepared to validate all incoming calls to Escape().
    //

    //
    // since this driver does not support any escape functions it will reject all
    // incoming EscapeFunction codes.
    //
    // If your driver supports an EscapeFunction, then add your function code to the
    // switch statement, and set hr = S_OK.  This will allow the function to continue
    // to the incoming/outgoing buffer validation.
    //

    HRESULT hr = E_NOTIMPL;
    switch(EscapeFunction){
    case 0:
    default:
        break;
    }

    //
    // if an EscapeFunction code is supported, then first validate the incoming and
    // outgoing buffers.
    //

    if(S_OK == hr){

        //
        // validate the incoming data buffer
        //

        if(IsBadReadPtr(pInData,cbInDataSize)){
            hr = E_UNEXPECTED;
        }

        //
        // if the incoming buffer is valid, proceed to validate the
        // outgoing buffer
        //

        if(S_OK == hr){
            if(IsBadWritePtr(pOutData,cbOutDataSize)){
                hr = E_UNEXPECTED;
            } else {

                //
                // validate the outgoing size pointer
                //

                if(IsBadWritePtr(pcbActualData,sizeof(DWORD))){
                    hr = E_UNEXPECTED;
                }
            }
        }

        //
        // now that buffer validation is complete, proceed to process the proper
        // EscapeFunction code.
        //

        if (S_OK == hr) {

            //
            // only process a validated EscapeFunction code, and buffers
            //

        }
    }

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::GetLastError
*
*   GetLastError is called to obtain the last operation error code reported
*   by the WIA device.  This is an error code that is specific to the WIA
*   driver.  If the caller wants more information about this error code then
*   they will call GetLastErrorInfo().  The GetLastErrorInfo() method is
*   responsible for adding more details about the requested error. (strings,
*   extended codes...etc)
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to a DWORD indicating the last error code.
*
* Return Value:
*
*    S_OK  - if the data can be written correctly
*    E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetLastError");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pdwLastDeviceError) {
        return E_INVALIDARG;
    }

    *pdwLastDeviceError = m_dwLastOperationError;
    return S_OK;
}

/**************************************************************************\
* CWIADevice::LockDevice
*
*   LockDevice is called to lock a WIA device for exclusive access.  This
*   method can be called directly by an application using the legacy STI
*   APIs, or by the WIA service.
*
*   A device should return STIERR_DEVICE_LOCKED if it has already been
*   locked by another client.  The WIA service will call LockDevice to
*   control the exclusive access to the WIA device.
*
*   Do not get this confused with drvLockWiaDevice().  IStiUsd::LockDevice
*   can get called directly by an appliation using the legacy STI APIs.
*   drvLockWiaDevice() is only called by the WIA service.  No appliation can
*   call drvLockWiaDevice().
*
* Arguments:
*
*    None
*
* Return Value:
*
*    S_OK  - if the device was successfully locked
*    STIERR_DEVICE_LOCKED - Error code if the device is already locked
*
* Remarks:
*
*    The WIA shell extension, which controls the visibility of a WIA device
*    in the "My Computer" and "Control Panel", calls LockDevice() directly.
*    This is used to lock the the device so the IStiUsd::Diagnostic() method
*    can get called when the user presses the "TEST Device" button.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::LockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::LockDevice");
    //
    // be very careful about how long locks are held.  An application can
    // come in using the STI APIs only, and lock your device.  This lock,
    // if held indefinitly could prevent access to your device from other
    // applications installed on the system.

    //
    // It might be useful to implement some sort of reasonable locking timeout
    // mechanism.  If a lock is held too long, then it should be auto-unlocked.
    // to allow others to access the device.
    // *** This should only be done, if you know it is safe to unlock your hardware.
    // Cases that may take a long time (like HUGE scans) can hold a lock for the entire
    // length.  A good question to ask in a long-locking case, is, "what is my driver
    // doing, that requires such a long locking time?"
    //

    HRESULT hr = S_OK;
    if (m_bDeviceLocked) {
        hr = STIERR_DEVICE_LOCKED;
    } else {
        m_bDeviceLocked = TRUE;
    }
    return hr;
}

/**************************************************************************\
* CWIADevice::UnLockDevice
*
*   UnLockDevice is called to unlock a WIA device from exclusive access.  This
*   method can be called directly by an application using the legacy STI
*   APIs, or by the WIA service.
*
*   A device should return STIERR_NEEDS_LOCK if it has not already been
*   locked by another client.  The WIA service will call UnLockDevice to
*   release exclusive access to the WIA device.
*
*   Do not get this confused with drvUnLockWiaDevice().  IStiUsd::UnLockDevice
*   can get called directly by an appliation using the legacy STI APIs.
*   drvUnLockWiaDevice() is only called by the WIA service.  No appliation can
*   call drvUnLockWiaDevice().
*
* Arguments:
*
*    None
*
* Return Value:
*
*    S_OK  - if the device was successfully locked
*    STIERR_NEEDS_LOCK - Error code if the device isn't already locked
*
* Remarks:
*
*    The WIA shell extension, which controls the visibility of a WIA device
*    in the "My Computer" and "Control Panel", calls UnLockDevice() directly.
*    (see IStiUsd::LockDevice() for details)
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::UnLockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::UnLockDevice");
    HRESULT hr = S_OK;
    if (!m_bDeviceLocked)
        hr = STIERR_NEEDS_LOCK;
    else {
        m_bDeviceLocked = FALSE;
    }
    return hr;
}

/**************************************************************************\
* CWIADevice::RawReadData
*
*   RawReadData is called to access the hardware directly.  Any application
*   that uses the legacy STI APIs can call RawReadData().  This method is
*   used when an application (useally a vendor-supplied application or library)
*   wants to read data from an open device port (controlled by this WIA driver).
*
* Arguments:
*
*    lpBuffer          - buffer for returned data
*    lpdwNumberOfBytes - number of bytes to read/returned
*    lpOverlapped      - overlap
*
* Return Value:
*
*    S_OK - if the read was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::RawReadData(
                                           LPVOID       lpBuffer,
                                           LPDWORD      lpdwNumberOfBytes,
                                           LPOVERLAPPED lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::RawReadData");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!lpdwNumberOfBytes){
        return E_INVALIDARG;
    }

    DWORD dwNumberOfBytes = *lpdwNumberOfBytes;

    if(!lpBuffer){
        return E_INVALIDARG;
    }

    //
    // lpOverlapped is used by a call to ReadFile, or DeviceIOControl call.  This
    // parameter can be NULL according to those APIs.
    //

    HRESULT hr = E_NOTIMPL;

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::RawWriteData
*
*   RawWriteData is called to access the hardware directly.  Any application
*   that uses the legacy STI APIs can call RawWriteData().  This method is
*   used when an application (useally a vendor-supplied application or library)
*   wants to write data to an open device port (controlled by this WIA driver).
*
* Arguments:
*
*    lpBuffer        - buffer for returned data
*    dwNumberOfBytes - number of bytes to write
*    lpOverlapped    - overlap
*
* Return Value:
*
*    S_OK - if the write was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::RawWriteData(
                                            LPVOID          lpBuffer,
                                            DWORD           dwNumberOfBytes,
                                            LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::RawWriteData");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!lpBuffer){
        return E_INVALIDARG;
    }

    //
    // lpOverlapped is used by a call to ReadFile, or DeviceIOControl call.  This
    // parameter can be NULL according to those APIs.
    //

    HRESULT hr = E_NOTIMPL;

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::RawReadCommand
*
*   RawReadCommand is called to access the hardware directly.  Any application
*   that uses the legacy STI APIs can call RawReadCommand().  This method is
*   used when an application (useally a vendor-supplied application or library)
*   wants to read data from an open device port (controlled by this WIA driver).
*
* Arguments:
*
*    lpBuffer          - buffer for returned data
*    lpdwNumberOfBytes - number of bytes to read/returned
*    lpOverlapped      - overlap
*
* Return Value:
*
*    S_OK - if the read was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::RawReadCommand(
                                              LPVOID          lpBuffer,
                                              LPDWORD         lpdwNumberOfBytes,
                                              LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::RawReadCommand");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!lpdwNumberOfBytes){
        return E_INVALIDARG;
    }

    DWORD dwNumberOfBytes = *lpdwNumberOfBytes;

    if(!lpBuffer){
        return E_INVALIDARG;
    }

    //
    // lpOverlapped is used by a call to ReadFile, or DeviceIOControl call.  This
    // parameter can be NULL according to those APIs.
    //

    HRESULT hr = E_NOTIMPL;

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::RawWriteCommand
*
*   RawWriteCommand is called to access the hardware directly.  Any application
*   that uses the legacy STI APIs can call RawWriteCommand().  This method is
*   used when an application (useally a vendor-supplied application or library)
*   wants to write data to an open device port (controlled by this WIA driver).
*
* Arguments:
*
*    lpBuffer       - buffer for returned data
*    nNumberOfBytes - number of bytes to write
*    lpOverlapped   - overlap
*
* Return Value:
*
*    S_OK - if the write was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::RawWriteCommand(
                                               LPVOID          lpBuffer,
                                               DWORD           dwNumberOfBytes,
                                               LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::RawWriteCommand");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!lpBuffer){
        return E_INVALIDARG;
    }

    //
    // lpOverlapped is used by a call to ReadFile, or DeviceIOControl call.  This
    // parameter can be NULL according to those APIs.
    //

    HRESULT hr = E_NOTIMPL;

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::SetNotificationHandle
*
*   SetNotificationHandle is called by the WIA service or internally by this
*   driver to start or stop event notifications.  The WIA service will pass
*   in a valid handle (created using CreateEvent() ), indicating that it
*   wants the WIA driver to signal this handle when an event occurs in the
*   hardware.
*
*   NULL can be passed to this SetNotificationHandle() method.  NULL
*   indicates that the WIA driver is to STOP all device activity, and exit
*   any event wait operations.
*
* Arguments:
*
*    hEvent -   HANDLE to an event created by the WIA service using CreateEvent()
*               This parameter can be NULL, indicating that all previous event
*               waiting should be stopped.
*
* Return Value:
*
*    S_OK - if the operation was successful
*    E_xxx - Error Code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::SetNotificationHandle(HANDLE hEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::SetNotificationHandle");

    HRESULT hr = S_OK;

    if (hEvent && (hEvent != INVALID_HANDLE_VALUE)) {

        //
        // A valid handle indicates that we are asked to start our "wait"
        // for device interrupt events
        //

        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, hEvent = %d",hEvent));

        //
        // reset last event GUID to GUID_NULL
        //

        m_guidLastEvent = GUID_NULL;

        //
        // clear EventOverlapped structure
        //

        memset(&m_EventOverlapped,0,sizeof(m_EventOverlapped));

        //
        // fill overlapped hEvent member with the event passed in by the WIA service.
        // This handle will be automatically signaled when an event is triggered at
        // the hardware level.
        //

        m_EventOverlapped.hEvent = hEvent;

        //
        // clear event data buffer.  This is the buffer that will be used to determine
        // what event was signaled from the device.
        //

        memset(m_EventData,0,sizeof(m_EventData));

        //
        // the code block below starts an interrupt event session using DeviceIoControl()
        //

#ifdef USE_REAL_EVENTS

        //
        // use the following call for interrupt events on your device
        //

        DWORD dwError = 0;
        BOOL bResult = DeviceIoControl( m_hDeviceDataHandle,
                                        IOCTL_WAIT_ON_DEVICE_EVENT,
                                        NULL,
                                        0,
                                        &m_EventData,
                                        sizeof(m_EventData),
                                        &dwError,
                                        &m_EventOverlapped );

        if (bResult) {
            hr = S_OK;
        } else {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }

#else // USE_REAL_EVENTS

        //
        // THIS IS FOR TESTING ONLY, DO NOT USE THIS METHOD FOR PROCESSING DEVICE EVENTS!!!
        //

        if (m_hFakeEventKey) {
            RegCloseKey(m_hFakeEventKey);
            m_hFakeEventKey = NULL;
        }

        DWORD dwDisposition = 0;
        if (RegCreateKeyEx(HKEY_CURRENT_USER,
                           HKEY_WIASCANR_FAKE_EVENTS,
                           0,
                           NULL,
                           0,
                           KEY_READ,
                           NULL,
                           &m_hFakeEventKey,
                           &dwDisposition) == ERROR_SUCCESS) {

            if (RegNotifyChangeKeyValue(
                                       m_hFakeEventKey,            // handle to key to watch
                                       FALSE,                      // subkey notification option
                                       REG_NOTIFY_CHANGE_LAST_SET, // changes to be reported
                                       m_EventOverlapped.hEvent,   // handle to event to be signaled
                                       TRUE                        // asynchronous reporting option
                                       ) == ERROR_SUCCESS ) {


            }
        }

#endif // USE_REAL_EVENTS

    } else {

        //
        // stop any hardware waiting events here, the WIA service has notified us to kill
        // all hardware event waiting
        //

        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Disabling event Notifications"));

#ifdef USE_REAL_EVENTS

        //
        // Stop hardware interrupt events.  This will actually stop all activity on the device.
        // Since DeviceIOControl was used with OVERLAPPED i/o functionality the CancelIo()
        // can be used to stop all kernel mode activity.
        //

        //
        // NOTE: It is important to use overlapped i/o calls with all activity involving the
        //       kernel mode drivers.  This will allow for proper time-outs and cancellation
        //       of device requests.
        //

        if(m_hDeviceDataHandle){
            if(!CancelIo(m_hDeviceDataHandle)){

                //
                // cancelling of the IO failed, call GetLastError() here to determine the cause.
                //

                LONG lError = ::GetLastError();

            }
        }

#else   // USE_REAL_EVENTS

        if (m_hFakeEventKey) {
            RegCloseKey(m_hFakeEventKey);
            m_hFakeEventKey = NULL;
        }

#endif  // USE_REAL_EVENTS

    }
    return hr;
}

/**************************************************************************\
* CWIADevice::GetNotificationData
*
*   GetNotificationData is called by the WIA service to get information about
*   an event that has just been signaled.  GetNotificationsData can be called
*   as a result of one of two event operations.
*
*   1. GetStatus() reported that there was an event pending, by setting the
*      STI_EVENTHANDLING_PENDING flag in the STI_DEVICE_STATUS structure.
*
*   2. The hEvent handle passed in by SetNotificationHandle() was signaled
*      by the hardware, or by calling SetEvent() directly.
*
*   The WIA driver is responsible for filling out the STINOTIFY structure
*   members:
*       dwSize - size of the STINOTIFY structure.
*       guidNotificationCode - GUID that represents the event that is to be
*                              responded to.  This should be set to GUID_NULL
*                              if no event is to be sent.  This will tell the
*                              WIA service that no event really happened.
*       abNotificationData - OPTIONAL - vendor specific information. This data
*                            is limited to 64 bytes of data ONLY.
*
* Arguments:
*
*    pBuffer    - Pointer to a STINOTIFY structure.
*
* Return Value:
*
*    S_OK  - if the data can be written successfully
*    E_xxx - Error code if the operation fails
*
* Remarks:
*
*   This WIA driver checks the m_bPolledEvent flag to determine where to get
*   the event information from.  If this flag is TRUE, it uses the event GUID
*   already set by the GetStatus() call. (see GetStatus comments for details)
*   If this flag is FALSE, then the WIA driver needs to look at the OVERLAPPED
*   result for more information.  The m_EventData BYTE array should contain
*   information about the event.  This is also where you can ask the device
*   more information about what event just occured.
*
* Sample Notes:
*
*   This WIA sample driver uses the Windows Registry to simulate the interrupt
*   event signaling.  It is not recommended to use this method in a production
*   driver.  The #define USE_REAL_EVENTS should be defined to build a WIA driver
*   that uses real device events.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetNotificationData");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!pBuffer){
        return E_INVALIDARG;
    }

    DWORD dwBytesRet = 0;

    //
    // check the event source flag, m_bPolledEvent.
    // * If it is TRUE, just pass the event set in GetStatus() call to
    // the STINOTIFY buffer and continue.
    //
    // * If it is FALSE, then you need to read the m_EventData buffer
    // to determine what event was fired.
    //

    if (m_bPolledEvent == FALSE) {

#ifdef USE_REAL_EVENTS

        BOOL bResult = GetOverlappedResult(m_hDeviceDataHandle, &m_EventOverlapped, &dwBytesRet, FALSE );
        if (bResult) {
            //
            // read the m_EventData buffer to determine the proper event.
            // set the m_guidLastEvent member to the proper event GUID
            // set the m_guidLastEvent to GUID_NULL when an event has
            // not happened that you are concerned with
            //
        }

#else   // USE_REAL_EVENTS

        if(m_hFakeEventKey){
            LONG  lEventCode = 0;
            DWORD dwEventCodeSize = sizeof(lEventCode);
            DWORD dwType = REG_DWORD;
            if(RegQueryValueEx(m_hFakeEventKey,
                               WIASCANR_DWORD_FAKE_EVENT_CODE,
                               NULL,
                               &dwType,
                               (BYTE*)&lEventCode,
                               &dwEventCodeSize) == ERROR_SUCCESS){

                //
                // process event code
                //

                switch(lEventCode){
                case ID_FAKE_SCANBUTTON:
                    m_guidLastEvent = WIA_EVENT_SCAN_IMAGE;
                    break;
                case ID_FAKE_COPYBUTTON:
                    m_guidLastEvent = WIA_EVENT_SCAN_PRINT_IMAGE;
                    break;
                case ID_FAKE_FAXBUTTON:
                    m_guidLastEvent = WIA_EVENT_SCAN_FAX_IMAGE;
                    break;
                case ID_FAKE_NOEVENT:
                default:
                    break;
                }
            }
        }

#endif  // USE_REAL_EVENTS

    }

    //
    // If the event was triggered, then fill in the STINOTIFY structure with
    // the proper event information
    //

    if (m_guidLastEvent != GUID_NULL) {
        memset(pBuffer,0,sizeof(STINOTIFY));
        pBuffer->dwSize               = sizeof(STINOTIFY);
        pBuffer->guidNotificationCode = m_guidLastEvent;

        //
        // reset the Last event GUID to GUID_NULL to clear the cached event
        //

        m_guidLastEvent = GUID_NULL;
    } else {
        return STIERR_NOEVENTS;
    }

    return S_OK;
}

/**************************************************************************\
* CWIADevice::GetLastErrorInfo
*
*   GetLastErrorInfo is called to get more information about a WIA device
*   specific error code.  This code could come from the IStiUsd::GetLastError()
*   method call, or a vendor specific application may want more information
*   about a known error code.
*
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    S_OK  - if the data can be written correctly
*    E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetLastErrorInfo");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pLastErrorInfo) {
        return E_INVALIDARG;
    }

    pLastErrorInfo->dwGenericError         = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0] = '\0';

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiascanr.rc
//

// Device Events, and Commands (Name strings)
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     100
#define IDS_CMD_SYNCRONIZE_NAME            101
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_EVENT_SCANBUTTON_NAME          104
#define IDS_EVENT_COPYBUTTON_NAME          105
#define IDS_EVENT_FAXBUTTON_NAME           106

// Device Events, and Commands (Description strings)
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     200
#define IDS_CMD_SYNCRONIZE_DESC            201
#define IDS_EVENT_DEVICE_CONNECTED_DESC    202
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 203
#define IDS_EVENT_SCANBUTTON_DESC          204
#define IDS_EVENT_COPYBUTTON_DESC          205
#define IDS_EVENT_FAXBUTTON_DESC           206

#define IDS_ROOTITEM_NAME                  300
#define IDS_TOPITEM_NAME                   301

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        700
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           700
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IWiaMiniDrv methods.
*
*******************************************************************************/

#include "pch.h"
#include <stdio.h>

extern HINSTANCE g_hInst;           // used for WIAS_LOGPROC macro

/**************************************************************************\
* CWIADevice::drvInitializeWia
*
*   drvInitializeWia is called by the WIA service in response to a WIA
*   application's call to IWiaDevMgr::CreateDevice (described in the
*   Platform SDK documentation), which means that this method is
*   called once for each new client connection.
*
*   This method should initialize any private structures and create the
*   driver item tree.  The driver item tree shows the layout of all WIA
*   items supported by this WIA device.  This method is for creating the
*   initial tree structure only, NOT the contents (WIA properties).  WIA properties for
*   these WIA driver items will be populated individually by multiple calls by
*   the WIA service to IWiaMiniDrv::drvInitItemProperties().
*
*   All WIA devices have a ROOT item.  This item is the parent to all
*   WIA device items.  To create a WIA device item the WIA driver should call
*   the WIA service helper function. wiasCreateDrvItem().
*
*   Example:
*
*   Creating a WIA device ROOT item might look like the following:
*
*   LONG lItemFlags = WiaItemTypeFolder|WiaItemTypeDevice|WiaItemTypeRoot;
*
*   IWiaDrvItem  *pIWiaDrvRootItem  = NULL;
*
*   HRESULT hr = wiasCreateDrvItem(lItemFlags,           // item flags
*                                  bstrRootItemName,     // item name ("Root")
*                                  bstrRootFullItemName, // item full name ("0000\Root")
*                                  (IWiaMiniDrv *)this,  // this WIA driver object
*                                  sizeof(MINIDRIVERITEMCONTEXT), // size of context
*                                  NULL,                 // context
*                                  &pIWiaDrvRootItem);   // created ROOT item
*                                                        // (IWiaDrvItem interface)
*
*   if(S_OK == hr){
*
*       //
*       // ROOT item was created successfully
*       //
*
*   }
*
*   Example:
*
*   Creating a WIA child item, located directly under the ROOT item we created in the
*   above sample might look like the following:
*
*   NOTE: notice the calling of IWiaDrvItem::AddItemToFolder() method to add the
*         newly created chld item to the ROOT item.
*
*   LONG lItemFlags = WiaItemTypeFile|WiaItemTypeDevice|WiaItemTypeImage;
*
*   PMINIDRIVERITEMCONTEXT pItemContext    = NULL;
*   IWiaDrvItem           *pIWiaDrvNewItem = NULL;
*
*   HRESULT hr = wiasCreateDrvItem(lItemFlags,           // item flags
*                                  bstrItemName,         // item name ("Flatbed")
*                                  bstrFullItemName,     // item full name ("0000\Root\Flatbed")
*                                  (IWiaMiniDrv *)this,  // this WIA driver object
*                                  sizeof(MINIDRIVERITEMCONTEXT), // size of context
*                                  (PBYTE)&pItemContext, // context
*                                  &pIWiaDrvNewItem);    // created child item
*                                                        // (IWiaDrvItem interface)
*
*   if(S_OK == hr){
*
*       //
*       // A New WIA driver item was created successfully
*       //
*
*       hr = pIWiaDrvNewItem->AddItemToFolder(pIWiaDrvRootItem); // add the new item to the ROOT
*       if(S_OK == hr){
*
*           //
*           // successfully created and added a new WIA driver item to the WIA driver item
*           // tree.
*           //
*
*       }
*       pNewItem->Release();
*       pNewItem = NULL;
*   }
*
*
*   See the DDK documentation on the proper flags for describing a WIA driver item.
*
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
* Return Value:
*
*   S_OK - if the operation was successful
*   E_xxx - Error Code if the operation failed
*
* Sample Notes:
*   This WIA sample driver calls an internal helper function called BuildItemTree().
*   This function follows the instructions outlined in the comments for
*   creating WIA driver items.
*   This WIA sample driver also breaks the initialization of some internal
*   structures (i.e. BuildCapabilities()) into separate helper functions.
*   When this driver's drvInitializeWia() method is called, it takes a moment
*   to create the necessary data for WIA property initialization (which happens
*   at the drvInitItemProperties)
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvInitializeWia(
                                                    BYTE        *pWiasContext,
                                                    LONG        lFlags,
                                                    BSTR        bstrDeviceID,
                                                    BSTR        bstrRootFullItemName,
                                                    IUnknown    *pStiDevice,
                                                    IUnknown    *pIUnknownOuter,
                                                    IWiaDrvItem **ppIDrvItemRoot,
                                                    IUnknown    **ppIUnknownInner,
                                                    LONG        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvInitializeWia");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrDeviceID         = %ws", bstrDeviceID));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrRootFullItemName = %ws",bstrRootFullItemName));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, lFlags               = %d",lFlags));
    HRESULT hr = S_OK;

    *plDevErrVal = 0;
    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;

    //
    //  Need to init names and STI pointer?
    //

    if (m_pStiDevice == NULL) {

        //
        // save STI device interface for locking
        //

        m_pStiDevice = (IStiDevice *)pStiDevice;
    }

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize SupportedFormats array
    //

    hr = BuildSupportedFormats();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Data Type array
    //

    hr = BuildSupportedDataTypes();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedDataTypes failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Intents array
    //

    hr = BuildSupportedIntents();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedIntents failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported TYMED array
    //

    hr = BuildSupportedTYMED();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSuportedTYMED failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported compression types array
    //

    hr = BuildSupportedCompressions();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedCompressions"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported Preview modes array
    //

    hr = BuildSupportedPreviewModes();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedPreviewModes"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  initial formats array
    //

    hr = BuildInitialFormats();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildInitialFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize supported resolutions array
    //

    hr = BuildSupportedResolutions();
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedResolutions failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // build WIA item tree
    //

    LONG lItemFlags = WiaItemTypeFolder|WiaItemTypeDevice|WiaItemTypeRoot;

    IWiaDrvItem  *pIWiaDrvRootItem  = NULL;

    //
    // create the ROOT item of the WIA device.  This name should NOT be localized
    // in different languages. "Root" is used by WIA drivers.
    //

    BSTR bstrRootItemName = SysAllocString(WIA_DEVICE_ROOT_NAME);
    if(!bstrRootItemName) {
        return E_OUTOFMEMORY;
    }

    hr = wiasCreateDrvItem(lItemFlags,           // item flags
                           bstrRootItemName,     // item name ("Root")
                           bstrRootFullItemName, // item full name ("0000\Root")
                           (IWiaMiniDrv *)this,  // this WIA driver object
                           sizeof(MINIDRIVERITEMCONTEXT), // size of context
                           NULL,                 // context
                           &pIWiaDrvRootItem);   // created ROOT item
                                                 // (IWiaDrvItem interface)
    if (S_OK == hr) {

        //
        // ROOT item was created successfully, save the newly created Root item
        // in the pointer given by the WIA service (ppIDrvItemRoot).
        //

        *ppIDrvItemRoot = pIWiaDrvRootItem;

        //
        // Create a child item  directly under the Root WIA item
        //

        lItemFlags = WiaItemTypeFile|WiaItemTypeDevice|WiaItemTypeImage;

        PMINIDRIVERITEMCONTEXT pItemContext    = NULL;
        IWiaDrvItem           *pIWiaDrvNewItem = NULL;

        //
        // create a name for the WIA child item.  "Flatbed" is used by WIA drivers that
        // support a flatbed scanner.
        //

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER
        BSTR bstrItemName = SysAllocString(WIA_DEVICE_FEEDER_NAME);
#else
        BSTR bstrItemName = SysAllocString(WIA_DEVICE_FLATBED_NAME);
#endif

        if (bstrItemName) {

            WCHAR  wszFullItemName[MAX_PATH + 1] = {0};
            _snwprintf(wszFullItemName,(sizeof(wszFullItemName) / sizeof(WCHAR)) - 1,L"%ls\\%ls",
                       bstrRootFullItemName,bstrItemName);

            BSTR bstrFullItemName = SysAllocString(wszFullItemName);
            if (bstrFullItemName) {
                hr = wiasCreateDrvItem(lItemFlags,           // item flags
                                       bstrItemName,         // item name ("Flatbed")
                                       bstrFullItemName,     // item full name ("0000\Root\Flatbed")
                                       (IWiaMiniDrv *)this,  // this WIA driver object
                                       sizeof(MINIDRIVERITEMCONTEXT), // size of context
                                       (BYTE**)&pItemContext, // context
                                       &pIWiaDrvNewItem);    // created child item
                                                             // (IWiaDrvItem interface)

                if (S_OK == hr) {

                    //
                    // A New WIA driver item was created successfully
                    //

                    hr = pIWiaDrvNewItem->AddItemToFolder(pIWiaDrvRootItem); // add the new item to the ROOT
                    if (S_OK == hr) {

                        //
                        // successfully created and added a new WIA driver item to the WIA driver item
                        // tree.
                        //

                    }

                    //
                    // The new item is no longer needed, because it has been passed to the WIA
                    // service.
                    //

                    pIWiaDrvNewItem->Release();
                    pIWiaDrvNewItem = NULL;
                }
                SysFreeString(bstrFullItemName);
                bstrFullItemName = NULL;
            } else {
                hr = E_OUTOFMEMORY;
            }
            SysFreeString(bstrItemName);
            bstrItemName = NULL;
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // increment application connection count
    //

    if(S_OK == hr){
        InterlockedIncrement(&m_lClientsConnected);
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::drvAcquireItemData
*
*   drvAcquireItemData is called by the WIA service when data it being
*   requested from a WIA item.  The WIA driver should determine what type of
*   transfer the application is attempting by looking at the following
*   members of the MINIDRV_TRANSFER_CONTEXT:
*
*       pmdtc->tymed - TYMED set by the application.
*           TYMED_FILE               - transfer for file.
*           TYMED_MULTIPAGE_FILE     - transfer to a multipage file format
*           TYMED_CALLBACK           - transfer to memory
*           TYMED_MULTIPAGE_CALLBACK - transfer to memory (multiple pages)
*
*   The different TYMED settings xxx_CALLBACK and xxx_FILE change the usage of
*   calling the application's callback interface.
*
*   xxx_CALLBACK:
*        call: pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback()
*
*        IT_MSG_DATA                  - we are transferring data.
*        IT_STATUS_TRANSFER_TO_CLIENT - data transfer message
*        PercentComplete              - percent complete of the entire transfer
*        pmdtc->cbOffset              - should be updated on the current location
*                                       that the application should write the next
*                                       data chunk.
*        BytesReceived                - number of bytes in the data chunk being sent to the
*                                       application.
*        pmdtc                        - MINIDRV_TRANSFER_CONTEXT context
*
*   xxx_FILE:
*        call: pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback()
*
*        IT_MSG_STATUS                - we are only sending status (NO DATA!!!)
*        IT_STATUS_TRANSFER_TO_CLIENT - data transfer message
*        PercentComplete              - percent complete of the entire transfer
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA item, Item used for transfer
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK - if the operation was successful
*   E_xxx - Error Code if the operation failed
*
* Sample Notes:
*   This WIA sample driver transfers data from two different sources.
*       1. flatbed
*       2. document feeder
*          a. standard feeder type
*          b. unknown page length feeder type
*             (when the UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER is used to build the
*              driver)
*
*   Notice the percent complete calculations for the unknown page length
*   scanner.  This sample knows that it can receive any page length from
*   the user.  It also knows that the average page used in this device is
*   AVERAGE_FAKE_PAGE_HEIGHT_INCHES in height.  Taking this into account
*   it calculates a rough percentage, so it an return percent complete to
*   the application.  When it receives data larger than the average page
*   length, it halts the percent complete to 95%, allowing the scan to
*   complete.  There are better ways to do this, and this is the one this
*   sample chooses to use.
*
*   Scanning from a feeder:
*
*   This WIA sample driver performs a few checks before continuing with a
*   feeder scan.
*
*   1. check if we are in FEEDER mode.
*       - This is done by looking at the m_bADFEnabled flag.  This flag is
*         set to TRUE when an application writes the WIA_DPS_DOCUMENT_HANDLING_SELECT
*         property to FEEDER.
*   2. checks the requested page count.
*       - This is done by looking at the WIA_DPS_PAGES property, set by the
*         application.
*         zero         ( 0) = scan all pages in the feeder
*         greater than (>0) = scan up to the requested amount.
*   3. unfeeds a previous page.
*      - This could be a jammed page, or the last page in the feeder scanned.
*        Only do this if your device requires the ADF to be cleared before
*        use.
*   4. checks for paper in the feeder.
*      - Always check for paper in the feeder before attempting to scan.
*        If you are about to scan the FIRST page, and no paper is detected
*        return a WIA_ERROR_PAPER_EMPTY error code.
*        If you are scanning the SECOND + pages, and no paper is detected
*        return a WIA_ERROR_PAPER_EMPTY error code or WIA_STATUS_END_OF_MEDIA
*        success code.
*   5. feed a page into the feeder.
*      - Only do this if your device requires the page to be prefed before
*        scanning.  Some document feeders auto-feed a page while scanning.
*        if your document feeder does this...you can skip this step.
*   6. check the feeder's status.
*      - make sure the feeder is in "GO" mode.  Everything checks out, and you
*        are ready to scan.  This will help catch paper jams, or other feeder
*        related problems that can occur before scanning.
*   7. scan
*   8. repeat steps 1 - 7 until all requested pages have been scanned, or
*      until the document feeder is out of paper.
*
*
*   Why is my ITEM SIZE set to ZERO (0)???
*
*   This WIA sample driver sets the WIA item size to zero (0).  This indicates to
*   the application that the WIA driver does not know the resulting image size.
*   This indicates to the WIA service, that the WIA driver wants to allocate it's
*   own data buffers.
*
*   This WIA driver reads the WIA_IPA_BUFFER_SIZE property and allocates a chunk
*   for a single band of data.  The WIA driver can allocate any amount of memory
*   it needs here, but it is recommended to keep allocation small.
*
*   How do I know if the WIA service allocated memory for me??
*
*   check the pmdtc->bClassDrvAllocBuf flag.  If it is TRUE, then the WIA
*   service was kind enough to allocate memory for you.  To find out how
*   much memory that was, check the pmdtc->lBufferSize member.
*
*   If I allocate my own memory, how do I let the WIA service know?
*
*   Allocate memory using CoTaskMemAlloc(), and use the pointer located in
*   pmdtc->pTransferBuffer. (REMEMBER THAT YOU ALLOCATED THIS..SO YOU FREE IT!!)
*   Set the pmdtc->lBufferSize to equal the size you allocated.
*   As stated above, this WIA sample driver allocates it's WIA_IPA_BUFFER_SIZE
*   and uses that memory.
*
*   Read the comments located in the code below for more details on data
*   transfers.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvAcquireItemData(
                                                      BYTE                      *pWiasContext,
                                                      LONG                      lFlags,
                                                      PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                                      LONG                      *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvAcquireItemData");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!pmdtc) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    HRESULT hr = E_FAIL;
    LONG lBytesTransferredToApplication = 0;

    //
    // Check if we are in Preview Mode and take any special actions required for performing that type
    // of scan.
    //

    if (IsPreviewScan(pWiasContext)) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Preview Property is SET"));
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Preview Property is NOT SET"));
    }

    //
    // Get number of pages requested, for ADF scanning loop
    //
    // (1-n) = number of pages to scan, or util FEEDER is empty and can not fulfill the request
    //  (0)  = scan all pages until FEEDER is empty
    //
    // NOTE: The driver should return an error in two cases only:
    //       1. fails to scan the first page (with paper empty, or other error)
    //       2. fails duing an ADF scan, and the error is unrecoverable (data loss is involved.)
    //
    //       In case #2, the driver should return a WIA_STATUS_END_OF_MEDIA code when the ADF runs
    //       out of paper, before completing the (1-n) scans requested.  This will allow the application
    //       to properly handle the transfer. (no data loss was involved, just could not complete the full
    //        request.  Some pages did transfer, and the application is holding on to the images.)
    //

    //
    // assume that we are scanning 1 page, (from a feeder or a flatbed), and we are not
    // going to empty the ADF.
    //

    BOOL bEmptyTheADF = FALSE;
    LONG lPagesRequested = 1;
    LONG lPagesScanned = 0;

    //
    // only ask for page count, if the feeder has been enabled.  If it has not, then assume
    // we are using the flatbed.
    //

    if (m_bADFEnabled) {
        lPagesRequested = GetPageCount(pWiasContext);
        if (lPagesRequested == 0) {
            bEmptyTheADF    = TRUE;
            lPagesRequested = 1;// set to 1 so we can enter our loop
                                // WIA_ERROR_PAPER_EMPTY will terminate
                                // the loop...or an error, or a cancel..
                                //
        }
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages to Scan = %d",lPagesRequested));

    //
    // scan until requested page count = 0
    //

    //
    // This is the start of scanning a single page.  The while loop will continue for all pages.
    //

    while (lPagesRequested > 0) {

        //
        // If the FEEDER is enabled, then we need to perform some feeder operations to get
        // the device started.  Some operations, you may want to do here are:
        // check the feeder's status, check paper, feed a page, or even eject a jammed or
        // previous page.
        //

        if (m_bADFEnabled) {

            //
            // clear an potential paper that may be blocking the scan pathway.
            //

            hr = m_pScanAPI->FakeScanner_ADFUnFeedPage();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (begin transfer) Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // check feeder for paper
            //

            hr = m_pScanAPI->FakeScanner_ADFHasPaper();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFHasPaper Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            } else if (hr == S_FALSE) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADF Reports Paper Empty"));
                if (lPagesScanned == 0) {
                    return WIA_ERROR_PAPER_EMPTY;
                } else {
                    return WIA_STATUS_END_OF_MEDIA;
                }
            }

            //
            // attempt to load a page (only if needed)
            //

            hr = m_pScanAPI->FakeScanner_ADFFeedPage();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFFeedPage Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // Check feeder's status
            //

            hr = m_pScanAPI->FakeScanner_ADFStatus();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFStatus Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }
        }


        LONG lScanPhase = SCAN_START;
        LONG lClassDrvAllocSize = 0;

        //
        // (1) Memory allocation
        //

        if (pmdtc->bClassDrvAllocBuf) {

            //
            // WIA allocated the buffer for data transfers
            //

            lClassDrvAllocSize = pmdtc->lBufferSize;
            hr = S_OK;
        } else {

            //
            // Driver allocated the buffer for data transfers
            //

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_BUFFER_SIZE, &lClassDrvAllocSize,NULL,TRUE);
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_BUFFER_SIZE"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            pmdtc->pTransferBuffer = (PBYTE) CoTaskMemAlloc(lClassDrvAllocSize);
            if (!pmdtc->pTransferBuffer) {
                return E_OUTOFMEMORY;
            }
            pmdtc->lBufferSize = lClassDrvAllocSize;
        }

        //
        // (2) Gather all information about data transfer settings and
        //     calculate the total data amount to transfer
        //

        if (hr == S_OK) {
            //
            // WIA service will populate the MINIDRV_TRANSFER_CONTEXT by reading the WIA properties.
            //
            // The following values will be written as a result of the wiasGetImageInformation() call
            //
            // pmdtc->lWidthInPixels
            // pmdtc->lLines
            // pmdtc->lDepth
            // pmdtc->lXRes
            // pmdtc->lYRes
            // pmdtc->lCompression
            // pmdtc->lItemSize
            // pmdtc->guidFormatID
            // pmdtc->tymed
            //
            // if the FORMAT is set to BMP or MEMORYBMP, the the following values
            // will also be set automatically
            //
            // pmdtc->cbWidthInBytes
            // pmdtc->lImageSize
            // pmdtc->lHeaderSize
            // pmdtc->lItemSize (will be updated using the known image format information)
            //

            hr = wiasGetImageInformation(pWiasContext,0,pmdtc);
            if (hr == S_OK) {

                //
                // (4) Send the image data to the application
                //

                LONG lDepth = 0;
                hr = wiasReadPropLong(pWiasContext, WIA_IPA_DEPTH, &lDepth,NULL,TRUE);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_DEPTH"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                    return hr;
                }

                LONG lPixelsPerLine = 0;
                hr = wiasReadPropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, &lPixelsPerLine,NULL,TRUE);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_PIXELS_PER_LINE"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                    return hr;
                }

                LONG lBytesPerLineRaw     = ((lPixelsPerLine * lDepth) + 7) / 8;
                LONG lBytesPerLineAligned = (lPixelsPerLine * lDepth) + 31;
                lBytesPerLineAligned      = (lBytesPerLineAligned / 8) & 0xfffffffc;
                LONG lTotalImageBytes     = pmdtc->lImageSize + pmdtc->lHeaderSize;
                LONG lBytesReceived       = pmdtc->lHeaderSize;
                lBytesTransferredToApplication = 0;
                pmdtc->cbOffset = 0;

                while ((lBytesReceived)) {

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

                    //
                    // since the feeder can return random length pages, it is a good idea to pick a common
                    // size, and base that as the common transfer lenght.  This will allow you to show
                    // a relativly decent progress indicator percent complete value.
                    // Note:  If you ever get a percent complete over 100%, it is a good idea to stop the
                    //        increment, and hold around 95....or close to 100.  This will keep appliations
                    //        from displaying a strange 105%.. or 365% complete to the end user.  Remember that
                    //        the application will display the exact percent complete value you return to them.
                    //        This calculation has to be accurate, or close to accurate.
                    //

                    lTotalImageBytes = lBytesPerLineRaw * (AVERAGE_FAKE_PAGE_HEIGHT_INCHES * pmdtc->lYRes);
                    LONG lPercentComplete = (LONG)(((float)lBytesTransferredToApplication/(float)lTotalImageBytes) * 100.0f);

                    //
                    // lock percent complete at 95%, until the scan is complete..
                    //

                    if (lPercentComplete >= 95) {
                        lPercentComplete = 95;
                    }
#else
                    LONG lPercentComplete = (LONG)(((float)lBytesTransferredToApplication/(float)lTotalImageBytes) * 100.0f);
#endif
                    switch (pmdtc->tymed) {
                    case TYMED_MULTIPAGE_CALLBACK:
                    case TYMED_CALLBACK:
                        {
                            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,IT_STATUS_TRANSFER_TO_CLIENT,
                                                                              lPercentComplete,pmdtc->cbOffset,lBytesReceived,pmdtc,0);
                            pmdtc->cbOffset += lBytesReceived;
                            lBytesTransferredToApplication += lBytesReceived;
                        }
                        break;
                    case TYMED_MULTIPAGE_FILE:
                    case TYMED_FILE:
                        {
                            pmdtc->lItemSize = lBytesReceived;
                            hr = wiasWriteBufToFile(0,pmdtc);
                            if (FAILED(hr)) {
                                break;
                            }

                            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,IT_STATUS_TRANSFER_TO_CLIENT,
                                                                              lPercentComplete,0,0,NULL,0);
                            lBytesTransferredToApplication += lBytesReceived;
                        }
                        break;
                    default:
                        {
                            hr = E_FAIL;
                        }
                        break;
                    }

                    //
                    // scan from device, requesting lBytesToReadFromDevice
                    //

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

                    //
                    // request buffer size, until the scanner can not return any more data
                    //

                    LONG lBytesRemainingToTransfer = pmdtc->lBufferSize;
#else
                    LONG lBytesRemainingToTransfer = (lTotalImageBytes - lBytesTransferredToApplication);
                    if (lBytesRemainingToTransfer <= 0) {
                        break;
                    }
#endif

                    //
                    // calculate number of bytes to request from device
                    //

                    LONG lBytesToReadFromDevice = (lBytesRemainingToTransfer > pmdtc->lBufferSize) ? pmdtc->lBufferSize : lBytesRemainingToTransfer;

                    // RAW data request
                    lBytesToReadFromDevice = (lBytesToReadFromDevice / lBytesPerLineAligned) * lBytesPerLineRaw;

                    // Aligned data request
                    // lBytesToReadFromDevice = (lBytesToReadFromDevice / lBytesPerLineAligned) * lBytesPerLineAligned;

                    if ((hr == S_FALSE)||FAILED(hr)) {

                        //
                        // user canceled the scan, or the callback failed for some reason
                        //

                        lPagesRequested = 0; // set pages to 0 to cleanly exit loop
                        break;
                    }

                    //
                    // request byte amount from device
                    //

                    hr = m_pScanAPI->FakeScanner_Scan(lScanPhase, pmdtc->pTransferBuffer, lBytesToReadFromDevice, (DWORD*)&lBytesReceived);
                    if (FAILED(hr)) {
                        break;
                    }

                    //
                    // This scanner, when scanning in 24-bit color mode provides RAW data with the RED and BLUE channels
                    // swapped.  If your scanner does this too, then you should call the SwapBuffer24 helper function.
                    //

                    if (pmdtc->lDepth == 24) {

                        //
                        // we are scanning color, so we need to swap the RED and BLUE values becuase our scanner
                        // scans RAW like this.
                        //

                        SwapBuffer24(pmdtc->pTransferBuffer,lBytesReceived);
                    }

                    //
                    // this scanner returns Raw data.  If your scanner does this too, then you should call the AlignInPlace
                    // helper function to align the data.
                    //

                    lBytesReceived = AlignInPlace(pmdtc->pTransferBuffer,lBytesReceived,lBytesPerLineAligned,lBytesPerLineRaw);

                    //
                    // advance to the next scanning stage for the device
                    //

                    if (lScanPhase == SCAN_START) {
                        lScanPhase = SCAN_CONTINUE;
                    }
                } // while ((lBytesReceived))
            }
        }

        //
        // force scanner to return scan head, and close device from scanning session
        //

        HRESULT Temphr = m_pScanAPI->FakeScanner_Scan(SCAN_END, NULL, 0, NULL);
        if (FAILED(Temphr)) {

            //
            // scanner failed to park scanner head in start position
            //

        }

        //
        // free any allocated memory for buffers
        //

        if (!pmdtc->bClassDrvAllocBuf) {
            CoTaskMemFree(pmdtc->pTransferBuffer);
            pmdtc->pTransferBuffer = NULL;
            pmdtc->lBufferSize = 0;
        }

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // because we are scanning with a feeder that can not determine the page height, it is necessary
        // for the driver to update the final file created.  Since this device scans only BMP files, it
        // is easy to locate the BITMAPINFOHEADER, and BITMAPFILEHEADER and update the final values.
        // Values that should be updated for BMP files:
        //
        // BITMAPFILEINFO   - bfSize      = final file size
        // BITMAPINFOHEADER - biHeight    = final image height in pixels
        // BITMAPINFOHEADER - biSizeImage = final image size
        //

        if ((pmdtc->tymed == TYMED_FILE)&&(pmdtc->guidFormatID == WiaImgFmt_BMP)) {

            BYTE BMPHeaderData[sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)];
            memset(BMPHeaderData,0,sizeof(BMPHeaderData));

            //
            // read BMP header, already written to the file
            //

            if (SetFilePointer((HANDLE)((LONG_PTR)pmdtc->hFile),0,NULL,FILE_BEGIN) != INVALID_SET_FILE_POINTER) {

                DWORD dwBytesReadFromFile = 0;
                if (ReadFile((HANDLE)((LONG_PTR)pmdtc->hFile),(BYTE*)BMPHeaderData,sizeof(BMPHeaderData),&dwBytesReadFromFile,NULL)) {

                    //
                    // validate that the read was successful, by comparing sizes
                    //

                    if ((LONG)dwBytesReadFromFile != sizeof(BMPHeaderData)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Header was not read from the file correctly"));
                    }

                    //
                    // adjust BMP HEADER values
                    //

                    BITMAPINFOHEADER UNALIGNED *pBMPInfoHeader = (BITMAPINFOHEADER*)(&BMPHeaderData[0] + sizeof(BITMAPFILEHEADER));
                    BITMAPFILEHEADER UNALIGNED *pBMPFileHeader = (BITMAPFILEHEADER*)BMPHeaderData;

                    LONG lDepth = 0;
                    hr = wiasReadPropLong(pWiasContext, WIA_IPA_DEPTH, &lDepth,NULL,TRUE);
                    if (S_OK == hr) {
                        LONG lPixelsPerLine = 0;
                        hr = wiasReadPropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, &lPixelsPerLine,NULL,TRUE);
                        if (S_OK == hr) {
                            LONG lBytesPerLineRaw     = ((lPixelsPerLine * lDepth) + 7) / 8;
                            LONG lBytesPerLineAligned = (lPixelsPerLine * lDepth) + 31;
                            lBytesPerLineAligned      = (lBytesPerLineAligned / 8) & 0xfffffffc;

                            pBMPInfoHeader->biHeight    = (lBytesTransferredToApplication / lBytesPerLineAligned);
                            pBMPInfoHeader->biSizeImage = (pBMPInfoHeader->biHeight * lBytesPerLineAligned);
                            pBMPFileHeader->bfSize      = pBMPInfoHeader->biSizeImage + pBMPFileHeader->bfOffBits;

                            //
                            // write BMP header, back to the file
                            //

                            if (SetFilePointer((HANDLE)((LONG_PTR)pmdtc->hFile),0,NULL,FILE_BEGIN) != INVALID_SET_FILE_POINTER) {

                                DWORD dwBytesWrittenToFile = 0;
                                WriteFile((HANDLE)((LONG_PTR)pmdtc->hFile),(BYTE*)BMPHeaderData,sizeof(BMPHeaderData),&dwBytesWrittenToFile,NULL);

                                //
                                // validate that the write was successful, by comparing sizes
                                //

                                if ((LONG)dwBytesWrittenToFile != sizeof(BMPHeaderData)) {
                                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, Header was not written to file correctly"));
                                }
                            } else {

                                //
                                // could not set file pointer to beginning of file
                                //

                                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, SetFilePointer Failed to set file pointer to the beginning of the file"));
                                hr = E_FAIL;
                            }
                        } else {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_PIXELS_PER_LINE"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_DEPTH"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ReadFile Failed to read data file"));
                    hr = E_FAIL;
                }
            } else {

                //
                // could not set file pointer to beginning of file
                //

                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, SetFilePointer Failed to set file pointer to the beginning of the file"));
                hr = E_FAIL;
            }
        }

#endif


        //
        // if the scan is going well, we should decrement the pages requested counter
        //

        if (S_OK == hr) {

            //
            // decrease the pages requested counter
            //

            lPagesRequested--;

            //
            // if we were asked to scan all pages in the document feeder, then
            // keep the pages request counter above 0 to stay in the loop
            //

            if (bEmptyTheADF) {
                lPagesRequested = 1;
            }

            //
            // only send ENDOFPAGE messages when the driver is set to a CALLBACK mode
            //

            if ((pmdtc->tymed == TYMED_CALLBACK)||(pmdtc->tymed == TYMED_MULTIPAGE_CALLBACK)) {
                //
                // send the NEW_PAGE message, when scanning multiple pages
                // in callback mode.  This will let the calling application
                // know when an end-of-page has been hit.
                //

                hr = wiasSendEndOfPage(pWiasContext, lPagesScanned, pmdtc);
                if (FAILED(hr)) {
                    lPagesRequested = 0;
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasSendEndOfPage Failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }

            //
            // incremement number of pages scanned
            //

            lPagesScanned++;

        }

    } // while (lPagesRequested > 0)
    return hr;
}

/**************************************************************************\
* CWIADevice::drvInitItemProperties
*
*   drvInitItemProperties is called to initialize the WIA properties for
*   the requested item.  To find out what item is being initialized, use the
*   pWiasContext pointer to identify it.
*
*   This method is called for every item in the tree that is accessed by
*   an application.  If an application attempts to read a WIA property on an
*   item for the first time, the WIA service will ask the WIA driver to
*   initialize the WIA property set for that item.  Once the WIA property
*   set has been initialized, any other reads/writes on that WIA item will
*   not produce a drvInitItemProperties call.
*
*   After a drvInitItemProperties method call, the WIA item is marked as
*   initialized and is ready for use. (This is on a per-application connection
*   basis.)
*
* Arguments:
*
*   pWiasContext - Pointer to WIA context (item information).
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code if the operation failed
*
* Sample Notes:
*   This WIA driver sample calls the internal helper functions
*   BuildRootItemProperties(), and BuildChildItemProperties() to assist in the
*   construction of the WIA item property sets.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvInitItemProperties(BYTE *pWiasContext,LONG lFlags,LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvInitItemProperties");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    //  This device doesn't touch hardware to initialize the device item
    //  properties, so set plDevErrVal to 0.
    //

    *plDevErrVal = 0;

    //
    //  Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasGetDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Set initial item properties.
    //

    LONG    lItemType = 0;

    pDrvItem->GetItemFlags(&lItemType);

    if (lItemType & WiaItemTypeRoot) {

        //
        //  This is for the root item.
        //

        //
        // Build Root Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildRootItemProperties();

        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildRootItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Add the device specific root item property names,
        //  using WIA service.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_RootItemInitInfo.lNumProps,
                                  m_RootItemInitInfo.piPropIDs,
                                  m_RootItemInitInfo.pszPropNames);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_RootItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_RootItemInitInfo.piPropIDs   = %x",m_RootItemInitInfo.piPropIDs));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_RootItemInitInfo.pszPropNames  = %x",m_RootItemInitInfo.pszPropNames));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Set the device specific root item properties to
        //  their default values using WIA service.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_RootItemInitInfo.lNumProps,
                               m_RootItemInitInfo.psPropSpec,
                               m_RootItemInitInfo.pvPropVars);
        //
        // Free PROPVARIANT array, This frees any memory that was allocated for a prop variant value.
        //

        // FreePropVariantArray(m_RootItemInitInfo.lNumProps,m_RootItemInitInfo.pvPropVars);


        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_RootItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_RootItemInitInfo.pszPropNames  = %x",m_RootItemInitInfo.pszPropNames));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_RootItemInitInfo.pvPropVars   = %x",m_RootItemInitInfo.pvPropVars));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_RootItemInitInfo.lNumProps,
                                     m_RootItemInitInfo.psPropSpec,
                                     m_RootItemInitInfo.pwpiPropInfo);

        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteRootItemProperties();
    } else {

        //
        //  This is for the child item.(Top)
        //

        //
        // Build Top Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildChildItemProperties();

        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildChildItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteChildItemProperties();
            return hr;
        }

        //
        //  Use the WIA service to set the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_ChildItemInitInfo.lNumProps,
                                  m_ChildItemInitInfo.piPropIDs,
                                  m_ChildItemInitInfo.pszPropNames);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_ChildItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.piPropIDs   = %x",m_ChildItemInitInfo.piPropIDs));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.pszPropNames  = %x",m_ChildItemInitInfo.pszPropNames));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteChildItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the item properties to their default
        //  values.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_ChildItemInitInfo.lNumProps,
                               m_ChildItemInitInfo.psPropSpec,
                               m_ChildItemInitInfo.pvPropVars);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_ChildItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.pszPropNames  = %x",m_ChildItemInitInfo.pszPropNames));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.pvPropVars   = %x",m_ChildItemInitInfo.pvPropVars));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteChildItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_ChildItemInitInfo.lNumProps,
                                     m_ChildItemInitInfo.psPropSpec,
                                     m_ChildItemInitInfo.pwpiPropInfo);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_ChildItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.psPropSpec   = %x",m_ChildItemInitInfo.psPropSpec));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.pwpiPropInfo  = %x",m_ChildItemInitInfo.pwpiPropInfo));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteChildItemProperties();
            return hr;
        }

        //
        //  Set item size properties.
        //

        hr = SetItemSize(pWiasContext);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, SetItemSize failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteChildItemProperties();
    }
    return hr;
}


/**************************************************************************\
* CWIADevice::drvValidateItemProperties
*
*   drvValidateItemProperties is called when changes are made
*   to an item's WIA properties.  The WIA driver should not only check that
*   the values are valid, but must update any valid values that may change
*   as a result.
*
*   If an a WIA property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA item, unused.
*   lFlags       - Operation flags, unused.
*   nPropSpec    - The number of properties that are being written
*   pPropSpec    - An array of PropSpecs identifying the properties that
*                  are being written.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - if the operation failed.
*
* History:
*
*    03/05/2002 Original Version
***************************************************************************/

HRESULT _stdcall CWIADevice::drvValidateItemProperties(
                                                             BYTE           *pWiasContext,
                                                             LONG           lFlags,
                                                             ULONG          nPropSpec,
                                                             const PROPSPEC *pPropSpec,
                                                             LONG           *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvValidateItemProperties");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!pPropSpec) {
        return E_INVALIDARG;
    }

    HRESULT hr      = S_OK;
    LONG lItemType  = 0;
    WIA_PROPERTY_CONTEXT Context;

    *plDevErrVal = 0;

    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (SUCCEEDED(hr)) {
        if (lItemType & WiaItemTypeRoot) {

            //
            //  Validate root item
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                // Check ADF to see if the status settings need to be updated
                // Also switch between FEEDER/FLATBED modes
                //

                hr = CheckADFStatus(pWiasContext, &Context);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckADFStatus failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // check Preview Property only if validation is successful so far....
                //

                if (SUCCEEDED(hr)) {

                    //
                    // Check Preview property to see if the settings are valid
                    //

                    hr = CheckPreview(pWiasContext, &Context);
                    if (SUCCEEDED(hr)) {

                        //
                        // call WIA service helper to validate other properties
                        //

                        hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }

                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreview failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                }
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Root Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

        } else {

            //
            // validate item properties here
            //

            //
            //  Create a property context needed by some WIA Service
            //  functions used below.
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                //  Check Current Intent first
                //

                hr = CheckIntent(pWiasContext, &Context);
                if (SUCCEEDED(hr)) {

                    //
                    //  Check if DataType is being written
                    //

                    hr = CheckDataType(pWiasContext, &Context);
                    if (SUCCEEDED(hr)) {

                        //
                        //  Use the WIA service to update the scan rect
                        //  properties and valid values.
                        //

                        LONG lBedWidth  = 0;
                        LONG lBedHeight = 0;

                        hr = m_pScanAPI->FakeScanner_GetBedWidthAndHeight(&lBedWidth,&lBedHeight);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, FakeScanner_GetBedWidthAndHeight failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                            return hr;
                        }

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

                        //
                        // the unknown length feeder only scanner, formally called the scrollfed scanner
                        // has a fixed width, and only scans full pages.
                        //

                        lBedHeight = 0;

                        hr = CheckXExtent(pWiasContext,&Context,lBedWidth);
#else
                        hr = wiasUpdateScanRect(pWiasContext,&Context,lBedWidth,lBedHeight);
#endif
                        if (SUCCEEDED(hr)) {

                            //
                            //  Use the WIA Service to update the valid values
                            //  for Format.  These are based on the value of
                            //  WIA_IPA_TYMED, so validation is also performed
                            //  on the tymed property by the service.
                            //

                            hr = wiasUpdateValidFormat(pWiasContext,
                                                       &Context,
                                                       (IWiaMiniDrv*) this);

                            if (SUCCEEDED(hr)) {

                                //
                                // Check Preferred format
                                //

                                hr = CheckPreferredFormat(pWiasContext, &Context);
                                if (FAILED(hr)) {
                                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreferredFormat failed"));
                                    WIAS_LHRESULT(m_pIWiaLog, hr);
                                }
                            } else {
                                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateValidFormat failed"));
                                WIAS_LHRESULT(m_pIWiaLog, hr);
                            }
                        } else {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateScanRect failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckDataType failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckIntent failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
                wiasFreePropContext(&Context);
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Child Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            //  Update the item size
            //

            if (SUCCEEDED(hr)) {
                hr = SetItemSize(pWiasContext);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }

            //
            // call WIA service helper to validate other properties
            //

            if (SUCCEEDED(hr)) {

                //
                // check image format property, and validate our pages valid values
                //

                hr = UpdateValidPages(pWiasContext,&Context);
                if (SUCCEEDED(hr)) {
                    hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, UpdateValidPages failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    //
    // log HRESULT sent back to caller
    //

    if (FAILED(hr)) {
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::drvWriteItemProperties
*
*   drvWriteItemProperties is called by the WIA Service prior to
*   drvAcquireItemData when the client requests a data transfer.  The WIA
*   should commit any settings it needs to the hardware before returning
*   from this method.
*
*   When this method is called, the WIA driver has been commited to
*   performing a data transfer.  Any application that attempts to acquire
*   data at this time, will be failed by the WIA service with a
*   WIA_ERROR_BUSY.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvWriteItemProperties(
                                                          BYTE                      *pWiasContext,
                                                          LONG                      lFlags,
                                                          PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                                          LONG                      *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvWriteItemProperties");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *plDevErrVal = 0;
    LONG lNumProperties = 9;
    PROPVARIANT pv[9];
    PROPSPEC ps[9] = {
        {PRSPEC_PROPID, WIA_IPS_XRES},
        {PRSPEC_PROPID, WIA_IPS_YRES},
        {PRSPEC_PROPID, WIA_IPS_XPOS},
        {PRSPEC_PROPID, WIA_IPS_YPOS},
        {PRSPEC_PROPID, WIA_IPS_XEXTENT},
        {PRSPEC_PROPID, WIA_IPS_YEXTENT},
        {PRSPEC_PROPID, WIA_IPA_DATATYPE},
        {PRSPEC_PROPID, WIA_IPS_BRIGHTNESS},
        {PRSPEC_PROPID, WIA_IPS_CONTRAST}
    };

    //
    // initialize propvariant structures
    //

    for (int i = 0; i< lNumProperties;i++) {
        pv[i].vt = VT_I4;
    }

    //
    // read child item properties
    //

    hr = wiasReadMultiple(pWiasContext, lNumProperties, ps, pv, NULL);

    if (hr == S_OK) {

        hr = m_pScanAPI->FakeScanner_SetXYResolution(pv[0].lVal,pv[1].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting x any y resolutions failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetDataType(pv[6].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting data type failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetIntensity(pv[7].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting intensity failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetContrast(pv[8].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting contrast failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetSelectionArea(pv[2].lVal, pv[3].lVal, pv[4].lVal, pv[5].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting selection area (extents) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }
    return hr;
}

/**************************************************************************\
* CWIADevice::drvReadItemProperties
*
*   drvReadItemProperties is called when an application tries to
*   read a WIA Item's properties. The WIA Service will first notify
*   the driver by calling this method.
*   The WIA driver should verify that the property being read is accurate.
*   This is a good place to access the hardware for properties that require
*   device status.
*   WIA_DPS_DOCUMENT_HANDLING_STATUS, or WIA_DPA_DEVICE_TIME if your device
*   supports a clock.
*
*   NOTE:  The WIA driver should only go to the hardware on rare occasions.
*          communicating with the hardware too much in this call, will cause
*          the WIA driver to appear sluggish and slow.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvReadItemProperties(
                                                         BYTE           *pWiasContext,
                                                         LONG           lFlags,
                                                         ULONG          nPropSpec,
                                                         const PROPSPEC *pPropSpec,
                                                         LONG           *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvReadItemProperties");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!pPropSpec) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    return S_OK;
}

/**************************************************************************\
* CWIADevice::drvLockWiaDevice
*
*   drvLockWiaDevice will be called by the WIA service when access to the
*   device is needed.  Application's can not call this method directly.
*   The WIA driver should see many drvLockWiaDevice() method calls followed
*   by drvUnLockWiaDevice() method calls for most of the WIA operations on
*   the device.
*
*   It is recommended for the WIA driver to all the IStiDevice::LockDevice()
*   method off of the interface passed in during the drvInitializeWia() method
*   call.  This will ensure that device locking is performed correctly by the
*   WIA service.  The WIA service will assist in keeping multiple client
*   applications from connecting to the WIA driver at the same time.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
* Return Value:
*
*   S_OK  - if the lock was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvLockWiaDevice(
                                                    BYTE *pWiasContext,
                                                    LONG lFlags,
                                                    LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvLockWiaDevice");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    return m_pStiDevice->LockDevice(m_dwLockTimeout);
}

/**************************************************************************\
* CWIADevice::drvUnLockWiaDevice
*
*   drvUnLockWiaDevice will be called by the WIA service when access to the
*   device needs to be released.  Application's can not call this method directly.
*
*   It is recommended for the WIA driver to all the IStiDevice::UnLockDevice()
*   method off of the interface passed in during the drvInitializeWia() method
*   call.  This will ensure that device unlocking is performed correctly by the
*   WIA service.  The WIA service will assist in keeping multiple client
*   applications from connecting to the WIA driver at the same time.
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA item, unused.
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the unlock was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvUnLockWiaDevice(
                                                      BYTE *pWiasContext,
                                                      LONG lFlags,
                                                      LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvUnLockWiaDevice");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWIADevice::drvAnalyzeItem
*
*   drvAnalyzeItem is called by the WIA service in response to the application
*   call IWiaItem::AnalyzeItem() method call.
*
*   The WIA driver should analyze the passed in WIA item (found by using
*   the pWiasContext) and create/generate sub items.
*
*   This feature of WIA is not currently used by any applications and is
*   still being reviewed for more details.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvAnalyzeItem(
                                                  BYTE *pWiasContext,
                                                  LONG lFlags,
                                                  LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvAnalyzeItem");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    return E_NOTIMPL;
}

/**************************************************************************\
* drvGetDeviceErrorStr
*
*   drvGetDeviceErrorStr is called by the WIA service to get more information
*   about device specific error codes returned by each WIA driver method call.
*   The WIA driver should map the incoming code to a user-readable string
*   explaining the details of the error.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvGetDeviceErrorStr(
                                                        LONG     lFlags,
                                                        LONG     lDevErrVal,
                                                        LPOLESTR *ppszDevErrStr,
                                                        LONG     *plDevErr)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvGetDeviceErrorStr");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!ppszDevErrStr) {
        return E_INVALIDARG;
    }

    if (!plDevErr) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    //  Map device errors to a strings
    //

    switch (lDevErrVal) {
    case 0:
        *ppszDevErrStr = NULL;
        *plDevErr  = 0;
        break;
    default:
        *ppszDevErrStr = NULL;
        *plDevErr  = 0;
        break;
    }
    return hr;
}

/**************************************************************************\
* drvDeviceCommand
*
*   drvDeviceCommand is called by the WIA service is response to the
*   application's call to IWiaItem::DeviceCommand method.
*   The WIA driver should process the received device command targeted to
*   the incoming WIA item. (determine the WIA item to receive the device
*   command by using the pWiasContext pointer).
*
*   Any command sent to the WIA driver that is not supported, should be
*   failed with an E_INVALIDARG error code.
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA item.
*   lFlags       - Operation flags, unused.
*   plCommand    - Pointer to command GUID.
*   ppWiaDrvItem - Optional pointer to returned item, unused.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the command was successfully processed
*   E_xxx - Error code, if the operation failed.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvDeviceCommand(
                                                    BYTE        *pWiasContext,
                                                    LONG        lFlags,
                                                    const GUID  *plCommand,
                                                    IWiaDrvItem **ppWiaDrvItem,
                                                    LONG        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvDeviceCommand");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!plCommand) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    HRESULT hr = S_OK;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {
        hr = S_OK;
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, unknown command sent to this device"));
        hr = E_NOTIMPL;
    }

    return hr;
}


/**************************************************************************\
* CWIADevice::drvGetCapabilities
*
*   drvGetCapabilities is called by the WIA service to obtain the WIA device
*   supported EVENTS and COMMANDS.
*
*   The WIA driver should first look at the incoming ulFlags parameter to
*   determine what request it should be answering:
*   The following requests are used:
*
*       WIA_DEVICE_COMMANDS - requesting device commands only
*       WIA_DEVICE_EVENTS   - requesting device events only
*       WIA_DEVICE_COMMANDS|WIA_DEVICE_EVENTS - requesting commands and events.
*
*    The WIA driver should allocate memory (to be stored in this WIA driver
*    and freed by this WIA driver) to contain an array of WIA_DEV_CAP_DRV
*    structures. A pointer to this WIA driver allocated memory should be
*    assigned to ppCapabilities.
*
*    IMPORTANT NOTE!!! - The WIA service will not free this memory.  It is up
*                        up to the WIA driver to manage the allocated memory.
*
*    The WIA driver should place the number of structures allocated in the
*    out parameter called pcelt.
*
*    The WIA device should fill out each of the WIA_DEV_CAP_DRV structure fields
*    with the following information.
*
*        guid           = Event or Command GUID
*        ulFlags        = Event or Command FLAGS
*        wszName        = Event or Command NAME
*        wszDescription = Event or Command DESCRIPTION
*        wszIcon        = Event or Command ICON
*
*
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned array.
*   ppCapabilities - Pointer to driver allocate and managed array.
*   plDevErrVal    - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvGetCapabilities(
                                                      BYTE            *pWiasContext,
                                                      LONG            ulFlags,
                                                      LONG            *pcelt,
                                                      WIA_DEV_CAP_DRV **ppCapabilities,
                                                      LONG            *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvGetCapabilites");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {

        //
        // The WIA service may pass in a NULL for the pWiasContext. This is expected
        // because there is a case where no item was created at the time the event was fired.
        //
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!pcelt) {
        return E_INVALIDARG;
    }

    if (!ppCapabilities) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    HRESULT hr = S_OK;

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Return depends on flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    //

    switch (ulFlags) {
    case WIA_DEVICE_COMMANDS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS)"));

        //
        //  report commands only
        //

        *pcelt          = m_NumSupportedCommands;
        *ppCapabilities = &m_pCapabilities[m_NumSupportedEvents];
        break;
    case WIA_DEVICE_EVENTS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_EVENTS)"));

        //
        //  report events only
        //

        *pcelt          = m_NumSupportedEvents;
        *ppCapabilities = m_pCapabilities;
        break;
    case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS|WIA_DEVICE_EVENTS)"));

        //
        //  report both events and commands
        //

        *pcelt          = (m_NumSupportedCommands + m_NumSupportedEvents);
        *ppCapabilities = m_pCapabilities;
        break;
    default:

        //
        //  invalid request
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, invalid flags"));
        return E_INVALIDARG;
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::drvDeleteItem
*
*   drvDeleteItem is called by the WIA service when a WIA application calls
*   IWiaItem::DeleteItem() method to delete a WIA item.
*
*   The WIA service will verify the following before calling this method.
*       1. The item is NOT a root item.
*       2. The item is a folder, and has NO children
*       3. The item's access rights allow deletion.
*
*   Since the the WIA service verifies these conditions, it is NOT necessary
*   for the WIA driver to also verify them.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
* Return Value:
*
*   S_OK - if the delete operation was successful
*   E_xxx - Error code, if the delete operation failed
*
* History:
*
*     03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvDeleteItem(
                                                 BYTE *pWiasContext,
                                                 LONG lFlags,
                                                 LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvDeleteItem");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    //
    // if this functionality is not supported on this item, then return
    // STG_E_ACCESSDENIED as the error code.
    //

    return STG_E_ACCESSDENIED;
}

/**************************************************************************\
* CWIADevice::drvFreeDrvItemContext
*
*   drvFreeDrvItemContext is called by the WIA service to free any WIA driver
*   allocated device specific context information.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvFreeDrvItemContext(
                                                         LONG lFlags,
                                                         BYTE *pSpecContext,
                                                         LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvFreeDrvItemContext");

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    PMINIDRIVERITEMCONTEXT pContext = NULL;
    pContext = (PMINIDRIVERITEMCONTEXT) pSpecContext;

    if (pContext) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvFreeDrvItemContext, Freeing my allocated context members"));
    }

    return S_OK;
}

/**************************************************************************\
* drvGetWiaFormatInfo
*
*   drvGetWiaFormatInfo is called by the WIA service to obtain the WIA device
*   supported TYMED and FORMAT pairs.
*
*    The WIA driver should allocate memory (to be stored in this WIA driver
*    and freed by this WIA driver) to contain an array of WIA_FORMAT_INFO
*    structures. A pointer to this WIA driver allocated memory should be
*    assigned to ppwfi.
*
*    IMPORTANT NOTE!!! - The WIA service will not free this memory.  It is up
*                        up to the WIA driver to manage the allocated memory.
*
*    The WIA driver should place the number of structures allocated in the
*    out parameter called pcelt.
*
*    The WIA device should fill out each of the WIA_FORMAT_INFO structure fields
*    with the following information.
*
*        guidFormatID  = Image Format GUID
*        lTymed        = TYMED associated with the Image Format GUID
*           Valid TYMEDs are: (Also known as "Media Type")
*               TYMED_FILE
*               TYMED_MULTIPAGE_FILE
*               TYMED_CALLBACK
*               TYMED_MULTIPAGE_CALLBACK
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*   03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvGetWiaFormatInfo(
                                                       BYTE            *pWiasContext,
                                                       LONG            lFlags,
                                                       LONG            *pcelt,
                                                       WIA_FORMAT_INFO **ppwfi,
                                                       LONG            *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvGetWiaFormatInfo");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!pcelt) {
        return E_INVALIDARG;
    }

    if (!ppwfi) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (NULL == m_pSupportedFormats) {
        hr = BuildSupportedFormats();
    }

    *plDevErrVal = 0;
    *pcelt       = m_NumSupportedFormats;
    *ppwfi       = m_pSupportedFormats;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_NumSupportedFormats = %d",m_NumSupportedFormats));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_pSupportedFormats   = %x",m_pSupportedFormats));
    return hr;
}

/**************************************************************************\
* drvNotifyPnpEvent
*
*   drvNotifyPnpEvent is called by the WIA service when system events occur.
*   The WIA driver should check the pEventGUID parameter to determine what
*   event is being processed.
*   Some common events that need to be processed are:
*
*       WIA_EVENT_POWER_SUSPEND - system is going to suspend/sleep mode
*       WIA_EVENT_POWER_RESUME  - system is waking up from suspend/sleep mode
*           The WIA driver should restore any event interrrupt wait states
*           after returning from a suspend.  This will ensure that the events
*           will still function when the system wakes up.
*
* Arguments:
*
*   pEventGUID   - Pointer to an event GUID
*   bstrDeviceID - Device ID
*   ulReserved   - reserved
*
* Return Value:
*
*   S_OK  - if the operation completed successfully
*   E_xxx - Error code if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvNotifyPnpEvent(
                                                     const GUID *pEventGUID,
                                                     BSTR       bstrDeviceID,
                                                     ULONG      ulReserved)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DrvNotifyPnpEvent");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if ((!pEventGUID)||(!bstrDeviceID)) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if(*pEventGUID == WIA_EVENT_POWER_SUSPEND) {

        //
        // disable any driver activity to make sure we properly
        // shutdown (the driver is not being unloaded, just disabled)
        //

    } else if(*pEventGUID == WIA_EVENT_POWER_RESUME) {

        //
        // re-establish any event notifications to make sure we properly setup
        // any event waiting status using the WIA service supplied event
        // handle
        //

        if(m_EventOverlapped.hEvent) {

            //
            // call ourselves with the cached EVENT handle given to
            // the WIA driver by the WIA service.
            //

            SetNotificationHandle(m_EventOverlapped.hEvent);
        }
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::drvUnInitializeWia
*
*   drvUnInitializeWia is called by the WIA service when an application
*   releases its last reference to any WIA items created.
*
*   NOTE: This call does not mean all clients are disconnected.  There
*         should be one call per client disconnect.
*
*   drvUnInitializeWia should be paired with a corresponding drvInitializeWia
*   call.
*
*   The WIA driver should NOT free any driver resources in this method
*   call unless it can safely determine that NO applications are
*   currently connected.
*
*   To determine the current application connection count, the WIA driver
*   can keep a reference counter in the method calls to drvInitializeWia()
*   (incrementing the counter) and drvUnInitializeWia() (decrementing the counter).
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA Root item context of the client's
*                  item tree.
*
* Return Value:
*   S_OK  - if the operation completed successfully
*   E_xxx - Error code, if the operation failed
*
* History:
*
*   03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvUnInitializeWia(
                                                      BYTE *pWiasContext)
{
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    InterlockedDecrement(&m_lClientsConnected);

    //
    // make sure we never decrement below zero (0)
    //

    if(m_lClientsConnected < 0){
        m_lClientsConnected = 0;
    }

    //
    // check for connected applications.
    //

    if(m_lClientsConnected == 0){

        //
        // There are no application clients connected to this WIA driver
        //

    }

    return S_OK;
}

/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* AlignInPlace
*
*   DWORD align a data buffer in place.
*
* Arguments:
*
*   pBuffer              - Pointer to the data buffer.
*   cbWritten            - Size of the data in bytes.
*   lBytesPerScanLine    - Number of bytes per scan line in the output data.
*   lBytesPerScanLineRaw - Number of bytes per scan line in the input data.
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

UINT CWIADevice::AlignInPlace(
                                    PBYTE pBuffer,
                                    LONG  cbWritten,
                                    LONG  lBytesPerScanLine,
                                    LONG  lBytesPerScanLineRaw)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::AlignInPlace");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pBuffer) {
        return 0;
    }

    if ((lBytesPerScanLine <= 0)||(lBytesPerScanLineRaw <= 0)) {
        return 0;
    }

    if (lBytesPerScanLineRaw % 4) {

        UINT  uiPadBytes          = lBytesPerScanLine - lBytesPerScanLineRaw;
        UINT  uiDevLinesWritten   = cbWritten / lBytesPerScanLineRaw;

        PBYTE pSrc = pBuffer + cbWritten - 1;
        PBYTE pDst = pBuffer + (uiDevLinesWritten * lBytesPerScanLine) - 1;

        while (pSrc >= pBuffer) {
            pDst -= uiPadBytes;

            for (LONG i = 0; i < lBytesPerScanLineRaw; i++) {
                *pDst-- = *pSrc--;
            }
        }
        return uiDevLinesWritten * lBytesPerScanLine;
    }
    return cbWritten;
}

/**************************************************************************\
* UnlinkItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::DeleteItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::DeleteItemTree");
    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, no tree to delete..."));
        return S_OK;
    }

    //
    //  Call device manager to unlink the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    if (SUCCEEDED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, m_pIDrvItemRoot is being released!!"));
        m_pIDrvItemRoot->Release();
        m_pIDrvItemRoot = NULL;
    }

    return hr;
}

/**************************************************************************\
* DeleteRootItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::DeleteRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteRootItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedPreviewModesArrayContents();

    if (NULL != m_RootItemInitInfo.pszPropNames) {
        delete [] m_RootItemInitInfo.pszPropNames;
        m_RootItemInitInfo.pszPropNames = NULL;
    }

    if (NULL != m_RootItemInitInfo.piPropIDs) {
        delete [] m_RootItemInitInfo.piPropIDs;
        m_RootItemInitInfo.piPropIDs = NULL;
    }

    if (NULL != m_RootItemInitInfo.pvPropVars) {
        FreePropVariantArray(m_RootItemInitInfo.lNumProps,m_RootItemInitInfo.pvPropVars);
        delete [] m_RootItemInitInfo.pvPropVars;
        m_RootItemInitInfo.pvPropVars = NULL;
    }

    if (NULL != m_RootItemInitInfo.psPropSpec) {
        delete [] m_RootItemInitInfo.psPropSpec;
        m_RootItemInitInfo.psPropSpec = NULL;
    }

    if (NULL != m_RootItemInitInfo.pwpiPropInfo) {
        delete [] m_RootItemInitInfo.pwpiPropInfo;
        m_RootItemInitInfo.pwpiPropInfo = NULL;
    }

    m_RootItemInitInfo.lNumProps = 0;

    return hr;
}

/**************************************************************************\
* BuildRootItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::BuildRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildRootItemProperties");

    HRESULT hr = S_OK;
    LONG PropIndex = 0;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_RootItemInitInfo.lNumProps = 17;   // standard properties + ADF specific

#else

    //
    // check for ADF
    //

    if (m_pScanAPI->FakeScanner_ADFAttached() == S_OK) {
        m_bADFAttached = TRUE;
    }

    //
    // set the number of properties
    //

    if (m_bADFAttached) {
        m_RootItemInitInfo.lNumProps = 19;   // standard properties + ADF specific
    } else {
        m_RootItemInitInfo.lNumProps = 10;    // standard properties only
    }

#endif

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::BuildRootItemProperties, Number of Properties = %d",m_RootItemInitInfo.lNumProps));

    m_RootItemInitInfo.pszPropNames   = new LPOLESTR[m_RootItemInitInfo.lNumProps];
    if (NULL != m_RootItemInitInfo.pszPropNames) {
        m_RootItemInitInfo.piPropIDs    = new PROPID[m_RootItemInitInfo.lNumProps];
        if (NULL != m_RootItemInitInfo.piPropIDs) {
            m_RootItemInitInfo.pvPropVars    = new PROPVARIANT[m_RootItemInitInfo.lNumProps];
            if (NULL != m_RootItemInitInfo.pvPropVars) {
                m_RootItemInitInfo.psPropSpec    = new PROPSPEC[m_RootItemInitInfo.lNumProps];
                if (NULL != m_RootItemInitInfo.psPropSpec) {
                    m_RootItemInitInfo.pwpiPropInfo   = new WIA_PROPERTY_INFO[m_RootItemInitInfo.lNumProps];
                    if (NULL == m_RootItemInitInfo.pwpiPropInfo)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, memory allocation failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

    ROOT_ITEM_INFORMATION RootItemInfo;

    hr = m_pScanAPI->FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, FakeScanner_GetRootPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

#ifndef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // WIA_DPS_HORIZONTAL_BED_SIZE and WIA_DPS_VERTICAL_BED_SIZE should not exist for scanners
    // that only have a feeder.  Theses are flatbed scanner properties only.
    //

    // Intialize WIA_DPS_HORIZONTAL_BED_SIZE
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_HORIZONTAL_BED_SIZE_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_HORIZONTAL_BED_SIZE;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.ScanBedWidth;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_VERTICAL_BED_SIZE
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_VERTICAL_BED_SIZE_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_VERTICAL_BED_SIZE;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.ScanBedHeight;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

#endif

    // Intialize WIA_IPA_ACCESS_RIGHTS
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_IPA_ACCESS_RIGHTS_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_IPA_ACCESS_RIGHTS;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = WIA_ITEM_READ|WIA_ITEM_WRITE;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_UI4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_XRES
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_OPTICAL_XRES_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_OPTICAL_XRES;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.OpticalXResolution;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_YRES
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_OPTICAL_YRES_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_OPTICAL_YRES;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.OpticalYResolution;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_DPA_FIRMWARE_VERSION
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPA_FIRMWARE_VERSION_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPA_FIRMWARE_VERSION;
    m_RootItemInitInfo.pvPropVars [PropIndex].bstrVal      = SysAllocString(RootItemInfo.FirmwareVersion);
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_BSTR;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.Nom  = m_RootItemInitInfo.pvPropVars [PropIndex].lVal;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;

    PropIndex++;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    m_RootItemInitInfo.pszPropNames[PropIndex]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]                    = WIA_DPS_MAX_SCAN_TIME;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal               = RootItemInfo.MaxScanTime;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid             = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_PREVIEW (LIST)
    m_RootItemInitInfo.pszPropNames[PropIndex]                    = WIA_DPS_PREVIEW_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]                    = WIA_DPS_PREVIEW;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_FINAL_SCAN;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid             = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_RootItemInitInfo.pvPropVars [PropIndex].vt;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList= (BYTE*)m_SupportedPreviewModes.plValues;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom  = m_RootItemInitInfo.pvPropVars [PropIndex].lVal;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedPreviewModes.lNumValues;

    PropIndex++;

    // Initialize WIA_DPS_SHOW_PREVIEW_CONTROL (NONE)
    m_RootItemInitInfo.pszPropNames[PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // Scanners that have a feeder that can not perform a preview scan should set the
    // WIA_DPS_SHOW_PREVIEW_CONTROL property to WIA_DONT_SHOW_PREVIEW_CONTROL.  This
    // will eliminate the preview control from being shown in the Microsoft common UI
    // dialogs, and the Scanner and Camera Wizard.
    //

    m_RootItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_DONT_SHOW_PREVIEW_CONTROL;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_RootItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_SHOW_PREVIEW_CONTROL;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_RootItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid             = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    //
    // if a Document feeder is attached...add the following properties
    //

    if (m_bADFAttached) {

        // Initialize WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederWidth;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_SHEET_FEED_SIZE
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // scanners that can not determine the length of the page in the feeder should
        // set this property to 0.  This will tell the application that the vertical
        // sheet feed size of the scanner is unknown
        //

        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = 0;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederHeight;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederCaps;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_STATUS
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederStatus;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_SELECT
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // scanners that only have a feeder and no flatbed, should set the WIA_DPS_DOCUMENT_HANDLING_SELECT
        // property to FEEDER as the initial setting.  This will let the application know that the device
        // is currently in FEEDER mode.  The valid values for this property should be set to FEEDER only
        // as well.  This will avoid any applications trying to set the WIA_DPS_DOCUMENT_HANDLING_SELECT
        // property to FLATBED.
        //

        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = FEEDER;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = FEEDER;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = FLATBED;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = FEEDER | FLATBED;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_FLAG;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.Nom  = m_RootItemInitInfo.pvPropVars [PropIndex].lVal;

        PropIndex++;

        // Initialize WIA_DPS_PAGES
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_PAGES_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_PAGES;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = 1;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_RANGE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = RootItemInfo.MaxPageCapacity;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = 1;

        PropIndex++;

        // Initialize WIA_DPS_SHEET_FEEDER_REGISTRATION
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederReg;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_HORIZONTAL_BED_REGISTRATION
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederHReg;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_BED_REGISTRATION
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederVReg;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

    }
    return hr;
}

/**************************************************************************\
* DeleteChildItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::DeleteChildItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteChildItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedFormatsArrayContents();
    DeleteSupportedDataTypesArrayContents();
    DeleteSupportedCompressionsArrayContents();
    DeleteSupportedTYMEDArrayContents();
    DeleteInitialFormatsArrayContents();
    DeleteSupportedResolutionsArrayContents();

    if (NULL != m_ChildItemInitInfo.pszPropNames) {
        delete [] m_ChildItemInitInfo.pszPropNames;
        m_ChildItemInitInfo.pszPropNames = NULL;
    }

    if (NULL != m_ChildItemInitInfo.piPropIDs) {
        delete [] m_ChildItemInitInfo.piPropIDs;
        m_ChildItemInitInfo.piPropIDs = NULL;
    }

    if (NULL != m_ChildItemInitInfo.pvPropVars) {
        for (LONG lPropIndex = 0; lPropIndex < m_ChildItemInitInfo.lNumProps; lPropIndex++) {

            //
            // set CLSID pointers to NULL, because we freed the memory above.
            // If this pointer is not NULL FreePropVariantArray would
            // try to free it again.
            //

            if (m_ChildItemInitInfo.pvPropVars[lPropIndex].vt == VT_CLSID) {
                m_ChildItemInitInfo.pvPropVars[lPropIndex].puuid = NULL;
            }
        }
        FreePropVariantArray(m_ChildItemInitInfo.lNumProps,m_ChildItemInitInfo.pvPropVars);
        delete [] m_ChildItemInitInfo.pvPropVars;
        m_ChildItemInitInfo.pvPropVars = NULL;
    }

    if (NULL != m_ChildItemInitInfo.psPropSpec) {
        delete [] m_ChildItemInitInfo.psPropSpec;
        m_ChildItemInitInfo.psPropSpec = NULL;
    }

    if (NULL != m_ChildItemInitInfo.pwpiPropInfo) {
        delete [] m_ChildItemInitInfo.pwpiPropInfo;
        m_ChildItemInitInfo.pwpiPropInfo = NULL;
    }

    m_ChildItemInitInfo.lNumProps = 0;

    return hr;
}

/**************************************************************************\
* BuildChlidItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::BuildChildItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildChildItemProperties");

    HRESULT hr = S_OK;

    m_ChildItemInitInfo.lNumProps = 29;
    m_ChildItemInitInfo.pszPropNames   = new LPOLESTR[m_ChildItemInitInfo.lNumProps];
    if (NULL != m_ChildItemInitInfo.pszPropNames) {
        m_ChildItemInitInfo.piPropIDs    = new PROPID[m_ChildItemInitInfo.lNumProps];
        if (NULL != m_ChildItemInitInfo.piPropIDs) {
            m_ChildItemInitInfo.pvPropVars    = new PROPVARIANT[m_ChildItemInitInfo.lNumProps];
            if (NULL != m_ChildItemInitInfo.pvPropVars) {
                m_ChildItemInitInfo.psPropSpec    = new PROPSPEC[m_ChildItemInitInfo.lNumProps];
                if (NULL != m_ChildItemInitInfo.psPropSpec) {
                    m_ChildItemInitInfo.pwpiPropInfo   = new WIA_PROPERTY_INFO[m_ChildItemInitInfo.lNumProps];
                    if (NULL == m_ChildItemInitInfo.pwpiPropInfo)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr)) {
        DeleteChildItemProperties();
        return hr;
    }

    ROOT_ITEM_INFORMATION RootItemInfo;
    hr = m_pScanAPI->FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, FakeScanner_GetRootPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteChildItemProperties();
        return hr;
    }

    TOP_ITEM_INFORMATION TopItemInfo;
    hr = m_pScanAPI->FakeScanner_GetTopPropertyInfo(&TopItemInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, FakeScanner_GetTopPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteChildItemProperties();
        return hr;
    }

    LONG PropIndex = 0;

    // Intialize WIA_IPS_XRES (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_XRES_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_XRES;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = m_SupportedResolutions.plValues[0];
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList= (BYTE*)m_SupportedResolutions.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom  = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedResolutions.lNumValues;

    PropIndex++;

    // Intialize WIA_IPS_YRES (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_YRES_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_YRES;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = m_SupportedResolutions.plValues[0];
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList= (BYTE*)m_SupportedResolutions.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom  = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedResolutions.lNumValues;

    PropIndex++;

    // Intialize WIA_IPS_XEXTENT (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_XEXTENT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_XEXTENT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = ((m_ChildItemInitInfo.pvPropVars [PropIndex-2].lVal * RootItemInfo.ScanBedWidth)/1000);
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // scanners that have a fixed width should set the valid values for WIA_IPS_XEXTENT to reflect that.
    // This will let the application know that this device has this behavior.
    //

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;

#else

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;

#endif

    PropIndex++;

    // Intialize WIA_IPS_YEXTENT (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_YEXTENT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_YEXTENT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = ((m_ChildItemInitInfo.pvPropVars [PropIndex-2].lVal * RootItemInfo.ScanBedHeight)/1000);
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // scanners that have a feeder that can not determine the length of the page, should
    // have 0 as the valid values for WIA_IPS_YEXTENT.  This will let the application
    // know that this device has this behavior.
    //

    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = 0;

#endif

    PropIndex++;

    // Intialize WIA_IPS_XPOS (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_XPOS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_XPOS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = (m_ChildItemInitInfo.pwpiPropInfo[PropIndex-2].ValidVal.Range.Max - 1);
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = 0;

#endif

    PropIndex++;

    // Intialize WIA_IPS_YPOS (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_YPOS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_YPOS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = (m_ChildItemInitInfo.pwpiPropInfo[PropIndex-2].ValidVal.Range.Max - 1);
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = 0;

#endif

    PropIndex++;

    // Intialize WIA_IPA_DATATYPE (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_DATATYPE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_DATATYPE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_DATATYPE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList    = (BYTE*)m_SupportedDataTypes.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom      = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedDataTypes.lNumValues;

    PropIndex++;

    // Intialize WIA_IPA_DEPTH (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_DEPTH_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_DEPTH;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_BITDEPTH;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_BRIGHTNESS (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_BRIGHTNESS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_BRIGHTNESS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.Brightness.lNom;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = TopItemInfo.Brightness.lInc;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = TopItemInfo.Brightness.lMin;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = TopItemInfo.Brightness.lMax;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = TopItemInfo.Brightness.lNom;

    PropIndex++;

    // Intialize WIA_IPS_CONTRAST (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_CONTRAST_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_CONTRAST;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.Contrast.lNom;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = TopItemInfo.Contrast.lInc;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = TopItemInfo.Contrast.lMin;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = TopItemInfo.Contrast.lMax;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = TopItemInfo.Contrast.lNom;

    PropIndex++;

    // Intialize WIA_IPS_CUR_INTENT (FLAG)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_CUR_INTENT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_CUR_INTENT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_INTENT_NONE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_FLAG;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.Nom  = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = WIA_INTENT_IMAGE_TYPE_COLOR | WIA_INTENT_IMAGE_TYPE_GRAYSCALE |
                                                           WIA_INTENT_IMAGE_TYPE_TEXT  | WIA_INTENT_MINIMIZE_SIZE |
                                                           WIA_INTENT_MAXIMIZE_QUALITY;

    PropIndex++;

    // Intialize WIA_IPA_PIXELS_PER_LINE (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_PIXELS_PER_LINE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_PIXELS_PER_LINE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = m_ChildItemInitInfo.pvPropVars [PropIndex-9].lVal;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_NUMER_OF_LINES (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_NUMBER_OF_LINES_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_NUMBER_OF_LINES;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = m_ChildItemInitInfo.pvPropVars [PropIndex-9].lVal;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PREFERRED_FORMAT (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_PREFERRED_FORMAT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_PREFERRED_FORMAT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].puuid              = &m_pInitialFormats[0];
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_CLSID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ITEM_SIZE (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_ITEM_SIZE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_ITEM_SIZE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_THRESHOLD (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_THRESHOLD_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_THRESHOLD;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.Threshold.lNom;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = TopItemInfo.Threshold.lInc;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = TopItemInfo.Threshold.lMin;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = TopItemInfo.Threshold.lMax;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = TopItemInfo.Threshold.lNom;

    PropIndex++;

    // Intialize WIA_IPA_FORMAT (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_FORMAT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_FORMAT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].puuid              = &m_pInitialFormats[0];
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_CLSID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.ListGuid.pList    = m_pInitialFormats;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.ListGuid.Nom      = *m_ChildItemInitInfo.pvPropVars[PropIndex].puuid;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.ListGuid.cNumList = m_NumInitialFormats;

    PropIndex++;

    // Intialize WIA_IPA_FILENAME_EXTENSION (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_FILENAME_EXTENSION_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_FILENAME_EXTENSION;
    m_ChildItemInitInfo.pvPropVars [PropIndex].bstrVal            = SysAllocString(L"BMP");
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_BSTR;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_TYMED (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_TYMED_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_TYMED;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_TYMED;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList    = (BYTE*)m_SupportedTYMED.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom      = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedTYMED.lNumValues;

    PropIndex++;

    // Intialize WIA_IPA_CHANNELS_PER_PIXEL (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_CHANNELS_PER_PIXEL;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BITS_PER_CHANNEL (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_BITS_PER_CHANNEL;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PLANAR (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_PLANAR_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_PLANAR;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_PLANAR;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BYTES_PER_LINE (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_BYTES_PER_LINE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_BYTES_PER_LINE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_MIN_BUFFER_SIZE (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.lMinimumBufferSize;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ACCESS_RIGHTS (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_ACCESS_RIGHTS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_ACCESS_RIGHTS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_ITEM_READ|WIA_ITEM_WRITE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_COMPRESSION (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_COMPRESSION_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_COMPRESSION;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_COMPRESSION;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList    = (BYTE*)m_SupportedCompressionTypes.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom      = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedCompressionTypes.lNumValues;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    m_ChildItemInitInfo.pszPropNames[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal         = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid       = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.Nom  = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;

    PropIndex++;

    // Initialize WIA_IPS_PHOTOMETRIC_INTERP
    m_ChildItemInitInfo.pszPropNames[PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal         = INITIAL_PHOTOMETRIC_INTERP;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid       = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_WARM_UP_TIME_STR (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_WARM_UP_TIME_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_WARM_UP_TIME;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.lMaxLampWarmupTime;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    return hr;
}

/**************************************************************************\
* BuildSupportedResolutions
*
*   This helper initializes the supported resolution array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedResolutions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedResolutions");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedResolutions.plValues) {

        //
        // Supported resolutions have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_SupportedResolutions.lNumValues = 6;
    m_SupportedResolutions.plValues     = new LONG[m_SupportedResolutions.lNumValues];
    if (m_SupportedResolutions.plValues) {
        m_SupportedResolutions.plValues[0] = 75;
        m_SupportedResolutions.plValues[1] = 100;
        m_SupportedResolutions.plValues[2] = 150;
        m_SupportedResolutions.plValues[3] = 200;
        m_SupportedResolutions.plValues[4] = 300;
        m_SupportedResolutions.plValues[5] = 600;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedResolutionsArrayContents
*
*   This helper deletes the supported resolutions array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedResolutionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedResolutionsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedResolutions.plValues)
        delete [] m_SupportedResolutions.plValues;

    m_SupportedResolutions.plValues     = NULL;
    m_SupportedResolutions.lNumValues   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedIntents
*
*   This helper initializes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedIntents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedIntents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedIntents.plValues) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_SupportedIntents.lNumValues   = 6;
    m_SupportedIntents.plValues     = new LONG[m_SupportedIntents.lNumValues];
    if (m_SupportedIntents.plValues) {
        m_SupportedIntents.plValues[0] = WIA_INTENT_NONE;
        m_SupportedIntents.plValues[1] = WIA_INTENT_IMAGE_TYPE_COLOR;
        m_SupportedIntents.plValues[2] = WIA_INTENT_IMAGE_TYPE_GRAYSCALE;
        m_SupportedIntents.plValues[3] = WIA_INTENT_IMAGE_TYPE_TEXT;
        m_SupportedIntents.plValues[4] = WIA_INTENT_MINIMIZE_SIZE;
        m_SupportedIntents.plValues[5] = WIA_INTENT_MAXIMIZE_QUALITY;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedIntentsArrayContents
*
*   This helper deletes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedIntentsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedIntentsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedIntents.plValues)
        delete [] m_SupportedIntents.plValues;

    m_SupportedIntents.plValues     = NULL;
    m_SupportedIntents.lNumValues   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedCompressions
*
*   This helper initializes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedCompressions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedCompressions");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedCompressionTypes.plValues) {

        //
        // Supported compression types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_SupportedCompressionTypes.lNumValues  = 1;
    m_SupportedCompressionTypes.plValues    = new LONG[m_SupportedCompressionTypes.lNumValues];
    if (m_SupportedCompressionTypes.plValues) {
        m_SupportedCompressionTypes.plValues[0] = WIA_COMPRESSION_NONE;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedCompressionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedCompressionsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedCompressionTypes.plValues)
        delete [] m_SupportedCompressionTypes.plValues;

    m_SupportedCompressionTypes.plValues     = NULL;
    m_SupportedCompressionTypes.lNumValues   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedPreviewModes
*
*   This helper initializes the supported preview mode array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedPreviewModes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedPreviewModes");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedPreviewModes.plValues) {

        //
        // Supported preview modes have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // if your scanner can not perform a preview scan, then
    // set the valid values for WIA_DPS_PREVIEW property to
    // WIA_FINAL_SCAN only
    //

    m_SupportedPreviewModes.lNumValues  = 1;
    m_SupportedPreviewModes.plValues    = new LONG[m_SupportedPreviewModes.lNumValues];
    if (m_SupportedPreviewModes.plValues) {
        m_SupportedPreviewModes.plValues[0] = WIA_FINAL_SCAN;
    } else
        hr = E_OUTOFMEMORY;
#else

    m_SupportedPreviewModes.lNumValues  = 2;
    m_SupportedPreviewModes.plValues    = new LONG[m_SupportedPreviewModes.lNumValues];
    if (m_SupportedPreviewModes.plValues) {
        m_SupportedPreviewModes.plValues[0] = WIA_FINAL_SCAN;
        m_SupportedPreviewModes.plValues[1] = WIA_PREVIEW_SCAN;
    } else
        hr = E_OUTOFMEMORY;
#endif

    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedPreviewModesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedPreviewModesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedPreviewModes.plValues)
        delete [] m_SupportedPreviewModes.plValues;

    m_SupportedPreviewModes.plValues     = NULL;
    m_SupportedPreviewModes.lNumValues   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedDataTypes
*
*   This helper initializes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedDataTypes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedDataTypes");

    HRESULT hr = S_OK;

    if (NULL != m_SupportedDataTypes.plValues) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_SupportedDataTypes.lNumValues  = 3;
    m_SupportedDataTypes.plValues = new LONG[m_SupportedDataTypes.lNumValues];
    if (m_SupportedDataTypes.plValues) {
        m_SupportedDataTypes.plValues[0] = WIA_DATA_THRESHOLD;
        m_SupportedDataTypes.plValues[1] = WIA_DATA_GRAYSCALE;
        m_SupportedDataTypes.plValues[2] = WIA_DATA_COLOR;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedDataTypesArrayContents
*
*   This helper deletes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedDataTypesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedDataTypesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedDataTypes.plValues)
        delete [] m_SupportedDataTypes.plValues;

    m_SupportedDataTypes.plValues     = NULL;
    m_SupportedDataTypes.lNumValues   = 0;
    return hr;
}

/**************************************************************************\
* BuildInitialFormats
*
*   This helper initializes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildInitialFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildInitialFormats");

    HRESULT hr = S_OK;

    if (NULL != m_pInitialFormats) {

        //
        // Supported initial formats have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumInitialFormats = 1;
    m_pInitialFormats     = new GUID[m_NumInitialFormats];
    if (m_pInitialFormats) {
        m_pInitialFormats[0] = WiaImgFmt_MEMORYBMP;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}
/**************************************************************************\
* DeleteInitialFormatsArrayContents
*
*   This helper deletes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteInitialFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteInitialFormatsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pInitialFormats)
        delete [] m_pInitialFormats;

    m_pInitialFormats     = NULL;
    m_NumInitialFormats   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedFormats
*
*   This helper initializes the supported format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedFormats");

    HRESULT hr = S_OK;

    if (NULL != m_pSupportedFormats) {

        //
        // Supported formats have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedFormatsArrayContents();
    if (SUCCEEDED(hr)) {

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // the unknown length feeder only scanner, formally called the scrollfed scanner
        // only supports BMP and MEMORYBMP
        //

        m_NumSupportedFormats = 2;
        m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
        if (m_pSupportedFormats) {
            m_pSupportedFormats[0].guidFormatID = WiaImgFmt_MEMORYBMP;
            m_pSupportedFormats[0].lTymed       = TYMED_CALLBACK;
            m_pSupportedFormats[1].guidFormatID = WiaImgFmt_BMP;
            m_pSupportedFormats[1].lTymed       = TYMED_FILE;
        } else
            hr = E_OUTOFMEMORY;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_NumSupportedFormats = 4;
        m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
        if (m_pSupportedFormats) {
            m_pSupportedFormats[0].guidFormatID = WiaImgFmt_MEMORYBMP;
            m_pSupportedFormats[0].lTymed       = TYMED_CALLBACK;
            m_pSupportedFormats[1].guidFormatID = WiaImgFmt_BMP;
            m_pSupportedFormats[1].lTymed       = TYMED_FILE;
            m_pSupportedFormats[2].guidFormatID = WiaImgFmt_TIFF;
            m_pSupportedFormats[2].lTymed       = TYMED_FILE;
            m_pSupportedFormats[3].guidFormatID = WiaImgFmt_TIFF;
            m_pSupportedFormats[3].lTymed       = TYMED_MULTIPAGE_CALLBACK;
        } else
            hr = E_OUTOFMEMORY;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedFormatsArrayContents
*
*   This helper deletes the supported formats array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedFormatsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedFormats)
        delete [] m_pSupportedFormats;

    m_pSupportedFormats     = NULL;
    m_NumSupportedFormats   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedTYMED
*
*   This helper initializes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedTYMED()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedTYMED");

    HRESULT hr = S_OK;

    if (NULL != m_SupportedTYMED.plValues) {

        //
        // Supported TYMED have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedTYMEDArrayContents();
    if (SUCCEEDED(hr)) {

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // if your scanner does not support multi-page
        // file formats, then only report TYMED_FILE, and
        // TYMED_CALLBACK for the WIA_IPA_TYMED property.
        // The unknown length feeder only scanner, formally called
        // the scrollfed scanner in this example does not support
        // multipage file formats
        //

        m_SupportedTYMED.lNumValues = 2;
        m_SupportedTYMED.plValues   = new LONG[m_SupportedTYMED.lNumValues];
        if (m_SupportedTYMED.plValues) {
            m_SupportedTYMED.plValues[0] = TYMED_FILE;
            m_SupportedTYMED.plValues[1] = TYMED_CALLBACK;
        } else
            hr = E_OUTOFMEMORY;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_SupportedTYMED.lNumValues = 3;
        m_SupportedTYMED.plValues   = new LONG[m_SupportedTYMED.lNumValues];
        if (m_SupportedTYMED.plValues) {
            m_SupportedTYMED.plValues[0] = TYMED_FILE;
            m_SupportedTYMED.plValues[1] = TYMED_CALLBACK;
            m_SupportedTYMED.plValues[2] = TYMED_MULTIPAGE_CALLBACK;
        } else
            hr = E_OUTOFMEMORY;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedTYMEDArrayContents
*
*   This helper deletes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedTYMEDArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedTYMEDArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedTYMED.plValues)
        delete [] m_SupportedTYMED.plValues;

    m_SupportedTYMED.plValues  = NULL;
    m_SupportedTYMED.lNumValues = 0;
    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::BuildCapabilities()
{
    HRESULT hr = S_OK;
    if (NULL != m_pCapabilities) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCommands  = 1;
    m_NumSupportedEvents    = 5;
    LONG lArrayIndex        = 0;    // increment this value when adding new items to
                                    // the capabilites array

    m_pCapabilities     = new WIA_DEV_CAP_DRV[m_NumSupportedCommands + m_NumSupportedEvents];
    if (m_pCapabilities) {

        //
        // Initialize EVENTS
        //

        // WIA_EVENT_DEVICE_CONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

        lArrayIndex++;

        // WIA_EVENT_DEVICE_DISCONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

        lArrayIndex++;

        // FAX BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_FAXBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_FAXBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_FAX_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        // COPY BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_COPYBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_COPYBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_PRINT_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        // SCAN BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_SCANBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_SCANBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        //
        // Initialize COMMANDS
        //

        // WIA_CMD_SYNCHRONIZE
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
        m_pCapabilities[lArrayIndex].ulFlags        = 0;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SYNCHRONIZE;

        lArrayIndex++;

    } else
        hr = E_OUTOFMEMORY;
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::DeleteCapabilitiesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteCapabilitiesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pCapabilities) {
        for (LONG i = 0; i < (m_NumSupportedCommands + m_NumSupportedEvents);i++) {

            if(m_pCapabilities[i].wszName){
                CoTaskMemFree(m_pCapabilities[i].wszName);
            }

            if(m_pCapabilities[i].wszDescription) {
                CoTaskMemFree(m_pCapabilities[i].wszDescription);
            }
        }
        delete [] m_pCapabilities;
        m_pCapabilities = NULL;
    }
    return hr;
}

/**************************************************************************\
* GetBSTRResourceString
*
*   This helper gets a BSTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   pBSTR       - pointer to a BSTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::GetBSTRResourceString(LONG lResourceID,BSTR *pBSTR,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::GetBSTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if (bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
        *pBSTR = SysAllocString(szStringValue);
#else
        WCHAR wszStringValue[255];

        //
        // convert szStringValue from char* to unsigned short* (ANSI only)
        //

        MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            szStringValue,
                            lstrlenA(szStringValue)+1,
                            wszStringValue,
                            (sizeof(wszStringValue)/sizeof(wszStringValue[0])));

        *pBSTR = SysAllocString(wszStringValue);
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::GetOLESTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if (bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
        *ppsz = NULL;
        *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
        if (*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
        } else {
            return E_OUTOFMEMORY;
        }

#else
        WCHAR wszStringValue[255];

        //
        // convert szStringValue from char* to unsigned short* (ANSI only)
        //

        MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            szStringValue,
                            lstrlenA(szStringValue)+1,
                            wszStringValue,
                            (sizeof(wszStringValue)/sizeof(wszStringValue[0])));

        *ppsz = NULL;
        *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
        if (*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
        } else {
            return E_OUTOFMEMORY;
        }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* SwapBuffer24
*
*   Place RGB bytes in correct order for DIB format.
*
* Arguments:
*
*   pBuffer     - Pointer to the data buffer.
*   lByteCount  - Size of the data in bytes.
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

VOID CWIADevice::SwapBuffer24(PBYTE pBuffer, LONG lByteCount)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::SwapBuffer24");

    if (!pBuffer) {
        return;
    }

    for (LONG i = 0; i < lByteCount; i+= 3) {
        BYTE bTemp     = pBuffer[i];
        pBuffer[i]     = pBuffer[i + 2];
        pBuffer[i + 2] = bTemp;
    }
}

/**************************************************************************\
* IsPreviewScan
*
*   Get the current preview setting from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    TRUE - Preview is set, FALSE - Final is set
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

BOOL CWIADevice::IsPreviewScan(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::IsPreviewScan");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return FALSE;
    }

    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, No Preview Property Found on ROOT item!"));
        return FALSE;
    }

    //
    //  Get the current preview setting.
    //

    LONG lPreview = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PREVIEW, &lPreview, NULL, true);
    if (hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, Failed to read Preview Property."));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return FALSE;
    }

    return(lPreview > 0);
}

/**************************************************************************\
* GetPageCount
*
*   Get the requested number of pages to scan from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    Number of pages to scan.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

LONG CWIADevice::GetPageCount(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetPageCount");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return 1;
    }

    //
    //  Get the requested page count.
    //

    LONG lPagesRequested = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PAGES, &lPagesRequested, NULL, true);
    if (hr != S_OK) {
        return 1;
    }

    return lPagesRequested;
}

/**************************************************************************\
* SetItemSize
*
*   Calulate the new item size, and write the new Item Size property value.
*
* Arguments:
*
*   pWiasContext       - item
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::SetItemSize(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::SetItemSize");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    HRESULT  hr = S_OK;

    hr = wiasWritePropLong(pWiasContext,WIA_IPA_ITEM_SIZE,0);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, wiasWritePropLong Failed to read WIA_IPA_ITEM_SIZE"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\scanapi.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       scanapi.cpp
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*   Fake Scanner device library.  This is a fake scanner library, intended
*   to simulate a scanner device.  This should only be used for testing
*   purposes.
*
***************************************************************************/

#include "pch.h"
#include "scanapi.h"
#include <time.h>

CFakeScanAPI::CFakeScanAPI()
{
    m_lLastEvent            = ID_FAKE_NOEVENT;
    m_hrLastADFError        = S_OK;
    m_bGreen                = TRUE;
    m_dwBytesWrittenSoFAR   = 0;
    m_TotalDataInDevice     = 0;
    m_PagesInADF            = MAX_PAGE_CAPACITY;

    memset(&m_RawDataInfo, 0,sizeof(RAW_DATA_INFORMATION));
    memset(&m_SrcDataInfo, 0,sizeof(RAW_DATA_INFORMATION));
}

CFakeScanAPI::~CFakeScanAPI()
{

}

HRESULT CFakeScanAPI::FakeScanner_Initialize()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo)
{
    HRESULT hr = S_OK;

    //
    // Fill in Root item property defaults
    //

    if (m_lMode == UNKNOWN_FEEDER_ONLY_SCANNER_MODE) {
        pRootItemInfo->DocumentFeederCaps   = FEEDER;
        pRootItemInfo->DocumentFeederStatus = FEED_READY;
        pRootItemInfo->DocumentFeederHReg   = CENTERED;
        pRootItemInfo->DocumentFeederReg    = CENTERED;
    } else {
        pRootItemInfo->DocumentFeederCaps   = FEEDER|FLATBED;
        pRootItemInfo->DocumentFeederStatus = FLAT_READY;
        pRootItemInfo->DocumentFeederHReg   = LEFT_JUSTIFIED;
        pRootItemInfo->DocumentFeederReg    = LEFT_JUSTIFIED;
    }

    pRootItemInfo->DocumentFeederWidth  = 8500;
    pRootItemInfo->DocumentFeederHeight = 11000;
    pRootItemInfo->DocumentFeederHReg   = LEFT_JUSTIFIED;
    pRootItemInfo->DocumentFeederReg    = LEFT_JUSTIFIED;
    pRootItemInfo->DocumentFeederVReg   = TOP_JUSTIFIED;
    pRootItemInfo->MaxPageCapacity      = MAX_PAGE_CAPACITY;
    pRootItemInfo->MaxScanTime          = MAX_SCANNING_TIME;
    pRootItemInfo->OpticalXResolution   = 300;
    pRootItemInfo->OpticalYResolution   = 300;
    pRootItemInfo->ScanBedWidth         = 8500;
    pRootItemInfo->ScanBedHeight        = 11000;

    //
    // copy firmware version in string form to WCHAR array
    //

    lstrcpyW(pRootItemInfo->FirmwareVersion,L"1.0a");

    return hr;
}
HRESULT CFakeScanAPI::FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo)
{
    HRESULT hr = S_OK;
    pTopItemInfo->bUseResolutionList    = TRUE; // use default resolution list

    pTopItemInfo->Brightness.lInc       = 1;
    pTopItemInfo->Brightness.lMax       = 1000;
    pTopItemInfo->Brightness.lMin       = -1000;
    pTopItemInfo->Brightness.lNom       = 0;

    pTopItemInfo->Contrast.lInc         = 1;
    pTopItemInfo->Contrast.lMax         = 1000;
    pTopItemInfo->Contrast.lMin         = -1000;
    pTopItemInfo->Contrast.lNom         = 0;

    pTopItemInfo->Threshold.lInc        = 1;
    pTopItemInfo->Threshold.lMax        = 1000;
    pTopItemInfo->Threshold.lMin        = -1000;
    pTopItemInfo->Threshold.lNom        = 0;

    pTopItemInfo->lMaxLampWarmupTime    = MAX_LAMP_WARMUP_TIME;
    pTopItemInfo->lMinimumBufferSize    = 262140;

    pTopItemInfo->XResolution.lInc      = 1;
    pTopItemInfo->XResolution.lMax      = 600;
    pTopItemInfo->XResolution.lMin      = 75;
    pTopItemInfo->XResolution.lNom      = 150;

    pTopItemInfo->YResolution.lInc      = 1;
    pTopItemInfo->YResolution.lMax      = 600;
    pTopItemInfo->YResolution.lMin      = 75;
    pTopItemInfo->YResolution.lNom      = 150;

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten)
{
    HRESULT hr = S_OK;

    switch (lState) {
    case SCAN_START:
        m_dwBytesWrittenSoFAR = 0;
        m_TotalDataInDevice   = CalcRandomDeviceDataTotalBytes();
        break;
    case SCAN_CONTINUE:
        break;
    case SCAN_END:
        m_bGreen = TRUE; // set back to green
        return S_OK;
    default:
        break;
    }

    if (NULL != pData) {
        switch (m_RawDataInfo.bpp) {
        case 24:
            {
                //
                // write green data for color
                //

                BYTE *pTempData = pData;
                for (DWORD dwBytes = 0; dwBytes < dwBytesToRead; dwBytes+=3) {
                    if (m_bGreen) {
                        pTempData[0] = 0;
                        pTempData[1] = 128;  // green
                        pTempData[2] = 0;
                    } else {
                        pTempData[0] = 0;
                        pTempData[1] = 0;
                        pTempData[2] = 128;  // blue
                    }
                    pTempData += 3;
                }
            }
            break;
        case 1:
        case 8:
        default:

            //
            // write simple gray for grayscale,
            // write vertical B/W stripes for threshold
            //

            if (m_bGreen) {
                memset(pData,128,dwBytesToRead);
            } else {
                memset(pData,200,dwBytesToRead);
            }
            break;
        }
    }

    //
    // fill out bytes written
    //

    if (NULL != pdwBytesWritten) {
        *pdwBytesWritten = dwBytesToRead;
    }

    if (m_bGreen) {
        m_bGreen = FALSE;
    } else {
        m_bGreen = TRUE;
    }

    if (m_lMode == UNKNOWN_FEEDER_ONLY_SCANNER_MODE) {

        //
        // keep track of bytes written so far
        //

        if (m_TotalDataInDevice == 0) {

            //
            // no data left in device
            //

            *pdwBytesWritten = 0;
            return hr;
        }

        if ((LONG)dwBytesToRead > m_TotalDataInDevice) {

            //
            // only give what is left in device
            //

            *pdwBytesWritten = dwBytesToRead;
            m_TotalDataInDevice = 0;
        } else {

            //
            // give full amount requested
            //

            m_TotalDataInDevice -= dwBytesToRead;
            if (m_TotalDataInDevice < 0) {
                m_TotalDataInDevice = 0;
            }
        }

    }

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetDataType(LONG lDataType)
{
    HRESULT hr = S_OK;
    switch (lDataType) {
    case WIA_DATA_COLOR:
        m_RawDataInfo.bpp = 24;
        break;
    case WIA_DATA_THRESHOLD:
        m_RawDataInfo.bpp = 1;
        break;
    case WIA_DATA_GRAYSCALE:
        m_RawDataInfo.bpp = 8;
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }
    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution)
{
    HRESULT hr = S_OK;
    m_RawDataInfo.lXRes = lXResolution;
    m_RawDataInfo.lYRes = lYResolution;
    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt)
{
    HRESULT hr = S_OK;

    //
    // record RAW data width and height
    //

    m_RawDataInfo.lWidthPixels  = lXExt;
    m_RawDataInfo.lHeightPixels = lYExt;
    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetContrast(LONG lContrast)
{
    HRESULT hr = S_OK;

    //
    // do nothing.. we are not concerned with Contrast
    //

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetIntensity(LONG lIntensity)
{
    HRESULT hr = S_OK;

    //
    // do nothing.. we are not concerned with Intensity
    //

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_DisableDevice()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_EnableDevice()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_DeviceOnline()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_Diagnostic()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight)
{
    HRESULT hr = E_FAIL;

    //
    // get our Root item settings, so we can use the width and height values
    //

    ROOT_ITEM_INFORMATION RootItemInfo;
    hr = FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if (SUCCEEDED(hr)) {
        *pWidth  = RootItemInfo.ScanBedWidth;
        *pHeight = RootItemInfo.ScanBedHeight;
    }
    return hr;
}

//
// standard device operations
//

HRESULT CFakeScanAPI::FakeScanner_ResetDevice()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_SetEmulationMode(LONG lDeviceMode)
{
    HRESULT hr = S_OK;

    switch (lDeviceMode) {
    case UNKNOWN_FEEDER_ONLY_SCANNER_MODE:
        m_lMode = UNKNOWN_FEEDER_ONLY_SCANNER_MODE;
        break;
    case FLATBED_SCANNER_MODE:
        m_lMode = FLATBED_SCANNER_MODE;
        break;
    default:
        m_lMode = 0;
        hr = E_INVALIDARG;
        break;
    }
    return hr;
}

//
// Automatic document feeder functions
//

HRESULT CFakeScanAPI::FakeScanner_ADFHasPaper()
{
    HRESULT hr = S_OK;

    //
    // check paper count
    //

    if (m_PagesInADF <= 0) {
        hr = S_FALSE;
        m_PagesInADF = MAX_PAGE_CAPACITY;
    }

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_ADFAvailable()
{
    HRESULT hr = S_OK;

    //
    // check ADF on-line
    //

    if (!m_ADFIsAvailable) {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_ADFFeedPage()
{
    HRESULT hr = S_OK;

    if (S_OK != FakeScanner_ADFHasPaper()) {

        //
        // set paper empty error code
        //

        hr = WIA_ERROR_PAPER_EMPTY;
    }

    //
    // update paper count for ADF
    //

    m_PagesInADF--;

    if (m_PagesInADF <0) {
        m_PagesInADF = 0;
    }

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_ADFUnFeedPage()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_ADFStatus()
{
    return m_hrLastADFError;
}

HRESULT CFakeScanAPI::FakeScanner_ADFAttached()
{
    return S_OK;
}

LONG CFakeScanAPI::WidthToDIBWidth(LONG lWidth)
{
    return(lWidth+3)&0xfffffffc;
}

LONG CFakeScanAPI::CalcTotalImageSize()
{
    LONG lTotalSize = 0;
    switch (m_RawDataInfo.bpp) {
    case 1:
        lTotalSize = ((m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lTotalSize = m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels;
        break;
    case 24:
        lTotalSize = (m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lTotalSize;
}

LONG CFakeScanAPI::CalcRawByteWidth()
{
    LONG lRawWidthBytes = 0;
    switch (m_RawDataInfo.bpp) {
    case 1:
        lRawWidthBytes = ((m_RawDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lRawWidthBytes = m_RawDataInfo.lWidthPixels;
        break;
    case 24:
        lRawWidthBytes = (m_RawDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lRawWidthBytes;
}

LONG CFakeScanAPI::CalcSrcByteWidth()
{
    LONG lSrcWidthBytes = 0;
    switch (m_SrcDataInfo.bpp) {
    case 1:
        lSrcWidthBytes = ((m_SrcDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lSrcWidthBytes = m_SrcDataInfo.lWidthPixels;
        break;
    case 24:
        lSrcWidthBytes = (m_SrcDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lSrcWidthBytes;
}

LONG CFakeScanAPI::CalcRandomDeviceDataTotalBytes()
{
    LONG lTotalBytes = 0;
    srand((unsigned)time(NULL));
    LONG lPageLengthInches = ((rand()%17) + 5);// max 22 inches, and min of 5 inches
    LONG lImageHeight = m_RawDataInfo.lYRes * lPageLengthInches;
    lTotalBytes = (CalcRawByteWidth() * lImageHeight);
    return lTotalBytes;
}

HRESULT CreateFakeScanner(CFakeScanAPI **ppFakeScanAPI, LONG lMode)
{
    HRESULT hr = S_OK;
    if (ppFakeScanAPI) {
        *ppFakeScanAPI = NULL;
        *ppFakeScanAPI = new CFakeScanAPI;
        if (NULL == *ppFakeScanAPI) {
            hr = E_OUTOFMEMORY;
        }
        CFakeScanAPI* pScanAPI = (CFakeScanAPI*)*ppFakeScanAPI;
        pScanAPI->FakeScanner_SetEmulationMode(lMode);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\scanapi.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       scanapi.h
*
*  VERSION:     1.1
*
*  DATE:        08 March, 2002
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#ifndef _SCANAPI_H
#define _SCANAPI_H

//
// ID mappings to events
//

#define ID_FAKE_NOEVENT             0
#define ID_FAKE_SCANBUTTON          100
#define ID_FAKE_COPYBUTTON          200
#define ID_FAKE_FAXBUTTON           300
#define ID_FAKE_ADFEVENT            400

//
// Scanner library modes
//

#define FLATBED_SCANNER_MODE        100
#define UNKNOWN_FEEDER_ONLY_SCANNER_MODE      200

//
// Scanning states
//

#define SCAN_START                  0
#define SCAN_CONTINUE               1
#define SCAN_END                    3

//
// Root Item information (for property initialization)
//

typedef struct _ROOT_ITEM_INFORMATION {
    LONG ScanBedWidth;          // 1/1000ths of an inch
    LONG ScanBedHeight;         // 1/1000ths of an inch
    LONG OpticalXResolution;    // Optical X Resolution of device
    LONG OpticalYResolution;    // Optical X Resolution of device
    LONG MaxScanTime;           // Milliseconds (total scan time)

    LONG DocumentFeederWidth;   // 1/1000ths of an inch
    LONG DocumentFeederHeight;  // 1/1000ths of an inch
    LONG DocumentFeederCaps;    // Capabilites of the device with feeder
    LONG DocumentFeederStatus;  // Status of document feeder
    LONG MaxPageCapacity;       // Maximum page capacity of feeder
    LONG DocumentFeederReg;     // document feeder alignment
    LONG DocumentFeederHReg;    // document feeder justification alignment (HORIZONTAL)
    LONG DocumentFeederVReg;    // document feeder justification alignment (VERTICAL)
    WCHAR FirmwareVersion[25];  // Firmware version of device
}ROOT_ITEM_INFORMATION, *PROOT_ITEM_INFORMATION;

//
// Range data type helper structure (used below)
//

typedef struct _RANGEPROPERTY {
    LONG lMin;  // minimum value
    LONG lMax;  // maximum value
    LONG lNom;  // numinal value
    LONG lInc;  // increment/step value
} RANGEPROPERTY,*PRANGEPROPERTY;

//
// Top Item information (for property initialization)
//

typedef struct _TOP_ITEM_INFORMATION {
    BOOL          bUseResolutionList;   // TRUE - use default Resolution list,
                                        // FALSE - use RANGEPROPERTY values
    RANGEPROPERTY Contrast;             // valid values for contrast
    RANGEPROPERTY Brightness;           // valid values for brightness
    RANGEPROPERTY Threshold;            // valid values for threshold
    RANGEPROPERTY XResolution;          // valid values for x resolution
    RANGEPROPERTY YResolution;          // valid values for y resolution
    LONG          lMinimumBufferSize;   // minimum buffer size
    LONG          lMaxLampWarmupTime;   // maximum lamp warmup time
} TOP_ITEM_INFORMATION, *PTOP_ITEM_INFORMATION;

//
// Scanner device constants
//

#define MAX_SCANNING_TIME    40000  // 40 seconds
#define MAX_LAMP_WARMUP_TIME 10000  // 10 seconds
#define MAX_PAGE_CAPACITY    25     // 25 pages

typedef struct _RAW_DATA_INFORMATION {
    LONG bpp;           // bits per pixel;
    LONG lWidthPixels;  // width of image in pixels
    LONG lHeightPixels; // height of image in pixels
    LONG lOffset;       // raw copy offset from top of raw buffer;
    LONG lXRes;         // x resolution
    LONG lYRes;         // y resolution
} RAW_DATA_INFORMATION,*PRAW_DATA_INFORMATION;

class CFakeScanAPI {
public:

    //
    // constructor/destructor
    //

    CFakeScanAPI();
    ~CFakeScanAPI();

    //
    // device initialization function
    //

    HRESULT FakeScanner_Initialize();

    //
    // device setting functions
    //

    HRESULT FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo);
    HRESULT FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo);
    HRESULT FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight);

    //
    // data acquisition functions
    //

    HRESULT FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten);
    HRESULT FakeScanner_SetDataType(LONG lDataType);
    HRESULT FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution);
    HRESULT FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt);
    HRESULT FakeScanner_SetContrast(LONG lContrast);

    HRESULT FakeScanner_SetIntensity(LONG lIntensity);

    //
    // standard device operations
    //

    HRESULT FakeScanner_ResetDevice();
    HRESULT FakeScanner_SetEmulationMode(LONG lDeviceMode);
    HRESULT FakeScanner_DisableDevice();
    HRESULT FakeScanner_EnableDevice();
    HRESULT FakeScanner_DeviceOnline();
    HRESULT FakeScanner_Diagnostic();

    //
    // Automatic document feeder functions
    //

    HRESULT FakeScanner_ADFAttached();
    HRESULT FakeScanner_ADFHasPaper();
    HRESULT FakeScanner_ADFAvailable();
    HRESULT FakeScanner_ADFFeedPage();
    HRESULT FakeScanner_ADFUnFeedPage();
    HRESULT FakeScanner_ADFStatus();

private:

    LONG    m_lLastEvent;           // Last Event ID
    LONG    m_lMode;                // Fake scanner library mode
    LONG    m_PagesInADF;           // Current number of pages in the ADF
    BOOL    m_ADFIsAvailable;       // ADF available TRUE/FALSE
    HRESULT m_hrLastADFError;       // ADF errors
    BOOL    m_bGreen;               // Are We Green?
    LONG    m_dwBytesWrittenSoFAR;  // How much data have we read so far?
    LONG    m_TotalDataInDevice;    // How much will we read total?

protected:

    //
    // RAW and SRC data information members
    //

    RAW_DATA_INFORMATION m_RawDataInfo; // Information about RAW data
    RAW_DATA_INFORMATION m_SrcDataInfo; // Information about SRC data

    //
    // RAW data calculation helper functions
    //

    LONG WidthToDIBWidth(LONG lWidth);
    LONG CalcTotalImageSize();
    LONG CalcRawByteWidth();
    LONG CalcSrcByteWidth();
    LONG CalcRandomDeviceDataTotalBytes();

};

HRESULT CreateFakeScanner(CFakeScanAPI **ppFakeScanAPI, LONG lMode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\wiascanr.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       wiascanr.cpp
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*   Implementation of the WIA Sample scanner class factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"
#ifndef INITGUID
    #include <initguid.h>
#endif

#if !defined(dllexp)
    #define DLLEXPORT __declspec( dllexport )
#endif

HINSTANCE g_hInst; // DLL module instance.

//
// This IID_IStiUSD GUID will eventually be in uuid.lib, at which point it should be removed
// from here.
//

// {0C9BB460-51AC-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiUSD, 0x0C9BB460L, 0x51AC, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

// {98B3790C-0D93-4f22-ADAF-51A45B33C998}
DEFINE_GUID(CLSID_SampleWIAScannerDevice,0x98b3790c, 0xd93, 0x4f22, 0xad, 0xaf, 0x51, 0xa4, 0x5b, 0x33, 0xc9, 0x98);

/***************************************************************************\
*
*  CWIADeviceClassFactory
*
\****************************************************************************/

class CWIADeviceClassFactory : public IClassFactory {
private:
    ULONG m_cRef;
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP CreateInstance(IUnknown __RPC_FAR *pUnkOuter,REFIID riid,void __RPC_FAR *__RPC_FAR *ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);
    CWIADeviceClassFactory();
    ~CWIADeviceClassFactory();
};

/**************************************************************************\
* CWIADeviceClassFactory::CWIADeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

CWIADeviceClassFactory::CWIADeviceClassFactory(void)
{
    m_cRef = 0;
}

/**************************************************************************\
* CWIADeviceClassFactory::~CWIADeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

CWIADeviceClassFactory::~CWIADeviceClassFactory(void)
{

}

/**************************************************************************\
* CWIADeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADeviceClassFactory::QueryInterface(
                                                          REFIID                      riid,
                                                          void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!ppvObject) {
        return E_INVALIDARG;
    }

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

/**************************************************************************\
* CWIADeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADeviceClassFactory::AddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWIADeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADeviceClassFactory::Release(void)
{
    ULONG ulRef = 0;
    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWIADeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADeviceClassFactory::CreateInstance(
                                                          IUnknown __RPC_FAR          *punkOuter,
                                                          REFIID                      riid,
                                                          void __RPC_FAR *__RPC_FAR   *ppvObject)
{

    //
    // If the caller is not requesting IID_IUnknown or IID_IStiUsd then
    // return E_NOINTERFACE, letting the caller know that interface
    // is not supported by this COM component.
    //

    if ((!IsEqualIID(riid, IID_IStiUSD)) && (!IsEqualIID(riid, IID_IUnknown))) {
        return E_NOINTERFACE;
    }

    //
    // If the caller is creating for aggregation, only IID_IUnknown can be requested.
    //

    if ((punkOuter) && (!IsEqualIID(riid, IID_IUnknown))) {
        return CLASS_E_NOAGGREGATION;
    }

    //
    // allocate the CWIAScannerDevce object.  This is the WIA minidriver object which
    // supports the WIA interfaces.  If allocation fails for this object, return an
    // E_OUTOFMEMORY error to the caller.
    //

    CWIADevice  *pDev = NULL;
    pDev = new CWIADevice(punkOuter);
    if (!pDev) {
        return E_OUTOFMEMORY;
    }

    //
    // If the allocation is successful, call PrivateInitialize().  This function handles
    // all internal initializing of the WIA minidriver object.  The implementation of this
    // function can be found in wiascanr.cpp.  If PrivateInitialize fails, then the WIA
    // minidriver object must be destroyed and the entire CreateInstance() muct fail.
    //

    HRESULT hr = pDev->PrivateInitialize();
    if (S_OK != hr) {
        delete pDev;
        pDev = NULL;
        return hr;
    }

    //
    // Call the NonDelegating interface methods to handle nonaggregated requests.
    // Do not do this if we are aggregated or the private IUknown interface will be lost.
    //

    hr = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hr;
}

/**************************************************************************\
* CWIADeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADeviceClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {

        //
        // The class factory is being locked
        //

    } else {

        //
        // The class factory is being unlocked
        //

    }
    return S_OK;
}

/**************************************************************************\
* CWIADevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::NonDelegatingQueryInterface(
                                                           REFIID  riid,
                                                           LPVOID  *ppvObj)
{
    if (!ppvObj) {
        return E_INVALIDARG;
    }

    *ppvObj = NULL;

    //
    // If the caller is asking for any interfaces supported by this WIA
    // minidriver, IID_IUnknown, IID_IStiUSD, or IID_WiaMiniDrv statis_cast
    // the "this" pointer to the requested interface.
    //

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    } else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    } else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    } else {
        return STIERR_NOINTERFACE;
    }

    (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();

    return S_OK;
}

/**************************************************************************\
* CWIADevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWIADevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADevice::NonDelegatingRelease(void)
{
    ULONG ulRef = InterlockedDecrement((LPLONG)&m_cRef);
    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWIADevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if(!m_punkOuter){
        return E_NOINTERFACE;
    }
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWIADevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADevice::AddRef(void)
{
    if(!m_punkOuter){
        return 0;
    }
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWIADevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADevice::Release(void)
{
    if(!m_punkOuter){
        return 0;
    }
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/


extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
                                                HINSTANCE   hinst,
                                                DWORD       dwReason,
                                                LPVOID      lpReserved)
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        g_hInst = hinst;
        DisableThreadLibraryCalls(hinst);
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Retrieves the class object from a DLL object handler or object
*   application.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
                                   REFCLSID    rclsid,
                                   REFIID      riid,
                                   LPVOID      *ppv)
{
    if (!ppv) {
        return E_INVALIDARG;
    }

    //
    // If the caller is not requesting the proper WIA minidriver class
    // then fail the call with CLASS_E_CLASSNOTAVAILABLE.
    //

    if (!IsEqualCLSID(rclsid, CLSID_SampleWIAScannerDevice) ) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    //
    // If the caller is not requesting IID_IUnknown or IID_IClassFactory
    // then fail the call with E_NOINTERFACE;
    //

    if ((!IsEqualIID(riid, IID_IUnknown)) && (!IsEqualIID(riid, IID_IClassFactory))) {
        return E_NOINTERFACE;
    }

    //
    // Allocate the WIA minidriver class factory that belongs to the WIA minidriver
    // COM object.
    //

    if (IsEqualCLSID(rclsid, CLSID_SampleWIAScannerDevice)) {
        CWIADeviceClassFactory *pcf = new CWIADeviceClassFactory;
        if (!pcf) {
            return E_OUTOFMEMORY;
        }
        *ppv = (LPVOID)pcf;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascnex\classes.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999

#ifndef _CLASSES_H_
#define _CLASSES_H_


/*****************************************************************************
class CShellExt

Implement our regular shell extensions.


******************************************************************************/

class ATL_NO_VTABLE CShellExt :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CShellExt, &CLSID_ScannerShellExt>,
    public IShellExtInit, public IContextMenu
{
    private:
        UINT_PTR m_ScanButtonidCmd;
        UINT_PTR m_CopyButtonidCmd;
        UINT_PTR m_FaxButtonidCmd;
        CComPtr<IWiaItem> m_pItem;
        
    public:
    DECLARE_REGISTRY_RESOURCEID(IDR_VIEWREG)
    BEGIN_COM_MAP(CShellExt)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IContextMenu)        
    END_COM_MAP()
        
        // IShellExtInit
        STDMETHODIMP Initialize (LPCITEMIDLIST pidlFolder,LPDATAOBJECT lpdobj,HKEY hkeyProgID);
        
        // IContextMenu
        STDMETHODIMP QueryContextMenu (HMENU hmenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
        STDMETHODIMP InvokeCommand    (LPCMINVOKECOMMANDINFO lpici);
        STDMETHODIMP GetCommandString (UINT_PTR idCmd, UINT uType,UINT* pwReserved,LPSTR pszName,UINT cchMax);
        ~CShellExt ();
        CShellExt ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\wiaprop.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       WIAProp.h
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*   Default property declarations and definitions for the
*   Sample WIA Scanner device.
*
***************************************************************************/

#ifndef _WIAPROP_H
#define _WIAPROP_H

#define SCANNER_FIRMWARE_VERSION L"1.0"
#define OPTICAL_XRESOLUTION      300
#define OPTICAL_YRESOLUTION      300
#define HORIZONTAL_BED_SIZE      8500   // in one thousandth's of an inch
#define VERTICAL_BED_SIZE        11000  // in one thousandth's of an inch

#define HORIZONTAL_ADF_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_ADF_BED_SIZE    11000  // in one thousandth's of an inch

#define HORIZONTAL_TPA_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_TPA_BED_SIZE    11000  // in one thousandth's of an inch

#define MIN_BUFFER_SIZE          65535

#define INITIAL_PHOTOMETRIC_INTERP WIA_PHOTO_WHITE_1
#define INITIAL_COMPRESSION        WIA_COMPRESSION_NONE
#define INITIAL_XRESOLUTION        150
#define INITIAL_YRESOLUTION        150
#define INITIAL_DATATYPE           WIA_DATA_GRAYSCALE
#define INITIAL_BITDEPTH           8
#define INITIAL_BRIGHTNESS         0
#define INITIAL_CONTRAST           0
#define INITIAL_CHANNELS_PER_PIXEL 1
#define INITIAL_BITS_PER_CHANNEL   8
#define INITIAL_PLANAR             WIA_PACKED_PIXEL
#define INITIAL_FORMAT             (GUID*) &WiaImgFmt_MEMORYBMP
#define INITIAL_TYMED              TYMED_CALLBACK

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\wiascanr.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       wiascanr.h
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*
*
***************************************************************************/

#include "pch.h"

//
// Base structure for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // IUnknown-like methods
    STDMETHOD(NonDelegatingQueryInterface)(THIS_
              REFIID riid,
              LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};

// WIA item specific context.
typedef struct _MINIDRIVERITEMCONTEXT{
   LONG     lSize;
   LONG     lHeaderSize;                        // Transfer header size
   LONG     lImageSize;                         // Image
   LONG     lDepth;                             // image bit depth
   LONG     lBytesPerScanLine;                  // bytes per scan line     (scanned data)
   LONG     lBytesPerScanLineRaw;               // bytes per scan line RAW (scanned data)
   LONG     lTotalRequested;                    // Total image bytes requested.
   LONG     lTotalWritten;                      // Total image bytes written.
} MINIDRIVERITEMCONTEXT, *PMINIDRIVERITEMCONTEXT;

typedef struct _BASIC_PROP_INFO {
    LONG lNumValues;
    LONG *plValues;
}BASIC_PROP_INFO,*PBASIC_PROP_INFO;

typedef struct _BASIC_PROP_INIT_INFO {
    LONG                lNumProps;     // number of item properties
    LPOLESTR            *pszPropNames; // item property names
    PROPID              *piPropIDs;    // item property ids
    PROPVARIANT         *pvPropVars;   // item property prop variants
    PROPSPEC            *psPropSpec;   // item property propspecs
    WIA_PROPERTY_INFO   *pwpiPropInfo; // item property attributes
}BASIC_PROP_INIT_INFO,*PBASIC_PROP_INIT_INFO;

#define HKEY_WIASCANR_FAKE_EVENTS TEXT("Software\\Microsoft\\WIASCANR")
#define WIASCANR_DWORD_FAKE_EVENT_CODE TEXT("EventCode")
#define AVERAGE_FAKE_PAGE_HEIGHT_INCHES 11
#define DEFAULT_LOCK_TIMEOUT 100

#define WIA_DEVICE_ROOT_NAME L"Root"       // THIS SHOULD NOT BE LOCALIZED
#define WIA_DEVICE_FLATBED_NAME L"Flatbed" // THIS SHOULD NOT BE LOCALIZED
#define WIA_DEVICE_FEEDER_NAME L"Feeder"   // THIS SHOULD NOT BE LOCALIZED

//
// Class definition for WIA device object
//

class CWIADevice : public IStiUSD,               // STI USD interface
                   public IWiaMiniDrv,           // WIA Minidriver interface
                   public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWIADevice(LPUNKNOWN punkOuter);
    ~CWIADevice();

    HRESULT PrivateInitialize();

private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    DWORD               m_dwLastOperationError; // Last error.
    DWORD               m_dwLockTimeout;        // Lock timeout for LockDevice() calls
    BOOL                m_bDeviceLocked;        // device locked/unlocked
    HANDLE              m_hDeviceDataHandle;    // Device communication handle

    // Event information
    OVERLAPPED          m_EventOverlapped;      // event overlapped IO structure
    BYTE                m_EventData[32];        // event data
    BOOL                m_bPolledEvent;         // event polling flag
    HKEY                m_hFakeEventKey;        // event HKEY for simulating notifications
    GUID                m_guidLastEvent;        // Last event ID.

    // WIA information
    IWiaDrvItem         *m_pIDrvItemRoot;       // The root item.
    IStiDevice          *m_pStiDevice;          // Sti object.
    IWiaLog             *m_pIWiaLog;            // WIA logging object
    BOOL                m_bADFEnabled;          // ADF enabled flag
    BOOL                m_bADFAttached;         // ADF attached flag
    LONG                m_lClientsConnected;    // number of applications connected

    CFakeScanAPI        *m_pScanAPI;            // FakeScanner API object

    LONG                m_NumSupportedFormats;  // Number of supported formats
    WIA_FORMAT_INFO     *m_pSupportedFormats;   // supported formats

    LONG                m_NumSupportedCommands; // Number of supported commands
    LONG                m_NumSupportedEvents;   // Number of supported events
    WIA_DEV_CAP_DRV     *m_pCapabilities;       // capabilities

    LONG                m_NumInitialFormats;    // Number of Initial formats
    GUID                *m_pInitialFormats;     // initial formats

    BASIC_PROP_INFO     m_SupportedTYMED;       // supported TYMED
    BASIC_PROP_INFO     m_SupportedDataTypes;   // supported data types
    BASIC_PROP_INFO     m_SupportedIntents;     // supported intents
    BASIC_PROP_INFO     m_SupportedCompressionTypes; // supported compression types
    BASIC_PROP_INFO     m_SupportedResolutions; // supported resolutions
    BASIC_PROP_INFO     m_SupportedPreviewModes;// supported preview modes

    LONG                m_NumRootItemProperties;// Number of Root item properties
    LONG                m_NumItemProperties;    // Number of item properties

    BASIC_PROP_INIT_INFO m_RootItemInitInfo;
    BASIC_PROP_INIT_INFO m_ChildItemInitInfo;

public:

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHOD(Initialize)(THIS_
        PSTIDEVICECONTROL pHelDcb,
        DWORD             dwStiVersion,
        HKEY              hParametersKey);

    STDMETHOD(GetCapabilities)(THIS_
        PSTI_USD_CAPS pDevCaps);

    STDMETHOD(GetStatus)(THIS_
        PSTI_DEVICE_STATUS pDevStatus);

    STDMETHOD(DeviceReset)(THIS);

    STDMETHOD(Diagnostic)(THIS_
        LPDIAG pBuffer);

    STDMETHOD(Escape)(THIS_
        STI_RAW_CONTROL_CODE EscapeFunction,
        LPVOID               lpInData,
        DWORD                cbInDataSize,
        LPVOID               pOutData,
        DWORD                dwOutDataSize,
        LPDWORD              pdwActualData);

    STDMETHOD(GetLastError)(THIS_
        LPDWORD pdwLastDeviceError);

    STDMETHOD(LockDevice)(THIS);

    STDMETHOD(UnLockDevice)(THIS);

    STDMETHOD(RawReadData)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteData)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawReadCommand)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteCommand)(THIS_
        LPVOID       lpBuffer,
        DWORD        dwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(SetNotificationHandle)(THIS_
        HANDLE hEvent);

    STDMETHOD(GetNotificationData)(THIS_
        LPSTINOTIFY lpNotify);

    STDMETHOD(GetLastErrorInfo)(THIS_
        STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        BSTR        bstrDeviceID,
        BSTR        bstrRootFullItemName,
        IUnknown    *pStiDevice,
        IUnknown    *pIUnknownOuter,
        IWiaDrvItem **ppIDrvItemRoot,
        IUnknown    **ppIUnknownInner,
        LONG        *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG     lFlags,
        LONG     lDevErrVal,
        LPOLESTR *ppszDevErrStr,
        LONG     *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        const GUID  *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG        *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE            *pWiasContext,
        LONG            ulFlags,
        LONG            *pcelt,
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG            *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG lFlags,
        BYTE *pSpecContext,
        LONG *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE            *pWiasContext,
        LONG            lFlags,
        LONG            *pcelt,
        WIA_FORMAT_INFO **ppwfi,
        LONG            *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID *pEventGUID,
        BSTR       bstrDeviceID,
        ULONG      ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE *pWiasContext);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // This section is for private helpers used for common WIA operations. //
    // These are custom to your driver.                                    //
    //                                                                     //
    //                                                                     //
    // -- WIA Item Management Helpers                                      //
    //    DeleteItemTree()                                                 //
    //                                                                     //
    // -- WIA Property Management Helpers                                  //
    //    BuildRootItemProperties()                                        //
    //    BuildTopItemProperties()                                         //
    //                                                                     //
    // -- WIA Capability Management Helpers                                //
    //    BuildRootItemProperties()                                        //
    //    DeleteRootItemProperties()                                       //
    //    BuildTopItemProperties()                                         //
    //    DeleteTopItemProperties()                                        //
    //    BuildCapabilities()                                              //
    //    DeleteCapabilitiesArrayContents()                                //
    //    BuildSupportedFormats()                                          //
    //    DeleteSupportedFormatsArrayContents()                            //
    //    BuildSupportedDataTypes()                                        //
    //    DeleteSupportedDataTypesArrayContents()                          //
    //    BuildSupportedIntents()                                          //
    //    DeleteSupportedIntentsArrayContents()                            //
    //    BuildSupportedCompressions()                                     //
    //    DeleteSupportedCompressionsArrayContents()                       //
    //    BuildSupportedPreviewModes()                                     //
    //    DeleteSupportedPreviewModesArrayContents()                       //
    //    BuildSupportedTYMED()                                            //
    //    DeleteSupportedTYMEDArrayContents()                              //
    //    BuildSupportedResolutions()                                      //
    //    DeleteSupportedResolutionsArrayContents()                        //
    //    BuildInitialFormats()                                            //
    //    DeleteInitialFormatsArrayContents()                              //
    //                                                                     //
    // -- WIA Validation Helpers                                           //
    //    CheckDataType()                                                  //
    //    CheckIntent()                                                    //
    //    CheckPreferredFormat()                                           //
    //    CheckADFStatus()                                                 //
    //    CheckPreview()                                                   //
    //    CheckXExtent()                                                   //
    //    UpdateValidDepth()                                               //
    //    UpdateValidPages()                                               //
    //    ValidateDataTransferContext()                                    //
    //                                                                     //
    // -- WIA Resource file Helpers                                        //
    //    GetBSTRResourceString()                                          //
    //    GetOLESTRResourceString()                                        //
    //                                                                     //
    // -- WIA Data Helpers                                                 //
    //    AlignInPlace()                                                   //
    //    SwapBuffer24()                                                   //
    //    GetPageCount()                                                   //
    //    IsPreviewScan()                                                  //
    //    SetItemSize()                                                    //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    HRESULT DeleteItemTree();

    HRESULT BuildRootItemProperties();
    HRESULT DeleteRootItemProperties();
    HRESULT BuildChildItemProperties();
    HRESULT DeleteChildItemProperties();
    HRESULT BuildCapabilities();
    HRESULT DeleteCapabilitiesArrayContents();
    HRESULT BuildSupportedFormats();
    HRESULT DeleteSupportedFormatsArrayContents();
    HRESULT BuildSupportedDataTypes();
    HRESULT DeleteSupportedDataTypesArrayContents();
    HRESULT BuildSupportedIntents();
    HRESULT DeleteSupportedIntentsArrayContents();
    HRESULT BuildSupportedCompressions();
    HRESULT DeleteSupportedCompressionsArrayContents();
    HRESULT BuildSupportedPreviewModes();
    HRESULT DeleteSupportedPreviewModesArrayContents();
    HRESULT BuildSupportedTYMED();
    HRESULT DeleteSupportedTYMEDArrayContents();
    HRESULT BuildSupportedResolutions();
    HRESULT DeleteSupportedResolutionsArrayContents();
    HRESULT BuildInitialFormats();
    HRESULT DeleteInitialFormatsArrayContents();

    HRESULT CheckDataType(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckIntent(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckPreferredFormat(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckADFStatus(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckPreview(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckXExtent(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext,LONG lWidth);
    HRESULT UpdateValidDepth(BYTE *pWiasContext,LONG lDataType,LONG *lDepth);
    HRESULT UpdateValidPages(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT ValidateDataTransferContext(PMINIDRV_TRANSFER_CONTEXT pDataTransferContext);

    HRESULT GetBSTRResourceString(LONG lLocalResourceID,BSTR *pBSTR,BOOL bLocal);
    HRESULT GetOLESTRResourceString(LONG lLocalResourceID,LPOLESTR *ppsz,BOOL bLocal);

    UINT AlignInPlace(PBYTE pBuffer,LONG cbWritten,LONG lBytesPerScanLine,LONG lBytesPerScanLineRaw);
    VOID SwapBuffer24(PBYTE pBuffer,LONG lByteCount);
    LONG GetPageCount(BYTE *pWiasContext);
    BOOL IsPreviewScan(BYTE *pWiasContext);
    HRESULT SetItemSize(BYTE *pWiasContext);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascnex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
#pragma hdrstop

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascnex\resource.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999

#define IDS_CATEGORYNAME                40006
#define IDS_PRESS_SCANBUTTON            30000
#define IDS_PRESS_COPYBUTTON            30001
#define IDS_PRESS_FAXBUTTON             30002

#define IDR_VIEWREG                     2001
#define IDR_CATEGORY                    2002
#define IDR_CATEGORIES                  2003
#define IDR_ELEMENT                     2004
#define IDI_TESTDEVICE                  2005
#define IDM_PRESS_SCANBUTTON            200
#define IDM_PRESS_COPYBUTTON            201
#define IDM_PRESS_FAXBUTTON             202
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascanr\validate.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       validate.cpp
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro
#define MAX_PAGE_CAPACITY    25     // 25 pages
/**************************************************************************\
* ValidateDataTransferContext
*
*   Checks the data transfer context to ensure it's valid.
*
* Arguments:
*
*    pDataTransferContext - Pointer the data transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::ValidateDataTransferContext(
    PMINIDRV_TRANSFER_CONTEXT pDataTransferContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::ValidateDataTransferContext");

    //
    // If the caller does not specify a MINIDRV_TRANSFER_CONTEXT structure
    // pointer then fail with E_INVALIDARG.
    //

    if(!pDataTransferContext)
    {
        return E_INVALIDARG;
    }

    //
    // If the size of the MINIDRV_TRANSFER_CONTEXT is not equal to the one
    // that is expected, then fail with E_INVALIDARG.
    //

    if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid data transfer context"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    switch(pDataTransferContext->tymed)
    {
    case TYMED_FILE:
        {

            //
            // If the FORMAT guid is not WiaImgFmt_BMP or WiaImgFmt_TIFF
            // then fail with E_INVALIDARG
            //

            if ((pDataTransferContext->guidFormatID != WiaImgFmt_BMP) &&
                (pDataTransferContext->guidFormatID != WiaImgFmt_TIFF)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_FILE"));
                hr = E_INVALIDARG;
            }
        }
        break;
    case TYMED_CALLBACK:
        {

            //
            // If the FORMAT guid is not WiaImgFmt_MEMORYBMP
            // then fail with E_INVALIDARG
            //

            if(pDataTransferContext->guidFormatID != WiaImgFmt_MEMORYBMP){
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_CALLBACK"));
                hr = E_INVALIDARG;
            }
        }
        break;
    case TYMED_MULTIPAGE_FILE:
        {

            //
            // If the FORMAT guid is not WiaImgFmt_TIFF
            // then fail with E_INVALIDARG
            //

            if(pDataTransferContext->guidFormatID != WiaImgFmt_TIFF){
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_MULTIPAGE_FILE"));
                hr = E_INVALIDARG;
            }
        }
        break;
    case TYMED_MULTIPAGE_CALLBACK:
        {

            //
            // If the FORMAT guid is not WiaImgFmt_TIFF
            // then fail with E_INVALIDARG
            //

            if(pDataTransferContext->guidFormatID != WiaImgFmt_TIFF){
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_MULTIPAGE_CALLBACK"));
                hr = E_INVALIDARG;
            }
        }
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

/**************************************************************************\
* UpdateValidDepth
*
*   Helper that updates the valid value for depth based on the data type.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the WiaItem context
*   lDataType   -   the value of the DataType property.
*   lDepth      -   the address of the variable where the Depth's new value
*                   will be returned.
*
* Return Value:
*
*   Status      -   S_OK if successful
*                   E_INVALIDARG if lDataType is unknown
*                   Errors are those returned by wiasReadPropLong,
*                   and wiasWritePropLong.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::UpdateValidDepth(
    BYTE        *pWiasContext,
    LONG        lDataType,
    LONG        *lDepth)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::UpdateValidDepth");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!lDepth)){
        return E_INVALIDARG;
    }

    //
    // Set the lDepth value according to the current lDataType setting
    //

    switch (lDataType) {
        case WIA_DATA_THRESHOLD:
            *lDepth = 1;
            break;
        case WIA_DATA_GRAYSCALE:
            *lDepth = 8;
            break;
        case WIA_DATA_COLOR:
            *lDepth = 24;
            break;
        default:
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("UpdateValidDepth, unknown data type"));
            return E_INVALIDARG;
    }

    return S_OK;
}

/**************************************************************************\
* CheckDataType
*
*   This helper method is called to check whether WIA_IPA_DATATYPE
*   property is changed.  When this property changes, other dependant
*   properties and their valid values must also be changed.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::CheckDataType(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::CheckDataType");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    WIAS_CHANGED_VALUE_INFO cviDataType;
    memset(&cviDataType,0,sizeof(cviDataType));

    WIAS_CHANGED_VALUE_INFO cviDepth;
    memset(&cviDepth,0,sizeof(cviDepth));

    //
    //  Call wiasGetChangedValue for DataType. It is checked first since it's
    //  not dependant on any other property.  All properties in this method
    //  that follow are dependant properties of DataType.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for DataType never change).  Also,
    //  the address of a variable for the old value is NULL, since the old
    //  value is not needed.  The address of bDataTypeChanged is passed
    //  so that dependant properties will know whether the DataType is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    HRESULT hr = wiasGetChangedValueLong(pWiasContext,pContext,FALSE,WIA_IPA_DATATYPE,&cviDataType);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for Depth. Depth is a dependant property of
    //  DataType whose valid value changes according to what the current
    //  value of DataType is.
    //
    //  The call to wiasGetChangedValue specifies that validation should only
    //  be skipped if the DataType has changed.  This is because the valid
    //  values for Depth will change according to the new value for
    //  DataType.  The address of a variable for the old value is NULL, since
    //  the old value is not needed.  The address of bDepthChanged is passed
    //  so that dependant properties will know whether the Depth is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,cviDataType.bChanged,WIA_IPA_DEPTH,&cviDepth);
    if (FAILED(hr)) {
        return hr;
    }

    if (cviDataType.bChanged) {

        //
        //  DataType changed so update valid value for Depth
        //

        hr = UpdateValidDepth(pWiasContext, cviDataType.Current.lVal, &cviDepth.Current.lVal);
        if (S_OK == hr) {

            //
            //  Check whether we must fold.  Depth will only be folded if it
            //  is not one of the properties that the app is changing.
            //

            if (!cviDepth.bChanged) {
                hr = wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, cviDepth.Current.lVal);
            }
        }
    }

    //
    //  Update properties dependant on DataType and Depth.
    //  Here, ChannelsPerPixel and BitsPerChannel are updated.
    //

    if (cviDataType.bChanged || cviDepth.bChanged) {
        if (S_OK == hr) {

            //
            // initialize PROPSPEC array
            //

            PROPSPEC ps[2] = {
                {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
                {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL  }
                };

            //
            // initilize PROPVARIANT array
            //

            PROPVARIANT pv[2];
            for (LONG index = 0; index < 2; index++) {
                PropVariantInit(&pv[index]);
                pv[index].vt = VT_I4;
            }

            //
            // use the current WIA data type to determine the proper
            // WIA_IPA_CHANNELS_PER_PIXEL and WIA_IPA_BITS_PER_CHANNEL
            // settings
            //

            switch (cviDataType.Current.lVal) {
                case WIA_DATA_THRESHOLD:
                    pv[0].lVal = 1;
                    pv[1].lVal = 1;
                    break;
                case WIA_DATA_GRAYSCALE:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
                case WIA_DATA_COLOR:
                    pv[0].lVal = 3;
                    pv[1].lVal = 8;
                    break;
                default:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
            }
            hr = wiasWriteMultiple(pWiasContext, 2, ps, pv);
        }
    }

    return hr;
}

/**************************************************************************\
* CheckIntent
*
*   This helper method is called to make the relevant changes if the
*   Current Intent property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::CheckIntent(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::CheckIntent");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)) {
        return E_INVALIDARG;
    }

    WIAS_CHANGED_VALUE_INFO cviIntent;
    memset(&cviIntent,0,sizeof(cviIntent));

    //
    //  Call wiasGetChangedValue for CurrentIntent. CurrentIntent is checked first
    //  since it's not dependant on any other property.  All properties in
    //  this method that follow are dependant properties of CurrentIntent.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for CurrentIntent never change). The
    //  address of the old value is specified as NULL, since it is not used.
    //  The address of bIntentChanged is passed so that dependant properties
    //  will know whether the YResolution is being changed or not.  This is
    //  important since dependant properties will need their valid values
    //  updated and may need to be folded to new valid values.
    //

    HRESULT hr = wiasGetChangedValueLong(pWiasContext,pContext,FALSE,WIA_IPS_CUR_INTENT,&cviIntent);
    if (S_OK ==hr) {

        //
        // If the WIA intent value was changed, then validate dependant values:
        // WIA_IPA_DATATYPE
        // WIA_IPA_DEPTH
        // WIA_IPS_XRES
        // WIA_IPS_YRES
        // WIA_IPS_XEXTENT
        // WIA_IPS_YEXTENT
        // WIA_IPA_PIXELS_PER_LINE
        // WIA_IPA_NUMBER_OF_LINES
        //

        if (cviIntent.bChanged) {

            LONG lImageTypeIntent = (cviIntent.Current.lVal & WIA_INTENT_IMAGE_TYPE_MASK);
            LONG lDataType = WIA_DATA_GRAYSCALE;
            LONG lDepth = 8;
            BOOL bUpdateDataTypeAndDepth = TRUE;
            switch (lImageTypeIntent) {

                case WIA_INTENT_NONE:
                    bUpdateDataTypeAndDepth = FALSE;
                    break;

                case WIA_INTENT_IMAGE_TYPE_GRAYSCALE:
                    lDataType = WIA_DATA_GRAYSCALE;
                    lDepth = 8;
                    break;

                case WIA_INTENT_IMAGE_TYPE_TEXT:
                    lDataType = WIA_DATA_THRESHOLD;
                    lDepth = 1;
                    break;

                case WIA_INTENT_IMAGE_TYPE_COLOR:
                    lDataType = WIA_DATA_COLOR;
                    lDepth = 24;
                    break;

                default:
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (TYPE) = %d",lImageTypeIntent));
                    return E_INVALIDARG;

            }

            if (bUpdateDataTypeAndDepth) {

                //
                // update the WIA_IPA_DATATYPE property and the WIA_IPA_DEPTH property
                //

                hr = wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, lDataType);
                if (S_OK == hr) {
                    hr = wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, lDepth);
                }
            }

            //
            // if we failed to complete the above operations, then
            // return, to avoid proceeding any more.
            //

            if(FAILED(hr)){
                return hr;
            }

            LONG lImageSizeIntent = (cviIntent.Current.lVal & WIA_INTENT_SIZE_MASK);

            switch (lImageSizeIntent) {
            case WIA_INTENT_NONE:
                    break;
            case WIA_INTENT_MINIMIZE_SIZE:
            case WIA_INTENT_MAXIMIZE_QUALITY:
                {

                    //
                    // Set the X and Y Resolutions.
                    //

                    hr = wiasWritePropLong(pWiasContext, WIA_IPS_XRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);
                    if(S_OK == hr){
                        hr = wiasWritePropLong(pWiasContext, WIA_IPS_YRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);
                    }

                    //
                    // check if we failed to update the WIA_IPS_XRES and WIA_IPS_YRES property
                    //

                    if(FAILED(hr)){
                        return hr;
                    }

                    //
                    //  The Resolutions and DataType were set, so update the property
                    //  context to indicate that they have changed.
                    //

                    hr = wiasSetPropChanged(WIA_IPS_XRES, pContext, TRUE);
                    if(S_OK == hr){
                        hr = wiasSetPropChanged(WIA_IPS_YRES, pContext, TRUE);
                        if(S_OK == hr){
                            hr = wiasSetPropChanged(WIA_IPA_DATATYPE, pContext, TRUE);
                        }
                    }

                    //
                    // check if we failed to flag WIA_IPS_XRES, WIA_IPS_YRES, and WIA_IPA_DATATYPE
                    // properties as changed
                    //

                    if(FAILED(hr)){
                        return hr;
                    }

                    //
                    // update IPA_NUMBER_OF_LINES property
                    //

                    LONG lLength = 0;

                    hr = wiasReadPropLong(pWiasContext, WIA_IPS_YEXTENT, &lLength, NULL, TRUE);
                    if (SUCCEEDED(hr)) {
                        hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, lLength);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_NUMBER_OF_LINES"));
                            return hr;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_YEXTENT"));
                        return hr;
                    }

                    //
                    // update IPA_PIXEL_PER_LINE property
                    //

                    LONG lWidth = 0;

                    hr = wiasReadPropLong(pWiasContext, WIA_IPS_XEXTENT, &lWidth, NULL, TRUE);
                    if (SUCCEEDED(hr)) {
                        hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lWidth);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_PIXELS_PER_LINE"));
                            return hr;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_XEXTENT"));
                        return hr;
                    }
                }
                break;
            default:
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (SIZE) = %d",lImageSizeIntent));
                return E_INVALIDARG;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, wiasGetChangedValue (intent) failed"));
    }
    return hr;
}

/**************************************************************************\
* CheckPreferredFormat
*
*   This helper method is called to make the relevant changes if the
*   Format property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::CheckPreferredFormat(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    //
    // update WIA_IPA_PREFERRED_FORMAT property to match current WIA_IPA_FORMAT setting.
    // This is a simple way of keeping the WIA_IPA_PREFERRED_FORMAT in sync with the
    // valid FORMAT.
    //
    // The proper action to take here is to choose the real preferred
    // format of your driver that fits in the valid value set of the current WIA_IPA_FORMAT
    // setting.  The preferred format is a value that appliations may use to transfer by default.
    //
    // example: if your driver supports JPEG, and you prefer the application to transfer in JPEG
    //          when ever possible, then make sure your preferred format is always JPEG.  Remember
    //          that the preferred format can only be set to JPEG if JPEG is one of the current
    //          valid values for WIA_IPA_FORMAT. (If it is not, then the application might attempt
    //          to set an invalid value, by reading the WIA_IPA_PREFERRED_FORMAT and writing it to
    //          WIA_IPA_FORMAT)
    //

    GUID FormatGUID = GUID_NULL;
    HRESULT hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &FormatGUID, NULL, TRUE);
    if (S_OK == hr) {

        //
        // update the WIA_IPA_FILENAME_EXTENSION property to the correct file extension
        //

        BSTR bstrFileExt = NULL;

        if((FormatGUID == WiaImgFmt_BMP)||(FormatGUID == WiaImgFmt_MEMORYBMP)) {
            bstrFileExt = SysAllocString(L"BMP");
        } else if (FormatGUID == WiaImgFmt_TIFF){
            bstrFileExt = SysAllocString(L"TIF");
        }

        //
        // if the allocation of the BSTR is successful, then attempt to set the
        // WIA_IPA_FILENAME_EXTENSION property.
        //

        if(bstrFileExt) {
            hr = wiasWritePropStr(pWiasContext,WIA_IPA_FILENAME_EXTENSION,bstrFileExt);

            //
            // free the allocated BSTR file extension
            //

            SysFreeString(bstrFileExt);
            bstrFileExt = NULL;
        }

        if (S_OK == hr){
            hr = wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, FormatGUID);
            if (FAILED(hr)){
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckPreferredFormat, could not write WIA_IPA_PREFERRED_FORMAT"));
                return hr;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPA_FORMAT"));
    }
    return hr;
}

/**************************************************************************\
* CheckADFStatus
*
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::CheckADFStatus(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::CheckADFStatus");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    //
    // If there is NOT an ADF attached, just return S_OK, telling the caller that
    // everything is OK
    //

    if(!m_bADFAttached){
        return S_OK;
    }

    //
    // get the ROOT item, this is where the document feeder properties exist
    //

    BYTE *pRootItemCtx = NULL;
    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    //
    // read the current WIA_DPS_DOCUMENT_HANDLING_SELECT setting from the ROOT
    // item.
    //

    LONG lDocHandlingSelect = 0;
    hr = wiasReadPropLong(pRootItemCtx,
                          WIA_DPS_DOCUMENT_HANDLING_SELECT,
                          &lDocHandlingSelect,
                          NULL,
                          FALSE);

    //
    // if S_FALSE is returned, then the WIA_DPS_DOCUMENT_HANDLING_SELECT property does
    // not exist.  This means that we should default to FLATBED settings
    //

    if(hr == S_FALSE){
        lDocHandlingSelect = FLATBED;
    }

    //
    // turn ON/OFF the ADF controller flag
    //

    if (SUCCEEDED(hr)) {
        switch (lDocHandlingSelect) {
        case FEEDER:
            m_bADFEnabled = TRUE;
            hr = S_OK;
            break;
        case FLATBED:
            m_bADFEnabled = FALSE;
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
            break;
        }
    }

    if (S_OK == hr) {

        //
        // update document handling status
        //

        if (m_bADFEnabled) {

            HRESULT Temphr = m_pScanAPI->FakeScanner_ADFAvailable();
            if (S_OK == Temphr) {
                hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FEED_READY);
            } else {
                hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,PAPER_JAM);
            }

            if (FAILED(Temphr))
                hr = Temphr;
        } else {
            hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FLAT_READY);
        }
    }
    return hr;
}

/**************************************************************************\
* CheckPreview
*
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::CheckPreview(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::CheckPreview");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    //
    // get the ROOT item, this is where the preview property exists
    //

    BYTE *pRootItemCtx = NULL;
    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    //
    // read the current WIA_DPS_PREVIEW setting from the ROOT item.
    //

    LONG lPreview = 0;
    hr = wiasReadPropLong(pRootItemCtx,WIA_DPS_PREVIEW,&lPreview,NULL,FALSE);
    if(hr == S_FALSE){

        //
        // if S_FALSE is returned, then the WIA_DPS_PREVIEW property does
        // not exist.  Return S_OK, because we are can not proceed any more.
        //

        return S_OK;
    }

    //
    // log the results to the debugger, to show the current status of the WIA_DPS_PREVIEW
    // property.  This is where you would normally perform an operation to set the WIA minidriver
    // into PREVIEW mode. (ON/OFF)
    //

    if (S_OK == hr) {
        switch (lPreview) {
        case WIA_FINAL_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_FINAL_SCAN"));
            break;
        case WIA_PREVIEW_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_PREVIEW_SCAN"));
            break;
        default:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to invalid argument (%d)",lPreview));
            hr = E_INVALIDARG;
            break;
        }
    }
    return hr;
}

/**************************************************************************\
* UpdateValidPages
*
*   This helper method is called to make the relevant changes to the Pages
*   property if a file format can not support multi-page.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::UpdateValidPages(BYTE *pWiasContext,
                                            WIA_PROPERTY_CONTEXT *pContext)
{
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    //
    // get the ROOT item, this is where the pages property exists
    //

    BYTE *pRootItemCtx   = NULL;
    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // read the current WIA_IPA_TYMED setting from the item
    //

    LONG lTymed = TYMED_FILE;
    hr = wiasReadPropLong(pWiasContext,WIA_IPA_TYMED,&lTymed,NULL,TRUE);
    if(S_OK == hr){
        switch(lTymed)
        {
        case TYMED_FILE:
            {
                GUID FormatGUID = GUID_NULL;
                hr = wiasReadPropGuid(pWiasContext,WIA_IPA_FORMAT,&FormatGUID,NULL,TRUE);
                if (S_OK == hr) {

                    if (FormatGUID == WiaImgFmt_BMP) {

                        //
                        // set the valid values for WIA_IPA_PAGES property to 1
                        // because there is no such thing as a multipage BMP file.
                        //

                        hr = wiasSetValidRangeLong(pRootItemCtx,WIA_DPS_PAGES,1,1,1,1);
                        if (S_OK == hr) {
                            hr = wiasWritePropLong(pRootItemCtx,WIA_DPS_PAGES,1);
                        }
                    }

                    if (FormatGUID == WiaImgFmt_TIFF) {

                        //
                        // set the valid values for WIA_IPA_PAGES property to MAX_PAGE_CAPACITY
                        // because there can be multiple pages transferred to TIF.
                        //

                        hr = wiasSetValidRangeLong(pRootItemCtx,WIA_DPS_PAGES,0,1,MAX_PAGE_CAPACITY,1);
                    }
                }
            }
            break;
        case TYMED_CALLBACK:
            {

                //
                // set the valid values for WIA_IPA_PAGES property to MAX_PAGE_CAPACITY
                // because there can be multiple pages transferred to memory.  Each page
                // will be separated by a IT_MSG_NEW_PAGE message in the application's
                // callback loop.
                //

                hr = wiasSetValidRangeLong(pRootItemCtx,WIA_DPS_PAGES,0,1,MAX_PAGE_CAPACITY,1);
            }
            break;
        default:
            break;
        }
    }
    return hr;
}

/**************************************************************************\
* CheckXExtent
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::CheckXExtent(BYTE *pWiasContext,
                                        WIA_PROPERTY_CONTEXT *pContext,
                                        LONG lWidth)
{
    HRESULT hr = S_OK;

    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CheckXExtent");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    LONG lMaxExtent;
    LONG lExt;
    WIAS_CHANGED_VALUE_INFO cviXRes, cviXExt;

    //
    // get x resolution changes
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,FALSE,WIA_IPS_XRES,&cviXRes);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // get x extent changes
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,cviXRes.bChanged,WIA_IPS_XEXTENT,&cviXExt);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // update extent
    //

    lMaxExtent = ((cviXRes.Current.lVal * lWidth) / 1000);

    //
    //  Update read-only property : PIXELS_PER_LINE.  The width in pixels
    //  of the scanned image is the same size as the XExtent.
    //

    if (SUCCEEDED(hr)) {
        hr = wiasWritePropLong(pWiasContext, WIA_IPS_XEXTENT, lMaxExtent);
        if(S_OK == hr){
            hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lMaxExtent);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascnex\precomp.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#define _ATL_NO_UUIDOF
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <initguid.h>
#include <shlguid.h>
#include "wiadevd.h"
#include "wiascidl.h"
#include "wia.h"
#include "wiaview.h"
#include "resource.h"
#include "wiascnex.h"
#include "classes.h"

#define g_hInst _Module.GetModuleInstance()
VOID Trace(LPCTSTR format,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascnex\shellext.cpp ===
///////////////////
// (C) COPYRIGHT MICROSOFT CORP., 1998-1999
//
// FILE: SHELLEXT.CPP
//
// DESCRIPTION: Implements IContextMenu and IShellPropSheetExt interfaces for
// the WIA Sample Scanner device
//
#include "precomp.h"
#pragma hdrstop

// Define a language-independent name for our menu verb

static const CHAR  g_PathVerbA[] =  "Press Scan Button";
static const WCHAR g_PathVerbW[] = L"Press Scan Button";

CShellExt :: CShellExt ()
{
    Trace(TEXT("CShellExt Constructor")); 
}

CShellExt::~CShellExt ()
{
    Trace(TEXT("CShellExt Destructor")); 
}

/*****************************************************************************

CShellExt::Initialize

Called by the shell when the user invokes context menu or property sheet for
one of our items. For context menus the dataobject may include more than one
selected item.

******************************************************************************/

STDMETHODIMP CShellExt::Initialize (LPCITEMIDLIST pidlFolder,
                                    LPDATAOBJECT lpdobj,
                                    HKEY hkeyProgID)
{
    Trace(TEXT("CShellExt::Initialize Called")); 
    LONG lType = 0;
    HRESULT hr = NOERROR;
    if (!lpdobj) {
        return E_INVALIDARG;
    }

    // For singular selections, the WIA namespace should always provide a
    // dataobject that also supports IWiaItem

    if (FAILED(lpdobj->QueryInterface (IID_IWiaItem, reinterpret_cast<LPVOID*>(&m_pItem)))) {
        // failing that, get the list of selected items from the data object
        UINT uItems         = 0;
        LPWSTR szName       = NULL;
        LPWSTR szToken      = NULL;
        
        szName = GetNamesFromDataObject (lpdobj, &uItems);

        //
        // we only support singular objects
        //

        if (uItems != 1) {
            hr = E_FAIL;
        } else {

            //
            // The name is of this format: <device id>::<item name>
            //

            LPWSTR szToken = wcstok (szName, L":");
            if (!szToken) {
                hr = E_FAIL;
            }

            //
            // Our extension only supports root items, so make sure there's no item
            // name
            //

            else if (wcstok (NULL, L":")) {
                hr = E_FAIL;
            } else {
                hr = CreateDeviceFromId (szToken, &m_pItem);
            }
        }
        if (szName) {
            delete [] szName;
        }
    }
    if (SUCCEEDED(hr)) {

        m_pItem->GetItemType (&lType);
        if (!(lType & WiaItemTypeRoot)) {
            hr = E_FAIL; // we only support changing the property on the root item
        }
    }
    return hr;
}

/*****************************************************************************

CShellExt::QueryContextMenu

Called by the shell to get our context menu strings for the selected item.

******************************************************************************/

STDMETHODIMP CShellExt::QueryContextMenu (HMENU hmenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    Trace(TEXT("CShellExt::QueryContextMenu Called"));
    Trace(TEXT("indexMenu  = %d"),indexMenu);
    Trace(TEXT("idCmdFirst = %d"),idCmdFirst);
    Trace(TEXT("idCmdLast  = %d"),idCmdLast);
    Trace(TEXT("uFlags     = %d"),uFlags);

    HRESULT hr = S_OK;    

    MENUITEMINFO mii;
    TCHAR szMenuItemName[MAX_PATH];
    memset(&mii,0,sizeof(mii));
    LoadString (g_hInst,IDS_PRESS_FAXBUTTON, szMenuItemName, MAX_PATH);

    mii.cbSize      = sizeof(mii);
    mii.fMask       = MIIM_STRING | MIIM_ID;
    mii.fState      = MFS_ENABLED;
    mii.wID         = idCmdFirst;
    mii.dwTypeData  = szMenuItemName;
    if (InsertMenuItem (hmenu, indexMenu, TRUE, &mii)) {
        m_FaxButtonidCmd = 0;
        memset(&mii,0,sizeof(mii));
        LoadString (g_hInst, IDS_PRESS_COPYBUTTON, szMenuItemName, MAX_PATH);

        mii.cbSize      = sizeof(mii);
        mii.fMask       = MIIM_STRING | MIIM_ID;
        mii.fState      = MFS_ENABLED;
        mii.wID         = idCmdFirst;    
        mii.dwTypeData  = szMenuItemName;
        if (InsertMenuItem (hmenu, indexMenu, TRUE, &mii)) {
            m_CopyButtonidCmd = 1;          
            memset(&mii,0,sizeof(mii));
            LoadString (g_hInst, IDS_PRESS_SCANBUTTON, szMenuItemName, MAX_PATH);

            mii.cbSize      = sizeof(mii);
            mii.fMask       = MIIM_STRING | MIIM_ID;
            mii.fState      = MFS_ENABLED;
            mii.wID         = idCmdFirst;    
            mii.dwTypeData  = szMenuItemName;
            if (InsertMenuItem (hmenu, indexMenu, TRUE, &mii)) {
                m_ScanButtonidCmd = 2;
                return MAKE_HRESULT(SEVERITY_SUCCESS, 0, 1);
            }
        }
    }    
    return hr;
}

/*****************************************************************************

CShellExt::InvokeCommand

Called by the shell when the user clicks one of our menu items

******************************************************************************/

STDMETHODIMP CShellExt::InvokeCommand    (LPCMINVOKECOMMANDINFO lpici)
{
    Trace(TEXT("CShellExt::InvokeCommand Called")); 
    HRESULT hr = S_OK;
    UINT_PTR idCmd = reinterpret_cast<UINT_PTR>(lpici->lpVerb);
    if(idCmd == 0){

        //
        // it's one of ours
        //

        MessageBox(NULL,TEXT("Context menu is Selected"),TEXT("Context Menu Verb Alert!"),MB_OK);            
    } else {
        hr = E_FAIL;
    }   
    return hr;
}

/*****************************************************************************

CShellExt::GetCommandString

Called by the shell to get our language independent verb name.

******************************************************************************/

STDMETHODIMP CShellExt::GetCommandString (UINT_PTR idCmd, UINT uType,UINT* pwReserved,LPSTR pszName,UINT cchMax)
{
    Trace(TEXT("CShellExt::GetCommandString Called")); 
    HRESULT hr = S_OK;

    if(idCmd == m_ScanButtonidCmd){
        
    } else if(idCmd == m_CopyButtonidCmd){
        
    } else if(idCmd == m_FaxButtonidCmd){
        
    } else {
        hr = E_FAIL;
    }
    
    if(FAILED(hr)){
        return hr;
    }

    switch (uType) {
    case GCS_VALIDATEA:
        if (pszName) {
            lstrcpyA (pszName, g_PathVerbA);
        }
        break;
    case GCS_VALIDATEW:
        if (pszName) {
            lstrcpyW (reinterpret_cast<LPWSTR>(pszName), g_PathVerbW);
        }
        break;
    case GCS_VERBA:
        lstrcpyA (pszName, g_PathVerbA);
        break;
    case GCS_VERBW:
        lstrcpyW (reinterpret_cast<LPWSTR>(pszName), g_PathVerbW);
        break;
    default:
        hr = E_FAIL;
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascroll\wiaprop.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       WIAProp.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Default property declarations and definitions for the
*   Sample WIA Scanner device.
*
***************************************************************************/

#ifndef _WIAPROP_H
#define _WIAPROP_H

#define SCANNER_FIRMWARE_VERSION L"1.0"
#define OPTICAL_XRESOLUTION      300
#define OPTICAL_YRESOLUTION      300
#define HORIZONTAL_BED_SIZE      8500   // in one thousandth's of an inch
#define VERTICAL_BED_SIZE        11000  // in one thousandth's of an inch

#define HORIZONTAL_ADF_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_ADF_BED_SIZE    11000  // in one thousandth's of an inch

#define HORIZONTAL_TPA_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_TPA_BED_SIZE    11000  // in one thousandth's of an inch

#define MIN_BUFFER_SIZE          65535

#define INITIAL_PHOTOMETRIC_INTERP WIA_PHOTO_WHITE_1
#define INITIAL_COMPRESSION        WIA_COMPRESSION_NONE
#define INITIAL_XRESOLUTION        150
#define INITIAL_YRESOLUTION        150
#define INITIAL_DATATYPE           WIA_DATA_GRAYSCALE
#define INITIAL_BITDEPTH           8
#define INITIAL_BRIGHTNESS         0
#define INITIAL_CONTRAST           0
#define INITIAL_CHANNELS_PER_PIXEL 1
#define INITIAL_BITS_PER_CHANNEL   8
#define INITIAL_PLANAR             WIA_PACKED_PIXEL
#define INITIAL_FORMAT             (GUID*) &WiaImgFmt_MEMORYBMP
#define INITIAL_TYMED              TYMED_CALLBACK

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascnex\wiascnex.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999

 #ifndef _WIASCNEX_H_
 #define _WIASCNEX_H_


 BOOL ShowMessage (HWND hParent, INT idCaption, INT idMessage);
 extern LONG                g_cRef;            // DLL reference counter.
 extern HINSTANCE           g_hInst;


void DllAddRef ();
void DllRelease ();
HRESULT CreateDeviceFromId (LPWSTR szDeviceId, IWiaItem **ppItem);
LPWSTR GetNamesFromDataObject (IDataObject *lpdobj, UINT *puItems);

// {50983B34-4F6E-448e-A2AB-3921EE71BE61}
DEFINE_GUID(CLSID_ScannerShellExt, 0x50983b34, 0x4f6e, 0x448e, 0xa2, 0xab, 0x39, 0x21, 0xee, 0x71, 0xbe, 0x61);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascroll\pch.h ===
#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <sti.h>
#include <assert.h>
#include <windows.h>
#include <stierr.h>

#define INITGUID
#include "initguid.h"
#include <stiusd.h>

#pragma intrinsic(memcmp,memset)

#include "resource.h"
#include "wiamindr.h"
#include "wiaprop.h"
#include "fscanapi.h"
#include "wiascroll.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascroll\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IWiaMiniDrv methods.
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;           // used for WIAS_LOGPROC macro

#define EST_PAGE_LENGTH_INCHES      17 // 17 inches
/**************************************************************************\
* CWIAScannerDevice::drvDeleteItem
*
*   This helper is called to delete a device item.
*   Note: Device items for this device may not be modified.
*         Return access denied.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*     7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvDeleteItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    *plDevErrVal = 0;
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvDeleteItem");
    return STG_E_ACCESSDENIED;
}

/**************************************************************************\
* SendImageHeader
*
*   This helper is called to send the bitmap header info to the callback
*   routine.
*   Note: This is a helper function used in TYMED_CALLBACK transfers.
*
* Arguments:
*
*   pmdtc   -   a pointer to a transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SendImageHeader(
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SendImageHeader");

    HRESULT hr = S_OK;

    if(pmdtc->guidFormatID == WiaImgFmt_BMP){
        BITMAPINFO UNALIGNED *pbmi = (LPBITMAPINFO)pmdtc->pTransferBuffer;
        UNALIGNED BITMAPINFOHEADER *pbmih = &pbmi->bmiHeader;
        pbmih->biHeight = -pbmih->biHeight;
    }

    //
    //  Send to class driver.  WIA Class driver will pass
    //  data through to client.
    //

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                     IT_STATUS_TRANSFER_TO_CLIENT,
                                                     0,
                                                     0,
                                                     pmdtc->lHeaderSize,
                                                     pmdtc,
                                                     0);

    if (hr == S_OK) {

        //
        //  If the transfer was successfull, advance offset for
        //  destination copy by the size of the data just sent.
        //

        pmdtc->cbOffset += pmdtc->lHeaderSize;
    }
    return hr;
}

/**************************************************************************\
* SendFilePreviewBitmapHeader
*
*   This helper is called to send the bitmap header info to the callback
*   routine.
*   Note: This is a helper function used in TYMED_FILE transfers with
*         (out of band data) enabled.
*
* Arguments:
*
*   pmdtc   -   a pointer to a transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SendFilePreviewImageHeader(
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SendImageHeader");

    HRESULT hr = S_OK;

    WIAS_DOWN_SAMPLE_INFO DownSampleInfo;
    memset(&DownSampleInfo,0,sizeof(DownSampleInfo));

    DownSampleInfo.ulBitsPerPixel       = pmdtc->lDepth;
    DownSampleInfo.ulOriginalWidth      = pmdtc->lWidthInPixels;
    DownSampleInfo.ulOriginalHeight     = pmdtc->lLines;
    DownSampleInfo.ulDownSampledHeight  = 0;
    DownSampleInfo.ulDownSampledWidth   = 0;
    DownSampleInfo.ulXRes               = pmdtc->lXRes;
    DownSampleInfo.ulYRes               = pmdtc->lYRes;

    hr = wiasDownSampleBuffer(0x1/*WIAS_GET_DOWNSAMPLED_SIZE_ONLY*/,
                              &DownSampleInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SendFilePreviewBitmapHeader, wiasDownSampleBuffer Failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    } else {

        //
        // acquire BITMAPHEADER pointer from pmdtc
        //

        pmdtc->pBaseBuffer          = pmdtc->pTransferBuffer + sizeof(BITMAPFILEHEADER);
        BITMAPINFO UNALIGNED *pbmi = (LPBITMAPINFO)pmdtc->pBaseBuffer;
        UNALIGNED BITMAPINFOHEADER *pbmih = &pbmi->bmiHeader;

        //
        // adjust width and height
        //

        pbmih->biHeight    = 0;                                 // set height to zero (0)
        pbmih->biWidth     = DownSampleInfo.ulDownSampledWidth; // set down sampled width

        //
        //  Send to class driver.  WIA Class driver will pass
        //  data through to client.
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_FILE_PREVIEW_DATA,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          0,
                                                          0,
                                                          pmdtc->lHeaderSize - sizeof(BITMAPFILEHEADER),
                                                          pmdtc,
                                                          0);
    }

    return hr;
}

/**************************************************************************\
* ScanItem
*
*   This helper is called to do a FILE transfer.
*   Note: This routine must fill the complete buffer, and return percent
*         complete status back to the client if a callback routine is
*         provided.
*
* Arguments:
*
*   pItemContext        - private item data
*   pMiniTranCtx        - minidriver supplied transfer info
*   plDevErrVal         - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*     7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::ScanItem(
    PMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::ScanItem");
    HRESULT hr = S_OK;

    LONG  lScanPhase   = SCAN_START;
    DWORD cbWritten    = 0;
    LONG  cbSize       = 0;
    PBYTE pBuf         = pmdtc->pTransferBuffer + pmdtc->lHeaderSize;
    LONG  lItemSize    = pmdtc->lHeaderSize;
    BYTE *pImageHeader = NULL;

    LONG  cbEstimatedPageSize = (pItemContext->lBytesPerScanLine * (pmdtc->lYRes * EST_PAGE_LENGTH_INCHES));

    //
    // data operation variables
    //

    BOOL  bSwapBGRData       = TRUE;
    BOOL  bDWORDAlign        = TRUE;
    BOOL  bVerticalFlip      = FALSE;
    LONG  lTotalLinesWritten = 0;
    ULONG ulDestDataOffset   = 0;

    pImageHeader = (BYTE*)LocalAlloc(LPTR,pmdtc->lHeaderSize);
    if (pImageHeader) {

        //
        // save image header, so we can update it later with correct number of lines..and size
        //

        memcpy(pImageHeader,pmdtc->pTransferBuffer,pmdtc->lHeaderSize);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, Could not allocate memory for FILE HEADER"));
        return E_OUTOFMEMORY;
    }

    //
    // send down sample header for out of band data
    //

    WIAS_DOWN_SAMPLE_INFO DownSampleInfo;
    memset(&DownSampleInfo,0,sizeof(DownSampleInfo));

    hr = SendFilePreviewImageHeader(pmdtc);
    if(hr == S_OK){

        //
        // move offset past file header
        //

        ulDestDataOffset += (pmdtc->lHeaderSize - sizeof(BITMAPFILEHEADER));
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, SendFilePreviewImageHeader Failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // scan until buffer runs out or scanner completes transfer
    //

    while ((lScanPhase == SCAN_START) || (cbWritten)) {

        //
        // Limit requests to max buffer size or less.
        //

        cbSize = m_MaxBufferSize;

        //
        // Request size to scanner must be modula the raw bytes per scan row.
        // Enough space for the alignment padding must be reserved.
        // These are requirements for AlignInPlace
        //

        cbSize = (cbSize / pItemContext->lBytesPerScanLine) * pItemContext->lBytesPerScanLineRaw;

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  lScanPhase indicates whether this is the first call to Scan,
        //  pBuf is a pointer to the buffer, cbSize is the amount of data
        //  requested from the scanner, and cbWritten will be set to the actual
        //  amount of data returned by the scanner.
        //

        hr = m_pScanAPI->FakeScanner_Scan(lScanPhase, pBuf, cbSize, &cbWritten);

        //
        // set flag to SCAN_CONTINUE, for other calls
        //

        lScanPhase = SCAN_CONTINUE;

        if (hr == S_OK) {
            if (cbWritten) {

                //
                // keep track of how many lines were written
                //

                lTotalLinesWritten += (cbWritten / pItemContext->lBytesPerScanLine);

                //
                // Place the scan data in correct byte order for 3 bytes ber pixel data.
                //

                if  ((pmdtc->lDepth       == 24) &&
                    ((pmdtc->guidFormatID == WiaImgFmt_BMP) ||
                    ((pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP)))) {

                    if (bSwapBGRData) {
                        SwapBuffer24(pBuf, cbWritten);
                    }
                }

                if (((pmdtc->guidFormatID == WiaImgFmt_BMP) ||
                    ((pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP)))) {

                    //
                    // Align the data on DWORD boundries.
                    //

                    if (bDWORDAlign) {
                        cbWritten = AlignInPlace(pBuf,
                                                 cbWritten,
                                                 pItemContext->lBytesPerScanLine,
                                                 pItemContext->lBytesPerScanLineRaw);
                    }
                }

                //
                // update lItemSize
                //

                if(lItemSize > 0){

                    //
                    // we have a header size already calculated in lItemSize,
                    // so add cbWritten to current size.
                    //

                    lItemSize += cbWritten;
                } else {

                    //
                    // this is pure data, no header
                    //

                    lItemSize = cbWritten;
                }

                //
                // decrease estimated page size, for (estimated percent complete calculation)
                //

                cbEstimatedPageSize -= lItemSize;

                //
                // avoid division by zero, by setting cbEstimatedPageSize to 1
                //

                if(cbEstimatedPageSize < 0){
                    cbEstimatedPageSize = 1;
                }

                //
                // If a status callback was specified callback the class driver.
                //

                if (pmdtc->pIWiaMiniDrvCallBack) {

                    FLOAT FractionComplete = 0.0f;
                    LONG  PercentComplete  = 0;

                    FractionComplete = (FLOAT)(lTotalLinesWritten * pItemContext->lBytesPerScanLineRaw) / (FLOAT)cbEstimatedPageSize;
                    if (FractionComplete > 0.9f) {
                        FractionComplete = 0.9f; // hold at 90% complete...until done
                    }

                    //
                    // calculate percent complete
                    //

                    PercentComplete = (LONG)(100 * FractionComplete);

                    //
                    // call back client with status on the transfer
                    //

                    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,
                                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                                      PercentComplete,
                                                                      0,
                                                                      0,
                                                                      NULL,
                                                                      0);
                    //
                    // check for user cancel (from IT_MSG_STATUS callback)
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItem, Transfer canceled by client (IT_MSG_STATUS callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItem, MiniDrvCallback failed (IT_MSG_STATUS callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }

                    //
                    // call back client with status on out of band data transfer
                    //

                    DownSampleInfo.pDestBuffer          = NULL;
                    DownSampleInfo.pSrcBuffer           = pBuf;
                    DownSampleInfo.ulActualSize         = 0;
                    DownSampleInfo.ulBitsPerPixel       = pmdtc->lDepth;
                    DownSampleInfo.ulDestBufSize        = 0;
                    DownSampleInfo.ulDownSampledHeight  = 0;
                    DownSampleInfo.ulDownSampledWidth   = 0;
                    DownSampleInfo.ulOriginalHeight     = (cbWritten / pItemContext->lBytesPerScanLine);
                    DownSampleInfo.ulOriginalWidth      = pmdtc->lWidthInPixels;
                    DownSampleInfo.ulSrcBufSize         = cbWritten;
                    DownSampleInfo.ulXRes               = pmdtc->lXRes;
                    DownSampleInfo.ulYRes               = pmdtc->lYRes;

                    //
                    // down sample data
                    //

                    hr = wiasDownSampleBuffer(0, &DownSampleInfo);
                    if(FAILED(hr)){
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, wiasDownSampleBuffer Failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    } else {

                        pmdtc->pBaseBuffer = DownSampleInfo.pDestBuffer;

                        //
                        // call back client with down sampled buffer
                        //

                        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_FILE_PREVIEW_DATA,
                                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                                          PercentComplete,
                                                                          ulDestDataOffset,
                                                                          DownSampleInfo.ulActualSize,
                                                                          pmdtc,
                                                                          0);
                        //
                        // update offset
                        //

                        ulDestDataOffset += DownSampleInfo.ulActualSize;
                    }

                    //
                    // check for user cancel (from IT_MSG_FILE_PREVIEW_DATA callback)
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,
                                    ("ScanItem, Transfer canceled by client (IT_MSG_FILE_PREVIEW_DATA callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,
                                    ("ScanItem, MiniDrvCallback failed (IT_MSG_FILE_PREVIEW_DATA callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }
                }

                //
                //  If the mini driver allocated a buffer, we need to write the
                //  buffer to the open file handle (opened by class driver).
                //

                if (!pmdtc->bClassDrvAllocBuf) {

                    //
                    //  Now that we know the true item size, update the mini driver
                    //  context.
                    //

                    pmdtc->lItemSize   = lItemSize;
                    pmdtc->lBufferSize = lItemSize;

                    //
                    // reset lItemSize
                    //

                    lItemSize = 0;

                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("ScanItem, Final lItemSize = %d bytes",lItemSize));

                    //
                    // write image data to disk (note: The first call of this will write the file header too!)
                    //

                    hr = wiasWritePageBufToFile(pmdtc);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, WritePageBufToFile failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }

                    //
                    // set pBuf to proper location
                    //

                    pBuf = pmdtc->pTransferBuffer;
                }

            }

        } else {

            //
            //  Get the device error
            //

            *plDevErrVal = (LONG) hr;
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, data transfer failed, status: 0x%X", hr));
            break;
        }
    }

    if (hr == S_OK) {
        if (pmdtc->guidFormatID == WiaImgFmt_BMP) {
            if(pImageHeader){

                BITMAPINFOHEADER UNALIGNED *pBMPInfoHeader = (BITMAPINFOHEADER*)(pImageHeader + sizeof(BITMAPFILEHEADER));
                BITMAPFILEHEADER UNALIGNED *pBMPFileHeader = (BITMAPFILEHEADER*)pImageHeader;

                //
                // set updated image height
                //

                pBMPInfoHeader->biHeight    = lTotalLinesWritten;

                //
                // set updated image size
                //

                pBMPInfoHeader->biSizeImage = (pBMPInfoHeader->biHeight * pItemContext->lBytesPerScanLine);

                //
                // set updated file size
                //

                pBMPFileHeader->bfSize      = pBMPInfoHeader->biSizeImage + pBMPFileHeader->bfOffBits;

                //
                // update file written to disk, by rewriting the header
                //

                DWORD dwBytesWrittenToFile = 0;

                //
                // reset file pointer to start of file
                //

                SetFilePointer((HANDLE)pmdtc->hFile,0,NULL,FILE_BEGIN);

                //
                // write (header size) bytes to the file, using the stored
                // file header above.
                //

                WriteFile((HANDLE)pmdtc->hFile,pImageHeader,pmdtc->lHeaderSize,&dwBytesWrittenToFile,NULL);

                //
                // validate that the write was successful, by comparing sizes
                //

                if((LONG)dwBytesWrittenToFile != pmdtc->lHeaderSize){
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, Header was not written to file correctly"));
                }

                //
                // this driver writes the data up-side-down..
                // so the final file needs to be flipped.
                // note: read the file, and flip it here??

                if (bVerticalFlip) {
                    // VerticalFlip(pItemContext, pmdtc);
                }
            }
        }

        //
        // call back client with status on the transfer
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100, // 100 percent complete!
                                                          0,
                                                          0,
                                                          NULL,
                                                          0);
        if(hr == S_OK){

            //
            // Since we are out of data.. we should send the WIA_STATUS_END_OF_MEDIA
            //

            // hr = WIA_STATUS_END_OF_MEDIA;
            hr = S_OK;
        }
    }

    HRESULT Temphr = m_pScanAPI->FakeScanner_Scan(SCAN_END, NULL, 0, NULL);
    if (FAILED(Temphr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, Ending a scanning session failed"));
        hr = Temphr;
    }

    //
    // free down sampled, temporary buffer
    //

    if(DownSampleInfo.pDestBuffer){
        CoTaskMemFree(DownSampleInfo.pDestBuffer);
        DownSampleInfo.pDestBuffer = NULL;
    }

    return hr;
}

/**************************************************************************\
* ScanItemCB
*
*   This helper is called to do a MEMORY transfer.
*   Note: This routine must fill buffers, adjust the buffer offset and
*         return percent complete status back to the client via a callback
*         routine. (a callback interface must be supplied by the caller for
*         this routine to function).
*
* Arguments:
*
*   pItemContext    - private item data
*   pmdtc           - buffer and callback information
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::ScanItemCB(
    PMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::ScanItemCB");
    HRESULT hr = S_OK;

    LONG  lScanPhase   = SCAN_START;
    DWORD cbWritten    = 0;
    LONG  cbSize       = 0;
    LONG  lItemSize    = pmdtc->lHeaderSize;
    BOOL  bSwapBGRData = TRUE;
    BOOL  bDWORDAlign  = TRUE;
    pmdtc->cbOffset    = 0;
    LONG  lTotalLinesWritten = 0;
    LONG  cbEstimatedPageSize = (pItemContext->lBytesPerScanLine * (pmdtc->lYRes * EST_PAGE_LENGTH_INCHES));
    BOOL  bIncludeHeaderData = TRUE;
    //
    //  This must be a callback transfer request
    //

    if ((pmdtc->pIWiaMiniDrvCallBack == NULL) ||
        (!pmdtc->bTransferDataCB)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, invalid callback params"));
        return E_INVALIDARG;
    }

    //
    //  SEND HEADER to client
    //

    hr = SendImageHeader(pmdtc);
    if(hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, SendImageHeader failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // scan until buffer runs out or scanner completes transfer
    //

    while ((lScanPhase == SCAN_START) || (cbWritten)) {

        PBYTE pBuf         = pmdtc->pTransferBuffer;

        //
        // Limit requests to max buffer size or less.
        //

        cbSize = m_MaxBufferSize;

        //
        // Request size to scanner must be modula the raw bytes per scan row.
        // Enough space for the alignment padding must be reserved.
        // These are requirements for AlignInPlace
        //

        cbSize = (cbSize / pItemContext->lBytesPerScanLine) * pItemContext->lBytesPerScanLineRaw;

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  lScanPhase indicates whether this is the first call to Scan,
        //  pBuf is a pointer to the buffer, cbSize is the amount of data
        //  requested from the scanner, and cbWritten will be set to the actual
        //  amount of data returned by the scanner.
        //

        hr = m_pScanAPI->FakeScanner_Scan(lScanPhase, pBuf, cbSize, &cbWritten);

        //
        // set flag to SCAN_CONTINUE, for other calls
        //

        lScanPhase = SCAN_CONTINUE;

        if (hr == S_OK) {
            if (cbWritten) {

                //
                // keep track of how many lines were written
                //

                lTotalLinesWritten += (cbWritten / pItemContext->lBytesPerScanLine);

                //
                // Place the scan data in correct byte order for 3 bytes ber pixel data.
                //

                if ((pmdtc->lDepth == 24) &&
                   ((pmdtc->guidFormatID == WiaImgFmt_BMP) ||
                   ((pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP)))) {

                     //
                     // swap data if needed
                     //

                     if(bSwapBGRData) {
                         SwapBuffer24(pBuf, cbWritten);
                     }
                }

                if (bDWORDAlign) {

                    //
                    // Align the data on DWORD boundries.
                    //

                    cbWritten = AlignInPlace(pBuf,
                                             cbWritten,
                                             pItemContext->lBytesPerScanLine,
                                             pItemContext->lBytesPerScanLineRaw);
                }

                //
                // decrease estimated page size, for (estimated percent complete calculation)
                //

                cbEstimatedPageSize -= cbWritten;

                //
                // update cbWritten to account for the image data header (if one exists), on first callback
                //

                if(bIncludeHeaderData){
                    cbWritten += lItemSize;
                    bIncludeHeaderData = FALSE;
                } else {

                    //
                    // update data offset (data written so far, from the start of the data buffer, (including image headers))
                    //

                    pmdtc->cbOffset += cbWritten;
                }

                //
                // avoid division by zero, by setting cbEstimatedPageSize to 1
                //

                if(cbEstimatedPageSize < 0){
                    cbEstimatedPageSize = 1;
                }

                //
                // If a status callback was specified callback the class driver.
                // There has to be a callback provided, this is the callback
                // transfer.
                //

                if (pmdtc->pIWiaMiniDrvCallBack) {

                    FLOAT FractionComplete = 0.0f;
                    LONG  PercentComplete  = 0;

                    FractionComplete = (FLOAT)(lTotalLinesWritten * pItemContext->lBytesPerScanLineRaw) / (FLOAT)cbEstimatedPageSize;
                    if (FractionComplete > 0.9f) {
                        FractionComplete = 0.9f; // hold at 90% complete...until done
                    }

                    //
                    // calculate percent complete
                    //

                    PercentComplete = (LONG)(100 * FractionComplete);

                    //
                    // call back client with status on the transfer and data offset
                    //

                    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                                      PercentComplete,
                                                                      pmdtc->cbOffset,
                                                                      cbWritten,
                                                                      pmdtc,
                                                                      0);
                    //
                    // check for user cancel
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItemCB, Transfer canceled by client (IT_MSG_DATA callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItemCB, MiniDrvCallback failed (IT_MSG_DATA callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }
                }
            }

        } else {

            //
            //  Get the device error
            //

            *plDevErrVal = (LONG) hr;
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItemCB, data transfer failed, status: 0x%X", hr));
            break;
        }
    }

    if (S_OK == hr) {

        //
        // call back client with status on the transfer
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100, // 100 percent complete!
                                                          0,
                                                          0,
                                                          NULL,
                                                          0);

        if (S_OK == hr) {

            //
            // Since we are out of data.. we should send the WIA_STATUS_END_OF_MEDIA
            //

            hr = WIA_STATUS_END_OF_MEDIA;
        }
    }

    //
    // end the scan
    //

    HRESULT Temphr = m_pScanAPI->FakeScanner_Scan(SCAN_END, NULL, 0, NULL);
    if(FAILED(Temphr)){
        WIAS_LERROR(m_pIWiaLog,
                    WIALOG_NO_RESOURCE_ID,
                    ("ScanItemCB, Ending a scanning session failed"));
        return Temphr;
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvAcquireItemData
*
*   This driver entry point is called when image data is requested from the
*   device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   pmdtc           - Pointer to mini driver context. On entry, only the
*                     portion of the mini driver context which is derived
*                     from the item properties is filled in.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvAcquireItemData");
    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetDrvItem() failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // Validate the data transfer context.
    //

    hr = ValidateDataTransferContext(pmdtc);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ValidateDataTransferContext() failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    //  Get item specific driver data
    //

    PMINIDRIVERITEMCONTEXT  pItemContext = NULL;

    hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, NULL item context"));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // for compressed data, unknown page lengths..or multipage transfers, the mini driver does not know the
    // size of the image, so a temporary buffer needs to be maintained by the WIA
    // minidriver.
    //

    if (!pmdtc->bClassDrvAllocBuf) {

        LONG lClassDrvAllocSize = pItemContext->lHeaderSize + m_MaxBufferSize; // header + max buffer band size
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, lHeaderSize = %d",pItemContext->lHeaderSize));
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Attempting to Allocate (%d)bytes for pmdtc->pTransferBuffer",lClassDrvAllocSize));

        pmdtc->pTransferBuffer = (PBYTE) CoTaskMemAlloc(lClassDrvAllocSize);
        if (!pmdtc->pTransferBuffer) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, unable to allocate temp transfer buffer, size: %d",(pmdtc->lImageSize + pmdtc->lHeaderSize)));
            return E_OUTOFMEMORY;
        }

        //
        // set new buffer size
        //

        pmdtc->lBufferSize = lClassDrvAllocSize;
    }

    //
    //  Use WIA services to fetch format specific info.  This information
    //  is based on the property settings.
    //

    hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);

    if (hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetImageInformation failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // Get number of pages requested, for ADF scanning loop
    //

    BOOL bEmptyTheADF = FALSE;
    LONG lPagesRequested = GetPageCount(pWiasContext);
    if (lPagesRequested == 0) {
        bEmptyTheADF    = TRUE;
        lPagesRequested = 1;// set to 1 so we can enter our loop
                            // WIA_ERROR_PAPER_EMPTY will terminate
                            // the loop...or an error, or a cancel..
                            //
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages to Scan = %d",lPagesRequested));

    if (m_bADFEnabled) { // FEEDER is enabled for scanning

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Feeder is enabled for use"));

        //
        // clear an potential paper that may be blocking the
        // scan pathway.
        //

        hr = m_pScanAPI->FakeScanner_ADFUnFeedPage();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (begin transfer) Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

    } else {            // FLATBED is enabled for scanning

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Feeder is disabled or no feeder exists"));

        //
        // Transfer only a single image
        //

        bEmptyTheADF    = FALSE;
        lPagesRequested = 1;
    }

    //
    // WIA document scanning loop
    //

    LONG lPagesScanned      = 0;        // number of pages currently scanned
    BOOL bCallBackTransfer  = FALSE;    // callback transfer flag
    while (lPagesRequested > 0) {

        if (m_bADFEnabled) {

            //
            // Check feeder for paper
            //

            hr = m_pScanAPI->FakeScanner_ADFHasPaper();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFHasPaper Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // Attempt to load a page (only if needed)
            //

            hr = m_pScanAPI->FakeScanner_ADFFeedPage();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFFeedPage Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // Check feeder's status
            //

            hr = m_pScanAPI->FakeScanner_ADFStatus();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFStatus Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }
        }

        //
        // update image information
        //

        hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetImageInformation Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);

            //
            // free any allocated memory
            //

            if (!pmdtc->bClassDrvAllocBuf) {
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (entire scan operation complete)"));
                if (NULL != pmdtc->pTransferBuffer) {
                    CoTaskMemFree(pmdtc->pTransferBuffer);
                    pmdtc->pTransferBuffer = NULL;
                }
            }
            return hr;
        }

        //
        //  Determine if this is a callback or file transfer.
        //

        if (pmdtc->tymed == TYMED_CALLBACK) {

            //
            // Scan the page to memory
            //

            bCallBackTransfer = TRUE;

            hr = ScanItemCB(pItemContext,
                            pmdtc,
                            plDevErrVal);

        } else {

            //
            // Scan the page to file
            //

            hr = ScanItem(pItemContext,
                          pmdtc,
                          plDevErrVal);

        }

        if (!bEmptyTheADF) {

            //
            // update pages requested counter
            //

            lPagesRequested--;
        }

        if (hr == S_FALSE) {

            //
            // user canceled the scan
            //

            lPagesRequested = 0; // set pages to 0 to cleanly exit loop
        }

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages left to scan = %d",lPagesRequested));

        if (m_bADFEnabled) {

            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Unloading a page from the feeder"));

            //
            // Attempt to unload the scanned page (only if needed)
            //

            hr = m_pScanAPI->FakeScanner_ADFUnFeedPage();
            if (SUCCEEDED(hr)) {
                if (bCallBackTransfer) {

                    //
                    // send the NEW_PAGE message, when scanning multiple pages
                    // in callback mode.  This will let the calling application
                    // know when an end-of-page has been hit.
                    //

                    hr = wiasSendEndOfPage(pWiasContext, lPagesScanned, pmdtc);
                    if (FAILED(hr)) {
                        lPagesRequested = 0;
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasSendEndOfPage Failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }

                    //
                    // increment pages scanned counter
                    //

                    lPagesScanned++;
                }
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (end transfer) Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }
        }

        /*
        //
        // free any allocated memory between scans to avoid memory leaks
        //

        if (!pmdtc->bClassDrvAllocBuf) {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (single scan operation complete)"));
            if (NULL != pmdtc->pTransferBuffer) {
                CoTaskMemFree(pmdtc->pTransferBuffer);
                pmdtc->pTransferBuffer = NULL;
            }
        }
        */
    }

    //
    // we are now finished scanning all documents
    //

    if (!pmdtc->bClassDrvAllocBuf) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (entire scan operation complete)"));
        if (NULL != pmdtc->pTransferBuffer) {
            CoTaskMemFree(pmdtc->pTransferBuffer);
            pmdtc->pTransferBuffer = NULL;
        }
    }

    return hr;
}

/**************************************************************************\
* IsPreviewScan
*
*   Get the current preview setting from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    TRUE - Preview is set, FALSE - Final is set
*
* History:
*
*    8/10/2000 Original Version
*
\**************************************************************************/

BOOL CWIAScannerDevice::IsPreviewScan(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::IsPreviewScan");
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, No Preview Property Found on ROOT item!"));
        return FALSE;
    }

    //
    //  Get the current preview setting.
    //

    LONG lPreview = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PREVIEW, &lPreview, NULL, true);
    if (hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, Failed to read Preview Property."));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return FALSE;
    }

    return (lPreview > 0);
}

/**************************************************************************\
* GetPageCount
*
*   Get the requested number of pages to scan from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    Number of pages to scan.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

LONG CWIAScannerDevice::GetPageCount(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetPageCount");
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return 1;
    }

    //
    //  Get the requested page count.
    //

    LONG lPagesRequested = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PAGES, &lPagesRequested, NULL, true);
    if (hr != S_OK) {
        return 1;
    }

    return lPagesRequested;
}

/**************************************************************************\
* SetItemSize
*
*   Calulate the new item size, and write the new Item Size property value.
*
* Arguments:
*
*   pWiasContext       - item
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SetItemSize(
    BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SetItemSize");
    HRESULT  hr = S_OK;
    LONG lWidthInBytes = 0;
    LONG lMinBufSize   = 0;
    GUID guidFormatID  = GUID_NULL;
    MINIDRV_TRANSFER_CONTEXT mdtc;

    LONG lNumProperties = 3;
    PROPVARIANT pv[3];
    PROPSPEC ps[3] = {{PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
                      {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
                      {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE}};

    //
    //  Clear the MiniDrvTransferContext
    //

    memset(&mdtc,0,sizeof(MINIDRV_TRANSFER_CONTEXT));

    //
    // read format GUID
    //

    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &guidFormatID, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_FORMAT error"));
        return hr;
    }

    //
    // read TYMED
    //

    hr = wiasReadPropLong(pWiasContext,WIA_IPA_TYMED, (LONG*)&mdtc.tymed, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_TYMED error"));
        return hr;
    }

    //
    // wias works for DIB, or uncompressed standard TIFF formats
    // Standard TIFFs are constructed using a DIB-like implementation.
    // The data is stored as one huge strip, rather than multiple smaller
    // strips.
    //

    hr = wiasGetImageInformation(pWiasContext, WIAS_INIT_CONTEXT, &mdtc);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, could not get image information"));
        return hr;
    }

    //
    // we want our driver to allocate the memory for our transfer bands,
    // and control the writing of them. To do this, Set item size to 0
    //

    mdtc.lItemSize = 0;

    //
    //  Set the MinBufferSize property.  MinBufferSize is the minimum buffer
    //  that a client can request for a data transfer.
    //

    switch (mdtc.tymed) {
    case TYMED_CALLBACK:

        //
        // callback uses driver's minimum buffer size.
        // This is could be taken from the driver at
        // initialization time.
        //

        lMinBufSize = m_MinBufferSize;
        break;

    case TYMED_FILE:

        //
        // file transfers, require that the minimum buffer size be the
        // entire length of the file.
        //

        lMinBufSize = m_MinBufferSize;//mdtc.lImageSize + mdtc.lHeaderSize;
        break;

    default:

        //
        // unknown TYMED
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, unknown tymed: 0x%08X", mdtc.tymed));
        return E_INVALIDARG;
    }

    //
    //  Initialize propvar's.  Then write the values.  Don't need to call
    //  PropVariantClear when done, since there are only LONG values.
    //

    for (int i = 0; i < lNumProperties; i++) {
        PropVariantInit(&pv[i]);
        pv[i].vt = VT_I4;
    }

    pv[0].lVal = mdtc.lItemSize;
    pv[1].lVal = mdtc.cbWidthInBytes;
    pv[2].lVal = lMinBufSize;

    //
    // Write WIA_IPA_ITEM_SIZE, WIA_IPA_BYTES_PER_LINE, and  WIA_IPA_MIN_BUFFER_SIZE
    // property values
    //

    hr = wiasWriteMultiple(pWiasContext, lNumProperties, ps, pv);
    if (SUCCEEDED(hr)) {

        //
        // Now update the MINIDRIVER TRANSFER CONTEXT with new values
        //

        //
        // Get a pointer to the associated driver item.
        //

        IWiaDrvItem* pDrvItem = NULL;

        hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
        if (FAILED(hr)) {
            return hr;
        }

        //
        // Get driver item's context
        //

        PMINIDRIVERITEMCONTEXT pItemContext = NULL;

        hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

        if (SUCCEEDED(hr)) {

            //
            // Calculate how many scan lines will fit in the buffer.
            //

            pItemContext->lBytesPerScanLineRaw = ((mdtc.lWidthInPixels * mdtc.lDepth) + 7)  / 8;
            pItemContext->lBytesPerScanLine    = (((mdtc.lWidthInPixels * mdtc.lDepth) + 31) / 8) & 0xfffffffc;
            pItemContext->lTotalRequested      = 0;// we don't know the image size
            pItemContext->lImageSize           = 0;// we don't know the image size
            pItemContext->lHeaderSize          = mdtc.lHeaderSize;

        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvWriteItemProperties, NULL item context"));
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, WriteMultiple failed"));
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvInitItemProperties
*
*   Initialize the device item properties. Called during item
*   initialization.  This is called by the WIA Class driver
*   after the item tree has been built.  It is called once for every
*   item in the tree.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA context (item information).
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvInitItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvInitItemProperties");
    HRESULT hr = S_OK;

    //
    //  This device doesn't touch hardware to initialize the device item
    //  properties, so set plDevErrVal to 0.
    //

    *plDevErrVal = 0;

    //
    //  Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasGetDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Set initial item properties.
    //

    LONG    lItemType = 0;

    pDrvItem->GetItemFlags(&lItemType);

    if (lItemType & WiaItemTypeRoot) {

        //
        //  This is for the root item.
        //

        //
        // Build Root Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildRootItemProperties();

        if(FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildRootItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Add the device specific root item property names,
        //  using WIA service.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_NumRootItemProperties,
                                  m_piRootItemDefaults,
                                  m_pszRootItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_piRootItemDefaults   = %x",m_piRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszRootItemDefaults  = %x",m_pszRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Set the device specific root item properties to
        //  their default values using WIA service.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_NumRootItemProperties,
                               m_psRootItemDefaults,
                               m_pvRootItemDefaults);
        //
        // Free PROPVARIANT array, This frees any memory that was allocated for a prop variant value.
        //

        // FreePropVariantArray(m_NumRootItemProperties,m_pvRootItemDefaults);


        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszRootItemDefaults  = %x",m_pszRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pvRootItemDefaults   = %x",m_pvRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_NumRootItemProperties,
                                     m_psRootItemDefaults,
                                     m_wpiRootItemDefaults);

        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_psRootItemDefaults   = %x",m_psRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_wpiRootItemDefaults  = %x",m_wpiRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteRootItemProperties();
    } else {

        //
        //  This is for the child item.(Top)
        //

        //
        // Build Top Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildTopItemProperties();

        if(FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildTopItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use the WIA service to set the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_NumItemProperties,
                                  m_piItemDefaults,
                                  m_pszItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_piItemDefaults   = %x",m_piItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszItemDefaults  = %x",m_pszItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the item properties to their default
        //  values.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_NumItemProperties,
                               m_psItemDefaults,
                               (PROPVARIANT*)m_pvItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszItemDefaults  = %x",m_pszItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pvItemDefaults   = %x",m_pvItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_NumItemProperties,
                                     m_psItemDefaults,
                                     m_wpiItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_psItemDefaults   = %x",m_psItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_wpiItemDefaults  = %x",m_wpiItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Set item size properties.
        //

        hr = SetItemSize(pWiasContext);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, SetItemSize failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteTopItemProperties();
    }
    return hr;
}


/**************************************************************************\
* CWIAScannerDevice::drvValidateItemProperties
*
*   Validate the device item properties.  It is called when changes are made
*   to an item's properties.  Driver should not only check that the values
*   are valid, but must update any valid values that may change as a result.
*   If an a property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   nPropSpec       - The number of properties that are being written
*   pPropSpec       - An array of PropSpecs identifying the properties that
*                     are being written.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
***************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvValidateItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvValidateItemProperties");

    HRESULT hr      = S_OK;
    LONG lItemType  = 0;
    WIA_PROPERTY_CONTEXT Context;

    *plDevErrVal = 0;

    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (SUCCEEDED(hr)) {
        if (lItemType & WiaItemTypeRoot) {

            //
            //  Validate root item
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                // Check ADF to see if the status settings need to be updated
                // Also switch between FEEDER/FLATBED modes
                //

                hr = CheckADFStatus(pWiasContext, &Context);
                if(FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckADFStatus failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // check Preview Property only if validation is successful so far....
                //

                if (SUCCEEDED(hr)) {

                    //
                    // Check Preview property to see if the settings are valid
                    //

                    hr = CheckPreview(pWiasContext, &Context);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreview failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }

                    //
                    // call WIA service helper to validate other properties
                    //

                    if (SUCCEEDED(hr)) {
                        hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    }
                }
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Root Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

        } else {

            //
            // validate item properties here
            //

            //
            //  Create a property context needed by some WIA Service
            //  functions used below.
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                //  Check Current Intent first
                //

                hr = CheckIntent(pWiasContext, &Context);
                if (SUCCEEDED(hr)) {

                    //
                    //  Check if DataType is being written
                    //

                    hr = CheckDataType(pWiasContext, &Context);
                    if (SUCCEEDED(hr)) {

                        //
                        //  update the extent properties and valid values.
                        //

                        LONG lBedWidth  = 0;
                        LONG lBedHeight = 0;
                        hr = m_pScanAPI->FakeScanner_GetBedWidthAndHeight(&lBedWidth,&lBedHeight);
                        if(FAILED(hr)){
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, FakeScanner_GetBedWidthAndHeight failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                            return hr;
                        }

                        hr = CheckXExtent(pWiasContext,&Context,lBedWidth);

                        if (SUCCEEDED(hr)) {

                            //
                            //  Use the WIA Service to update the valid values
                            //  for Format.  These are based on the value of
                            //  WIA_IPA_TYMED, so validation is also performed
                            //  on the tymed property by the service.
                            //

                            hr = wiasUpdateValidFormat(pWiasContext,
                                                       &Context,
                                                       (IWiaMiniDrv*) this);

                            if (SUCCEEDED(hr)) {

                                //
                                // Check Preferred format
                                //

                                hr = CheckPreferredFormat(pWiasContext, &Context);
                                if(FAILED(hr)){
                                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreferredFormat failed"));
                                    WIAS_LHRESULT(m_pIWiaLog, hr);
                                }
                            } else {
                                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateValidFormat failed"));
                                WIAS_LHRESULT(m_pIWiaLog, hr);
                            }
                        } else {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateScanRect failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckDataType failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckIntent failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
                wiasFreePropContext(&Context);
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Child Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            //  Update the item size
            //

            if (SUCCEEDED(hr)) {
                hr = SetItemSize(pWiasContext);
                if(FAILED(hr)){
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }

            //
            // call WIA service helper to validate other properties
            //

            if (SUCCEEDED(hr)) {
                hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                if(FAILED(hr)){
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    //
    // log HRESULT sent back to caller
    //

    if(FAILED(hr)){
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.  This is called by the
*   WIA Class driver prior to drvAcquireItemData when the client requests
*   a data transfer.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvWriteItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvWriteItemProperties");
    HRESULT hr = S_OK;
    *plDevErrVal = 0;
    LONG lNumProperties = 9;
    PROPVARIANT pv[9];
    PROPSPEC ps[9] = {
        {PRSPEC_PROPID, WIA_IPS_XRES},
        {PRSPEC_PROPID, WIA_IPS_YRES},
        {PRSPEC_PROPID, WIA_IPS_XPOS},
        {PRSPEC_PROPID, WIA_IPS_YPOS},
        {PRSPEC_PROPID, WIA_IPS_XEXTENT},
        {PRSPEC_PROPID, WIA_IPS_YEXTENT},
        {PRSPEC_PROPID, WIA_IPA_DATATYPE},
        {PRSPEC_PROPID, WIA_IPS_BRIGHTNESS},
        {PRSPEC_PROPID, WIA_IPS_CONTRAST}
    };

    //
    // initialize propvariant structures
    //

    for (int i = 0; i< lNumProperties;i++) {
        pv[i].vt = VT_I4;
    }

    //
    // read child item properties
    //

    hr = wiasReadMultiple(pWiasContext, lNumProperties, ps, pv, NULL);

    if (hr == S_OK) {

        hr = m_pScanAPI->FakeScanner_SetXYResolution(pv[0].lVal,pv[1].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting x any y resolutions failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetDataType(pv[6].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting data type failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetIntensity(pv[7].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting intensity failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetContrast(pv[8].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting contrast failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetSelectionArea(pv[2].lVal, pv[3].lVal, pv[4].lVal, pv[5].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting selection area (extents) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvReadItemProperties
*
*   Read the device item properties.  When a client application tries to
*   read a WIA Item's properties, the WIA Class driver will first notify
*   the driver by calling this method.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvReadItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvReadItemProperties");
    *plDevErrVal = 0;
    return S_OK;
}

/**************************************************************************\
* CWIAScannerDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->LockDevice(m_dwLockTimeout);
}

/**************************************************************************\
* CWIAScannerDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvUnLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvUnLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWIAScannerDevice::drvAnalyzeItem
*
*   This device does not support image analysis, so return E_NOTIMPL.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvAnalyzeItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvAnalyzeItem");
    *plDevErrVal = 0;
    return E_NOTIMPL;
}

/**************************************************************************\
* CWIAScannerDevice::drvFreeDrvItemContext
*
*   Free any device specific context.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvFreeDrvItemContext(
    LONG                        lFlags,
    BYTE                        *pSpecContext,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvFreeDrvItemContext");
    *plDevErrVal = 0;
    PMINIDRIVERITEMCONTEXT pContext = NULL;
    pContext = (PMINIDRIVERITEMCONTEXT) pSpecContext;

    if (pContext){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvFreeDrvItemContext, Freeing my allocated context members"));
    }

    return S_OK;
}

/**************************************************************************\
* CWIAScannerDevice::drvInitializeWia
*
*   Initialize the WIA mini driver.  This will build up the driver item tree
*   and perform any other initialization code that's needed for WIA.
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvInitializeWia(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    BSTR                        bstrDeviceID,
    BSTR                        bstrRootFullItemName,
    IUnknown                    *pStiDevice,
    IUnknown                    *pIUnknownOuter,
    IWiaDrvItem                 **ppIDrvItemRoot,
    IUnknown                    **ppIUnknownInner,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvInitializeWia");
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrDeviceID         = %ws", bstrDeviceID));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrRootFullItemName = %ws",bstrRootFullItemName));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, lFlags               = %d",lFlags));
    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;

    //
    //  Need to init names and STI pointer?
    //

    if (m_pStiDevice == NULL) {

        //
        // save STI device interface for locking
        //

        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID.
        //

        m_bstrDeviceID = SysAllocString(bstrDeviceID);

        if (!m_bstrDeviceID) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate device ID string"));
            return E_OUTOFMEMORY;
        }

        //
        // Cache the root property stream name.
        //

        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (!m_bstrRootFullItemName) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate prop stream name"));
            return E_OUTOFMEMORY;
        }
    }

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize SupportedFormats array
    //

    hr = BuildSupportedFormats();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Data Type array
    //

    hr = BuildSupportedDataTypes();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedDataTypes failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Intents array
    //

    hr = BuildSupportedIntents();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedIntents failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported TYMED array
    //

    hr = BuildSupportedTYMED();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSuportedTYMED failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported compression types array
    //

    hr = BuildSupportedCompressions();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedCompressions"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported Preview modes array
    //

    hr = BuildSupportedPreviewModes();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedPreviewModes"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  initial formats array
    //

    hr = BuildInitialFormats();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildInitialFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize supported resolutions array
    //

    hr = BuildSupportedResolutions();
    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedResolutions failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Build the device item tree, if it hasn't been built yet.
    //
    //  Send a Device Command to yourself, or Call BuildItemTree manually
    //

    if (!m_pIDrvItemRoot) {
        LONG    lDevErrVal = 0;
        hr = drvDeviceCommand(NULL, 0, &WIA_CMD_SYNCHRONIZE, NULL, &lDevErrVal);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, drvDeviceCommand(WIA_CMD_SYNCHRONIZE) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
    }

    //
    // save root item pointer. (REMEMBER TO RELEASE THIS INTERFACE)
    //

    *ppIDrvItemRoot = m_pIDrvItemRoot;

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
* Return Value:
*    Status
*
* History:
*
*   7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvUnInitializeWia(
    BYTE                *pWiasContext)
{
    return S_OK;
}


/**************************************************************************\
* drvGetDeviceErrorStr
*
*   Map a device error value to a string.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetDeviceErrorStr(
    LONG                        lFlags,
    LONG                        lDevErrVal,
    LPOLESTR                    *ppszDevErrStr,
    LONG                        *plDevErr)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetDeviceErrorStr");
    HRESULT hr = S_OK;

    //
    //  Map device errors to a string to be placed in the event log.
    //

    //
    // look up error strings in resource file.
    //

    switch (lDevErrVal) {
        case 0:
            *ppszDevErrStr = L"No Error";                   // hard coded for now
            *plDevErr  = 0;
            hr = S_OK;
            break;
        default:
            *ppszDevErrStr = L"Device Error, Unknown Error";// hard coded for now
            *plDevErr  = 0;
            hr = E_FAIL;
            break;
    }
    return hr;
}

/**************************************************************************\
* drvDeviceCommand
*
*   Issue a command to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   plCommand       - Pointer to command GUID.
*   ppWiaDrvItem    - Optional pointer to returned item, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvDeviceCommand(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    const GUID                  *plCommand,
    IWiaDrvItem                 **ppWiaDrvItem,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvDeviceCommand");
    *plDevErrVal = 0;
    HRESULT hr = S_OK;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        //
        // SYNCHRONIZE - Build the minidriver representation of
        //               the current item list, if it doesn't exist.
        //

        if (!m_pIDrvItemRoot) {
            hr = BuildItemTree();
        } else {
            hr = S_OK;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, unknown command sent to this device"));
        hr = E_NOTIMPL;
    }

    return hr;
}


/**************************************************************************\
* CWIAScannerDevice::drvGetCapabilities
*
*   Get supported device commands and events as an array of WIA_DEV_CAPS.
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned GUID array.
*   ppCapabilities - Pointer to returned GUID array.
*   plDevErrVal    - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetCapabilities(
    BYTE                        *pWiasContext,
    LONG                        ulFlags,
    LONG                        *pcelt,
    WIA_DEV_CAP_DRV             **ppCapabilities,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetCapabilites");
    *plDevErrVal = 0;

    HRESULT hr = S_OK;

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Return depends on flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    //

    switch (ulFlags) {
    case WIA_DEVICE_COMMANDS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS)"));

        //
        //  report commands only
        //

        *pcelt          = m_NumSupportedCommands;
        *ppCapabilities = &m_pCapabilities[m_NumSupportedEvents];
        break;
    case WIA_DEVICE_EVENTS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_EVENTS)"));

        //
        //  report events only
        //

        *pcelt          = m_NumSupportedEvents;
        *ppCapabilities = m_pCapabilities;
        break;
    case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS|WIA_DEVICE_EVENTS)"));

        //
        //  report both events and commands
        //

        *pcelt          = m_NumCapabilities;
        *ppCapabilities = m_pCapabilities;
        break;
    default:

        //
        //  invalid request
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, invalid flags"));
        return E_INVALIDARG;
    }
    return hr;
}

/**************************************************************************\
* drvGetWiaFormatInfo
*
*   Returns an array of WIA_FORMAT_INFO structs, which specify the format
*   and media type pairs that are supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*   7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetWiaFormatInfo");

    HRESULT hr = S_OK;

    if(NULL == m_pSupportedFormats){
        hr = BuildSupportedFormats();
    }

    *plDevErrVal = 0;
    *pcelt       = m_NumSupportedFormats;
    *ppwfi       = m_pSupportedFormats;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_NumSupportedFormats = %d",m_NumSupportedFormats));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_pSupportedFormats   = %x",m_pSupportedFormats));
    return hr;
}

/**************************************************************************\
* drvNotifyPnpEvent
*
*   Pnp Event received by device manager.  This is called when a Pnp event
*   is received for this device.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvNotifyPnpEvent(
    const GUID                  *pEventGUID,
    BSTR                        bstrDeviceID,
    ULONG                       ulReserved)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DrvNotifyPnpEvent");
    HRESULT hr = S_OK;

    if (*pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (WIA_EVENT_DEVICE_DISCONNECTED)"));
        hr = m_pScanAPI->FakeScanner_DisableDevice();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, disable failed"));
        }
    }

    return hr;
}


/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* AlignInPlace
*
*   DWORD align a data buffer in place.
*
* Arguments:
*
*   pBuffer              - Pointer to the data buffer.
*   cbWritten            - Size of the data in bytes.
*   lBytesPerScanLine    - Number of bytes per scan line in the output data.
*   lBytesPerScanLineRaw - Number of bytes per scan line in the input data.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

UINT CWIAScannerDevice::AlignInPlace(
   PBYTE pBuffer,
   LONG  cbWritten,
   LONG  lBytesPerScanLine,
   LONG  lBytesPerScanLineRaw)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::AlignInPlace");
    if (lBytesPerScanLineRaw % 4) {

      UINT  uiPadBytes          = lBytesPerScanLine - lBytesPerScanLineRaw;
      UINT  uiDevLinesWritten   = cbWritten / lBytesPerScanLineRaw;

      PBYTE pSrc = pBuffer + cbWritten - 1;
      PBYTE pDst = pBuffer + (uiDevLinesWritten * lBytesPerScanLine) - 1;

      while (pSrc >= pBuffer) {
         pDst -= uiPadBytes;

         for (LONG i = 0; i < lBytesPerScanLineRaw; i++) {
            *pDst-- = *pSrc--;
         }
      }
      return uiDevLinesWritten * lBytesPerScanLine;
   }
   return cbWritten;
}

/**************************************************************************\
* UnlinkItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::DeleteItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::DeleteItemTree");
    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, no tree to delete..."));
        return S_OK;
    }

    //
    //  Call device manager to unlink the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    if (SUCCEEDED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, m_pIDrvItemRoot is being released!!"));
        m_pIDrvItemRoot->Release();
        m_pIDrvItemRoot = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildItemTree
*
*   The device uses the WIA Service functions to build up a tree of
*   device items. This device supports only a single data acquisition item so
*   build a device item tree with only one child off the root.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::BuildItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::BuildItemTree");
    //
    //  The device item tree must not exist.
    //

    WIAS_ASSERT( (g_hInst), (m_pIDrvItemRoot == NULL));

    //
    //  Call the class driver to create the root item.
    //

    HRESULT hr = E_FAIL;

    //
    //  Name the root.
    //

    BSTR bstrRootItemName = NULL;
    hr = GetBSTRResourceString(IDS_ROOTITEM_NAME,&bstrRootItemName,TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasCreateDrvItem(WiaItemTypeFolder |
                               WiaItemTypeDevice |
                               WiaItemTypeRoot,
                               bstrRootItemName,
                               m_bstrRootFullItemName,
                               (IWiaMiniDrv *)this,
                               sizeof(MINIDRIVERITEMCONTEXT),
                               NULL,
                               &m_pIDrvItemRoot);

        SysFreeString(bstrRootItemName);
    }

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Create and add the Top/Front and Bottom/Back device items.
    //

    for (INT i = 0; i < NUM_DEVICE_ITEM; i++) {

        //
        //  Build the item names.
        //

        BSTR bstrItemName = NULL;
        hr = GetBSTRResourceString(IDS_TOPITEM_NAME,&bstrItemName,TRUE);
        if (SUCCEEDED(hr)) {

            // SBB - RAID 370299 - orenr - 2001/04/18 - Security fix -
            // potential buffer overrun.  Changed wcscpy and wcscat
            // to use _snwprintf instead

            WCHAR  szFullItemName[MAX_PATH + 1] = {0};
            _snwprintf(szFullItemName,
                       (sizeof(szFullItemName) / sizeof(WCHAR)) - 1,
                       L"%ls\\%ls",
                       m_bstrRootFullItemName,
                       bstrItemName);

            //
            //  Call the class driver to create another driver item.
            //  This will be inserted as the child item.
            //

            PMINIDRIVERITEMCONTEXT pItemContext;
            IWiaDrvItem           *pItem = NULL;
            BSTR                  bstrFullItemName = SysAllocString(szFullItemName);
            if(bstrFullItemName) {
                hr = wiasCreateDrvItem(WiaItemTypeFile  |
                                       WiaItemTypeImage |
                                       WiaItemTypeDevice,
                                       bstrItemName,
                                       bstrFullItemName,
                                       (IWiaMiniDrv *)this,
                                       sizeof(MINIDRIVERITEMCONTEXT),
                                       (PBYTE*) &pItemContext,
                                       &pItem);
                SysFreeString(bstrFullItemName);
                bstrFullItemName = NULL;
            } else {

                hr = E_OUTOFMEMORY;

                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, allocation of BSTR for full item name failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }
            if (SUCCEEDED(hr)) {

                //
                // Initialize device specific context.
                //

                memset(pItemContext, 0, sizeof(MINIDRIVERITEMCONTEXT));
                pItemContext->lSize = sizeof(MINIDRIVERITEMCONTEXT);

                //
                //  Call the class driver to add pItem to the folder
                //  m_pIDrvItemRoot (i.e. make pItem a child of
                //  m_pIDrvItemRoot).
                //

                hr = pItem->AddItemToFolder(m_pIDrvItemRoot);

                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, AddItemToFolder failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // release and created items
                //

                pItem->Release();

            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            // free the BSTR allocated by the BSTRResourceString helper
            //

            SysFreeString(bstrItemName);

        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, unable to allocate item name"));
            hr = E_OUTOFMEMORY;
        }

        break;  // Error if here, quit iterating.
    }

    if (FAILED(hr)) {
        DeleteItemTree();
    }
    return hr;
}

/**************************************************************************\
* DeleteRootItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszRootItemDefaults - Property name  array         (LPOLESTR)
*   m_piRootItemDefaults  - Property ID array             (PROPID)
*   m_pvRootItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psRootItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiRootItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteRootItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedPreviewModesArrayContents();

    if(NULL != m_pszRootItemDefaults){
        delete [] m_pszRootItemDefaults;
        m_pszRootItemDefaults = NULL;
    }

    if(NULL != m_piRootItemDefaults){
        delete [] m_piRootItemDefaults;
        m_piRootItemDefaults = NULL;
    }

    if(NULL != m_pvRootItemDefaults){
        FreePropVariantArray(m_NumRootItemProperties,m_pvRootItemDefaults);
        delete [] m_pvRootItemDefaults;
        m_pvRootItemDefaults = NULL;
    }

    if(NULL != m_psRootItemDefaults){
        delete [] m_psRootItemDefaults;
        m_psRootItemDefaults = NULL;
    }

    if(NULL != m_wpiRootItemDefaults){
        delete [] m_wpiRootItemDefaults;
        m_wpiRootItemDefaults = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildRootItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszRootItemDefaults - Property name  array         (LPOLESTR)
*   m_piRootItemDefaults  - Property ID array             (PROPID)
*   m_pvRootItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psRootItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiRootItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildRootItemProperties");

    HRESULT hr = S_OK;
    LONG PropIndex = 0;

    //
    // check for ADF
    //

    if(m_pScanAPI->FakeScanner_ADFAttached() == S_OK){
        m_bADFAttached = TRUE;
    }

    //
    // set the number of properties
    //

    if(m_bADFAttached){
        m_NumRootItemProperties = 16;   // standard properties + ADF specific
    } else {
        m_NumRootItemProperties = 7;    // standard properties only
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildRootItemProperties, Number of Properties = %d",m_NumRootItemProperties));

    m_pszRootItemDefaults   = new LPOLESTR[m_NumRootItemProperties];
    if(NULL != m_pszRootItemDefaults){
        m_piRootItemDefaults    = new PROPID[m_NumRootItemProperties];
        if (NULL != m_piRootItemDefaults) {
            m_pvRootItemDefaults    = new PROPVARIANT[m_NumRootItemProperties];
            if(NULL != m_pvRootItemDefaults){
                m_psRootItemDefaults    = new PROPSPEC[m_NumRootItemProperties];
                if(NULL != m_psRootItemDefaults){
                    m_wpiRootItemDefaults   = new WIA_PROPERTY_INFO[m_NumRootItemProperties];
                    if(NULL == m_wpiRootItemDefaults)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, memory allocation failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

    ROOT_ITEM_INFORMATION RootItemInfo;

    hr = m_pScanAPI->FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, FakeScanner_GetRootPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

    // Intialize WIA_IPA_ACCESS_RIGHTS
    m_pszRootItemDefaults[PropIndex]              = WIA_IPA_ACCESS_RIGHTS_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_IPA_ACCESS_RIGHTS;
    m_pvRootItemDefaults [PropIndex].lVal         = WIA_ITEM_READ|WIA_ITEM_WRITE;
    m_pvRootItemDefaults [PropIndex].vt           = VT_UI4;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_XRES
    m_pszRootItemDefaults[PropIndex]              = WIA_DPS_OPTICAL_XRES_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_DPS_OPTICAL_XRES;
    m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.OpticalXResolution;
    m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_YRES
    m_pszRootItemDefaults[PropIndex]              = WIA_DPS_OPTICAL_YRES_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_DPS_OPTICAL_YRES;
    m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.OpticalYResolution;
    m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_DPA_FIRMWARE_VERSION
    m_pszRootItemDefaults[PropIndex]              = WIA_DPA_FIRMWARE_VERSION_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_DPA_FIRMWARE_VERSION;
    m_pvRootItemDefaults [PropIndex].bstrVal      = SysAllocString(RootItemInfo.FirmwareVersion);
    m_pvRootItemDefaults [PropIndex].vt           = VT_BSTR;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    m_pszRootItemDefaults[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    m_pvRootItemDefaults [PropIndex].lVal         = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;
    m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;
    m_wpiRootItemDefaults[PropIndex].ValidVal.Flag.Nom  = m_pvRootItemDefaults [PropIndex].lVal;
    m_wpiRootItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;

    PropIndex++;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    m_pszRootItemDefaults[PropIndex]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    m_piRootItemDefaults [PropIndex]                    = WIA_DPS_MAX_SCAN_TIME;
    m_pvRootItemDefaults [PropIndex].lVal               = RootItemInfo.MaxScanTime;
    m_pvRootItemDefaults [PropIndex].vt                 = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid             = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt                 = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_PREVIEW (LIST)
    m_pszRootItemDefaults[PropIndex]                    = WIA_DPS_PREVIEW_STR;
    m_piRootItemDefaults [PropIndex]                    = WIA_DPS_PREVIEW;
    m_pvRootItemDefaults [PropIndex].lVal               = WIA_FINAL_SCAN;
    m_pvRootItemDefaults [PropIndex].vt                 = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid             = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiRootItemDefaults[PropIndex].vt                 = m_pvRootItemDefaults [PropIndex].vt;
    m_wpiRootItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)m_pSupportedPreviewModes;
    m_wpiRootItemDefaults[PropIndex].ValidVal.List.Nom  = m_pvRootItemDefaults [PropIndex].lVal;
    m_wpiRootItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedPreviewModes;

    PropIndex++;

    // Initialize WIA_DPS_SHOW_PREVIEW_CONTROL (NONE)
    m_pszRootItemDefaults[PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL_STR;
    m_piRootItemDefaults [PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL;
    m_pvRootItemDefaults [PropIndex].lVal               = WIA_DONT_SHOW_PREVIEW_CONTROL;
    m_pvRootItemDefaults [PropIndex].vt                 = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid             = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt                 = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    //
    // if a Document feeder is attached...add the following properties
    //

    if(m_bADFAttached) {

        // Initialize WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederWidth;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederCaps;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_STATUS
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederStatus;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_SELECT
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT;
        m_pvRootItemDefaults [PropIndex].lVal         = FEEDER;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_FLAG;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Flag.Nom  = m_pvRootItemDefaults [PropIndex].lVal;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Flag.ValidBits = FEEDER | FLATBED;

        PropIndex++;

        // Initialize WIA_DPS_PAGES
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_PAGES_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_PAGES;
        m_pvRootItemDefaults [PropIndex].lVal         = 1;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_RANGE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Range.Min = 0;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Range.Max = RootItemInfo.MaxPageCapacity;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Range.Nom = 1;

        PropIndex++;

        // Initialize WIA_DPS_SHEET_FEEDER_REGISTRATION
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederReg;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_HORIZONTAL_BED_REGISTRATION
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederHReg;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_BED_REGISTRATION
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederVReg;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

    }
    return hr;
}

/**************************************************************************\
* DeleteTopItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszItemDefaults - Property name  array         (LPOLESTR)
*   m_piItemDefaults  - Property ID array             (PROPID)
*   m_pvItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteTopItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteTopItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedFormatsArrayContents();
    DeleteSupportedDataTypesArrayContents();
    DeleteSupportedCompressionsArrayContents();
    DeleteSupportedTYMEDArrayContents();
    DeleteInitialFormatsArrayContents();
    DeleteSupportedResolutionsArrayContents();

    if(NULL != m_pszItemDefaults){
        delete [] m_pszItemDefaults;
        m_pszItemDefaults = NULL;
    }

    if(NULL != m_piItemDefaults){
        delete [] m_piItemDefaults;
        m_piItemDefaults = NULL;
    }

    if(NULL != m_pvItemDefaults){
        for(LONG lPropIndex = 0; lPropIndex < m_NumItemProperties; lPropIndex++){

            //
            // set CLSID pointers to NULL, because we freed the memory above.
            // If this pointer is not NULL FreePropVariantArray would
            // try to free it again.
            //

            if(m_pvItemDefaults[lPropIndex].vt == VT_CLSID){
                m_pvItemDefaults[lPropIndex].puuid = NULL;
            }
        }
        FreePropVariantArray(m_NumItemProperties,m_pvItemDefaults);
        delete [] m_pvItemDefaults;
        m_pvItemDefaults = NULL;
    }

    if(NULL != m_psItemDefaults){
        delete [] m_psItemDefaults;
        m_psItemDefaults = NULL;
    }

    if(NULL != m_wpiItemDefaults){
        delete [] m_wpiItemDefaults;
        m_wpiItemDefaults = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildTopItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
*       [Array Name]        [Description]           [Array Type]
*
*   m_pszItemDefaults - Property name  array         (LPOLESTR)
*   m_piItemDefaults  - Property ID array             (PROPID)
*   m_pvItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildTopItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildTopItemProperties");

    HRESULT hr = S_OK;

    m_NumItemProperties = 27;
    m_pszItemDefaults   = new LPOLESTR[m_NumItemProperties];
    if(NULL != m_pszItemDefaults){
        m_piItemDefaults    = new PROPID[m_NumItemProperties];
        if (NULL != m_piItemDefaults) {
            m_pvItemDefaults    = new PROPVARIANT[m_NumItemProperties];
            if(NULL != m_pvItemDefaults){
                m_psItemDefaults    = new PROPSPEC[m_NumItemProperties];
                if(NULL != m_psItemDefaults){
                    m_wpiItemDefaults   = new WIA_PROPERTY_INFO[m_NumItemProperties];
                    if(NULL == m_wpiItemDefaults)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    if(FAILED(hr)){
        DeleteTopItemProperties();
        return hr;
    }

    ROOT_ITEM_INFORMATION RootItemInfo;
    hr = m_pScanAPI->FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildTopItemProperties, FakeScanner_GetRootPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteTopItemProperties();
        return hr;
    }

    TOP_ITEM_INFORMATION TopItemInfo;
    hr = m_pScanAPI->FakeScanner_GetTopPropertyInfo(&TopItemInfo);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildTopItemProperties, FakeScanner_GetTopPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteTopItemProperties();
        return hr;
    }

    LONG PropIndex = 0;

    if (TopItemInfo.bUseResolutionList) {

        // Intialize WIA_IPS_XRES (LIST)
        m_pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
        m_piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
        m_pvItemDefaults [PropIndex].lVal               = m_pSupportedResolutions[PropIndex];
        m_pvItemDefaults [PropIndex].vt                 = VT_I4;
        m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
        m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
        m_wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)m_pSupportedResolutions;
        m_wpiItemDefaults[PropIndex].ValidVal.List.Nom  = m_pvItemDefaults [PropIndex].lVal;
        m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedResolutions;

        PropIndex++;

        // Intialize WIA_IPS_YRES (LIST)
        m_pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
        m_piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
        m_pvItemDefaults [PropIndex].lVal               = m_pSupportedResolutions[PropIndex-1];
        m_pvItemDefaults [PropIndex].vt                 = VT_I4;
        m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
        m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
        m_wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)m_pSupportedResolutions;
        m_wpiItemDefaults[PropIndex].ValidVal.List.Nom  = m_pvItemDefaults [PropIndex].lVal;
        m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedResolutions;

        PropIndex++;

    } else {
        // we have a range
        // Intialize WIA_IPS_XRES (RANGE)
        m_pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
        m_piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
        m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.XResolution.lNom;
        m_pvItemDefaults [PropIndex].vt                 = VT_I4;
        m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
        m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.XResolution.lInc;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.XResolution.lMin;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.XResolution.lMax;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.XResolution.lNom;

        PropIndex++;

        // Intialize WIA_IPS_YRES (RANGE)
        m_pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
        m_piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
        m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.YResolution.lNom;
        m_pvItemDefaults [PropIndex].vt                 = VT_I4;
        m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
        m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.YResolution.lInc;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.YResolution.lMin;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.YResolution.lMax;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.YResolution.lNom;

        PropIndex++;
    }

    // Intialize WIA_IPS_XEXTENT (RANGE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_XEXTENT_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_XEXTENT;
    m_pvItemDefaults [PropIndex].lVal               = (m_pvItemDefaults [PropIndex-2].lVal * RootItemInfo.ScanBedWidth)/1000;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_XPOS (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_XPOS_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_XPOS;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_YPOS (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_YPOS_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_YPOS;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;


    PropIndex++;

    // Intialize WIA_IPA_DATATYPE (LIST)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_DATATYPE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_DATATYPE;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_DATATYPE;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    m_wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)m_pSupportedDataTypes;
    m_wpiItemDefaults[PropIndex].ValidVal.List.Nom      = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedDataTypes;

    PropIndex++;

    // Intialize WIA_IPA_DEPTH (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_DEPTH_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_DEPTH;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_BITDEPTH;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_BRIGHTNESS (RANGE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_BRIGHTNESS_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_BRIGHTNESS;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.Brightness.lNom;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.Brightness.lInc;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.Brightness.lMin;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.Brightness.lMax;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.Brightness.lNom;

    PropIndex++;

    // Intialize WIA_IPS_CONTRAST (RANGE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_CONTRAST_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_CONTRAST;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.Contrast.lNom;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.Contrast.lInc;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.Contrast.lMin;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.Contrast.lMax;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.Contrast.lNom;

    PropIndex++;

    // Intialize WIA_IPS_CUR_INTENT (FLAG)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_CUR_INTENT_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_CUR_INTENT;
    m_pvItemDefaults [PropIndex].lVal               = WIA_INTENT_NONE;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_FLAG;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WIA_INTENT_IMAGE_TYPE_COLOR | WIA_INTENT_IMAGE_TYPE_GRAYSCALE |
                                                           WIA_INTENT_IMAGE_TYPE_TEXT  | WIA_INTENT_MINIMIZE_SIZE |
                                                           WIA_INTENT_MAXIMIZE_QUALITY;

    PropIndex++;

    // Intialize WIA_IPA_PIXELS_PER_LINE (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_PIXELS_PER_LINE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_PIXELS_PER_LINE;
    m_pvItemDefaults [PropIndex].lVal               = m_pvItemDefaults[PropIndex-8].lVal;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_NUMER_OF_LINES (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_NUMBER_OF_LINES_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_NUMBER_OF_LINES;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PREFERRED_FORMAT (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_PREFERRED_FORMAT_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_PREFERRED_FORMAT;
    m_pvItemDefaults [PropIndex].puuid              = &m_pInitialFormats[0];
    m_pvItemDefaults [PropIndex].vt                 = VT_CLSID;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ITEM_SIZE (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_ITEM_SIZE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_ITEM_SIZE;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_THRESHOLD (RANGE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_THRESHOLD_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_THRESHOLD;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.Threshold.lNom;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.Threshold.lInc;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.Threshold.lMin;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.Threshold.lMax;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.Threshold.lNom;

    PropIndex++;

    // Intialize WIA_IPA_FORMAT (LIST)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_FORMAT_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_FORMAT;
    m_pvItemDefaults [PropIndex].puuid              = &m_pInitialFormats[0];
    m_pvItemDefaults [PropIndex].vt                 = VT_CLSID;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    m_wpiItemDefaults[PropIndex].ValidVal.ListGuid.pList    = m_pInitialFormats;
    m_wpiItemDefaults[PropIndex].ValidVal.ListGuid.Nom      = *m_pvItemDefaults[PropIndex].puuid;
    m_wpiItemDefaults[PropIndex].ValidVal.ListGuid.cNumList = m_NumInitialFormats;

    PropIndex++;

    // Intialize WIA_IPA_TYMED (LIST)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_TYMED_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_TYMED;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_TYMED;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    m_wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)m_pSupportedTYMED;
    m_wpiItemDefaults[PropIndex].ValidVal.List.Nom      = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedTYMED;

    PropIndex++;

    // Intialize WIA_IPA_CHANNELS_PER_PIXEL (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_CHANNELS_PER_PIXEL;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BITS_PER_CHANNEL (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_BITS_PER_CHANNEL;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PLANAR (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_PLANAR_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_PLANAR;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_PLANAR;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BYTES_PER_LINE (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_BYTES_PER_LINE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_BYTES_PER_LINE;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_MIN_BUFFER_SIZE (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.lMinimumBufferSize;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ACCESS_RIGHTS (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_ACCESS_RIGHTS_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_ACCESS_RIGHTS;
    m_pvItemDefaults [PropIndex].lVal               = WIA_ITEM_READ|WIA_ITEM_WRITE;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_COMPRESSION (LIST)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_COMPRESSION_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_COMPRESSION;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_COMPRESSION;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    m_wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)m_pSupportedCompressionTypes;
    m_wpiItemDefaults[PropIndex].ValidVal.List.Nom      = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedCompressionTypes;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    m_pszItemDefaults[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    m_piItemDefaults [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    m_pvItemDefaults [PropIndex].lVal         = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;
    m_pvItemDefaults [PropIndex].vt           = VT_I4;
    m_psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid       = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    m_wpiItemDefaults[PropIndex].vt           = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;

    PropIndex++;

    // Initialize WIA_IPS_PHOTOMETRIC_INTERP
    m_pszItemDefaults[PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP_STR;
    m_piItemDefaults [PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP;
    m_pvItemDefaults [PropIndex].lVal         = INITIAL_PHOTOMETRIC_INTERP;
    m_pvItemDefaults [PropIndex].vt           = VT_I4;
    m_psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid       = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt           = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_WARM_UP_TIME_STR (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_WARM_UP_TIME_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_WARM_UP_TIME;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.lMaxLampWarmupTime;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    return hr;
}

/**************************************************************************\
* BuildSupportedResolutions
*
*   This helper initializes the supported resolution array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedResolutions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedResolutions");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedResolutions) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedResolutions   = 6;
    m_pSupportedResolutions     = new LONG[m_NumSupportedResolutions];
    if(m_pSupportedResolutions){
        m_pSupportedResolutions[0] = 75;
        m_pSupportedResolutions[1] = 100;
        m_pSupportedResolutions[2] = 150;
        m_pSupportedResolutions[3] = 200;
        m_pSupportedResolutions[4] = 300;
        m_pSupportedResolutions[5] = 600;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedResolutionsArrayContents
*
*   This helper deletes the supported resolutions array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedResolutionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedResolutionsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedResolutions)
        delete [] m_pSupportedResolutions;

    m_pSupportedResolutions     = NULL;
    m_NumSupportedResolutions   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedIntents
*
*   This helper initializes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedIntents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedIntents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedIntents) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedIntents   = 6;
    m_pSupportedIntents     = new LONG[m_NumSupportedIntents];
    if(m_pSupportedIntents){
        m_pSupportedIntents[0] = WIA_INTENT_NONE;
        m_pSupportedIntents[1] = WIA_INTENT_IMAGE_TYPE_COLOR;
        m_pSupportedIntents[2] = WIA_INTENT_IMAGE_TYPE_GRAYSCALE;
        m_pSupportedIntents[3] = WIA_INTENT_IMAGE_TYPE_TEXT;
        m_pSupportedIntents[4] = WIA_INTENT_MINIMIZE_SIZE;
        m_pSupportedIntents[5] = WIA_INTENT_MAXIMIZE_QUALITY;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedIntentsArrayContents
*
*   This helper deletes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedIntentsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedIntentsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedIntents)
        delete [] m_pSupportedIntents;

    m_pSupportedIntents     = NULL;
    m_NumSupportedIntents   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedCompressions
*
*   This helper initializes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedCompressions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedCompressions");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedCompressionTypes) {

        //
        // Supported compression types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCompressionTypes  = 1;
    m_pSupportedCompressionTypes    = new LONG[m_NumSupportedCompressionTypes];
    if(m_pSupportedCompressionTypes){
        m_pSupportedCompressionTypes[0] = WIA_COMPRESSION_NONE;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedCompressionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedCompressionsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedCompressionTypes)
        delete [] m_pSupportedCompressionTypes;

    m_pSupportedCompressionTypes     = NULL;
    m_NumSupportedCompressionTypes   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedPreviewModes
*
*   This helper initializes the supported preview mode array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    8/17/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedPreviewModes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedPreviewModes");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedPreviewModes) {

        //
        // Supported preview modes have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedPreviewModes  = 1;
    m_pSupportedPreviewModes    = new LONG[m_NumSupportedPreviewModes];
    if(m_pSupportedPreviewModes){
        m_pSupportedPreviewModes[0] = WIA_FINAL_SCAN;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    8/17/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedPreviewModesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedPreviewModesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedPreviewModes)
        delete [] m_pSupportedPreviewModes;

    m_pSupportedPreviewModes     = NULL;
    m_NumSupportedPreviewModes   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedDataTypes
*
*   This helper initializes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedDataTypes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedDataTypes");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedDataTypes) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedDataTypes  = 3;
    m_pSupportedDataTypes = new LONG[m_NumSupportedDataTypes];
    if(m_pSupportedDataTypes){
        m_pSupportedDataTypes[0] = WIA_DATA_THRESHOLD;
        m_pSupportedDataTypes[1] = WIA_DATA_GRAYSCALE;
        m_pSupportedDataTypes[2] = WIA_DATA_COLOR;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedDataTypesArrayContents
*
*   This helper deletes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedDataTypesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedDataTypesArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedDataTypes)
        delete [] m_pSupportedDataTypes;

    m_pSupportedDataTypes     = NULL;
    m_NumSupportedDataTypes   = 0;
    return hr;
}

/**************************************************************************\
* BuildInitialFormats
*
*   This helper initializes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildInitialFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildInitialFormats");

    HRESULT hr = S_OK;

    if(NULL != m_pInitialFormats) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumInitialFormats = 1;
    m_pInitialFormats     = new GUID[m_NumInitialFormats];
    if(m_pInitialFormats){
        m_pInitialFormats[0] = WiaImgFmt_MEMORYBMP;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}
/**************************************************************************\
* DeleteInitialFormatsArrayContents
*
*   This helper deletes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteInitialFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteInitialFormatsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pInitialFormats)
        delete [] m_pInitialFormats;

    m_pInitialFormats     = NULL;
    m_NumInitialFormats   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedFormats
*
*   This helper initializes the supported format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedFormats");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedFormats) {

        //
        // Supported formats have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedFormatsArrayContents();
    if (SUCCEEDED(hr)) {
        m_NumSupportedFormats = 2;

        m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
        if (m_pSupportedFormats) {
            m_pSupportedFormats[0].guidFormatID = WiaImgFmt_MEMORYBMP;
            m_pSupportedFormats[0].lTymed       = TYMED_CALLBACK;
            m_pSupportedFormats[1].guidFormatID = WiaImgFmt_BMP;
            m_pSupportedFormats[1].lTymed       = TYMED_FILE;
        } else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedFormatsArrayContents
*
*   This helper deletes the supported formats array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedFormatsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedFormats)
        delete [] m_pSupportedFormats;

    m_pSupportedFormats     = NULL;
    m_NumSupportedFormats   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedTYMED
*
*   This helper initializes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedTYMED()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedTYMED");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedTYMED) {

        //
        // Supported TYMED have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedTYMEDArrayContents();
    if (SUCCEEDED(hr)) {
        m_NumSupportedTYMED = 2;
        m_pSupportedTYMED   = new LONG[m_NumSupportedTYMED];
        if (m_pSupportedTYMED) {
            m_pSupportedTYMED[0] = TYMED_FILE;
            m_pSupportedTYMED[1] = TYMED_CALLBACK;

        } else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedTYMEDArrayContents
*
*   This helper deletes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedTYMEDArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedTYMEDArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedTYMED)
        delete [] m_pSupportedTYMED;

    m_pSupportedTYMED  = NULL;
    m_NumSupportedTYMED = 0;
    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildCapabilities()
{
    HRESULT hr = S_OK;
    if(NULL != m_pCapabilities) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCommands  = 1;
    m_NumSupportedEvents    = 5;
    m_NumCapabilities       = (m_NumSupportedCommands + m_NumSupportedEvents);
    LONG lArrayIndex        = 0;    // increment this value when adding new items to
                                    // the capabilites array

    m_pCapabilities     = new WIA_DEV_CAP_DRV[m_NumCapabilities];
    if (m_pCapabilities) {

        //
        // Initialize EVENTS
        //

        // WIA_EVENT_DEVICE_CONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

        lArrayIndex++;

        // WIA_EVENT_DEVICE_DISCONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

        lArrayIndex++;

        // FAX BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_FAXBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_FAXBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_FAX_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        // COPY BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_COPYBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_COPYBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_PRINT_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        // SCAN BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_SCANBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_SCANBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        //
        // Initialize COMMANDS
        //

        // WIA_CMD_SYNCHRONIZE
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
        m_pCapabilities[lArrayIndex].ulFlags        = 0;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SYNCHRONIZE;

        lArrayIndex++;

    } else
        hr = E_OUTOFMEMORY;
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteCapabilitiesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteCapabilitiesArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pCapabilities) {
        for (LONG i = 0; i < m_NumCapabilities;i++) {
            CoTaskMemFree(m_pCapabilities[i].wszName);
            CoTaskMemFree(m_pCapabilities[i].wszDescription);
        }
        delete [] m_pCapabilities;

        m_pCapabilities = NULL;
    }
    return hr;
}

/**************************************************************************\
* GetBSTRResourceString
*
*   This helper gets a BSTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   pBSTR       - pointer to a BSTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::GetBSTRResourceString(LONG lResourceID,BSTR *pBSTR,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::GetBSTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *pBSTR = SysAllocString(szStringValue);
#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *pBSTR = SysAllocString(wszStringValue);
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::GetOLESTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* VerticalFlip
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

VOID CWIAScannerDevice::VerticalFlip(
             PMINIDRIVERITEMCONTEXT     pDrvItemContext,
             PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext)

{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::VerticalFlip");
    LONG        iHeight;
    LONG        iWidth          = pDrvItemContext->lBytesPerScanLineRaw;
    ULONG       uiDepth         = pDrvItemContext->lDepth;
    LONG        ScanLineWidth   = pDrvItemContext->lBytesPerScanLine;
    BITMAPINFO  UNALIGNED *pbmi = NULL;
    PBYTE       pImageTop       = NULL;
    UNALIGNED BITMAPINFOHEADER *pbmih = NULL;
    //
    // find out if data is TYMED_FILE or TYMED_HGLOBAL
    //

    if (pDataTransferContext->tymed == TYMED_FILE) {

        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer + sizeof(BITMAPFILEHEADER));

    } else if (pDataTransferContext->tymed == TYMED_HGLOBAL) {

        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer);

    } else {
        return;
    }

    //
    // init memory pointer and height
    //

    pbmih = (BITMAPINFOHEADER*)&pbmi->bmiHeader;

    pImageTop = &pDataTransferContext->pTransferBuffer[0] + pDataTransferContext->lHeaderSize;
    iHeight = pbmih->biHeight;

    //
    // try to allocat a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,ScanLineWidth);

    if (pBuffer != NULL) {

        LONG  index;
        PBYTE pImageBottom;

        pImageBottom = pImageTop + (iHeight-1) * ScanLineWidth;

        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,ScanLineWidth);
            memcpy(pImageTop,pImageBottom,ScanLineWidth);
            memcpy(pImageBottom,pBuffer,ScanLineWidth);

            pImageTop    += ScanLineWidth;
            pImageBottom -= ScanLineWidth;
        }

        LocalFree(pBuffer);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("VerticalFlip, LocalAlloc failed allocating %d bytes",ScanLineWidth));
    }
}

/**************************************************************************\
* SwapBuffer24
*
*   Place RGB bytes in correct order for DIB format.
*
* Arguments:
*
*   pBuffer     - Pointer to the data buffer.
*   lByteCount  - Size of the data in bytes.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

VOID CWIAScannerDevice::SwapBuffer24(PBYTE pBuffer, LONG lByteCount)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::::SwapBuffer24");
    for (LONG i = 0; i < lByteCount; i+= 3) {
        BYTE bTemp = pBuffer[i];
        pBuffer[i]     = pBuffer[i + 2];
        pBuffer[i + 2] = bTemp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascroll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiascroll.rc
//

// Device Events, and Commands (Name strings)
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     100
#define IDS_CMD_SYNCRONIZE_NAME            101
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_EVENT_SCANBUTTON_NAME          104
#define IDS_EVENT_COPYBUTTON_NAME          105
#define IDS_EVENT_FAXBUTTON_NAME           106

// Device Events, and Commands (Description strings)
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     200
#define IDS_CMD_SYNCRONIZE_DESC            201
#define IDS_EVENT_DEVICE_CONNECTED_DESC    202
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 203
#define IDS_EVENT_SCANBUTTON_DESC          204
#define IDS_EVENT_COPYBUTTON_DESC          205
#define IDS_EVENT_FAXBUTTON_DESC           206

#define IDS_ROOTITEM_NAME                  300
#define IDS_TOPITEM_NAME                   301

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        700
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           700
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascnex\wiascnex.cpp ===
////////////////////////////////////
// (C) COPYRIGHT MICROSOFT CORP., 1998-1999
//
// FILE: WIASCNEX.CPP
//
// DESCRIPTION: Implements core DLL routines.
//
#include "precomp.h"
#pragma hdrstop
#include <string.h>
#include <tchar.h>
#include "resource.h"

#include "wiascidl_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ScannerShellExt,  CShellExt)
END_OBJECT_MAP()

static CComBSTR          g_strCategory;

STDAPI DllRegisterServer(void)
{

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}


EXTERN_C
BOOL
DllMain(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

            _Module.Init (ObjectMap, hinst);
            DisableThreadLibraryCalls(hinst);

            break;

        case DLL_PROCESS_DETACH:
            _Module.Term();
            break;
    }
    return TRUE;
}


extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return _Module.GetLockCount()==0 ? S_OK : S_FALSE;
}

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);

}


/*****************************************************************************

ShowMessage

Utility function for displaying messageboxes

******************************************************************************/

BOOL ShowMessage (HWND hParent, INT idCaption, INT idMessage)
{
    MSGBOXPARAMS mbp;
    BOOL bRet;
    INT  i;

    ZeroMemory (&mbp, sizeof(mbp));
    mbp.cbSize = sizeof(mbp);
    mbp.hwndOwner = hParent;
    mbp.hInstance = g_hInst;
    mbp.lpszText = MAKEINTRESOURCE(idMessage);
    mbp.lpszCaption = MAKEINTRESOURCE(idCaption);
    mbp.dwStyle = MB_OK | MB_APPLMODAL;

    i = MessageBoxIndirect (&mbp);
    bRet = (IDOK==i);
    return bRet;
}

/*****************************************************************************

FindLastID

Utility for getting the last relative pidl from a full pidl

******************************************************************************/
// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

LPITEMIDLIST
FindLastID(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    if (pidl == NULL)
        return NULL;

    // Find the last one
    while (pidlNext->mkid.cb)
    {
        pidlLast = pidlNext;
        pidlNext = ILNext(pidlLast);
    }

    return (LPITEMIDLIST)pidlLast;
}

/*****************************************************************************

CreateDeviceFromID

Utility for attaching to WIA and getting a root IWiaItem interface

*****************************************************************************/
HRESULT
CreateDeviceFromId (LPWSTR szDeviceId, IWiaItem **ppItem)
{
    IWiaDevMgr *pDevMgr;
    HRESULT hr = CoCreateInstance (CLSID_WiaDevMgr,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IWiaDevMgr,
                                   reinterpret_cast<LPVOID*>(&pDevMgr));
    if (SUCCEEDED(hr))
    {
        BSTR strId = SysAllocString (szDeviceId);
        hr = pDevMgr->CreateDevice (strId, ppItem);
        SysFreeString (strId);
        pDevMgr->Release ();
    }
    return hr;
}

/*****************************************************************************\

    GetNamesFromDataObject

    Return the list of selected item identifiers. Each identifier is of the form
    "<DEVICEID>::<FULL PATH NAME>". the list is double-null terminated

*****************************************************************************/

LPWSTR
GetNamesFromDataObject (IDataObject *lpdobj, UINT *puItems)
{
    FORMATETC fmt;
    STGMEDIUM stg;
    LPWSTR szRet = NULL;
    LPWSTR szCurrent;
    UINT nItems;
    size_t size;
    if (puItems)
    {
        *puItems = 0;
    }

    fmt.cfFormat = (CLIPFORMAT) RegisterClipboardFormat (TEXT("WIAItemNames"));
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.lindex = -1;
    fmt.ptd = NULL;
    fmt.tymed = TYMED_HGLOBAL;

    if (lpdobj && puItems && SUCCEEDED(lpdobj->GetData (&fmt, &stg)))
    {
        szCurrent = reinterpret_cast<LPWSTR>(GlobalLock (stg.hGlobal));

        // count the number of items in the double-null terminated string
        szRet  = szCurrent;
        nItems = 0;
        while (*szRet)
        {
            nItems++;
            while (*szRet)
            {
                szRet++;
            }
            szRet++;
        }
        *puItems = nItems;
        size = (szRet-szCurrent+1)*sizeof(WCHAR);
        szRet = new WCHAR[size];
        CopyMemory (szRet, szCurrent, size);
        GlobalUnlock (stg.hGlobal);
        GlobalFree (stg.hGlobal);
    }
    return szRet;
}

VOID Trace(LPCTSTR format,...)
{

//#ifdef DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

//#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascroll\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IStiUSD methods.
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

#define THREAD_TERMINATION_TIMEOUT  10000
VOID EventThread( LPVOID  lpParameter ); // event thread

/**************************************************************************\
* CWIAScannerDevice::CWIAScannerDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

CWIAScannerDevice::CWIAScannerDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_fValid(FALSE),
    m_punkOuter(NULL),
    m_pIStiDevControl(NULL),
    m_bUsdLoadEvent(FALSE),
    m_dwLastOperationError(0),
    m_dwLockTimeout(100),
    m_hSignalEvent(NULL),
    m_hShutdownEvent(NULL),
    m_hEventNotifyThread(NULL),
    m_guidLastEvent(GUID_NULL),
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pIWiaEventCallback(NULL),
    m_pIDrvItemRoot(NULL),
    m_pStiDevice(NULL),
    m_hInstance(NULL),
    m_pIWiaLog(NULL),
    m_NumSupportedFormats(0),
    m_NumCapabilities(0),
    m_NumSupportedTYMED(0),
    m_NumInitialFormats(0),
    m_NumSupportedDataTypes(0),
    m_NumSupportedIntents(0),
    m_NumSupportedCompressionTypes(0),
    m_NumSupportedResolutions(0),
    m_pSupportedFormats(NULL),
    m_pInitialFormats(NULL),
    m_pCapabilities(NULL),
    m_pSupportedTYMED(NULL),
    m_pSupportedDataTypes(NULL),
    m_pSupportedIntents(NULL),
    m_pSupportedCompressionTypes(NULL),
    m_pSupportedResolutions(NULL),
    m_pSupportedPreviewModes(NULL),
    m_pszRootItemDefaults(NULL),
    m_piRootItemDefaults(NULL),
    m_pvRootItemDefaults(NULL),
    m_psRootItemDefaults(NULL),
    m_wpiRootItemDefaults(NULL),
    m_pszItemDefaults(NULL),
    m_piItemDefaults(NULL),
    m_pvItemDefaults(NULL),
    m_psItemDefaults(NULL),
    m_wpiItemDefaults(NULL),
    m_NumRootItemProperties(0),
    m_NumItemProperties(0),
    m_MaxBufferSize(524280),
    m_MinBufferSize(262140),
    m_bDeviceLocked(FALSE),
    m_DeviceDefaultDataHandle(NULL),
    m_pszDeviceNameA(NULL),
    m_bADFEnabled(TRUE),
    m_pScanAPI(NULL)
{
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }
}

/**************************************************************************\
* CWIAScannerDevice::PrivateInitialize
*
*   Device class private initialization code
*
* Arguments:
*
*    None
*
* Return Value:
*
*    HRESULT
*
\**************************************************************************/

HRESULT CWIAScannerDevice::PrivateInitialize()
{
    HRESULT hr = S_OK;

#ifdef USE_SERVICE_LOG_CREATION
    hr = wiasCreateLogInstance(g_hInst, &m_pIWiaLog);
#else

    hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWiaLog,(void**)&m_pIWiaLog);

    if (SUCCEEDED(hr)) {
        m_pIWiaLog->InitializeLog((LONG)(LONG_PTR)g_hInst);
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Logging COM object created successfully for wiascroll.dll"));
    } else {
#ifdef DEBUG
        OutputDebugString(TEXT("Could not CoCreateInstance on Logging COM object for wiafbdrv.dll, because we are STI only\n"));
        OutputDebugString(TEXT("********* (Device must have been created for STI only) *********\n"));
#endif
    }

#endif

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_csShutdown, MINLONG)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::PrivateInitialize, create shutdown critsec failed"));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }


    if(hr == S_OK) {
        // Create event for syncronization of notifications shutdown.
        m_hShutdownEvent =  CreateEvent(NULL,FALSE,FALSE,NULL);

        if (m_hShutdownEvent && (INVALID_HANDLE_VALUE != m_hShutdownEvent)) {
            m_fValid = TRUE;
        } else {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::PrivateInitialize, create shutdown event failed"));
        }
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::~CWIAScannerDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

CWIAScannerDevice::~CWIAScannerDevice(void)
{

    // Kill notification thread if it exists.
    SetNotificationHandle(NULL);

    // Close event for syncronization of notifications shutdown.
    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }

    // Release the device control interface.
    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }

    //
    // WIA member destruction
    //

    // Tear down the driver item tree.
    if (m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIAScannerDevice, Deleting Device Item Tree (this is OK)"));
        DeleteItemTree();
        m_pIDrvItemRoot = NULL;
    }

    // free any IO handles opened
    if(m_DeviceDefaultDataHandle){
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIAScannerDevice, Closing DefaultDeviceDataHandle"));
        CloseHandle(m_DeviceDefaultDataHandle);
        m_DeviceDefaultDataHandle = NULL;
    }

    // Cleanup the WIA event sink.
    if (m_pIWiaEventCallback) {
        m_pIWiaEventCallback->Release();
        m_pIWiaEventCallback = NULL;
    }

    // Free the storage for the device ID.
    if (m_bstrDeviceID) {
        SysFreeString(m_bstrDeviceID);
        m_bstrDeviceID = NULL;
    }

    // Release the objects supporting device property storage.
    if (m_bstrRootFullItemName) {
        SysFreeString(m_bstrRootFullItemName);
        m_bstrRootFullItemName = NULL;
    }

    // Delete allocated arrays
    DeleteCapabilitiesArrayContents();
    DeleteSupportedIntentsArrayContents();

    // Free the critical section.
    DeleteCriticalSection(&m_csShutdown);
    if(m_pIWiaLog)
        m_pIWiaLog->Release();

    if(m_pScanAPI){
        // disable fake scanner device
        m_pScanAPI->FakeScanner_DisableDevice();
        delete m_pScanAPI;
    }
}

/**************************************************************************\
* CWIAScannerDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetCapabilities");
    memset(pUsdCaps, 0, sizeof(STI_USD_CAPS));
    pUsdCaps->dwVersion     = STI_VERSION;
    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT|
                              STI_GENCAP_NOTIFICATIONS |
                              STI_GENCAP_POLLING_NEEDED;
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetStatus");
    HRESULT hr = S_OK;

    // Validate parameters.
    if (!pDevStatus) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    // If we are asked, verify the device is online.
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, WIA is asking the device if we are ONLINE"));
        pDevStatus->dwOnlineState = 0L;
        hr = m_pScanAPI->FakeScanner_DeviceOnline();
        if(SUCCEEDED(hr)){
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Device is ONLINE"));
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetStatus, Device is OFFLINE"));
        }
    }

    // If we are asked, verify state of event.
    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {

        // Generate an event the first time we load.
        if (m_bUsdLoadEvent) {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;
            m_guidLastEvent                  = guidEventFirstLoaded;
            m_bUsdLoadEvent                  = FALSE;
        }

        // check for device events
        LONG lButtonIndex = ID_FAKE_NOEVENT;
        hr = m_pScanAPI->FakeScanner_GetDeviceEvent(&lButtonIndex);
        if(SUCCEEDED(hr)){
            switch(lButtonIndex){
            case ID_FAKE_SCANBUTTON:
                m_guidLastEvent = WIA_EVENT_SCAN_IMAGE;
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Scan Button Pressed!"));
                break;
            case ID_FAKE_COPYBUTTON:
                m_guidLastEvent = WIA_EVENT_SCAN_PRINT_IMAGE;
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Copy Button Pressed!"));
                break;
            case ID_FAKE_FAXBUTTON:
                m_guidLastEvent = WIA_EVENT_SCAN_FAX_IMAGE;
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Fax Button Pressed!"));
                break;
            default:
                m_guidLastEvent = GUID_NULL;
                break;
            }

            if(m_guidLastEvent != GUID_NULL){
                pDevStatus->dwEventHandlingState |= STI_EVENTHANDLING_PENDING;
            }
        }
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::DeviceReset
*
*   Reset device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::DeviceReset(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::DeviceReset");

    return m_pScanAPI->FakeScanner_ResetDevice();
}

/**************************************************************************\
* CWIAScannerDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Diagnostic");

    // Initialize response buffer
    memset(&pBuffer->sErrorInfo,0,sizeof(pBuffer->sErrorInfo));
    pBuffer->dwStatusMask = 0;
    pBuffer->sErrorInfo.dwGenericError  = NOERROR;
    pBuffer->sErrorInfo.dwVendorError   = 0;

    return m_pScanAPI->FakeScanner_Diagnostic();
}

/**************************************************************************\
* CWIAScannerDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::SetNotificationHandle(HANDLE hEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SetNotificationHandle");
    HRESULT hr = STI_OK;

    EnterCriticalSection(&m_csShutdown);

    // Are we starting or stopping the notification thread?
    if (hEvent && (hEvent != INVALID_HANDLE_VALUE)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, hEvent   = %d",hEvent));
        m_hSignalEvent  = hEvent;
        m_guidLastEvent = GUID_NULL;

        if (NULL == m_hEventNotifyThread) {
            DWORD dwThread = 0;
            m_hEventNotifyThread = ::CreateThread(NULL,
                                                  0,
                                                  (LPTHREAD_START_ROUTINE)EventThread,
                                                  (LPVOID)this,
                                                  0,
                                                  &dwThread);
            if (!m_hEventNotifyThread) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("FlatbedScannerUsdDevice::SetNotificationHandle, CreateThread failed"));
                hr = STIERR_UNSUPPORTED;
            }
        }
    } else {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Disabling event Notifications"));
        // Disable event notifications.
        if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
            if (!SetEvent(m_hShutdownEvent)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Setting Shutdown event failed.."));
            } else {

                if (NULL != m_hEventNotifyThread) {

                    //
                    // WAIT for thread to terminate, if one exists
                    //

                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Waiting for Event Thread to terminate (%d ms timeout)",THREAD_TERMINATION_TIMEOUT));
                    DWORD dwResult = WaitForSingleObject(m_hEventNotifyThread,THREAD_TERMINATION_TIMEOUT);
                    switch (dwResult) {
                    case WAIT_TIMEOUT:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread termination TIMED OUT!"));
                        break;
                    case WAIT_OBJECT_0:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, We are signaled...YAY!"));
                        break;
                    case WAIT_ABANDONED:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread was abandoned.."));
                        break;
                    case WAIT_FAILED:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread returned a failure..."));
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, GetLastError() Code = %d",::GetLastError()));
                        break;
                    default:
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Unknown signal (%d) received from WaitForSingleObject() call",dwResult));
                        break;
                    }
                }

                //
                // Close event for syncronization of notifications shutdown.
                //

                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Closing m_hShutdownEvent handle (it has been signaled)"));
                CloseHandle(m_hShutdownEvent);
                m_hShutdownEvent = NULL;
            }
        }

        //
        // terminate thread
        //

        if (NULL != m_hEventNotifyThread) {
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, closing event Notifications thread handle"));
            CloseHandle(m_hEventNotifyThread);
            m_hEventNotifyThread = NULL;
        }

        m_guidLastEvent      = GUID_NULL;
    }

    LeaveCriticalSection(&m_csShutdown);
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::GetNotificationData
*
*   Provides data on an event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetNotificationData");
    // If we have notification ready - return it's guid
    if (!IsEqualIID(m_guidLastEvent, GUID_NULL)) {
        memset(&pBuffer->abNotificationData,0,sizeof(pBuffer->abNotificationData));
        pBuffer->dwSize               = sizeof(STINOTIFY);
        pBuffer->guidNotificationCode = m_guidLastEvent;
        m_guidLastEvent               = GUID_NULL;
    } else {
        return STIERR_NOEVENTS;
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Escape");

    // Write command to device if needed.
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetLastError");

    if (IsBadWritePtr(pdwLastDeviceError, sizeof(DWORD))) {
        return STIERR_INVALID_PARAM;
    }

    *pdwLastDeviceError = m_dwLastOperationError;
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetLastErrorInfo");

    if (IsBadWritePtr(pLastErrorInfo, sizeof(STI_ERROR_INFO))) {
        return STIERR_INVALID_PARAM;
    }

    pLastErrorInfo->dwGenericError          = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0]  = '\0';

    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::LockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::LockDevice");
    HRESULT hr = STI_OK;
    if(m_bDeviceLocked)
        hr = STIERR_DEVICE_LOCKED;
    else {
        m_bDeviceLocked = TRUE;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::UnLockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::UnLockDevice");
    HRESULT hr = STI_OK;
    if(!m_bDeviceLocked)
        hr = STIERR_NEEDS_LOCK;
    else {
        m_bDeviceLocked = FALSE;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    lpdwNumberOfBytes  - number of bytes to read/returned
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawReadData");
    HRESULT hr = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDefaultDataHandle) {
        fRet = ReadFile( m_DeviceDefaultDataHandle,
                         lpBuffer,
                         *lpdwNumberOfBytes,
                         &dwBytesReturned,
                         lpOverlapped );

        m_dwLastOperationError = ::GetLastError();
        hr = fRet ? STI_OK : HRESULT_FROM_WIN32(m_dwLastOperationError);

        *lpdwNumberOfBytes = (fRet) ? dwBytesReturned : 0;
    } else {
        hr = STIERR_NOT_INITIALIZED;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    dwNumberOfBytes    - number of bytes to write
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawWriteData");
    HRESULT hr   = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDefaultDataHandle) {
        fRet = WriteFile(m_DeviceDefaultDataHandle,lpBuffer,dwNumberOfBytes,&dwBytesReturned,lpOverlapped);
        m_dwLastOperationError = ::GetLastError();
        hr = fRet ? STI_OK : HRESULT_FROM_WIN32(m_dwLastOperationError);
    } else {
        hr = STIERR_NOT_INITIALIZED;
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::RawReadCommand
*
*
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    lpdwNumberOfBytes  - number of bytes to read/returned
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawReadCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::RawWriteCommand
*
*
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    nNumberOfBytes     - number of bytes to write
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawWriteCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    - device interface
*    dwStiVersion           - STI version
*    hParametersKey         - HKEY for registry reading/writing
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Initialize");

    HRESULT hr = STI_OK;
    WCHAR szDeviceNameW[255];
    UINT uiNameLen = 0;

    if (!pIStiDevControl) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    // Cache the device control interface.
    m_pIStiDevControl = pIStiDevControl;
    m_pIStiDevControl->AddRef();

    //
    // Get the name of the device port
    //

    hr = m_pIStiDevControl->GetMyDevicePortName(szDeviceNameW,sizeof(szDeviceNameW)/sizeof(WCHAR));
    if (!SUCCEEDED(hr) || !*szDeviceNameW) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, couldn't get device port"));
        return hr;
    }

    uiNameLen = WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, NULL, NULL, 0, 0);
    if (!uiNameLen) {
        return STIERR_INVALID_PARAM;
    }

    m_pszDeviceNameA = new CHAR[uiNameLen+1];
    if (!m_pszDeviceNameA) {
        return STIERR_INVALID_PARAM;
    }

    WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, m_pszDeviceNameA, uiNameLen, 0, 0);

    //
    // Uncomment the comment block below to have the driver create the kernel mode file
    // handles.
    //

    /*

    //
    // Open kernel mode device driver.
    //

    m_DeviceDefaultDataHandle = CreateFileA(m_pszDeviceNameA,
                                     GENERIC_READ | GENERIC_WRITE, // Access mask
                                     0,                            // Share mode
                                     NULL,                         // SA
                                     OPEN_EXISTING,                // Create disposition
                                     FILE_ATTRIBUTE_SYSTEM,        // Attributes
                                     NULL );

    m_dwLastOperationError = ::GetLastError();

    hr = (m_DeviceDefaultDataHandle != INVALID_HANDLE_VALUE) ?
                S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,m_dwLastOperationError);

    if (FAILED(hr)) {
        return hr;
    }

    */

    //
    // Load BITMAP file, (used only as sample scanned data by sample scanner driver)
    //

    if (SUCCEEDED(hr)) {
        hr = CreateInstance(&m_pScanAPI,SCROLLFED_SCANNER_MODE);
        if (m_pScanAPI) {
            hr = m_pScanAPI->FakeScanner_Initialize();
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, Could not create FakeScanner API object"));
            hr = E_OUTOFMEMORY;
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
    }


    //
    // Open DeviceData section to read driver specific information
    //

    HKEY hKey = hParametersKey;
    HKEY hOpenKey = NULL;
    if (RegOpenKeyEx(hKey,                     // handle to open key
                     TEXT("DeviceData"),       // address of name of subkey to open
                     0,                        // options (must be NULL)
                     KEY_QUERY_VALUE|KEY_READ, // just want to QUERY a value
                     &hOpenKey                 // address of handle to open key
                    ) == ERROR_SUCCESS) {



        //
        // This is where you read registry entries for your device.
        // The DeviceData section is the proper place to put this information
        //


        //
        // close registry key when finished
        //

        RegCloseKey(hOpenKey);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, couldn't open DeviceData KEY"));
        return E_FAIL;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::DoEventProcessing
*
*   Process device events
*
* Arguments:
*
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DoEventProcessing()
{
    HRESULT hr = S_OK;

    OVERLAPPED Overlapped;
    ZeroMemory( &Overlapped, sizeof( Overlapped ));

    //
    // create an Event for the device to signal
    //

    Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    BYTE    InterruptData   = 0;
    DWORD   dwIndex         = 0;
    DWORD   dwError         = 0;
    LONG    lButtonIndex    = ID_FAKE_NOEVENT;

    //
    // initialize the Event handle array for WaitForMultipleObjects() call
    //

    HANDLE  hEventArray[2] = {m_hShutdownEvent, Overlapped.hEvent};

    //
    // Initialize thread control variables
    //

    BOOL    fLooping = TRUE;
    BOOL    bRet     = TRUE;

    while (fLooping) {

#ifdef _USE_REAL_DEVICE_FOR_EVENTS

        //
        // use the following call for interrupt events on your device
        //

        bRet = DeviceIoControl( m_DeviceDefaultDataHandle,
                                IOCTL_WAIT_ON_DEVICE_EVENT,
                                NULL,
                                0,
                                &InterruptData,
                                sizeof(InterruptData),
                                &dwError,
                                &Overlapped );

#else

        //
        // This for the FakeScanner API calls
        //

        bRet = TRUE;
        m_pScanAPI->FakeScanner_SetInterruptEventHandle(Overlapped.hEvent);

#endif
        if ( bRet || ( !bRet && ( ::GetLastError() == ERROR_IO_PENDING ))) {

            //
            // wait for event to happen from device, or a Shutdown event from the WIA service
            //

            dwIndex = WaitForMultipleObjects( 2, hEventArray,FALSE, INFINITE );

            //
            // determine how to handle event from device here
            //

            switch ( dwIndex ) {
            case WAIT_OBJECT_0+1:   // EVENT FROM THE DEVICE

#ifdef _USE_REAL_DEVICE_FOR_EVENTS

                DWORD dwBytesRet = 0;

                //
                // use the following call for interrupt events on your device
                //

                bRet = GetOverlappedResult( m_DeviceDefaultDataHandle, &Overlapped, &dwBytesRet, FALSE );
#else
                //
                // Fake Scanner API
                //

                //
                // check for device event information
                //

                lButtonIndex = ID_FAKE_NOEVENT;
                hr = m_pScanAPI->FakeScanner_GetDeviceEvent(&lButtonIndex);
                if (SUCCEEDED(hr)) {
                    switch (lButtonIndex) {
                    case ID_FAKE_SCANBUTTON:
                        m_guidLastEvent = WIA_EVENT_SCAN_IMAGE;
                        break;
                    case ID_FAKE_COPYBUTTON:
                        m_guidLastEvent = WIA_EVENT_SCAN_PRINT_IMAGE;
                        break;
                    case ID_FAKE_FAXBUTTON:
                        m_guidLastEvent = WIA_EVENT_SCAN_FAX_IMAGE;
                        break;
                    default:
                        m_guidLastEvent = GUID_NULL;
                        break;
                    }

                    if (m_guidLastEvent != GUID_NULL) {
                        SetEvent(m_hSignalEvent);
                    }
                }

#endif

                //
                // manually reset device event, after it has been signaled
                //

                ResetEvent( Overlapped.hEvent );
                break;
            case WAIT_OBJECT_0:     // SHUTDOWN EVENT
            default:
                fLooping = FALSE;   // for loop to stop
            }
        } else {
            dwError = ::GetLastError();
            break;
        }
    } // end while (fLooping)

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// THREADS SECTION                                                                    //
////////////////////////////////////////////////////////////////////////////////////////

VOID EventThread( LPVOID  lpParameter )
{
    PWIASCANNERDEVICE pThisDevice = (PWIASCANNERDEVICE)lpParameter;
    pThisDevice->DoEventProcessing();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascroll\validate.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       validate.cpp
*
*  VERSION:     1.0
*
*  DATE:        17 July, 2000
*
*  DESCRIPTION:
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

/**************************************************************************\
* ValidateDataTransferContext
*
*   Checks the data transfer context to ensure it's valid.
*
* Arguments:
*
*    pDataTransferContext - Pointer the data transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::ValidateDataTransferContext(
    PMINIDRV_TRANSFER_CONTEXT pDataTransferContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::ValidateDataTransferContext");

    if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid data transfer context"));
        return E_INVALIDARG;;
    }

    //
    //  for TYMED file, only WiaImgFmt_BMP is allowed by this driver
    //

    if (pDataTransferContext->tymed == TYMED_FILE) {

        if (pDataTransferContext->guidFormatID != WiaImgFmt_BMP) {
            if (pDataTransferContext->guidFormatID != WiaImgFmt_TIFF) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_FILE"));
                return E_INVALIDARG;
            }
        }
    }

    //
    //  for TYMED CALLBACK, only WiaImgFmt_MEMORYBMP is allowed by this driver
    //

    if (pDataTransferContext->tymed == TYMED_CALLBACK) {

        if (pDataTransferContext->guidFormatID != WiaImgFmt_MEMORYBMP) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_CALLBACK"));
            return E_INVALIDARG;;
        }
    }

    return S_OK;
}

/**************************************************************************\
* UpdateValidDepth
*
*   Helper that updates the valid value for depth based on the data type.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the WiaItem context
*   lDataType   -   the value of the DataType property.
*   lDepth      -   the address of the variable where the Depth's new value
*                   will be returned.
*
* Return Value:
*
*   Status      -   S_OK if successful
*                   E_INVALIDARG if lDataType is unknown
*                   Errors are those returned by wiasReadPropLong,
*                   and wiasWritePropLong.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::UpdateValidDepth(
    BYTE        *pWiasContext,
    LONG        lDataType,
    LONG        *lDepth)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::UpdateValidDepth");
    HRESULT hr = S_OK;
    LONG    pValidDepth[1];

    switch (lDataType) {
        case WIA_DATA_THRESHOLD:
            pValidDepth[0] = 1;
            break;
        case WIA_DATA_GRAYSCALE:
            pValidDepth[0] = 8;
            break;
        case WIA_DATA_COLOR:
            pValidDepth[0] = 24;
            break;
        default:
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("UpdateValidDepth, unknown data type"));
            return E_INVALIDARG;
    }

    if (lDepth) {
        *lDepth = pValidDepth[0];
    }

    return hr;
}

/**************************************************************************\
* CheckDataType
*
*   This helper method is called to check whether WIA_IPA_DATATYPE
*   property is changed.  When this property changes, other dependant
*   properties and their valid values must also be changed.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckDataType(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckDataType");
    WIAS_CHANGED_VALUE_INFO cviDataType, cviDepth;
    HRESULT                 hr = S_OK;

    //
    //  Call wiasGetChangedValue for DataType. It is checked first since it's
    //  not dependant on any other property.  All properties in this method
    //  that follow are dependant properties of DataType.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for DataType never change).  Also,
    //  the address of a variable for the old value is NULL, since the old
    //  value is not needed.  The address of bDataTypeChanged is passed
    //  so that dependant properties will know whether the DataType is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPA_DATATYPE,
                                 &cviDataType);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for Depth. Depth is a dependant property of
    //  DataType whose valid value changes according to what the current
    //  value of DataType is.
    //
    //  The call to wiasGetChangedValue specifies that validation should only
    //  be skipped if the DataType has changed.  This is because the valid
    //  values for Depth will change according to the new value for
    //  DataType.  The address of a variable for the old value is NULL, since
    //  the old value is not needed.  The address of bDepthChanged is passed
    //  so that dependant properties will know whether the Depth is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 cviDataType.bChanged,
                                 WIA_IPA_DEPTH,
                                 &cviDepth);
    if (FAILED(hr)) {
        return hr;
    }

    if (cviDataType.bChanged) {

        //
        //  DataType changed so update valid value for Depth
        //

        hr = UpdateValidDepth(pWiasContext, cviDataType.Current.lVal, &cviDepth.Current.lVal);

        if (SUCCEEDED(hr)) {

            //
            //  Check whether we must fold.  Depth will only be folded if it
            //  is not one of the properties that the app is changing.
            //

            if (!cviDepth.bChanged) {
                hr = wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, cviDepth.Current.lVal);
            }
        }
    }

    //
    //  Update properties dependant on DataType and Depth.
    //  Here, ChannelsPerPixel and BitsPerChannel are updated.
    //

    if (cviDataType.bChanged || cviDepth.bChanged) {
        if (SUCCEEDED(hr)) {
            #define NUM_PROPS_TO_SET 2
            PROPSPEC    ps[NUM_PROPS_TO_SET] = {
                            {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
                            {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL}};
            PROPVARIANT pv[NUM_PROPS_TO_SET];

            for (LONG index = 0; index < NUM_PROPS_TO_SET; index++) {
                PropVariantInit(&pv[index]);
                pv[index].vt = VT_I4;
            }

            switch (cviDataType.Current.lVal) {
                case WIA_DATA_THRESHOLD:
                    pv[0].lVal = 1;
                    pv[1].lVal = 1;
                    break;

                case WIA_DATA_GRAYSCALE:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;

                case WIA_DATA_COLOR:
                    pv[0].lVal = 3;
                    pv[1].lVal = 8;
                    break;

                default:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
            }
            hr = wiasWriteMultiple(pWiasContext, NUM_PROPS_TO_SET, ps, pv);
        }
    }

    return hr;
}

/**************************************************************************\
* CheckIntent
*
*   This helper method is called to make the relevant changes if the
*   Current Intent property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckIntent(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckIntent");
    HRESULT                 hr;
    WIAS_CHANGED_VALUE_INFO cviIntent;

    //
    //  Call wiasGetChangedValue for CurrentIntent. CurrentIntent is checked first
    //  since it's not dependant on any other property.  All properties in
    //  this method that follow are dependant properties of CurrentIntent.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for CurrentIntent never change). The
    //  address of the old value is specified as NULL, since it is not used.
    //  The address of bIntentChanged is passed so that dependant properties
    //  will know whether the YResolution is being changed or not.  This is
    //  important since dependant properties will need their valid values
    //  updated and may need to be folded to new valid values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPS_CUR_INTENT,
                                 &cviIntent);
    if (SUCCEEDED(hr)) {
        if (cviIntent.bChanged) {

            LONG lImageSizeIntent = (cviIntent.Current.lVal & WIA_INTENT_SIZE_MASK);
            LONG lImageTypeIntent = (cviIntent.Current.lVal & WIA_INTENT_IMAGE_TYPE_MASK);

            switch (lImageTypeIntent) {

                case WIA_INTENT_NONE:
                    break;

                case WIA_INTENT_IMAGE_TYPE_GRAYSCALE:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_GRAYSCALE);
                    UpdateValidDepth (pWiasContext, WIA_DATA_GRAYSCALE, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 8);
                    break;

                case WIA_INTENT_IMAGE_TYPE_TEXT:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_THRESHOLD);
                    UpdateValidDepth (pWiasContext, WIA_DATA_THRESHOLD, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 1);
                    break;

                case WIA_INTENT_IMAGE_TYPE_COLOR:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_COLOR);
                    UpdateValidDepth(pWiasContext, WIA_DATA_COLOR, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 24);
                    break;

                default:
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (TYPE) = %d",lImageTypeIntent));
                    return E_INVALIDARG;

            }

            switch (lImageSizeIntent) {
            case WIA_INTENT_NONE:
                    break;
            case WIA_INTENT_MINIMIZE_SIZE:
            case WIA_INTENT_MAXIMIZE_QUALITY:
                {

                    //
                    // Set the X and Y Resolutions.
                    //

                    wiasWritePropLong(pWiasContext, WIA_IPS_XRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);
                    wiasWritePropLong(pWiasContext, WIA_IPS_YRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);

                    //
                    //  The Resolutions and DataType were set, so update the property
                    //  context to indicate that they have changed.
                    //

                    wiasSetPropChanged(WIA_IPS_XRES, pContext, TRUE);
                    wiasSetPropChanged(WIA_IPS_YRES, pContext, TRUE);
                    wiasSetPropChanged(WIA_IPA_DATATYPE, pContext, TRUE);
                }
                break;
            default:
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (SIZE) = %d",lImageSizeIntent));
                return E_INVALIDARG;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, wiasGetChangedValue (intent) failed"));
    }
    return hr;
}

/**************************************************************************\
* CheckPreferredFormat
*
*   This helper method is called to make the relevant changes if the
*   Format property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckPreferredFormat(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    HRESULT hr = S_OK;

    //
    // update WIA_IPA_PREFERRED_FORMAT property
    //

    GUID FormatGUID;
    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &FormatGUID, NULL, TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, FormatGUID);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckPreferredFormat, could not write WIA_IPA_PREFERRED_FORMAT"));
            return hr;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPA_FORMAT"));
    }
    return hr;
}

/**************************************************************************\
* CheckADFStatus
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckADFStatus(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckADFStatus");

    if(!m_bADFAttached)
        return S_OK;

    HRESULT hr = S_OK;

    BYTE    *pRootItemCtx   = NULL;
    LONG lDocHandlingSelect = 0;
    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    hr = wiasReadPropLong(pRootItemCtx,
                          WIA_DPS_DOCUMENT_HANDLING_SELECT,
                          &lDocHandlingSelect,
                          NULL,
                          FALSE);
    if(hr == S_FALSE){
        lDocHandlingSelect = FEEDER;
    }

    if (SUCCEEDED(hr)) {
        switch (lDocHandlingSelect) {
        case FEEDER:
            m_bADFEnabled = TRUE;
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
            return hr;
            break;
        }
    }

    //
    // update document handling status
    //

    if (m_bADFEnabled) {

        HRESULT Temphr = m_pScanAPI->FakeScanner_ADFAvailable();
        if (S_OK == Temphr) {
            hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FEED_READY);
        } else {
            hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,PAPER_JAM);
        }

        if (FAILED(Temphr))
            hr = Temphr;
    } else {
        hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FLAT_READY);
    }
    return hr;
}

/**************************************************************************\
* CheckPreview
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    8/21/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckPreview(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckPreview");

    HRESULT hr = S_OK;

    BYTE    *pRootItemCtx   = NULL;
    LONG lPreview = 0;
    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    hr = wiasReadPropLong(pRootItemCtx,
                          WIA_DPS_PREVIEW,
                          &lPreview,
                          NULL,
                          FALSE);
    if(hr == S_FALSE){
        // property does not exist...so return S_OK
        return S_OK;
    }

    if (SUCCEEDED(hr)) {
        switch (lPreview) {
        case WIA_FINAL_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_FINAL_SCAN"));
            hr = S_OK;
            break;
        default:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to invalid argument (%d)",lPreview));
            hr = E_INVALIDARG;
            break;
        }
    }
    return hr;
}

/**************************************************************************\
* CheckXExtent
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    8/21/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckXExtent(BYTE *pWiasContext,
                                        WIA_PROPERTY_CONTEXT *pContext,
                                        LONG lWidth)
{
    HRESULT hr = S_OK;

    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CheckXExtent");

    LONG lMaxExtent;
    LONG lExt;
    WIAS_CHANGED_VALUE_INFO cviXRes, cviXExt;

    //
    // get x resolution changes
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,FALSE,WIA_IPS_XRES,&cviXRes);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // get x extent changes
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,cviXRes.bChanged,WIA_IPS_XEXTENT,&cviXExt);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // update extent
    //

    lMaxExtent = ((cviXRes.Current.lVal * lWidth) / 1000);

    //
    //  Update read-only property : PIXELS_PER_LINE.  The width in pixels
    //  of the scanned image is the same size as the XExtent.
    //

    if (SUCCEEDED(hr)) {
        hr = wiasWritePropLong(pWiasContext, WIA_IPS_XEXTENT, lMaxExtent);
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lMaxExtent);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascroll\wiascroll.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiascroll.cpp
*
*  VERSION:     1.0
*
*  DATE:        16 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA Sample scanner class factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
CRITICAL_SECTION    g_csCOM;           // COM initialize syncronization.
IWiaLog            *g_pIWiaLog = NULL; // WIA Logging Interface

// Is COM initialized
BOOL    g_COMInitialized = FALSE;


/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }
    LeaveCriticalSection(&g_csCOM);

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    LeaveCriticalSection(&g_csCOM);
    return TRUE;
}

/***************************************************************************\
*
*  CWIAScannerDeviceClassFactory
*
\****************************************************************************/

class CWIAScannerDeviceClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    CWIAScannerDeviceClassFactory();
    ~CWIAScannerDeviceClassFactory();
};

/**************************************************************************\
* CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory, (creating)"));
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::~CWIAScannerDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

CWIAScannerDeviceClassFactory::~CWIAScannerDeviceClassFactory(void)
{
    // Destructor logic
    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory, (destroy)"));
//    WIA_DEBUG_DESTROY();
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDeviceClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDeviceClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    CWIAScannerDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new CWIAScannerDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    hres = pDev->PrivateInitialize();
    if(hres != S_OK) {
        delete pDev;
        return hres;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!IsValid() || !ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWIAScannerDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWIAScannerDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWIAScannerDevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/


extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    HRESULT hr = E_FAIL;
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            
            __try {
                if(!InitializeCriticalSectionAndSpinCount(&g_csCOM, MINLONG)) {
                    return FALSE;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {

            }

            DeleteCriticalSection(&g_csCOM);
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_SampleWIAScannerDevice) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_SampleWIAScannerDevice)) {
        CWIAScannerDeviceClassFactory *pcf = new CWIAScannerDeviceClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\scanner\microsft\wiascroll\wiascroll.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiascroll.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*
*
***************************************************************************/

#include "pch.h"

typedef GUID* PGUID;

#if defined( _WIN32 ) && !defined( _NO_COM)
//////////////////////////////////////////////////////////////////////////
// GUID / CLSID definition section (for your specific device)           //
//                                                                      //
// IMPORTANT!! - REMEMBER TO CHANGE YOUR .INF FILE TO MATCH YOUR WIA    //
//               DRIVER'S CLSID!!                                       //
//                                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// {98B3790C-0D93-4f22-ADAF-51A45B33C998}
DEFINE_GUID(CLSID_SampleWIAScannerDevice,
0x98b3790c, 0xd93, 0x4f22, 0xad, 0xaf, 0x51, 0xa4, 0x5b, 0x33, 0xc9, 0x99);

// {48A89A69-C08C-482a-B3E5-CD50B50B5DFA}
DEFINE_GUID(guidEventFirstLoaded,
0x48a89a69, 0xc08c, 0x482a, 0xb3, 0xe5, 0xcd, 0x50, 0xb5, 0xb, 0x5d, 0xfa);

#endif

//////////////////////////////////////////////////////////////////////////
// DLL #define Section                                                  //
//////////////////////////////////////////////////////////////////////////

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"
#define DATASEG_DEFAULT         DATASEG_SHARED

#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);

#pragma data_seg(DATASEG_PERINSTANCE)
#pragma data_seg(DATASEG_DEFAULT)

extern UINT g_cRefThisDll;
extern UINT g_cLocks;
extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);
extern void DllAddRef(void);
extern void DllRelease(void);

//
// Base structure for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // IUnknown-like methods
    STDMETHOD(NonDelegatingQueryInterface)(THIS_
              REFIID riid,
              LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};

// This sample WIA scanner supports a single scanning context.
#define NUM_DEVICE_ITEM     1

// Device item specific context.
typedef struct _MINIDRIVERITEMCONTEXT{
   LONG     lSize;
   LONG     lTotalWritten;                      // Total image bytes written.
   // Scan parameters:
   LONG     lDepth;                             // image bit depth
   LONG     lBytesPerScanLine;                  // bytes per scan line     (scanned data)
   LONG     lBytesPerScanLineRaw;               // bytes per scan line RAW (scanned data)
   LONG     lTotalRequested;                    // Total image bytes requested.
   // pTransferBuffer information
   LONG     lImageSize;                         // Image
   LONG     lHeaderSize;                        // Transfer header size
} MINIDRIVERITEMCONTEXT, *PMINIDRIVERITEMCONTEXT;

//
// Class definition for sample WIA scanner object
//

class CWIAScannerDevice : public IStiUSD,               // STI USD interface
                          public IWiaMiniDrv,           // WIA Minidriver interface
                          public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWIAScannerDevice(LPUNKNOWN punkOuter);
    HRESULT PrivateInitialize();
    ~CWIAScannerDevice();

private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    BOOL                m_fValid;               // Is object initialized?
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    PSTIDEVICECONTROL   m_pIStiDevControl;      // Device control interface.
    BOOLEAN             m_bUsdLoadEvent;        // Controls load event.
    DWORD               m_dwLastOperationError; // Last error.
    DWORD               m_dwLockTimeout;        // Lock timeout for LockDevice() calls
    BOOL                m_bDeviceLocked;        // device locked/unlocked
    CHAR                *m_pszDeviceNameA;      // CreateFileName for default RawRead/RawWrite handle
    HANDLE              m_DeviceDefaultDataHandle;//default RawRead/RawWrite handle

    // Event information
    CRITICAL_SECTION    m_csShutdown;           // Syncronizes shutdown.
    HANDLE              m_hSignalEvent;         // Signal event handle.
    HANDLE              m_hShutdownEvent;       // Shutdown event handle.
    HANDLE              m_hEventNotifyThread;   // Does event notification.
    GUID                m_guidLastEvent;        // Last event ID.

    // WIA information, one time initialization.
    BSTR                m_bstrDeviceID;         // WIA unique device ID.
    BSTR                m_bstrRootFullItemName; // Device name for prop streams.
    IWiaEventCallback   *m_pIWiaEventCallback;  // WIA event sink.
    IWiaDrvItem         *m_pIDrvItemRoot;       // The root item.
    IStiDevice          *m_pStiDevice;          // Sti object.

    HINSTANCE           m_hInstance;            // Module's HINSTANCE
    IWiaLog             *m_pIWiaLog;            // WIA logging object

    LONG                m_NumSupportedCommands; // Number of supported commands
    LONG                m_NumSupportedEvents;   // Number of supported events

    LONG                m_NumSupportedFormats;  // Number of supported formats
    LONG                m_NumCapabilities;      // Number of capabilities
    LONG                m_NumSupportedTYMED;    // Number of supported TYMED
    LONG                m_NumInitialFormats;    // Number of Initial formats
    LONG                m_NumSupportedDataTypes;// Number of supported data types
    LONG                m_NumSupportedIntents;  // Number of supported intents
    LONG                m_NumSupportedCompressionTypes; // Number of supported compression types
    LONG                m_NumSupportedResolutions; // Number of supported resolutions
    LONG                m_NumSupportedPreviewModes;// Number of supported preview modes

    WIA_FORMAT_INFO     *m_pSupportedFormats;   // supported formats
    WIA_DEV_CAP_DRV     *m_pCapabilities;       // capabilities
    LONG                *m_pSupportedTYMED;     // supported TYMED
    GUID                *m_pInitialFormats;     // initial formats
    LONG                *m_pSupportedDataTypes; // supported data types
    LONG                *m_pSupportedIntents;   // supported intents
    LONG                *m_pSupportedCompressionTypes; // supported compression types
    LONG                *m_pSupportedResolutions;// supported resolutions
    LONG                *m_pSupportedPreviewModes;// supported preview modes

    LONG                m_NumRootItemProperties;// Number of Root item properties
    LONG                m_NumItemProperties;    // Number of item properties

    LPOLESTR            *m_pszRootItemDefaults; // root item property names
    PROPID              *m_piRootItemDefaults;  // root item property ids
    PROPVARIANT         *m_pvRootItemDefaults;  // root item property prop variants
    PROPSPEC            *m_psRootItemDefaults;  // root item property propspecs
    WIA_PROPERTY_INFO   *m_wpiRootItemDefaults; // root item property attributes

    LPOLESTR            *m_pszItemDefaults;     // item property names
    PROPID              *m_piItemDefaults;      // item property ids
    PROPVARIANT         *m_pvItemDefaults;      // item property prop variants
    PROPSPEC            *m_psItemDefaults;      // item property propspecs
    WIA_PROPERTY_INFO   *m_wpiItemDefaults;     // item property attributes

    BOOL                m_bADFEnabled;          // ADF enabled
    BOOL                m_bADFAttached;         // ADF attached

    BOOL                m_bTPAEnabled;          // TPA enabled
    BOOL                m_bTPAAttached;         // TPA attached

    LONG                m_MaxBufferSize;        // Maximum buffer for device
    LONG                m_MinBufferSize;        // Minimum buffer for device

    CFakeScanAPI        *m_pScanAPI;            // FakeScanner API object

    // inline member functions
    BOOL inline IsValid(VOID) {
        return m_fValid;
    }

public:

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHOD(Initialize)(THIS_
        PSTIDEVICECONTROL pHelDcb,
        DWORD             dwStiVersion,
        HKEY              hParametersKey);

    STDMETHOD(GetCapabilities)(THIS_
        PSTI_USD_CAPS pDevCaps);

    STDMETHOD(GetStatus)(THIS_
        PSTI_DEVICE_STATUS pDevStatus);

    STDMETHOD(DeviceReset)(THIS);

    STDMETHOD(Diagnostic)(THIS_
        LPDIAG pBuffer);

    STDMETHOD(Escape)(THIS_
        STI_RAW_CONTROL_CODE EscapeFunction,
        LPVOID               lpInData,
        DWORD                cbInDataSize,
        LPVOID               pOutData,
        DWORD                dwOutDataSize,
        LPDWORD              pdwActualData);

    STDMETHOD(GetLastError)(THIS_
        LPDWORD pdwLastDeviceError);

    STDMETHOD(LockDevice)(THIS);

    STDMETHOD(UnLockDevice)(THIS);

    STDMETHOD(RawReadData)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteData)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawReadCommand)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteCommand)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(SetNotificationHandle)(THIS_
        HANDLE hEvent);

    STDMETHOD(GetNotificationData)(THIS_
        LPSTINOTIFY lpNotify);

    STDMETHOD(GetLastErrorInfo)(THIS_
        STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        BSTR        bstrDeviceID,
        BSTR        bstrRootFullItemName,
        IUnknown    *pStiDevice,
        IUnknown    *pIUnknownOuter,
        IWiaDrvItem **ppIDrvItemRoot,
        IUnknown    **ppIUnknownInner,
        LONG        *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG     lFlags,
        LONG     lDevErrVal,
        LPOLESTR *ppszDevErrStr,
        LONG     *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        const GUID  *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG        *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG lFlags,
        BYTE *pSpecContext,
        LONG *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE            *pWiasContext,
        LONG            ulFlags,
        LONG            *pcelt,
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG            *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE            *pWiasContext,
        LONG            lFlags,
        LONG            *pcelt,
        WIA_FORMAT_INFO **ppwfi,
        LONG            *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID *pEventGUID,
        BSTR       bstrDeviceID,
        ULONG      ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE *pWiasContext);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // This section is for private helpers used for common WIA operations. //
    // These are custom to your driver.                                    //
    //                                                                     //
    //                                                                     //
    // -- WIA Item Management Helpers                                      //
    //    BuildItemTree()                                                  //
    //    DeleteItemTree()                                                 //
    //                                                                     //
    // -- WIA Property Management Helpers                                  //
    //    BuildRootItemProperties()                                        //
    //    BuildTopItemProperties()                                         //
    //                                                                     //
    // -- WIA Capability Management Helpers                                //
    //    BuildRootItemProperties()                                        //
    //    DeleteRootItemProperties()                                       //
    //    BuildTopItemProperties()                                         //
    //    DeleteTopItemProperties()                                        //
    //    BuildCapabilities()                                              //
    //    DeleteCapabilitiesArrayContents()                                //
    //    BuildSupportedFormats()                                          //
    //    DeleteSupportedFormatsArrayContents()                            //
    //    BuildSupportedDataTypes()                                        //
    //    DeleteSupportedDataTypesArrayContents()                          //
    //    BuildSupportedIntents()                                          //
    //    DeleteSupportedIntentsArrayContents()                            //
    //    BuildSupportedCompressions()                                     //
    //    DeleteSupportedCompressionsArrayContents()                       //
    //    BuildSupportedTYMED()                                            //
    //    DeleteSupportedTYMEDArrayContents()                              //
    //    BuildInitialFormats()                                            //
    //    DeleteInitialFormatsArrayContents()                              //
    //                                                                     //
    // -- WIA Validation Helpers                                           //
    //    CheckDataType()                                                  //
    //    CheckIntent()                                                    //
    //    CheckPreferredFormat()                                           //
    //    SetItemSize()                                                    //
    //    UpdateValidDepth()                                               //
    //    ValidateDataTransferContext()                                    //
    //                                                                     //
    // -- WIA Resource file Helpers                                        //
    //    GetBSTRResourceString()                                          //
    //    GetOLESTRResourceString()                                        //
    //                                                                     //
    // -- WIA Data acqusition Helpers                                      //
    //    ScanItem()                                                       //
    //    ScanItemCB()                                                     //
    //    SendImageHeader()                                               //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    HRESULT _stdcall BuildItemTree(void);

    HRESULT _stdcall DeleteItemTree(void);

    HRESULT BuildRootItemProperties();

    HRESULT DeleteRootItemProperties();

    HRESULT BuildTopItemProperties();

    HRESULT DeleteTopItemProperties();

    HRESULT BuildCapabilities();

    HRESULT DeleteCapabilitiesArrayContents();

    HRESULT BuildSupportedFormats();

    HRESULT DeleteSupportedFormatsArrayContents();

    HRESULT BuildSupportedDataTypes();

    HRESULT DeleteSupportedDataTypesArrayContents();

    HRESULT BuildSupportedIntents();

    HRESULT DeleteSupportedIntentsArrayContents();

    HRESULT BuildSupportedCompressions();

    HRESULT DeleteSupportedCompressionsArrayContents();

    HRESULT BuildSupportedPreviewModes();

    HRESULT DeleteSupportedPreviewModesArrayContents();

    HRESULT BuildSupportedTYMED();

    HRESULT DeleteSupportedTYMEDArrayContents();

    HRESULT BuildSupportedResolutions();

    HRESULT DeleteSupportedResolutionsArrayContents();

    HRESULT BuildInitialFormats();

    HRESULT DeleteInitialFormatsArrayContents();

    HRESULT CheckDataType(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckIntent(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckPreferredFormat(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckADFStatus(BYTE *pWiasContext,
                           WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckPreview(BYTE *pWiasContext,
                         WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckXExtent(BYTE *pWiasContext,
                         WIA_PROPERTY_CONTEXT *pContext,
                         LONG lWidth);

    HRESULT UpdateValidDepth(
        BYTE *pWiasContext,
        LONG lDataType,
        LONG *lDepth);

    HRESULT ValidateDataTransferContext(
        PMINIDRV_TRANSFER_CONTEXT pDataTransferContext);

    HRESULT SetItemSize(
        BYTE *pWiasContext);

    HRESULT _stdcall ScanItem(
        PMINIDRIVERITEMCONTEXT,
        PMINIDRV_TRANSFER_CONTEXT,
        LONG*);

    HRESULT _stdcall ScanItemCB(
        PMINIDRIVERITEMCONTEXT,
        PMINIDRV_TRANSFER_CONTEXT,
        LONG*);

    HRESULT SendImageHeader(
        PMINIDRV_TRANSFER_CONTEXT pmdtc);

    HRESULT SendFilePreviewImageHeader(
        PMINIDRV_TRANSFER_CONTEXT pmdtc);

    HRESULT GetBSTRResourceString(
        LONG lLocalResourceID,
        BSTR *pBSTR,
        BOOL bLocal);

    HRESULT GetOLESTRResourceString(
        LONG lLocalResourceID,
        LPOLESTR *ppsz,
        BOOL bLocal);

    UINT AlignInPlace(
        PBYTE   pBuffer,
        LONG    cbWritten,
        LONG    lBytesPerScanLine,
        LONG    lBytesPerScanLineRaw);

    VOID VerticalFlip(
        PMINIDRIVERITEMCONTEXT     pDrvItemContext,
        PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext);

    VOID SwapBuffer24(
        PBYTE pBuffer,
        LONG lByteCount);

    LONG GetPageCount(
        BYTE *pWiasContext);

    BOOL IsPreviewScan(
        BYTE *pWiasContext);

public:
    HRESULT DoEventProcessing();
};

typedef CWIAScannerDevice *PWIASCANNERDEVICE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\sti\sampcpl\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sampusd.rc
// Copyright (c) Microsoft 1998, All Rights Reserved
//
#define IDC_STATIC                      -1
#define IDD_PAGE_GENERAL                106
#define IDC_EDIT_PATH                   1000
#define IDC_BUTTON_BROWSE               1001

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\sti\sampcpl\sampcpl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       sampcpl.h
//
//--------------------------------------------------------------------------

// Copyright (c) Microsoft 1998, All Rights Reserved

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include <sti.h>
#include <stireg.h>
#include <stierr.h>
#include <stiusd.h>

#if !defined(DLLEXPORT)
#define DLLEXPORT __declspec( dllexport )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\sti\sampusd\device.cpp ===
/****************************************************************************
 *
 *  DEVICE.CPP
 *
 *  Copyright (C) Microsoft Corporation 1996-1999
 *  All rights reserved
 *
 ***************************************************************************/

#include "Sampusd.h"

#include <stdio.h>

VOID
FileChangeThread(
    LPVOID  lpParameter
    );


UsdSampDevice::UsdSampDevice( LPUNKNOWN punkOuter ):
    m_cRef(1),
    m_punkOuter(NULL),
    m_fValid(FALSE),
    m_pDcb(NULL),
    m_DeviceDataHandle(INVALID_HANDLE_VALUE),
    m_hSignalEvent(INVALID_HANDLE_VALUE),
    m_hThread(NULL),
    m_guidLastEvent(GUID_NULL),
    m_EventSignalState(TRUE)
{

    //
    // See if we are aggregated. If we are ( which will be almost always the case )
    // save pointer to controlling Unknown , so subsequent calls will be delegated
    // If not, set the same pointer to "this" .
    // N.b. cast below is important in order to point to right virtual table
    //
    if (punkOuter) {
        m_punkOuter = punkOuter;
    }
    else {
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }

    m_hShutdownEvent =  CreateEvent( NULL,   // Attributes
                                   TRUE,     // Manual reset
                                   FALSE,    // Initial state - not set
                                   NULL );   // Anonymous

    if ( (INVALID_HANDLE_VALUE !=m_hShutdownEvent) && (NULL != m_hShutdownEvent)) {
        m_fValid = TRUE;
    }
}

UsdSampDevice::~UsdSampDevice( VOID )
{
    // Kill notification thread if it exists
    SetNotificationHandle(NULL);

    if (m_hShutdownEvent && m_hShutdownEvent!=INVALID_HANDLE_VALUE) {
        CloseHandle(m_hShutdownEvent);
    }

    if( INVALID_HANDLE_VALUE != m_DeviceDataHandle ) {
        CloseHandle( m_DeviceDataHandle );
    }

    if (m_pszDeviceNameA) {
        delete [] m_pszDeviceNameA;
        m_pszDeviceNameA = NULL;
    }
}

STDMETHODIMP UsdSampDevice::GetCapabilities( PSTI_USD_CAPS pUsdCaps )
{
    HRESULT hres = STI_OK;

    ZeroMemory(pUsdCaps,sizeof(*pUsdCaps));

    pUsdCaps->dwVersion = STI_VERSION;

    // We do support device notifications, but not reuiring polling
    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT;

    return hres;
}

STDMETHODIMP UsdSampDevice::GetStatus( PSTI_DEVICE_STATUS pDevStatus )
{
    HRESULT hres = STI_OK;

    //
    // If we are asked, verify whether device is online
    //
    pDevStatus->dwOnlineState = 0L;
    if( pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE )  {
        if (INVALID_HANDLE_VALUE != m_DeviceDataHandle) {
            // File is always on-line
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }
    }

    //
    // If we are asked, verify state of event
    //
    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;
    if( pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE ) {

        //
        // Launch app very first time we load
        //
        if(m_EventSignalState) {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;

            m_guidLastEvent = guidEventFirstLoaded;

            m_EventSignalState = FALSE;
        }

        if (IsChangeDetected(NULL,FALSE)) {
            pDevStatus->dwEventHandlingState |= STI_EVENTHANDLING_PENDING;
        }
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::DeviceReset( VOID )
{
    HRESULT hres = STI_OK;

    // Reset current active device
    if (INVALID_HANDLE_VALUE != m_DeviceDataHandle) {

        ::SetFilePointer( m_DeviceDataHandle, 0, NULL, FILE_BEGIN);

        m_dwLastOperationError = ::GetLastError();
    }

    hres = HRESULT_FROM_WIN32(m_dwLastOperationError);

    return hres;
}

STDMETHODIMP UsdSampDevice::Diagnostic( LPDIAG pBuffer )
{
    HRESULT hres = STI_OK;

    // Initialize response buffer
    pBuffer->dwStatusMask = 0;

    ZeroMemory(&pBuffer->sErrorInfo,sizeof(pBuffer->sErrorInfo));

    pBuffer->sErrorInfo.dwGenericError = NOERROR;
    pBuffer->sErrorInfo.dwVendorError = 0;

    // This example always returns that the unit passed diagnostics

    return hres;
}

STDMETHODIMP UsdSampDevice:: SetNotificationHandle( HANDLE hEvent )
// SYNCHRONIZED
{
    HRESULT hres = STI_OK;

    TAKE_CRIT_SECT t(m_cs);

    if (hEvent && (hEvent !=INVALID_HANDLE_VALUE)) {

        m_hSignalEvent = hEvent;

        if (m_DeviceDataHandle != INVALID_HANDLE_VALUE) {
            //
            // if we need to be asyncronous, create notification thread
            //
            m_dwAsync = 1;
            m_guidLastEvent = GUID_NULL;

            if (m_dwAsync) {

                if (!m_hThread) {

                    DWORD   dwThread;

                    m_hThread = ::CreateThread(NULL,
                                           0,
                                           (LPTHREAD_START_ROUTINE)FileChangeThread,
                                           (LPVOID)this,
                                           0,
                                           &dwThread);

                    m_pDcb->WriteToErrorLog(STI_TRACE_INFORMATION,
                                    L"SampUSD::Enabling notification monitoring",
                                    NOERROR) ;
                }
            }
            else {
                hres = STIERR_UNSUPPORTED;
            }
        }
        else {
            hres = STIERR_NOT_INITIALIZED;
        }
    }
    else {

        //
        // Disable hardware notifications
        //
        SetEvent(m_hShutdownEvent);
        if ( m_hThread ) {
            WaitForSingleObject(m_hThread,400);
            CloseHandle(m_hThread);
            m_hThread = NULL;
            m_guidLastEvent = GUID_NULL;
        }

        m_pDcb->WriteToErrorLog(STI_TRACE_INFORMATION,
                        L"SampUSD::Disabling notification monitoring",
                        NOERROR) ;

    }

    return hres;
}


STDMETHODIMP UsdSampDevice::GetNotificationData( LPSTINOTIFY pBuffer )
// SYNCHRONIZED
{
    HRESULT hres = STI_OK;

    TAKE_CRIT_SECT t(m_cs);

    //
    // If we have notification ready - return it's guid
    //
    if (!IsEqualIID(m_guidLastEvent,GUID_NULL)) {
        pBuffer->guidNotificationCode  = m_guidLastEvent;
        m_guidLastEvent = GUID_NULL;
        pBuffer->dwSize = sizeof(STINOTIFY);
    }
    else {
        hres = STIERR_NOEVENTS;
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::Escape( STI_RAW_CONTROL_CODE    EscapeFunction,
                                    LPVOID                  pInData,
                                    DWORD                   cbInDataSize,
                                    LPVOID                  pOutData,
                                    DWORD                   cbOutDataSize,
                                    LPDWORD                 pcbActualData )
{
    HRESULT hres = STI_OK;
    //
    // Write indata to device  if needed.
    //

    hres = STIERR_UNSUPPORTED;
    return hres;
}

STDMETHODIMP UsdSampDevice::GetLastError( LPDWORD pdwLastDeviceError )
// SYNCHRONIZED
{
    HRESULT hres = STI_OK;

    TAKE_CRIT_SECT t(m_cs);

    if ( IsBadWritePtr( pdwLastDeviceError,4 ))
    {
        hres = STIERR_INVALID_PARAM;
    }
    else
    {
        *pdwLastDeviceError = m_dwLastOperationError;
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
// SYNCHRONIZED
{
    HRESULT hres = STI_OK;

    TAKE_CRIT_SECT t(m_cs);

    if ( IsBadWritePtr( pLastErrorInfo,4 ))
    {
        hres = STIERR_INVALID_PARAM;
    }
    else
    {
        pLastErrorInfo->dwGenericError = m_dwLastOperationError;
        pLastErrorInfo->szExtendedErrorText[0] = L'\0';
    }

    return hres;
}


STDMETHODIMP UsdSampDevice::LockDevice( VOID )
{
    HRESULT hres = STI_OK;

    return hres;
}

STDMETHODIMP UsdSampDevice::UnLockDevice( VOID )
{
    HRESULT hres = STI_OK;

    return hres;
}

STDMETHODIMP UsdSampDevice::RawReadData( LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes,
                                        LPOVERLAPPED lpOverlapped )
{
    HRESULT hres = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDataHandle)
    {
        m_dwLastOperationError = NOERROR;

        fRet = ::ReadFile(m_DeviceDataHandle,
                    lpBuffer,
                    *lpdwNumberOfBytes,
                    lpdwNumberOfBytes,
                    lpOverlapped);

        if (!fRet) {
            m_dwLastOperationError = ::GetLastError();
        }

        hres = HRESULT_FROM_WIN32(m_dwLastOperationError);
    }
    else
    {
        hres = STIERR_NOT_INITIALIZED;
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::RawWriteData( LPVOID lpBuffer, DWORD dwNumberOfBytes,
                                            LPOVERLAPPED lpOverlapped )
{
    HRESULT hres = STI_OK;
    BOOL    fRet = FALSE;;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDataHandle)
    {
        fRet = ::WriteFile(m_DeviceDataHandle,
                            lpBuffer,
                            dwNumberOfBytes,
                            &dwBytesReturned,
                            lpOverlapped);

        if (!fRet) {
            m_dwLastOperationError = ::GetLastError();
        }

        hres = HRESULT_FROM_WIN32(m_dwLastOperationError);

    }
    else
    {
        hres = STIERR_NOT_INITIALIZED;
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::RawReadCommand( LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes,
                                            LPOVERLAPPED lpOverlapped )
{
    HRESULT hres = STIERR_UNSUPPORTED;

    return hres;
}

STDMETHODIMP UsdSampDevice::RawWriteCommand( LPVOID lpBuffer, DWORD nNumberOfBytes,
                                            LPOVERLAPPED lpOverlapped )
{
    HRESULT hres = STIERR_UNSUPPORTED;

    return hres;
}


STDMETHODIMP UsdSampDevice::Initialize( PSTIDEVICECONTROL pDcb, DWORD dwStiVersion,
                                        HKEY hParametersKey )
{
    HRESULT hres = STI_OK;
    UINT    uiNameLen = 0;
    WCHAR   szDeviceNameW[MAX_PATH];


    if (!pDcb) {
        return STIERR_INVALID_PARAM;
    }

    *szDeviceNameW = L'\0';

    // Check STI specification version number
    m_pDcb = pDcb;
    m_pDcb->AddRef();

    // Get the name of the device port we need to open
    hres = m_pDcb->GetMyDevicePortName(szDeviceNameW,sizeof(szDeviceNameW)/sizeof(WCHAR));
    if (!SUCCEEDED(hres) || !*szDeviceNameW) {
        return hres;
    }

    // Convert name to SBCS
    uiNameLen = WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, NULL, NULL, 0, 0);
    if (!uiNameLen) {
        return STIERR_INVALID_PARAM;
    }

    m_pszDeviceNameA = new CHAR[uiNameLen+1];
    if (!m_pszDeviceNameA) {
        return STIERR_INVALID_PARAM;
    }

    WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, m_pszDeviceNameA, uiNameLen, 0, 0);

    //
    // Open device ourselves
    //
    m_DeviceDataHandle = CreateFileA( m_pszDeviceNameA,
                                     GENERIC_READ ,                     // Access mask
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,    // Share mode
                                     NULL,                              // SA
                                     OPEN_EXISTING,                     // Create disposition
                                     FILE_ATTRIBUTE_SYSTEM,             // Attributes
                                     NULL );
    m_dwLastOperationError = ::GetLastError();

    hres = (m_DeviceDataHandle != INVALID_HANDLE_VALUE) ?
                S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,m_dwLastOperationError);

    return hres;

}

VOID
UsdSampDevice::
RunNotifications(VOID)
{

    HANDLE  hNotifyFileSystemChange = INVALID_HANDLE_VALUE;
    DWORD   dwErr;

    CHAR    szDirPath[MAX_PATH];
    CHAR    *pszLastSlash;

    //
    // Find name of the parent directory for out file and set up waiting on any
    // changes in it.
    //
    lstrcpyA(szDirPath,m_pszDeviceNameA);
    pszLastSlash = strrchr(szDirPath,'\\');
    if (pszLastSlash) {
        *pszLastSlash = '\0';
    }

    hNotifyFileSystemChange = FindFirstChangeNotificationA(
                                szDirPath,
                                FALSE,
                                FILE_NOTIFY_CHANGE_SIZE |
                                FILE_NOTIFY_CHANGE_LAST_WRITE |
                                FILE_NOTIFY_CHANGE_FILE_NAME |
                                FILE_NOTIFY_CHANGE_DIR_NAME
                                );

    if (hNotifyFileSystemChange == INVALID_HANDLE_VALUE) {
        dwErr = ::GetLastError();
        return;
    }

    // Set initial values for time and size
    IsChangeDetected(NULL);

    //
    HANDLE  hEvents[2] = {m_hShutdownEvent,hNotifyFileSystemChange};
    BOOL    fLooping = TRUE;

    while (fLooping) {
        dwErr = ::WaitForMultipleObjects(2,
                                         hEvents,
                                         FALSE,
                                         INFINITE );
        switch(dwErr) {
            case WAIT_OBJECT_0+1:

                // Change detected - signal
                if (m_hSignalEvent !=INVALID_HANDLE_VALUE) {

                    // Which change ?
                    if (IsChangeDetected(&m_guidLastEvent)) {

                        m_pDcb->WriteToErrorLog(STI_TRACE_INFORMATION,
                                        L"SampUSD::Monitored file change detected",
                                        NOERROR) ;


                        ::SetEvent(m_hSignalEvent);
                    }
                }

                // Go back to waiting for next file system event
                FindNextChangeNotification(hNotifyFileSystemChange);
                break;

            case WAIT_OBJECT_0:
                // Fall through
            default:
                fLooping = FALSE;
        }
    }

    FindCloseChangeNotification(hNotifyFileSystemChange);
}

BOOL
UsdSampDevice::
IsChangeDetected(
    GUID    *pguidEvent,
    BOOL    fRefresh    // TRUE
    )
{

    BOOL            fRet = FALSE;
    LARGE_INTEGER   liNewHugeSize;
    FILETIME        ftLastWriteTime;
    DWORD           dwError;

    WIN32_FILE_ATTRIBUTE_DATA sNewFileAttributes;

    ZeroMemory(&sNewFileAttributes,sizeof(sNewFileAttributes));

    dwError = NOERROR;

    if ( GetFileAttributesExA(m_pszDeviceNameA,GetFileExInfoStandard, &sNewFileAttributes)) {

        ftLastWriteTime =sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart= sNewFileAttributes.nFileSizeHigh ;
    }
    else {

        BY_HANDLE_FILE_INFORMATION sFileInfo;

        if (GetFileInformationByHandle(m_DeviceDataHandle,&sFileInfo)) {
            ftLastWriteTime =sFileInfo.ftLastWriteTime;
            liNewHugeSize.LowPart = sFileInfo.nFileSizeLow;
            liNewHugeSize.HighPart= sFileInfo.nFileSizeHigh ;
        }
        else {
            dwError = ::GetLastError();
        }
    }

    if (NOERROR == dwError ) {

        //
        // First check size, because it is easy to change time without changing size
        //
        if (m_dwLastHugeSize.QuadPart != liNewHugeSize.QuadPart) {
            if (pguidEvent) {
                *pguidEvent = guidEventSizeChanged;
            }
            fRet = TRUE;
        }
        else {
            if (CompareFileTime(&m_ftLastWriteTime,&ftLastWriteTime) == -1 ) {
                if (pguidEvent) {
                    *pguidEvent = guidEventTimeChanged;
                }
                fRet = TRUE;
            }
            else {
                // Nothing really changed
            }
        }

        m_ftLastWriteTime = ftLastWriteTime;
        m_dwLastHugeSize = liNewHugeSize;
    }

    return fRet;
}

VOID
FileChangeThread(
    LPVOID  lpParameter
    )
{
    UsdSampDevice   *pThisDevice = (UsdSampDevice *)lpParameter;

    pThisDevice->RunNotifications();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\sti\sampusd\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

// Copyright (c) Microsoft 1998, All Rights Reserved
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\sti\sampusd\sampusd.cpp ===
/****************************************************************************
 *
 *  SampUSD.CPP
 *
 *  Copyright (C) Microsoft Corporation 1996-1999
 *  All rights reserved
 *
 ***************************************************************************/

#define INITGUID

#include "Sampusd.h"
#include "resource.h"

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

// Reference counter for the whole library
DWORD       g_cRef;

// DLL module instance
HINSTANCE   g_hInst;

// Critical section for low level syncronization
CRITICAL_SECTION g_crstDll;

// Can we use UNICODE APIs
BOOL    g_NoUnicodePlatform = TRUE;

// Is COM initialized
BOOL    g_COMInitialized = FALSE;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.
 *
 *****************************************************************************/

void
DllEnterCrit(void)
{
    EnterCriticalSection(&g_crstDll);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void
DllLeaveCrit(void)
{
    LeaveCriticalSection(&g_crstDll);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllAddRef |
 *
 *          Increment the reference count on the DLL.
 *
 *****************************************************************************/

void
DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRelease |
 *
 *          Decrement the reference count on the DLL.
 *
 *****************************************************************************/

void
DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllInitializeCOM |
 *
 *          Initialize COM libraries
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          Returns a boolean error code.
 *
 *****************************************************************************/

BOOL
DllInitializeCOM(
    void
    )
{
    DllEnterCrit();

    if(!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }

    DllLeaveCrit();

    return g_COMInitialized;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllUnInitializeCOM |
 *
 *          UnInitialize COM libraries
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          Returns a boolean error code.
 *
 *****************************************************************************/
BOOL
DllUnInitializeCOM(
    void
    )
{
    DllEnterCrit();

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    DllLeaveCrit();

    return TRUE;
}

/*****************************************************************************
 *
 *  @class UsdSampClassFactory |
 *
 *****************************************************************************/

class UsdSampClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    UsdSampClassFactory();
};

UsdSampClassFactory::UsdSampClassFactory()
{
    //DEBUGPRINTF((DBG_LVL_DEBUG, TEXT("UsdSampClassFactory: Constructor")));

    // Constructor logic
    m_cRef = 0;
}


STDMETHODIMP UsdSampClassFactory::QueryInterface(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    // DEBUGPRINTF((DBG_LVL_DEBUG, TEXT("UsdSampClassFactory: QueryInterface")));

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) UsdSampClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) UsdSampClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}


STDMETHODIMP UsdSampClassFactory::CreateInstance(
    /* [unique][in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{

    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested, so fail
    // call if not.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    UsdSampDevice    *pDev = NULL;
    HRESULT         hres;

    pDev = new UsdSampDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    //
    // Move to the requested interface
    //
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}


STDMETHODIMP UsdSampClassFactory::LockServer(
    /* [in] */ BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }

    return NOERROR;
}

/*****************************************************************************
 *
 *  @class UsdSampDevice | INonDelegatingUnknown
 *
 *****************************************************************************/
STDMETHODIMP UsdSampDevice::NonDelegatingQueryInterface( REFIID riid, LPVOID* ppvObj )
{
    HRESULT hres;

    if( !IsValid() || !ppvObj )
    {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if( IsEqualIID( riid, IID_IUnknown ))
    {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
        hres = S_OK;
    }
    else if( IsEqualIID( riid, IID_IStiUSD ))
    {
        *ppvObj = static_cast<IStiUSD*>(this);
        hres = S_OK;
    }
    else
    {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}


STDMETHODIMP_(ULONG) UsdSampDevice::NonDelegatingAddRef( VOID )
{
    ULONG ulRef;
    ulRef = InterlockedIncrement((LPLONG)&m_cRef);
    return ulRef;
}

STDMETHODIMP_(ULONG) UsdSampDevice::NonDelegatingRelease( VOID )
{
    ULONG ulRef;
    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if(!ulRef)
    {
        delete this;
    }

    return ulRef;
}

/*****************************************************************************
 *
 *  @class UsdSampDevice | IUnknown (Delegating)
 *
 *         Delegating unknown methods.
 *
 *****************************************************************************/

STDMETHODIMP UsdSampDevice::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}


STDMETHODIMP_(ULONG) UsdSampDevice::AddRef( VOID )
{
    return m_punkOuter->AddRef();
}

STDMETHODIMP_(ULONG) UsdSampDevice::Release( VOID )
{
    return m_punkOuter->Release();
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllEntryPoint |
 *
 *          Called to notify the DLL about various things that can happen.
 *
 *          We are not interested in thread attaches and detaches,
 *          so we disable thread notifications for performance reasons.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          The instance handle of this DLL.
 *
 *  @parm   DWORD | dwReason |
 *
 *          Notification code.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Not used.
 *
 *  @returns
 *
 *          Returns <c TRUE> to allow the DLL to load.
 *
 *****************************************************************************/


extern "C"
DLLEXPORT
BOOL APIENTRY
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

        g_hInst = hinst;

        // Disable thread library calls to avoid
        // deadlock when we spin up the worker thread

        DisableThreadLibraryCalls(hinst);
        InitializeCriticalSection(&g_crstDll);

        // Set global flags
        // g_NoUnicodePlatform = !OSUtil_IsPlatformUnicode();

        break;

    case DLL_PROCESS_DETACH:
        if (g_cRef) {
            // DPRINTF("Sampusd: Unloaded before all objects Release()d! Crash soon!\r\n");
        }

        // Free COM libraries if connected to them
        // DllUnInitializeCOM();

        break;
    }

    return 1;
}


extern "C"
DLLEXPORT
BOOL WINAPI
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    return DllEntryPoint(hinst, dwReason, lpReserved);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllCanUnloadNow |
 *
 *          Determine whether the DLL has any outstanding interfaces.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the DLL can unload, <c S_FALSE> if
 *          it is not safe to unload.
 *
 *****************************************************************************/
extern "C"
STDMETHODIMP
DllCanUnloadNow(void)
{
    HRESULT hres;

    hres = g_cRef ? S_FALSE : S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllGetClassObject |
 *
 *          Create an <i IClassFactory> instance for this DLL.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The object being requested.
 *
 *  @parm   RIID | riid |
 *
 *          The desired interface on the object.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Output pointer.
 *
 *  @notes
 *          We support only one class of objects , so this function does not need
 *          to go through table of supported classes , looking for proper constructor
 *
 *
 *****************************************************************************/
extern "C"
STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{

    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_SampUSDObj) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_SampUSDObj)) {
        UsdSampClassFactory *pcf = new UsdSampClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\sti\sampcpl\sampcpl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sampcpl.cpp
//
//--------------------------------------------------------------------------


#define INITGUID

#include "Sampcpl.h"
#include <prsht.h>
#include "resource.h"

BOOL WINAPI IsPlatformNT();

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

// Reference counter for the whole library
DWORD       g_cRef;

// DLL module instance
HINSTANCE   g_hInst;

// Can we use UNICODE APIs
BOOL    g_NoUnicodePlatform = TRUE;

// Is COM initialized
BOOL    g_COMInitialized = FALSE;

//
PSTI        g_pSti = NULL;

/*****************************************************************************
 *
 *     Code
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllEntryPoint |
 *
 *          Called to notify the DLL about various things that can happen.
 *
 *          We are not interested in thread attaches and detaches,
 *          so we disable thread notifications for performance reasons.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          The instance handle of this DLL.
 *
 *  @parm   DWORD | dwReason |
 *
 *          Notification code.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Not used.
 *
 *  @returns
 *
 *          Returns <c TRUE> to allow the DLL to load.
 *
 *****************************************************************************/


extern "C"
DLLEXPORT
BOOL APIENTRY
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

        g_hInst = hinst;

        ::DisableThreadLibraryCalls(hinst);

        // Set global flags
        g_NoUnicodePlatform = !IsPlatformNT();

        break;

    case DLL_PROCESS_DETACH:
        if (g_cRef) {
        }

        break;
    }

    return 1;
}


extern "C"
DLLEXPORT
BOOL WINAPI
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    return DllEntryPoint(hinst, dwReason, lpReserved);
}

INT_PTR
CALLBACK
USDSampPropDialog(
    HWND    hwnd,
    UINT    uMessage,
    WPARAM  wp,
    LPARAM  lp
    )
{
    PSTI_DEVICE_INFORMATION psdi;
    HRESULT     hres;

    switch (uMessage)
    {
        case WM_INITDIALOG:

            //  On WM_INITDIALOG, the LPARAM points at the PROPSHEETPAGE that created
            //  us.  We walk down to the lParam member to find the pointer to this
            //  STI device.
           TCHAR szPath[MAX_PATH];

            // Request STI interface pointer
            g_pSti = NULL;

            hres = ::StiCreateInstance(::GetModuleHandle(NULL),
                                        STI_VERSION,
                                        &g_pSti,
                                        NULL);

            psdi = (PSTI_DEVICE_INFORMATION) ((LPPROPSHEETPAGE) lp) -> lParam;

            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) psdi);

            *szPath = TEXT('\0');

            #ifndef UNICODE
            WideCharToMultiByte(CP_ACP, 0,
                                psdi->pszPortName,-1,
                                szPath,sizeof(szPath),
                                NULL,NULL);
            #else
            lstrcpy(szPath,psdi->pszPortName);
            #endif

            Edit_SetText(GetDlgItem(hwnd,IDC_EDIT_PATH),szPath);
            Edit_LimitText(GetDlgItem(hwnd,IDC_EDIT_PATH), MAX_PATH);

            return TRUE;

        case WM_COMMAND:
            {
                if (GET_WM_COMMAND_ID(wp,lp) == IDC_BUTTON_BROWSE &&
                    GET_WM_COMMAND_CMD(wp,lp) == BN_CLICKED) {

                    static  TCHAR    szAppFilter[]=TEXT("Files\0*.*\0All Files\0*.*\0");

                    TCHAR szFileName[MAX_PATH];
                    OPENFILENAME ofn;

                    DWORD   dwLastError;

                    szFileName[0] = TEXT('\0');

                    /* prompt user for file to open */
                    ofn.lStructSize = sizeof(OPENFILENAME);
                    ofn.hwndOwner = hwnd;
                    ofn.hInstance = NULL;
                    ofn.lpstrFilter = szAppFilter;
                    ofn.lpstrCustomFilter = NULL;
                    ofn.nMaxCustFilter = 0;
                    ofn.nFilterIndex = 0;
                    ofn.lpstrFile = szFileName;
                    ofn.nMaxFile = sizeof(szFileName);
                    ofn.lpstrFileTitle = NULL;
                    ofn.nMaxFileTitle = 0;
                    ofn.lpstrInitialDir = NULL;
                    ofn.lpstrTitle = NULL;
                    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER;
                    ofn.nFileOffset = 0;
                    ofn.nFileExtension = 0;
                    ofn.lpstrDefExt = NULL;
                    ofn.lCustData = 0;
                    ofn.lpfnHook = NULL;
                    ofn.lpTemplateName = NULL;

                    if (GetOpenFileName(&ofn)) {
                        Edit_SetText(GetDlgItem(hwnd,IDC_EDIT_PATH),szFileName);
                    }
                    else {
                        dwLastError = ::GetLastError();
                    }

                    return TRUE;
                }
                else
                    if (GET_WM_COMMAND_ID(wp,lp) == IDC_EDIT_PATH  &&
                        GET_WM_COMMAND_CMD(wp,lp) == EN_CHANGE ) {
                        // Enable Apply button
                            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
                        return TRUE;
                    }

            }
            break;

        case WM_DESTROY:
            // Destroy things
            g_pSti->Release();
            g_pSti = NULL;
            break;

        case WM_NOTIFY:
            {
                LPNMHDR lpnmh = (LPNMHDR) lp;

                if ( lpnmh -> code == PSN_APPLY ) {

                    // Write path to the registry

                    psdi = (PSTI_DEVICE_INFORMATION)GetWindowLong(hwnd, DWLP_USER);

                    if (psdi && g_pSti) {

                        TCHAR    szPath[MAX_PATH];
                        WCHAR   wszPath[MAX_PATH];

                        szPath[0] = '\0';
                        wszPath[0] = L'\0';

                        g_pSti->WriteToErrorLog(STI_TRACE_INFORMATION,
                                                L"Writing new path to the registry for Sample USD"
                                                );


                        GetWindowText(GetDlgItem(hwnd,IDC_EDIT_PATH),szPath,sizeof(szPath));

                        if (*szPath) {

                            HRESULT hres;
                            STI_DEVICE_INFORMATION  sdiNew;
                            STI_DEVICE_INFORMATION  *psdiNew = &sdiNew;

                            CopyMemory(psdiNew,psdi,sizeof(STI_DEVICE_INFORMATION));

                            #ifndef UNICODE
                            MultiByteToWideChar(CP_ACP, 0,
                                                szPath,-1,
                                                wszPath,sizeof(wszPath));
                            #else
                            lstrcpy(wszPath,szPath);
                            #endif

                            psdiNew->pszPortName = wszPath;

                            hres = g_pSti->SetupDeviceParameters(psdiNew);

                            if (!SUCCEEDED(hres)) {
                                g_pSti->WriteToErrorLog(STI_TRACE_ERROR,
                                                        L"Could not save new port name"
                                                        );
                            }
                        }
                    }
                }
            }

        default:   ;
    }

    return  FALSE;
}

PROPSHEETPAGE    psp = {sizeof psp, PSP_DEFAULT };

typedef BOOL    (WINAPI *ADDER)(HPROPSHEETPAGE hpsp, LPARAM lp);

extern "C"
BOOL
WINAPI
EnumStiPropPages(
    PSTI_DEVICE_INFORMATION psdi,
    ADDER                   adder,
    LPARAM lp
    ) {

    psp.hInstance = g_hInst;

    psp.pszTemplate = MAKEINTRESOURCE(IDD_PAGE_GENERAL);
    psp.pfnDlgProc = USDSampPropDialog;
    psp.lParam = (LPARAM) psdi;

    HPROPSHEETPAGE  hpsp = CreatePropertySheetPage(&psp);

    if  (!hpsp || !(*adder)(hpsp, lp)) {
        if  (hpsp)  {
            DestroyPropertySheetPage(hpsp);
        }

        return  FALSE;  //  We failed to add anything...
    }

    return  TRUE;
}


BOOL WINAPI
IsPlatformNT(
    VOID
    )
{
    OSVERSIONINFO  ver;
    BOOL            bReturn = FALSE;

    ZeroMemory(&ver,sizeof(ver));
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(!GetVersionEx(&ver)) {
        bReturn = FALSE;
    }
    else {
        switch(ver.dwPlatformId) {

            case VER_PLATFORM_WIN32_WINDOWS:
                bReturn = FALSE;
                break;

            case VER_PLATFORM_WIN32_NT:
                bReturn = TRUE;
                break;

            default:
                bReturn = FALSE;
                break;
        }
    }

    return bReturn;

}  //  endproc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\sti\sampusd\sampusd.h ===
/****************************g************************************************
 *
 *  SampUSD.H
 *
 *  Copyright (C) Microsoft Corporation 1996-1997
 *  All rights reserved
 *
 ***************************************************************************/

//#define WIN32_LEAN_AND_MEAN

#include <windows.h>

#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include "sti.h"
#include "stierr.h"
#include "stiusd.h"

#if !defined(DLLEXPORT)
#define DLLEXPORT __declspec( dllexport )
#endif

/*
 * Class IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)

// This GUID must match that use in the .inf file for this device.

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

// {61127F40-E1A5-11D0-B454-00A02438AD48}
DEFINE_GUID(guidEventTimeChanged, 0x61127F40L, 0xE1A5, 0x11D0, 0xB4, 0x54, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventSizeChanged, 0x052ED270L, 0x28A3, 0x11D1, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventFirstLoaded, 0x052ED270L, 0x28A3, 0x11D3, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);


// {C3A80960-28B1-11D1-ACAD-00A02438AD48}
DEFINE_GUID(CLSID_SampUSDObj, 0xC3A80960L, 0x28B1, 0x11D1, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

#endif


#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"

#define DATASEG_DEFAULT         DATASEG_SHARED

#pragma data_seg(DATASEG_PERINSTANCE)

// Set the default data segment
#pragma data_seg(DATASEG_DEFAULT)

//
// Module ref counting
//
extern  UINT g_cRefThisDll;
extern  UINT g_cLocks;
extern  HINSTANCE   g_hInst;

extern  BOOL DllInitializeCOM(void);
extern  BOOL DllUnInitializeCOM(void);

extern  void DllAddRef(void);
extern  void DllRelease(void);

//
// Auto critical section clss
//

class CRIT_SECT
{
public:
    void Lock() {EnterCriticalSection(&m_sec);}
    void Unlock() {LeaveCriticalSection(&m_sec);}
    CRIT_SECT() {InitializeCriticalSection(&m_sec);}
    ~CRIT_SECT() {DeleteCriticalSection(&m_sec);}
    CRITICAL_SECTION m_sec;
};

class TAKE_CRIT_SECT
{
private:
    CRIT_SECT& _syncres;

public:
    inline TAKE_CRIT_SECT(CRIT_SECT& syncres) : _syncres(syncres) { _syncres.Lock(); }
    inline ~TAKE_CRIT_SECT() { _syncres.Unlock(); }
};

//
// Base class for supporting non-delegating IUnknown for contained objects
//
struct INonDelegatingUnknown
{
    // *** IUnknown-like methods ***
    STDMETHOD(NonDelegatingQueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};

//
// Class definition for object
//

class UsdSampDevice :  public IStiUSD, public INonDelegatingUnknown
{
private:
    ULONG       m_cRef;
    BOOL        m_fValid;

    CRIT_SECT   m_cs;

    LPUNKNOWN   m_punkOuter;
    PSTIDEVICECONTROL   m_pDcb;
    CHAR        *m_pszDeviceNameA;
    HANDLE      m_DeviceDataHandle;
    DWORD       m_dwLastOperationError;
    DWORD       m_dwAsync ;
    HANDLE      m_hSignalEvent;
    HANDLE      m_hShutdownEvent;
    HANDLE      m_hThread;
    BOOL        m_EventSignalState;


    FILETIME    m_ftLastWriteTime;
    LARGE_INTEGER   m_dwLastHugeSize;

    GUID        m_guidLastEvent;

    BOOL inline IsValid(VOID) {
        return m_fValid;
    }

public:
    // *** IUnknown-like methods ***
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();


    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /*** IStiUSD methods ***/
    STDMETHOD(Initialize) (THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey)  ;
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps)  ;
    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus)  ;
    STDMETHOD(DeviceReset)(THIS )  ;
    STDMETHOD(Diagnostic)(THIS_ LPDIAG pBuffer)  ;
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData)   ;
    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError)  ;
    STDMETHOD(LockDevice) (THIS )  ;
    STDMETHOD(UnLockDevice) (THIS )  ;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent)  ;
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY   lpNotify)  ;
    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo);

    /****               ***/
    UsdSampDevice(LPUNKNOWN punkOuter);
    ~UsdSampDevice();

    VOID    RunNotifications(VOID);
    BOOL    IsChangeDetected(GUID    *pguidEvent,BOOL   fRefresh=TRUE);
};

typedef UsdSampDevice *PUsdSampDevice;

//
// Syncronization mechanisms
//
#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\private.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        private.h
*
*  VERSION:     1.0
*
*  DATE:        11/8/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Definitions for the wiautil.lib library, which should not be public.
*
*****************************************************************************/

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

class CImageStream : public IStream
{
public:
	CImageStream();
	~CImageStream();

    STDMETHOD(SetBuffer)(BYTE *pBuffer, INT iSize, SKIP_AMOUNT iSkipAmt = SKIP_OFF);
    
    // IUnknown 

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ISequentialStream

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

    // IStream

    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);

private:
    LONG                m_cRef;         // Reference count
    
    BYTE               *m_pBuffer;      // Buffer to use for reads and writes
    INT                 m_iSize;        // Size of the buffer
    INT                 m_iPosition;    // Current position in the buffer
    INT                 m_iOffset;      // Offset to apply to reads and writes
    BYTE                m_Header[sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)];
                                        // Location to store bmp file and info headers
};

#endif // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\pch.h ===
#include <windows.h>
#include <stddef.h>
#include <objbase.h>
#include <gdiplus.h>
#include <wiamindr.h>
#include "wiautil.h"
#include "private.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\wia\drivers\util\other.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    gdipconv.cpp

Abstract:

    Helper functions for using GDI+ to convert image formats

Author:

    DavePar

Revision History:


--*/

#include "pch.h"

/**************************************************************************\
* wiauGetDrvItemContext
\**************************************************************************/

HRESULT wiauGetDrvItemContext(BYTE *pWiasContext, VOID **ppItemCtx, IWiaDrvItem **ppDrvItem)
{
    HRESULT hr = S_OK;

    //
    // Locals
    //
    IWiaDrvItem *pWiaDrvItem = NULL;

    REQUIRE_ARGS(!pWiasContext || !ppItemCtx, hr, "wiauGetDrvItemContext");
    
    *ppItemCtx = NULL;
    if (ppDrvItem)
        *ppDrvItem = NULL;

    hr = wiasGetDrvItem(pWiasContext, &pWiaDrvItem);
    REQUIRE_SUCCESS(hr, "wiauGetDrvItemContext", "wiasGetDrvItem failed");

    hr = pWiaDrvItem->GetDeviceSpecContext((BYTE **) ppItemCtx);
    REQUIRE_SUCCESS(hr, "wiauGetDrvItemContext", "GetDeviceSpecContext failed");
    
    if (!*ppItemCtx)
    {
        wiauDbgError("wiauGetDrvItemContext", "Item context is null");
        hr = E_FAIL;
        goto Cleanup;
    }

    if (ppDrvItem)
    {
        *ppDrvItem = pWiaDrvItem;
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauSetImageItemSize
\**************************************************************************/

HRESULT wiauSetImageItemSize(BYTE *pWiasContext, LONG lWidth, LONG lHeight,
                             LONG lDepth, LONG lSize, PWSTR pwszExt)
{
    HRESULT  hr = S_OK;

    LONG lNewSize     = 0;
    LONG lWidthInBytes = 0;
    GUID guidFormatID  = GUID_NULL;
    BSTR bstrExt = NULL;

    LONG lNumProperties = 2;
    PROPVARIANT pv[3];
    PROPSPEC ps[3] = {{PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
                      {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
                      {PRSPEC_PROPID, WIA_IPA_FILENAME_EXTENSION}};

    //
    // Read the current format GUID
    //
    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &guidFormatID, NULL, TRUE);
    REQUIRE_SUCCESS(hr, "wiauSetImageItemSize", "wiasReadPropGuid failed");

    if (IsEqualCLSID(guidFormatID, WiaImgFmt_BMP) ||
        IsEqualCLSID(guidFormatID, WiaImgFmt_MEMORYBMP))
    {
        lNewSize = sizeof(BITMAPINFOHEADER);

        //
        // if this is a file, add file header to size
        //
        if (IsEqualCLSID(guidFormatID, WiaImgFmt_BMP))
        {
            lNewSize += sizeof(BITMAPFILEHEADER);
        }

        //
        // Calculate number of bytes per line, width must be
        // aligned to 4 byte boundary.
        //
        lWidthInBytes = ((lWidth * lDepth + 31) & ~31) / 8;

        //
        // Calculate image size
        //
        lNewSize += lWidthInBytes * lHeight;

        //
        // Set the extension property
        //
        if (pwszExt) {
            bstrExt = SysAllocString(L"BMP");
            REQUIRE_ALLOC(bstrExt, hr, "wiauSetImageItemSize");
        }
    }
    else
    {
        lNewSize = lSize;
        lWidthInBytes = 0;
        
        //
        // Set the extension property
        //
        if (pwszExt) {
            bstrExt = SysAllocString(pwszExt);
            REQUIRE_ALLOC(bstrExt, hr, "wiauSetImageItemSize");
        }
    }

    //
    // Initialize propvar's.  Then write the values.  Don't need to call
    // PropVariantClear when done, since no memory was allocated.
    //
    if (bstrExt)
        lNumProperties++;

    for (int i = 0; i < lNumProperties; i++) {
        PropVariantInit(&pv[i]);
    }

    pv[0].vt = VT_I4;
    pv[0].lVal = lNewSize;
    pv[1].vt = VT_I4;
    pv[1].lVal = lWidthInBytes;
    pv[2].vt = VT_BSTR;
    pv[2].bstrVal = bstrExt;

    //
    // Write WIA_IPA_ITEM_SIZE and WIA_IPA_BYTES_PER_LINE property values
    //

    hr = wiasWriteMultiple(pWiasContext, lNumProperties, ps, pv);
    REQUIRE_SUCCESS(hr, "wiauSetImageItemSize", "wiasWriteMultiple failed");

Cleanup:
    if (bstrExt)
        SysFreeString(bstrExt);

    return hr;
}

/**************************************************************************\
* wiauPropsInPropSpec
\**************************************************************************/

BOOL wiauPropsInPropSpec(LONG NumPropSpecs, const PROPSPEC *pPropSpecs,
                         int NumProps, PROPID *pProps)
{
    for (int count = 0; count < NumProps; count++)
        if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, pProps[count]))
            return TRUE;

    return FALSE;
}

/**************************************************************************\
* wiauPropInPropSpec
\**************************************************************************/

BOOL wiauPropInPropSpec(LONG NumPropSpecs, const PROPSPEC *pPropSpecs,
                        PROPID PropId, int *pIdx)
{
    if (pPropSpecs)
    {
        for (int count = 0; count < NumPropSpecs; count++)
            if (pPropSpecs[count].propid == PropId)
            {
                if (pIdx)
                    *pIdx = count;
                return TRUE;
            }
    }

    return FALSE;
}

/**************************************************************************\
* wiauGetValidFormats
\**************************************************************************/

HRESULT wiauGetValidFormats(IWiaMiniDrv *pDrv, BYTE *pWiasContext, LONG TymedValue,
                            int *pNumFormats, GUID **ppFormatArray)
{
    HRESULT hr = S_OK;

    LONG NumFi = 0;
    WIA_FORMAT_INFO *pFiArray = NULL;
    LONG lErrVal = 0;
    GUID *pFA = NULL;

    REQUIRE_ARGS(!pDrv || !ppFormatArray || !pNumFormats, hr, "wiauGetValidFormats");

    *ppFormatArray = NULL;
    *pNumFormats = 0;

    hr = pDrv->drvGetWiaFormatInfo(pWiasContext, 0, &NumFi, &pFiArray, &lErrVal);
    REQUIRE_SUCCESS(hr, "wiauGetValidFormats", "drvGetWiaFormatInfo failed");

    //
    // This will allocate more spots than necessary, but pNumFormats will be set correctly
    //
    pFA = new GUID[NumFi];
    REQUIRE_ALLOC(pFA, hr, "wiauGetValidFormats");

    for (int count = 0; count < NumFi; count++)
    {
        if (pFiArray[count].lTymed == TymedValue)
        {
            pFA[*pNumFormats] = pFiArray[count].guidFormatID;
            (*pNumFormats)++;
        }
    }

    *ppFormatArray = pFA;

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauGetResourceString
\**************************************************************************/
HRESULT wiauGetResourceString(HINSTANCE hInst, LONG lResourceID, BSTR *pbstrStr)
{
    DBG_FN("GetResourceString");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    INT iLen = 0;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");
    WCHAR wszTempStr[MAX_PATH] = L"";

    REQUIRE_ARGS(!pbstrStr, hr, "GetResourceString");
    *pbstrStr = NULL;

    //
    // Get the string from the resource
    //
    iLen = LoadString(hInst, lResourceID, tszTempStr, MAX_PATH);
    REQUIRE_FILEIO(iLen, hr, "GetResourceString", "LoadString failed");

    hr = wiauStrT2W(tszTempStr, wszTempStr, sizeof(wszTempStr));
    REQUIRE_SUCCESS(hr, "GetResourceString", "wiauStrT2W failed");

    //
    // Caller must free this allocated BSTR
    //
    *pbstrStr = SysAllocString(wszTempStr);
    REQUIRE_ALLOC(*pbstrStr, hr, "GetResourceString");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegOpenDataW
\**************************************************************************/
HRESULT wiauRegOpenDataW(HKEY hkeyAncestor, HKEY *phkeyDeviceData)
{
    DBG_FN("wiauRegOpenDataW");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;

    REQUIRE_ARGS(!hkeyAncestor || !phkeyDeviceData, hr, "wiauRegOpenDataW");

    lReturn = ::RegOpenKeyExW(hkeyAncestor, L"DeviceData", 0, KEY_READ, phkeyDeviceData);
    REQUIRE_WIN32(lReturn, hr, "wiauRegOpenDataW", "RegOpenKeyExW failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegOpenDataA
\**************************************************************************/
HRESULT wiauRegOpenDataA(HKEY hkeyAncestor, HKEY *phkeyDeviceData)
{
    DBG_FN("wiauRegOpenDataA");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;

    REQUIRE_ARGS(!hkeyAncestor || !phkeyDeviceData, hr, "wiauRegOpenDataA");

    lReturn = ::RegOpenKeyExA(hkeyAncestor, "DeviceData", 0, KEY_READ, phkeyDeviceData);
    REQUIRE_WIN32(lReturn, hr, "wiauRegOpenDataA", "RegOpenKeyExA failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegGetStrW
\****************************************************************